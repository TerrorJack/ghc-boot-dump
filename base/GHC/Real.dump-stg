
==================== Pre unarise: ====================
2018-03-16 15:56:01.978962824 UTC

GHC.Real.$p1Fractional
  :: forall a. GHC.Real.Fractional a => GHC.Num.Num a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_s1j3U]
        case v_s1j3U of {
          GHC.Real.C:Fractional v_s1j3W [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_s1j3W;
        };

GHC.Real./ :: forall a. GHC.Real.Fractional a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_s1j40]
        case v_s1j40 of {
          GHC.Real.C:Fractional _ [Occ=Dead]
                                v_s1j43 [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_s1j43;
        };

GHC.Real.recip :: forall a. GHC.Real.Fractional a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_s1j46]
        case v_s1j46 of {
          GHC.Real.C:Fractional _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_s1j4a [Occ=Once]
                                _ [Occ=Dead] ->
              v_s1j4a;
        };

GHC.Real.fromRational
  :: forall a. GHC.Real.Fractional a => GHC.Real.Rational -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_s1j4c]
        case v_s1j4c of {
          GHC.Real.C:Fractional _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_s1j4h [Occ=Once] ->
              v_s1j4h;
        };

GHC.Real.$p1Integral
  :: forall a. GHC.Real.Integral a => GHC.Real.Real a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLL),U(U,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1j4i]
        case v_s1j4i of {
          GHC.Real.C:Integral v_s1j4k [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j4k;
        };

GHC.Real.$p2Integral
  :: forall a. GHC.Real.Integral a => GHC.Enum.Enum a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLL),U(A,U,A,A,A,A,A,A,A)>] =
    [] \r [v_s1j4t]
        case v_s1j4t of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              v_s1j4w [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j4w;
        };

GHC.Real.quot :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLL),U(A,A,U,A,A,A,A,A,A)>] =
    [] \r [v_s1j4E]
        case v_s1j4E of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j4I [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j4I;
        };

GHC.Real.rem :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLL),U(A,A,A,U,A,A,A,A,A)>] =
    [] \r [v_s1j4P]
        case v_s1j4P of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j4U [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j4U;
        };

GHC.Real.div :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLL),U(A,A,A,A,U,A,A,A,A)>] =
    [] \r [v_s1j50]
        case v_s1j50 of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j56 [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j56;
        };

GHC.Real.mod :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLL),U(A,A,A,A,A,U,A,A,A)>] =
    [] \r [v_s1j5b]
        case v_s1j5b of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j5i [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j5i;
        };

GHC.Real.quotRem
  :: forall a. GHC.Real.Integral a => a -> a -> (a, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLL),U(A,A,A,A,A,A,U,A,A)>] =
    [] \r [v_s1j5m]
        case v_s1j5m of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j5u [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j5u;
        };

GHC.Real.divMod
  :: forall a. GHC.Real.Integral a => a -> a -> (a, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSL),U(A,A,A,A,A,A,A,U,A)>] =
    [] \r [v_s1j5x]
        case v_s1j5x of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j5G [Occ=Once]
                              _ [Occ=Dead] ->
              v_s1j5G;
        };

GHC.Real.toInteger
  :: forall a. GHC.Real.Integral a => a -> GHC.Integer.Type.Integer
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLS),U(A,A,A,A,A,A,A,A,U)>] =
    [] \r [v_s1j5I]
        case v_s1j5I of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j5S [Occ=Once] ->
              v_s1j5S;
        };

GHC.Real.$p1Real :: forall a. GHC.Real.Real a => GHC.Num.Num a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_s1j5T]
        case v_s1j5T of {
          GHC.Real.C:Real v_s1j5V [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
              v_s1j5V;
        };

GHC.Real.$p2Real :: forall a. GHC.Real.Real a => GHC.Classes.Ord a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_s1j5Y]
        case v_s1j5Y of {
          GHC.Real.C:Real _ [Occ=Dead] v_s1j61 [Occ=Once] _ [Occ=Dead] ->
              v_s1j61;
        };

GHC.Real.toRational
  :: forall a. GHC.Real.Real a => a -> GHC.Real.Rational
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_s1j63]
        case v_s1j63 of {
          GHC.Real.C:Real _ [Occ=Dead] _ [Occ=Dead] v_s1j67 [Occ=Once] ->
              v_s1j67;
        };

GHC.Real.$p1RealFrac
  :: forall a. GHC.Real.RealFrac a => GHC.Real.Real a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLL),U(U,A,A,A,A,A,A)>] =
    [] \r [v_s1j68]
        case v_s1j68 of {
          GHC.Real.C:RealFrac v_s1j6a [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j6a;
        };

GHC.Real.$p2RealFrac
  :: forall a. GHC.Real.RealFrac a => GHC.Real.Fractional a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLL),U(A,U,A,A,A,A,A)>] =
    [] \r [v_s1j6h]
        case v_s1j6h of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              v_s1j6k [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j6k;
        };

GHC.Real.properFraction
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> (b, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLL),U(A,A,U,A,A,A,A)>] =
    [] \r [v_s1j6q]
        case v_s1j6q of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j6u [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j6u;
        };

GHC.Real.truncate
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLL),U(A,A,A,U,A,A,A)>] =
    [] \r [v_s1j6z]
        case v_s1j6z of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j6E [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j6E;
        };

GHC.Real.round
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLL),U(A,A,A,A,U,A,A)>] =
    [] \r [v_s1j6I]
        case v_s1j6I of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j6O [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j6O;
        };

GHC.Real.ceiling
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSL),U(A,A,A,A,A,U,A)>] =
    [] \r [v_s1j6R]
        case v_s1j6R of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j6Y [Occ=Once]
                              _ [Occ=Dead] ->
              v_s1j6Y;
        };

GHC.Real.floor
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLS),U(A,A,A,A,A,A,U)>] =
    [] \r [v_s1j70]
        case v_s1j70 of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j78 [Occ=Once] ->
              v_s1j78;
        };

GHC.Real.$W:% [InlPrag=INLINE[2]]
  :: forall a. a -> a -> GHC.Real.Ratio a
[GblId[DataConWrapper],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>m,
 Unf=OtherCon []] =
    [] \r [dt_s1j79 dt_s1j7a]
        case dt_s1j79 of dt_s1j7b {
          __DEFAULT ->
              case dt_s1j7a of dt_s1j7c {
                __DEFAULT -> GHC.Real.:% [dt_s1j7b dt_s1j7c];
              };
        };

GHC.Real.$fOrdRatio_$s$c< [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1j7d w1_s1j7e]
        case w_s1j7d of {
          GHC.Real.:% ww1_s1j7g [Occ=Once] ww2_s1j7h [Occ=Once] ->
              case w1_s1j7e of {
                GHC.Real.:% ww4_s1j7j [Occ=Once] ww5_s1j7k [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1j7j ww2_s1j7h
                    of
                    sat_s1j7m
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1j7g ww5_s1j7k
                          of
                          sat_s1j7l
                          { __DEFAULT ->
                                case
                                    GHC.Integer.Type.ltInteger# sat_s1j7l sat_s1j7m
                                of
                                wild_s1j7n
                                { __DEFAULT -> tagToEnum# [wild_s1j7n];
                                };
                          };
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$c<= [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1j7o w1_s1j7p]
        case w_s1j7o of {
          GHC.Real.:% ww1_s1j7r [Occ=Once] ww2_s1j7s [Occ=Once] ->
              case w1_s1j7p of {
                GHC.Real.:% ww4_s1j7u [Occ=Once] ww5_s1j7v [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1j7u ww2_s1j7s
                    of
                    sat_s1j7x
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1j7r ww5_s1j7v
                          of
                          sat_s1j7w
                          { __DEFAULT ->
                                case
                                    GHC.Integer.Type.leInteger# sat_s1j7w sat_s1j7x
                                of
                                wild_s1j7y
                                { __DEFAULT -> tagToEnum# [wild_s1j7y];
                                };
                          };
                    };
              };
        };

GHC.Real.$w$s$ccompare [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Types.Ordering
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1j7z ww1_s1j7A ww2_s1j7B ww3_s1j7C]
        case GHC.Integer.Type.eqInteger# ww_s1j7z ww2_s1j7B of wild_s1j7D {
          __DEFAULT ->
              let-no-escape {
                $j_s1j7E [Occ=Once*T[0], Dmd=<L,1*U>] :: GHC.Types.Ordering
                [LclId[JoinId(0)], Unf=OtherCon []] =
                    [ww_s1j7z ww1_s1j7A ww2_s1j7B ww3_s1j7C] \r []
                        case
                            GHC.Integer.Type.timesInteger ww2_s1j7B ww1_s1j7A
                        of
                        sat_s1j7G
                        { __DEFAULT ->
                              case
                                  GHC.Integer.Type.timesInteger ww_s1j7z ww3_s1j7C
                              of
                              sat_s1j7F
                              { __DEFAULT ->
                                    case GHC.Integer.Type.leInteger# sat_s1j7F sat_s1j7G of {
                                      __DEFAULT -> GHC.Types.GT [];
                                      1# -> GHC.Types.LT [];
                                    };
                              };
                        };
              } in 
                case wild_s1j7D of {
                  __DEFAULT -> $j_s1j7E;
                  1# ->
                      case GHC.Integer.Type.eqInteger# ww1_s1j7A ww3_s1j7C of {
                        __DEFAULT -> $j_s1j7E;
                        1# -> GHC.Types.EQ [];
                      };
                };
        };

GHC.Real.$fEnumRatio_$s$ccompare [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1j7K w1_s1j7L]
        case w_s1j7K of {
          GHC.Real.:% ww1_s1j7N [Occ=Once] ww2_s1j7O [Occ=Once] ->
              case w1_s1j7L of {
                GHC.Real.:% ww4_s1j7Q [Occ=Once] ww5_s1j7R [Occ=Once] ->
                    GHC.Real.$w$s$ccompare ww1_s1j7N ww2_s1j7O ww4_s1j7Q ww5_s1j7R;
              };
        };

GHC.Real.$fEnumRatio_$s$c>=
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [x_s1j7S y_s1j7T]
        case x_s1j7S of {
          GHC.Real.:% ww1_s1j7V [Occ=Once] ww2_s1j7W [Occ=Once] ->
              case y_s1j7T of {
                GHC.Real.:% ww4_s1j7Y [Occ=Once] ww5_s1j7Z [Occ=Once] ->
                    case
                        GHC.Real.$w$s$ccompare ww1_s1j7V ww2_s1j7W ww4_s1j7Y ww5_s1j7Z
                    of
                    { __DEFAULT -> GHC.Types.True [];
                      GHC.Types.LT -> GHC.Types.False [];
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$c>
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [x_s1j81 y_s1j82]
        case x_s1j81 of {
          GHC.Real.:% ww1_s1j84 [Occ=Once] ww2_s1j85 [Occ=Once] ->
              case y_s1j82 of {
                GHC.Real.:% ww4_s1j87 [Occ=Once] ww5_s1j88 [Occ=Once] ->
                    case
                        GHC.Real.$w$s$ccompare ww1_s1j84 ww2_s1j85 ww4_s1j87 ww5_s1j88
                    of
                    { __DEFAULT -> GHC.Types.False [];
                      GHC.Types.GT -> GHC.Types.True [];
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$cmin
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_s1j8a y_s1j8b]
        case x_s1j8a of ww_s1j8c {
          GHC.Real.:% ww1_s1j8d [Occ=Once] ww2_s1j8e [Occ=Once] ->
              case y_s1j8b of ww3_s1j8f {
                GHC.Real.:% ww4_s1j8g [Occ=Once] ww5_s1j8h [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1j8g ww2_s1j8e
                    of
                    sat_s1j8j
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1j8d ww5_s1j8h
                          of
                          sat_s1j8i
                          { __DEFAULT ->
                                case GHC.Integer.Type.leInteger# sat_s1j8i sat_s1j8j of {
                                  __DEFAULT -> ww3_s1j8f;
                                  1# -> ww_s1j8c;
                                };
                          };
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$cmax
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_s1j8l y_s1j8m]
        case x_s1j8l of ww_s1j8n {
          GHC.Real.:% ww1_s1j8o [Occ=Once] ww2_s1j8p [Occ=Once] ->
              case y_s1j8m of ww3_s1j8q {
                GHC.Real.:% ww4_s1j8r [Occ=Once] ww5_s1j8s [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1j8r ww2_s1j8p
                    of
                    sat_s1j8u
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1j8o ww5_s1j8s
                          of
                          sat_s1j8t
                          { __DEFAULT ->
                                case GHC.Integer.Type.leInteger# sat_s1j8t sat_s1j8u of {
                                  __DEFAULT -> ww_s1j8n;
                                  1# -> ww3_s1j8q;
                                };
                          };
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$cnegate
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1j8w]
        case ds_s1j8w of {
          GHC.Real.:% x_s1j8y [Occ=Once] y_s1j8z [Occ=Once] ->
              case GHC.Integer.Type.negateInteger x_s1j8y of dt_s1j8A {
                __DEFAULT -> GHC.Real.:% [dt_s1j8A y_s1j8z];
              };
        };

GHC.Real.$fFractionalRatio_$s$cabs
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1j8B]
        case ds_s1j8B of {
          GHC.Real.:% x_s1j8D [Occ=Once] y_s1j8E [Occ=Once] ->
              case GHC.Integer.Type.absInteger x_s1j8D of dt_s1j8F {
                __DEFAULT -> GHC.Real.:% [dt_s1j8F y_s1j8E];
              };
        };

sat_s1j8G :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s1j8H :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1j8G GHC.Types.[]];

GHC.Real.$fEnumRatio1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s1j8H;

GHC.Real.$fFractionalRatio_$s$csignum
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SL),1*U(U,A)>m, Unf=OtherCon []] =
    [] \r [ds_s1j8I]
        case ds_s1j8I of {
          GHC.Real.:% x_s1j8K [Occ=Once] _ [Occ=Dead] ->
              case GHC.Integer.Type.signumInteger x_s1j8K of dt_s1j8M {
                __DEFAULT -> GHC.Real.:% [dt_s1j8M GHC.Real.$fEnumRatio1];
              };
        };

GHC.Real.$fFractionalRatio_$s$cfromInteger
  :: GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [x_s1j8N]
        case x_s1j8N of dt_s1j8O {
          __DEFAULT -> GHC.Real.:% [dt_s1j8O GHC.Real.$fEnumRatio1];
        };

GHC.Real.$fRealInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real GHC.Integer.Type.Integer
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Num.$fNumInteger
                                    GHC.Integer.Type.$fOrdInteger
                                    GHC.Real.$fFractionalRatio_$s$cfromInteger];

GHC.Real.$fIntegralInt_$ctoInteger
  :: GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1j8P]
        case ds_s1j8P of {
          GHC.Types.I# i_s1j8R [Occ=Once] ->
              GHC.Integer.Type.smallInteger i_s1j8R;
        };

GHC.Real.$fEnumRatio_$ctoRational
  :: GHC.Types.Int -> GHC.Real.Rational
[GblId, Arity=1, Str=<S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [x_s1j8S]
        case x_s1j8S of {
          GHC.Types.I# i_s1j8U [Occ=Once] ->
              case GHC.Integer.Type.smallInteger i_s1j8U of dt_s1j8V {
                __DEFAULT -> GHC.Real.:% [dt_s1j8V GHC.Real.$fEnumRatio1];
              };
        };

GHC.Real.$fRealInt [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real GHC.Types.Int
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Num.$fNumInt
                                    GHC.Classes.$fOrdInt
                                    GHC.Real.$fEnumRatio_$ctoRational];

GHC.Real.$fIntegralWord_$ctoInteger
  :: GHC.Types.Word -> GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1j8W]
        case ds_s1j8W of {
          GHC.Types.W# x#_s1j8Y [Occ=Once] ->
              GHC.Integer.Type.wordToInteger x#_s1j8Y;
        };

GHC.Real.$fIntegralInteger_$ctoInteger
  :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [n_s1j8Z] n_s1j8Z;

GHC.Real.$fEqRatio_$s$c== [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1j90 w1_s1j91]
        case w_s1j90 of {
          GHC.Real.:% ww1_s1j93 [Occ=Once] ww2_s1j94 [Occ=Once] ->
              case w1_s1j91 of {
                GHC.Real.:% ww4_s1j96 [Occ=Once] ww5_s1j97 [Occ=Once] ->
                    case GHC.Integer.Type.eqInteger# ww1_s1j93 ww4_s1j96 of {
                      __DEFAULT -> GHC.Types.False [];
                      1# ->
                          case
                              GHC.Integer.Type.eqInteger# ww2_s1j94 ww5_s1j97
                          of
                          wild1_s1j99
                          { __DEFAULT -> tagToEnum# [wild1_s1j99];
                          };
                    };
              };
        };

GHC.Real.$fEqRatio_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1j9a w1_s1j9b w2_s1j9c]
        case w1_s1j9b of {
          GHC.Real.:% ww1_s1j9e [Occ=Once] ww2_s1j9f [Occ=Once] ->
              case w2_s1j9c of {
                GHC.Real.:% ww4_s1j9h [Occ=Once] ww5_s1j9i [Occ=Once] ->
                    case GHC.Classes.== w_s1j9a ww1_s1j9e ww4_s1j9h of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> GHC.Classes.== w_s1j9a ww2_s1j9f ww5_s1j9i;
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$c/= [InlPrag=INLINE (sat-args=2)]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1j9k eta1_s1j9l]
        case eta_s1j9k of {
          GHC.Real.:% a1_s1j9n [Occ=Once] a2_s1j9o [Occ=Once] ->
              case eta1_s1j9l of {
                GHC.Real.:% b1_s1j9q [Occ=Once] b2_s1j9r [Occ=Once] ->
                    case GHC.Integer.Type.eqInteger# a1_s1j9n b1_s1j9q of {
                      __DEFAULT -> GHC.Types.True [];
                      1# ->
                          case GHC.Integer.Type.eqInteger# a2_s1j9o b2_s1j9r of {
                            __DEFAULT -> GHC.Types.True [];
                            1# -> GHC.Types.False [];
                          };
                    };
              };
        };

GHC.Real.$fEqRatio_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_s1j9u eta_s1j9v eta1_s1j9w]
        case eta_s1j9v of {
          GHC.Real.:% ww1_s1j9y [Occ=Once] ww2_s1j9z [Occ=Once] ->
              case eta1_s1j9w of {
                GHC.Real.:% ww4_s1j9B [Occ=Once] ww5_s1j9C [Occ=Once] ->
                    case GHC.Classes.== $dEq_s1j9u ww1_s1j9y ww4_s1j9B of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True ->
                          case GHC.Classes.== $dEq_s1j9u ww2_s1j9z ww5_s1j9C of {
                            GHC.Types.False -> GHC.Types.True [];
                            GHC.Types.True -> GHC.Types.False [];
                          };
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$fEqRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Real.$fEqRatio_$s$c==
                                     GHC.Real.$fOrdRatio_$s$c/=];

GHC.Real.$fEqRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Real.Ratio a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s1j9F]
        let {
          sat_s1j9H [Occ=Once]
            :: GHC.Real.Ratio a_a1eDJ
               -> GHC.Real.Ratio a_a1eDJ -> GHC.Types.Bool
          [LclId] =
              [$dEq_s1j9F] \r [eta_B2 eta_B1]
                  GHC.Real.$fEqRatio_$c/= $dEq_s1j9F eta_B2 eta_B1; } in
        let {
          sat_s1j9G [Occ=Once]
            :: GHC.Real.Ratio a_a1eDJ
               -> GHC.Real.Ratio a_a1eDJ -> GHC.Types.Bool
          [LclId] =
              [$dEq_s1j9F] \r [eta_B2 eta_B1]
                  GHC.Real.$fEqRatio_$c== $dEq_s1j9F eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s1j9G sat_s1j9H];

GHC.Real.$fOrdRatio_$s$fOrdRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [GHC.Real.$fOrdRatio_$s$fEqRatio
                                      GHC.Real.$fEnumRatio_$s$ccompare
                                      GHC.Real.$fOrdRatio_$s$c<
                                      GHC.Real.$fEnumRatio_$s$c<=
                                      GHC.Real.$fOrdRatio_$s$c>
                                      GHC.Real.$fEnumRatio_$s$c>=
                                      GHC.Real.$fOrdRatio_$s$cmax
                                      GHC.Real.$fOrdRatio_$s$cmin];

GHC.Real.$fOrdRatio_$cp1Ord
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Classes.Eq (GHC.Real.Ratio a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1j9I]
        let {
          sat_s1j9L [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_a1eJ2
          [LclId] =
              [$dIntegral_s1j9I] \u []
                  case GHC.Real.$p1Integral $dIntegral_s1j9I of sat_s1j9J {
                    __DEFAULT ->
                        case GHC.Real.$p2Real sat_s1j9J of sat_s1j9K {
                          __DEFAULT -> GHC.Classes.$p1Ord sat_s1j9K;
                        };
                  };
        } in  GHC.Real.$fEqRatio sat_s1j9L;

GHC.Real.even1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

GHC.Real.$dmfloor
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U,U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1j9M eta_s1j9N eta1_s1j9O]
        let {
          ds_s1j9P [Dmd=<L,U(1*U,1*U)>] :: (b_a1eDd, a_a1dNs)
          [LclId] =
              [$dRealFrac_s1j9M eta_s1j9N eta1_s1j9O] \u []
                  GHC.Real.properFraction $dRealFrac_s1j9M eta_s1j9N eta1_s1j9O;
        } in 
          case
              GHC.Real.$p1RealFrac $dRealFrac_s1j9M
          of
          $dReal_s1j9Q [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
          { __DEFAULT ->
                let {
                  sat_s1j9X [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [$dReal_s1j9Q] \u []
                          case GHC.Real.$p1Real $dReal_s1j9Q of sat_s1j9W {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1j9W GHC.Real.even1;
                          }; } in
                let {
                  sat_s1j9V [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [ds_s1j9P] \u []
                          case ds_s1j9P of {
                            (,) _ [Occ=Dead] r_s1j9U [Occ=Once] -> r_s1j9U;
                          };
                } in 
                  case GHC.Real.$p2Real $dReal_s1j9Q of sat_s1j9R {
                    __DEFAULT ->
                        case GHC.Classes.< sat_s1j9R sat_s1j9V sat_s1j9X of {
                          GHC.Types.False ->
                              case ds_s1j9P of {
                                (,) n_s1ja0 [Occ=Once] _ [Occ=Dead] -> n_s1ja0;
                              };
                          GHC.Types.True ->
                              case
                                  GHC.Real.$p1Integral eta_s1j9N
                              of
                              $dReal1_s1ja2 [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                              { __DEFAULT ->
                                    case
                                        GHC.Real.$p1Real $dReal1_s1ja2
                                    of
                                    $dNum_s1ja3 [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                    { __DEFAULT ->
                                          let {
                                            sat_s1ja8 [Occ=Once] :: b_a1eDd
                                            [LclId] =
                                                [$dNum_s1ja3] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_s1ja3 GHC.Real.$fEnumRatio1; } in
                                          let {
                                            sat_s1ja7 [Occ=Once] :: b_a1eDd
                                            [LclId] =
                                                [ds_s1j9P] \u []
                                                    case ds_s1j9P of {
                                                      (,) n_s1ja5 [Occ=Once] _ [Occ=Dead] ->
                                                          n_s1ja5;
                                                    };
                                          } in  GHC.Num.- $dNum_s1ja3 sat_s1ja7 sat_s1ja8;
                                    };
                              };
                        };
                  };
          };

GHC.Real.$dmceiling
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,A,1*C1(C1(U)),A,A,A),A),A,1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U,U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1ja9 eta_s1jaa eta1_s1jab]
        let {
          ds_s1jac [Dmd=<L,U(1*U,1*U)>] :: (b_a1eCG, a_a1dNs)
          [LclId] =
              [$dRealFrac_s1ja9 eta_s1jaa eta1_s1jab] \u []
                  GHC.Real.properFraction $dRealFrac_s1ja9 eta_s1jaa eta1_s1jab;
        } in 
          case
              GHC.Real.$p1RealFrac $dRealFrac_s1ja9
          of
          $dReal_s1jad [Dmd=<S(LS(LLLLC(C(S))LLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,A,1*C1(C1(U)),A,A,A),A)>]
          { __DEFAULT ->
                let {
                  sat_s1jak [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [$dReal_s1jad] \u []
                          case GHC.Real.$p1Real $dReal_s1jad of sat_s1jaj {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1jaj GHC.Real.even1;
                          }; } in
                let {
                  sat_s1jai [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [ds_s1jac] \u []
                          case ds_s1jac of {
                            (,) _ [Occ=Dead] r_s1jah [Occ=Once] -> r_s1jah;
                          };
                } in 
                  case GHC.Real.$p2Real $dReal_s1jad of sat_s1jae {
                    __DEFAULT ->
                        case GHC.Classes.> sat_s1jae sat_s1jai sat_s1jak of {
                          GHC.Types.False ->
                              case ds_s1jac of {
                                (,) n_s1jan [Occ=Once] _ [Occ=Dead] -> n_s1jan;
                              };
                          GHC.Types.True ->
                              case
                                  GHC.Real.$p1Integral eta_s1jaa
                              of
                              $dReal1_s1jap [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
                              { __DEFAULT ->
                                    case
                                        GHC.Real.$p1Real $dReal1_s1jap
                                    of
                                    $dNum_s1jaq [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                                    { __DEFAULT ->
                                          let {
                                            sat_s1jav [Occ=Once] :: b_a1eCG
                                            [LclId] =
                                                [$dNum_s1jaq] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_s1jaq GHC.Real.$fEnumRatio1; } in
                                          let {
                                            sat_s1jau [Occ=Once] :: b_a1eCG
                                            [LclId] =
                                                [ds_s1jac] \u []
                                                    case ds_s1jac of {
                                                      (,) n_s1jas [Occ=Once] _ [Occ=Dead] ->
                                                          n_s1jas;
                                                    };
                                          } in  GHC.Num.+ $dNum_s1jaq sat_s1jau sat_s1jav;
                                    };
                              };
                        };
                  };
          };

GHC.Real.$dmtruncate [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S(SL)))LLLL),1*U(A,A,1*C1(C1(U(1*U,A))),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1jaw $dIntegral_s1jax x_s1jay]
        case
            GHC.Real.properFraction $dRealFrac_s1jaw $dIntegral_s1jax x_s1jay
        of
        { (,) m_s1jaA [Occ=Once] _ [Occ=Dead] -> m_s1jaA;
        };

GHC.Real.$dmrecip [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Real.Fractional a => a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LL),U(1*U(A,A,A,A,A,A,1*C1(U)),1*C1(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_s1jaC eta_s1jaD]
        let {
          sat_s1jaF [Occ=Once] :: a_a1dNK
          [LclId] =
              [$dFractional_s1jaC] \u []
                  case GHC.Real.$p1Fractional $dFractional_s1jaC of sat_s1jaE {
                    __DEFAULT -> GHC.Num.fromInteger sat_s1jaE GHC.Real.$fEnumRatio1;
                  };
        } in  GHC.Real./ $dFractional_s1jaC sat_s1jaF eta_s1jaD;

GHC.Real.$dm/ [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Fractional a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLC(C(S))LLLL)LLL),U(1*U(A,A,1*C1(C1(U)),A,A,A,A),A,1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_s1jaG eta_s1jaH eta1_s1jaI]
        let {
          sat_s1jaK [Occ=Once] :: a_a1dNK
          [LclId] =
              [$dFractional_s1jaG eta1_s1jaI] \u []
                  GHC.Real.recip $dFractional_s1jaG eta1_s1jaI;
        } in 
          case GHC.Real.$p1Fractional $dFractional_s1jaG of sat_s1jaJ {
            __DEFAULT -> GHC.Num.* sat_s1jaJ eta_s1jaH sat_s1jaK;
          };

GHC.Real.$dmdivMod
  :: forall a. GHC.Real.Integral a => a -> a -> (a, a)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,1*C1(C1(U(U,U))),A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jaL eta_s1jaM eta1_s1jaN]
        case
            GHC.Real.$p1Integral $dIntegral_s1jaL
        of
        $dReal_s1jaO [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jaP [Dmd=<L,U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U))>]
                  :: GHC.Num.Num a_a1dNO
                [LclId] =
                    [$dReal_s1jaO] \u [] GHC.Real.$p1Real $dReal_s1jaO; } in
              let {
                ds_s1jaQ [Dmd=<L,U(1*U(U,U),1*U,1*U)>]
                  :: ((a_a1dNO, a_a1dNO), a_a1dNO, a_a1dNO)
                [LclId] =
                    [$dIntegral_s1jaL eta_s1jaM eta1_s1jaN] \u []
                        case
                            GHC.Real.quotRem $dIntegral_s1jaL eta_s1jaM eta1_s1jaN
                        of
                        wild_s1jaR
                        { (,) q_s1jaS [Occ=Once] r_s1jaT [Occ=Once] ->
                              (,,) [wild_s1jaR q_s1jaS r_s1jaT];
                        }; } in
              let {
                r_s1jaU :: a_a1dNO
                [LclId] =
                    [ds_s1jaQ] \u []
                        case ds_s1jaQ of {
                          (,,) _ [Occ=Dead] _ [Occ=Dead] r1_s1jaY [Occ=Once] -> r1_s1jaY;
                        }; } in
              let {
                sat_s1jb3 [Occ=Once] :: a_a1dNO
                [LclId] =
                    [eta1_s1jaN $dNum_s1jaP] \u []
                        let {
                          sat_s1jb2 [Occ=Once] :: a_a1dNO
                          [LclId] =
                              [eta1_s1jaN $dNum_s1jaP] \u []
                                  GHC.Num.signum $dNum_s1jaP eta1_s1jaN;
                        } in  GHC.Num.negate $dNum_s1jaP sat_s1jb2; } in
              let {
                sat_s1jb1 [Occ=Once] :: a_a1dNO
                [LclId] =
                    [$dNum_s1jaP r_s1jaU] \u [] GHC.Num.signum $dNum_s1jaP r_s1jaU;
              } in 
                case GHC.Real.$p2Real $dReal_s1jaO of sat_s1jaZ {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_s1jaZ of sat_s1jb0 {
                        __DEFAULT ->
                            case GHC.Classes.== sat_s1jb0 sat_s1jb1 sat_s1jb3 of {
                              GHC.Types.False ->
                                  case ds_s1jaQ of {
                                    (,,) qr_s1jb6 [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> qr_s1jb6;
                                  };
                              GHC.Types.True ->
                                  let {
                                    sat_s1jbg [Occ=Once] :: a_a1dNO
                                    [LclId] =
                                        [eta1_s1jaN $dNum_s1jaP r_s1jaU] \u []
                                            GHC.Num.+ $dNum_s1jaP r_s1jaU eta1_s1jaN; } in
                                  let {
                                    sat_s1jbf [Occ=Once] :: a_a1dNO
                                    [LclId] =
                                        [$dNum_s1jaP ds_s1jaQ] \u []
                                            let {
                                              sat_s1jbe [Occ=Once] :: a_a1dNO
                                              [LclId] =
                                                  [$dNum_s1jaP] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s1jaP GHC.Real.$fEnumRatio1; } in
                                            let {
                                              sat_s1jbd [Occ=Once] :: a_a1dNO
                                              [LclId] =
                                                  [ds_s1jaQ] \u []
                                                      case ds_s1jaQ of {
                                                        (,,) _ [Occ=Dead]
                                                             q_s1jbb [Occ=Once]
                                                             _ [Occ=Dead] ->
                                                            q_s1jbb;
                                                      };
                                            } in  GHC.Num.- $dNum_s1jaP sat_s1jbd sat_s1jbe;
                                  } in  (,) [sat_s1jbf sat_s1jbg];
                            };
                      };
                };
        };

GHC.Real.$dmmod [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(S(LS)))L),1*U(A,A,A,A,A,A,A,1*C1(C1(U(A,1*U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jbh n_s1jbi d_s1jbj]
        case GHC.Real.divMod $dIntegral_s1jbh n_s1jbi d_s1jbj of {
          (,) _ [Occ=Dead] r_s1jbm [Occ=Once] -> r_s1jbm;
        };

GHC.Real.$dmdiv [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(S(SL)))L),1*U(A,A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jbn n_s1jbo d_s1jbp]
        case GHC.Real.divMod $dIntegral_s1jbn n_s1jbo d_s1jbp of {
          (,) q_s1jbr [Occ=Once] _ [Occ=Dead] -> q_s1jbr;
        };

GHC.Real.$dmrem [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(LS)))LL),1*U(A,A,A,A,A,A,1*C1(C1(U(A,1*U))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jbt n_s1jbu d_s1jbv]
        case GHC.Real.quotRem $dIntegral_s1jbt n_s1jbu d_s1jbv of {
          (,) _ [Occ=Dead] r_s1jby [Occ=Once] -> r_s1jby;
        };

GHC.Real.$dmquot [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))LL),1*U(A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jbz n_s1jbA d_s1jbB]
        case GHC.Real.quotRem $dIntegral_s1jbz n_s1jbA d_s1jbB of {
          (,) q_s1jbD [Occ=Once] _ [Occ=Dead] -> q_s1jbD;
        };

GHC.Real.divZeroError [InlPrag=NOINLINE] :: forall a. a
[GblId, Str=x] =
    [] \u [] raise# [GHC.Exception.divZeroException];

GHC.Real.$fIntegralInt1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

GHC.Real.$fIntegralInt_$cmod [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1jbF w1_s1jbG]
        case w1_s1jbG of {
          GHC.Types.I# ww1_s1jbI [Occ=Once!] ->
              case ww1_s1jbI of wild_s1jbJ {
                __DEFAULT ->
                    case w_s1jbF of {
                      GHC.Types.I# x_s1jbL [Occ=Once] ->
                          case GHC.Classes.modInt# x_s1jbL wild_s1jbJ of ww2_s1jbM {
                            __DEFAULT -> GHC.Types.I# [ww2_s1jbM];
                          };
                    };
                -1# -> GHC.Real.$fIntegralInt1;
                0# -> GHC.Real.divZeroError;
              };
        };

GHC.Real.$fIntegralInt_$crem
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [a_s1jbO b_s1jbP]
        case b_s1jbP of {
          GHC.Types.I# x_s1jbR [Occ=Once!] ->
              case x_s1jbR of wild1_s1jbS {
                __DEFAULT ->
                    case a_s1jbO of {
                      GHC.Types.I# x1_s1jbU [Occ=Once] ->
                          case remInt# [x1_s1jbU wild1_s1jbS] of wild3_s1jbV {
                            __DEFAULT -> GHC.Types.I# [wild3_s1jbV];
                          };
                    };
                -1# -> GHC.Real.$fIntegralInt1;
                0# -> GHC.Real.divZeroError;
              };
        };

GHC.Real.$fIntegralInteger_$cquot [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1jbW eta1_s1jbX]
        case GHC.Integer.Type.eqInteger# eta1_s1jbX GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.quotInteger eta_s1jbW eta1_s1jbX;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$crem [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1jbZ eta1_s1jc0]
        case GHC.Integer.Type.eqInteger# eta1_s1jc0 GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.remInteger eta_s1jbZ eta1_s1jc0;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cdiv [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1jc2 eta1_s1jc3]
        case GHC.Integer.Type.eqInteger# eta1_s1jc3 GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.divInteger eta_s1jc2 eta1_s1jc3;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cmod [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1jc5 eta1_s1jc6]
        case GHC.Integer.Type.eqInteger# eta1_s1jc6 GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.modInteger eta_s1jc5 eta1_s1jc6;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cquotRem [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
[GblId, Arity=2, Str=<S,1*U><S,U>m, Unf=OtherCon []] =
    [] \r [eta_s1jc8 eta1_s1jc9]
        case GHC.Integer.Type.eqInteger# eta1_s1jc9 GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.quotRemInteger eta_s1jc8 eta1_s1jc9 of {
                (#,#) ipv_s1jcc [Occ=Once] ipv1_s1jcd [Occ=Once] ->
                    (,) [ipv_s1jcc ipv1_s1jcd];
              };
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cdivMod [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
[GblId, Arity=2, Str=<S,1*U><S,U>m, Unf=OtherCon []] =
    [] \r [eta_s1jce eta1_s1jcf]
        case GHC.Integer.Type.eqInteger# eta1_s1jcf GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.divModInteger eta_s1jce eta1_s1jcf of {
                (#,#) ipv_s1jci [Occ=Once] ipv1_s1jcj [Occ=Once] ->
                    (,) [ipv_s1jci ipv1_s1jcj];
              };
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Integral GHC.Integer.Type.Integer
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Integral! [GHC.Real.$fRealInteger
                                        GHC.Enum.$fEnumInteger
                                        GHC.Real.$fIntegralInteger_$cquot
                                        GHC.Real.$fIntegralInteger_$crem
                                        GHC.Real.$fIntegralInteger_$cdiv
                                        GHC.Real.$fIntegralInteger_$cmod
                                        GHC.Real.$fIntegralInteger_$cquotRem
                                        GHC.Real.$fIntegralInteger_$cdivMod
                                        GHC.Real.$fIntegralInteger_$ctoInteger];

GHC.Real.$fIntegralWord_$cquot
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1jck y_s1jcl]
        case ds_s1jck of {
          GHC.Types.W# x#_s1jcn [Occ=Once] ->
              case y_s1jcl of {
                GHC.Types.W# y#_s1jcp [Occ=Once!] ->
                    case y#_s1jcp of wild2_s1jcq {
                      __DEFAULT ->
                          case quotWord# [x#_s1jcn wild2_s1jcq] of wild3_s1jcr {
                            __DEFAULT -> GHC.Types.W# [wild3_s1jcr];
                          };
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralWord_$crem
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1jcs y_s1jct]
        case ds_s1jcs of {
          GHC.Types.W# x#_s1jcv [Occ=Once] ->
              case y_s1jct of {
                GHC.Types.W# y#_s1jcx [Occ=Once!] ->
                    case y#_s1jcx of wild2_s1jcy {
                      __DEFAULT ->
                          case remWord# [x#_s1jcv wild2_s1jcy] of wild3_s1jcz {
                            __DEFAULT -> GHC.Types.W# [wild3_s1jcz];
                          };
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralWord_$cquotRem
  :: GHC.Types.Word
     -> GHC.Types.Word -> (GHC.Types.Word, GHC.Types.Word)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1jcA y_s1jcB]
        case ds_s1jcA of {
          GHC.Types.W# x#_s1jcD [Occ=Once] ->
              case y_s1jcB of {
                GHC.Types.W# y#_s1jcF [Occ=Once!] ->
                    case y#_s1jcF of wild2_s1jcG {
                      __DEFAULT ->
                          case quotRemWord# [x#_s1jcD wild2_s1jcG] of {
                            (#,#) ipv_s1jcI [Occ=Once] ipv1_s1jcJ [Occ=Once] ->
                                let {
                                  sat_s1jcL [Occ=Once] :: GHC.Types.Word
                                  [LclId] =
                                      CCCS GHC.Types.W#! [ipv1_s1jcJ]; } in
                                let {
                                  sat_s1jcK [Occ=Once] :: GHC.Types.Word
                                  [LclId] =
                                      CCCS GHC.Types.W#! [ipv_s1jcI];
                                } in  (,) [sat_s1jcK sat_s1jcL];
                          };
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralWord_$cdivMod
  :: GHC.Types.Word
     -> GHC.Types.Word -> (GHC.Types.Word, GHC.Types.Word)
[GblId, Arity=2, Str=<S,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [ds_s1jcM y_s1jcN]
        case ds_s1jcM of {
          GHC.Types.W# x#_s1jcP ->
              case y_s1jcN of {
                GHC.Types.W# y#_s1jcR [Occ=Once!] ->
                    case y#_s1jcR of wild2_s1jcS {
                      __DEFAULT ->
                          let {
                            sat_s1jcW [Occ=Once] :: GHC.Types.Word
                            [LclId] =
                                [x#_s1jcP wild2_s1jcS] \u []
                                    case remWord# [x#_s1jcP wild2_s1jcS] of wild3_s1jcV {
                                      __DEFAULT -> GHC.Types.W# [wild3_s1jcV];
                                    }; } in
                          let {
                            sat_s1jcU [Occ=Once] :: GHC.Types.Word
                            [LclId] =
                                [x#_s1jcP wild2_s1jcS] \u []
                                    case quotWord# [x#_s1jcP wild2_s1jcS] of wild3_s1jcT {
                                      __DEFAULT -> GHC.Types.W# [wild3_s1jcT];
                                    };
                          } in  (,) [sat_s1jcU sat_s1jcW];
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.ratioZeroDenominatorError [InlPrag=NOINLINE]
  :: forall a. a
[GblId, Str=x] =
    [] \u [] raise# [GHC.Exception.ratioZeroDenomException];

GHC.Real.$fFractionalRatio_$s$crecip [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_s1jcX]
        case w_s1jcX of {
          GHC.Real.:% ww1_s1jcZ ww2_s1jd0 [Occ=Once*] ->
              case GHC.Integer.Type.eqInteger# ww1_s1jcZ GHC.Real.even1 of {
                __DEFAULT ->
                    case GHC.Integer.Type.ltInteger# ww1_s1jcZ GHC.Real.even1 of {
                      __DEFAULT -> GHC.Real.:% [ww2_s1jd0 ww1_s1jcZ];
                      1# ->
                          case GHC.Integer.Type.negateInteger ww2_s1jd0 of dt_s1jd3 {
                            __DEFAULT ->
                                case GHC.Integer.Type.negateInteger ww1_s1jcZ of dt1_s1jd4 {
                                  __DEFAULT -> GHC.Real.:% [dt_s1jd3 dt1_s1jd4];
                                };
                          };
                    };
                1# -> GHC.Real.ratioZeroDenominatorError;
              };
        };

GHC.Real.overflowError [InlPrag=NOINLINE] :: forall a. a
[GblId, Str=x] =
    [] \u [] raise# [GHC.Exception.overflowException];

lvl_r1j38 :: (GHC.Types.Int, GHC.Types.Int)
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Real.overflowError
                        GHC.Real.$fIntegralInt1];

GHC.Real.$fIntegralInt_$cdivMod [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jd6 w1_s1jd7]
        case w_s1jd6 of {
          GHC.Types.I# ww1_s1jd9 ->
              case w1_s1jd7 of {
                GHC.Types.I# ww3_s1jdb [Occ=Once!] ->
                    case ww3_s1jdb of wild_s1jdc {
                      __DEFAULT ->
                          case ># [ww1_s1jd9 0#] of {
                            __DEFAULT ->
                                case <# [ww1_s1jd9 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww1_s1jd9 wild_s1jdc] of {
                                        (#,#) ipv_s1jdg [Occ=Once] ipv1_s1jdh [Occ=Once] ->
                                            let {
                                              sat_s1jdj [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s1jdh]; } in
                                            let {
                                              sat_s1jdi [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_s1jdg];
                                            } in  (,) [sat_s1jdi sat_s1jdj];
                                      };
                                  1# ->
                                      case ># [wild_s1jdc 0#] of {
                                        __DEFAULT ->
                                            case quotRemInt# [ww1_s1jd9 wild_s1jdc] of {
                                              (#,#) ipv_s1jdm [Occ=Once] ipv1_s1jdn [Occ=Once] ->
                                                  let {
                                                    sat_s1jdp [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv1_s1jdn]; } in
                                                  let {
                                                    sat_s1jdo [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv_s1jdm];
                                                  } in  (,) [sat_s1jdo sat_s1jdp];
                                            };
                                        1# ->
                                            case +# [ww1_s1jd9 1#] of sat_s1jdq {
                                              __DEFAULT ->
                                                  case quotRemInt# [sat_s1jdq wild_s1jdc] of {
                                                    (#,#) ipv_s1jds [Occ=Once]
                                                          ipv1_s1jdt [Occ=Once] ->
                                                        case
                                                            +# [ipv1_s1jdt wild_s1jdc]
                                                        of
                                                        sat_s1jdw
                                                        { __DEFAULT ->
                                                              case -# [sat_s1jdw 1#] of sat_s1jdx {
                                                                __DEFAULT ->
                                                                    let {
                                                                      sat_s1jdy [Occ=Once]
                                                                        :: GHC.Types.Int
                                                                      [LclId] =
                                                                          CCCS GHC.Types.I#! [sat_s1jdx];
                                                                    } in 
                                                                      case
                                                                          -# [ipv_s1jds 1#]
                                                                      of
                                                                      sat_s1jdu
                                                                      { __DEFAULT ->
                                                                            let {
                                                                              sat_s1jdv [Occ=Once]
                                                                                :: GHC.Types.Int
                                                                              [LclId] =
                                                                                  CCCS GHC.Types.I#! [sat_s1jdu];
                                                                            } in 
                                                                              (,) [sat_s1jdv
                                                                                   sat_s1jdy];
                                                                      };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            1# ->
                                case <# [wild_s1jdc 0#] of {
                                  __DEFAULT ->
                                      case <# [ww1_s1jd9 0#] of {
                                        __DEFAULT ->
                                            case quotRemInt# [ww1_s1jd9 wild_s1jdc] of {
                                              (#,#) ipv_s1jdC [Occ=Once] ipv1_s1jdD [Occ=Once] ->
                                                  let {
                                                    sat_s1jdF [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv1_s1jdD]; } in
                                                  let {
                                                    sat_s1jdE [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv_s1jdC];
                                                  } in  (,) [sat_s1jdE sat_s1jdF];
                                            };
                                        1# ->
                                            case ># [wild_s1jdc 0#] of {
                                              __DEFAULT ->
                                                  case quotRemInt# [ww1_s1jd9 wild_s1jdc] of {
                                                    (#,#) ipv_s1jdI [Occ=Once]
                                                          ipv1_s1jdJ [Occ=Once] ->
                                                        let {
                                                          sat_s1jdL [Occ=Once] :: GHC.Types.Int
                                                          [LclId] =
                                                              CCCS GHC.Types.I#! [ipv1_s1jdJ]; } in
                                                        let {
                                                          sat_s1jdK [Occ=Once] :: GHC.Types.Int
                                                          [LclId] =
                                                              CCCS GHC.Types.I#! [ipv_s1jdI];
                                                        } in  (,) [sat_s1jdK sat_s1jdL];
                                                  };
                                              1# ->
                                                  case +# [ww1_s1jd9 1#] of sat_s1jdM {
                                                    __DEFAULT ->
                                                        case quotRemInt# [sat_s1jdM wild_s1jdc] of {
                                                          (#,#) ipv_s1jdO [Occ=Once]
                                                                ipv1_s1jdP [Occ=Once] ->
                                                              case
                                                                  +# [ipv1_s1jdP wild_s1jdc]
                                                              of
                                                              sat_s1jdS
                                                              { __DEFAULT ->
                                                                    case
                                                                        -# [sat_s1jdS 1#]
                                                                    of
                                                                    sat_s1jdT
                                                                    { __DEFAULT ->
                                                                          let {
                                                                            sat_s1jdU [Occ=Once]
                                                                              :: GHC.Types.Int
                                                                            [LclId] =
                                                                                CCCS GHC.Types.I#! [sat_s1jdT];
                                                                          } in 
                                                                            case
                                                                                -# [ipv_s1jdO 1#]
                                                                            of
                                                                            sat_s1jdQ
                                                                            { __DEFAULT ->
                                                                                  let {
                                                                                    sat_s1jdR [Occ=Once]
                                                                                      :: GHC.Types.Int
                                                                                    [LclId] =
                                                                                        CCCS GHC.Types.I#! [sat_s1jdQ];
                                                                                  } in 
                                                                                    (,) [sat_s1jdR
                                                                                         sat_s1jdU];
                                                                            };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                  1# ->
                                      case -# [ww1_s1jd9 1#] of sat_s1jdV {
                                        __DEFAULT ->
                                            case quotRemInt# [sat_s1jdV wild_s1jdc] of {
                                              (#,#) ipv_s1jdX [Occ=Once] ipv1_s1jdY [Occ=Once] ->
                                                  case +# [ipv1_s1jdY wild_s1jdc] of sat_s1je1 {
                                                    __DEFAULT ->
                                                        case +# [sat_s1je1 1#] of sat_s1je2 {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_s1je3 [Occ=Once]
                                                                  :: GHC.Types.Int
                                                                [LclId] =
                                                                    CCCS GHC.Types.I#! [sat_s1je2];
                                                              } in 
                                                                case
                                                                    -# [ipv_s1jdX 1#]
                                                                of
                                                                sat_s1jdZ
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_s1je0 [Occ=Once]
                                                                          :: GHC.Types.Int
                                                                        [LclId] =
                                                                            CCCS GHC.Types.I#! [sat_s1jdZ];
                                                                      } in 
                                                                        (,) [sat_s1je0 sat_s1je3];
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                      -1# ->
                          case ww1_s1jd9 of wild1_s1je4 {
                            __DEFAULT ->
                                case ># [wild1_s1je4 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [wild1_s1je4 -1#] of {
                                        (#,#) ipv_s1je7 [Occ=Once] ipv1_s1je8 [Occ=Once] ->
                                            let {
                                              sat_s1jea [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s1je8]; } in
                                            let {
                                              sat_s1je9 [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_s1je7];
                                            } in  (,) [sat_s1je9 sat_s1jea];
                                      };
                                  1# ->
                                      case -# [wild1_s1je4 1#] of sat_s1jeb {
                                        __DEFAULT ->
                                            case quotRemInt# [sat_s1jeb -1#] of {
                                              (#,#) ipv_s1jed [Occ=Once] ipv1_s1jee [Occ=Once] ->
                                                  case +# [ipv1_s1jee -1#] of sat_s1jeh {
                                                    __DEFAULT ->
                                                        case +# [sat_s1jeh 1#] of sat_s1jei {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_s1jej [Occ=Once]
                                                                  :: GHC.Types.Int
                                                                [LclId] =
                                                                    CCCS GHC.Types.I#! [sat_s1jei];
                                                              } in 
                                                                case
                                                                    -# [ipv_s1jed 1#]
                                                                of
                                                                sat_s1jef
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_s1jeg [Occ=Once]
                                                                          :: GHC.Types.Int
                                                                        [LclId] =
                                                                            CCCS GHC.Types.I#! [sat_s1jef];
                                                                      } in 
                                                                        (,) [sat_s1jeg sat_s1jej];
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            -9223372036854775808# -> lvl_r1j38;
                          };
                      0# -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralInt_$cquotRem [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jel w1_s1jem]
        case w_s1jel of {
          GHC.Types.I# ww1_s1jeo [Occ=Once*] ->
              case w1_s1jem of {
                GHC.Types.I# ww3_s1jeq [Occ=Once!] ->
                    case ww3_s1jeq of wild_s1jer {
                      __DEFAULT ->
                          case quotRemInt# [ww1_s1jeo wild_s1jer] of {
                            (#,#) ipv_s1jet [Occ=Once] ipv1_s1jeu [Occ=Once] ->
                                let {
                                  sat_s1jew [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s1jeu]; } in
                                let {
                                  sat_s1jev [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv_s1jet];
                                } in  (,) [sat_s1jev sat_s1jew];
                          };
                      -1# ->
                          case ww1_s1jeo of wild1_s1jex {
                            __DEFAULT ->
                                case quotRemInt# [wild1_s1jex -1#] of {
                                  (#,#) ipv_s1jez [Occ=Once] ipv1_s1jeA [Occ=Once] ->
                                      let {
                                        sat_s1jeC [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv1_s1jeA]; } in
                                      let {
                                        sat_s1jeB [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv_s1jez];
                                      } in  (,) [sat_s1jeB sat_s1jeC];
                                };
                            -9223372036854775808# -> lvl_r1j38;
                          };
                      0# -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$w$cdiv [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Str=<S,U><S,1*U>, Unf=OtherCon []] =
    [] \r [ww_s1jeE ww1_s1jeF]
        case ww1_s1jeF of wild_s1jeG {
          __DEFAULT -> GHC.Classes.divInt# ww_s1jeE wild_s1jeG;
          -1# ->
              case ww_s1jeE of wild1_s1jeH {
                __DEFAULT -> GHC.Classes.divInt# wild1_s1jeH -1#;
                -9223372036854775808# -> GHC.Real.overflowError;
              };
          0# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInt_$cdiv [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jeK w1_s1jeL]
        case w_s1jeK of {
          GHC.Types.I# ww1_s1jeN [Occ=Once] ->
              case w1_s1jeL of {
                GHC.Types.I# ww3_s1jeP [Occ=Once] ->
                    case GHC.Real.$w$cdiv ww1_s1jeN ww3_s1jeP of ww4_s1jeQ {
                      __DEFAULT -> GHC.Types.I# [ww4_s1jeQ];
                    };
              };
        };

GHC.Real.$fIntegralInt_$cquot [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jeR w1_s1jeS]
        case w_s1jeR of {
          GHC.Types.I# ww1_s1jeU [Occ=Once*] ->
              case w1_s1jeS of {
                GHC.Types.I# ww3_s1jeW [Occ=Once!] ->
                    case ww3_s1jeW of wild_s1jeX {
                      __DEFAULT ->
                          case quotInt# [ww1_s1jeU wild_s1jeX] of ww4_s1jeY {
                            __DEFAULT -> GHC.Types.I# [ww4_s1jeY];
                          };
                      -1# ->
                          case ww1_s1jeU of wild1_s1jeZ {
                            __DEFAULT ->
                                case quotInt# [wild1_s1jeZ -1#] of sat_s1jf0 {
                                  __DEFAULT -> GHC.Types.I# [sat_s1jf0];
                                };
                            -9223372036854775808# -> GHC.Real.overflowError;
                          };
                      0# -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralInt [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Integral GHC.Types.Int
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Integral! [GHC.Real.$fRealInt
                                        GHC.Enum.$fEnumInt
                                        GHC.Real.$fIntegralInt_$cquot
                                        GHC.Real.$fIntegralInt_$crem
                                        GHC.Real.$fIntegralInt_$cdiv
                                        GHC.Real.$fIntegralInt_$cmod
                                        GHC.Real.$fIntegralInt_$cquotRem
                                        GHC.Real.$fIntegralInt_$cdivMod
                                        GHC.Real.$fIntegralInt_$ctoInteger];

lvl1_r1j39 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [-1#];

lvl2_r1j3a :: GHC.Types.Int
[GblId] =
    [] \u [] GHC.Real.$wgcd' lvl1_r1j39 0#;
GHC.Real.$wgcd' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: GHC.Types.Int -> GHC.Prim.Int# -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [w_s1jf3 ww_s1jf4]
        case ww_s1jf4 of wild_s1jf5 {
          __DEFAULT ->
              case w_s1jf3 of {
                GHC.Types.I# x_s1jf7 [Occ=Once] ->
                    case remInt# [x_s1jf7 wild_s1jf5] of wild2_s1jf8 {
                      __DEFAULT ->
                          let {
                            sat_s1jf9 [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [wild_s1jf5];
                          } in  GHC.Real.$wgcd' sat_s1jf9 wild2_s1jf8;
                    };
              };
          -1# -> lvl2_r1j3a;
          0# -> w_s1jf3;
        };

GHC.Real.$fEnumRatio_gcd' [Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [a_s1jfa ds_s1jfb]
        case GHC.Integer.Type.eqInteger# ds_s1jfb GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.remInteger a_s1jfa ds_s1jfb of sat_s1jfd {
                __DEFAULT -> GHC.Real.$fEnumRatio_gcd' ds_s1jfb sat_s1jfd;
              };
          1# -> a_s1jfa;
        };

GHC.Real.gcd [InlPrag=NOINLINE[1]]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(U(A,A,A,A,C(U),A,1*C1(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jfe eta_s1jff eta1_s1jfg]
        case
            GHC.Real.$p1Integral $dIntegral_s1jfe
        of
        $dReal_s1jfh [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(U(A,A,A,A,C(U),A,1*C1(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                lvl8_s1jfi [Occ=OnceL] :: a_a1eor
                [LclId] =
                    [$dReal_s1jfh] \u []
                        case GHC.Real.$p1Real $dReal_s1jfh of sat_s1jfj {
                          __DEFAULT -> GHC.Num.fromInteger sat_s1jfj GHC.Real.even1;
                        };
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1jfh
                of
                $dEq_s1jfk [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Classes.$p1Ord $dEq_s1jfk
                      of
                      $dEq1_s1jfl [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                      { __DEFAULT ->
                            let {
                              $dNum_s1jfm [Dmd=<L,U(A,A,A,A,C(U),A,A)>] :: GHC.Num.Num a_a1eor
                              [LclId] =
                                  [$dReal_s1jfh] \u [] GHC.Real.$p1Real $dReal_s1jfh; } in
                            let {
                              sat_s1jft [Occ=Once] :: a_a1eor
                              [LclId] =
                                  [eta1_s1jfg $dNum_s1jfm] \u []
                                      GHC.Num.abs $dNum_s1jfm eta1_s1jfg; } in
                            let {
                              sat_s1jfs [Occ=Once] :: a_a1eor
                              [LclId] =
                                  [eta_s1jff $dNum_s1jfm] \u [] GHC.Num.abs $dNum_s1jfm eta_s1jff;
                            } in 
                              let-no-escape {
                                gcd'_s1jfn [Occ=LoopBreakerT[2]] :: a_a1eor -> a_a1eor -> a_a1eor
                                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                    sat-only [$dIntegral_s1jfe
                                              lvl8_s1jfi
                                              $dEq1_s1jfl
                                              gcd'_s1jfn] \r [a1_s1jfo ds_s1jfp]
                                        case GHC.Classes.== $dEq1_s1jfl ds_s1jfp lvl8_s1jfi of {
                                          GHC.Types.False ->
                                              let {
                                                sat_s1jfr [Occ=Once] :: a_a1eor
                                                [LclId] =
                                                    [$dIntegral_s1jfe a1_s1jfo ds_s1jfp] \u []
                                                        GHC.Real.rem
                                                            $dIntegral_s1jfe a1_s1jfo ds_s1jfp;
                                              } in  gcd'_s1jfn ds_s1jfp sat_s1jfr;
                                          GHC.Types.True -> a1_s1jfo;
                                        };
                              } in  gcd'_s1jfn sat_s1jfs sat_s1jft;
                      };
                };
        };

GHC.Real.$w$sreduce [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [w_s1jfu w1_s1jfv]
        case GHC.Integer.Type.eqInteger# w1_s1jfv GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.absInteger w1_s1jfv of sat_s1jfz {
                __DEFAULT ->
                    case GHC.Integer.Type.absInteger w_s1jfu of sat_s1jfy {
                      __DEFAULT ->
                          case
                              GHC.Real.$fEnumRatio_gcd' sat_s1jfy sat_s1jfz
                          of
                          d_s1jfx [Dmd=<S,U>]
                          { __DEFAULT ->
                                case GHC.Integer.Type.eqInteger# d_s1jfx GHC.Real.even1 of {
                                  __DEFAULT ->
                                      case
                                          GHC.Integer.Type.quotInteger w_s1jfu d_s1jfx
                                      of
                                      dt_s1jfB
                                      { __DEFAULT ->
                                            case
                                                GHC.Integer.Type.quotInteger w1_s1jfv d_s1jfx
                                            of
                                            dt1_s1jfC
                                            { __DEFAULT -> (#,#) [dt_s1jfB dt1_s1jfC];
                                            };
                                      };
                                  1# -> GHC.Real.divZeroError;
                                };
                          };
                    };
              };
          1# -> GHC.Real.ratioZeroDenominatorError;
        };

GHC.Real.reduce_$sreduce [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S,U>m, Unf=OtherCon []] =
    [] \r [w_s1jfF w1_s1jfG]
        case GHC.Real.$w$sreduce w_s1jfF w1_s1jfG of {
          (#,#) ww1_s1jfI [Occ=Once] ww2_s1jfJ [Occ=Once] ->
              GHC.Real.:% [ww1_s1jfI ww2_s1jfJ];
        };

GHC.Real.$fRealWord_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Word -> GHC.Real.Rational
[GblId, Arity=1, Str=<S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1jfK]
        case w_s1jfK of {
          GHC.Types.W# ww1_s1jfM [Occ=Once] ->
              case GHC.Integer.Type.wordToInteger ww1_s1jfM of sat_s1jfN {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger sat_s1jfN GHC.Real.$fEnumRatio1
                    of
                    sat_s1jfO
                    { __DEFAULT ->
                          case GHC.Real.$w$sreduce sat_s1jfO GHC.Real.$fEnumRatio1 of {
                            (#,#) ww3_s1jfQ [Occ=Once] ww4_s1jfR [Occ=Once] ->
                                GHC.Real.:% [ww3_s1jfQ ww4_s1jfR];
                          };
                    };
              };
        };

GHC.Real.$fRealWord [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real GHC.Types.Word
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Num.$fNumWord
                                    GHC.Classes.$fOrdWord
                                    GHC.Real.$fRealWord_$ctoRational];

GHC.Real.$fIntegralWord [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Integral GHC.Types.Word
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Integral! [GHC.Real.$fRealWord
                                        GHC.Enum.$fEnumWord
                                        GHC.Real.$fIntegralWord_$cquot
                                        GHC.Real.$fIntegralWord_$crem
                                        GHC.Real.$fIntegralWord_$cquot
                                        GHC.Real.$fIntegralWord_$crem
                                        GHC.Real.$fIntegralWord_$cquotRem
                                        GHC.Real.$fIntegralWord_$cdivMod
                                        GHC.Real.$fIntegralWord_$ctoInteger];

GHC.Real.$fFractionalRatio_$s$c* [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jfS w1_s1jfT]
        case w_s1jfS of {
          GHC.Real.:% ww1_s1jfV [Occ=Once] ww2_s1jfW [Occ=Once] ->
              case w1_s1jfT of {
                GHC.Real.:% ww4_s1jfY [Occ=Once] ww5_s1jfZ [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww2_s1jfW ww5_s1jfZ
                    of
                    sat_s1jg1
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1jfV ww4_s1jfY
                          of
                          sat_s1jg0
                          { __DEFAULT ->
                                case GHC.Real.$w$sreduce sat_s1jg0 sat_s1jg1 of {
                                  (#,#) ww7_s1jg3 [Occ=Once] ww8_s1jg4 [Occ=Once] ->
                                      GHC.Real.:% [ww7_s1jg3 ww8_s1jg4];
                                };
                          };
                    };
              };
        };

GHC.Real.$w$s$c- [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=4, Str=<S,1*U><S,U><S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1jg5 ww1_s1jg6 ww2_s1jg7 ww3_s1jg8]
        case
            GHC.Integer.Type.timesInteger ww1_s1jg6 ww3_s1jg8
        of
        sat_s1jgc
        { __DEFAULT ->
              case
                  GHC.Integer.Type.timesInteger ww2_s1jg7 ww1_s1jg6
              of
              sat_s1jga
              { __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger ww_s1jg5 ww3_s1jg8
                    of
                    sat_s1jg9
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.minusInteger sat_s1jg9 sat_s1jga
                          of
                          sat_s1jgb
                          { __DEFAULT -> GHC.Real.$w$sreduce sat_s1jgb sat_s1jgc;
                          };
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$c- [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jgd w1_s1jge]
        case w_s1jgd of {
          GHC.Real.:% ww1_s1jgg [Occ=Once] ww2_s1jgh [Occ=Once] ->
              case w1_s1jge of {
                GHC.Real.:% ww4_s1jgj [Occ=Once] ww5_s1jgk [Occ=Once] ->
                    case GHC.Real.$w$s$c- ww1_s1jgg ww2_s1jgh ww4_s1jgj ww5_s1jgk of {
                      (#,#) ww7_s1jgm [Occ=Once] ww8_s1jgn [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jgm ww8_s1jgn];
                    };
              };
        };

GHC.Real.$w$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=4, Str=<S,1*U><S,U><S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1jgo ww1_s1jgp ww2_s1jgq ww3_s1jgr]
        case
            GHC.Integer.Type.timesInteger ww1_s1jgp ww3_s1jgr
        of
        sat_s1jgv
        { __DEFAULT ->
              case
                  GHC.Integer.Type.timesInteger ww2_s1jgq ww1_s1jgp
              of
              sat_s1jgt
              { __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger ww_s1jgo ww3_s1jgr
                    of
                    sat_s1jgs
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.plusInteger sat_s1jgs sat_s1jgt
                          of
                          sat_s1jgu
                          { __DEFAULT -> GHC.Real.$w$sreduce sat_s1jgu sat_s1jgv;
                          };
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jgw w1_s1jgx]
        case w_s1jgw of {
          GHC.Real.:% ww1_s1jgz [Occ=Once] ww2_s1jgA [Occ=Once] ->
              case w1_s1jgx of {
                GHC.Real.:% ww4_s1jgC [Occ=Once] ww5_s1jgD [Occ=Once] ->
                    case GHC.Real.$w$s$c+ ww1_s1jgz ww2_s1jgA ww4_s1jgC ww5_s1jgD of {
                      (#,#) ww7_s1jgF [Occ=Once] ww8_s1jgG [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jgF ww8_s1jgG];
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$fNumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Num.Num (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Num.C:Num! [GHC.Real.$fEnumRatio_$s$c+
                                  GHC.Real.$fEnumRatio_$s$c-
                                  GHC.Real.$fFractionalRatio_$s$c*
                                  GHC.Real.$fFractionalRatio_$s$cnegate
                                  GHC.Real.$fFractionalRatio_$s$cabs
                                  GHC.Real.$fFractionalRatio_$s$csignum
                                  GHC.Real.$fFractionalRatio_$s$cfromInteger];

GHC.Real.$w$s$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1jgH ww1_s1jgI]
        case GHC.Integer.Type.absInteger ww1_s1jgI of sat_s1jgL {
          __DEFAULT ->
              case GHC.Integer.Type.signumInteger ww1_s1jgI of sat_s1jgJ {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger ww_s1jgH sat_s1jgJ
                    of
                    sat_s1jgK
                    { __DEFAULT -> GHC.Real.$w$sreduce sat_s1jgK sat_s1jgL;
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Rational -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_s1jgM]
        case w_s1jgM of {
          GHC.Real.:% ww1_s1jgO [Occ=Once] ww2_s1jgP [Occ=Once] ->
              case GHC.Real.$w$s$cfromRational ww1_s1jgO ww2_s1jgP of {
                (#,#) ww4_s1jgR [Occ=Once] ww5_s1jgS [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jgR ww5_s1jgS];
              };
        };

GHC.Real.$w$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId,
 Arity=4,
 Str=<S,1*U><S,1*U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_s1jgT ww1_s1jgU ww2_s1jgV ww3_s1jgW]
        case
            GHC.Integer.Type.timesInteger ww1_s1jgU ww2_s1jgV
        of
        y_s1jgX [Dmd=<S,U>]
        { __DEFAULT ->
              case GHC.Integer.Type.absInteger y_s1jgX of sat_s1jh1 {
                __DEFAULT ->
                    case GHC.Integer.Type.signumInteger y_s1jgX of sat_s1jgZ {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww_s1jgT ww3_s1jgW
                          of
                          sat_s1jgY
                          { __DEFAULT ->
                                case
                                    GHC.Integer.Type.timesInteger sat_s1jgY sat_s1jgZ
                                of
                                sat_s1jh0
                                { __DEFAULT -> GHC.Real.$w$sreduce sat_s1jh0 sat_s1jh1;
                                };
                          };
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jh2 w1_s1jh3]
        case w_s1jh2 of {
          GHC.Real.:% ww1_s1jh5 [Occ=Once] ww2_s1jh6 [Occ=Once] ->
              case w1_s1jh3 of {
                GHC.Real.:% ww4_s1jh8 [Occ=Once] ww5_s1jh9 [Occ=Once] ->
                    case GHC.Real.$w$s$c/ ww1_s1jh5 ww2_s1jh6 ww4_s1jh8 ww5_s1jh9 of {
                      (#,#) ww7_s1jhb [Occ=Once] ww8_s1jhc [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jhb ww8_s1jhc];
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$fFractionalRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Fractional (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Fractional! [GHC.Real.$fFractionalRatio_$s$fNumRatio
                                          GHC.Real.$fFractionalRatio_$s$c/
                                          GHC.Real.$fFractionalRatio_$s$crecip
                                          GHC.Real.$fFractionalRatio_$s$cfromRational];

GHC.Real.ratioPrec :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [7#];

GHC.Real.infinity :: GHC.Real.Rational
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.$fEnumRatio1 GHC.Real.even1];

GHC.Real.notANumber :: GHC.Real.Rational
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.even1 GHC.Real.even1];

GHC.Real.numerator :: forall a. GHC.Real.Ratio a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_s1jhd]
        case ds_s1jhd of {
          GHC.Real.:% x_s1jhf [Occ=Once] _ [Occ=Dead] -> x_s1jhf;
        };

GHC.Real.denominator :: forall a. GHC.Real.Ratio a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1jhh]
        case ds_s1jhh of {
          GHC.Real.:% _ [Occ=Dead] y_s1jhk [Occ=Once] -> y_s1jhk;
        };

GHC.Real.$w$snumericEnumFrom [InlPrag=NOUSERINLINE[0],
                              Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Real.Ratio GHC.Integer.Type.Integer,
           [GHC.Real.Ratio GHC.Integer.Type.Integer] #)
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1jhl ww1_s1jhm]
        let {
          sat_s1jhu [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
          [LclId] =
              [ww_s1jhl ww1_s1jhm] \u []
                  case
                      GHC.Real.$w$s$c+
                          ww_s1jhl ww1_s1jhm GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
                  of
                  { (#,#) ww3_s1jhp [Occ=Once] ww4_s1jhq [Occ=Once] ->
                        case GHC.Real.$w$snumericEnumFrom ww3_s1jhp ww4_s1jhq of {
                          (#,#) ww6_s1jhs [Occ=Once] ww7_s1jht [Occ=Once] ->
                              : [ww6_s1jhs ww7_s1jht];
                        };
                  }; } in
        let {
          sat_s1jhn [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId] =
              CCCS GHC.Real.:%! [ww_s1jhl ww1_s1jhm];
        } in  (#,#) [sat_s1jhn sat_s1jhu];

GHC.Real.$fEnumRatio_$snumericEnumFrom [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m2, Unf=OtherCon []] =
    [] \r [w_s1jhv]
        case w_s1jhv of {
          GHC.Real.:% ww1_s1jhx [Occ=Once] ww2_s1jhy [Occ=Once] ->
              case GHC.Real.$w$snumericEnumFrom ww1_s1jhx ww2_s1jhy of {
                (#,#) ww4_s1jhA [Occ=Once] ww5_s1jhB [Occ=Once] ->
                    : [ww4_s1jhA ww5_s1jhB];
              };
        };

GHC.Real.$wnumericEnumFrom [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: forall a. GHC.Real.Fractional a => a -> (# a, [a] #)
[GblId,
 Arity=2,
 Str=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1jhC w1_s1jhD]
        case w1_s1jhD of n_s1jhE {
          __DEFAULT ->
              let {
                sat_s1jhL [Occ=Once] :: [a_s1hA7]
                [LclId] =
                    [w_s1jhC n_s1jhE] \u []
                        case
                            GHC.Real.$p1Fractional w_s1jhC
                        of
                        $dNum_s1jhF [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                        { __DEFAULT ->
                              let {
                                sat_s1jhG [Occ=Once] :: a_s1hA7
                                [LclId] =
                                    [$dNum_s1jhF] \u []
                                        GHC.Num.fromInteger $dNum_s1jhF GHC.Real.$fEnumRatio1;
                              } in 
                                case GHC.Num.+ $dNum_s1jhF n_s1jhE sat_s1jhG of sat_s1jhH {
                                  __DEFAULT ->
                                      case GHC.Real.$wnumericEnumFrom w_s1jhC sat_s1jhH of {
                                        (#,#) ww1_s1jhJ [Occ=Once] ww2_s1jhK [Occ=Once] ->
                                            : [ww1_s1jhJ ww2_s1jhK];
                                      };
                                };
                        };
              } in  (#,#) [n_s1jhE sat_s1jhL];
        };

GHC.Real.numericEnumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Fractional a => a -> [a]
[GblId,
 Arity=2,
 Str=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_s1jhM w1_s1jhN]
        case GHC.Real.$wnumericEnumFrom w_s1jhM w1_s1jhN of {
          (#,#) ww1_s1jhP [Occ=Once] ww2_s1jhQ [Occ=Once] ->
              : [ww1_s1jhP ww2_s1jhQ];
        };

sat_s1jhR :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_s1jhS :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1jhR GHC.Types.[]];

GHC.Real.even2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s1jhS;

GHC.Real.$fEnumRatio2 :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId] =
    [] \u []
        case
            GHC.Real.$w$s$c/
                GHC.Real.$fEnumRatio1
                GHC.Real.$fEnumRatio1
                GHC.Real.even2
                GHC.Real.$fEnumRatio1
        of
        { (#,#) ww1_s1jhU [Occ=Once] ww2_s1jhV [Occ=Once] ->
              GHC.Real.:% [ww1_s1jhU ww2_s1jhV];
        };

GHC.Real.$w$snumericEnumFromTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId, Arity=3, Str=<L,U><L,U><L,1*U(U,U)>, Unf=OtherCon []] =
    [] \r [ww_s1jhW ww1_s1jhX w_s1jhY]
        case GHC.Real.$w$snumericEnumFrom ww_s1jhW ww1_s1jhX of {
          (#,#) ww3_s1ji0 [Occ=Once] ww4_s1ji1 [Occ=Once] ->
              let {
                sat_s1jie [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
                [LclId] =
                    CCCS :! [ww3_s1ji0 ww4_s1ji1]; } in
              let {
                ds_s1ji2 [Occ=OnceL, Dmd=<L,U(U,U)>]
                  :: GHC.Real.Ratio GHC.Integer.Type.Integer
                [LclId] =
                    [w_s1jhY] \u []
                        case w_s1jhY of {
                          GHC.Real.:% ww6_s1ji4 [Occ=Once] ww7_s1ji5 [Occ=Once] ->
                              case GHC.Real.$fEnumRatio2 of {
                                GHC.Real.:% ww9_s1ji7 [Occ=Once] ww10_s1ji8 [Occ=Once] ->
                                    case
                                        GHC.Real.$w$s$c+ ww6_s1ji4 ww7_s1ji5 ww9_s1ji7 ww10_s1ji8
                                    of
                                    { (#,#) ww12_s1jia [Occ=Once] ww13_s1jib [Occ=Once] ->
                                          GHC.Real.:% [ww12_s1jia ww13_s1jib];
                                    };
                              };
                        }; } in
              let {
                sat_s1jid [Occ=Once]
                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                [LclId] =
                    [ds_s1ji2] \r [ds1_s1jic]
                        GHC.Real.$fEnumRatio_$s$c<= ds1_s1jic ds_s1ji2;
              } in  GHC.List.takeWhile sat_s1jid sat_s1jie;
        };

GHC.Real.$fEnumRatio_$snumericEnumFromTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jif w1_s1jig]
        case w_s1jif of {
          GHC.Real.:% ww1_s1jii [Occ=Once] ww2_s1jij [Occ=Once] ->
              GHC.Real.$w$snumericEnumFromTo ww1_s1jii ww2_s1jij w1_s1jig;
        };

GHC.Real.numericEnumFromTo
  :: forall a.
     (GHC.Classes.Ord a, GHC.Real.Fractional a) =>
     a -> a -> [a]
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U(U(C(C1(U)),A,A,A,A,A,C(U)),1*C1(C1(U)),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1jik $dFractional_s1jil eta_s1jim eta1_s1jin]
        case GHC.Real.$wnumericEnumFrom $dFractional_s1jil eta_s1jim of {
          (#,#) ww1_s1jip [Occ=Once] ww2_s1jiq [Occ=Once] ->
              let {
                $dNum_s1jir [Dmd=<L,U(1*C1(C1(U)),A,A,A,A,A,C(U))>]
                  :: GHC.Num.Num a_a1ew7
                [LclId] =
                    [$dFractional_s1jil] \u []
                        GHC.Real.$p1Fractional $dFractional_s1jil; } in
              let {
                sat_s1jiy [Occ=Once] :: [a_a1ew7]
                [LclId] =
                    CCCS :! [ww1_s1jip ww2_s1jiq]; } in
              let {
                ds_s1jis [Occ=OnceL] :: a_a1ew7
                [LclId] =
                    [$dFractional_s1jil eta1_s1jin $dNum_s1jir] \u []
                        let {
                          sat_s1jiv [Occ=Once] :: a_a1ew7
                          [LclId] =
                              [$dFractional_s1jil $dNum_s1jir] \u []
                                  let {
                                    sat_s1jiu [Occ=Once] :: a_a1ew7
                                    [LclId] =
                                        [$dNum_s1jir] \u []
                                            GHC.Num.fromInteger $dNum_s1jir GHC.Real.even2; } in
                                  let {
                                    sat_s1jit [Occ=Once] :: a_a1ew7
                                    [LclId] =
                                        [$dNum_s1jir] \u []
                                            GHC.Num.fromInteger $dNum_s1jir GHC.Real.$fEnumRatio1;
                                  } in  GHC.Real./ $dFractional_s1jil sat_s1jit sat_s1jiu;
                        } in  GHC.Num.+ $dNum_s1jir eta1_s1jin sat_s1jiv; } in
              let {
                sat_s1jix [Occ=Once] :: a_a1ew7 -> GHC.Types.Bool
                [LclId] =
                    [$dOrd_s1jik ds_s1jis] \r [ds1_s1jiw]
                        GHC.Classes.<= $dOrd_s1jik ds1_s1jiw ds_s1jis;
              } in  GHC.List.takeWhile sat_s1jix sat_s1jiy;
        };

GHC.Real.$w$snumericEnumFromThen [InlPrag=NOUSERINLINE[0],
                                  Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Real.Ratio GHC.Integer.Type.Integer,
           [GHC.Real.Ratio GHC.Integer.Type.Integer] #)
[GblId, Arity=4, Str=<L,U><L,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1jiz ww1_s1jiA ww2_s1jiB ww3_s1jiC]
        let {
          sat_s1jiN [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
          [LclId] =
              [ww_s1jiz ww1_s1jiA ww2_s1jiB ww3_s1jiC] \u []
                  case GHC.Real.$w$s$c+ ww2_s1jiB ww3_s1jiC ww2_s1jiB ww3_s1jiC of {
                    (#,#) ww5_s1jiF [Occ=Once] ww6_s1jiG [Occ=Once] ->
                        case GHC.Real.$w$s$c- ww5_s1jiF ww6_s1jiG ww_s1jiz ww1_s1jiA of {
                          (#,#) ww8_s1jiI [Occ=Once] ww9_s1jiJ [Occ=Once] ->
                              case
                                  GHC.Real.$w$snumericEnumFromThen
                                      ww2_s1jiB ww3_s1jiC ww8_s1jiI ww9_s1jiJ
                              of
                              { (#,#) ww11_s1jiL [Occ=Once] ww12_s1jiM [Occ=Once] ->
                                    : [ww11_s1jiL ww12_s1jiM];
                              };
                        };
                  }; } in
        let {
          sat_s1jiD [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId] =
              CCCS GHC.Real.:%! [ww_s1jiz ww1_s1jiA];
        } in  (#,#) [sat_s1jiD sat_s1jiN];

GHC.Real.$fEnumRatio_$snumericEnumFromThen [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s1jiO w1_s1jiP]
        case w_s1jiO of {
          GHC.Real.:% ww1_s1jiR [Occ=Once] ww2_s1jiS [Occ=Once] ->
              case w1_s1jiP of {
                GHC.Real.:% ww4_s1jiU [Occ=Once] ww5_s1jiV [Occ=Once] ->
                    case
                        GHC.Real.$w$snumericEnumFromThen
                            ww1_s1jiR ww2_s1jiS ww4_s1jiU ww5_s1jiV
                    of
                    { (#,#) ww7_s1jiX [Occ=Once] ww8_s1jiY [Occ=Once] ->
                          : [ww7_s1jiX ww8_s1jiY];
                    };
              };
        };

GHC.Real.$wnumericEnumFromThen [InlPrag=NOUSERINLINE[0],
                                Occ=LoopBreaker]
  :: forall a. GHC.Real.Fractional a => a -> a -> (# a, [a] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1jiZ w1_s1jj0 w2_s1jj1]
        case w1_s1jj0 of n_s1jj2 {
          __DEFAULT ->
              case w2_s1jj1 of m_s1jj3 {
                __DEFAULT ->
                    let {
                      sat_s1jja [Occ=Once] :: [a_s1hAH]
                      [LclId] =
                          [w_s1jiZ n_s1jj2 m_s1jj3] \u []
                              case
                                  GHC.Real.$p1Fractional w_s1jiZ
                              of
                              $dNum_s1jj4 [Dmd=<S(LC(C(S))LLLLL),U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,A)>]
                              { __DEFAULT ->
                                    let {
                                      sat_s1jj5 [Occ=Once] :: a_s1hAH
                                      [LclId] =
                                          [m_s1jj3 $dNum_s1jj4] \u []
                                              GHC.Num.+ $dNum_s1jj4 m_s1jj3 m_s1jj3;
                                    } in 
                                      case GHC.Num.- $dNum_s1jj4 sat_s1jj5 n_s1jj2 of sat_s1jj6 {
                                        __DEFAULT ->
                                            case
                                                GHC.Real.$wnumericEnumFromThen
                                                    w_s1jiZ m_s1jj3 sat_s1jj6
                                            of
                                            { (#,#) ww1_s1jj8 [Occ=Once] ww2_s1jj9 [Occ=Once] ->
                                                  : [ww1_s1jj8 ww2_s1jj9];
                                            };
                                      };
                              };
                    } in  (#,#) [n_s1jj2 sat_s1jja];
              };
        };

GHC.Real.numericEnumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Fractional a => a -> a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)><S,1*U><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_s1jjb w1_s1jjc w2_s1jjd]
        case GHC.Real.$wnumericEnumFromThen w_s1jjb w1_s1jjc w2_s1jjd of {
          (#,#) ww1_s1jjf [Occ=Once] ww2_s1jjg [Occ=Once] ->
              : [ww1_s1jjf ww2_s1jjg];
        };

GHC.Real.$w$snumericEnumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=5,
 Str=<L,U><L,U><L,U><L,U><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [ww_s1jjh ww1_s1jji ww2_s1jjj ww3_s1jjk w_s1jjl]
        case
            GHC.Real.$w$snumericEnumFromThen
                ww_s1jjh ww1_s1jji ww2_s1jjj ww3_s1jjk
        of
        { (#,#) ww5_s1jjn [Occ=Once] ww6_s1jjo [Occ=Once] ->
              let {
                sat_s1jjV [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
                [LclId] =
                    CCCS :! [ww5_s1jjn ww6_s1jjo]; } in
              let {
                sat_s1jjU [Occ=Once, Dmd=<L,C(U)>]
                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                [LclId] =
                    [ww_s1jjh ww1_s1jji ww2_s1jjj ww3_s1jjk w_s1jjl] \u []
                        case
                            GHC.Real.$w$s$ccompare ww2_s1jjj ww3_s1jjk ww_s1jjh ww1_s1jji
                        of
                        { __DEFAULT ->
                              let {
                                ds_s1jjq [Occ=OnceL, Dmd=<L,U(U,U)>]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer
                                [LclId] =
                                    [ww_s1jjh ww1_s1jji ww2_s1jjj ww3_s1jjk w_s1jjl] \u []
                                        case w_s1jjl of {
                                          GHC.Real.:% ww8_s1jjs [Occ=Once] ww9_s1jjt [Occ=Once] ->
                                              case
                                                  GHC.Real.$w$s$c-
                                                      ww2_s1jjj ww3_s1jjk ww_s1jjh ww1_s1jji
                                              of
                                              { (#,#) ww11_s1jjv [Occ=Once] ww12_s1jjw [Occ=Once] ->
                                                    case
                                                        GHC.Real.$w$s$c/
                                                            ww11_s1jjv
                                                            ww12_s1jjw
                                                            GHC.Real.even2
                                                            GHC.Real.$fEnumRatio1
                                                    of
                                                    { (#,#) ww14_s1jjy [Occ=Once]
                                                            ww15_s1jjz [Occ=Once] ->
                                                          case
                                                              GHC.Real.$w$s$c+
                                                                  ww8_s1jjs
                                                                  ww9_s1jjt
                                                                  ww14_s1jjy
                                                                  ww15_s1jjz
                                                          of
                                                          { (#,#) ww17_s1jjB [Occ=Once]
                                                                  ww18_s1jjC [Occ=Once] ->
                                                                GHC.Real.:% [ww17_s1jjB ww18_s1jjC];
                                                          };
                                                    };
                                              };
                                        }; } in
                              let {
                                sat_s1jjE [Occ=OnceT[0]]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                                [LclId] =
                                    [ds_s1jjq] \r [ds1_s1jjD]
                                        GHC.Real.$fEnumRatio_$s$c<= ds1_s1jjD ds_s1jjq;
                              } in  sat_s1jjE;
                          GHC.Types.LT ->
                              let {
                                ds_s1jjF [Occ=OnceL, Dmd=<L,U(U,U)>]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer
                                [LclId] =
                                    [ww_s1jjh ww1_s1jji ww2_s1jjj ww3_s1jjk w_s1jjl] \u []
                                        case w_s1jjl of {
                                          GHC.Real.:% ww8_s1jjH [Occ=Once] ww9_s1jjI [Occ=Once] ->
                                              case
                                                  GHC.Real.$w$s$c-
                                                      ww2_s1jjj ww3_s1jjk ww_s1jjh ww1_s1jji
                                              of
                                              { (#,#) ww11_s1jjK [Occ=Once] ww12_s1jjL [Occ=Once] ->
                                                    case
                                                        GHC.Real.$w$s$c/
                                                            ww11_s1jjK
                                                            ww12_s1jjL
                                                            GHC.Real.even2
                                                            GHC.Real.$fEnumRatio1
                                                    of
                                                    { (#,#) ww14_s1jjN [Occ=Once]
                                                            ww15_s1jjO [Occ=Once] ->
                                                          case
                                                              GHC.Real.$w$s$c+
                                                                  ww8_s1jjH
                                                                  ww9_s1jjI
                                                                  ww14_s1jjN
                                                                  ww15_s1jjO
                                                          of
                                                          { (#,#) ww17_s1jjQ [Occ=Once]
                                                                  ww18_s1jjR [Occ=Once] ->
                                                                GHC.Real.:% [ww17_s1jjQ ww18_s1jjR];
                                                          };
                                                    };
                                              };
                                        }; } in
                              let {
                                sat_s1jjT [Occ=OnceT[0]]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                                [LclId] =
                                    [ds_s1jjF] \r [ds1_s1jjS]
                                        GHC.Real.$fEnumRatio_$s$c>= ds1_s1jjS ds_s1jjF;
                              } in  sat_s1jjT;
                        };
              } in  GHC.List.takeWhile sat_s1jjU sat_s1jjV;
        };

GHC.Real.$fEnumRatio_$snumericEnumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=3,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jjW w1_s1jjX w2_s1jjY]
        case w_s1jjW of {
          GHC.Real.:% ww1_s1jk0 [Occ=Once] ww2_s1jk1 [Occ=Once] ->
              case w1_s1jjX of {
                GHC.Real.:% ww4_s1jk3 [Occ=Once] ww5_s1jk4 [Occ=Once] ->
                    GHC.Real.$w$snumericEnumFromThenTo
                        ww1_s1jk0 ww2_s1jk1 ww4_s1jk3 ww5_s1jk4 w2_s1jjY;
              };
        };

GHC.Real.numericEnumFromThenTo
  :: forall a.
     (GHC.Classes.Ord a, GHC.Real.Fractional a) =>
     a -> a -> a -> [a]
[GblId,
 Arity=5,
 Str=<L,U(A,A,A,C(C1(U)),A,C(C1(U)),A,A)><L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,1*C1(U)),1*C1(C1(U)),A,A)><S,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1jk5
           $dFractional_s1jk6
           eta_s1jk7
           eta1_s1jk8
           eta2_s1jk9]
        case
            GHC.Real.$wnumericEnumFromThen
                $dFractional_s1jk6 eta_s1jk7 eta1_s1jk8
        of
        { (#,#) ww1_s1jkb [Occ=Once] ww2_s1jkc [Occ=Once] ->
              let {
                sat_s1jkp [Occ=Once] :: [a_a1evf]
                [LclId] =
                    CCCS :! [ww1_s1jkb ww2_s1jkc]; } in
              let {
                sat_s1jko [Occ=Once, Dmd=<L,C(U)>] :: a_a1evf -> GHC.Types.Bool
                [LclId] =
                    [$dOrd_s1jk5
                     $dFractional_s1jk6
                     eta_s1jk7
                     eta1_s1jk8
                     eta2_s1jk9] \u []
                        let {
                          $dNum_s1jkd [Dmd=<L,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                            :: GHC.Num.Num a_a1evf
                          [LclId] =
                              [$dFractional_s1jk6] \u []
                                  GHC.Real.$p1Fractional $dFractional_s1jk6; } in
                        let {
                          mid_s1jke [Occ=Once*] :: a_a1evf
                          [LclId] =
                              [$dFractional_s1jk6 eta_s1jk7 eta1_s1jk8 $dNum_s1jkd] \u []
                                  let {
                                    sat_s1jkg [Occ=Once] :: a_a1evf
                                    [LclId] =
                                        [$dNum_s1jkd] \u []
                                            GHC.Num.fromInteger $dNum_s1jkd GHC.Real.even2; } in
                                  let {
                                    sat_s1jkf [Occ=Once] :: a_a1evf
                                    [LclId] =
                                        [eta_s1jk7 eta1_s1jk8 $dNum_s1jkd] \u []
                                            GHC.Num.- $dNum_s1jkd eta1_s1jk8 eta_s1jk7;
                                  } in  GHC.Real./ $dFractional_s1jk6 sat_s1jkf sat_s1jkg;
                        } in 
                          case GHC.Classes.>= $dOrd_s1jk5 eta1_s1jk8 eta_s1jk7 of {
                            GHC.Types.False ->
                                let {
                                  ds_s1jki [Occ=OnceL] :: a_a1evf
                                  [LclId] =
                                      [eta2_s1jk9 $dNum_s1jkd mid_s1jke] \u []
                                          GHC.Num.+ $dNum_s1jkd eta2_s1jk9 mid_s1jke; } in
                                let {
                                  sat_s1jkk [Occ=OnceT[0]] :: a_a1evf -> GHC.Types.Bool
                                  [LclId] =
                                      [$dOrd_s1jk5 ds_s1jki] \r [ds1_s1jkj]
                                          GHC.Classes.>= $dOrd_s1jk5 ds1_s1jkj ds_s1jki;
                                } in  sat_s1jkk;
                            GHC.Types.True ->
                                let {
                                  ds_s1jkl [Occ=OnceL] :: a_a1evf
                                  [LclId] =
                                      [eta2_s1jk9 $dNum_s1jkd mid_s1jke] \u []
                                          GHC.Num.+ $dNum_s1jkd eta2_s1jk9 mid_s1jke; } in
                                let {
                                  sat_s1jkn [Occ=OnceT[0]] :: a_a1evf -> GHC.Types.Bool
                                  [LclId] =
                                      [$dOrd_s1jk5 ds_s1jkl] \r [ds1_s1jkm]
                                          GHC.Classes.<= $dOrd_s1jk5 ds1_s1jkm ds_s1jkl;
                                } in  sat_s1jkn;
                          };
              } in  GHC.List.takeWhile sat_s1jko sat_s1jkp;
        };

GHC.Real.fromIntegral [InlPrag=NOINLINE[1]]
  :: forall a b. (GHC.Real.Integral a, GHC.Num.Num b) => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U))><S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jkq $dNum_s1jkr eta_s1jks]
        let {
          sat_s1jkt [Occ=Once] :: GHC.Integer.Type.Integer
          [LclId] =
              [$dIntegral_s1jkq eta_s1jks] \u []
                  GHC.Real.toInteger $dIntegral_s1jkq eta_s1jks;
        } in  GHC.Num.fromInteger $dNum_s1jkr sat_s1jkt;

GHC.Real.realToFrac [InlPrag=NOINLINE[1]]
  :: forall a b. (GHC.Real.Real a, GHC.Real.Fractional b) => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(U))><S(LLLC(S)),1*U(A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_s1jku $dFractional_s1jkv eta_s1jkw]
        let {
          sat_s1jkx [Occ=Once] :: GHC.Real.Rational
          [LclId] =
              [$dReal_s1jku eta_s1jkw] \u []
                  GHC.Real.toRational $dReal_s1jku eta_s1jkw;
        } in  GHC.Real.fromRational $dFractional_s1jkv sat_s1jkx;

GHC.Real.showSigned1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['-'#];

GHC.Real.showSigned
  :: forall a.
     GHC.Real.Real a =>
     (a -> GHC.Show.ShowS) -> GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)><L,1*C1(U)><L,1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_s1jky eta_s1jkz eta1_s1jkA eta2_s1jkB]
        let {
          $dNum_s1jkC [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>]
            :: GHC.Num.Num a_a1euj
          [LclId] =
              [$dReal_s1jky] \u [] GHC.Real.$p1Real $dReal_s1jky; } in
        let {
          sat_s1jkE [Occ=Once] :: a_a1euj
          [LclId] =
              [$dNum_s1jkC] \u [] GHC.Num.fromInteger $dNum_s1jkC GHC.Real.even1;
        } in 
          case GHC.Real.$p2Real $dReal_s1jky of sat_s1jkD {
            __DEFAULT ->
                case GHC.Classes.< sat_s1jkD eta2_s1jkB sat_s1jkE of {
                  GHC.Types.False -> eta_s1jkz eta2_s1jkB;
                  GHC.Types.True ->
                      case eta1_s1jkA of {
                        GHC.Types.I# x_s1jkH [Occ=Once] ->
                            let {
                              g1_s1jkI [Occ=OnceL*!, Dmd=<L,C(U)>]
                                :: GHC.Base.String -> GHC.Base.String
                              [LclId] =
                                  [eta_s1jkz eta2_s1jkB $dNum_s1jkC] \u []
                                      let {
                                        sat_s1jkJ [Occ=Once] :: a_a1euj
                                        [LclId] =
                                            [eta2_s1jkB $dNum_s1jkC] \u []
                                                GHC.Num.negate $dNum_s1jkC eta2_s1jkB;
                                      } in  eta_s1jkz sat_s1jkJ;
                            } in 
                              case ># [x_s1jkH 6#] of {
                                __DEFAULT ->
                                    let {
                                      sat_s1jkN [Occ=OnceT[0]]
                                        :: GHC.Base.String -> [GHC.Types.Char]
                                      [LclId] =
                                          [g1_s1jkI] \r [x1_s1jkL]
                                              let {
                                                sat_s1jkM [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_s1jkI x1_s1jkL] \u [] g1_s1jkI x1_s1jkL;
                                              } in  : [GHC.Real.showSigned1 sat_s1jkM];
                                    } in  sat_s1jkN;
                                1# ->
                                    let {
                                      sat_s1jkS [Occ=OnceT[0]]
                                        :: GHC.Base.String -> [GHC.Types.Char]
                                      [LclId] =
                                          [g1_s1jkI] \r [x1_s1jkO]
                                              let {
                                                sat_s1jkQ [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_s1jkI x1_s1jkO] \u []
                                                        let {
                                                          sat_s1jkP [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2
                                                                       x1_s1jkO];
                                                        } in  g1_s1jkI sat_s1jkP; } in
                                              let {
                                                sat_s1jkR [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    CCCS :! [GHC.Real.showSigned1 sat_s1jkQ];
                                              } in  : [GHC.Show.$fShow(,)4 sat_s1jkR];
                                    } in  sat_s1jkS;
                              };
                      };
                };
          };

GHC.Real.even [InlPrag=INLINABLE]
  :: forall a. GHC.Real.Integral a => a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,1*C1(C1(U)),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jkT eta_s1jkU]
        case
            GHC.Real.$p1Integral $dIntegral_s1jkT
        of
        $dReal_s1jkV [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jkW [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_a1eq0
                [LclId] =
                    [$dReal_s1jkV] \u [] GHC.Real.$p1Real $dReal_s1jkV; } in
              let {
                sat_s1jl1 [Occ=Once] :: a_a1eq0
                [LclId] =
                    [$dNum_s1jkW] \u []
                        GHC.Num.fromInteger $dNum_s1jkW GHC.Real.even1; } in
              let {
                sat_s1jl0 [Occ=Once] :: a_a1eq0
                [LclId] =
                    [$dIntegral_s1jkT eta_s1jkU $dNum_s1jkW] \u []
                        let {
                          sat_s1jkZ [Occ=Once] :: a_a1eq0
                          [LclId] =
                              [$dNum_s1jkW] \u [] GHC.Num.fromInteger $dNum_s1jkW GHC.Real.even2;
                        } in  GHC.Real.rem $dIntegral_s1jkT eta_s1jkU sat_s1jkZ;
              } in 
                case GHC.Real.$p2Real $dReal_s1jkV of sat_s1jkX {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_s1jkX of sat_s1jkY {
                        __DEFAULT -> GHC.Classes.== sat_s1jkY sat_s1jl0 sat_s1jl1;
                      };
                };
        };

GHC.Real.odd [InlPrag=INLINABLE]
  :: forall a. GHC.Real.Integral a => a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jl2 x_s1jl3]
        case GHC.Real.even $dIntegral_s1jl2 x_s1jl3 of {
          GHC.Types.False -> GHC.Types.True [];
          GHC.Types.True -> GHC.Types.False [];
        };

lvl3_r1j3b :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.$fEnumRatio1 GHC.Real.even2];

lvl4_r1j3c :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "round default defn: Bad value"#;

GHC.Real.$fRealFracRatio1 :: forall b. b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl4_r1j3c of sat_s1jl5 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1jl5;
        };

GHC.Real.$dmround
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,A,A,1*C1(U)),1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U(U(U,U),U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1jl6 eta_s1jl7 eta1_s1jl8]
        let {
          ds_s1jl9 [Dmd=<L,U(1*U,1*U)>] :: (b_a1eBu, a_a1dNs)
          [LclId] =
              [$dRealFrac_s1jl6 eta_s1jl7 eta1_s1jl8] \u []
                  GHC.Real.properFraction $dRealFrac_s1jl6 eta_s1jl7 eta1_s1jl8;
        } in 
          case
              GHC.Real.$p1RealFrac $dRealFrac_s1jl6
          of
          $dReal_s1jla [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p2Real $dReal_s1jla
                of
                $dOrd_s1jlb [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Classes.$p1Ord $dOrd_s1jlb
                      of
                      $dEq_s1jlc [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                      { __DEFAULT ->
                            let {
                              $dNum_s1jld [Dmd=<L,U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U))>]
                                :: GHC.Num.Num a_a1dNs
                              [LclId] =
                                  [$dReal_s1jla] \u [] GHC.Real.$p1Real $dReal_s1jla; } in
                            let {
                              r_s1jle :: a_a1dNs
                              [LclId] =
                                  [ds_s1jl9] \u []
                                      case ds_s1jl9 of {
                                        (,) _ [Occ=Dead] r1_s1jlh [Occ=Once] -> r1_s1jlh;
                                      }; } in
                            let {
                              ds1_s1jli :: a_a1dNs
                              [LclId] =
                                  [$dRealFrac_s1jl6 $dNum_s1jld r_s1jle] \u []
                                      let {
                                        sat_s1jlm [Occ=Once] :: a_a1dNs
                                        [LclId] =
                                            [$dRealFrac_s1jl6 $dNum_s1jld r_s1jle] \u []
                                                let {
                                                  sat_s1jll [Occ=Once] :: a_a1dNs
                                                  [LclId] =
                                                      [$dRealFrac_s1jl6] \u []
                                                          case
                                                              GHC.Real.$p2RealFrac $dRealFrac_s1jl6
                                                          of
                                                          sat_s1jlk
                                                          { __DEFAULT ->
                                                                GHC.Real.fromRational
                                                                    sat_s1jlk lvl3_r1j3b;
                                                          }; } in
                                                let {
                                                  sat_s1jlj [Occ=Once] :: a_a1dNs
                                                  [LclId] =
                                                      [$dNum_s1jld r_s1jle] \u []
                                                          GHC.Num.abs $dNum_s1jld r_s1jle;
                                                } in  GHC.Num.- $dNum_s1jld sat_s1jlj sat_s1jll;
                                      } in  GHC.Num.signum $dNum_s1jld sat_s1jlm; } in
                            let {
                              n_s1jln :: b_a1eBu
                              [LclId] =
                                  [ds_s1jl9] \u []
                                      case ds_s1jl9 of {
                                        (,) n1_s1jlp [Occ=Once] _ [Occ=Dead] -> n1_s1jlp;
                                      }; } in
                            let {
                              sat_s1jls [Occ=Once] :: a_a1dNs
                              [LclId] =
                                  [$dNum_s1jld] \u []
                                      let {
                                        sat_s1jlr [Occ=Once] :: a_a1dNs
                                        [LclId] =
                                            [$dNum_s1jld] \u []
                                                GHC.Num.fromInteger
                                                    $dNum_s1jld GHC.Real.$fEnumRatio1;
                                      } in  GHC.Num.negate $dNum_s1jld sat_s1jlr;
                            } in 
                              case GHC.Classes.== $dEq_s1jlc ds1_s1jli sat_s1jls of {
                                GHC.Types.False ->
                                    let {
                                      sat_s1jlB [Occ=Once] :: a_a1dNs
                                      [LclId] =
                                          [$dNum_s1jld] \u []
                                              GHC.Num.fromInteger $dNum_s1jld GHC.Real.even1;
                                    } in 
                                      let-no-escape {
                                        m_s1jlu [Occ=Once*T[0], Dmd=<L,1*U>] :: b_a1eBu
                                        [LclId[JoinId(0)], Unf=OtherCon []] =
                                            [eta_s1jl7
                                             $dOrd_s1jlb
                                             $dNum_s1jld
                                             r_s1jle
                                             n_s1jln] \r []
                                                case
                                                    GHC.Real.$p1Integral eta_s1jl7
                                                of
                                                $dReal1_s1jlv [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                                { __DEFAULT ->
                                                      case
                                                          GHC.Real.$p1Real $dReal1_s1jlv
                                                      of
                                                      $dNum1_s1jlw [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                                      { __DEFAULT ->
                                                            let {
                                                              sat_s1jlx [Occ=Once] :: a_a1dNs
                                                              [LclId] =
                                                                  [$dNum_s1jld] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_s1jld
                                                                          GHC.Real.even1;
                                                            } in 
                                                              case
                                                                  GHC.Classes.<
                                                                      $dOrd_s1jlb r_s1jle sat_s1jlx
                                                              of
                                                              { GHC.Types.False ->
                                                                    let {
                                                                      sat_s1jlz [Occ=Once]
                                                                        :: b_a1eBu
                                                                      [LclId] =
                                                                          [$dNum1_s1jlw] \u []
                                                                              GHC.Num.fromInteger
                                                                                  $dNum1_s1jlw
                                                                                  GHC.Real.$fEnumRatio1;
                                                                    } in 
                                                                      GHC.Num.+
                                                                          $dNum1_s1jlw
                                                                          n_s1jln
                                                                          sat_s1jlz;
                                                                GHC.Types.True ->
                                                                    let {
                                                                      sat_s1jlA [Occ=Once]
                                                                        :: b_a1eBu
                                                                      [LclId] =
                                                                          [$dNum1_s1jlw] \u []
                                                                              GHC.Num.fromInteger
                                                                                  $dNum1_s1jlw
                                                                                  GHC.Real.$fEnumRatio1;
                                                                    } in 
                                                                      GHC.Num.-
                                                                          $dNum1_s1jlw
                                                                          n_s1jln
                                                                          sat_s1jlA;
                                                              };
                                                      };
                                                };
                                      } in 
                                        case GHC.Classes.== $dEq_s1jlc ds1_s1jli sat_s1jlB of {
                                          GHC.Types.False ->
                                              let {
                                                sat_s1jlD [Occ=Once] :: a_a1dNs
                                                [LclId] =
                                                    [$dNum_s1jld] \u []
                                                        GHC.Num.fromInteger
                                                            $dNum_s1jld GHC.Real.$fEnumRatio1;
                                              } in 
                                                case
                                                    GHC.Classes.== $dEq_s1jlc ds1_s1jli sat_s1jlD
                                                of
                                                { GHC.Types.False -> GHC.Real.$fRealFracRatio1;
                                                  GHC.Types.True -> m_s1jlu;
                                                };
                                          GHC.Types.True ->
                                              case GHC.Real.even eta_s1jl7 n_s1jln of {
                                                GHC.Types.False -> m_s1jlu;
                                                GHC.Types.True -> n_s1jln;
                                              };
                                        };
                                GHC.Types.True -> n_s1jln;
                              };
                      };
                };
          };

GHC.Real.integralEnumFrom
  :: forall a. (GHC.Real.Integral a, GHC.Enum.Bounded a) => a -> [a]
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,1*U(A,1*U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jlG $dBounded_s1jlH eta_s1jlI]
        let {
          f_s1jlJ [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
            :: GHC.Real.Real a_a1eoa
          [LclId] =
              [$dIntegral_s1jlG] \s []
                  GHC.Real.$p1Integral $dIntegral_s1jlG; } in
        let {
          f1_s1jlK [Occ=OnceL, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
            :: GHC.Num.Num a_a1eoa
          [LclId] =
              [f_s1jlJ] \u [] GHC.Real.$p1Real f_s1jlJ; } in
        let {
          sat_s1jlM [Occ=Once] :: a_a1eoa
          [LclId] =
              [$dBounded_s1jlH] \u [] GHC.Enum.maxBound $dBounded_s1jlH;
        } in 
          case
              GHC.Real.toInteger $dIntegral_s1jlG sat_s1jlM
          of
          lim_s1jlL [Dmd=<S,U>]
          { __DEFAULT ->
                let {
                  go_s1jlN [Occ=LoopBreaker] :: GHC.Integer.Type.Integer -> [a_a1eoa]
                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                      sat-only [f1_s1jlK lim_s1jlL go_s1jlN] \r [x_s1jlO]
                          case GHC.Integer.Type.gtInteger# x_s1jlO lim_s1jlL of {
                            __DEFAULT ->
                                let {
                                  sat_s1jlS [Occ=Once] :: [a_a1eoa]
                                  [LclId] =
                                      [go_s1jlN x_s1jlO] \u []
                                          case
                                              GHC.Integer.Type.plusInteger
                                                  x_s1jlO GHC.Real.$fEnumRatio1
                                          of
                                          sat_s1jlR
                                          { __DEFAULT -> go_s1jlN sat_s1jlR;
                                          }; } in
                                let {
                                  sat_s1jlQ [Occ=Once] :: a_a1eoa
                                  [LclId] =
                                      [f1_s1jlK x_s1jlO] \u [] GHC.Num.fromInteger f1_s1jlK x_s1jlO;
                                } in  : [sat_s1jlQ sat_s1jlS];
                            1# -> [] [];
                          };
                } in 
                  case GHC.Real.toInteger $dIntegral_s1jlG eta_s1jlI of sat_s1jlT {
                    __DEFAULT -> go_s1jlN sat_s1jlT;
                  };
          };

GHC.Real.integralEnumFromThen
  :: forall a.
     (GHC.Real.Integral a, GHC.Enum.Bounded a) =>
     a -> a -> [a]
[GblId,
 Arity=4,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,1*U(1*U,1*U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jlU $dBounded_s1jlV eta_s1jlW eta1_s1jlX]
        case
            GHC.Real.toInteger $dIntegral_s1jlU eta1_s1jlX
        of
        i_n2_s1jlY [Dmd=<S,U>]
        { __DEFAULT ->
              case
                  GHC.Real.toInteger $dIntegral_s1jlU eta_s1jlW
              of
              i_n1_s1jlZ [Dmd=<S,U>]
              { __DEFAULT ->
                    case GHC.Integer.Type.geInteger# i_n2_s1jlY i_n1_s1jlZ of {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.minusInteger i_n2_s1jlY i_n1_s1jlZ
                          of
                          delta_s1jm1 [Dmd=<S,U>]
                          { __DEFAULT ->
                                let {
                                  f_s1jm2 [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
                                    :: GHC.Real.Real a_a1enm
                                  [LclId] =
                                      [$dIntegral_s1jlU] \s []
                                          GHC.Real.$p1Integral $dIntegral_s1jlU; } in
                                let {
                                  f1_s1jm3 [Occ=OnceL*, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
                                    :: GHC.Num.Num a_a1enm
                                  [LclId] =
                                      [f_s1jm2] \u [] GHC.Real.$p1Real f_s1jm2;
                                } in 
                                  case GHC.Integer.Type.geInteger# delta_s1jm1 GHC.Real.even1 of {
                                    __DEFAULT ->
                                        let {
                                          sat_s1jm6 [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1jlV] \u []
                                                  GHC.Enum.minBound $dBounded_s1jlV;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1jlU sat_s1jm6
                                          of
                                          lim_s1jm5 [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1jm7 [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1jm1
                                                                f1_s1jm3
                                                                lim_s1jm5
                                                                go_s1jm7] \r [x_s1jm8]
                                                          case
                                                              GHC.Integer.Type.ltInteger#
                                                                  x_s1jm8 lim_s1jm5
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1jmc [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1jm1
                                                                       go_s1jm7
                                                                       x_s1jm8] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1jm8
                                                                                  delta_s1jm1
                                                                          of
                                                                          sat_s1jmb
                                                                          { __DEFAULT ->
                                                                                go_s1jm7 sat_s1jmb;
                                                                          }; } in
                                                                let {
                                                                  sat_s1jma [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1jm3 x_s1jm8] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1jm3 x_s1jm8;
                                                                } in  : [sat_s1jma sat_s1jmc];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1jm7 i_n1_s1jlZ;
                                          };
                                    1# ->
                                        let {
                                          sat_s1jme [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1jlV] \u []
                                                  GHC.Enum.minBound $dBounded_s1jlV;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1jlU sat_s1jme
                                          of
                                          lim_s1jmd [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1jmf [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1jm1
                                                                f1_s1jm3
                                                                lim_s1jmd
                                                                go_s1jmf] \r [x_s1jmg]
                                                          case
                                                              GHC.Integer.Type.gtInteger#
                                                                  x_s1jmg lim_s1jmd
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1jmk [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1jm1
                                                                       go_s1jmf
                                                                       x_s1jmg] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1jmg
                                                                                  delta_s1jm1
                                                                          of
                                                                          sat_s1jmj
                                                                          { __DEFAULT ->
                                                                                go_s1jmf sat_s1jmj;
                                                                          }; } in
                                                                let {
                                                                  sat_s1jmi [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1jm3 x_s1jmg] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1jm3 x_s1jmg;
                                                                } in  : [sat_s1jmi sat_s1jmk];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1jmf i_n1_s1jlZ;
                                          };
                                  };
                          };
                      1# ->
                          case
                              GHC.Integer.Type.minusInteger i_n2_s1jlY i_n1_s1jlZ
                          of
                          delta_s1jml [Dmd=<S,U>]
                          { __DEFAULT ->
                                let {
                                  f_s1jmm [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
                                    :: GHC.Real.Real a_a1enm
                                  [LclId] =
                                      [$dIntegral_s1jlU] \s []
                                          GHC.Real.$p1Integral $dIntegral_s1jlU; } in
                                let {
                                  f1_s1jmn [Occ=OnceL*, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
                                    :: GHC.Num.Num a_a1enm
                                  [LclId] =
                                      [f_s1jmm] \u [] GHC.Real.$p1Real f_s1jmm;
                                } in 
                                  case GHC.Integer.Type.geInteger# delta_s1jml GHC.Real.even1 of {
                                    __DEFAULT ->
                                        let {
                                          sat_s1jmq [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1jlV] \u []
                                                  GHC.Enum.maxBound $dBounded_s1jlV;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1jlU sat_s1jmq
                                          of
                                          lim_s1jmp [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1jmr [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1jml
                                                                f1_s1jmn
                                                                lim_s1jmp
                                                                go_s1jmr] \r [x_s1jms]
                                                          case
                                                              GHC.Integer.Type.ltInteger#
                                                                  x_s1jms lim_s1jmp
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1jmw [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1jml
                                                                       go_s1jmr
                                                                       x_s1jms] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1jms
                                                                                  delta_s1jml
                                                                          of
                                                                          sat_s1jmv
                                                                          { __DEFAULT ->
                                                                                go_s1jmr sat_s1jmv;
                                                                          }; } in
                                                                let {
                                                                  sat_s1jmu [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1jmn x_s1jms] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1jmn x_s1jms;
                                                                } in  : [sat_s1jmu sat_s1jmw];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1jmr i_n1_s1jlZ;
                                          };
                                    1# ->
                                        let {
                                          sat_s1jmy [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1jlV] \u []
                                                  GHC.Enum.maxBound $dBounded_s1jlV;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1jlU sat_s1jmy
                                          of
                                          lim_s1jmx [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1jmz [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1jml
                                                                f1_s1jmn
                                                                lim_s1jmx
                                                                go_s1jmz] \r [x_s1jmA]
                                                          case
                                                              GHC.Integer.Type.gtInteger#
                                                                  x_s1jmA lim_s1jmx
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1jmE [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1jml
                                                                       go_s1jmz
                                                                       x_s1jmA] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1jmA
                                                                                  delta_s1jml
                                                                          of
                                                                          sat_s1jmD
                                                                          { __DEFAULT ->
                                                                                go_s1jmz sat_s1jmD;
                                                                          }; } in
                                                                let {
                                                                  sat_s1jmC [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1jmn x_s1jmA] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1jmn x_s1jmA;
                                                                } in  : [sat_s1jmC sat_s1jmE];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1jmz i_n1_s1jlZ;
                                          };
                                  };
                          };
                    };
              };
        };

GHC.Real.integralEnumFromTo
  :: forall a. GHC.Real.Integral a => a -> a -> [a]
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jmF eta_s1jmG eta1_s1jmH]
        let {
          f_s1jmI [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
            :: GHC.Real.Real a_a1en9
          [LclId] =
              [$dIntegral_s1jmF] \s []
                  GHC.Real.$p1Integral $dIntegral_s1jmF; } in
        let {
          f1_s1jmJ [Occ=OnceL, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
            :: GHC.Num.Num a_a1en9
          [LclId] =
              [f_s1jmI] \u [] GHC.Real.$p1Real f_s1jmI;
        } in 
          case
              GHC.Real.toInteger $dIntegral_s1jmF eta1_s1jmH
          of
          lim_s1jmK [Dmd=<S,U>]
          { __DEFAULT ->
                let {
                  go_s1jmL [Occ=LoopBreaker] :: GHC.Integer.Type.Integer -> [a_a1en9]
                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                      sat-only [f1_s1jmJ lim_s1jmK go_s1jmL] \r [x_s1jmM]
                          case GHC.Integer.Type.gtInteger# x_s1jmM lim_s1jmK of {
                            __DEFAULT ->
                                let {
                                  sat_s1jmQ [Occ=Once] :: [a_a1en9]
                                  [LclId] =
                                      [go_s1jmL x_s1jmM] \u []
                                          case
                                              GHC.Integer.Type.plusInteger
                                                  x_s1jmM GHC.Real.$fEnumRatio1
                                          of
                                          sat_s1jmP
                                          { __DEFAULT -> go_s1jmL sat_s1jmP;
                                          }; } in
                                let {
                                  sat_s1jmO [Occ=Once] :: a_a1en9
                                  [LclId] =
                                      [f1_s1jmJ x_s1jmM] \u [] GHC.Num.fromInteger f1_s1jmJ x_s1jmM;
                                } in  : [sat_s1jmO sat_s1jmQ];
                            1# -> [] [];
                          };
                } in 
                  case GHC.Real.toInteger $dIntegral_s1jmF eta_s1jmG of sat_s1jmR {
                    __DEFAULT -> go_s1jmL sat_s1jmR;
                  };
          };

GHC.Real.integralEnumFromThenTo
  :: forall a. GHC.Real.Integral a => a -> a -> a -> [a]
[GblId,
 Arity=4,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jmS eta_s1jmT eta1_s1jmU eta2_s1jmV]
        case
            GHC.Real.toInteger $dIntegral_s1jmS eta_s1jmT
        of
        x_s1jmW [Dmd=<S,U>]
        { __DEFAULT ->
              case GHC.Real.toInteger $dIntegral_s1jmS eta1_s1jmU of sat_s1jmY {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.minusInteger sat_s1jmY x_s1jmW
                    of
                    delta_s1jmX [Dmd=<S,U>]
                    { __DEFAULT ->
                          let {
                            f_s1jmZ [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
                              :: GHC.Real.Real a_a1emS
                            [LclId] =
                                [$dIntegral_s1jmS] \s []
                                    GHC.Real.$p1Integral $dIntegral_s1jmS; } in
                          let {
                            f1_s1jn0 [Occ=OnceL*, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
                              :: GHC.Num.Num a_a1emS
                            [LclId] =
                                [f_s1jmZ] \u [] GHC.Real.$p1Real f_s1jmZ;
                          } in 
                            case GHC.Integer.Type.geInteger# delta_s1jmX GHC.Real.even1 of {
                              __DEFAULT ->
                                  case
                                      GHC.Real.toInteger $dIntegral_s1jmS eta2_s1jmV
                                  of
                                  lim_s1jn2 [Dmd=<S,U>]
                                  { __DEFAULT ->
                                        let {
                                          go_s1jn3 [Occ=LoopBreaker]
                                            :: GHC.Integer.Type.Integer -> [a_a1emS]
                                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                              sat-only [delta_s1jmX
                                                        f1_s1jn0
                                                        lim_s1jn2
                                                        go_s1jn3] \r [x1_s1jn4]
                                                  case
                                                      GHC.Integer.Type.ltInteger# x1_s1jn4 lim_s1jn2
                                                  of
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_s1jn8 [Occ=Once] :: [a_a1emS]
                                                          [LclId] =
                                                              [delta_s1jmX go_s1jn3 x1_s1jn4] \u []
                                                                  case
                                                                      GHC.Integer.Type.plusInteger
                                                                          x1_s1jn4 delta_s1jmX
                                                                  of
                                                                  sat_s1jn7
                                                                  { __DEFAULT -> go_s1jn3 sat_s1jn7;
                                                                  }; } in
                                                        let {
                                                          sat_s1jn6 [Occ=Once] :: a_a1emS
                                                          [LclId] =
                                                              [f1_s1jn0 x1_s1jn4] \u []
                                                                  GHC.Num.fromInteger
                                                                      f1_s1jn0 x1_s1jn4;
                                                        } in  : [sat_s1jn6 sat_s1jn8];
                                                    1# -> [] [];
                                                  };
                                        } in  go_s1jn3 x_s1jmW;
                                  };
                              1# ->
                                  case
                                      GHC.Real.toInteger $dIntegral_s1jmS eta2_s1jmV
                                  of
                                  lim_s1jn9 [Dmd=<S,U>]
                                  { __DEFAULT ->
                                        let {
                                          go_s1jna [Occ=LoopBreaker]
                                            :: GHC.Integer.Type.Integer -> [a_a1emS]
                                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                              sat-only [delta_s1jmX
                                                        f1_s1jn0
                                                        lim_s1jn9
                                                        go_s1jna] \r [x1_s1jnb]
                                                  case
                                                      GHC.Integer.Type.gtInteger# x1_s1jnb lim_s1jn9
                                                  of
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_s1jnf [Occ=Once] :: [a_a1emS]
                                                          [LclId] =
                                                              [delta_s1jmX go_s1jna x1_s1jnb] \u []
                                                                  case
                                                                      GHC.Integer.Type.plusInteger
                                                                          x1_s1jnb delta_s1jmX
                                                                  of
                                                                  sat_s1jne
                                                                  { __DEFAULT -> go_s1jna sat_s1jne;
                                                                  }; } in
                                                        let {
                                                          sat_s1jnd [Occ=Once] :: a_a1emS
                                                          [LclId] =
                                                              [f1_s1jn0 x1_s1jnb] \u []
                                                                  GHC.Num.fromInteger
                                                                      f1_s1jn0 x1_s1jnb;
                                                        } in  : [sat_s1jnd sat_s1jnf];
                                                    1# -> [] [];
                                                  };
                                        } in  go_s1jna x_s1jmW;
                                  };
                            };
                    };
              };
        };

GHC.Real.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Real.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$trModule4];

GHC.Real.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Real"#;

GHC.Real.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$trModule2];

GHC.Real.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Real.$trModule3
                                     GHC.Real.$trModule1];

$krep_r1j3d :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Integer.Type.$tcInteger
                                              GHC.Types.[]];

$krep1_r1j3e :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.Real.$tcFractional1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*
                                         $krep1_r1j3e];

$krep2_r1j3f :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep3_r1j3g :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep2_r1j3f];

$krep4_r1j3h :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep3_r1j3g];

$krep5_r1j3i :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep_r1j3d];

$krep6_r1j3j :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_r1j3f GHC.Types.[]];

$krep7_r1j3k :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_r1j3f $krep6_r1j3j];

$krep8_r1j3l :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc(,)
                                              $krep7_r1j3k];

$krep9_r1j3m :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep8_r1j3l];

$krep10_r1j3n :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep9_r1j3m];

$krep11_r1j3o :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Num.$tcNum
                                              $krep6_r1j3j];

$krep12_r1j3p :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Enum.$tcEnum
                                              $krep6_r1j3j];

$krep13_r1j3q :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Classes.$tcOrd
                                              $krep6_r1j3j];

GHC.Real.$tcRatio2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Ratio"#;

GHC.Real.$tcRatio1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcRatio2];

GHC.Real.$tcRatio :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17658523810845794968##
                                    1271393732863050253##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcRatio1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep14_r1j3r :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcRatio
                                              $krep6_r1j3j];

$krep15_r1j3s :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep14_r1j3r];

GHC.Real.$tc':%1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep15_r1j3s];

GHC.Real.$tc':%3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "':%"#;

GHC.Real.$tc':%2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc':%3];

GHC.Real.$tc':% :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11952989868638128372##
                                    6861245286732044789##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc':%2
                                    1#
                                    GHC.Real.$tc':%1];

$krep16_r1j3t :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r1j3d GHC.Types.[]];

$krep17_r1j3u :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcRatio
                                              $krep16_r1j3t];

$krep18_r1j3v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep17_r1j3u];

$krep19_r1j3w :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep17_r1j3u $krep2_r1j3f];

GHC.Real.$tcReal2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Real"#;

GHC.Real.$tcReal1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcReal2];

GHC.Real.$tcReal :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1826502536394630182##
                                    14487785779892251413##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcReal1
                                    0#
                                    GHC.Real.$tcFractional1];

$krep20_r1j3x :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcReal
                                              $krep6_r1j3j];

$krep21_r1j3y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep18_r1j3v $krep20_r1j3x];

$krep22_r1j3z :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep13_r1j3q $krep21_r1j3y];

GHC.Real.$tc'C:Real1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1j3o $krep22_r1j3z];

GHC.Real.$tc'C:Real3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Real"#;

GHC.Real.$tc'C:Real2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc'C:Real3];

GHC.Real.$tc'C:Real :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5938283050841830427##
                                    8926187074226767634##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc'C:Real2
                                    1#
                                    GHC.Real.$tc'C:Real1];

GHC.Real.$tcIntegral2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Integral"#;

GHC.Real.$tcIntegral1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcIntegral2];

GHC.Real.$tcIntegral :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16601157811546713973##
                                    3304955164956033666##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcIntegral1
                                    0#
                                    GHC.Real.$tcFractional1];

$krep23_r1j3A :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcIntegral
                                              $krep6_r1j3j];

$krep24_r1j3B :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r1j3i $krep23_r1j3A];

$krep25_r1j3C :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_r1j3n $krep24_r1j3B];

$krep26_r1j3D :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_r1j3n $krep25_r1j3C];

$krep27_r1j3E :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep26_r1j3D];

$krep28_r1j3F :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep27_r1j3E];

$krep29_r1j3G :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep28_r1j3F];

$krep30_r1j3H :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep29_r1j3G];

$krep31_r1j3I :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep12_r1j3p $krep30_r1j3H];

GHC.Real.$tc'C:Integral1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep20_r1j3x $krep31_r1j3I];

GHC.Real.$tc'C:Integral3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Integral"#;

GHC.Real.$tc'C:Integral2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc'C:Integral3];

GHC.Real.$tc'C:Integral :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12141017740256829283##
                                    17564033539811245778##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc'C:Integral2
                                    1#
                                    GHC.Real.$tc'C:Integral1];

GHC.Real.$tcFractional3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Fractional"#;

GHC.Real.$tcFractional2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcFractional3];

GHC.Real.$tcFractional :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14968870971062750857##
                                    13774835939651899219##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcFractional2
                                    0#
                                    GHC.Real.$tcFractional1];

$krep32_r1j3J :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcFractional
                                              $krep6_r1j3j];

$krep33_r1j3K :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep19_r1j3w $krep32_r1j3J];

$krep34_r1j3L :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r1j3g $krep33_r1j3K];

$krep35_r1j3M :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep34_r1j3L];

GHC.Real.$tc'C:Fractional1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1j3o $krep35_r1j3M];

GHC.Real.$tc'C:Fractional3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Fractional"#;

GHC.Real.$tc'C:Fractional2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc'C:Fractional3];

GHC.Real.$tc'C:Fractional :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15706435530565718930##
                                    11021884564355505453##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc'C:Fractional2
                                    1#
                                    GHC.Real.$tc'C:Fractional1];

GHC.Real.$tcRealFrac2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "RealFrac"#;

GHC.Real.$tcRealFrac1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcRealFrac2];

GHC.Real.$tcRealFrac :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2318913099678420819##
                                    6373121509494083706##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcRealFrac1
                                    0#
                                    GHC.Real.$tcFractional1];

GHC.Real.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     a -> a -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jng ww_s1jnh ww1_s1jni ww2_s1jnj ww3_s1jnk]
        case
            GHC.Real.$p1Integral w_s1jng
        of
        $dReal_s1jnl [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jnm [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
                  :: GHC.Num.Num a_s1hBR
                [LclId] =
                    [$dReal_s1jnl] \u [] GHC.Real.$p1Real $dReal_s1jnl; } in
              let {
                sat_s1jnp [Occ=Once] :: a_s1hBR
                [LclId] =
                    [ww1_s1jni ww2_s1jnj $dNum_s1jnm] \u []
                        GHC.Num.* $dNum_s1jnm ww2_s1jnj ww1_s1jni; } in
              let {
                sat_s1jno [Occ=Once] :: a_s1hBR
                [LclId] =
                    [ww_s1jnh ww3_s1jnk $dNum_s1jnm] \u []
                        GHC.Num.* $dNum_s1jnm ww_s1jnh ww3_s1jnk;
              } in 
                case GHC.Real.$p2Real $dReal_s1jnl of sat_s1jnn {
                  __DEFAULT -> GHC.Classes.< sat_s1jnn sat_s1jno sat_s1jnp;
                };
        };

GHC.Real.$fOrdRatio_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jnq w1_s1jnr w2_s1jns]
        case w1_s1jnr of {
          GHC.Real.:% ww1_s1jnu [Occ=Once] ww2_s1jnv [Occ=Once] ->
              case w2_s1jns of {
                GHC.Real.:% ww4_s1jnx [Occ=Once] ww5_s1jny [Occ=Once] ->
                    GHC.Real.$w$c< w_s1jnq ww1_s1jnu ww2_s1jnv ww4_s1jnx ww5_s1jny;
              };
        };

GHC.Real.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     a -> a -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jnz ww_s1jnA ww1_s1jnB ww2_s1jnC ww3_s1jnD]
        case
            GHC.Real.$p1Integral w_s1jnz
        of
        $dReal_s1jnE [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jnF [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
                  :: GHC.Num.Num a_s1hC6
                [LclId] =
                    [$dReal_s1jnE] \u [] GHC.Real.$p1Real $dReal_s1jnE; } in
              let {
                sat_s1jnI [Occ=Once] :: a_s1hC6
                [LclId] =
                    [ww1_s1jnB ww2_s1jnC $dNum_s1jnF] \u []
                        GHC.Num.* $dNum_s1jnF ww2_s1jnC ww1_s1jnB; } in
              let {
                sat_s1jnH [Occ=Once] :: a_s1hC6
                [LclId] =
                    [ww_s1jnA ww3_s1jnD $dNum_s1jnF] \u []
                        GHC.Num.* $dNum_s1jnF ww_s1jnA ww3_s1jnD;
              } in 
                case GHC.Real.$p2Real $dReal_s1jnE of sat_s1jnG {
                  __DEFAULT -> GHC.Classes.<= sat_s1jnG sat_s1jnH sat_s1jnI;
                };
        };

GHC.Real.$fOrdRatio_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jnJ w1_s1jnK w2_s1jnL]
        case w1_s1jnK of {
          GHC.Real.:% ww1_s1jnN [Occ=Once] ww2_s1jnO [Occ=Once] ->
              case w2_s1jnL of {
                GHC.Real.:% ww4_s1jnQ [Occ=Once] ww5_s1jnR [Occ=Once] ->
                    GHC.Real.$w$c<= w_s1jnJ ww1_s1jnN ww2_s1jnO ww4_s1jnQ ww5_s1jnR;
              };
        };

GHC.Real.$fOrdRatio_$cmax
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jnS x_s1jnT y_s1jnU]
        case x_s1jnT of ww_s1jnV {
          GHC.Real.:% ww1_s1jnW [Occ=Once] ww2_s1jnX [Occ=Once] ->
              case y_s1jnU of ww3_s1jnY {
                GHC.Real.:% ww4_s1jnZ [Occ=Once] ww5_s1jo0 [Occ=Once] ->
                    case
                        GHC.Real.$w$c<=
                            $dIntegral_s1jnS ww1_s1jnW ww2_s1jnX ww4_s1jnZ ww5_s1jo0
                    of
                    { GHC.Types.False -> ww_s1jnV;
                      GHC.Types.True -> ww3_s1jnY;
                    };
              };
        };

GHC.Real.$fOrdRatio_$cmin
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jo2 x_s1jo3 y_s1jo4]
        case x_s1jo3 of ww_s1jo5 {
          GHC.Real.:% ww1_s1jo6 [Occ=Once] ww2_s1jo7 [Occ=Once] ->
              case y_s1jo4 of ww3_s1jo8 {
                GHC.Real.:% ww4_s1jo9 [Occ=Once] ww5_s1joa [Occ=Once] ->
                    case
                        GHC.Real.$w$c<=
                            $dIntegral_s1jo2 ww1_s1jo6 ww2_s1jo7 ww4_s1jo9 ww5_s1joa
                    of
                    { GHC.Types.False -> ww3_s1jo8;
                      GHC.Types.True -> ww_s1jo5;
                    };
              };
        };

GHC.Real.$w$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     a -> a -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(1*U(A,A,C(C1(U)),A,A,A,A),U(1*U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1joc ww_s1jod ww1_s1joe ww2_s1jof ww3_s1jog]
        case
            GHC.Real.$p1Integral w_s1joc
        of
        $dEq_s1joh [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p2Real $dEq_s1joh
              of
              $dEq1_s1joi [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Classes.$p1Ord $dEq1_s1joi
                    of
                    $dEq2_s1joj [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                    { __DEFAULT ->
                          case GHC.Classes.== $dEq2_s1joj ww_s1jod ww2_s1jof of {
                            GHC.Types.False ->
                                case
                                    GHC.Real.$w$c<= w_s1joc ww_s1jod ww1_s1joe ww2_s1jof ww3_s1jog
                                of
                                { GHC.Types.False -> GHC.Types.GT [];
                                  GHC.Types.True -> GHC.Types.LT [];
                                };
                            GHC.Types.True ->
                                case GHC.Classes.== $dEq2_s1joj ww1_s1joe ww3_s1jog of {
                                  GHC.Types.False ->
                                      case
                                          GHC.Real.$w$c<=
                                              w_s1joc ww_s1jod ww1_s1joe ww2_s1jof ww3_s1jog
                                      of
                                      { GHC.Types.False -> GHC.Types.GT [];
                                        GHC.Types.True -> GHC.Types.LT [];
                                      };
                                  GHC.Types.True -> GHC.Types.EQ [];
                                };
                          };
                    };
              };
        };

GHC.Real.$fOrdRatio_$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1joo w1_s1jop w2_s1joq]
        case w1_s1jop of {
          GHC.Real.:% ww1_s1jos [Occ=Once] ww2_s1jot [Occ=Once] ->
              case w2_s1joq of {
                GHC.Real.:% ww4_s1jov [Occ=Once] ww5_s1jow [Occ=Once] ->
                    GHC.Real.$w$ccompare
                        w_s1joo ww1_s1jos ww2_s1jot ww4_s1jov ww5_s1jow;
              };
        };

GHC.Real.$fOrdRatio_$c>
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jox x_s1joy y_s1joz]
        case x_s1joy of {
          GHC.Real.:% ww1_s1joB [Occ=Once] ww2_s1joC [Occ=Once] ->
              case y_s1joz of {
                GHC.Real.:% ww4_s1joE [Occ=Once] ww5_s1joF [Occ=Once] ->
                    case
                        GHC.Real.$w$ccompare
                            $dIntegral_s1jox ww1_s1joB ww2_s1joC ww4_s1joE ww5_s1joF
                    of
                    { __DEFAULT -> GHC.Types.False [];
                      GHC.Types.GT -> GHC.Types.True [];
                    };
              };
        };

GHC.Real.$fOrdRatio_$c>=
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1joH x_s1joI y_s1joJ]
        case x_s1joI of {
          GHC.Real.:% ww1_s1joL [Occ=Once] ww2_s1joM [Occ=Once] ->
              case y_s1joJ of {
                GHC.Real.:% ww4_s1joO [Occ=Once] ww5_s1joP [Occ=Once] ->
                    case
                        GHC.Real.$w$ccompare
                            $dIntegral_s1joH ww1_s1joL ww2_s1joM ww4_s1joO ww5_s1joP
                    of
                    { __DEFAULT -> GHC.Types.True [];
                      GHC.Types.LT -> GHC.Types.False [];
                    };
              };
        };

GHC.Real.$fOrdRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Classes.Ord (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>m] =
    [] \r [$dIntegral_s1joR]
        let {
          sat_s1joZ [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Real.Ratio a_a1eJ2
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$cmin $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joY [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Real.Ratio a_a1eJ2
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$cmax $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joX [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c>= $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joW [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c> $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joV [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c<= $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joU [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c< $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joT [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Ordering
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$ccompare $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joS [Occ=Once] :: GHC.Classes.Eq (GHC.Real.Ratio a_a1eJ2)
          [LclId] =
              [$dIntegral_s1joR] \u []
                  GHC.Real.$fOrdRatio_$cp1Ord $dIntegral_s1joR;
        } in 
          GHC.Classes.C:Ord [sat_s1joS
                             sat_s1joT
                             sat_s1joU
                             sat_s1joV
                             sat_s1joW
                             sat_s1joX
                             sat_s1joY
                             sat_s1joZ];

GHC.Real.$fNumRatio_$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LLLC(S)LLL)LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,1*C1(U),A,A,A),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jp0 w1_s1jp1]
        case w1_s1jp1 of {
          GHC.Real.:% ww1_s1jp3 [Occ=Once] ww2_s1jp4 [Occ=Once] ->
              case GHC.Real.$p1Integral w_s1jp0 of sat_s1jp5 {
                __DEFAULT ->
                    case GHC.Real.$p1Real sat_s1jp5 of sat_s1jp6 {
                      __DEFAULT ->
                          case GHC.Num.negate sat_s1jp6 ww1_s1jp3 of dt_s1jp7 {
                            __DEFAULT -> GHC.Real.:% [dt_s1jp7 ww2_s1jp4];
                          };
                    };
              };
        };

GHC.Real.$fNumRatio_$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LLLLC(S)LL)LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,1*C1(U),A,A),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jp8 w1_s1jp9]
        case w1_s1jp9 of {
          GHC.Real.:% ww1_s1jpb [Occ=Once] ww2_s1jpc [Occ=Once] ->
              case GHC.Real.$p1Integral w_s1jp8 of sat_s1jpd {
                __DEFAULT ->
                    case GHC.Real.$p1Real sat_s1jpd of sat_s1jpe {
                      __DEFAULT ->
                          case GHC.Num.abs sat_s1jpe ww1_s1jpb of dt_s1jpf {
                            __DEFAULT -> GHC.Real.:% [dt_s1jpf ww2_s1jpc];
                          };
                    };
              };
        };

GHC.Real.$w$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLC(S)C(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jpg ww_s1jph]
        case
            GHC.Real.$p1Integral w_s1jpg
        of
        $dReal_s1jpi [Dmd=<S(S(LLLLLC(S)C(S))LL),1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1jpi
              of
              $dNum_s1jpj [Dmd=<S(LLLLLC(S)C(S)),U(A,A,A,A,A,1*C1(U),1*C1(U))>]
              { __DEFAULT ->
                    case GHC.Num.signum $dNum_s1jpj ww_s1jph of dt_s1jpk {
                      __DEFAULT ->
                          case
                              GHC.Num.fromInteger $dNum_s1jpj GHC.Real.$fEnumRatio1
                          of
                          dt1_s1jpl
                          { __DEFAULT -> (#,#) [dt_s1jpk dt1_s1jpl];
                          };
                    };
              };
        };

GHC.Real.$fNumRatio_$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLC(S)C(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SL),1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jpm w1_s1jpn]
        case w1_s1jpn of {
          GHC.Real.:% ww1_s1jpp [Occ=Once] _ [Occ=Dead] ->
              case GHC.Real.$w$csignum w_s1jpm ww1_s1jpp of {
                (#,#) ww4_s1jps [Occ=Once] ww5_s1jpt [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jps ww5_s1jpt];
              };
        };

GHC.Real.$w$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jpu w1_s1jpv]
        case
            GHC.Real.$p1Integral w_s1jpu
        of
        $dReal_s1jpw [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1jpw
              of
              $dNum_s1jpx [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
              { __DEFAULT ->
                    case GHC.Num.fromInteger $dNum_s1jpx w1_s1jpv of dt_s1jpy {
                      __DEFAULT ->
                          case
                              GHC.Num.fromInteger $dNum_s1jpx GHC.Real.$fEnumRatio1
                          of
                          dt1_s1jpz
                          { __DEFAULT -> (#,#) [dt_s1jpy dt1_s1jpz];
                          };
                    };
              };
        };

GHC.Real.$fNumRatio_$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1jpA w1_s1jpB]
        case GHC.Real.$w$cfromInteger w_s1jpA w1_s1jpB of {
          (#,#) ww1_s1jpD [Occ=Once] ww2_s1jpE [Occ=Once] ->
              GHC.Real.:% [ww1_s1jpD ww2_s1jpE];
        };

GHC.Real.$fRealRatio_$s$ctoRational
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Real.Rational
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1jpF] ds_s1jpF;

GHC.Real.$fRealRatio_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Rational
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)),U(A,A,A,A,A,A,A,A,C(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jpG w1_s1jpH]
        case w1_s1jpH of {
          GHC.Real.:% ww1_s1jpJ [Occ=Once] ww2_s1jpK [Occ=Once] ->
              case GHC.Real.toInteger w_s1jpG ww1_s1jpJ of dt_s1jpL {
                __DEFAULT ->
                    case GHC.Real.toInteger w_s1jpG ww2_s1jpK of dt1_s1jpM {
                      __DEFAULT -> GHC.Real.:% [dt_s1jpL dt1_s1jpM];
                    };
              };
        };

GHC.Real.$w$crecip [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jpN ww_s1jpO ww1_s1jpP]
        case
            GHC.Real.$p1Integral w_s1jpN
        of
        $dReal_s1jpQ [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jpR [Dmd=<L,U(A,A,A,C(U),A,A,C(U))>] :: GHC.Num.Num a_s1hDt
                [LclId] =
                    [$dReal_s1jpQ] \u [] GHC.Real.$p1Real $dReal_s1jpQ;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1jpQ
                of
                $dOrd_s1jpS [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1jpU [Occ=Once] :: a_s1hDt
                        [LclId] =
                            [$dNum_s1jpR] \u [] GHC.Num.fromInteger $dNum_s1jpR GHC.Real.even1;
                      } in 
                        case GHC.Classes.$p1Ord $dOrd_s1jpS of sat_s1jpT {
                          __DEFAULT ->
                              case GHC.Classes.== sat_s1jpT ww_s1jpO sat_s1jpU of {
                                GHC.Types.False ->
                                    let {
                                      sat_s1jpW [Occ=Once] :: a_s1hDt
                                      [LclId] =
                                          [$dNum_s1jpR] \u []
                                              GHC.Num.fromInteger $dNum_s1jpR GHC.Real.even1;
                                    } in 
                                      case GHC.Classes.< $dOrd_s1jpS ww_s1jpO sat_s1jpW of {
                                        GHC.Types.False -> (#,#) [ww1_s1jpP ww_s1jpO];
                                        GHC.Types.True ->
                                            case GHC.Num.negate $dNum_s1jpR ww1_s1jpP of dt_s1jpY {
                                              __DEFAULT ->
                                                  case
                                                      GHC.Num.negate $dNum_s1jpR ww_s1jpO
                                                  of
                                                  dt1_s1jpZ
                                                  { __DEFAULT -> (#,#) [dt_s1jpY dt1_s1jpZ];
                                                  };
                                            };
                                      };
                                GHC.Types.True -> GHC.Real.ratioZeroDenominatorError;
                              };
                        };
                };
        };

GHC.Real.$fFractionalRatio_$crecip [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jq1 w1_s1jq2]
        case w1_s1jq2 of {
          GHC.Real.:% ww1_s1jq4 [Occ=Once] ww2_s1jq5 [Occ=Once] ->
              case GHC.Real.$w$crecip w_s1jq1 ww1_s1jq4 ww2_s1jq5 of {
                (#,#) ww4_s1jq7 [Occ=Once] ww5_s1jq8 [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jq7 ww5_s1jq8];
              };
        };

GHC.Real.$w$s$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# b, GHC.Real.Ratio GHC.Integer.Type.Integer #)
[GblId,
 Arity=3,
 Str=<L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jq9 ww_s1jqa ww1_s1jqb]
        let {
          ds_s1jqc [Dmd=<L,U(1*U,1*U)>]
            :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
          [LclId] =
              [ww_s1jqa ww1_s1jqb] \u []
                  case GHC.Integer.Type.eqInteger# ww1_s1jqb GHC.Real.even1 of {
                    __DEFAULT ->
                        case GHC.Integer.Type.quotRemInteger ww_s1jqa ww1_s1jqb of {
                          (#,#) ipv_s1jqf [Occ=Once] ipv1_s1jqg [Occ=Once] ->
                              (,) [ipv_s1jqf ipv1_s1jqg];
                        };
                    1# -> GHC.Real.divZeroError;
                  }; } in
        let {
          sat_s1jqs [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId] =
              [ww1_s1jqb ds_s1jqc] \u []
                  case ds_s1jqc of {
                    (,) _ [Occ=Dead] r_s1jqq [Occ=Once] ->
                        case r_s1jqq of dt_s1jqr {
                          __DEFAULT -> GHC.Real.:% [dt_s1jqr ww1_s1jqb];
                        };
                  }; } in
        let {
          sat_s1jqn [Occ=Once] :: b_s1hDF
          [LclId] =
              [w_s1jq9 ds_s1jqc] \u []
                  let {
                    sat_s1jqm [Occ=Once] :: GHC.Integer.Type.Integer
                    [LclId] =
                        [ds_s1jqc] \u []
                            case ds_s1jqc of {
                              (,) q_s1jqk [Occ=Once] _ [Occ=Dead] -> q_s1jqk;
                            };
                  } in 
                    case GHC.Real.$p1Integral w_s1jq9 of sat_s1jqh {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_s1jqh of sat_s1jqi {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1jqi sat_s1jqm;
                          };
                    };
        } in  (#,#) [sat_s1jqn sat_s1jqs];

GHC.Real.$fEnumRatio_$s$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer
     -> (b, GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jqt w1_s1jqu]
        case w1_s1jqu of {
          GHC.Real.:% ww1_s1jqw [Occ=Once] ww2_s1jqx [Occ=Once] ->
              case GHC.Real.$w$s$cproperFraction w_s1jqt ww1_s1jqw ww2_s1jqx of {
                (#,#) ww4_s1jqz [Occ=Once] ww5_s1jqA [Occ=Once] ->
                    (,) [ww4_s1jqz ww5_s1jqA];
              };
        };

GHC.Real.$w$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b.
     GHC.Real.Integral b =>
     a -> a -> (# b, GHC.Real.Ratio a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,1*C1(C1(U(1*U,1*U))),A,1*C1(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jqB w1_s1jqC ww_s1jqD ww1_s1jqE]
        let {
          ds_s1jqF [Dmd=<L,U(1*U,1*U)>] :: (a_s1hDR, a_s1hDR)
          [LclId] =
              [w_s1jqB ww_s1jqD ww1_s1jqE] \u []
                  GHC.Real.quotRem w_s1jqB ww_s1jqD ww1_s1jqE; } in
        let {
          sat_s1jqS [Occ=Once] :: GHC.Real.Ratio a_s1hDR
          [LclId] =
              [ww1_s1jqE ds_s1jqF] \u []
                  case ds_s1jqF of {
                    (,) _ [Occ=Dead] r_s1jqQ [Occ=Once] ->
                        case r_s1jqQ of dt_s1jqR {
                          __DEFAULT -> GHC.Real.:% [dt_s1jqR ww1_s1jqE];
                        };
                  }; } in
        let {
          sat_s1jqN [Occ=Once] :: b_s1hDT
          [LclId] =
              [w_s1jqB w1_s1jqC ds_s1jqF] \u []
                  let {
                    sat_s1jqM [Occ=Once] :: GHC.Integer.Type.Integer
                    [LclId] =
                        [w_s1jqB ds_s1jqF] \u []
                            let {
                              sat_s1jqL [Occ=Once] :: a_s1hDR
                              [LclId] =
                                  [ds_s1jqF] \u []
                                      case ds_s1jqF of {
                                        (,) q_s1jqJ [Occ=Once] _ [Occ=Dead] -> q_s1jqJ;
                                      };
                            } in  GHC.Real.toInteger w_s1jqB sat_s1jqL;
                  } in 
                    case GHC.Real.$p1Integral w1_s1jqC of sat_s1jqG {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_s1jqG of sat_s1jqH {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1jqH sat_s1jqM;
                          };
                    };
        } in  (#,#) [sat_s1jqN sat_s1jqS];

GHC.Real.$fEnumRatio_$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio a -> (b, GHC.Real.Ratio a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jqT w1_s1jqU w2_s1jqV]
        case w2_s1jqV of {
          GHC.Real.:% ww1_s1jqX [Occ=Once] ww2_s1jqY [Occ=Once] ->
              case
                  GHC.Real.$w$cproperFraction w_s1jqT w1_s1jqU ww1_s1jqX ww2_s1jqY
              of
              { (#,#) ww4_s1jr0 [Occ=Once] ww5_s1jr1 [Occ=Once] ->
                    (,) [ww4_s1jr0 ww5_s1jr1];
              };
        };

GHC.Real.$wreduce [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,A,A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jr2 w1_s1jr3 w2_s1jr4]
        case
            GHC.Real.$p1Integral w_s1jr2
        of
        $dReal_s1jr5 [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s1jr9 [Occ=Once] :: a_s1hE5
                [LclId] =
                    [$dReal_s1jr5] \u []
                        case GHC.Real.$p1Real $dReal_s1jr5 of sat_s1jr8 {
                          __DEFAULT -> GHC.Num.fromInteger sat_s1jr8 GHC.Real.even1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s1jr5 of sat_s1jr6 {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_s1jr6 of sat_s1jr7 {
                        __DEFAULT ->
                            case GHC.Classes.== sat_s1jr7 w2_s1jr4 sat_s1jr9 of {
                              GHC.Types.False ->
                                  let {
                                    d_s1jrb :: a_s1hE5
                                    [LclId] =
                                        [w_s1jr2 w1_s1jr3 w2_s1jr4] \u []
                                            GHC.Real.gcd w_s1jr2 w1_s1jr3 w2_s1jr4;
                                  } in 
                                    case GHC.Real.quot w_s1jr2 w1_s1jr3 d_s1jrb of dt_s1jrc {
                                      __DEFAULT ->
                                          case GHC.Real.quot w_s1jr2 w2_s1jr4 d_s1jrb of dt1_s1jrd {
                                            __DEFAULT -> (#,#) [dt_s1jrc dt1_s1jrd];
                                          };
                                    };
                              GHC.Types.True -> GHC.Real.ratioZeroDenominatorError;
                            };
                      };
                };
        };

GHC.Real.reduce [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,A,A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1jrf w1_s1jrg w2_s1jrh]
        case GHC.Real.$wreduce w_s1jrf w1_s1jrg w2_s1jrh of {
          (#,#) ww1_s1jrj [Occ=Once] ww2_s1jrk [Occ=Once] ->
              GHC.Real.:% [ww1_s1jrj ww2_s1jrk];
        };

GHC.Real.%_$s% [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>m, Unf=OtherCon []] =
    [] \r [w_s1jrl w1_s1jrm]
        case GHC.Real.$w$s$cfromRational w_s1jrl w1_s1jrm of {
          (#,#) ww1_s1jro [Occ=Once] ww2_s1jrp [Occ=Once] ->
              GHC.Real.:% [ww1_s1jro ww2_s1jrp];
        };

GHC.Real.$w% [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,1*C1(C1(U)),A,C(U),1*C1(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jrq w1_s1jrr w2_s1jrs]
        let {
          $dReal_s1jrt [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,A,1*C1(C1(U)),A,1*C1(U),1*C1(U),A),A,A)>]
            :: GHC.Real.Real a_s1hEj
          [LclId] =
              [w_s1jrq] \s [] GHC.Real.$p1Integral w_s1jrq; } in
        let {
          $dNum_s1jru [Dmd=<L,U(A,A,1*C1(C1(U)),A,1*C1(U),1*C1(U),A)>]
            :: GHC.Num.Num a_s1hEj
          [LclId] =
              [$dReal_s1jrt] \u [] GHC.Real.$p1Real $dReal_s1jrt; } in
        let {
          sat_s1jrx [Occ=Once] :: a_s1hEj
          [LclId] =
              [w2_s1jrs $dNum_s1jru] \u [] GHC.Num.abs $dNum_s1jru w2_s1jrs; } in
        let {
          sat_s1jrw [Occ=Once] :: a_s1hEj
          [LclId] =
              [w1_s1jrr w2_s1jrs $dNum_s1jru] \u []
                  let {
                    sat_s1jrv [Occ=Once] :: a_s1hEj
                    [LclId] =
                        [w2_s1jrs $dNum_s1jru] \u [] GHC.Num.signum $dNum_s1jru w2_s1jrs;
                  } in  GHC.Num.* $dNum_s1jru w1_s1jrr sat_s1jrv;
        } in  GHC.Real.$wreduce w_s1jrq sat_s1jrw sat_s1jrx;

GHC.Real.% [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1jry w1_s1jrz w2_s1jrA]
        case GHC.Real.$w% w_s1jry w1_s1jrz w2_s1jrA of {
          (#,#) ww1_s1jrC [Occ=Once] ww2_s1jrD [Occ=Once] ->
              GHC.Real.:% [ww1_s1jrC ww2_s1jrD];
        };

GHC.Real.$w$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jrE ww_s1jrF ww1_s1jrG ww2_s1jrH ww3_s1jrI]
        let {
          $dReal_s1jrJ [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hEr
          [LclId] =
              [w_s1jrE] \s [] GHC.Real.$p1Integral w_s1jrE; } in
        let {
          $dNum_s1jrK [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hEr
          [LclId] =
              [$dReal_s1jrJ] \u [] GHC.Real.$p1Real $dReal_s1jrJ; } in
        let {
          sat_s1jrM [Occ=Once] :: a_s1hEr
          [LclId] =
              [ww1_s1jrG ww2_s1jrH $dNum_s1jrK] \u []
                  GHC.Num.* $dNum_s1jrK ww1_s1jrG ww2_s1jrH; } in
        let {
          sat_s1jrL [Occ=Once] :: a_s1hEr
          [LclId] =
              [ww_s1jrF ww3_s1jrI $dNum_s1jrK] \u []
                  GHC.Num.* $dNum_s1jrK ww_s1jrF ww3_s1jrI;
        } in  GHC.Real.$w% w_s1jrE sat_s1jrL sat_s1jrM;

GHC.Real.$fFractionalRatio_$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jrN w1_s1jrO w2_s1jrP]
        case w1_s1jrO of {
          GHC.Real.:% ww1_s1jrR [Occ=Once] ww2_s1jrS [Occ=Once] ->
              case w2_s1jrP of {
                GHC.Real.:% ww4_s1jrU [Occ=Once] ww5_s1jrV [Occ=Once] ->
                    case
                        GHC.Real.$w$c/ w_s1jrN ww1_s1jrR ww2_s1jrS ww4_s1jrU ww5_s1jrV
                    of
                    { (#,#) ww7_s1jrX [Occ=Once] ww8_s1jrY [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jrX ww8_s1jrY];
                    };
              };
        };

GHC.Real.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jrZ ww_s1js0 ww1_s1js1]
        let {
          $dReal_s1js2 [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
            :: GHC.Real.Real a_s1hEJ
          [LclId] =
              [w_s1jrZ] \s [] GHC.Real.$p1Integral w_s1jrZ; } in
        let {
          $dNum_s1js3 [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_s1hEJ
          [LclId] =
              [$dReal_s1js2] \u [] GHC.Real.$p1Real $dReal_s1js2; } in
        let {
          sat_s1js5 [Occ=Once] :: a_s1hEJ
          [LclId] =
              [ww1_s1js1 $dNum_s1js3] \u []
                  GHC.Num.fromInteger $dNum_s1js3 ww1_s1js1; } in
        let {
          sat_s1js4 [Occ=Once] :: a_s1hEJ
          [LclId] =
              [ww_s1js0 $dNum_s1js3] \u []
                  GHC.Num.fromInteger $dNum_s1js3 ww_s1js0;
        } in  GHC.Real.$w% w_s1jrZ sat_s1js4 sat_s1js5;

GHC.Real.$fFractionalRatio_$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Rational -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1js6 w1_s1js7]
        case w1_s1js7 of {
          GHC.Real.:% ww1_s1js9 [Occ=Once] ww2_s1jsa [Occ=Once] ->
              case GHC.Real.$w$cfromRational w_s1js6 ww1_s1js9 ww2_s1jsa of {
                (#,#) ww4_s1jsc [Occ=Once] ww5_s1jsd [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jsc ww5_s1jsd];
              };
        };

GHC.Real.$w$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(1*C1(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jse ww_s1jsf ww1_s1jsg ww2_s1jsh ww3_s1jsi]
        let {
          $dReal_s1jsj [Occ=OnceL,
                        Dmd=<L,1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hEV
          [LclId] =
              [w_s1jse] \s [] GHC.Real.$p1Integral w_s1jse; } in
        let {
          $dNum_s1jsk [Dmd=<L,U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hEV
          [LclId] =
              [$dReal_s1jsj] \u [] GHC.Real.$p1Real $dReal_s1jsj; } in
        let {
          sat_s1jso [Occ=Once] :: a_s1hEV
          [LclId] =
              [ww1_s1jsg ww3_s1jsi $dNum_s1jsk] \u []
                  GHC.Num.* $dNum_s1jsk ww1_s1jsg ww3_s1jsi; } in
        let {
          sat_s1jsn [Occ=Once] :: a_s1hEV
          [LclId] =
              [ww_s1jsf ww1_s1jsg ww2_s1jsh ww3_s1jsi $dNum_s1jsk] \u []
                  let {
                    sat_s1jsm [Occ=Once] :: a_s1hEV
                    [LclId] =
                        [ww1_s1jsg ww2_s1jsh $dNum_s1jsk] \u []
                            GHC.Num.* $dNum_s1jsk ww2_s1jsh ww1_s1jsg; } in
                  let {
                    sat_s1jsl [Occ=Once] :: a_s1hEV
                    [LclId] =
                        [ww_s1jsf ww3_s1jsi $dNum_s1jsk] \u []
                            GHC.Num.* $dNum_s1jsk ww_s1jsf ww3_s1jsi;
                  } in  GHC.Num.+ $dNum_s1jsk sat_s1jsl sat_s1jsm;
        } in  GHC.Real.$wreduce w_s1jse sat_s1jsn sat_s1jso;

GHC.Real.$fNumRatio_$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jsp w1_s1jsq w2_s1jsr]
        case w1_s1jsq of {
          GHC.Real.:% ww1_s1jst [Occ=Once] ww2_s1jsu [Occ=Once] ->
              case w2_s1jsr of {
                GHC.Real.:% ww4_s1jsw [Occ=Once] ww5_s1jsx [Occ=Once] ->
                    case
                        GHC.Real.$w$c+ w_s1jsp ww1_s1jst ww2_s1jsu ww4_s1jsw ww5_s1jsx
                    of
                    { (#,#) ww7_s1jsz [Occ=Once] ww8_s1jsA [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jsz ww8_s1jsA];
                    };
              };
        };

GHC.Real.$w$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,1*C1(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jsB ww_s1jsC ww1_s1jsD ww2_s1jsE ww3_s1jsF]
        let {
          $dReal_s1jsG [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hFd
          [LclId] =
              [w_s1jsB] \s [] GHC.Real.$p1Integral w_s1jsB; } in
        let {
          $dNum_s1jsH [Dmd=<L,U(A,1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hFd
          [LclId] =
              [$dReal_s1jsG] \u [] GHC.Real.$p1Real $dReal_s1jsG; } in
        let {
          sat_s1jsL [Occ=Once] :: a_s1hFd
          [LclId] =
              [ww1_s1jsD ww3_s1jsF $dNum_s1jsH] \u []
                  GHC.Num.* $dNum_s1jsH ww1_s1jsD ww3_s1jsF; } in
        let {
          sat_s1jsK [Occ=Once] :: a_s1hFd
          [LclId] =
              [ww_s1jsC ww1_s1jsD ww2_s1jsE ww3_s1jsF $dNum_s1jsH] \u []
                  let {
                    sat_s1jsJ [Occ=Once] :: a_s1hFd
                    [LclId] =
                        [ww1_s1jsD ww2_s1jsE $dNum_s1jsH] \u []
                            GHC.Num.* $dNum_s1jsH ww2_s1jsE ww1_s1jsD; } in
                  let {
                    sat_s1jsI [Occ=Once] :: a_s1hFd
                    [LclId] =
                        [ww_s1jsC ww3_s1jsF $dNum_s1jsH] \u []
                            GHC.Num.* $dNum_s1jsH ww_s1jsC ww3_s1jsF;
                  } in  GHC.Num.- $dNum_s1jsH sat_s1jsI sat_s1jsJ;
        } in  GHC.Real.$wreduce w_s1jsB sat_s1jsK sat_s1jsL;

GHC.Real.$fNumRatio_$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jsM w1_s1jsN w2_s1jsO]
        case w1_s1jsN of {
          GHC.Real.:% ww1_s1jsQ [Occ=Once] ww2_s1jsR [Occ=Once] ->
              case w2_s1jsO of {
                GHC.Real.:% ww4_s1jsT [Occ=Once] ww5_s1jsU [Occ=Once] ->
                    case
                        GHC.Real.$w$c- w_s1jsM ww1_s1jsQ ww2_s1jsR ww4_s1jsT ww5_s1jsU
                    of
                    { (#,#) ww7_s1jsW [Occ=Once] ww8_s1jsX [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jsW ww8_s1jsX];
                    };
              };
        };

GHC.Real.$w$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jsY ww_s1jsZ ww1_s1jt0 ww2_s1jt1 ww3_s1jt2]
        let {
          $dReal_s1jt3 [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hFv
          [LclId] =
              [w_s1jsY] \s [] GHC.Real.$p1Integral w_s1jsY; } in
        let {
          $dNum_s1jt4 [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hFv
          [LclId] =
              [$dReal_s1jt3] \u [] GHC.Real.$p1Real $dReal_s1jt3; } in
        let {
          sat_s1jt6 [Occ=Once] :: a_s1hFv
          [LclId] =
              [ww1_s1jt0 ww3_s1jt2 $dNum_s1jt4] \u []
                  GHC.Num.* $dNum_s1jt4 ww1_s1jt0 ww3_s1jt2; } in
        let {
          sat_s1jt5 [Occ=Once] :: a_s1hFv
          [LclId] =
              [ww_s1jsZ ww2_s1jt1 $dNum_s1jt4] \u []
                  GHC.Num.* $dNum_s1jt4 ww_s1jsZ ww2_s1jt1;
        } in  GHC.Real.$wreduce w_s1jsY sat_s1jt5 sat_s1jt6;

GHC.Real.$fNumRatio_$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jt7 w1_s1jt8 w2_s1jt9]
        case w1_s1jt8 of {
          GHC.Real.:% ww1_s1jtb [Occ=Once] ww2_s1jtc [Occ=Once] ->
              case w2_s1jt9 of {
                GHC.Real.:% ww4_s1jte [Occ=Once] ww5_s1jtf [Occ=Once] ->
                    case
                        GHC.Real.$w$c* w_s1jt7 ww1_s1jtb ww2_s1jtc ww4_s1jte ww5_s1jtf
                    of
                    { (#,#) ww7_s1jth [Occ=Once] ww8_s1jti [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jth ww8_s1jti];
                    };
              };
        };

GHC.Real.$fNumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Real.Integral a => GHC.Num.Num (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dIntegral_s1jtj]
        let {
          sat_s1jtq [Occ=Once]
            :: GHC.Integer.Type.Integer -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B1]
                  GHC.Real.$fNumRatio_$cfromInteger $dIntegral_s1jtj eta_B1; } in
        let {
          sat_s1jtp [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B1]
                  GHC.Real.$fNumRatio_$csignum $dIntegral_s1jtj eta_B1; } in
        let {
          sat_s1jto [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B1]
                  GHC.Real.$fNumRatio_$cabs $dIntegral_s1jtj eta_B1; } in
        let {
          sat_s1jtn [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B1]
                  GHC.Real.$fNumRatio_$cnegate $dIntegral_s1jtj eta_B1; } in
        let {
          sat_s1jtm [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM
               -> GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B2 eta_B1]
                  GHC.Real.$fNumRatio_$c* $dIntegral_s1jtj eta_B2 eta_B1; } in
        let {
          sat_s1jtl [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM
               -> GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B2 eta_B1]
                  GHC.Real.$fNumRatio_$c- $dIntegral_s1jtj eta_B2 eta_B1; } in
        let {
          sat_s1jtk [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM
               -> GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B2 eta_B1]
                  GHC.Real.$fNumRatio_$c+ $dIntegral_s1jtj eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [sat_s1jtk
                         sat_s1jtl
                         sat_s1jtm
                         sat_s1jtn
                         sat_s1jto
                         sat_s1jtp
                         sat_s1jtq];

GHC.Real.$fEnumRatio3 :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.$fEnumRatio1
                                GHC.Real.$fEnumRatio1];

GHC.Real.$fEnumRatio_$s$csucc
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [x_s1jtr]
        case x_s1jtr of {
          GHC.Real.:% ww1_s1jtt [Occ=Once] ww2_s1jtu [Occ=Once] ->
              case
                  GHC.Real.$w$s$c+
                      ww1_s1jtt ww2_s1jtu GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1jtw [Occ=Once] ww5_s1jtx [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jtw ww5_s1jtx];
              };
        };

GHC.Real.$fEnumRatio_$csucc
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jty x_s1jtz]
        case x_s1jtz of {
          GHC.Real.:% ww1_s1jtB [Occ=Once] ww2_s1jtC [Occ=Once] ->
              case
                  GHC.Real.$w$cfromInteger $dIntegral_s1jty GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1jtE [Occ=Once] ww5_s1jtF [Occ=Once] ->
                    case
                        GHC.Real.$w$c+
                            $dIntegral_s1jty ww1_s1jtB ww2_s1jtC ww4_s1jtE ww5_s1jtF
                    of
                    { (#,#) ww7_s1jtH [Occ=Once] ww8_s1jtI [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jtH ww8_s1jtI];
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$cpred
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [x_s1jtJ]
        case x_s1jtJ of {
          GHC.Real.:% ww1_s1jtL [Occ=Once] ww2_s1jtM [Occ=Once] ->
              case
                  GHC.Real.$w$s$c-
                      ww1_s1jtL ww2_s1jtM GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1jtO [Occ=Once] ww5_s1jtP [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jtO ww5_s1jtP];
              };
        };

GHC.Real.$fEnumRatio_$cpred
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jtQ x_s1jtR]
        case x_s1jtR of {
          GHC.Real.:% ww1_s1jtT [Occ=Once] ww2_s1jtU [Occ=Once] ->
              case
                  GHC.Real.$w$cfromInteger $dIntegral_s1jtQ GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1jtW [Occ=Once] ww5_s1jtX [Occ=Once] ->
                    case
                        GHC.Real.$w$c-
                            $dIntegral_s1jtQ ww1_s1jtT ww2_s1jtU ww4_s1jtW ww5_s1jtX
                    of
                    { (#,#) ww7_s1jtZ [Occ=Once] ww8_s1ju0 [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jtZ ww8_s1ju0];
                    };
              };
        };

GHC.Real.$fFractionalRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Fractional (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dIntegral_s1ju1]
        let {
          sat_s1ju5 [Occ=Once] :: GHC.Real.Rational -> GHC.Real.Ratio a_a1eGy
          [LclId] =
              [$dIntegral_s1ju1] \r [eta_B1]
                  GHC.Real.$fFractionalRatio_$cfromRational
                      $dIntegral_s1ju1 eta_B1; } in
        let {
          sat_s1ju4 [Occ=Once]
            :: GHC.Real.Ratio a_a1eGy -> GHC.Real.Ratio a_a1eGy
          [LclId] =
              [$dIntegral_s1ju1] \r [eta_B1]
                  GHC.Real.$fFractionalRatio_$crecip $dIntegral_s1ju1 eta_B1; } in
        let {
          sat_s1ju3 [Occ=Once]
            :: GHC.Real.Ratio a_a1eGy
               -> GHC.Real.Ratio a_a1eGy -> GHC.Real.Ratio a_a1eGy
          [LclId] =
              [$dIntegral_s1ju1] \r [eta_B2 eta_B1]
                  GHC.Real.$fFractionalRatio_$c/ $dIntegral_s1ju1 eta_B2 eta_B1; } in
        let {
          sat_s1ju2 [Occ=Once] :: GHC.Num.Num (GHC.Real.Ratio a_a1eGy)
          [LclId] =
              [$dIntegral_s1ju1] \u [] GHC.Real.$fNumRatio $dIntegral_s1ju1;
        } in 
          GHC.Real.C:Fractional [sat_s1ju2 sat_s1ju3 sat_s1ju4 sat_s1ju5];

GHC.Real.$fEnumRatio_$cenumFrom
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1ju6]
        let {
          w_s1ju7 [Occ=OnceL, Dmd=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)>]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1ju6] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1ju6; } in
        let {
          sat_s1juc [Occ=OnceT[0]]
            :: GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [w_s1ju7] \r [w1_s1ju8]
                  case GHC.Real.$wnumericEnumFrom w_s1ju7 w1_s1ju8 of {
                    (#,#) ww1_s1jua [Occ=Once] ww2_s1jub [Occ=Once] ->
                        : [ww1_s1jua ww2_s1jub];
                  };
        } in  sat_s1juc;

GHC.Real.$fEnumRatio_$cenumFromThen
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jud]
        let {
          w_s1jue [Occ=OnceL,
                   Dmd=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)>]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1jud] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1jud; } in
        let {
          sat_s1juk [Occ=OnceT[0]]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [w_s1jue] \r [w1_s1juf w2_s1jug]
                  case GHC.Real.$wnumericEnumFromThen w_s1jue w1_s1juf w2_s1jug of {
                    (#,#) ww1_s1jui [Occ=Once] ww2_s1juj [Occ=Once] ->
                        : [ww1_s1jui ww2_s1juj];
                  };
        } in  sat_s1juk;

GHC.Real.$fEnumRatio_$cenumFromTo
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jul]
        let {
          sat_s1jun [Occ=Once]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1jul] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1jul; } in
        let {
          sat_s1jum [Occ=Once] :: GHC.Classes.Ord (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1jul] \u [] GHC.Real.$fOrdRatio $dIntegral_s1jul;
        } in  GHC.Real.numericEnumFromTo sat_s1jum sat_s1jun;

GHC.Real.$fEnumRatio_$cenumFromThenTo
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a
     -> GHC.Real.Ratio a -> GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1juo]
        let {
          sat_s1juq [Occ=Once]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1juo] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1juo; } in
        let {
          sat_s1jup [Occ=Once] :: GHC.Classes.Ord (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1juo] \u [] GHC.Real.$fOrdRatio $dIntegral_s1juo;
        } in  GHC.Real.numericEnumFromThenTo sat_s1jup sat_s1juq;

GHC.Real.$fRealFracRatio_$s$fRealRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Real.$fFractionalRatio_$s$fNumRatio
                                    GHC.Real.$fOrdRatio_$s$fOrdRatio
                                    GHC.Real.$fRealRatio_$s$ctoRational];

GHC.Real.$fRealRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Real (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,C(U))>m] =
    [] \r [$dIntegral_s1jur]
        let {
          sat_s1juu [Occ=Once] :: GHC.Real.Ratio a_a1eHn -> GHC.Real.Rational
          [LclId] =
              [$dIntegral_s1jur] \r [eta_B1]
                  GHC.Real.$fRealRatio_$ctoRational $dIntegral_s1jur eta_B1; } in
        let {
          sat_s1jut [Occ=Once] :: GHC.Classes.Ord (GHC.Real.Ratio a_a1eHn)
          [LclId] =
              [$dIntegral_s1jur] \u [] GHC.Real.$fOrdRatio $dIntegral_s1jur; } in
        let {
          sat_s1jus [Occ=Once] :: GHC.Num.Num (GHC.Real.Ratio a_a1eHn)
          [LclId] =
              [$dIntegral_s1jur] \u [] GHC.Real.$fNumRatio $dIntegral_s1jur;
        } in  GHC.Real.C:Real [sat_s1jus sat_s1jut sat_s1juu];

GHC.Real.$w$s$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(1*C1(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1juv ww_s1juw ww1_s1jux]
        case GHC.Real.$w$s$cproperFraction w_s1juv ww_s1juw ww1_s1jux of {
          (#,#) ww3_s1juz [Occ=Once*] ww4_s1juA [Occ=Once!] ->
              case ww4_s1juA of {
                GHC.Real.:% ww6_s1juC [Occ=Once] ww7_s1juD [Occ=Once] ->
                    case
                        GHC.Real.$w$s$ccompare
                            ww6_s1juC ww7_s1juD GHC.Real.even1 GHC.Real.$fEnumRatio1
                    of
                    { __DEFAULT -> ww3_s1juz;
                      GHC.Types.GT ->
                          case
                              GHC.Real.$p1Integral w_s1juv
                          of
                          $dReal_s1juF [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
                          { __DEFAULT ->
                                case
                                    GHC.Real.$p1Real $dReal_s1juF
                                of
                                $dNum_s1juG [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                                { __DEFAULT ->
                                      let {
                                        sat_s1juH [Occ=Once] :: b_s1hFX
                                        [LclId] =
                                            [$dNum_s1juG] \u []
                                                GHC.Num.fromInteger
                                                    $dNum_s1juG GHC.Real.$fEnumRatio1;
                                      } in  GHC.Num.+ $dNum_s1juG ww3_s1juz sat_s1juH;
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$s$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1juI w1_s1juJ]
        case w1_s1juJ of {
          GHC.Real.:% ww1_s1juL [Occ=Once] ww2_s1juM [Occ=Once] ->
              GHC.Real.$w$s$cceiling w_s1juI ww1_s1juL ww2_s1juM;
        };

GHC.Real.$w$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(1*C1(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1juN w1_s1juO ww_s1juP ww1_s1juQ]
        case
            GHC.Real.$w$cproperFraction w_s1juN w1_s1juO ww_s1juP ww1_s1juQ
        of
        { (#,#) ww3_s1juS [Occ=Once*] ww4_s1juT [Occ=Once!] ->
              case ww4_s1juT of {
                GHC.Real.:% ww6_s1juV [Occ=Once] ww7_s1juW [Occ=Once] ->
                    case GHC.Real.$w$cfromInteger w_s1juN GHC.Real.even1 of {
                      (#,#) ww9_s1juY [Occ=Once] ww10_s1juZ [Occ=Once] ->
                          case
                              GHC.Real.$w$ccompare
                                  w_s1juN ww6_s1juV ww7_s1juW ww9_s1juY ww10_s1juZ
                          of
                          { __DEFAULT -> ww3_s1juS;
                            GHC.Types.GT ->
                                case
                                    GHC.Real.$p1Integral w1_s1juO
                                of
                                $dReal_s1jv1 [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
                                { __DEFAULT ->
                                      case
                                          GHC.Real.$p1Real $dReal_s1jv1
                                      of
                                      $dNum_s1jv2 [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                                      { __DEFAULT ->
                                            let {
                                              sat_s1jv3 [Occ=Once] :: b_s1hGi
                                              [LclId] =
                                                  [$dNum_s1jv2] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s1jv2 GHC.Real.$fEnumRatio1;
                                            } in  GHC.Num.+ $dNum_s1jv2 ww3_s1juS sat_s1jv3;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jv4 w1_s1jv5 w2_s1jv6]
        case w2_s1jv6 of {
          GHC.Real.:% ww1_s1jv8 [Occ=Once] ww2_s1jv9 [Occ=Once] ->
              GHC.Real.$w$cceiling w_s1jv4 w1_s1jv5 ww1_s1jv8 ww2_s1jv9;
        };

GHC.Real.$w$s$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,1*C1(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jva ww_s1jvb ww1_s1jvc]
        case GHC.Real.$w$s$cproperFraction w_s1jva ww_s1jvb ww1_s1jvc of {
          (#,#) ww3_s1jve [Occ=Once*] ww4_s1jvf [Occ=Once!] ->
              case ww4_s1jvf of {
                GHC.Real.:% x_s1jvh [Occ=Once] y_s1jvi [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger GHC.Real.even1 y_s1jvi
                    of
                    sat_s1jvk
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger x_s1jvh GHC.Real.$fEnumRatio1
                          of
                          sat_s1jvj
                          { __DEFAULT ->
                                case GHC.Integer.Type.ltInteger# sat_s1jvj sat_s1jvk of {
                                  __DEFAULT -> ww3_s1jve;
                                  1# ->
                                      case
                                          GHC.Real.$p1Integral w_s1jva
                                      of
                                      $dReal_s1jvm [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                      { __DEFAULT ->
                                            case
                                                GHC.Real.$p1Real $dReal_s1jvm
                                            of
                                            $dNum_s1jvn [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                            { __DEFAULT ->
                                                  let {
                                                    sat_s1jvo [Occ=Once] :: b_s1hGr
                                                    [LclId] =
                                                        [$dNum_s1jvn] \u []
                                                            GHC.Num.fromInteger
                                                                $dNum_s1jvn GHC.Real.$fEnumRatio1;
                                                  } in  GHC.Num.- $dNum_s1jvn ww3_s1jve sat_s1jvo;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$s$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jvp w1_s1jvq]
        case w1_s1jvq of {
          GHC.Real.:% ww1_s1jvs [Occ=Once] ww2_s1jvt [Occ=Once] ->
              GHC.Real.$w$s$cfloor w_s1jvp ww1_s1jvs ww2_s1jvt;
        };

GHC.Real.$w$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLLLLC(S))S(LLC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(A,1*C1(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jvu w1_s1jvv ww_s1jvw ww1_s1jvx]
        case
            GHC.Real.$w$cproperFraction w_s1jvu w1_s1jvv ww_s1jvw ww1_s1jvx
        of
        { (#,#) ww3_s1jvz [Occ=Once*] ww4_s1jvA [Occ=Once!] ->
              case ww4_s1jvA of {
                GHC.Real.:% ww6_s1jvC [Occ=Once] ww7_s1jvD [Occ=Once] ->
                    case GHC.Real.$w$cfromInteger w_s1jvu GHC.Real.even1 of {
                      (#,#) ww9_s1jvF [Occ=Once] ww10_s1jvG [Occ=Once] ->
                          case
                              GHC.Real.$w$c< w_s1jvu ww6_s1jvC ww7_s1jvD ww9_s1jvF ww10_s1jvG
                          of
                          { GHC.Types.False -> ww3_s1jvz;
                            GHC.Types.True ->
                                case
                                    GHC.Real.$p1Integral w1_s1jvv
                                of
                                $dReal_s1jvI [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                { __DEFAULT ->
                                      case
                                          GHC.Real.$p1Real $dReal_s1jvI
                                      of
                                      $dNum_s1jvJ [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                      { __DEFAULT ->
                                            let {
                                              sat_s1jvK [Occ=Once] :: b_s1hGM
                                              [LclId] =
                                                  [$dNum_s1jvJ] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s1jvJ GHC.Real.$fEnumRatio1;
                                            } in  GHC.Num.- $dNum_s1jvJ ww3_s1jvz sat_s1jvK;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLLLLC(S))S(LLC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(A,A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jvL w1_s1jvM w2_s1jvN]
        case w2_s1jvN of {
          GHC.Real.:% ww1_s1jvP [Occ=Once] ww2_s1jvQ [Occ=Once] ->
              GHC.Real.$w$cfloor w_s1jvL w1_s1jvM ww1_s1jvP ww2_s1jvQ;
        };

sat_s1jvR :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s1jvS :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1jvR GHC.Types.[]];

GHC.Real.$fRealFracRatio2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.False sat_s1jvS;

GHC.Real.$w$s$cround [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jvT ww_s1jvU ww1_s1jvV]
        case GHC.Real.$w$s$cproperFraction w_s1jvT ww_s1jvU ww1_s1jvV of {
          (#,#) ww3_s1jvX ww4_s1jvY [Occ=Once!] ->
              case ww4_s1jvY of {
                GHC.Real.:% ww6_s1jw0 ww7_s1jw1 ->
                    case GHC.Integer.Type.absInteger ww6_s1jw0 of dt_s1jw2 {
                      __DEFAULT ->
                          case
                              GHC.Real.$w$s$c-
                                  dt_s1jw2 ww7_s1jw1 GHC.Real.$fEnumRatio1 GHC.Real.even2
                          of
                          { (#,#) ww9_s1jw4 [Occ=Once] _ [Occ=Dead] ->
                                case GHC.Integer.Type.signumInteger ww9_s1jw4 of dt1_s1jw6 {
                                  __DEFAULT ->
                                      case
                                          GHC.Integer.Type.eqInteger#
                                              dt1_s1jw6 GHC.Real.$fRealFracRatio2
                                      of
                                      { __DEFAULT ->
                                            let-no-escape {
                                              m_s1jw8 [Occ=Once*T[0], Dmd=<L,1*U>] :: b_s1hH5
                                              [LclId[JoinId(0)], Unf=OtherCon []] =
                                                  [w_s1jvT ww3_s1jvX ww6_s1jw0 ww7_s1jw1] \r []
                                                      case
                                                          GHC.Real.$p1Integral w_s1jvT
                                                      of
                                                      $dReal_s1jw9 [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                                      { __DEFAULT ->
                                                            case
                                                                GHC.Real.$p1Real $dReal_s1jw9
                                                            of
                                                            $dNum_s1jwa [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                                            { __DEFAULT ->
                                                                  case
                                                                      GHC.Integer.Type.timesInteger
                                                                          GHC.Real.even1 ww7_s1jw1
                                                                  of
                                                                  sat_s1jwc
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Integer.Type.timesInteger
                                                                                ww6_s1jw0
                                                                                GHC.Real.$fEnumRatio1
                                                                        of
                                                                        sat_s1jwb
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.ltInteger#
                                                                                      sat_s1jwb
                                                                                      sat_s1jwc
                                                                              of
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_s1jwe [Occ=Once]
                                                                                        :: b_s1hH5
                                                                                      [LclId] =
                                                                                          [$dNum_s1jwa] \u []
                                                                                              GHC.Num.fromInteger
                                                                                                  $dNum_s1jwa
                                                                                                  GHC.Real.$fEnumRatio1;
                                                                                    } in 
                                                                                      GHC.Num.+
                                                                                          $dNum_s1jwa
                                                                                          ww3_s1jvX
                                                                                          sat_s1jwe;
                                                                                1# ->
                                                                                    let {
                                                                                      sat_s1jwf [Occ=Once]
                                                                                        :: b_s1hH5
                                                                                      [LclId] =
                                                                                          [$dNum_s1jwa] \u []
                                                                                              GHC.Num.fromInteger
                                                                                                  $dNum_s1jwa
                                                                                                  GHC.Real.$fEnumRatio1;
                                                                                    } in 
                                                                                      GHC.Num.-
                                                                                          $dNum_s1jwa
                                                                                          ww3_s1jvX
                                                                                          sat_s1jwf;
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                            } in 
                                              case
                                                  GHC.Integer.Type.eqInteger#
                                                      dt1_s1jw6 GHC.Real.even1
                                              of
                                              { __DEFAULT ->
                                                    case
                                                        GHC.Integer.Type.eqInteger#
                                                            dt1_s1jw6 GHC.Real.$fEnumRatio1
                                                    of
                                                    { __DEFAULT -> GHC.Real.$fRealFracRatio1;
                                                      1# -> m_s1jw8;
                                                    };
                                                1# ->
                                                    case GHC.Real.even w_s1jvT ww3_s1jvX of {
                                                      GHC.Types.False -> m_s1jw8;
                                                      GHC.Types.True -> ww3_s1jvX;
                                                    };
                                              };
                                        1# -> ww3_s1jvX;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$s$cround [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jwj w1_s1jwk]
        case w1_s1jwk of {
          GHC.Real.:% ww1_s1jwm [Occ=Once] ww2_s1jwn [Occ=Once] ->
              GHC.Real.$w$s$cround w_s1jwj ww1_s1jwm ww2_s1jwn;
        };

GHC.Real.$w$cround [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLC(S)C(S)C(S)C(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),1*C1(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jwo w1_s1jwp ww_s1jwq ww1_s1jwr]
        case
            GHC.Real.$w$cproperFraction w_s1jwo w1_s1jwp ww_s1jwq ww1_s1jwr
        of
        { (#,#) ww3_s1jwt ww4_s1jwu [Occ=Once!] ->
              case ww4_s1jwu of {
                GHC.Real.:% ww6_s1jww ww7_s1jwx ->
                    case GHC.Real.$p1Integral w_s1jwo of sat_s1jwy {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_s1jwy of sat_s1jwz {
                            __DEFAULT ->
                                case GHC.Num.abs sat_s1jwz ww6_s1jww of dt_s1jwA {
                                  __DEFAULT ->
                                      case
                                          GHC.Real.$w$cfromRational
                                              w_s1jwo GHC.Real.$fEnumRatio1 GHC.Real.even2
                                      of
                                      { (#,#) ww9_s1jwC [Occ=Once] ww10_s1jwD [Occ=Once] ->
                                            case
                                                GHC.Real.$w$c-
                                                    w_s1jwo dt_s1jwA ww7_s1jwx ww9_s1jwC ww10_s1jwD
                                            of
                                            { (#,#) ww12_s1jwF [Occ=Once] _ [Occ=Dead] ->
                                                  case GHC.Real.$w$csignum w_s1jwo ww12_s1jwF of {
                                                    (#,#) ww15_s1jwI ww16_s1jwJ ->
                                                        case
                                                            GHC.Real.$w$cfromInteger
                                                                w_s1jwo GHC.Real.$fEnumRatio1
                                                        of
                                                        { (#,#) ww18_s1jwL ww19_s1jwM ->
                                                              case
                                                                  GHC.Real.$p1Integral w_s1jwo
                                                              of
                                                              sat_s1jwN
                                                              { __DEFAULT ->
                                                                    case
                                                                        GHC.Real.$p1Real sat_s1jwN
                                                                    of
                                                                    sat_s1jwO
                                                                    { __DEFAULT ->
                                                                          case
                                                                              GHC.Num.negate
                                                                                  sat_s1jwO
                                                                                  ww18_s1jwL
                                                                          of
                                                                          dt1_s1jwP
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    GHC.Real.$p1Integral
                                                                                        w_s1jwo
                                                                                of
                                                                                $dEq_s1jwQ [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          GHC.Real.$p2Real
                                                                                              $dEq_s1jwQ
                                                                                      of
                                                                                      $dEq1_s1jwR [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                GHC.Classes.$p1Ord
                                                                                                    $dEq1_s1jwR
                                                                                            of
                                                                                            $dEq2_s1jwS [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                                                                            { __DEFAULT ->
                                                                                                  let-no-escape {
                                                                                                    $j_s1jwT [Occ=Once*T[0],
                                                                                                              Dmd=<L,1*U>]
                                                                                                      :: b_s1hHq
                                                                                                    [LclId[JoinId(0)],
                                                                                                     Unf=OtherCon []] =
                                                                                                        [w_s1jwo
                                                                                                         w1_s1jwp
                                                                                                         ww3_s1jwt
                                                                                                         ww6_s1jww
                                                                                                         ww7_s1jwx
                                                                                                         ww15_s1jwI
                                                                                                         ww16_s1jwJ
                                                                                                         ww18_s1jwL
                                                                                                         ww19_s1jwM
                                                                                                         $dEq2_s1jwS] \r []
                                                                                                            case
                                                                                                                GHC.Real.$w$cfromInteger
                                                                                                                    w_s1jwo
                                                                                                                    GHC.Real.even1
                                                                                                            of
                                                                                                            { (#,#) ww21_s1jwV
                                                                                                                    ww22_s1jwW ->
                                                                                                                  let-no-escape {
                                                                                                                    m_s1jwX [Dmd=<L,1*U>]
                                                                                                                      :: b_s1hHq
                                                                                                                    [LclId[JoinId(0)],
                                                                                                                     Unf=OtherCon []] =
                                                                                                                        [w_s1jwo
                                                                                                                         w1_s1jwp
                                                                                                                         ww3_s1jwt
                                                                                                                         ww6_s1jww
                                                                                                                         ww7_s1jwx
                                                                                                                         ww21_s1jwV
                                                                                                                         ww22_s1jwW] \r []
                                                                                                                            case
                                                                                                                                GHC.Real.$p1Integral
                                                                                                                                    w1_s1jwp
                                                                                                                            of
                                                                                                                            $dReal_s1jwY [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      GHC.Real.$p1Real
                                                                                                                                          $dReal_s1jwY
                                                                                                                                  of
                                                                                                                                  $dNum_s1jwZ [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            GHC.Real.$w$c<
                                                                                                                                                w_s1jwo
                                                                                                                                                ww6_s1jww
                                                                                                                                                ww7_s1jwx
                                                                                                                                                ww21_s1jwV
                                                                                                                                                ww22_s1jwW
                                                                                                                                        of
                                                                                                                                        { GHC.Types.False ->
                                                                                                                                              let {
                                                                                                                                                sat_s1jx1 [Occ=Once]
                                                                                                                                                  :: b_s1hHq
                                                                                                                                                [LclId] =
                                                                                                                                                    [$dNum_s1jwZ] \u []
                                                                                                                                                        GHC.Num.fromInteger
                                                                                                                                                            $dNum_s1jwZ
                                                                                                                                                            GHC.Real.$fEnumRatio1;
                                                                                                                                              } in 
                                                                                                                                                GHC.Num.+
                                                                                                                                                    $dNum_s1jwZ
                                                                                                                                                    ww3_s1jwt
                                                                                                                                                    sat_s1jx1;
                                                                                                                                          GHC.Types.True ->
                                                                                                                                              let {
                                                                                                                                                sat_s1jx2 [Occ=Once]
                                                                                                                                                  :: b_s1hHq
                                                                                                                                                [LclId] =
                                                                                                                                                    [$dNum_s1jwZ] \u []
                                                                                                                                                        GHC.Num.fromInteger
                                                                                                                                                            $dNum_s1jwZ
                                                                                                                                                            GHC.Real.$fEnumRatio1;
                                                                                                                                              } in 
                                                                                                                                                GHC.Num.-
                                                                                                                                                    $dNum_s1jwZ
                                                                                                                                                    ww3_s1jwt
                                                                                                                                                    sat_s1jx2;
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                  } in 
                                                                                                                    let-no-escape {
                                                                                                                      $j1_s1jx3 [Occ=Once*T[0],
                                                                                                                                 Dmd=<L,1*U>]
                                                                                                                        :: b_s1hHq
                                                                                                                      [LclId[JoinId(0)],
                                                                                                                       Unf=OtherCon []] =
                                                                                                                          [ww15_s1jwI
                                                                                                                           ww16_s1jwJ
                                                                                                                           ww18_s1jwL
                                                                                                                           ww19_s1jwM
                                                                                                                           $dEq2_s1jwS
                                                                                                                           m_s1jwX] \r []
                                                                                                                              case
                                                                                                                                  GHC.Classes.==
                                                                                                                                      $dEq2_s1jwS
                                                                                                                                      ww15_s1jwI
                                                                                                                                      ww18_s1jwL
                                                                                                                              of
                                                                                                                              { GHC.Types.False ->
                                                                                                                                    GHC.Real.$fRealFracRatio1;
                                                                                                                                GHC.Types.True ->
                                                                                                                                    case
                                                                                                                                        GHC.Classes.==
                                                                                                                                            $dEq2_s1jwS
                                                                                                                                            ww16_s1jwJ
                                                                                                                                            ww19_s1jwM
                                                                                                                                    of
                                                                                                                                    { GHC.Types.False ->
                                                                                                                                          GHC.Real.$fRealFracRatio1;
                                                                                                                                      GHC.Types.True ->
                                                                                                                                          m_s1jwX;
                                                                                                                                    };
                                                                                                                              };
                                                                                                                    } in 
                                                                                                                      case
                                                                                                                          GHC.Classes.==
                                                                                                                              $dEq2_s1jwS
                                                                                                                              ww15_s1jwI
                                                                                                                              ww21_s1jwV
                                                                                                                      of
                                                                                                                      { GHC.Types.False ->
                                                                                                                            $j1_s1jx3;
                                                                                                                        GHC.Types.True ->
                                                                                                                            case
                                                                                                                                GHC.Classes.==
                                                                                                                                    $dEq2_s1jwS
                                                                                                                                    ww16_s1jwJ
                                                                                                                                    ww22_s1jwW
                                                                                                                            of
                                                                                                                            { GHC.Types.False ->
                                                                                                                                  $j1_s1jx3;
                                                                                                                              GHC.Types.True ->
                                                                                                                                  case
                                                                                                                                      GHC.Real.even
                                                                                                                                          w1_s1jwp
                                                                                                                                          ww3_s1jwt
                                                                                                                                  of
                                                                                                                                  { GHC.Types.False ->
                                                                                                                                        m_s1jwX;
                                                                                                                                    GHC.Types.True ->
                                                                                                                                        ww3_s1jwt;
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                            };
                                                                                                  } in 
                                                                                                    case
                                                                                                        GHC.Classes.==
                                                                                                            $dEq2_s1jwS
                                                                                                            ww15_s1jwI
                                                                                                            dt1_s1jwP
                                                                                                    of
                                                                                                    { GHC.Types.False ->
                                                                                                          $j_s1jwT;
                                                                                                      GHC.Types.True ->
                                                                                                          case
                                                                                                              GHC.Classes.==
                                                                                                                  $dEq2_s1jwS
                                                                                                                  ww16_s1jwJ
                                                                                                                  ww19_s1jwM
                                                                                                          of
                                                                                                          { GHC.Types.False ->
                                                                                                                $j_s1jwT;
                                                                                                            GHC.Types.True ->
                                                                                                                ww3_s1jwt;
                                                                                                          };
                                                                                                    };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$cround [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLC(S)C(S)C(S)C(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jxb w1_s1jxc w2_s1jxd]
        case w2_s1jxd of {
          GHC.Real.:% ww1_s1jxf [Occ=Once] ww2_s1jxg [Occ=Once] ->
              GHC.Real.$w$cround w_s1jxb w1_s1jxc ww1_s1jxf ww2_s1jxg;
        };

GHC.Real.$fRealFracRatio_$s$ctruncate [InlPrag=INLINE (sat-args=1)]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jxh x_s1jxi]
        case x_s1jxi of {
          GHC.Real.:% x1_s1jxk [Occ=Once] y_s1jxl ->
              let {
                sat_s1jxt [Occ=Once] :: GHC.Integer.Type.Integer
                [LclId] =
                    [x1_s1jxk y_s1jxl] \u []
                        case GHC.Integer.Type.eqInteger# y_s1jxl GHC.Real.even1 of {
                          __DEFAULT ->
                              case GHC.Integer.Type.quotRemInteger x1_s1jxk y_s1jxl of {
                                (#,#) ipv_s1jxq [Occ=Once] _ [Occ=Dead] -> ipv_s1jxq;
                              };
                          1# -> GHC.Real.divZeroError;
                        };
              } in 
                case GHC.Real.$p1Integral $dIntegral_s1jxh of sat_s1jxm {
                  __DEFAULT ->
                      case GHC.Real.$p1Real sat_s1jxm of sat_s1jxn {
                        __DEFAULT -> GHC.Num.fromInteger sat_s1jxn sat_s1jxt;
                      };
                };
        };

GHC.Real.$fRealFracRatio_$ctruncate [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jxu $dIntegral1_s1jxv x_s1jxw]
        case x_s1jxw of {
          GHC.Real.:% ww1_s1jxy [Occ=Once] ww2_s1jxz [Occ=Once] ->
              case
                  GHC.Real.$w$cproperFraction
                      $dIntegral_s1jxu $dIntegral1_s1jxv ww1_s1jxy ww2_s1jxz
              of
              { (#,#) ww4_s1jxB [Occ=Once] _ [Occ=Dead] -> ww4_s1jxB;
              };
        };

GHC.Real.$fRealFracRatio_$s$fRealFracRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.RealFrac (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:RealFrac! [GHC.Real.$fRealFracRatio_$s$fRealRatio
                                        GHC.Real.$fFractionalRatio_$s$fFractionalRatio
                                        GHC.Real.$fEnumRatio_$s$cproperFraction
                                        GHC.Real.$fRealFracRatio_$s$ctruncate
                                        GHC.Real.$fRealFracRatio_$s$cround
                                        GHC.Real.$fRealFracRatio_$s$cceiling
                                        GHC.Real.$fRealFracRatio_$s$cfloor];

GHC.Real.$fRealFracRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.RealFrac (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))>m] =
    [] \r [$dIntegral_s1jxD]
        let {
          sat_s1jxK [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1jxD] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$cfloor
                      $dIntegral_s1jxD eta_B2 eta_B1; } in
        let {
          sat_s1jxJ [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1jxD] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$cceiling
                      $dIntegral_s1jxD eta_B2 eta_B1; } in
        let {
          sat_s1jxI [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1jxD] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$cround
                      $dIntegral_s1jxD eta_B2 eta_B1; } in
        let {
          sat_s1jxH [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1jxD] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$ctruncate
                      $dIntegral_s1jxD eta_B2 eta_B1; } in
        let {
          sat_s1jxG [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               GHC.Real.Ratio a_a1eFc -> (b, GHC.Real.Ratio a_a1eFc)
          [LclId] =
              [$dIntegral_s1jxD] \r [eta_B2 eta_B1]
                  GHC.Real.$fEnumRatio_$cproperFraction
                      $dIntegral_s1jxD eta_B2 eta_B1; } in
        let {
          sat_s1jxF [Occ=Once]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eFc)
          [LclId] =
              [$dIntegral_s1jxD] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1jxD; } in
        let {
          sat_s1jxE [Occ=Once] :: GHC.Real.Real (GHC.Real.Ratio a_a1eFc)
          [LclId] =
              [$dIntegral_s1jxD] \u [] GHC.Real.$fRealRatio $dIntegral_s1jxD;
        } in 
          GHC.Real.C:RealFrac [sat_s1jxE
                               sat_s1jxF
                               sat_s1jxG
                               sat_s1jxH
                               sat_s1jxI
                               sat_s1jxJ
                               sat_s1jxK];

g_r1j3N
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
[GblId, Arity=3, Str=<S,U><S,U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [x_s1jxL y_s1jxM z_s1jxN]
        case
            GHC.Integer.Type.remInteger y_s1jxM GHC.Real.even2
        of
        sat_s1jxO
        { __DEFAULT ->
              case GHC.Integer.Type.eqInteger# sat_s1jxO GHC.Real.even1 of {
                __DEFAULT ->
                    case GHC.Integer.Type.eqInteger# y_s1jxM GHC.Real.$fEnumRatio1 of {
                      __DEFAULT ->
                          case GHC.Integer.Type.timesInteger x_s1jxL z_s1jxN of sat_s1jxT {
                            __DEFAULT ->
                                case
                                    GHC.Integer.Type.quotInteger y_s1jxM GHC.Real.even2
                                of
                                sat_s1jxS
                                { __DEFAULT ->
                                      case
                                          GHC.Integer.Type.timesInteger x_s1jxL x_s1jxL
                                      of
                                      sat_s1jxR
                                      { __DEFAULT -> g_r1j3N sat_s1jxR sat_s1jxS sat_s1jxT;
                                      };
                                };
                          };
                      1# -> GHC.Integer.Type.timesInteger x_s1jxL z_s1jxN;
                    };
                1# ->
                    case
                        GHC.Integer.Type.quotInteger y_s1jxM GHC.Real.even2
                    of
                    sat_s1jxV
                    { __DEFAULT ->
                          case GHC.Integer.Type.timesInteger x_s1jxL x_s1jxL of sat_s1jxU {
                            __DEFAULT -> g_r1j3N sat_s1jxU sat_s1jxV z_s1jxN;
                          };
                    };
              };
        };

GHC.Real.^_f [Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [x_s1jxW y_s1jxX]
        case
            GHC.Integer.Type.remInteger y_s1jxX GHC.Real.even2
        of
        sat_s1jxY
        { __DEFAULT ->
              case GHC.Integer.Type.eqInteger# sat_s1jxY GHC.Real.even1 of {
                __DEFAULT ->
                    case GHC.Integer.Type.eqInteger# y_s1jxX GHC.Real.$fEnumRatio1 of {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.quotInteger y_s1jxX GHC.Real.even2
                          of
                          sat_s1jy2
                          { __DEFAULT ->
                                case GHC.Integer.Type.timesInteger x_s1jxW x_s1jxW of sat_s1jy1 {
                                  __DEFAULT -> g_r1j3N sat_s1jy1 sat_s1jy2 x_s1jxW;
                                };
                          };
                      1# -> x_s1jxW;
                    };
                1# ->
                    case
                        GHC.Integer.Type.quotInteger y_s1jxX GHC.Real.even2
                    of
                    sat_s1jy4
                    { __DEFAULT ->
                          case GHC.Integer.Type.timesInteger x_s1jxW x_s1jxW of sat_s1jy3 {
                            __DEFAULT -> GHC.Real.^_f sat_s1jy3 sat_s1jy4;
                          };
                    };
              };
        };

lvl5_r1j3O :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Negative exponent"#;

GHC.Real.^1 :: GHC.Integer.Type.Integer
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1jy5 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1jy5;
        };

GHC.Real.^_$s^ [InlPrag=NOUSERINLINE[1]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [x0_s1jy6 y0_s1jy7]
        case GHC.Integer.Type.ltInteger# y0_s1jy7 GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.eqInteger# y0_s1jy7 GHC.Real.even1 of {
                __DEFAULT -> GHC.Real.^_f x0_s1jy6 y0_s1jy7;
                1# -> GHC.Real.$fEnumRatio1;
              };
          1# -> GHC.Real.^1;
        };

GHC.Real.$w$s$cfromEnum [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Prim.Int#
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1jya ww1_s1jyb]
        case GHC.Integer.Type.eqInteger# ww1_s1jyb GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.quotRemInteger ww_s1jya ww1_s1jyb of {
                (#,#) ipv_s1jye [Occ=Once] _ [Occ=Dead] ->
                    GHC.Integer.Type.integerToInt ipv_s1jye;
              };
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fEnumRatio_$s$cfromEnum [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Int
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_s1jyh]
        case w_s1jyh of {
          GHC.Real.:% ww1_s1jyj [Occ=Once] ww2_s1jyk [Occ=Once] ->
              case GHC.Real.$w$s$cfromEnum ww1_s1jyj ww2_s1jyk of ww3_s1jyl {
                __DEFAULT -> GHC.Types.I# [ww3_s1jyl];
              };
        };

GHC.Real.$fEnumRatio_$cfromEnum
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)),U(A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A,1*C1(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jym x_s1jyn]
        case x_s1jyn of {
          GHC.Real.:% ww1_s1jyp [Occ=Once] ww2_s1jyq [Occ=Once] ->
              let {
                sat_s1jyu [Occ=Once] :: a_a1eE0
                [LclId] =
                    [$dIntegral_s1jym ww1_s1jyp ww2_s1jyq] \u []
                        case GHC.Real.quotRem $dIntegral_s1jym ww1_s1jyp ww2_s1jyq of {
                          (,) q_s1jys [Occ=Once] _ [Occ=Dead] -> q_s1jys;
                        };
              } in 
                case GHC.Real.toInteger $dIntegral_s1jym sat_s1jyu of sat_s1jyv {
                  __DEFAULT ->
                      case GHC.Integer.Type.integerToInt sat_s1jyv of wild_s1jyw {
                        __DEFAULT -> GHC.Types.I# [wild_s1jyw];
                      };
                };
        };

GHC.Real.ratioPrec1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [8#];

GHC.Real.$fShowRatio2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    " % "#;

GHC.Real.$w$s$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Base.String
     -> (# GHC.Types.Char, [GHC.Types.Char] #)
[GblId, Arity=4, Str=<S,U><L,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1jyx ww1_s1jyy ww2_s1jyz w_s1jyA]
        case ># [ww_s1jyx 7#] of {
          __DEFAULT ->
              let {
                sat_s1jyG [Occ=Once] :: GHC.Base.String
                [LclId] =
                    [ww2_s1jyz w_s1jyA] \u []
                        let {
                          sat_s1jyF [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [ww2_s1jyz w_s1jyA] \u []
                                  case GHC.Show.$w$cshowsPrec4 8# ww2_s1jyz w_s1jyA of {
                                    (#,#) ww4_s1jyD [Occ=Once] ww5_s1jyE [Occ=Once] ->
                                        : [ww4_s1jyD ww5_s1jyE];
                                  };
                        } in 
                          GHC.CString.unpackAppendCString# GHC.Real.$fShowRatio2 sat_s1jyF;
              } in  GHC.Show.$w$cshowsPrec4 8# ww1_s1jyy sat_s1jyG;
          1# ->
              let {
                sat_s1jyQ [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [ww1_s1jyy ww2_s1jyz w_s1jyA] \u []
                        let {
                          sat_s1jyM [Occ=Once] :: GHC.Base.String
                          [LclId] =
                              [ww2_s1jyz w_s1jyA] \u []
                                  let {
                                    sat_s1jyL [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [ww2_s1jyz w_s1jyA] \u []
                                            let {
                                              sat_s1jyH [Occ=Once] :: GHC.Base.String
                                              [LclId] =
                                                  CCCS :! [GHC.Show.$fShow(,)2 w_s1jyA];
                                            } in 
                                              case
                                                  GHC.Show.$w$cshowsPrec4 8# ww2_s1jyz sat_s1jyH
                                              of
                                              { (#,#) ww4_s1jyJ [Occ=Once] ww5_s1jyK [Occ=Once] ->
                                                    : [ww4_s1jyJ ww5_s1jyK];
                                              };
                                  } in 
                                    GHC.CString.unpackAppendCString#
                                        GHC.Real.$fShowRatio2 sat_s1jyL;
                        } in 
                          case GHC.Show.$w$cshowsPrec4 8# ww1_s1jyy sat_s1jyM of {
                            (#,#) ww4_s1jyO [Occ=Once] ww5_s1jyP [Occ=Once] ->
                                : [ww4_s1jyO ww5_s1jyP];
                          };
              } in  (#,#) [GHC.Show.$fShow(,)4 sat_s1jyQ];
        };

GHC.Real.$fShowRatio_$s$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S(SS),1*U(U,U)><L,U>m2,
 Unf=OtherCon []] =
    [] \r [w_s1jyR w1_s1jyS w2_s1jyT]
        case w_s1jyR of {
          GHC.Types.I# ww1_s1jyV [Occ=Once] ->
              case w1_s1jyS of {
                GHC.Real.:% ww3_s1jyX [Occ=Once] ww4_s1jyY [Occ=Once] ->
                    case
                        GHC.Real.$w$s$cshowsPrec ww1_s1jyV ww3_s1jyX ww4_s1jyY w2_s1jyT
                    of
                    { (#,#) ww6_s1jz0 [Occ=Once] ww7_s1jz1 [Occ=Once] ->
                          : [ww6_s1jz0 ww7_s1jz1];
                    };
              };
        };

GHC.Real.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> a -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jz2 ww_s1jz3 ww1_s1jz4 ww2_s1jz5]
        let {
          f_s1jz6 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s1jz2 ww1_s1jz4] \u []
                  GHC.Show.showsPrec w_s1jz2 GHC.Real.ratioPrec1 ww1_s1jz4; } in
        let {
          g1_s1jz7 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s1jz2 ww2_s1jz5] \u []
                  GHC.Show.showsPrec w_s1jz2 GHC.Real.ratioPrec1 ww2_s1jz5;
        } in 
          case ># [ww_s1jz3 7#] of {
            __DEFAULT ->
                let {
                  sat_s1jzc [Occ=OnceT[0]] :: GHC.Base.String -> GHC.Base.String
                  [LclId] =
                      [f_s1jz6 g1_s1jz7] \r [x_s1jz9]
                          let {
                            sat_s1jzb [Occ=Once] :: GHC.Base.String
                            [LclId] =
                                [g1_s1jz7 x_s1jz9] \u []
                                    let {
                                      sat_s1jza [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g1_s1jz7 x_s1jz9] \u [] g1_s1jz7 x_s1jz9;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          GHC.Real.$fShowRatio2 sat_s1jza;
                          } in  f_s1jz6 sat_s1jzb;
                } in  sat_s1jzc;
            1# ->
                let {
                  sat_s1jzi [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s1jz6 g1_s1jz7] \r [x_s1jzd]
                          let {
                            sat_s1jzh [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s1jz6 g1_s1jz7 x_s1jzd] \u []
                                    let {
                                      sat_s1jzg [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          [g1_s1jz7 x_s1jzd] \u []
                                              let {
                                                sat_s1jzf [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_s1jz7 x_s1jzd] \u []
                                                        let {
                                                          sat_s1jze [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_s1jzd];
                                                        } in  g1_s1jz7 sat_s1jze;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    GHC.Real.$fShowRatio2 sat_s1jzf;
                                    } in  f_s1jz6 sat_s1jzg;
                          } in  : [GHC.Show.$fShow(,)4 sat_s1jzh];
                } in  sat_s1jzi;
          };

GHC.Real.$fShowRatio_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> GHC.Real.Ratio a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jzj w1_s1jzk w2_s1jzl]
        case w1_s1jzk of {
          GHC.Types.I# ww1_s1jzn [Occ=Once] ->
              case w2_s1jzl of {
                GHC.Real.:% ww3_s1jzp [Occ=Once] ww4_s1jzq [Occ=Once] ->
                    GHC.Real.$w$cshowsPrec w_s1jzj ww1_s1jzn ww3_s1jzp ww4_s1jzq;
              };
        };

GHC.Real.$fShowRatio1
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S(SS),1*U(U,U)><L,U>m2, Unf=OtherCon []] =
    [] \r [w_s1jzr w1_s1jzs]
        case w_s1jzr of {
          GHC.Real.:% ww1_s1jzu [Occ=Once] ww2_s1jzv [Occ=Once] ->
              case GHC.Real.$w$s$cshowsPrec 0# ww1_s1jzu ww2_s1jzv w1_s1jzs of {
                (#,#) ww4_s1jzx [Occ=Once] ww5_s1jzy [Occ=Once] ->
                    : [ww4_s1jzx ww5_s1jzy];
              };
        };

GHC.Real.$fShowRatio_$s$cshowList
  :: [GHC.Real.Ratio GHC.Integer.Type.Integer] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s1jzz s_s1jzA]
        GHC.Show.showList__ GHC.Real.$fShowRatio1 ls_s1jzz s_s1jzA;

GHC.Real.$fShowRatio_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [GHC.Real.Ratio a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s1jzB ls_s1jzC s_s1jzD]
        let {
          sat_s1jzI [Occ=Once] :: GHC.Real.Ratio a_a1ePl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s1jzB] \r [w_s1jzE]
                  case w_s1jzE of {
                    GHC.Real.:% ww1_s1jzG [Occ=Once] ww2_s1jzH [Occ=Once] ->
                        GHC.Real.$w$cshowsPrec $dShow_s1jzB 0# ww1_s1jzG ww2_s1jzH;
                  };
        } in  GHC.Show.showList__ sat_s1jzI ls_s1jzC s_s1jzD;

GHC.Real.$w$s$cshow [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Types.Char, [GHC.Types.Char] #)
[GblId, Arity=2, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1jzJ ww1_s1jzK]
        let {
          sat_s1jzP [Occ=Once] :: GHC.Base.String
          [LclId] =
              [ww1_s1jzK] \u []
                  let {
                    sat_s1jzO [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [ww1_s1jzK] \u []
                            case GHC.Show.$w$cshowsPrec4 8# ww1_s1jzK GHC.Types.[] of {
                              (#,#) ww3_s1jzM [Occ=Once] ww4_s1jzN [Occ=Once] ->
                                  : [ww3_s1jzM ww4_s1jzN];
                            };
                  } in 
                    GHC.CString.unpackAppendCString# GHC.Real.$fShowRatio2 sat_s1jzO;
        } in  GHC.Show.$w$cshowsPrec4 8# ww_s1jzJ sat_s1jzP;

GHC.Real.$fShowRatio_$s$cshow [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Base.String
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m2, Unf=OtherCon []] =
    [] \r [w_s1jzQ]
        case w_s1jzQ of {
          GHC.Real.:% ww1_s1jzS [Occ=Once] ww2_s1jzT [Occ=Once] ->
              case GHC.Real.$w$s$cshow ww1_s1jzS ww2_s1jzT of {
                (#,#) ww4_s1jzV [Occ=Once] ww5_s1jzW [Occ=Once] ->
                    : [ww4_s1jzV ww5_s1jzW];
              };
        };

GHC.Real.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Show.Show a => a -> a -> GHC.Base.String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jzX ww_s1jzY ww1_s1jzZ]
        let {
          sat_s1jA1 [Occ=Once] :: GHC.Base.String
          [LclId] =
              [w_s1jzX ww1_s1jzZ] \u []
                  let {
                    sat_s1jA0 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [w_s1jzX ww1_s1jzZ] \u []
                            GHC.Show.showsPrec
                                w_s1jzX GHC.Real.ratioPrec1 ww1_s1jzZ GHC.Types.[];
                  } in 
                    GHC.CString.unpackAppendCString# GHC.Real.$fShowRatio2 sat_s1jA0;
        } in 
          GHC.Show.showsPrec w_s1jzX GHC.Real.ratioPrec1 ww_s1jzY sat_s1jA1;

GHC.Real.$fShowRatio_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Show.Show a => GHC.Real.Ratio a -> GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jA2 w1_s1jA3]
        case w1_s1jA3 of {
          GHC.Real.:% ww1_s1jA5 [Occ=Once] ww2_s1jA6 [Occ=Once] ->
              GHC.Real.$w$cshow w_s1jA2 ww1_s1jA5 ww2_s1jA6;
        };

GHC.Real.$fShowRatio_$s$fShowRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [GHC.Real.$fShowRatio_$s$cshowsPrec
                                    GHC.Real.$fShowRatio_$s$cshow
                                    GHC.Real.$fShowRatio_$s$cshowList];

GHC.Real.$fShowRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => GHC.Show.Show (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s1jA7]
        let {
          sat_s1jAa [Occ=Once] :: [GHC.Real.Ratio a_a1ePl] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s1jA7] \r [eta_B2 eta_B1]
                  GHC.Real.$fShowRatio_$cshowList $dShow_s1jA7 eta_B2 eta_B1; } in
        let {
          sat_s1jA9 [Occ=Once] :: GHC.Real.Ratio a_a1ePl -> GHC.Base.String
          [LclId] =
              [$dShow_s1jA7] \r [eta_B1]
                  GHC.Real.$fShowRatio_$cshow $dShow_s1jA7 eta_B1; } in
        let {
          sat_s1jA8 [Occ=Once]
            :: GHC.Types.Int -> GHC.Real.Ratio a_a1ePl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s1jA7] \r [eta_B2 eta_B1]
                  GHC.Real.$fShowRatio_$cshowsPrec $dShow_s1jA7 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s1jA8 sat_s1jA9 sat_s1jAa];

GHC.Real.$w$slcm [InlPrag=NOINLINE[1]]
  :: GHC.Types.Word -> GHC.Prim.Word# -> GHC.Prim.Word#
[GblId, Arity=2, Str=<L,1*U(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [w_s1jAb ww_s1jAc]
        case ww_s1jAc of wild_s1jAd {
          __DEFAULT ->
              case w_s1jAb of wild1_s1jAe {
                GHC.Types.W# x_s1jAf [Occ=Once!] ->
                    case x_s1jAf of wild2_s1jAg {
                      __DEFAULT ->
                          let {
                            sat_s1jAh [Occ=Once] :: GHC.Types.Word
                            [LclId] =
                                CCCS GHC.Types.W#! [wild_s1jAd];
                          } in 
                            case
                                GHC.Real.gcd GHC.Real.$fIntegralWord wild1_s1jAe sat_s1jAh
                            of
                            { GHC.Types.W# y#_s1jAj [Occ=Once!] ->
                                  case y#_s1jAj of wild4_s1jAk {
                                    __DEFAULT ->
                                        case quotWord# [wild2_s1jAg wild4_s1jAk] of wild5_s1jAl {
                                          __DEFAULT -> timesWord# [wild5_s1jAl wild_s1jAd];
                                        };
                                    0## -> GHC.Real.divZeroError;
                                  };
                            };
                      0## -> 0##;
                    };
              };
          0## -> 0##;
        };

GHC.Real.lcm_$slcm [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1jAn w1_s1jAo]
        case w1_s1jAo of {
          GHC.Types.W# ww1_s1jAq [Occ=Once] ->
              case GHC.Real.$w$slcm w_s1jAn ww1_s1jAq of ww2_s1jAr {
                __DEFAULT -> GHC.Types.W# [ww2_s1jAr];
              };
        };

GHC.Real.$w$slcm1 [InlPrag=NOINLINE[1]]
  :: GHC.Types.Int -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Str=<L,1*U(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [w_s1jAs ww_s1jAt]
        case ww_s1jAt of wild_s1jAu {
          __DEFAULT ->
              case w_s1jAs of wild1_s1jAv {
                GHC.Types.I# x_s1jAw [Occ=Once!] ->
                    case x_s1jAw of wild2_s1jAx {
                      __DEFAULT ->
                          let-no-escape {
                            $j_s1jAy [Occ=Once*!T[1], Dmd=<C(S),1*C1(U)>]
                              :: GHC.Prim.Int# -> GHC.Prim.Int#
                            [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                sat-only [wild_s1jAu wild1_s1jAv wild2_s1jAx] \r [ww1_s1jAz]
                                    let {
                                      sat_s1jAC [Occ=Once, Dmd=<L,1*U(U)>] :: GHC.Types.Int
                                      [LclId] =
                                          [wild1_s1jAv wild2_s1jAx] \s []
                                              case >=# [wild2_s1jAx 0#] of {
                                                __DEFAULT ->
                                                    case negateInt# [wild2_s1jAx] of sat_s1jAB {
                                                      __DEFAULT -> GHC.Types.I# [sat_s1jAB];
                                                    };
                                                1# -> wild1_s1jAv;
                                              };
                                    } in 
                                      case GHC.Real.$wgcd' sat_s1jAC ww1_s1jAz of {
                                        GHC.Types.I# x1_s1jAE [Occ=Once!] ->
                                            case x1_s1jAE of wild4_s1jAF {
                                              __DEFAULT ->
                                                  case
                                                      quotInt# [wild2_s1jAx wild4_s1jAF]
                                                  of
                                                  wild5_s1jAG
                                                  { __DEFAULT ->
                                                        case
                                                            *# [wild5_s1jAG wild_s1jAu]
                                                        of
                                                        x2_s1jAH [Dmd=<S,U>]
                                                        { __DEFAULT ->
                                                              case >=# [x2_s1jAH 0#] of {
                                                                __DEFAULT -> negateInt# [x2_s1jAH];
                                                                1# -> x2_s1jAH;
                                                              };
                                                        };
                                                  };
                                              -1# ->
                                                  case wild2_s1jAx of wild5_s1jAJ {
                                                    __DEFAULT ->
                                                        case
                                                            quotInt# [wild5_s1jAJ -1#]
                                                        of
                                                        sat_s1jAL
                                                        { __DEFAULT ->
                                                              case
                                                                  *# [sat_s1jAL wild_s1jAu]
                                                              of
                                                              x2_s1jAK [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case >=# [x2_s1jAK 0#] of {
                                                                      __DEFAULT ->
                                                                          negateInt# [x2_s1jAK];
                                                                      1# -> x2_s1jAK;
                                                                    };
                                                              };
                                                        };
                                                    -9223372036854775808# -> GHC.Real.overflowError;
                                                  };
                                              0# -> GHC.Real.divZeroError;
                                            };
                                      };
                          } in 
                            case >=# [wild_s1jAu 0#] of {
                              __DEFAULT ->
                                  case negateInt# [wild_s1jAu] of sat_s1jAQ {
                                    __DEFAULT -> $j_s1jAy sat_s1jAQ;
                                  };
                              1# -> $j_s1jAy wild_s1jAu;
                            };
                      0# -> 0#;
                    };
              };
          0# -> 0#;
        };

GHC.Real.lcm_$slcm1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1jAR w1_s1jAS]
        case w1_s1jAS of {
          GHC.Types.I# ww1_s1jAU [Occ=Once] ->
              case GHC.Real.$w$slcm1 w_s1jAR ww1_s1jAU of ww2_s1jAV {
                __DEFAULT -> GHC.Types.I# [ww2_s1jAV];
              };
        };

GHC.Real.lcm [InlPrag=NOINLINE[1]]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(SS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,1*C1(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,1*C1(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jAW eta_s1jAX eta1_s1jAY]
        case
            GHC.Real.$p1Integral $dIntegral_s1jAW
        of
        $dReal_s1jAZ [Dmd=<S(SS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,1*C1(C1(U)),A,1*C1(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1jAZ
              of
              $dNum_s1jB0 [Dmd=<S,U(A,A,1*C1(C1(U)),A,1*C1(U),A,C(U))>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p2Real $dReal_s1jAZ
                    of
                    $dOrd_s1jB1 [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                    { __DEFAULT ->
                          case
                              GHC.Classes.$p1Ord $dOrd_s1jB1
                          of
                          $dEq_s1jB2 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                          { __DEFAULT ->
                                let {
                                  sat_s1jB3 [Occ=Once] :: a_a1epg
                                  [LclId] =
                                      [$dNum_s1jB0] \u []
                                          GHC.Num.fromInteger $dNum_s1jB0 GHC.Real.even1;
                                } in 
                                  case GHC.Classes.== $dEq_s1jB2 eta1_s1jAY sat_s1jB3 of {
                                    GHC.Types.False ->
                                        let {
                                          sat_s1jB5 [Occ=Once] :: a_a1epg
                                          [LclId] =
                                              [$dNum_s1jB0] \u []
                                                  GHC.Num.fromInteger $dNum_s1jB0 GHC.Real.even1;
                                        } in 
                                          case GHC.Classes.== $dEq_s1jB2 eta_s1jAX sat_s1jB5 of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_s1jB9 [Occ=Once] :: a_a1epg
                                                  [LclId] =
                                                      [$dIntegral_s1jAW
                                                       eta_s1jAX
                                                       eta1_s1jAY
                                                       $dNum_s1jB0] \u []
                                                          let {
                                                            sat_s1jB8 [Occ=Once] :: a_a1epg
                                                            [LclId] =
                                                                [$dIntegral_s1jAW
                                                                 eta_s1jAX
                                                                 eta1_s1jAY] \u []
                                                                    let {
                                                                      sat_s1jB7 [Occ=Once]
                                                                        :: a_a1epg
                                                                      [LclId] =
                                                                          [$dIntegral_s1jAW
                                                                           eta_s1jAX
                                                                           eta1_s1jAY] \u []
                                                                              GHC.Real.gcd
                                                                                  $dIntegral_s1jAW
                                                                                  eta_s1jAX
                                                                                  eta1_s1jAY;
                                                                    } in 
                                                                      GHC.Real.quot
                                                                          $dIntegral_s1jAW
                                                                          eta_s1jAX
                                                                          sat_s1jB7;
                                                          } in 
                                                            GHC.Num.*
                                                                $dNum_s1jB0 sat_s1jB8 eta1_s1jAY;
                                                } in  GHC.Num.abs $dNum_s1jB0 sat_s1jB9;
                                            GHC.Types.True ->
                                                GHC.Num.fromInteger $dNum_s1jB0 GHC.Real.even1;
                                          };
                                    GHC.Types.True ->
                                        GHC.Num.fromInteger $dNum_s1jB0 GHC.Real.even1;
                                  };
                          };
                    };
              };
        };

GHC.Real.$w$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => GHC.Types.Int -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jBa w1_s1jBb]
        case
            GHC.Real.$p1Integral w_s1jBa
        of
        $dReal_s1jBc [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1jBc
              of
              $dNum_s1jBd [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
              { __DEFAULT ->
                    let {
                      sat_s1jBg [Occ=Once] :: GHC.Integer.Type.Integer
                      [LclId] =
                          [w1_s1jBb] \u []
                              case w1_s1jBb of {
                                GHC.Types.I# i_s1jBf [Occ=Once] ->
                                    GHC.Integer.Type.smallInteger i_s1jBf;
                              };
                    } in 
                      case GHC.Num.fromInteger $dNum_s1jBd sat_s1jBg of dt_s1jBh {
                        __DEFAULT ->
                            case
                                GHC.Num.fromInteger $dNum_s1jBd GHC.Real.$fEnumRatio1
                            of
                            dt1_s1jBi
                            { __DEFAULT -> (#,#) [dt_s1jBh dt1_s1jBi];
                            };
                      };
              };
        };

GHC.Real.$fEnumRatio_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Types.Int -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jBj w1_s1jBk]
        case GHC.Real.$w$ctoEnum w_s1jBj w1_s1jBk of {
          (#,#) ww1_s1jBm [Occ=Once] ww2_s1jBn [Occ=Once] ->
              GHC.Real.:% [ww1_s1jBm ww2_s1jBn];
        };

GHC.Real.$fEnumRatio_$s$fEnumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Enum.Enum (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Enum! [GHC.Real.$fEnumRatio_$s$csucc
                                    GHC.Real.$fEnumRatio_$s$cpred
                                    GHC.Real.$fEnumRatio_$ctoRational
                                    GHC.Real.$fEnumRatio_$s$cfromEnum
                                    GHC.Real.$fEnumRatio_$snumericEnumFrom
                                    GHC.Real.$fEnumRatio_$snumericEnumFromThen
                                    GHC.Real.$fEnumRatio_$snumericEnumFromTo
                                    GHC.Real.$fEnumRatio_$snumericEnumFromThenTo];

GHC.Real.$fEnumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Enum.Enum (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,A))),A,C(U))>m] =
    [] \r [$dIntegral_s1jBo]
        let {
          sat_s1jBw [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0
               -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1jBo] \u []
                  GHC.Real.$fEnumRatio_$cenumFromThenTo $dIntegral_s1jBo; } in
        let {
          sat_s1jBv [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1jBo] \u []
                  GHC.Real.$fEnumRatio_$cenumFromTo $dIntegral_s1jBo; } in
        let {
          sat_s1jBu [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1jBo] \u []
                  GHC.Real.$fEnumRatio_$cenumFromThen $dIntegral_s1jBo; } in
        let {
          sat_s1jBt [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1jBo] \u []
                  GHC.Real.$fEnumRatio_$cenumFrom $dIntegral_s1jBo; } in
        let {
          sat_s1jBs [Occ=Once] :: GHC.Real.Ratio a_a1eE0 -> GHC.Types.Int
          [LclId] =
              [$dIntegral_s1jBo] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$cfromEnum $dIntegral_s1jBo eta_B1; } in
        let {
          sat_s1jBr [Occ=Once] :: GHC.Types.Int -> GHC.Real.Ratio a_a1eE0
          [LclId] =
              [$dIntegral_s1jBo] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$ctoEnum $dIntegral_s1jBo eta_B1; } in
        let {
          sat_s1jBq [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0 -> GHC.Real.Ratio a_a1eE0
          [LclId] =
              [$dIntegral_s1jBo] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$cpred $dIntegral_s1jBo eta_B1; } in
        let {
          sat_s1jBp [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0 -> GHC.Real.Ratio a_a1eE0
          [LclId] =
              [$dIntegral_s1jBo] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$csucc $dIntegral_s1jBo eta_B1;
        } in 
          GHC.Enum.C:Enum [sat_s1jBp
                           sat_s1jBq
                           sat_s1jBr
                           sat_s1jBs
                           sat_s1jBt
                           sat_s1jBu
                           sat_s1jBv
                           sat_s1jBw];

$wg_r1j3P
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><S,U><S,U>,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s1jBx ww1_s1jBy ww2_s1jBz]
        case remInt# [ww1_s1jBy 2#] of {
          __DEFAULT ->
              case ww1_s1jBy of wild1_s1jBB {
                __DEFAULT ->
                    case *# [ww_s1jBx ww2_s1jBz] of sat_s1jBE {
                      __DEFAULT ->
                          case quotInt# [wild1_s1jBB 2#] of sat_s1jBD {
                            __DEFAULT ->
                                case *# [ww_s1jBx ww_s1jBx] of sat_s1jBC {
                                  __DEFAULT -> $wg_r1j3P sat_s1jBC sat_s1jBD sat_s1jBE;
                                };
                          };
                    };
                1# -> *# [ww_s1jBx ww2_s1jBz];
              };
          0# ->
              case quotInt# [ww1_s1jBy 2#] of sat_s1jBG {
                __DEFAULT ->
                    case *# [ww_s1jBx ww_s1jBx] of sat_s1jBF {
                      __DEFAULT -> $wg_r1j3P sat_s1jBF sat_s1jBG ww2_s1jBz;
                    };
              };
        };

GHC.Real.$wf1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1jBH ww1_s1jBI]
        case remInt# [ww1_s1jBI 2#] of {
          __DEFAULT ->
              case ww1_s1jBI of wild1_s1jBK {
                __DEFAULT ->
                    case quotInt# [wild1_s1jBK 2#] of sat_s1jBM {
                      __DEFAULT ->
                          case *# [ww_s1jBH ww_s1jBH] of sat_s1jBL {
                            __DEFAULT -> $wg_r1j3P sat_s1jBL sat_s1jBM ww_s1jBH;
                          };
                    };
                1# -> ww_s1jBH;
              };
          0# ->
              case quotInt# [ww1_s1jBI 2#] of sat_s1jBO {
                __DEFAULT ->
                    case *# [ww_s1jBH ww_s1jBH] of sat_s1jBN {
                      __DEFAULT -> GHC.Real.$wf1 sat_s1jBN sat_s1jBO;
                    };
              };
        };

GHC.Real.^_f2 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jBP w1_s1jBQ]
        case w_s1jBP of {
          GHC.Types.I# ww1_s1jBS [Occ=Once] ->
              case w1_s1jBQ of {
                GHC.Types.I# ww3_s1jBU [Occ=Once] ->
                    case GHC.Real.$wf1 ww1_s1jBS ww3_s1jBU of ww4_s1jBV {
                      __DEFAULT -> GHC.Types.I# [ww4_s1jBV];
                    };
              };
        };

GHC.Real.^3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

GHC.Real.^2 :: GHC.Types.Int
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1jBW {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1jBW;
        };

GHC.Real.^_$s^2 [InlPrag=NOUSERINLINE[1]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [x0_s1jBX y0_s1jBY]
        case y0_s1jBY of {
          GHC.Types.I# x_s1jC0 ->
              case <# [x_s1jC0 0#] of {
                __DEFAULT ->
                    case x_s1jC0 of wild1_s1jC2 {
                      __DEFAULT ->
                          case x0_s1jBX of {
                            GHC.Types.I# ww1_s1jC4 [Occ=Once] ->
                                case GHC.Real.$wf1 ww1_s1jC4 wild1_s1jC2 of ww2_s1jC5 {
                                  __DEFAULT -> GHC.Types.I# [ww2_s1jC5];
                                };
                          };
                      0# -> GHC.Real.^3;
                    };
                1# -> GHC.Real.^2;
              };
        };

$wg1_r1j3Q
  :: GHC.Integer.Type.Integer
     -> GHC.Prim.Int#
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
[GblId, Arity=3, Str=<S,U><S,U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_s1jC6 ww_s1jC7 w1_s1jC8]
        case remInt# [ww_s1jC7 2#] of {
          __DEFAULT ->
              case ww_s1jC7 of wild1_s1jCa {
                __DEFAULT ->
                    case GHC.Integer.Type.timesInteger w_s1jC6 w1_s1jC8 of sat_s1jCd {
                      __DEFAULT ->
                          case quotInt# [wild1_s1jCa 2#] of sat_s1jCc {
                            __DEFAULT ->
                                case GHC.Integer.Type.timesInteger w_s1jC6 w_s1jC6 of sat_s1jCb {
                                  __DEFAULT -> $wg1_r1j3Q sat_s1jCb sat_s1jCc sat_s1jCd;
                                };
                          };
                    };
                1# -> GHC.Integer.Type.timesInteger w_s1jC6 w1_s1jC8;
              };
          0# ->
              case quotInt# [ww_s1jC7 2#] of sat_s1jCf {
                __DEFAULT ->
                    case GHC.Integer.Type.timesInteger w_s1jC6 w_s1jC6 of sat_s1jCe {
                      __DEFAULT -> $wg1_r1j3Q sat_s1jCe sat_s1jCf w1_s1jC8;
                    };
              };
        };

GHC.Real.$wf [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Prim.Int# -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [w_s1jCg ww_s1jCh]
        case remInt# [ww_s1jCh 2#] of {
          __DEFAULT ->
              case ww_s1jCh of wild1_s1jCj {
                __DEFAULT ->
                    case quotInt# [wild1_s1jCj 2#] of sat_s1jCl {
                      __DEFAULT ->
                          case GHC.Integer.Type.timesInteger w_s1jCg w_s1jCg of sat_s1jCk {
                            __DEFAULT -> $wg1_r1j3Q sat_s1jCk sat_s1jCl w_s1jCg;
                          };
                    };
                1# -> w_s1jCg;
              };
          0# ->
              case quotInt# [ww_s1jCh 2#] of sat_s1jCn {
                __DEFAULT ->
                    case GHC.Integer.Type.timesInteger w_s1jCg w_s1jCg of sat_s1jCm {
                      __DEFAULT -> GHC.Real.$wf sat_s1jCm sat_s1jCn;
                    };
              };
        };

GHC.Real.^_f1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [w_s1jCo w1_s1jCp]
        case w1_s1jCp of {
          GHC.Types.I# ww1_s1jCr [Occ=Once] ->
              GHC.Real.$wf w_s1jCo ww1_s1jCr;
        };

GHC.Real.^_$s^1 [InlPrag=NOUSERINLINE[1]]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<L,U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x0_s1jCs y0_s1jCt]
        case y0_s1jCt of {
          GHC.Types.I# x_s1jCv ->
              case <# [x_s1jCv 0#] of {
                __DEFAULT ->
                    case x_s1jCv of wild1_s1jCx {
                      __DEFAULT -> GHC.Real.$wf x0_s1jCs wild1_s1jCx;
                      0# -> GHC.Real.$fEnumRatio1;
                    };
                1# -> GHC.Real.^1;
              };
        };

lvl6_r1j3R :: GHC.Real.Rational
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1jCy {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1jCy;
        };

lvl7_r1j3S :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1jCz {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1jCz;
        };

GHC.Real.^ [InlPrag=INLINABLE[1]]
  :: forall a b. (GHC.Num.Num a, GHC.Real.Integral b) => a -> b -> a
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))><S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s1jCA $dIntegral_s1jCB eta_s1jCC eta1_s1jCD]
        case
            GHC.Real.$p1Integral $dIntegral_s1jCB
        of
        $dReal_s1jCE [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum1_s1jCF [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num b_a1eqq
                [LclId] =
                    [$dReal_s1jCE] \u [] GHC.Real.$p1Real $dReal_s1jCE;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1jCE
                of
                $dOrd_s1jCG [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1jCH [Occ=Once] :: b_a1eqq
                        [LclId] =
                            [$dNum1_s1jCF] \u []
                                GHC.Num.fromInteger $dNum1_s1jCF GHC.Real.even1;
                      } in 
                        case GHC.Classes.< $dOrd_s1jCG eta1_s1jCD sat_s1jCH of {
                          GHC.Types.False ->
                              let {
                                sat_s1jCK [Occ=Once] :: b_a1eqq
                                [LclId] =
                                    [$dNum1_s1jCF] \u []
                                        GHC.Num.fromInteger $dNum1_s1jCF GHC.Real.even1;
                              } in 
                                case GHC.Classes.$p1Ord $dOrd_s1jCG of sat_s1jCJ {
                                  __DEFAULT ->
                                      case GHC.Classes.== sat_s1jCJ eta1_s1jCD sat_s1jCK of {
                                        GHC.Types.False ->
                                            let {
                                              lvl8_s1jCM :: b_a1eqq
                                              [LclId] =
                                                  [$dNum1_s1jCF] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum1_s1jCF GHC.Real.even2;
                                            } in 
                                              let-no-escape {
                                                exit_s1jCN [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                                  :: a_a1eqp -> b_a1eqq -> a_a1eqp
                                                [LclId[JoinId(2)],
                                                 Arity=2,
                                                 Str=<L,U><L,U>,
                                                 Unf=OtherCon []] =
                                                    sat-only [$dNum_s1jCA
                                                              $dIntegral_s1jCB
                                                              $dNum1_s1jCF
                                                              $dOrd_s1jCG
                                                              lvl8_s1jCM] \r [x_s1jCO y_s1jCP]
                                                        case
                                                            GHC.Classes.$p1Ord $dOrd_s1jCG
                                                        of
                                                        $dEq_s1jCQ [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                                        { __DEFAULT ->
                                                              let {
                                                                lvl9_s1jCR :: b_a1eqq
                                                                [LclId] =
                                                                    [$dNum1_s1jCF] \u []
                                                                        GHC.Num.fromInteger
                                                                            $dNum1_s1jCF
                                                                            GHC.Real.$fEnumRatio1;
                                                              } in 
                                                                case
                                                                    GHC.Classes.==
                                                                        $dEq_s1jCQ
                                                                        y_s1jCP
                                                                        lvl9_s1jCR
                                                                of
                                                                { GHC.Types.False ->
                                                                      let {
                                                                        sat_s1jD8 [Occ=Once]
                                                                          :: b_a1eqq
                                                                        [LclId] =
                                                                            [$dIntegral_s1jCB
                                                                             lvl8_s1jCM
                                                                             y_s1jCP] \u []
                                                                                GHC.Real.quot
                                                                                    $dIntegral_s1jCB
                                                                                    y_s1jCP
                                                                                    lvl8_s1jCM; } in
                                                                      let {
                                                                        sat_s1jD7 [Occ=Once]
                                                                          :: a_a1eqp
                                                                        [LclId] =
                                                                            [$dNum_s1jCA
                                                                             x_s1jCO] \u []
                                                                                GHC.Num.*
                                                                                    $dNum_s1jCA
                                                                                    x_s1jCO
                                                                                    x_s1jCO;
                                                                      } in 
                                                                        let-no-escape {
                                                                          exit1_s1jCT [Occ=OnceL!T[2],
                                                                                       Dmd=<C(C(S)),C(C1(U))>]
                                                                            :: a_a1eqp
                                                                               -> a_a1eqp -> a_a1eqp
                                                                          [LclId[JoinId(2)],
                                                                           Arity=2,
                                                                           Str=<L,U><L,U>,
                                                                           Unf=OtherCon []] =
                                                                              sat-only [$dNum_s1jCA] \r [x1_s1jCU
                                                                                                         z_s1jCV]
                                                                                  GHC.Num.*
                                                                                      $dNum_s1jCA
                                                                                      x1_s1jCU
                                                                                      z_s1jCV;
                                                                        } in 
                                                                          let-no-escape {
                                                                            g1_s1jCW [Occ=LoopBreakerT[3]]
                                                                              :: a_a1eqp
                                                                                 -> b_a1eqq
                                                                                 -> a_a1eqp
                                                                                 -> a_a1eqp
                                                                            [LclId[JoinId(3)],
                                                                             Arity=3,
                                                                             Str=<L,U><L,U><L,U>,
                                                                             Unf=OtherCon []] =
                                                                                sat-only [$dNum_s1jCA
                                                                                          $dIntegral_s1jCB
                                                                                          lvl8_s1jCM
                                                                                          $dEq_s1jCQ
                                                                                          lvl9_s1jCR
                                                                                          exit1_s1jCT
                                                                                          g1_s1jCW] \r [x1_s1jCX
                                                                                                        y1_s1jCY
                                                                                                        z_s1jCZ]
                                                                                    case
                                                                                        GHC.Real.even
                                                                                            $dIntegral_s1jCB
                                                                                            y1_s1jCY
                                                                                    of
                                                                                    { GHC.Types.False ->
                                                                                          case
                                                                                              GHC.Classes.==
                                                                                                  $dEq_s1jCQ
                                                                                                  y1_s1jCY
                                                                                                  lvl9_s1jCR
                                                                                          of
                                                                                          { GHC.Types.False ->
                                                                                                let {
                                                                                                  sat_s1jD4 [Occ=Once]
                                                                                                    :: a_a1eqp
                                                                                                  [LclId] =
                                                                                                      [$dNum_s1jCA
                                                                                                       x1_s1jCX
                                                                                                       z_s1jCZ] \u []
                                                                                                          GHC.Num.*
                                                                                                              $dNum_s1jCA
                                                                                                              x1_s1jCX
                                                                                                              z_s1jCZ; } in
                                                                                                let {
                                                                                                  sat_s1jD3 [Occ=Once]
                                                                                                    :: b_a1eqq
                                                                                                  [LclId] =
                                                                                                      [$dIntegral_s1jCB
                                                                                                       lvl8_s1jCM
                                                                                                       y1_s1jCY] \u []
                                                                                                          GHC.Real.quot
                                                                                                              $dIntegral_s1jCB
                                                                                                              y1_s1jCY
                                                                                                              lvl8_s1jCM; } in
                                                                                                let {
                                                                                                  sat_s1jD2 [Occ=Once]
                                                                                                    :: a_a1eqp
                                                                                                  [LclId] =
                                                                                                      [$dNum_s1jCA
                                                                                                       x1_s1jCX] \u []
                                                                                                          GHC.Num.*
                                                                                                              $dNum_s1jCA
                                                                                                              x1_s1jCX
                                                                                                              x1_s1jCX;
                                                                                                } in 
                                                                                                  g1_s1jCW
                                                                                                      sat_s1jD2
                                                                                                      sat_s1jD3
                                                                                                      sat_s1jD4;
                                                                                            GHC.Types.True ->
                                                                                                exit1_s1jCT
                                                                                                    x1_s1jCX
                                                                                                    z_s1jCZ;
                                                                                          };
                                                                                      GHC.Types.True ->
                                                                                          let {
                                                                                            sat_s1jD6 [Occ=Once]
                                                                                              :: b_a1eqq
                                                                                            [LclId] =
                                                                                                [$dIntegral_s1jCB
                                                                                                 lvl8_s1jCM
                                                                                                 y1_s1jCY] \u []
                                                                                                    GHC.Real.quot
                                                                                                        $dIntegral_s1jCB
                                                                                                        y1_s1jCY
                                                                                                        lvl8_s1jCM; } in
                                                                                          let {
                                                                                            sat_s1jD5 [Occ=Once]
                                                                                              :: a_a1eqp
                                                                                            [LclId] =
                                                                                                [$dNum_s1jCA
                                                                                                 x1_s1jCX] \u []
                                                                                                    GHC.Num.*
                                                                                                        $dNum_s1jCA
                                                                                                        x1_s1jCX
                                                                                                        x1_s1jCX;
                                                                                          } in 
                                                                                            g1_s1jCW
                                                                                                sat_s1jD5
                                                                                                sat_s1jD6
                                                                                                z_s1jCZ;
                                                                                    };
                                                                          } in 
                                                                            g1_s1jCW
                                                                                sat_s1jD7
                                                                                sat_s1jD8
                                                                                x_s1jCO;
                                                                  GHC.Types.True -> x_s1jCO;
                                                                };
                                                        };
                                              } in 
                                                let-no-escape {
                                                  f_s1jD9 [Occ=LoopBreakerT[2]]
                                                    :: a_a1eqp -> b_a1eqq -> a_a1eqp
                                                  [LclId[JoinId(2)],
                                                   Arity=2,
                                                   Str=<L,U><L,U>,
                                                   Unf=OtherCon []] =
                                                      sat-only [$dNum_s1jCA
                                                                $dIntegral_s1jCB
                                                                lvl8_s1jCM
                                                                exit_s1jCN
                                                                f_s1jD9] \r [x_s1jDa y_s1jDb]
                                                          case
                                                              GHC.Real.even $dIntegral_s1jCB y_s1jDb
                                                          of
                                                          { GHC.Types.False ->
                                                                exit_s1jCN x_s1jDa y_s1jDb;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_s1jDe [Occ=Once] :: b_a1eqq
                                                                  [LclId] =
                                                                      [$dIntegral_s1jCB
                                                                       lvl8_s1jCM
                                                                       y_s1jDb] \u []
                                                                          GHC.Real.quot
                                                                              $dIntegral_s1jCB
                                                                              y_s1jDb
                                                                              lvl8_s1jCM; } in
                                                                let {
                                                                  sat_s1jDd [Occ=Once] :: a_a1eqp
                                                                  [LclId] =
                                                                      [$dNum_s1jCA x_s1jDa] \u []
                                                                          GHC.Num.*
                                                                              $dNum_s1jCA
                                                                              x_s1jDa
                                                                              x_s1jDa;
                                                                } in  f_s1jD9 sat_s1jDd sat_s1jDe;
                                                          };
                                                } in  f_s1jD9 eta_s1jCC eta1_s1jCD;
                                        GHC.Types.True ->
                                            GHC.Num.fromInteger $dNum_s1jCA GHC.Real.$fEnumRatio1;
                                      };
                                };
                          GHC.Types.True -> lvl7_r1j3S;
                        };
                };
        };
GHC.Real.^%^ [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Rational -> a -> GHC.Real.Rational
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1jDf w1_s1jDg w2_s1jDh]
        case w1_s1jDg of {
          GHC.Real.:% ww1_s1jDj [Occ=Once] ww2_s1jDk [Occ=Once] ->
              case GHC.Real.$w^%^ w_s1jDf ww1_s1jDj ww2_s1jDk w2_s1jDh of {
                (#,#) ww4_s1jDm [Occ=Once] ww5_s1jDn [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jDm ww5_s1jDn];
              };
        };
GHC.Real.$w^%^ [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> a
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jDo ww_s1jDp ww1_s1jDq w1_s1jDr]
        case
            GHC.Real.$p1Integral w_s1jDo
        of
        $dReal_s1jDs [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jDt [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_s1hK5
                [LclId] =
                    [$dReal_s1jDs] \u [] GHC.Real.$p1Real $dReal_s1jDs;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1jDs
                of
                $dOrd_s1jDu [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1jDv [Occ=Once] :: a_s1hK5
                        [LclId] =
                            [$dNum_s1jDt] \u [] GHC.Num.fromInteger $dNum_s1jDt GHC.Real.even1;
                      } in 
                        case GHC.Classes.< $dOrd_s1jDu w1_s1jDr sat_s1jDv of {
                          GHC.Types.False ->
                              let {
                                sat_s1jDy [Occ=Once] :: a_s1hK5
                                [LclId] =
                                    [$dNum_s1jDt] \u []
                                        GHC.Num.fromInteger $dNum_s1jDt GHC.Real.even1;
                              } in 
                                case GHC.Classes.$p1Ord $dOrd_s1jDu of sat_s1jDx {
                                  __DEFAULT ->
                                      case GHC.Classes.== sat_s1jDx w1_s1jDr sat_s1jDy of {
                                        GHC.Types.False ->
                                            case
                                                GHC.Real.^
                                                    GHC.Num.$fNumInteger w_s1jDo ww_s1jDp w1_s1jDr
                                            of
                                            dt_s1jDA
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Real.^
                                                          GHC.Num.$fNumInteger
                                                          w_s1jDo
                                                          ww1_s1jDq
                                                          w1_s1jDr
                                                  of
                                                  dt1_s1jDB
                                                  { __DEFAULT -> (#,#) [dt_s1jDA dt1_s1jDB];
                                                  };
                                            };
                                        GHC.Types.True ->
                                            (#,#) [GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1];
                                      };
                                };
                          GHC.Types.True -> lvl6_r1j3R;
                        };
                };
        };

GHC.Real.$w^^%^^ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> a
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId,
 Arity=4,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLLLL),U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,1*C1(C1(U)),A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jDD ww_s1jDE ww1_s1jDF w1_s1jDG]
        case
            GHC.Real.$p1Integral w_s1jDD
        of
        $dReal_s1jDH [Dmd=<S(LS(LLLLC(C(S))LLL)L),U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,1*C1(C1(U)),A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jDI [Dmd=<L,U(A,A,A,C(U),A,A,C(U))>] :: GHC.Num.Num a_s1hKi
                [LclId] =
                    [$dReal_s1jDH] \u [] GHC.Real.$p1Real $dReal_s1jDH;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1jDH
                of
                $dOrd_s1jDJ [Dmd=<S(LLLLC(C(S))LLL),U(1*U(1*C1(C1(U)),A),A,A,A,1*C1(C1(U)),A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1jDK [Occ=Once] :: a_s1hKi
                        [LclId] =
                            [$dNum_s1jDI] \u [] GHC.Num.fromInteger $dNum_s1jDI GHC.Real.even1;
                      } in 
                        case GHC.Classes.> $dOrd_s1jDJ w1_s1jDG sat_s1jDK of {
                          GHC.Types.False ->
                              let {
                                sat_s1jDN [Occ=Once] :: a_s1hKi
                                [LclId] =
                                    [$dNum_s1jDI] \u []
                                        GHC.Num.fromInteger $dNum_s1jDI GHC.Real.even1;
                              } in 
                                case GHC.Classes.$p1Ord $dOrd_s1jDJ of sat_s1jDM {
                                  __DEFAULT ->
                                      case GHC.Classes.== sat_s1jDM w1_s1jDG sat_s1jDN of {
                                        GHC.Types.False ->
                                            case
                                                GHC.Integer.Type.gtInteger# ww_s1jDE GHC.Real.even1
                                            of
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.eqInteger#
                                                          ww_s1jDE GHC.Real.even1
                                                  of
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_s1jDT [Occ=Once] :: a_s1hKi
                                                          [LclId] =
                                                              [w1_s1jDG $dNum_s1jDI] \u []
                                                                  GHC.Num.negate
                                                                      $dNum_s1jDI w1_s1jDG; } in
                                                        let {
                                                          sat_s1jDS [Occ=Once]
                                                            :: GHC.Integer.Type.Integer
                                                          [LclId] =
                                                              [ww_s1jDE] \u []
                                                                  GHC.Integer.Type.negateInteger
                                                                      ww_s1jDE;
                                                        } in 
                                                          case
                                                              GHC.Real.^
                                                                  GHC.Num.$fNumInteger
                                                                  w_s1jDD
                                                                  sat_s1jDS
                                                                  sat_s1jDT
                                                          of
                                                          dd_s1jDR [Dmd=<S,1*U>]
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1jDV [Occ=Once] :: a_s1hKi
                                                                  [LclId] =
                                                                      [w1_s1jDG $dNum_s1jDI] \u []
                                                                          GHC.Num.negate
                                                                              $dNum_s1jDI w1_s1jDG;
                                                                } in 
                                                                  case
                                                                      GHC.Real.^
                                                                          GHC.Num.$fNumInteger
                                                                          w_s1jDD
                                                                          ww1_s1jDF
                                                                          sat_s1jDV
                                                                  of
                                                                  nn_s1jDU [Dmd=<S,1*U>]
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Real.even
                                                                                w_s1jDD w1_s1jDG
                                                                        of
                                                                        { GHC.Types.False ->
                                                                              case
                                                                                  GHC.Integer.Type.negateInteger
                                                                                      nn_s1jDU
                                                                              of
                                                                              dt_s1jDX
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        dd_s1jDR
                                                                                    of
                                                                                    dt1_s1jDY
                                                                                    { __DEFAULT ->
                                                                                          (#,#) [dt_s1jDX
                                                                                                 dt1_s1jDY];
                                                                                    };
                                                                              };
                                                                          GHC.Types.True ->
                                                                              case
                                                                                  nn_s1jDU
                                                                              of
                                                                              dt_s1jDZ
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        dd_s1jDR
                                                                                    of
                                                                                    dt1_s1jE0
                                                                                    { __DEFAULT ->
                                                                                          (#,#) [dt_s1jDZ
                                                                                                 dt1_s1jE0];
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                          };
                                                    1# -> GHC.Real.ratioZeroDenominatorError;
                                                  };
                                              1# ->
                                                  let {
                                                    sat_s1jE2 [Occ=Once] :: a_s1hKi
                                                    [LclId] =
                                                        [w1_s1jDG $dNum_s1jDI] \u []
                                                            GHC.Num.negate $dNum_s1jDI w1_s1jDG;
                                                  } in 
                                                    case
                                                        GHC.Real.^
                                                            GHC.Num.$fNumInteger
                                                            w_s1jDD
                                                            ww1_s1jDF
                                                            sat_s1jE2
                                                    of
                                                    dt_s1jE3
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_s1jE4 [Occ=Once] :: a_s1hKi
                                                            [LclId] =
                                                                [w1_s1jDG $dNum_s1jDI] \u []
                                                                    GHC.Num.negate
                                                                        $dNum_s1jDI w1_s1jDG;
                                                          } in 
                                                            case
                                                                GHC.Real.^
                                                                    GHC.Num.$fNumInteger
                                                                    w_s1jDD
                                                                    ww_s1jDE
                                                                    sat_s1jE4
                                                            of
                                                            dt1_s1jE5
                                                            { __DEFAULT ->
                                                                  (#,#) [dt_s1jE3 dt1_s1jE5];
                                                            };
                                                    };
                                            };
                                        GHC.Types.True ->
                                            (#,#) [GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1];
                                      };
                                };
                          GHC.Types.True ->
                              case
                                  GHC.Real.^ GHC.Num.$fNumInteger w_s1jDD ww_s1jDE w1_s1jDG
                              of
                              dt_s1jE6
                              { __DEFAULT ->
                                    case
                                        GHC.Real.^ GHC.Num.$fNumInteger w_s1jDD ww1_s1jDF w1_s1jDG
                                    of
                                    dt1_s1jE7
                                    { __DEFAULT -> (#,#) [dt_s1jE6 dt1_s1jE7];
                                    };
                              };
                        };
                };
        };

GHC.Real.^^%^^ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Rational -> a -> GHC.Real.Rational
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLLLL),U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,C(C1(U)),A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1jE8 w1_s1jE9 w2_s1jEa]
        case w1_s1jE9 of {
          GHC.Real.:% ww1_s1jEc [Occ=Once] ww2_s1jEd [Occ=Once] ->
              case GHC.Real.$w^^%^^ w_s1jE8 ww1_s1jEc ww2_s1jEd w2_s1jEa of {
                (#,#) ww4_s1jEf [Occ=Once] ww5_s1jEg [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jEf ww5_s1jEg];
              };
        };

GHC.Real.^^ [InlPrag=INLINABLE[1]]
  :: forall a b.
     (GHC.Real.Fractional a, GHC.Real.Integral b) =>
     a -> b -> a
[GblId,
 Arity=4,
 Str=<L,U(1*U(A,A,C(C1(U)),A,A,A,1*C1(U)),A,1*C1(U),A)><S(S(LS(LLLLLC(C(S))LL)L)LLLLLLLL),U(U(U(A,A,A,1*C1(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,1*C1(C1(U)),A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_s1jEh $dIntegral_s1jEi eta_s1jEj eta1_s1jEk]
        case
            GHC.Real.$p1Integral $dIntegral_s1jEi
        of
        $dReal_s1jEl [Dmd=<S(LS(LLLLLC(C(S))LL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,A,A,A,1*C1(C1(U)),A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jEm [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>]
                  :: GHC.Num.Num b_a1etw
                [LclId] =
                    [$dReal_s1jEl] \u [] GHC.Real.$p1Real $dReal_s1jEl; } in
              let {
                sat_s1jEo [Occ=Once] :: b_a1etw
                [LclId] =
                    [$dNum_s1jEm] \u [] GHC.Num.fromInteger $dNum_s1jEm GHC.Real.even1;
              } in 
                case GHC.Real.$p2Real $dReal_s1jEl of sat_s1jEn {
                  __DEFAULT ->
                      case GHC.Classes.>= sat_s1jEn eta1_s1jEk sat_s1jEo of {
                        GHC.Types.False ->
                            let {
                              sat_s1jEs [Occ=Once] :: a_a1etv
                              [LclId] =
                                  [$dFractional_s1jEh
                                   $dIntegral_s1jEi
                                   eta_s1jEj
                                   eta1_s1jEk
                                   $dNum_s1jEm] \u []
                                      let {
                                        sat_s1jEr [Occ=Once] :: b_a1etw
                                        [LclId] =
                                            [eta1_s1jEk $dNum_s1jEm] \u []
                                                GHC.Num.negate $dNum_s1jEm eta1_s1jEk; } in
                                      let {
                                        sat_s1jEq [Occ=Once, Dmd=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>]
                                          :: GHC.Num.Num a_a1etv
                                        [LclId] =
                                            [$dFractional_s1jEh] \u []
                                                GHC.Real.$p1Fractional $dFractional_s1jEh;
                                      } in 
                                        GHC.Real.^ sat_s1jEq $dIntegral_s1jEi eta_s1jEj sat_s1jEr;
                            } in  GHC.Real.recip $dFractional_s1jEh sat_s1jEs;
                        GHC.Types.True ->
                            let {
                              sat_s1jEt [Occ=Once, Dmd=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>]
                                :: GHC.Num.Num a_a1etv
                              [LclId] =
                                  [$dFractional_s1jEh] \u []
                                      GHC.Real.$p1Fractional $dFractional_s1jEh;
                            } in  GHC.Real.^ sat_s1jEt $dIntegral_s1jEi eta_s1jEj eta1_s1jEk;
                      };
                };
        };

GHC.Real.C:Fractional
  :: forall a.
     GHC.Num.Num a =>
     (a -> a -> a)
     -> (a -> a) -> (GHC.Real.Rational -> a) -> GHC.Real.Fractional a
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Real.C:Fractional [eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Real.C:Integral
  :: forall a.
     (GHC.Real.Real a, GHC.Enum.Enum a) =>
     (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> (a, a))
     -> (a -> a -> (a, a))
     -> (a -> GHC.Integer.Type.Integer)
     -> GHC.Real.Integral a
[GblId[DataCon],
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B9
           eta_B8
           eta_B7
           eta_B6
           eta_B5
           eta_B4
           eta_B3
           eta_B2
           eta_B1]
        GHC.Real.C:Integral [eta_B9
                             eta_B8
                             eta_B7
                             eta_B6
                             eta_B5
                             eta_B4
                             eta_B3
                             eta_B2
                             eta_B1];

GHC.Real.C:Real
  :: forall a.
     (GHC.Num.Num a, GHC.Classes.Ord a) =>
     (a -> GHC.Real.Rational) -> GHC.Real.Real a
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Real.C:Real [eta_B3 eta_B2 eta_B1];

GHC.Real.C:RealFrac
  :: forall a.
     (GHC.Real.Real a, GHC.Real.Fractional a) =>
     (forall b. GHC.Real.Integral b => a -> (b, a))
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> GHC.Real.RealFrac a
[GblId[DataCon],
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Real.C:RealFrac [eta_B7
                             eta_B6
                             eta_B5
                             eta_B4
                             eta_B3
                             eta_B2
                             eta_B1];

GHC.Real.:% :: forall a. a -> a -> GHC.Real.Ratio a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Real.:% [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 15:56:02.162552378 UTC

GHC.Real.$p1Fractional
  :: forall a. GHC.Real.Fractional a => GHC.Num.Num a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_s1j3U]
        case v_s1j3U of {
          GHC.Real.C:Fractional v_s1j3W [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_s1j3W;
        };

GHC.Real./ :: forall a. GHC.Real.Fractional a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_s1j40]
        case v_s1j40 of {
          GHC.Real.C:Fractional _ [Occ=Dead]
                                v_s1j43 [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_s1j43;
        };

GHC.Real.recip :: forall a. GHC.Real.Fractional a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_s1j46]
        case v_s1j46 of {
          GHC.Real.C:Fractional _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_s1j4a [Occ=Once]
                                _ [Occ=Dead] ->
              v_s1j4a;
        };

GHC.Real.fromRational
  :: forall a. GHC.Real.Fractional a => GHC.Real.Rational -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_s1j4c]
        case v_s1j4c of {
          GHC.Real.C:Fractional _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_s1j4h [Occ=Once] ->
              v_s1j4h;
        };

GHC.Real.$p1Integral
  :: forall a. GHC.Real.Integral a => GHC.Real.Real a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLL),U(U,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1j4i]
        case v_s1j4i of {
          GHC.Real.C:Integral v_s1j4k [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j4k;
        };

GHC.Real.$p2Integral
  :: forall a. GHC.Real.Integral a => GHC.Enum.Enum a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLL),U(A,U,A,A,A,A,A,A,A)>] =
    [] \r [v_s1j4t]
        case v_s1j4t of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              v_s1j4w [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j4w;
        };

GHC.Real.quot :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLL),U(A,A,U,A,A,A,A,A,A)>] =
    [] \r [v_s1j4E]
        case v_s1j4E of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j4I [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j4I;
        };

GHC.Real.rem :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLL),U(A,A,A,U,A,A,A,A,A)>] =
    [] \r [v_s1j4P]
        case v_s1j4P of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j4U [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j4U;
        };

GHC.Real.div :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLL),U(A,A,A,A,U,A,A,A,A)>] =
    [] \r [v_s1j50]
        case v_s1j50 of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j56 [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j56;
        };

GHC.Real.mod :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLL),U(A,A,A,A,A,U,A,A,A)>] =
    [] \r [v_s1j5b]
        case v_s1j5b of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j5i [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j5i;
        };

GHC.Real.quotRem
  :: forall a. GHC.Real.Integral a => a -> a -> (a, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLL),U(A,A,A,A,A,A,U,A,A)>] =
    [] \r [v_s1j5m]
        case v_s1j5m of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j5u [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j5u;
        };

GHC.Real.divMod
  :: forall a. GHC.Real.Integral a => a -> a -> (a, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSL),U(A,A,A,A,A,A,A,U,A)>] =
    [] \r [v_s1j5x]
        case v_s1j5x of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j5G [Occ=Once]
                              _ [Occ=Dead] ->
              v_s1j5G;
        };

GHC.Real.toInteger
  :: forall a. GHC.Real.Integral a => a -> GHC.Integer.Type.Integer
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLS),U(A,A,A,A,A,A,A,A,U)>] =
    [] \r [v_s1j5I]
        case v_s1j5I of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j5S [Occ=Once] ->
              v_s1j5S;
        };

GHC.Real.$p1Real :: forall a. GHC.Real.Real a => GHC.Num.Num a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_s1j5T]
        case v_s1j5T of {
          GHC.Real.C:Real v_s1j5V [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
              v_s1j5V;
        };

GHC.Real.$p2Real :: forall a. GHC.Real.Real a => GHC.Classes.Ord a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_s1j5Y]
        case v_s1j5Y of {
          GHC.Real.C:Real _ [Occ=Dead] v_s1j61 [Occ=Once] _ [Occ=Dead] ->
              v_s1j61;
        };

GHC.Real.toRational
  :: forall a. GHC.Real.Real a => a -> GHC.Real.Rational
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_s1j63]
        case v_s1j63 of {
          GHC.Real.C:Real _ [Occ=Dead] _ [Occ=Dead] v_s1j67 [Occ=Once] ->
              v_s1j67;
        };

GHC.Real.$p1RealFrac
  :: forall a. GHC.Real.RealFrac a => GHC.Real.Real a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLL),U(U,A,A,A,A,A,A)>] =
    [] \r [v_s1j68]
        case v_s1j68 of {
          GHC.Real.C:RealFrac v_s1j6a [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j6a;
        };

GHC.Real.$p2RealFrac
  :: forall a. GHC.Real.RealFrac a => GHC.Real.Fractional a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLL),U(A,U,A,A,A,A,A)>] =
    [] \r [v_s1j6h]
        case v_s1j6h of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              v_s1j6k [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j6k;
        };

GHC.Real.properFraction
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> (b, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLL),U(A,A,U,A,A,A,A)>] =
    [] \r [v_s1j6q]
        case v_s1j6q of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j6u [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j6u;
        };

GHC.Real.truncate
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLL),U(A,A,A,U,A,A,A)>] =
    [] \r [v_s1j6z]
        case v_s1j6z of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j6E [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j6E;
        };

GHC.Real.round
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLL),U(A,A,A,A,U,A,A)>] =
    [] \r [v_s1j6I]
        case v_s1j6I of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j6O [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1j6O;
        };

GHC.Real.ceiling
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSL),U(A,A,A,A,A,U,A)>] =
    [] \r [v_s1j6R]
        case v_s1j6R of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j6Y [Occ=Once]
                              _ [Occ=Dead] ->
              v_s1j6Y;
        };

GHC.Real.floor
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLS),U(A,A,A,A,A,A,U)>] =
    [] \r [v_s1j70]
        case v_s1j70 of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1j78 [Occ=Once] ->
              v_s1j78;
        };

GHC.Real.$W:% [InlPrag=INLINE[2]]
  :: forall a. a -> a -> GHC.Real.Ratio a
[GblId[DataConWrapper],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>m,
 Unf=OtherCon []] =
    [] \r [dt_s1j79 dt_s1j7a]
        case dt_s1j79 of dt_s1j7b {
          __DEFAULT ->
              case dt_s1j7a of dt_s1j7c {
                __DEFAULT -> GHC.Real.:% [dt_s1j7b dt_s1j7c];
              };
        };

GHC.Real.$fOrdRatio_$s$c< [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1j7d w1_s1j7e]
        case w_s1j7d of {
          GHC.Real.:% ww1_s1j7g [Occ=Once] ww2_s1j7h [Occ=Once] ->
              case w1_s1j7e of {
                GHC.Real.:% ww4_s1j7j [Occ=Once] ww5_s1j7k [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1j7j ww2_s1j7h
                    of
                    sat_s1j7m
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1j7g ww5_s1j7k
                          of
                          sat_s1j7l
                          { __DEFAULT ->
                                case
                                    GHC.Integer.Type.ltInteger# sat_s1j7l sat_s1j7m
                                of
                                wild_s1j7n
                                { __DEFAULT -> tagToEnum# [wild_s1j7n];
                                };
                          };
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$c<= [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1j7o w1_s1j7p]
        case w_s1j7o of {
          GHC.Real.:% ww1_s1j7r [Occ=Once] ww2_s1j7s [Occ=Once] ->
              case w1_s1j7p of {
                GHC.Real.:% ww4_s1j7u [Occ=Once] ww5_s1j7v [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1j7u ww2_s1j7s
                    of
                    sat_s1j7x
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1j7r ww5_s1j7v
                          of
                          sat_s1j7w
                          { __DEFAULT ->
                                case
                                    GHC.Integer.Type.leInteger# sat_s1j7w sat_s1j7x
                                of
                                wild_s1j7y
                                { __DEFAULT -> tagToEnum# [wild_s1j7y];
                                };
                          };
                    };
              };
        };

GHC.Real.$w$s$ccompare [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Types.Ordering
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1j7z ww1_s1j7A ww2_s1j7B ww3_s1j7C]
        case GHC.Integer.Type.eqInteger# ww_s1j7z ww2_s1j7B of wild_s1j7D {
          __DEFAULT ->
              let-no-escape {
                $j_s1j7E [Occ=Once*T[0], Dmd=<L,1*U>] :: GHC.Types.Ordering
                [LclId[JoinId(0)], Unf=OtherCon []] =
                    [ww_s1j7z ww1_s1j7A ww2_s1j7B ww3_s1j7C] \r []
                        case
                            GHC.Integer.Type.timesInteger ww2_s1j7B ww1_s1j7A
                        of
                        sat_s1j7G
                        { __DEFAULT ->
                              case
                                  GHC.Integer.Type.timesInteger ww_s1j7z ww3_s1j7C
                              of
                              sat_s1j7F
                              { __DEFAULT ->
                                    case GHC.Integer.Type.leInteger# sat_s1j7F sat_s1j7G of {
                                      __DEFAULT -> GHC.Types.GT [];
                                      1# -> GHC.Types.LT [];
                                    };
                              };
                        };
              } in 
                case wild_s1j7D of {
                  __DEFAULT -> $j_s1j7E;
                  1# ->
                      case GHC.Integer.Type.eqInteger# ww1_s1j7A ww3_s1j7C of {
                        __DEFAULT -> $j_s1j7E;
                        1# -> GHC.Types.EQ [];
                      };
                };
        };

GHC.Real.$fEnumRatio_$s$ccompare [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1j7K w1_s1j7L]
        case w_s1j7K of {
          GHC.Real.:% ww1_s1j7N [Occ=Once] ww2_s1j7O [Occ=Once] ->
              case w1_s1j7L of {
                GHC.Real.:% ww4_s1j7Q [Occ=Once] ww5_s1j7R [Occ=Once] ->
                    GHC.Real.$w$s$ccompare ww1_s1j7N ww2_s1j7O ww4_s1j7Q ww5_s1j7R;
              };
        };

GHC.Real.$fEnumRatio_$s$c>=
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [x_s1j7S y_s1j7T]
        case x_s1j7S of {
          GHC.Real.:% ww1_s1j7V [Occ=Once] ww2_s1j7W [Occ=Once] ->
              case y_s1j7T of {
                GHC.Real.:% ww4_s1j7Y [Occ=Once] ww5_s1j7Z [Occ=Once] ->
                    case
                        GHC.Real.$w$s$ccompare ww1_s1j7V ww2_s1j7W ww4_s1j7Y ww5_s1j7Z
                    of
                    { __DEFAULT -> GHC.Types.True [];
                      GHC.Types.LT -> GHC.Types.False [];
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$c>
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [x_s1j81 y_s1j82]
        case x_s1j81 of {
          GHC.Real.:% ww1_s1j84 [Occ=Once] ww2_s1j85 [Occ=Once] ->
              case y_s1j82 of {
                GHC.Real.:% ww4_s1j87 [Occ=Once] ww5_s1j88 [Occ=Once] ->
                    case
                        GHC.Real.$w$s$ccompare ww1_s1j84 ww2_s1j85 ww4_s1j87 ww5_s1j88
                    of
                    { __DEFAULT -> GHC.Types.False [];
                      GHC.Types.GT -> GHC.Types.True [];
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$cmin
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_s1j8a y_s1j8b]
        case x_s1j8a of ww_s1j8c {
          GHC.Real.:% ww1_s1j8d [Occ=Once] ww2_s1j8e [Occ=Once] ->
              case y_s1j8b of ww3_s1j8f {
                GHC.Real.:% ww4_s1j8g [Occ=Once] ww5_s1j8h [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1j8g ww2_s1j8e
                    of
                    sat_s1j8j
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1j8d ww5_s1j8h
                          of
                          sat_s1j8i
                          { __DEFAULT ->
                                case GHC.Integer.Type.leInteger# sat_s1j8i sat_s1j8j of {
                                  __DEFAULT -> ww3_s1j8f;
                                  1# -> ww_s1j8c;
                                };
                          };
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$cmax
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_s1j8l y_s1j8m]
        case x_s1j8l of ww_s1j8n {
          GHC.Real.:% ww1_s1j8o [Occ=Once] ww2_s1j8p [Occ=Once] ->
              case y_s1j8m of ww3_s1j8q {
                GHC.Real.:% ww4_s1j8r [Occ=Once] ww5_s1j8s [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1j8r ww2_s1j8p
                    of
                    sat_s1j8u
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1j8o ww5_s1j8s
                          of
                          sat_s1j8t
                          { __DEFAULT ->
                                case GHC.Integer.Type.leInteger# sat_s1j8t sat_s1j8u of {
                                  __DEFAULT -> ww_s1j8n;
                                  1# -> ww3_s1j8q;
                                };
                          };
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$cnegate
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1j8w]
        case ds_s1j8w of {
          GHC.Real.:% x_s1j8y [Occ=Once] y_s1j8z [Occ=Once] ->
              case GHC.Integer.Type.negateInteger x_s1j8y of dt_s1j8A {
                __DEFAULT -> GHC.Real.:% [dt_s1j8A y_s1j8z];
              };
        };

GHC.Real.$fFractionalRatio_$s$cabs
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1j8B]
        case ds_s1j8B of {
          GHC.Real.:% x_s1j8D [Occ=Once] y_s1j8E [Occ=Once] ->
              case GHC.Integer.Type.absInteger x_s1j8D of dt_s1j8F {
                __DEFAULT -> GHC.Real.:% [dt_s1j8F y_s1j8E];
              };
        };

sat_s1j8G :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s1j8H :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1j8G GHC.Types.[]];

GHC.Real.$fEnumRatio1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s1j8H;

GHC.Real.$fFractionalRatio_$s$csignum
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SL),1*U(U,A)>m, Unf=OtherCon []] =
    [] \r [ds_s1j8I]
        case ds_s1j8I of {
          GHC.Real.:% x_s1j8K [Occ=Once] _ [Occ=Dead] ->
              case GHC.Integer.Type.signumInteger x_s1j8K of dt_s1j8M {
                __DEFAULT -> GHC.Real.:% [dt_s1j8M GHC.Real.$fEnumRatio1];
              };
        };

GHC.Real.$fFractionalRatio_$s$cfromInteger
  :: GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [x_s1j8N]
        case x_s1j8N of dt_s1j8O {
          __DEFAULT -> GHC.Real.:% [dt_s1j8O GHC.Real.$fEnumRatio1];
        };

GHC.Real.$fRealInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real GHC.Integer.Type.Integer
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Num.$fNumInteger
                                    GHC.Integer.Type.$fOrdInteger
                                    GHC.Real.$fFractionalRatio_$s$cfromInteger];

GHC.Real.$fIntegralInt_$ctoInteger
  :: GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1j8P]
        case ds_s1j8P of {
          GHC.Types.I# i_s1j8R [Occ=Once] ->
              GHC.Integer.Type.smallInteger i_s1j8R;
        };

GHC.Real.$fEnumRatio_$ctoRational
  :: GHC.Types.Int -> GHC.Real.Rational
[GblId, Arity=1, Str=<S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [x_s1j8S]
        case x_s1j8S of {
          GHC.Types.I# i_s1j8U [Occ=Once] ->
              case GHC.Integer.Type.smallInteger i_s1j8U of dt_s1j8V {
                __DEFAULT -> GHC.Real.:% [dt_s1j8V GHC.Real.$fEnumRatio1];
              };
        };

GHC.Real.$fRealInt [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real GHC.Types.Int
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Num.$fNumInt
                                    GHC.Classes.$fOrdInt
                                    GHC.Real.$fEnumRatio_$ctoRational];

GHC.Real.$fIntegralWord_$ctoInteger
  :: GHC.Types.Word -> GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1j8W]
        case ds_s1j8W of {
          GHC.Types.W# x#_s1j8Y [Occ=Once] ->
              GHC.Integer.Type.wordToInteger x#_s1j8Y;
        };

GHC.Real.$fIntegralInteger_$ctoInteger
  :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [n_s1j8Z] n_s1j8Z;

GHC.Real.$fEqRatio_$s$c== [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1j90 w1_s1j91]
        case w_s1j90 of {
          GHC.Real.:% ww1_s1j93 [Occ=Once] ww2_s1j94 [Occ=Once] ->
              case w1_s1j91 of {
                GHC.Real.:% ww4_s1j96 [Occ=Once] ww5_s1j97 [Occ=Once] ->
                    case GHC.Integer.Type.eqInteger# ww1_s1j93 ww4_s1j96 of {
                      __DEFAULT -> GHC.Types.False [];
                      1# ->
                          case
                              GHC.Integer.Type.eqInteger# ww2_s1j94 ww5_s1j97
                          of
                          wild1_s1j99
                          { __DEFAULT -> tagToEnum# [wild1_s1j99];
                          };
                    };
              };
        };

GHC.Real.$fEqRatio_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1j9a w1_s1j9b w2_s1j9c]
        case w1_s1j9b of {
          GHC.Real.:% ww1_s1j9e [Occ=Once] ww2_s1j9f [Occ=Once] ->
              case w2_s1j9c of {
                GHC.Real.:% ww4_s1j9h [Occ=Once] ww5_s1j9i [Occ=Once] ->
                    case GHC.Classes.== w_s1j9a ww1_s1j9e ww4_s1j9h of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> GHC.Classes.== w_s1j9a ww2_s1j9f ww5_s1j9i;
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$c/= [InlPrag=INLINE (sat-args=2)]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1j9k eta1_s1j9l]
        case eta_s1j9k of {
          GHC.Real.:% a1_s1j9n [Occ=Once] a2_s1j9o [Occ=Once] ->
              case eta1_s1j9l of {
                GHC.Real.:% b1_s1j9q [Occ=Once] b2_s1j9r [Occ=Once] ->
                    case GHC.Integer.Type.eqInteger# a1_s1j9n b1_s1j9q of {
                      __DEFAULT -> GHC.Types.True [];
                      1# ->
                          case GHC.Integer.Type.eqInteger# a2_s1j9o b2_s1j9r of {
                            __DEFAULT -> GHC.Types.True [];
                            1# -> GHC.Types.False [];
                          };
                    };
              };
        };

GHC.Real.$fEqRatio_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_s1j9u eta_s1j9v eta1_s1j9w]
        case eta_s1j9v of {
          GHC.Real.:% ww1_s1j9y [Occ=Once] ww2_s1j9z [Occ=Once] ->
              case eta1_s1j9w of {
                GHC.Real.:% ww4_s1j9B [Occ=Once] ww5_s1j9C [Occ=Once] ->
                    case GHC.Classes.== $dEq_s1j9u ww1_s1j9y ww4_s1j9B of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True ->
                          case GHC.Classes.== $dEq_s1j9u ww2_s1j9z ww5_s1j9C of {
                            GHC.Types.False -> GHC.Types.True [];
                            GHC.Types.True -> GHC.Types.False [];
                          };
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$fEqRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Real.$fEqRatio_$s$c==
                                     GHC.Real.$fOrdRatio_$s$c/=];

GHC.Real.$fEqRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Real.Ratio a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s1j9F]
        let {
          sat_s1j9H [Occ=Once]
            :: GHC.Real.Ratio a_a1eDJ
               -> GHC.Real.Ratio a_a1eDJ -> GHC.Types.Bool
          [LclId] =
              [$dEq_s1j9F] \r [eta_B2 eta_B1]
                  GHC.Real.$fEqRatio_$c/= $dEq_s1j9F eta_B2 eta_B1; } in
        let {
          sat_s1j9G [Occ=Once]
            :: GHC.Real.Ratio a_a1eDJ
               -> GHC.Real.Ratio a_a1eDJ -> GHC.Types.Bool
          [LclId] =
              [$dEq_s1j9F] \r [eta_B2 eta_B1]
                  GHC.Real.$fEqRatio_$c== $dEq_s1j9F eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s1j9G sat_s1j9H];

GHC.Real.$fOrdRatio_$s$fOrdRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [GHC.Real.$fOrdRatio_$s$fEqRatio
                                      GHC.Real.$fEnumRatio_$s$ccompare
                                      GHC.Real.$fOrdRatio_$s$c<
                                      GHC.Real.$fEnumRatio_$s$c<=
                                      GHC.Real.$fOrdRatio_$s$c>
                                      GHC.Real.$fEnumRatio_$s$c>=
                                      GHC.Real.$fOrdRatio_$s$cmax
                                      GHC.Real.$fOrdRatio_$s$cmin];

GHC.Real.$fOrdRatio_$cp1Ord
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Classes.Eq (GHC.Real.Ratio a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1j9I]
        let {
          sat_s1j9L [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_a1eJ2
          [LclId] =
              [$dIntegral_s1j9I] \u []
                  case GHC.Real.$p1Integral $dIntegral_s1j9I of sat_s1j9J {
                    __DEFAULT ->
                        case GHC.Real.$p2Real sat_s1j9J of sat_s1j9K {
                          __DEFAULT -> GHC.Classes.$p1Ord sat_s1j9K;
                        };
                  };
        } in  GHC.Real.$fEqRatio sat_s1j9L;

GHC.Real.even1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

GHC.Real.$dmfloor
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U,U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1j9M eta_s1j9N eta1_s1j9O]
        let {
          ds_s1j9P [Dmd=<L,U(1*U,1*U)>] :: (b_a1eDd, a_a1dNs)
          [LclId] =
              [$dRealFrac_s1j9M eta_s1j9N eta1_s1j9O] \u []
                  GHC.Real.properFraction $dRealFrac_s1j9M eta_s1j9N eta1_s1j9O;
        } in 
          case
              GHC.Real.$p1RealFrac $dRealFrac_s1j9M
          of
          $dReal_s1j9Q [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
          { __DEFAULT ->
                let {
                  sat_s1j9X [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [$dReal_s1j9Q] \u []
                          case GHC.Real.$p1Real $dReal_s1j9Q of sat_s1j9W {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1j9W GHC.Real.even1;
                          }; } in
                let {
                  sat_s1j9V [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [ds_s1j9P] \u []
                          case ds_s1j9P of {
                            (,) _ [Occ=Dead] r_s1j9U [Occ=Once] -> r_s1j9U;
                          };
                } in 
                  case GHC.Real.$p2Real $dReal_s1j9Q of sat_s1j9R {
                    __DEFAULT ->
                        case GHC.Classes.< sat_s1j9R sat_s1j9V sat_s1j9X of {
                          GHC.Types.False ->
                              case ds_s1j9P of {
                                (,) n_s1ja0 [Occ=Once] _ [Occ=Dead] -> n_s1ja0;
                              };
                          GHC.Types.True ->
                              case
                                  GHC.Real.$p1Integral eta_s1j9N
                              of
                              $dReal1_s1ja2 [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                              { __DEFAULT ->
                                    case
                                        GHC.Real.$p1Real $dReal1_s1ja2
                                    of
                                    $dNum_s1ja3 [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                    { __DEFAULT ->
                                          let {
                                            sat_s1ja8 [Occ=Once] :: b_a1eDd
                                            [LclId] =
                                                [$dNum_s1ja3] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_s1ja3 GHC.Real.$fEnumRatio1; } in
                                          let {
                                            sat_s1ja7 [Occ=Once] :: b_a1eDd
                                            [LclId] =
                                                [ds_s1j9P] \u []
                                                    case ds_s1j9P of {
                                                      (,) n_s1ja5 [Occ=Once] _ [Occ=Dead] ->
                                                          n_s1ja5;
                                                    };
                                          } in  GHC.Num.- $dNum_s1ja3 sat_s1ja7 sat_s1ja8;
                                    };
                              };
                        };
                  };
          };

GHC.Real.$dmceiling
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,A,1*C1(C1(U)),A,A,A),A),A,1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U,U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1ja9 eta_s1jaa eta1_s1jab]
        let {
          ds_s1jac [Dmd=<L,U(1*U,1*U)>] :: (b_a1eCG, a_a1dNs)
          [LclId] =
              [$dRealFrac_s1ja9 eta_s1jaa eta1_s1jab] \u []
                  GHC.Real.properFraction $dRealFrac_s1ja9 eta_s1jaa eta1_s1jab;
        } in 
          case
              GHC.Real.$p1RealFrac $dRealFrac_s1ja9
          of
          $dReal_s1jad [Dmd=<S(LS(LLLLC(C(S))LLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,A,1*C1(C1(U)),A,A,A),A)>]
          { __DEFAULT ->
                let {
                  sat_s1jak [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [$dReal_s1jad] \u []
                          case GHC.Real.$p1Real $dReal_s1jad of sat_s1jaj {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1jaj GHC.Real.even1;
                          }; } in
                let {
                  sat_s1jai [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [ds_s1jac] \u []
                          case ds_s1jac of {
                            (,) _ [Occ=Dead] r_s1jah [Occ=Once] -> r_s1jah;
                          };
                } in 
                  case GHC.Real.$p2Real $dReal_s1jad of sat_s1jae {
                    __DEFAULT ->
                        case GHC.Classes.> sat_s1jae sat_s1jai sat_s1jak of {
                          GHC.Types.False ->
                              case ds_s1jac of {
                                (,) n_s1jan [Occ=Once] _ [Occ=Dead] -> n_s1jan;
                              };
                          GHC.Types.True ->
                              case
                                  GHC.Real.$p1Integral eta_s1jaa
                              of
                              $dReal1_s1jap [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
                              { __DEFAULT ->
                                    case
                                        GHC.Real.$p1Real $dReal1_s1jap
                                    of
                                    $dNum_s1jaq [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                                    { __DEFAULT ->
                                          let {
                                            sat_s1jav [Occ=Once] :: b_a1eCG
                                            [LclId] =
                                                [$dNum_s1jaq] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_s1jaq GHC.Real.$fEnumRatio1; } in
                                          let {
                                            sat_s1jau [Occ=Once] :: b_a1eCG
                                            [LclId] =
                                                [ds_s1jac] \u []
                                                    case ds_s1jac of {
                                                      (,) n_s1jas [Occ=Once] _ [Occ=Dead] ->
                                                          n_s1jas;
                                                    };
                                          } in  GHC.Num.+ $dNum_s1jaq sat_s1jau sat_s1jav;
                                    };
                              };
                        };
                  };
          };

GHC.Real.$dmtruncate [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S(SL)))LLLL),1*U(A,A,1*C1(C1(U(1*U,A))),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1jaw $dIntegral_s1jax x_s1jay]
        case
            GHC.Real.properFraction $dRealFrac_s1jaw $dIntegral_s1jax x_s1jay
        of
        { (,) m_s1jaA [Occ=Once] _ [Occ=Dead] -> m_s1jaA;
        };

GHC.Real.$dmrecip [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Real.Fractional a => a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LL),U(1*U(A,A,A,A,A,A,1*C1(U)),1*C1(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_s1jaC eta_s1jaD]
        let {
          sat_s1jaF [Occ=Once] :: a_a1dNK
          [LclId] =
              [$dFractional_s1jaC] \u []
                  case GHC.Real.$p1Fractional $dFractional_s1jaC of sat_s1jaE {
                    __DEFAULT -> GHC.Num.fromInteger sat_s1jaE GHC.Real.$fEnumRatio1;
                  };
        } in  GHC.Real./ $dFractional_s1jaC sat_s1jaF eta_s1jaD;

GHC.Real.$dm/ [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Fractional a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLC(C(S))LLLL)LLL),U(1*U(A,A,1*C1(C1(U)),A,A,A,A),A,1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_s1jaG eta_s1jaH eta1_s1jaI]
        let {
          sat_s1jaK [Occ=Once] :: a_a1dNK
          [LclId] =
              [$dFractional_s1jaG eta1_s1jaI] \u []
                  GHC.Real.recip $dFractional_s1jaG eta1_s1jaI;
        } in 
          case GHC.Real.$p1Fractional $dFractional_s1jaG of sat_s1jaJ {
            __DEFAULT -> GHC.Num.* sat_s1jaJ eta_s1jaH sat_s1jaK;
          };

GHC.Real.$dmdivMod
  :: forall a. GHC.Real.Integral a => a -> a -> (a, a)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,1*C1(C1(U(U,U))),A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jaL eta_s1jaM eta1_s1jaN]
        case
            GHC.Real.$p1Integral $dIntegral_s1jaL
        of
        $dReal_s1jaO [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jaP [Dmd=<L,U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U))>]
                  :: GHC.Num.Num a_a1dNO
                [LclId] =
                    [$dReal_s1jaO] \u [] GHC.Real.$p1Real $dReal_s1jaO; } in
              let {
                ds_s1jaQ [Dmd=<L,U(1*U(U,U),1*U,1*U)>]
                  :: ((a_a1dNO, a_a1dNO), a_a1dNO, a_a1dNO)
                [LclId] =
                    [$dIntegral_s1jaL eta_s1jaM eta1_s1jaN] \u []
                        case
                            GHC.Real.quotRem $dIntegral_s1jaL eta_s1jaM eta1_s1jaN
                        of
                        wild_s1jaR
                        { (,) q_s1jaS [Occ=Once] r_s1jaT [Occ=Once] ->
                              (,,) [wild_s1jaR q_s1jaS r_s1jaT];
                        }; } in
              let {
                r_s1jaU :: a_a1dNO
                [LclId] =
                    [ds_s1jaQ] \u []
                        case ds_s1jaQ of {
                          (,,) _ [Occ=Dead] _ [Occ=Dead] r1_s1jaY [Occ=Once] -> r1_s1jaY;
                        }; } in
              let {
                sat_s1jb3 [Occ=Once] :: a_a1dNO
                [LclId] =
                    [eta1_s1jaN $dNum_s1jaP] \u []
                        let {
                          sat_s1jb2 [Occ=Once] :: a_a1dNO
                          [LclId] =
                              [eta1_s1jaN $dNum_s1jaP] \u []
                                  GHC.Num.signum $dNum_s1jaP eta1_s1jaN;
                        } in  GHC.Num.negate $dNum_s1jaP sat_s1jb2; } in
              let {
                sat_s1jb1 [Occ=Once] :: a_a1dNO
                [LclId] =
                    [$dNum_s1jaP r_s1jaU] \u [] GHC.Num.signum $dNum_s1jaP r_s1jaU;
              } in 
                case GHC.Real.$p2Real $dReal_s1jaO of sat_s1jaZ {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_s1jaZ of sat_s1jb0 {
                        __DEFAULT ->
                            case GHC.Classes.== sat_s1jb0 sat_s1jb1 sat_s1jb3 of {
                              GHC.Types.False ->
                                  case ds_s1jaQ of {
                                    (,,) qr_s1jb6 [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> qr_s1jb6;
                                  };
                              GHC.Types.True ->
                                  let {
                                    sat_s1jbg [Occ=Once] :: a_a1dNO
                                    [LclId] =
                                        [eta1_s1jaN $dNum_s1jaP r_s1jaU] \u []
                                            GHC.Num.+ $dNum_s1jaP r_s1jaU eta1_s1jaN; } in
                                  let {
                                    sat_s1jbf [Occ=Once] :: a_a1dNO
                                    [LclId] =
                                        [$dNum_s1jaP ds_s1jaQ] \u []
                                            let {
                                              sat_s1jbe [Occ=Once] :: a_a1dNO
                                              [LclId] =
                                                  [$dNum_s1jaP] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s1jaP GHC.Real.$fEnumRatio1; } in
                                            let {
                                              sat_s1jbd [Occ=Once] :: a_a1dNO
                                              [LclId] =
                                                  [ds_s1jaQ] \u []
                                                      case ds_s1jaQ of {
                                                        (,,) _ [Occ=Dead]
                                                             q_s1jbb [Occ=Once]
                                                             _ [Occ=Dead] ->
                                                            q_s1jbb;
                                                      };
                                            } in  GHC.Num.- $dNum_s1jaP sat_s1jbd sat_s1jbe;
                                  } in  (,) [sat_s1jbf sat_s1jbg];
                            };
                      };
                };
        };

GHC.Real.$dmmod [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(S(LS)))L),1*U(A,A,A,A,A,A,A,1*C1(C1(U(A,1*U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jbh n_s1jbi d_s1jbj]
        case GHC.Real.divMod $dIntegral_s1jbh n_s1jbi d_s1jbj of {
          (,) _ [Occ=Dead] r_s1jbm [Occ=Once] -> r_s1jbm;
        };

GHC.Real.$dmdiv [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(S(SL)))L),1*U(A,A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jbn n_s1jbo d_s1jbp]
        case GHC.Real.divMod $dIntegral_s1jbn n_s1jbo d_s1jbp of {
          (,) q_s1jbr [Occ=Once] _ [Occ=Dead] -> q_s1jbr;
        };

GHC.Real.$dmrem [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(LS)))LL),1*U(A,A,A,A,A,A,1*C1(C1(U(A,1*U))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jbt n_s1jbu d_s1jbv]
        case GHC.Real.quotRem $dIntegral_s1jbt n_s1jbu d_s1jbv of {
          (,) _ [Occ=Dead] r_s1jby [Occ=Once] -> r_s1jby;
        };

GHC.Real.$dmquot [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))LL),1*U(A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jbz n_s1jbA d_s1jbB]
        case GHC.Real.quotRem $dIntegral_s1jbz n_s1jbA d_s1jbB of {
          (,) q_s1jbD [Occ=Once] _ [Occ=Dead] -> q_s1jbD;
        };

GHC.Real.divZeroError [InlPrag=NOINLINE] :: forall a. a
[GblId, Str=x] =
    [] \u [] raise# [GHC.Exception.divZeroException];

GHC.Real.$fIntegralInt1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

GHC.Real.$fIntegralInt_$cmod [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1jbF w1_s1jbG]
        case w1_s1jbG of {
          GHC.Types.I# ww1_s1jbI [Occ=Once!] ->
              case ww1_s1jbI of wild_s1jbJ {
                __DEFAULT ->
                    case w_s1jbF of {
                      GHC.Types.I# x_s1jbL [Occ=Once] ->
                          case GHC.Classes.modInt# x_s1jbL wild_s1jbJ of ww2_s1jbM {
                            __DEFAULT -> GHC.Types.I# [ww2_s1jbM];
                          };
                    };
                -1# -> GHC.Real.$fIntegralInt1;
                0# -> GHC.Real.divZeroError;
              };
        };

GHC.Real.$fIntegralInt_$crem
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [a_s1jbO b_s1jbP]
        case b_s1jbP of {
          GHC.Types.I# x_s1jbR [Occ=Once!] ->
              case x_s1jbR of wild1_s1jbS {
                __DEFAULT ->
                    case a_s1jbO of {
                      GHC.Types.I# x1_s1jbU [Occ=Once] ->
                          case remInt# [x1_s1jbU wild1_s1jbS] of wild3_s1jbV {
                            __DEFAULT -> GHC.Types.I# [wild3_s1jbV];
                          };
                    };
                -1# -> GHC.Real.$fIntegralInt1;
                0# -> GHC.Real.divZeroError;
              };
        };

GHC.Real.$fIntegralInteger_$cquot [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1jbW eta1_s1jbX]
        case GHC.Integer.Type.eqInteger# eta1_s1jbX GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.quotInteger eta_s1jbW eta1_s1jbX;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$crem [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1jbZ eta1_s1jc0]
        case GHC.Integer.Type.eqInteger# eta1_s1jc0 GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.remInteger eta_s1jbZ eta1_s1jc0;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cdiv [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1jc2 eta1_s1jc3]
        case GHC.Integer.Type.eqInteger# eta1_s1jc3 GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.divInteger eta_s1jc2 eta1_s1jc3;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cmod [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1jc5 eta1_s1jc6]
        case GHC.Integer.Type.eqInteger# eta1_s1jc6 GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.modInteger eta_s1jc5 eta1_s1jc6;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cquotRem [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
[GblId, Arity=2, Str=<S,1*U><S,U>m, Unf=OtherCon []] =
    [] \r [eta_s1jc8 eta1_s1jc9]
        case GHC.Integer.Type.eqInteger# eta1_s1jc9 GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.quotRemInteger eta_s1jc8 eta1_s1jc9 of {
                (#,#) ipv_s1jcc [Occ=Once] ipv1_s1jcd [Occ=Once] ->
                    (,) [ipv_s1jcc ipv1_s1jcd];
              };
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cdivMod [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
[GblId, Arity=2, Str=<S,1*U><S,U>m, Unf=OtherCon []] =
    [] \r [eta_s1jce eta1_s1jcf]
        case GHC.Integer.Type.eqInteger# eta1_s1jcf GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.divModInteger eta_s1jce eta1_s1jcf of {
                (#,#) ipv_s1jci [Occ=Once] ipv1_s1jcj [Occ=Once] ->
                    (,) [ipv_s1jci ipv1_s1jcj];
              };
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Integral GHC.Integer.Type.Integer
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Integral! [GHC.Real.$fRealInteger
                                        GHC.Enum.$fEnumInteger
                                        GHC.Real.$fIntegralInteger_$cquot
                                        GHC.Real.$fIntegralInteger_$crem
                                        GHC.Real.$fIntegralInteger_$cdiv
                                        GHC.Real.$fIntegralInteger_$cmod
                                        GHC.Real.$fIntegralInteger_$cquotRem
                                        GHC.Real.$fIntegralInteger_$cdivMod
                                        GHC.Real.$fIntegralInteger_$ctoInteger];

GHC.Real.$fIntegralWord_$cquot
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1jck y_s1jcl]
        case ds_s1jck of {
          GHC.Types.W# x#_s1jcn [Occ=Once] ->
              case y_s1jcl of {
                GHC.Types.W# y#_s1jcp [Occ=Once!] ->
                    case y#_s1jcp of wild2_s1jcq {
                      __DEFAULT ->
                          case quotWord# [x#_s1jcn wild2_s1jcq] of wild3_s1jcr {
                            __DEFAULT -> GHC.Types.W# [wild3_s1jcr];
                          };
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralWord_$crem
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1jcs y_s1jct]
        case ds_s1jcs of {
          GHC.Types.W# x#_s1jcv [Occ=Once] ->
              case y_s1jct of {
                GHC.Types.W# y#_s1jcx [Occ=Once!] ->
                    case y#_s1jcx of wild2_s1jcy {
                      __DEFAULT ->
                          case remWord# [x#_s1jcv wild2_s1jcy] of wild3_s1jcz {
                            __DEFAULT -> GHC.Types.W# [wild3_s1jcz];
                          };
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralWord_$cquotRem
  :: GHC.Types.Word
     -> GHC.Types.Word -> (GHC.Types.Word, GHC.Types.Word)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1jcA y_s1jcB]
        case ds_s1jcA of {
          GHC.Types.W# x#_s1jcD [Occ=Once] ->
              case y_s1jcB of {
                GHC.Types.W# y#_s1jcF [Occ=Once!] ->
                    case y#_s1jcF of wild2_s1jcG {
                      __DEFAULT ->
                          case quotRemWord# [x#_s1jcD wild2_s1jcG] of {
                            (#,#) ipv_s1jcI [Occ=Once] ipv1_s1jcJ [Occ=Once] ->
                                let {
                                  sat_s1jcL [Occ=Once] :: GHC.Types.Word
                                  [LclId] =
                                      CCCS GHC.Types.W#! [ipv1_s1jcJ]; } in
                                let {
                                  sat_s1jcK [Occ=Once] :: GHC.Types.Word
                                  [LclId] =
                                      CCCS GHC.Types.W#! [ipv_s1jcI];
                                } in  (,) [sat_s1jcK sat_s1jcL];
                          };
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralWord_$cdivMod
  :: GHC.Types.Word
     -> GHC.Types.Word -> (GHC.Types.Word, GHC.Types.Word)
[GblId, Arity=2, Str=<S,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [ds_s1jcM y_s1jcN]
        case ds_s1jcM of {
          GHC.Types.W# x#_s1jcP ->
              case y_s1jcN of {
                GHC.Types.W# y#_s1jcR [Occ=Once!] ->
                    case y#_s1jcR of wild2_s1jcS {
                      __DEFAULT ->
                          let {
                            sat_s1jcW [Occ=Once] :: GHC.Types.Word
                            [LclId] =
                                [x#_s1jcP wild2_s1jcS] \u []
                                    case remWord# [x#_s1jcP wild2_s1jcS] of wild3_s1jcV {
                                      __DEFAULT -> GHC.Types.W# [wild3_s1jcV];
                                    }; } in
                          let {
                            sat_s1jcU [Occ=Once] :: GHC.Types.Word
                            [LclId] =
                                [x#_s1jcP wild2_s1jcS] \u []
                                    case quotWord# [x#_s1jcP wild2_s1jcS] of wild3_s1jcT {
                                      __DEFAULT -> GHC.Types.W# [wild3_s1jcT];
                                    };
                          } in  (,) [sat_s1jcU sat_s1jcW];
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.ratioZeroDenominatorError [InlPrag=NOINLINE]
  :: forall a. a
[GblId, Str=x] =
    [] \u [] raise# [GHC.Exception.ratioZeroDenomException];

GHC.Real.$fFractionalRatio_$s$crecip [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_s1jcX]
        case w_s1jcX of {
          GHC.Real.:% ww1_s1jcZ ww2_s1jd0 [Occ=Once*] ->
              case GHC.Integer.Type.eqInteger# ww1_s1jcZ GHC.Real.even1 of {
                __DEFAULT ->
                    case GHC.Integer.Type.ltInteger# ww1_s1jcZ GHC.Real.even1 of {
                      __DEFAULT -> GHC.Real.:% [ww2_s1jd0 ww1_s1jcZ];
                      1# ->
                          case GHC.Integer.Type.negateInteger ww2_s1jd0 of dt_s1jd3 {
                            __DEFAULT ->
                                case GHC.Integer.Type.negateInteger ww1_s1jcZ of dt1_s1jd4 {
                                  __DEFAULT -> GHC.Real.:% [dt_s1jd3 dt1_s1jd4];
                                };
                          };
                    };
                1# -> GHC.Real.ratioZeroDenominatorError;
              };
        };

GHC.Real.overflowError [InlPrag=NOINLINE] :: forall a. a
[GblId, Str=x] =
    [] \u [] raise# [GHC.Exception.overflowException];

lvl_r1j38 :: (GHC.Types.Int, GHC.Types.Int)
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Real.overflowError
                        GHC.Real.$fIntegralInt1];

GHC.Real.$fIntegralInt_$cdivMod [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jd6 w1_s1jd7]
        case w_s1jd6 of {
          GHC.Types.I# ww1_s1jd9 ->
              case w1_s1jd7 of {
                GHC.Types.I# ww3_s1jdb [Occ=Once!] ->
                    case ww3_s1jdb of wild_s1jdc {
                      __DEFAULT ->
                          case ># [ww1_s1jd9 0#] of {
                            __DEFAULT ->
                                case <# [ww1_s1jd9 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww1_s1jd9 wild_s1jdc] of {
                                        (#,#) ipv_s1jdg [Occ=Once] ipv1_s1jdh [Occ=Once] ->
                                            let {
                                              sat_s1jdj [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s1jdh]; } in
                                            let {
                                              sat_s1jdi [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_s1jdg];
                                            } in  (,) [sat_s1jdi sat_s1jdj];
                                      };
                                  1# ->
                                      case ># [wild_s1jdc 0#] of {
                                        __DEFAULT ->
                                            case quotRemInt# [ww1_s1jd9 wild_s1jdc] of {
                                              (#,#) ipv_s1jdm [Occ=Once] ipv1_s1jdn [Occ=Once] ->
                                                  let {
                                                    sat_s1jdp [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv1_s1jdn]; } in
                                                  let {
                                                    sat_s1jdo [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv_s1jdm];
                                                  } in  (,) [sat_s1jdo sat_s1jdp];
                                            };
                                        1# ->
                                            case +# [ww1_s1jd9 1#] of sat_s1jdq {
                                              __DEFAULT ->
                                                  case quotRemInt# [sat_s1jdq wild_s1jdc] of {
                                                    (#,#) ipv_s1jds [Occ=Once]
                                                          ipv1_s1jdt [Occ=Once] ->
                                                        case
                                                            +# [ipv1_s1jdt wild_s1jdc]
                                                        of
                                                        sat_s1jdw
                                                        { __DEFAULT ->
                                                              case -# [sat_s1jdw 1#] of sat_s1jdx {
                                                                __DEFAULT ->
                                                                    let {
                                                                      sat_s1jdy [Occ=Once]
                                                                        :: GHC.Types.Int
                                                                      [LclId] =
                                                                          CCCS GHC.Types.I#! [sat_s1jdx];
                                                                    } in 
                                                                      case
                                                                          -# [ipv_s1jds 1#]
                                                                      of
                                                                      sat_s1jdu
                                                                      { __DEFAULT ->
                                                                            let {
                                                                              sat_s1jdv [Occ=Once]
                                                                                :: GHC.Types.Int
                                                                              [LclId] =
                                                                                  CCCS GHC.Types.I#! [sat_s1jdu];
                                                                            } in 
                                                                              (,) [sat_s1jdv
                                                                                   sat_s1jdy];
                                                                      };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            1# ->
                                case <# [wild_s1jdc 0#] of {
                                  __DEFAULT ->
                                      case <# [ww1_s1jd9 0#] of {
                                        __DEFAULT ->
                                            case quotRemInt# [ww1_s1jd9 wild_s1jdc] of {
                                              (#,#) ipv_s1jdC [Occ=Once] ipv1_s1jdD [Occ=Once] ->
                                                  let {
                                                    sat_s1jdF [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv1_s1jdD]; } in
                                                  let {
                                                    sat_s1jdE [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv_s1jdC];
                                                  } in  (,) [sat_s1jdE sat_s1jdF];
                                            };
                                        1# ->
                                            case ># [wild_s1jdc 0#] of {
                                              __DEFAULT ->
                                                  case quotRemInt# [ww1_s1jd9 wild_s1jdc] of {
                                                    (#,#) ipv_s1jdI [Occ=Once]
                                                          ipv1_s1jdJ [Occ=Once] ->
                                                        let {
                                                          sat_s1jdL [Occ=Once] :: GHC.Types.Int
                                                          [LclId] =
                                                              CCCS GHC.Types.I#! [ipv1_s1jdJ]; } in
                                                        let {
                                                          sat_s1jdK [Occ=Once] :: GHC.Types.Int
                                                          [LclId] =
                                                              CCCS GHC.Types.I#! [ipv_s1jdI];
                                                        } in  (,) [sat_s1jdK sat_s1jdL];
                                                  };
                                              1# ->
                                                  case +# [ww1_s1jd9 1#] of sat_s1jdM {
                                                    __DEFAULT ->
                                                        case quotRemInt# [sat_s1jdM wild_s1jdc] of {
                                                          (#,#) ipv_s1jdO [Occ=Once]
                                                                ipv1_s1jdP [Occ=Once] ->
                                                              case
                                                                  +# [ipv1_s1jdP wild_s1jdc]
                                                              of
                                                              sat_s1jdS
                                                              { __DEFAULT ->
                                                                    case
                                                                        -# [sat_s1jdS 1#]
                                                                    of
                                                                    sat_s1jdT
                                                                    { __DEFAULT ->
                                                                          let {
                                                                            sat_s1jdU [Occ=Once]
                                                                              :: GHC.Types.Int
                                                                            [LclId] =
                                                                                CCCS GHC.Types.I#! [sat_s1jdT];
                                                                          } in 
                                                                            case
                                                                                -# [ipv_s1jdO 1#]
                                                                            of
                                                                            sat_s1jdQ
                                                                            { __DEFAULT ->
                                                                                  let {
                                                                                    sat_s1jdR [Occ=Once]
                                                                                      :: GHC.Types.Int
                                                                                    [LclId] =
                                                                                        CCCS GHC.Types.I#! [sat_s1jdQ];
                                                                                  } in 
                                                                                    (,) [sat_s1jdR
                                                                                         sat_s1jdU];
                                                                            };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                  1# ->
                                      case -# [ww1_s1jd9 1#] of sat_s1jdV {
                                        __DEFAULT ->
                                            case quotRemInt# [sat_s1jdV wild_s1jdc] of {
                                              (#,#) ipv_s1jdX [Occ=Once] ipv1_s1jdY [Occ=Once] ->
                                                  case +# [ipv1_s1jdY wild_s1jdc] of sat_s1je1 {
                                                    __DEFAULT ->
                                                        case +# [sat_s1je1 1#] of sat_s1je2 {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_s1je3 [Occ=Once]
                                                                  :: GHC.Types.Int
                                                                [LclId] =
                                                                    CCCS GHC.Types.I#! [sat_s1je2];
                                                              } in 
                                                                case
                                                                    -# [ipv_s1jdX 1#]
                                                                of
                                                                sat_s1jdZ
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_s1je0 [Occ=Once]
                                                                          :: GHC.Types.Int
                                                                        [LclId] =
                                                                            CCCS GHC.Types.I#! [sat_s1jdZ];
                                                                      } in 
                                                                        (,) [sat_s1je0 sat_s1je3];
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                      -1# ->
                          case ww1_s1jd9 of wild1_s1je4 {
                            __DEFAULT ->
                                case ># [wild1_s1je4 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [wild1_s1je4 -1#] of {
                                        (#,#) ipv_s1je7 [Occ=Once] ipv1_s1je8 [Occ=Once] ->
                                            let {
                                              sat_s1jea [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s1je8]; } in
                                            let {
                                              sat_s1je9 [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_s1je7];
                                            } in  (,) [sat_s1je9 sat_s1jea];
                                      };
                                  1# ->
                                      case -# [wild1_s1je4 1#] of sat_s1jeb {
                                        __DEFAULT ->
                                            case quotRemInt# [sat_s1jeb -1#] of {
                                              (#,#) ipv_s1jed [Occ=Once] ipv1_s1jee [Occ=Once] ->
                                                  case +# [ipv1_s1jee -1#] of sat_s1jeh {
                                                    __DEFAULT ->
                                                        case +# [sat_s1jeh 1#] of sat_s1jei {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_s1jej [Occ=Once]
                                                                  :: GHC.Types.Int
                                                                [LclId] =
                                                                    CCCS GHC.Types.I#! [sat_s1jei];
                                                              } in 
                                                                case
                                                                    -# [ipv_s1jed 1#]
                                                                of
                                                                sat_s1jef
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_s1jeg [Occ=Once]
                                                                          :: GHC.Types.Int
                                                                        [LclId] =
                                                                            CCCS GHC.Types.I#! [sat_s1jef];
                                                                      } in 
                                                                        (,) [sat_s1jeg sat_s1jej];
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            -9223372036854775808# -> lvl_r1j38;
                          };
                      0# -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralInt_$cquotRem [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jel w1_s1jem]
        case w_s1jel of {
          GHC.Types.I# ww1_s1jeo [Occ=Once*] ->
              case w1_s1jem of {
                GHC.Types.I# ww3_s1jeq [Occ=Once!] ->
                    case ww3_s1jeq of wild_s1jer {
                      __DEFAULT ->
                          case quotRemInt# [ww1_s1jeo wild_s1jer] of {
                            (#,#) ipv_s1jet [Occ=Once] ipv1_s1jeu [Occ=Once] ->
                                let {
                                  sat_s1jew [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s1jeu]; } in
                                let {
                                  sat_s1jev [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv_s1jet];
                                } in  (,) [sat_s1jev sat_s1jew];
                          };
                      -1# ->
                          case ww1_s1jeo of wild1_s1jex {
                            __DEFAULT ->
                                case quotRemInt# [wild1_s1jex -1#] of {
                                  (#,#) ipv_s1jez [Occ=Once] ipv1_s1jeA [Occ=Once] ->
                                      let {
                                        sat_s1jeC [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv1_s1jeA]; } in
                                      let {
                                        sat_s1jeB [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv_s1jez];
                                      } in  (,) [sat_s1jeB sat_s1jeC];
                                };
                            -9223372036854775808# -> lvl_r1j38;
                          };
                      0# -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$w$cdiv [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Str=<S,U><S,1*U>, Unf=OtherCon []] =
    [] \r [ww_s1jeE ww1_s1jeF]
        case ww1_s1jeF of wild_s1jeG {
          __DEFAULT -> GHC.Classes.divInt# ww_s1jeE wild_s1jeG;
          -1# ->
              case ww_s1jeE of wild1_s1jeH {
                __DEFAULT -> GHC.Classes.divInt# wild1_s1jeH -1#;
                -9223372036854775808# -> GHC.Real.overflowError;
              };
          0# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInt_$cdiv [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jeK w1_s1jeL]
        case w_s1jeK of {
          GHC.Types.I# ww1_s1jeN [Occ=Once] ->
              case w1_s1jeL of {
                GHC.Types.I# ww3_s1jeP [Occ=Once] ->
                    case GHC.Real.$w$cdiv ww1_s1jeN ww3_s1jeP of ww4_s1jeQ {
                      __DEFAULT -> GHC.Types.I# [ww4_s1jeQ];
                    };
              };
        };

GHC.Real.$fIntegralInt_$cquot [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jeR w1_s1jeS]
        case w_s1jeR of {
          GHC.Types.I# ww1_s1jeU [Occ=Once*] ->
              case w1_s1jeS of {
                GHC.Types.I# ww3_s1jeW [Occ=Once!] ->
                    case ww3_s1jeW of wild_s1jeX {
                      __DEFAULT ->
                          case quotInt# [ww1_s1jeU wild_s1jeX] of ww4_s1jeY {
                            __DEFAULT -> GHC.Types.I# [ww4_s1jeY];
                          };
                      -1# ->
                          case ww1_s1jeU of wild1_s1jeZ {
                            __DEFAULT ->
                                case quotInt# [wild1_s1jeZ -1#] of sat_s1jf0 {
                                  __DEFAULT -> GHC.Types.I# [sat_s1jf0];
                                };
                            -9223372036854775808# -> GHC.Real.overflowError;
                          };
                      0# -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralInt [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Integral GHC.Types.Int
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Integral! [GHC.Real.$fRealInt
                                        GHC.Enum.$fEnumInt
                                        GHC.Real.$fIntegralInt_$cquot
                                        GHC.Real.$fIntegralInt_$crem
                                        GHC.Real.$fIntegralInt_$cdiv
                                        GHC.Real.$fIntegralInt_$cmod
                                        GHC.Real.$fIntegralInt_$cquotRem
                                        GHC.Real.$fIntegralInt_$cdivMod
                                        GHC.Real.$fIntegralInt_$ctoInteger];

lvl1_r1j39 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [-1#];

lvl2_r1j3a :: GHC.Types.Int
[GblId] =
    [] \u [] GHC.Real.$wgcd' lvl1_r1j39 0#;
GHC.Real.$wgcd' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: GHC.Types.Int -> GHC.Prim.Int# -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [w_s1jf3 ww_s1jf4]
        case ww_s1jf4 of wild_s1jf5 {
          __DEFAULT ->
              case w_s1jf3 of {
                GHC.Types.I# x_s1jf7 [Occ=Once] ->
                    case remInt# [x_s1jf7 wild_s1jf5] of wild2_s1jf8 {
                      __DEFAULT ->
                          let {
                            sat_s1jf9 [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [wild_s1jf5];
                          } in  GHC.Real.$wgcd' sat_s1jf9 wild2_s1jf8;
                    };
              };
          -1# -> lvl2_r1j3a;
          0# -> w_s1jf3;
        };

GHC.Real.$fEnumRatio_gcd' [Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [a_s1jfa ds_s1jfb]
        case GHC.Integer.Type.eqInteger# ds_s1jfb GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.remInteger a_s1jfa ds_s1jfb of sat_s1jfd {
                __DEFAULT -> GHC.Real.$fEnumRatio_gcd' ds_s1jfb sat_s1jfd;
              };
          1# -> a_s1jfa;
        };

GHC.Real.gcd [InlPrag=NOINLINE[1]]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(U(A,A,A,A,C(U),A,1*C1(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jfe eta_s1jff eta1_s1jfg]
        case
            GHC.Real.$p1Integral $dIntegral_s1jfe
        of
        $dReal_s1jfh [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(U(A,A,A,A,C(U),A,1*C1(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                lvl8_s1jfi [Occ=OnceL] :: a_a1eor
                [LclId] =
                    [$dReal_s1jfh] \u []
                        case GHC.Real.$p1Real $dReal_s1jfh of sat_s1jfj {
                          __DEFAULT -> GHC.Num.fromInteger sat_s1jfj GHC.Real.even1;
                        };
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1jfh
                of
                $dEq_s1jfk [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Classes.$p1Ord $dEq_s1jfk
                      of
                      $dEq1_s1jfl [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                      { __DEFAULT ->
                            let {
                              $dNum_s1jfm [Dmd=<L,U(A,A,A,A,C(U),A,A)>] :: GHC.Num.Num a_a1eor
                              [LclId] =
                                  [$dReal_s1jfh] \u [] GHC.Real.$p1Real $dReal_s1jfh; } in
                            let {
                              sat_s1jft [Occ=Once] :: a_a1eor
                              [LclId] =
                                  [eta1_s1jfg $dNum_s1jfm] \u []
                                      GHC.Num.abs $dNum_s1jfm eta1_s1jfg; } in
                            let {
                              sat_s1jfs [Occ=Once] :: a_a1eor
                              [LclId] =
                                  [eta_s1jff $dNum_s1jfm] \u [] GHC.Num.abs $dNum_s1jfm eta_s1jff;
                            } in 
                              let-no-escape {
                                gcd'_s1jfn [Occ=LoopBreakerT[2]] :: a_a1eor -> a_a1eor -> a_a1eor
                                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                    sat-only [$dIntegral_s1jfe
                                              lvl8_s1jfi
                                              $dEq1_s1jfl
                                              gcd'_s1jfn] \r [a1_s1jfo ds_s1jfp]
                                        case GHC.Classes.== $dEq1_s1jfl ds_s1jfp lvl8_s1jfi of {
                                          GHC.Types.False ->
                                              let {
                                                sat_s1jfr [Occ=Once] :: a_a1eor
                                                [LclId] =
                                                    [$dIntegral_s1jfe a1_s1jfo ds_s1jfp] \u []
                                                        GHC.Real.rem
                                                            $dIntegral_s1jfe a1_s1jfo ds_s1jfp;
                                              } in  gcd'_s1jfn ds_s1jfp sat_s1jfr;
                                          GHC.Types.True -> a1_s1jfo;
                                        };
                              } in  gcd'_s1jfn sat_s1jfs sat_s1jft;
                      };
                };
        };

GHC.Real.$w$sreduce [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [w_s1jfu w1_s1jfv]
        case GHC.Integer.Type.eqInteger# w1_s1jfv GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.absInteger w1_s1jfv of sat_s1jfz {
                __DEFAULT ->
                    case GHC.Integer.Type.absInteger w_s1jfu of sat_s1jfy {
                      __DEFAULT ->
                          case
                              GHC.Real.$fEnumRatio_gcd' sat_s1jfy sat_s1jfz
                          of
                          d_s1jfx [Dmd=<S,U>]
                          { __DEFAULT ->
                                case GHC.Integer.Type.eqInteger# d_s1jfx GHC.Real.even1 of {
                                  __DEFAULT ->
                                      case
                                          GHC.Integer.Type.quotInteger w_s1jfu d_s1jfx
                                      of
                                      dt_s1jfB
                                      { __DEFAULT ->
                                            case
                                                GHC.Integer.Type.quotInteger w1_s1jfv d_s1jfx
                                            of
                                            dt1_s1jfC
                                            { __DEFAULT -> (#,#) [dt_s1jfB dt1_s1jfC];
                                            };
                                      };
                                  1# -> GHC.Real.divZeroError;
                                };
                          };
                    };
              };
          1# -> GHC.Real.ratioZeroDenominatorError;
        };

GHC.Real.reduce_$sreduce [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S,U>m, Unf=OtherCon []] =
    [] \r [w_s1jfF w1_s1jfG]
        case GHC.Real.$w$sreduce w_s1jfF w1_s1jfG of {
          (#,#) ww1_s1jfI [Occ=Once] ww2_s1jfJ [Occ=Once] ->
              GHC.Real.:% [ww1_s1jfI ww2_s1jfJ];
        };

GHC.Real.$fRealWord_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Word -> GHC.Real.Rational
[GblId, Arity=1, Str=<S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1jfK]
        case w_s1jfK of {
          GHC.Types.W# ww1_s1jfM [Occ=Once] ->
              case GHC.Integer.Type.wordToInteger ww1_s1jfM of sat_s1jfN {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger sat_s1jfN GHC.Real.$fEnumRatio1
                    of
                    sat_s1jfO
                    { __DEFAULT ->
                          case GHC.Real.$w$sreduce sat_s1jfO GHC.Real.$fEnumRatio1 of {
                            (#,#) ww3_s1jfQ [Occ=Once] ww4_s1jfR [Occ=Once] ->
                                GHC.Real.:% [ww3_s1jfQ ww4_s1jfR];
                          };
                    };
              };
        };

GHC.Real.$fRealWord [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real GHC.Types.Word
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Num.$fNumWord
                                    GHC.Classes.$fOrdWord
                                    GHC.Real.$fRealWord_$ctoRational];

GHC.Real.$fIntegralWord [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Integral GHC.Types.Word
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Integral! [GHC.Real.$fRealWord
                                        GHC.Enum.$fEnumWord
                                        GHC.Real.$fIntegralWord_$cquot
                                        GHC.Real.$fIntegralWord_$crem
                                        GHC.Real.$fIntegralWord_$cquot
                                        GHC.Real.$fIntegralWord_$crem
                                        GHC.Real.$fIntegralWord_$cquotRem
                                        GHC.Real.$fIntegralWord_$cdivMod
                                        GHC.Real.$fIntegralWord_$ctoInteger];

GHC.Real.$fFractionalRatio_$s$c* [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jfS w1_s1jfT]
        case w_s1jfS of {
          GHC.Real.:% ww1_s1jfV [Occ=Once] ww2_s1jfW [Occ=Once] ->
              case w1_s1jfT of {
                GHC.Real.:% ww4_s1jfY [Occ=Once] ww5_s1jfZ [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww2_s1jfW ww5_s1jfZ
                    of
                    sat_s1jg1
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1jfV ww4_s1jfY
                          of
                          sat_s1jg0
                          { __DEFAULT ->
                                case GHC.Real.$w$sreduce sat_s1jg0 sat_s1jg1 of {
                                  (#,#) ww7_s1jg3 [Occ=Once] ww8_s1jg4 [Occ=Once] ->
                                      GHC.Real.:% [ww7_s1jg3 ww8_s1jg4];
                                };
                          };
                    };
              };
        };

GHC.Real.$w$s$c- [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=4, Str=<S,1*U><S,U><S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1jg5 ww1_s1jg6 ww2_s1jg7 ww3_s1jg8]
        case
            GHC.Integer.Type.timesInteger ww1_s1jg6 ww3_s1jg8
        of
        sat_s1jgc
        { __DEFAULT ->
              case
                  GHC.Integer.Type.timesInteger ww2_s1jg7 ww1_s1jg6
              of
              sat_s1jga
              { __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger ww_s1jg5 ww3_s1jg8
                    of
                    sat_s1jg9
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.minusInteger sat_s1jg9 sat_s1jga
                          of
                          sat_s1jgb
                          { __DEFAULT -> GHC.Real.$w$sreduce sat_s1jgb sat_s1jgc;
                          };
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$c- [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jgd w1_s1jge]
        case w_s1jgd of {
          GHC.Real.:% ww1_s1jgg [Occ=Once] ww2_s1jgh [Occ=Once] ->
              case w1_s1jge of {
                GHC.Real.:% ww4_s1jgj [Occ=Once] ww5_s1jgk [Occ=Once] ->
                    case GHC.Real.$w$s$c- ww1_s1jgg ww2_s1jgh ww4_s1jgj ww5_s1jgk of {
                      (#,#) ww7_s1jgm [Occ=Once] ww8_s1jgn [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jgm ww8_s1jgn];
                    };
              };
        };

GHC.Real.$w$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=4, Str=<S,1*U><S,U><S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1jgo ww1_s1jgp ww2_s1jgq ww3_s1jgr]
        case
            GHC.Integer.Type.timesInteger ww1_s1jgp ww3_s1jgr
        of
        sat_s1jgv
        { __DEFAULT ->
              case
                  GHC.Integer.Type.timesInteger ww2_s1jgq ww1_s1jgp
              of
              sat_s1jgt
              { __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger ww_s1jgo ww3_s1jgr
                    of
                    sat_s1jgs
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.plusInteger sat_s1jgs sat_s1jgt
                          of
                          sat_s1jgu
                          { __DEFAULT -> GHC.Real.$w$sreduce sat_s1jgu sat_s1jgv;
                          };
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jgw w1_s1jgx]
        case w_s1jgw of {
          GHC.Real.:% ww1_s1jgz [Occ=Once] ww2_s1jgA [Occ=Once] ->
              case w1_s1jgx of {
                GHC.Real.:% ww4_s1jgC [Occ=Once] ww5_s1jgD [Occ=Once] ->
                    case GHC.Real.$w$s$c+ ww1_s1jgz ww2_s1jgA ww4_s1jgC ww5_s1jgD of {
                      (#,#) ww7_s1jgF [Occ=Once] ww8_s1jgG [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jgF ww8_s1jgG];
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$fNumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Num.Num (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Num.C:Num! [GHC.Real.$fEnumRatio_$s$c+
                                  GHC.Real.$fEnumRatio_$s$c-
                                  GHC.Real.$fFractionalRatio_$s$c*
                                  GHC.Real.$fFractionalRatio_$s$cnegate
                                  GHC.Real.$fFractionalRatio_$s$cabs
                                  GHC.Real.$fFractionalRatio_$s$csignum
                                  GHC.Real.$fFractionalRatio_$s$cfromInteger];

GHC.Real.$w$s$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1jgH ww1_s1jgI]
        case GHC.Integer.Type.absInteger ww1_s1jgI of sat_s1jgL {
          __DEFAULT ->
              case GHC.Integer.Type.signumInteger ww1_s1jgI of sat_s1jgJ {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger ww_s1jgH sat_s1jgJ
                    of
                    sat_s1jgK
                    { __DEFAULT -> GHC.Real.$w$sreduce sat_s1jgK sat_s1jgL;
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Rational -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_s1jgM]
        case w_s1jgM of {
          GHC.Real.:% ww1_s1jgO [Occ=Once] ww2_s1jgP [Occ=Once] ->
              case GHC.Real.$w$s$cfromRational ww1_s1jgO ww2_s1jgP of {
                (#,#) ww4_s1jgR [Occ=Once] ww5_s1jgS [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jgR ww5_s1jgS];
              };
        };

GHC.Real.$w$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId,
 Arity=4,
 Str=<S,1*U><S,1*U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_s1jgT ww1_s1jgU ww2_s1jgV ww3_s1jgW]
        case
            GHC.Integer.Type.timesInteger ww1_s1jgU ww2_s1jgV
        of
        y_s1jgX [Dmd=<S,U>]
        { __DEFAULT ->
              case GHC.Integer.Type.absInteger y_s1jgX of sat_s1jh1 {
                __DEFAULT ->
                    case GHC.Integer.Type.signumInteger y_s1jgX of sat_s1jgZ {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww_s1jgT ww3_s1jgW
                          of
                          sat_s1jgY
                          { __DEFAULT ->
                                case
                                    GHC.Integer.Type.timesInteger sat_s1jgY sat_s1jgZ
                                of
                                sat_s1jh0
                                { __DEFAULT -> GHC.Real.$w$sreduce sat_s1jh0 sat_s1jh1;
                                };
                          };
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jh2 w1_s1jh3]
        case w_s1jh2 of {
          GHC.Real.:% ww1_s1jh5 [Occ=Once] ww2_s1jh6 [Occ=Once] ->
              case w1_s1jh3 of {
                GHC.Real.:% ww4_s1jh8 [Occ=Once] ww5_s1jh9 [Occ=Once] ->
                    case GHC.Real.$w$s$c/ ww1_s1jh5 ww2_s1jh6 ww4_s1jh8 ww5_s1jh9 of {
                      (#,#) ww7_s1jhb [Occ=Once] ww8_s1jhc [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jhb ww8_s1jhc];
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$fFractionalRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Fractional (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Fractional! [GHC.Real.$fFractionalRatio_$s$fNumRatio
                                          GHC.Real.$fFractionalRatio_$s$c/
                                          GHC.Real.$fFractionalRatio_$s$crecip
                                          GHC.Real.$fFractionalRatio_$s$cfromRational];

GHC.Real.ratioPrec :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [7#];

GHC.Real.infinity :: GHC.Real.Rational
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.$fEnumRatio1 GHC.Real.even1];

GHC.Real.notANumber :: GHC.Real.Rational
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.even1 GHC.Real.even1];

GHC.Real.numerator :: forall a. GHC.Real.Ratio a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_s1jhd]
        case ds_s1jhd of {
          GHC.Real.:% x_s1jhf [Occ=Once] _ [Occ=Dead] -> x_s1jhf;
        };

GHC.Real.denominator :: forall a. GHC.Real.Ratio a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1jhh]
        case ds_s1jhh of {
          GHC.Real.:% _ [Occ=Dead] y_s1jhk [Occ=Once] -> y_s1jhk;
        };

GHC.Real.$w$snumericEnumFrom [InlPrag=NOUSERINLINE[0],
                              Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Real.Ratio GHC.Integer.Type.Integer,
           [GHC.Real.Ratio GHC.Integer.Type.Integer] #)
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1jhl ww1_s1jhm]
        let {
          sat_s1jhu [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
          [LclId] =
              [ww_s1jhl ww1_s1jhm] \u []
                  case
                      GHC.Real.$w$s$c+
                          ww_s1jhl ww1_s1jhm GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
                  of
                  { (#,#) ww3_s1jhp [Occ=Once] ww4_s1jhq [Occ=Once] ->
                        case GHC.Real.$w$snumericEnumFrom ww3_s1jhp ww4_s1jhq of {
                          (#,#) ww6_s1jhs [Occ=Once] ww7_s1jht [Occ=Once] ->
                              : [ww6_s1jhs ww7_s1jht];
                        };
                  }; } in
        let {
          sat_s1jhn [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId] =
              CCCS GHC.Real.:%! [ww_s1jhl ww1_s1jhm];
        } in  (#,#) [sat_s1jhn sat_s1jhu];

GHC.Real.$fEnumRatio_$snumericEnumFrom [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m2, Unf=OtherCon []] =
    [] \r [w_s1jhv]
        case w_s1jhv of {
          GHC.Real.:% ww1_s1jhx [Occ=Once] ww2_s1jhy [Occ=Once] ->
              case GHC.Real.$w$snumericEnumFrom ww1_s1jhx ww2_s1jhy of {
                (#,#) ww4_s1jhA [Occ=Once] ww5_s1jhB [Occ=Once] ->
                    : [ww4_s1jhA ww5_s1jhB];
              };
        };

GHC.Real.$wnumericEnumFrom [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: forall a. GHC.Real.Fractional a => a -> (# a, [a] #)
[GblId,
 Arity=2,
 Str=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1jhC w1_s1jhD]
        case w1_s1jhD of n_s1jhE {
          __DEFAULT ->
              let {
                sat_s1jhL [Occ=Once] :: [a_s1hA7]
                [LclId] =
                    [w_s1jhC n_s1jhE] \u []
                        case
                            GHC.Real.$p1Fractional w_s1jhC
                        of
                        $dNum_s1jhF [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                        { __DEFAULT ->
                              let {
                                sat_s1jhG [Occ=Once] :: a_s1hA7
                                [LclId] =
                                    [$dNum_s1jhF] \u []
                                        GHC.Num.fromInteger $dNum_s1jhF GHC.Real.$fEnumRatio1;
                              } in 
                                case GHC.Num.+ $dNum_s1jhF n_s1jhE sat_s1jhG of sat_s1jhH {
                                  __DEFAULT ->
                                      case GHC.Real.$wnumericEnumFrom w_s1jhC sat_s1jhH of {
                                        (#,#) ww1_s1jhJ [Occ=Once] ww2_s1jhK [Occ=Once] ->
                                            : [ww1_s1jhJ ww2_s1jhK];
                                      };
                                };
                        };
              } in  (#,#) [n_s1jhE sat_s1jhL];
        };

GHC.Real.numericEnumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Fractional a => a -> [a]
[GblId,
 Arity=2,
 Str=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_s1jhM w1_s1jhN]
        case GHC.Real.$wnumericEnumFrom w_s1jhM w1_s1jhN of {
          (#,#) ww1_s1jhP [Occ=Once] ww2_s1jhQ [Occ=Once] ->
              : [ww1_s1jhP ww2_s1jhQ];
        };

sat_s1jhR :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_s1jhS :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1jhR GHC.Types.[]];

GHC.Real.even2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s1jhS;

GHC.Real.$fEnumRatio2 :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId] =
    [] \u []
        case
            GHC.Real.$w$s$c/
                GHC.Real.$fEnumRatio1
                GHC.Real.$fEnumRatio1
                GHC.Real.even2
                GHC.Real.$fEnumRatio1
        of
        { (#,#) ww1_s1jhU [Occ=Once] ww2_s1jhV [Occ=Once] ->
              GHC.Real.:% [ww1_s1jhU ww2_s1jhV];
        };

GHC.Real.$w$snumericEnumFromTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId, Arity=3, Str=<L,U><L,U><L,1*U(U,U)>, Unf=OtherCon []] =
    [] \r [ww_s1jhW ww1_s1jhX w_s1jhY]
        case GHC.Real.$w$snumericEnumFrom ww_s1jhW ww1_s1jhX of {
          (#,#) ww3_s1ji0 [Occ=Once] ww4_s1ji1 [Occ=Once] ->
              let {
                sat_s1jie [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
                [LclId] =
                    CCCS :! [ww3_s1ji0 ww4_s1ji1]; } in
              let {
                ds_s1ji2 [Occ=OnceL, Dmd=<L,U(U,U)>]
                  :: GHC.Real.Ratio GHC.Integer.Type.Integer
                [LclId] =
                    [w_s1jhY] \u []
                        case w_s1jhY of {
                          GHC.Real.:% ww6_s1ji4 [Occ=Once] ww7_s1ji5 [Occ=Once] ->
                              case GHC.Real.$fEnumRatio2 of {
                                GHC.Real.:% ww9_s1ji7 [Occ=Once] ww10_s1ji8 [Occ=Once] ->
                                    case
                                        GHC.Real.$w$s$c+ ww6_s1ji4 ww7_s1ji5 ww9_s1ji7 ww10_s1ji8
                                    of
                                    { (#,#) ww12_s1jia [Occ=Once] ww13_s1jib [Occ=Once] ->
                                          GHC.Real.:% [ww12_s1jia ww13_s1jib];
                                    };
                              };
                        }; } in
              let {
                sat_s1jid [Occ=Once]
                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                [LclId] =
                    [ds_s1ji2] \r [ds1_s1jic]
                        GHC.Real.$fEnumRatio_$s$c<= ds1_s1jic ds_s1ji2;
              } in  GHC.List.takeWhile sat_s1jid sat_s1jie;
        };

GHC.Real.$fEnumRatio_$snumericEnumFromTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jif w1_s1jig]
        case w_s1jif of {
          GHC.Real.:% ww1_s1jii [Occ=Once] ww2_s1jij [Occ=Once] ->
              GHC.Real.$w$snumericEnumFromTo ww1_s1jii ww2_s1jij w1_s1jig;
        };

GHC.Real.numericEnumFromTo
  :: forall a.
     (GHC.Classes.Ord a, GHC.Real.Fractional a) =>
     a -> a -> [a]
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U(U(C(C1(U)),A,A,A,A,A,C(U)),1*C1(C1(U)),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1jik $dFractional_s1jil eta_s1jim eta1_s1jin]
        case GHC.Real.$wnumericEnumFrom $dFractional_s1jil eta_s1jim of {
          (#,#) ww1_s1jip [Occ=Once] ww2_s1jiq [Occ=Once] ->
              let {
                $dNum_s1jir [Dmd=<L,U(1*C1(C1(U)),A,A,A,A,A,C(U))>]
                  :: GHC.Num.Num a_a1ew7
                [LclId] =
                    [$dFractional_s1jil] \u []
                        GHC.Real.$p1Fractional $dFractional_s1jil; } in
              let {
                sat_s1jiy [Occ=Once] :: [a_a1ew7]
                [LclId] =
                    CCCS :! [ww1_s1jip ww2_s1jiq]; } in
              let {
                ds_s1jis [Occ=OnceL] :: a_a1ew7
                [LclId] =
                    [$dFractional_s1jil eta1_s1jin $dNum_s1jir] \u []
                        let {
                          sat_s1jiv [Occ=Once] :: a_a1ew7
                          [LclId] =
                              [$dFractional_s1jil $dNum_s1jir] \u []
                                  let {
                                    sat_s1jiu [Occ=Once] :: a_a1ew7
                                    [LclId] =
                                        [$dNum_s1jir] \u []
                                            GHC.Num.fromInteger $dNum_s1jir GHC.Real.even2; } in
                                  let {
                                    sat_s1jit [Occ=Once] :: a_a1ew7
                                    [LclId] =
                                        [$dNum_s1jir] \u []
                                            GHC.Num.fromInteger $dNum_s1jir GHC.Real.$fEnumRatio1;
                                  } in  GHC.Real./ $dFractional_s1jil sat_s1jit sat_s1jiu;
                        } in  GHC.Num.+ $dNum_s1jir eta1_s1jin sat_s1jiv; } in
              let {
                sat_s1jix [Occ=Once] :: a_a1ew7 -> GHC.Types.Bool
                [LclId] =
                    [$dOrd_s1jik ds_s1jis] \r [ds1_s1jiw]
                        GHC.Classes.<= $dOrd_s1jik ds1_s1jiw ds_s1jis;
              } in  GHC.List.takeWhile sat_s1jix sat_s1jiy;
        };

GHC.Real.$w$snumericEnumFromThen [InlPrag=NOUSERINLINE[0],
                                  Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Real.Ratio GHC.Integer.Type.Integer,
           [GHC.Real.Ratio GHC.Integer.Type.Integer] #)
[GblId, Arity=4, Str=<L,U><L,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1jiz ww1_s1jiA ww2_s1jiB ww3_s1jiC]
        let {
          sat_s1jiN [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
          [LclId] =
              [ww_s1jiz ww1_s1jiA ww2_s1jiB ww3_s1jiC] \u []
                  case GHC.Real.$w$s$c+ ww2_s1jiB ww3_s1jiC ww2_s1jiB ww3_s1jiC of {
                    (#,#) ww5_s1jiF [Occ=Once] ww6_s1jiG [Occ=Once] ->
                        case GHC.Real.$w$s$c- ww5_s1jiF ww6_s1jiG ww_s1jiz ww1_s1jiA of {
                          (#,#) ww8_s1jiI [Occ=Once] ww9_s1jiJ [Occ=Once] ->
                              case
                                  GHC.Real.$w$snumericEnumFromThen
                                      ww2_s1jiB ww3_s1jiC ww8_s1jiI ww9_s1jiJ
                              of
                              { (#,#) ww11_s1jiL [Occ=Once] ww12_s1jiM [Occ=Once] ->
                                    : [ww11_s1jiL ww12_s1jiM];
                              };
                        };
                  }; } in
        let {
          sat_s1jiD [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId] =
              CCCS GHC.Real.:%! [ww_s1jiz ww1_s1jiA];
        } in  (#,#) [sat_s1jiD sat_s1jiN];

GHC.Real.$fEnumRatio_$snumericEnumFromThen [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s1jiO w1_s1jiP]
        case w_s1jiO of {
          GHC.Real.:% ww1_s1jiR [Occ=Once] ww2_s1jiS [Occ=Once] ->
              case w1_s1jiP of {
                GHC.Real.:% ww4_s1jiU [Occ=Once] ww5_s1jiV [Occ=Once] ->
                    case
                        GHC.Real.$w$snumericEnumFromThen
                            ww1_s1jiR ww2_s1jiS ww4_s1jiU ww5_s1jiV
                    of
                    { (#,#) ww7_s1jiX [Occ=Once] ww8_s1jiY [Occ=Once] ->
                          : [ww7_s1jiX ww8_s1jiY];
                    };
              };
        };

GHC.Real.$wnumericEnumFromThen [InlPrag=NOUSERINLINE[0],
                                Occ=LoopBreaker]
  :: forall a. GHC.Real.Fractional a => a -> a -> (# a, [a] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1jiZ w1_s1jj0 w2_s1jj1]
        case w1_s1jj0 of n_s1jj2 {
          __DEFAULT ->
              case w2_s1jj1 of m_s1jj3 {
                __DEFAULT ->
                    let {
                      sat_s1jja [Occ=Once] :: [a_s1hAH]
                      [LclId] =
                          [w_s1jiZ n_s1jj2 m_s1jj3] \u []
                              case
                                  GHC.Real.$p1Fractional w_s1jiZ
                              of
                              $dNum_s1jj4 [Dmd=<S(LC(C(S))LLLLL),U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,A)>]
                              { __DEFAULT ->
                                    let {
                                      sat_s1jj5 [Occ=Once] :: a_s1hAH
                                      [LclId] =
                                          [m_s1jj3 $dNum_s1jj4] \u []
                                              GHC.Num.+ $dNum_s1jj4 m_s1jj3 m_s1jj3;
                                    } in 
                                      case GHC.Num.- $dNum_s1jj4 sat_s1jj5 n_s1jj2 of sat_s1jj6 {
                                        __DEFAULT ->
                                            case
                                                GHC.Real.$wnumericEnumFromThen
                                                    w_s1jiZ m_s1jj3 sat_s1jj6
                                            of
                                            { (#,#) ww1_s1jj8 [Occ=Once] ww2_s1jj9 [Occ=Once] ->
                                                  : [ww1_s1jj8 ww2_s1jj9];
                                            };
                                      };
                              };
                    } in  (#,#) [n_s1jj2 sat_s1jja];
              };
        };

GHC.Real.numericEnumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Fractional a => a -> a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)><S,1*U><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_s1jjb w1_s1jjc w2_s1jjd]
        case GHC.Real.$wnumericEnumFromThen w_s1jjb w1_s1jjc w2_s1jjd of {
          (#,#) ww1_s1jjf [Occ=Once] ww2_s1jjg [Occ=Once] ->
              : [ww1_s1jjf ww2_s1jjg];
        };

GHC.Real.$w$snumericEnumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=5,
 Str=<L,U><L,U><L,U><L,U><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [ww_s1jjh ww1_s1jji ww2_s1jjj ww3_s1jjk w_s1jjl]
        case
            GHC.Real.$w$snumericEnumFromThen
                ww_s1jjh ww1_s1jji ww2_s1jjj ww3_s1jjk
        of
        { (#,#) ww5_s1jjn [Occ=Once] ww6_s1jjo [Occ=Once] ->
              let {
                sat_s1jjV [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
                [LclId] =
                    CCCS :! [ww5_s1jjn ww6_s1jjo]; } in
              let {
                sat_s1jjU [Occ=Once, Dmd=<L,C(U)>]
                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                [LclId] =
                    [ww_s1jjh ww1_s1jji ww2_s1jjj ww3_s1jjk w_s1jjl] \u []
                        case
                            GHC.Real.$w$s$ccompare ww2_s1jjj ww3_s1jjk ww_s1jjh ww1_s1jji
                        of
                        { __DEFAULT ->
                              let {
                                ds_s1jjq [Occ=OnceL, Dmd=<L,U(U,U)>]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer
                                [LclId] =
                                    [ww_s1jjh ww1_s1jji ww2_s1jjj ww3_s1jjk w_s1jjl] \u []
                                        case w_s1jjl of {
                                          GHC.Real.:% ww8_s1jjs [Occ=Once] ww9_s1jjt [Occ=Once] ->
                                              case
                                                  GHC.Real.$w$s$c-
                                                      ww2_s1jjj ww3_s1jjk ww_s1jjh ww1_s1jji
                                              of
                                              { (#,#) ww11_s1jjv [Occ=Once] ww12_s1jjw [Occ=Once] ->
                                                    case
                                                        GHC.Real.$w$s$c/
                                                            ww11_s1jjv
                                                            ww12_s1jjw
                                                            GHC.Real.even2
                                                            GHC.Real.$fEnumRatio1
                                                    of
                                                    { (#,#) ww14_s1jjy [Occ=Once]
                                                            ww15_s1jjz [Occ=Once] ->
                                                          case
                                                              GHC.Real.$w$s$c+
                                                                  ww8_s1jjs
                                                                  ww9_s1jjt
                                                                  ww14_s1jjy
                                                                  ww15_s1jjz
                                                          of
                                                          { (#,#) ww17_s1jjB [Occ=Once]
                                                                  ww18_s1jjC [Occ=Once] ->
                                                                GHC.Real.:% [ww17_s1jjB ww18_s1jjC];
                                                          };
                                                    };
                                              };
                                        }; } in
                              let {
                                sat_s1jjE [Occ=OnceT[0]]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                                [LclId] =
                                    [ds_s1jjq] \r [ds1_s1jjD]
                                        GHC.Real.$fEnumRatio_$s$c<= ds1_s1jjD ds_s1jjq;
                              } in  sat_s1jjE;
                          GHC.Types.LT ->
                              let {
                                ds_s1jjF [Occ=OnceL, Dmd=<L,U(U,U)>]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer
                                [LclId] =
                                    [ww_s1jjh ww1_s1jji ww2_s1jjj ww3_s1jjk w_s1jjl] \u []
                                        case w_s1jjl of {
                                          GHC.Real.:% ww8_s1jjH [Occ=Once] ww9_s1jjI [Occ=Once] ->
                                              case
                                                  GHC.Real.$w$s$c-
                                                      ww2_s1jjj ww3_s1jjk ww_s1jjh ww1_s1jji
                                              of
                                              { (#,#) ww11_s1jjK [Occ=Once] ww12_s1jjL [Occ=Once] ->
                                                    case
                                                        GHC.Real.$w$s$c/
                                                            ww11_s1jjK
                                                            ww12_s1jjL
                                                            GHC.Real.even2
                                                            GHC.Real.$fEnumRatio1
                                                    of
                                                    { (#,#) ww14_s1jjN [Occ=Once]
                                                            ww15_s1jjO [Occ=Once] ->
                                                          case
                                                              GHC.Real.$w$s$c+
                                                                  ww8_s1jjH
                                                                  ww9_s1jjI
                                                                  ww14_s1jjN
                                                                  ww15_s1jjO
                                                          of
                                                          { (#,#) ww17_s1jjQ [Occ=Once]
                                                                  ww18_s1jjR [Occ=Once] ->
                                                                GHC.Real.:% [ww17_s1jjQ ww18_s1jjR];
                                                          };
                                                    };
                                              };
                                        }; } in
                              let {
                                sat_s1jjT [Occ=OnceT[0]]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                                [LclId] =
                                    [ds_s1jjF] \r [ds1_s1jjS]
                                        GHC.Real.$fEnumRatio_$s$c>= ds1_s1jjS ds_s1jjF;
                              } in  sat_s1jjT;
                        };
              } in  GHC.List.takeWhile sat_s1jjU sat_s1jjV;
        };

GHC.Real.$fEnumRatio_$snumericEnumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=3,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jjW w1_s1jjX w2_s1jjY]
        case w_s1jjW of {
          GHC.Real.:% ww1_s1jk0 [Occ=Once] ww2_s1jk1 [Occ=Once] ->
              case w1_s1jjX of {
                GHC.Real.:% ww4_s1jk3 [Occ=Once] ww5_s1jk4 [Occ=Once] ->
                    GHC.Real.$w$snumericEnumFromThenTo
                        ww1_s1jk0 ww2_s1jk1 ww4_s1jk3 ww5_s1jk4 w2_s1jjY;
              };
        };

GHC.Real.numericEnumFromThenTo
  :: forall a.
     (GHC.Classes.Ord a, GHC.Real.Fractional a) =>
     a -> a -> a -> [a]
[GblId,
 Arity=5,
 Str=<L,U(A,A,A,C(C1(U)),A,C(C1(U)),A,A)><L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,1*C1(U)),1*C1(C1(U)),A,A)><S,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1jk5
           $dFractional_s1jk6
           eta_s1jk7
           eta1_s1jk8
           eta2_s1jk9]
        case
            GHC.Real.$wnumericEnumFromThen
                $dFractional_s1jk6 eta_s1jk7 eta1_s1jk8
        of
        { (#,#) ww1_s1jkb [Occ=Once] ww2_s1jkc [Occ=Once] ->
              let {
                sat_s1jkp [Occ=Once] :: [a_a1evf]
                [LclId] =
                    CCCS :! [ww1_s1jkb ww2_s1jkc]; } in
              let {
                sat_s1jko [Occ=Once, Dmd=<L,C(U)>] :: a_a1evf -> GHC.Types.Bool
                [LclId] =
                    [$dOrd_s1jk5
                     $dFractional_s1jk6
                     eta_s1jk7
                     eta1_s1jk8
                     eta2_s1jk9] \u []
                        let {
                          $dNum_s1jkd [Dmd=<L,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                            :: GHC.Num.Num a_a1evf
                          [LclId] =
                              [$dFractional_s1jk6] \u []
                                  GHC.Real.$p1Fractional $dFractional_s1jk6; } in
                        let {
                          mid_s1jke [Occ=Once*] :: a_a1evf
                          [LclId] =
                              [$dFractional_s1jk6 eta_s1jk7 eta1_s1jk8 $dNum_s1jkd] \u []
                                  let {
                                    sat_s1jkg [Occ=Once] :: a_a1evf
                                    [LclId] =
                                        [$dNum_s1jkd] \u []
                                            GHC.Num.fromInteger $dNum_s1jkd GHC.Real.even2; } in
                                  let {
                                    sat_s1jkf [Occ=Once] :: a_a1evf
                                    [LclId] =
                                        [eta_s1jk7 eta1_s1jk8 $dNum_s1jkd] \u []
                                            GHC.Num.- $dNum_s1jkd eta1_s1jk8 eta_s1jk7;
                                  } in  GHC.Real./ $dFractional_s1jk6 sat_s1jkf sat_s1jkg;
                        } in 
                          case GHC.Classes.>= $dOrd_s1jk5 eta1_s1jk8 eta_s1jk7 of {
                            GHC.Types.False ->
                                let {
                                  ds_s1jki [Occ=OnceL] :: a_a1evf
                                  [LclId] =
                                      [eta2_s1jk9 $dNum_s1jkd mid_s1jke] \u []
                                          GHC.Num.+ $dNum_s1jkd eta2_s1jk9 mid_s1jke; } in
                                let {
                                  sat_s1jkk [Occ=OnceT[0]] :: a_a1evf -> GHC.Types.Bool
                                  [LclId] =
                                      [$dOrd_s1jk5 ds_s1jki] \r [ds1_s1jkj]
                                          GHC.Classes.>= $dOrd_s1jk5 ds1_s1jkj ds_s1jki;
                                } in  sat_s1jkk;
                            GHC.Types.True ->
                                let {
                                  ds_s1jkl [Occ=OnceL] :: a_a1evf
                                  [LclId] =
                                      [eta2_s1jk9 $dNum_s1jkd mid_s1jke] \u []
                                          GHC.Num.+ $dNum_s1jkd eta2_s1jk9 mid_s1jke; } in
                                let {
                                  sat_s1jkn [Occ=OnceT[0]] :: a_a1evf -> GHC.Types.Bool
                                  [LclId] =
                                      [$dOrd_s1jk5 ds_s1jkl] \r [ds1_s1jkm]
                                          GHC.Classes.<= $dOrd_s1jk5 ds1_s1jkm ds_s1jkl;
                                } in  sat_s1jkn;
                          };
              } in  GHC.List.takeWhile sat_s1jko sat_s1jkp;
        };

GHC.Real.fromIntegral [InlPrag=NOINLINE[1]]
  :: forall a b. (GHC.Real.Integral a, GHC.Num.Num b) => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U))><S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jkq $dNum_s1jkr eta_s1jks]
        let {
          sat_s1jkt [Occ=Once] :: GHC.Integer.Type.Integer
          [LclId] =
              [$dIntegral_s1jkq eta_s1jks] \u []
                  GHC.Real.toInteger $dIntegral_s1jkq eta_s1jks;
        } in  GHC.Num.fromInteger $dNum_s1jkr sat_s1jkt;

GHC.Real.realToFrac [InlPrag=NOINLINE[1]]
  :: forall a b. (GHC.Real.Real a, GHC.Real.Fractional b) => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(U))><S(LLLC(S)),1*U(A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_s1jku $dFractional_s1jkv eta_s1jkw]
        let {
          sat_s1jkx [Occ=Once] :: GHC.Real.Rational
          [LclId] =
              [$dReal_s1jku eta_s1jkw] \u []
                  GHC.Real.toRational $dReal_s1jku eta_s1jkw;
        } in  GHC.Real.fromRational $dFractional_s1jkv sat_s1jkx;

GHC.Real.showSigned1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['-'#];

GHC.Real.showSigned
  :: forall a.
     GHC.Real.Real a =>
     (a -> GHC.Show.ShowS) -> GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)><L,1*C1(U)><L,1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_s1jky eta_s1jkz eta1_s1jkA eta2_s1jkB]
        let {
          $dNum_s1jkC [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>]
            :: GHC.Num.Num a_a1euj
          [LclId] =
              [$dReal_s1jky] \u [] GHC.Real.$p1Real $dReal_s1jky; } in
        let {
          sat_s1jkE [Occ=Once] :: a_a1euj
          [LclId] =
              [$dNum_s1jkC] \u [] GHC.Num.fromInteger $dNum_s1jkC GHC.Real.even1;
        } in 
          case GHC.Real.$p2Real $dReal_s1jky of sat_s1jkD {
            __DEFAULT ->
                case GHC.Classes.< sat_s1jkD eta2_s1jkB sat_s1jkE of {
                  GHC.Types.False -> eta_s1jkz eta2_s1jkB;
                  GHC.Types.True ->
                      case eta1_s1jkA of {
                        GHC.Types.I# x_s1jkH [Occ=Once] ->
                            let {
                              g1_s1jkI [Occ=OnceL*!, Dmd=<L,C(U)>]
                                :: GHC.Base.String -> GHC.Base.String
                              [LclId] =
                                  [eta_s1jkz eta2_s1jkB $dNum_s1jkC] \u []
                                      let {
                                        sat_s1jkJ [Occ=Once] :: a_a1euj
                                        [LclId] =
                                            [eta2_s1jkB $dNum_s1jkC] \u []
                                                GHC.Num.negate $dNum_s1jkC eta2_s1jkB;
                                      } in  eta_s1jkz sat_s1jkJ;
                            } in 
                              case ># [x_s1jkH 6#] of {
                                __DEFAULT ->
                                    let {
                                      sat_s1jkN [Occ=OnceT[0]]
                                        :: GHC.Base.String -> [GHC.Types.Char]
                                      [LclId] =
                                          [g1_s1jkI] \r [x1_s1jkL]
                                              let {
                                                sat_s1jkM [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_s1jkI x1_s1jkL] \u [] g1_s1jkI x1_s1jkL;
                                              } in  : [GHC.Real.showSigned1 sat_s1jkM];
                                    } in  sat_s1jkN;
                                1# ->
                                    let {
                                      sat_s1jkS [Occ=OnceT[0]]
                                        :: GHC.Base.String -> [GHC.Types.Char]
                                      [LclId] =
                                          [g1_s1jkI] \r [x1_s1jkO]
                                              let {
                                                sat_s1jkQ [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_s1jkI x1_s1jkO] \u []
                                                        let {
                                                          sat_s1jkP [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2
                                                                       x1_s1jkO];
                                                        } in  g1_s1jkI sat_s1jkP; } in
                                              let {
                                                sat_s1jkR [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    CCCS :! [GHC.Real.showSigned1 sat_s1jkQ];
                                              } in  : [GHC.Show.$fShow(,)4 sat_s1jkR];
                                    } in  sat_s1jkS;
                              };
                      };
                };
          };

GHC.Real.even [InlPrag=INLINABLE]
  :: forall a. GHC.Real.Integral a => a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,1*C1(C1(U)),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jkT eta_s1jkU]
        case
            GHC.Real.$p1Integral $dIntegral_s1jkT
        of
        $dReal_s1jkV [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jkW [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_a1eq0
                [LclId] =
                    [$dReal_s1jkV] \u [] GHC.Real.$p1Real $dReal_s1jkV; } in
              let {
                sat_s1jl1 [Occ=Once] :: a_a1eq0
                [LclId] =
                    [$dNum_s1jkW] \u []
                        GHC.Num.fromInteger $dNum_s1jkW GHC.Real.even1; } in
              let {
                sat_s1jl0 [Occ=Once] :: a_a1eq0
                [LclId] =
                    [$dIntegral_s1jkT eta_s1jkU $dNum_s1jkW] \u []
                        let {
                          sat_s1jkZ [Occ=Once] :: a_a1eq0
                          [LclId] =
                              [$dNum_s1jkW] \u [] GHC.Num.fromInteger $dNum_s1jkW GHC.Real.even2;
                        } in  GHC.Real.rem $dIntegral_s1jkT eta_s1jkU sat_s1jkZ;
              } in 
                case GHC.Real.$p2Real $dReal_s1jkV of sat_s1jkX {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_s1jkX of sat_s1jkY {
                        __DEFAULT -> GHC.Classes.== sat_s1jkY sat_s1jl0 sat_s1jl1;
                      };
                };
        };

GHC.Real.odd [InlPrag=INLINABLE]
  :: forall a. GHC.Real.Integral a => a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jl2 x_s1jl3]
        case GHC.Real.even $dIntegral_s1jl2 x_s1jl3 of {
          GHC.Types.False -> GHC.Types.True [];
          GHC.Types.True -> GHC.Types.False [];
        };

lvl3_r1j3b :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.$fEnumRatio1 GHC.Real.even2];

lvl4_r1j3c :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "round default defn: Bad value"#;

GHC.Real.$fRealFracRatio1 :: forall b. b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl4_r1j3c of sat_s1jl5 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1jl5;
        };

GHC.Real.$dmround
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,A,A,1*C1(U)),1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U(U(U,U),U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1jl6 eta_s1jl7 eta1_s1jl8]
        let {
          ds_s1jl9 [Dmd=<L,U(1*U,1*U)>] :: (b_a1eBu, a_a1dNs)
          [LclId] =
              [$dRealFrac_s1jl6 eta_s1jl7 eta1_s1jl8] \u []
                  GHC.Real.properFraction $dRealFrac_s1jl6 eta_s1jl7 eta1_s1jl8;
        } in 
          case
              GHC.Real.$p1RealFrac $dRealFrac_s1jl6
          of
          $dReal_s1jla [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p2Real $dReal_s1jla
                of
                $dOrd_s1jlb [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Classes.$p1Ord $dOrd_s1jlb
                      of
                      $dEq_s1jlc [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                      { __DEFAULT ->
                            let {
                              $dNum_s1jld [Dmd=<L,U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U))>]
                                :: GHC.Num.Num a_a1dNs
                              [LclId] =
                                  [$dReal_s1jla] \u [] GHC.Real.$p1Real $dReal_s1jla; } in
                            let {
                              r_s1jle :: a_a1dNs
                              [LclId] =
                                  [ds_s1jl9] \u []
                                      case ds_s1jl9 of {
                                        (,) _ [Occ=Dead] r1_s1jlh [Occ=Once] -> r1_s1jlh;
                                      }; } in
                            let {
                              ds1_s1jli :: a_a1dNs
                              [LclId] =
                                  [$dRealFrac_s1jl6 $dNum_s1jld r_s1jle] \u []
                                      let {
                                        sat_s1jlm [Occ=Once] :: a_a1dNs
                                        [LclId] =
                                            [$dRealFrac_s1jl6 $dNum_s1jld r_s1jle] \u []
                                                let {
                                                  sat_s1jll [Occ=Once] :: a_a1dNs
                                                  [LclId] =
                                                      [$dRealFrac_s1jl6] \u []
                                                          case
                                                              GHC.Real.$p2RealFrac $dRealFrac_s1jl6
                                                          of
                                                          sat_s1jlk
                                                          { __DEFAULT ->
                                                                GHC.Real.fromRational
                                                                    sat_s1jlk lvl3_r1j3b;
                                                          }; } in
                                                let {
                                                  sat_s1jlj [Occ=Once] :: a_a1dNs
                                                  [LclId] =
                                                      [$dNum_s1jld r_s1jle] \u []
                                                          GHC.Num.abs $dNum_s1jld r_s1jle;
                                                } in  GHC.Num.- $dNum_s1jld sat_s1jlj sat_s1jll;
                                      } in  GHC.Num.signum $dNum_s1jld sat_s1jlm; } in
                            let {
                              n_s1jln :: b_a1eBu
                              [LclId] =
                                  [ds_s1jl9] \u []
                                      case ds_s1jl9 of {
                                        (,) n1_s1jlp [Occ=Once] _ [Occ=Dead] -> n1_s1jlp;
                                      }; } in
                            let {
                              sat_s1jls [Occ=Once] :: a_a1dNs
                              [LclId] =
                                  [$dNum_s1jld] \u []
                                      let {
                                        sat_s1jlr [Occ=Once] :: a_a1dNs
                                        [LclId] =
                                            [$dNum_s1jld] \u []
                                                GHC.Num.fromInteger
                                                    $dNum_s1jld GHC.Real.$fEnumRatio1;
                                      } in  GHC.Num.negate $dNum_s1jld sat_s1jlr;
                            } in 
                              case GHC.Classes.== $dEq_s1jlc ds1_s1jli sat_s1jls of {
                                GHC.Types.False ->
                                    let {
                                      sat_s1jlB [Occ=Once] :: a_a1dNs
                                      [LclId] =
                                          [$dNum_s1jld] \u []
                                              GHC.Num.fromInteger $dNum_s1jld GHC.Real.even1;
                                    } in 
                                      let-no-escape {
                                        m_s1jlu [Occ=Once*T[0], Dmd=<L,1*U>] :: b_a1eBu
                                        [LclId[JoinId(0)], Unf=OtherCon []] =
                                            [eta_s1jl7
                                             $dOrd_s1jlb
                                             $dNum_s1jld
                                             r_s1jle
                                             n_s1jln] \r []
                                                case
                                                    GHC.Real.$p1Integral eta_s1jl7
                                                of
                                                $dReal1_s1jlv [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                                { __DEFAULT ->
                                                      case
                                                          GHC.Real.$p1Real $dReal1_s1jlv
                                                      of
                                                      $dNum1_s1jlw [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                                      { __DEFAULT ->
                                                            let {
                                                              sat_s1jlx [Occ=Once] :: a_a1dNs
                                                              [LclId] =
                                                                  [$dNum_s1jld] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_s1jld
                                                                          GHC.Real.even1;
                                                            } in 
                                                              case
                                                                  GHC.Classes.<
                                                                      $dOrd_s1jlb r_s1jle sat_s1jlx
                                                              of
                                                              { GHC.Types.False ->
                                                                    let {
                                                                      sat_s1jlz [Occ=Once]
                                                                        :: b_a1eBu
                                                                      [LclId] =
                                                                          [$dNum1_s1jlw] \u []
                                                                              GHC.Num.fromInteger
                                                                                  $dNum1_s1jlw
                                                                                  GHC.Real.$fEnumRatio1;
                                                                    } in 
                                                                      GHC.Num.+
                                                                          $dNum1_s1jlw
                                                                          n_s1jln
                                                                          sat_s1jlz;
                                                                GHC.Types.True ->
                                                                    let {
                                                                      sat_s1jlA [Occ=Once]
                                                                        :: b_a1eBu
                                                                      [LclId] =
                                                                          [$dNum1_s1jlw] \u []
                                                                              GHC.Num.fromInteger
                                                                                  $dNum1_s1jlw
                                                                                  GHC.Real.$fEnumRatio1;
                                                                    } in 
                                                                      GHC.Num.-
                                                                          $dNum1_s1jlw
                                                                          n_s1jln
                                                                          sat_s1jlA;
                                                              };
                                                      };
                                                };
                                      } in 
                                        case GHC.Classes.== $dEq_s1jlc ds1_s1jli sat_s1jlB of {
                                          GHC.Types.False ->
                                              let {
                                                sat_s1jlD [Occ=Once] :: a_a1dNs
                                                [LclId] =
                                                    [$dNum_s1jld] \u []
                                                        GHC.Num.fromInteger
                                                            $dNum_s1jld GHC.Real.$fEnumRatio1;
                                              } in 
                                                case
                                                    GHC.Classes.== $dEq_s1jlc ds1_s1jli sat_s1jlD
                                                of
                                                { GHC.Types.False -> GHC.Real.$fRealFracRatio1;
                                                  GHC.Types.True -> m_s1jlu;
                                                };
                                          GHC.Types.True ->
                                              case GHC.Real.even eta_s1jl7 n_s1jln of {
                                                GHC.Types.False -> m_s1jlu;
                                                GHC.Types.True -> n_s1jln;
                                              };
                                        };
                                GHC.Types.True -> n_s1jln;
                              };
                      };
                };
          };

GHC.Real.integralEnumFrom
  :: forall a. (GHC.Real.Integral a, GHC.Enum.Bounded a) => a -> [a]
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,1*U(A,1*U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jlG $dBounded_s1jlH eta_s1jlI]
        let {
          f_s1jlJ [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
            :: GHC.Real.Real a_a1eoa
          [LclId] =
              [$dIntegral_s1jlG] \s []
                  GHC.Real.$p1Integral $dIntegral_s1jlG; } in
        let {
          f1_s1jlK [Occ=OnceL, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
            :: GHC.Num.Num a_a1eoa
          [LclId] =
              [f_s1jlJ] \u [] GHC.Real.$p1Real f_s1jlJ; } in
        let {
          sat_s1jlM [Occ=Once] :: a_a1eoa
          [LclId] =
              [$dBounded_s1jlH] \u [] GHC.Enum.maxBound $dBounded_s1jlH;
        } in 
          case
              GHC.Real.toInteger $dIntegral_s1jlG sat_s1jlM
          of
          lim_s1jlL [Dmd=<S,U>]
          { __DEFAULT ->
                let {
                  go_s1jlN [Occ=LoopBreaker] :: GHC.Integer.Type.Integer -> [a_a1eoa]
                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                      sat-only [f1_s1jlK lim_s1jlL go_s1jlN] \r [x_s1jlO]
                          case GHC.Integer.Type.gtInteger# x_s1jlO lim_s1jlL of {
                            __DEFAULT ->
                                let {
                                  sat_s1jlS [Occ=Once] :: [a_a1eoa]
                                  [LclId] =
                                      [go_s1jlN x_s1jlO] \u []
                                          case
                                              GHC.Integer.Type.plusInteger
                                                  x_s1jlO GHC.Real.$fEnumRatio1
                                          of
                                          sat_s1jlR
                                          { __DEFAULT -> go_s1jlN sat_s1jlR;
                                          }; } in
                                let {
                                  sat_s1jlQ [Occ=Once] :: a_a1eoa
                                  [LclId] =
                                      [f1_s1jlK x_s1jlO] \u [] GHC.Num.fromInteger f1_s1jlK x_s1jlO;
                                } in  : [sat_s1jlQ sat_s1jlS];
                            1# -> [] [];
                          };
                } in 
                  case GHC.Real.toInteger $dIntegral_s1jlG eta_s1jlI of sat_s1jlT {
                    __DEFAULT -> go_s1jlN sat_s1jlT;
                  };
          };

GHC.Real.integralEnumFromThen
  :: forall a.
     (GHC.Real.Integral a, GHC.Enum.Bounded a) =>
     a -> a -> [a]
[GblId,
 Arity=4,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,1*U(1*U,1*U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jlU $dBounded_s1jlV eta_s1jlW eta1_s1jlX]
        case
            GHC.Real.toInteger $dIntegral_s1jlU eta1_s1jlX
        of
        i_n2_s1jlY [Dmd=<S,U>]
        { __DEFAULT ->
              case
                  GHC.Real.toInteger $dIntegral_s1jlU eta_s1jlW
              of
              i_n1_s1jlZ [Dmd=<S,U>]
              { __DEFAULT ->
                    case GHC.Integer.Type.geInteger# i_n2_s1jlY i_n1_s1jlZ of {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.minusInteger i_n2_s1jlY i_n1_s1jlZ
                          of
                          delta_s1jm1 [Dmd=<S,U>]
                          { __DEFAULT ->
                                let {
                                  f_s1jm2 [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
                                    :: GHC.Real.Real a_a1enm
                                  [LclId] =
                                      [$dIntegral_s1jlU] \s []
                                          GHC.Real.$p1Integral $dIntegral_s1jlU; } in
                                let {
                                  f1_s1jm3 [Occ=OnceL*, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
                                    :: GHC.Num.Num a_a1enm
                                  [LclId] =
                                      [f_s1jm2] \u [] GHC.Real.$p1Real f_s1jm2;
                                } in 
                                  case GHC.Integer.Type.geInteger# delta_s1jm1 GHC.Real.even1 of {
                                    __DEFAULT ->
                                        let {
                                          sat_s1jm6 [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1jlV] \u []
                                                  GHC.Enum.minBound $dBounded_s1jlV;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1jlU sat_s1jm6
                                          of
                                          lim_s1jm5 [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1jm7 [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1jm1
                                                                f1_s1jm3
                                                                lim_s1jm5
                                                                go_s1jm7] \r [x_s1jm8]
                                                          case
                                                              GHC.Integer.Type.ltInteger#
                                                                  x_s1jm8 lim_s1jm5
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1jmc [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1jm1
                                                                       go_s1jm7
                                                                       x_s1jm8] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1jm8
                                                                                  delta_s1jm1
                                                                          of
                                                                          sat_s1jmb
                                                                          { __DEFAULT ->
                                                                                go_s1jm7 sat_s1jmb;
                                                                          }; } in
                                                                let {
                                                                  sat_s1jma [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1jm3 x_s1jm8] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1jm3 x_s1jm8;
                                                                } in  : [sat_s1jma sat_s1jmc];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1jm7 i_n1_s1jlZ;
                                          };
                                    1# ->
                                        let {
                                          sat_s1jme [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1jlV] \u []
                                                  GHC.Enum.minBound $dBounded_s1jlV;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1jlU sat_s1jme
                                          of
                                          lim_s1jmd [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1jmf [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1jm1
                                                                f1_s1jm3
                                                                lim_s1jmd
                                                                go_s1jmf] \r [x_s1jmg]
                                                          case
                                                              GHC.Integer.Type.gtInteger#
                                                                  x_s1jmg lim_s1jmd
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1jmk [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1jm1
                                                                       go_s1jmf
                                                                       x_s1jmg] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1jmg
                                                                                  delta_s1jm1
                                                                          of
                                                                          sat_s1jmj
                                                                          { __DEFAULT ->
                                                                                go_s1jmf sat_s1jmj;
                                                                          }; } in
                                                                let {
                                                                  sat_s1jmi [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1jm3 x_s1jmg] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1jm3 x_s1jmg;
                                                                } in  : [sat_s1jmi sat_s1jmk];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1jmf i_n1_s1jlZ;
                                          };
                                  };
                          };
                      1# ->
                          case
                              GHC.Integer.Type.minusInteger i_n2_s1jlY i_n1_s1jlZ
                          of
                          delta_s1jml [Dmd=<S,U>]
                          { __DEFAULT ->
                                let {
                                  f_s1jmm [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
                                    :: GHC.Real.Real a_a1enm
                                  [LclId] =
                                      [$dIntegral_s1jlU] \s []
                                          GHC.Real.$p1Integral $dIntegral_s1jlU; } in
                                let {
                                  f1_s1jmn [Occ=OnceL*, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
                                    :: GHC.Num.Num a_a1enm
                                  [LclId] =
                                      [f_s1jmm] \u [] GHC.Real.$p1Real f_s1jmm;
                                } in 
                                  case GHC.Integer.Type.geInteger# delta_s1jml GHC.Real.even1 of {
                                    __DEFAULT ->
                                        let {
                                          sat_s1jmq [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1jlV] \u []
                                                  GHC.Enum.maxBound $dBounded_s1jlV;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1jlU sat_s1jmq
                                          of
                                          lim_s1jmp [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1jmr [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1jml
                                                                f1_s1jmn
                                                                lim_s1jmp
                                                                go_s1jmr] \r [x_s1jms]
                                                          case
                                                              GHC.Integer.Type.ltInteger#
                                                                  x_s1jms lim_s1jmp
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1jmw [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1jml
                                                                       go_s1jmr
                                                                       x_s1jms] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1jms
                                                                                  delta_s1jml
                                                                          of
                                                                          sat_s1jmv
                                                                          { __DEFAULT ->
                                                                                go_s1jmr sat_s1jmv;
                                                                          }; } in
                                                                let {
                                                                  sat_s1jmu [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1jmn x_s1jms] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1jmn x_s1jms;
                                                                } in  : [sat_s1jmu sat_s1jmw];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1jmr i_n1_s1jlZ;
                                          };
                                    1# ->
                                        let {
                                          sat_s1jmy [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1jlV] \u []
                                                  GHC.Enum.maxBound $dBounded_s1jlV;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1jlU sat_s1jmy
                                          of
                                          lim_s1jmx [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1jmz [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1jml
                                                                f1_s1jmn
                                                                lim_s1jmx
                                                                go_s1jmz] \r [x_s1jmA]
                                                          case
                                                              GHC.Integer.Type.gtInteger#
                                                                  x_s1jmA lim_s1jmx
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1jmE [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1jml
                                                                       go_s1jmz
                                                                       x_s1jmA] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1jmA
                                                                                  delta_s1jml
                                                                          of
                                                                          sat_s1jmD
                                                                          { __DEFAULT ->
                                                                                go_s1jmz sat_s1jmD;
                                                                          }; } in
                                                                let {
                                                                  sat_s1jmC [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1jmn x_s1jmA] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1jmn x_s1jmA;
                                                                } in  : [sat_s1jmC sat_s1jmE];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1jmz i_n1_s1jlZ;
                                          };
                                  };
                          };
                    };
              };
        };

GHC.Real.integralEnumFromTo
  :: forall a. GHC.Real.Integral a => a -> a -> [a]
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jmF eta_s1jmG eta1_s1jmH]
        let {
          f_s1jmI [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
            :: GHC.Real.Real a_a1en9
          [LclId] =
              [$dIntegral_s1jmF] \s []
                  GHC.Real.$p1Integral $dIntegral_s1jmF; } in
        let {
          f1_s1jmJ [Occ=OnceL, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
            :: GHC.Num.Num a_a1en9
          [LclId] =
              [f_s1jmI] \u [] GHC.Real.$p1Real f_s1jmI;
        } in 
          case
              GHC.Real.toInteger $dIntegral_s1jmF eta1_s1jmH
          of
          lim_s1jmK [Dmd=<S,U>]
          { __DEFAULT ->
                let {
                  go_s1jmL [Occ=LoopBreaker] :: GHC.Integer.Type.Integer -> [a_a1en9]
                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                      sat-only [f1_s1jmJ lim_s1jmK go_s1jmL] \r [x_s1jmM]
                          case GHC.Integer.Type.gtInteger# x_s1jmM lim_s1jmK of {
                            __DEFAULT ->
                                let {
                                  sat_s1jmQ [Occ=Once] :: [a_a1en9]
                                  [LclId] =
                                      [go_s1jmL x_s1jmM] \u []
                                          case
                                              GHC.Integer.Type.plusInteger
                                                  x_s1jmM GHC.Real.$fEnumRatio1
                                          of
                                          sat_s1jmP
                                          { __DEFAULT -> go_s1jmL sat_s1jmP;
                                          }; } in
                                let {
                                  sat_s1jmO [Occ=Once] :: a_a1en9
                                  [LclId] =
                                      [f1_s1jmJ x_s1jmM] \u [] GHC.Num.fromInteger f1_s1jmJ x_s1jmM;
                                } in  : [sat_s1jmO sat_s1jmQ];
                            1# -> [] [];
                          };
                } in 
                  case GHC.Real.toInteger $dIntegral_s1jmF eta_s1jmG of sat_s1jmR {
                    __DEFAULT -> go_s1jmL sat_s1jmR;
                  };
          };

GHC.Real.integralEnumFromThenTo
  :: forall a. GHC.Real.Integral a => a -> a -> a -> [a]
[GblId,
 Arity=4,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jmS eta_s1jmT eta1_s1jmU eta2_s1jmV]
        case
            GHC.Real.toInteger $dIntegral_s1jmS eta_s1jmT
        of
        x_s1jmW [Dmd=<S,U>]
        { __DEFAULT ->
              case GHC.Real.toInteger $dIntegral_s1jmS eta1_s1jmU of sat_s1jmY {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.minusInteger sat_s1jmY x_s1jmW
                    of
                    delta_s1jmX [Dmd=<S,U>]
                    { __DEFAULT ->
                          let {
                            f_s1jmZ [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
                              :: GHC.Real.Real a_a1emS
                            [LclId] =
                                [$dIntegral_s1jmS] \s []
                                    GHC.Real.$p1Integral $dIntegral_s1jmS; } in
                          let {
                            f1_s1jn0 [Occ=OnceL*, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
                              :: GHC.Num.Num a_a1emS
                            [LclId] =
                                [f_s1jmZ] \u [] GHC.Real.$p1Real f_s1jmZ;
                          } in 
                            case GHC.Integer.Type.geInteger# delta_s1jmX GHC.Real.even1 of {
                              __DEFAULT ->
                                  case
                                      GHC.Real.toInteger $dIntegral_s1jmS eta2_s1jmV
                                  of
                                  lim_s1jn2 [Dmd=<S,U>]
                                  { __DEFAULT ->
                                        let {
                                          go_s1jn3 [Occ=LoopBreaker]
                                            :: GHC.Integer.Type.Integer -> [a_a1emS]
                                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                              sat-only [delta_s1jmX
                                                        f1_s1jn0
                                                        lim_s1jn2
                                                        go_s1jn3] \r [x1_s1jn4]
                                                  case
                                                      GHC.Integer.Type.ltInteger# x1_s1jn4 lim_s1jn2
                                                  of
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_s1jn8 [Occ=Once] :: [a_a1emS]
                                                          [LclId] =
                                                              [delta_s1jmX go_s1jn3 x1_s1jn4] \u []
                                                                  case
                                                                      GHC.Integer.Type.plusInteger
                                                                          x1_s1jn4 delta_s1jmX
                                                                  of
                                                                  sat_s1jn7
                                                                  { __DEFAULT -> go_s1jn3 sat_s1jn7;
                                                                  }; } in
                                                        let {
                                                          sat_s1jn6 [Occ=Once] :: a_a1emS
                                                          [LclId] =
                                                              [f1_s1jn0 x1_s1jn4] \u []
                                                                  GHC.Num.fromInteger
                                                                      f1_s1jn0 x1_s1jn4;
                                                        } in  : [sat_s1jn6 sat_s1jn8];
                                                    1# -> [] [];
                                                  };
                                        } in  go_s1jn3 x_s1jmW;
                                  };
                              1# ->
                                  case
                                      GHC.Real.toInteger $dIntegral_s1jmS eta2_s1jmV
                                  of
                                  lim_s1jn9 [Dmd=<S,U>]
                                  { __DEFAULT ->
                                        let {
                                          go_s1jna [Occ=LoopBreaker]
                                            :: GHC.Integer.Type.Integer -> [a_a1emS]
                                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                              sat-only [delta_s1jmX
                                                        f1_s1jn0
                                                        lim_s1jn9
                                                        go_s1jna] \r [x1_s1jnb]
                                                  case
                                                      GHC.Integer.Type.gtInteger# x1_s1jnb lim_s1jn9
                                                  of
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_s1jnf [Occ=Once] :: [a_a1emS]
                                                          [LclId] =
                                                              [delta_s1jmX go_s1jna x1_s1jnb] \u []
                                                                  case
                                                                      GHC.Integer.Type.plusInteger
                                                                          x1_s1jnb delta_s1jmX
                                                                  of
                                                                  sat_s1jne
                                                                  { __DEFAULT -> go_s1jna sat_s1jne;
                                                                  }; } in
                                                        let {
                                                          sat_s1jnd [Occ=Once] :: a_a1emS
                                                          [LclId] =
                                                              [f1_s1jn0 x1_s1jnb] \u []
                                                                  GHC.Num.fromInteger
                                                                      f1_s1jn0 x1_s1jnb;
                                                        } in  : [sat_s1jnd sat_s1jnf];
                                                    1# -> [] [];
                                                  };
                                        } in  go_s1jna x_s1jmW;
                                  };
                            };
                    };
              };
        };

GHC.Real.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Real.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$trModule4];

GHC.Real.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Real"#;

GHC.Real.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$trModule2];

GHC.Real.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Real.$trModule3
                                     GHC.Real.$trModule1];

$krep_r1j3d :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Integer.Type.$tcInteger
                                              GHC.Types.[]];

$krep1_r1j3e :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.Real.$tcFractional1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*
                                         $krep1_r1j3e];

$krep2_r1j3f :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep3_r1j3g :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep2_r1j3f];

$krep4_r1j3h :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep3_r1j3g];

$krep5_r1j3i :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep_r1j3d];

$krep6_r1j3j :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_r1j3f GHC.Types.[]];

$krep7_r1j3k :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_r1j3f $krep6_r1j3j];

$krep8_r1j3l :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc(,)
                                              $krep7_r1j3k];

$krep9_r1j3m :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep8_r1j3l];

$krep10_r1j3n :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep9_r1j3m];

$krep11_r1j3o :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Num.$tcNum
                                              $krep6_r1j3j];

$krep12_r1j3p :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Enum.$tcEnum
                                              $krep6_r1j3j];

$krep13_r1j3q :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Classes.$tcOrd
                                              $krep6_r1j3j];

GHC.Real.$tcRatio2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Ratio"#;

GHC.Real.$tcRatio1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcRatio2];

GHC.Real.$tcRatio :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17658523810845794968##
                                    1271393732863050253##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcRatio1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep14_r1j3r :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcRatio
                                              $krep6_r1j3j];

$krep15_r1j3s :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep14_r1j3r];

GHC.Real.$tc':%1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep15_r1j3s];

GHC.Real.$tc':%3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "':%"#;

GHC.Real.$tc':%2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc':%3];

GHC.Real.$tc':% :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11952989868638128372##
                                    6861245286732044789##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc':%2
                                    1#
                                    GHC.Real.$tc':%1];

$krep16_r1j3t :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r1j3d GHC.Types.[]];

$krep17_r1j3u :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcRatio
                                              $krep16_r1j3t];

$krep18_r1j3v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep17_r1j3u];

$krep19_r1j3w :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep17_r1j3u $krep2_r1j3f];

GHC.Real.$tcReal2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Real"#;

GHC.Real.$tcReal1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcReal2];

GHC.Real.$tcReal :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1826502536394630182##
                                    14487785779892251413##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcReal1
                                    0#
                                    GHC.Real.$tcFractional1];

$krep20_r1j3x :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcReal
                                              $krep6_r1j3j];

$krep21_r1j3y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep18_r1j3v $krep20_r1j3x];

$krep22_r1j3z :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep13_r1j3q $krep21_r1j3y];

GHC.Real.$tc'C:Real1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1j3o $krep22_r1j3z];

GHC.Real.$tc'C:Real3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Real"#;

GHC.Real.$tc'C:Real2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc'C:Real3];

GHC.Real.$tc'C:Real :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5938283050841830427##
                                    8926187074226767634##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc'C:Real2
                                    1#
                                    GHC.Real.$tc'C:Real1];

GHC.Real.$tcIntegral2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Integral"#;

GHC.Real.$tcIntegral1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcIntegral2];

GHC.Real.$tcIntegral :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16601157811546713973##
                                    3304955164956033666##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcIntegral1
                                    0#
                                    GHC.Real.$tcFractional1];

$krep23_r1j3A :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcIntegral
                                              $krep6_r1j3j];

$krep24_r1j3B :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r1j3i $krep23_r1j3A];

$krep25_r1j3C :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_r1j3n $krep24_r1j3B];

$krep26_r1j3D :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_r1j3n $krep25_r1j3C];

$krep27_r1j3E :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep26_r1j3D];

$krep28_r1j3F :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep27_r1j3E];

$krep29_r1j3G :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep28_r1j3F];

$krep30_r1j3H :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep29_r1j3G];

$krep31_r1j3I :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep12_r1j3p $krep30_r1j3H];

GHC.Real.$tc'C:Integral1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep20_r1j3x $krep31_r1j3I];

GHC.Real.$tc'C:Integral3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Integral"#;

GHC.Real.$tc'C:Integral2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc'C:Integral3];

GHC.Real.$tc'C:Integral :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12141017740256829283##
                                    17564033539811245778##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc'C:Integral2
                                    1#
                                    GHC.Real.$tc'C:Integral1];

GHC.Real.$tcFractional3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Fractional"#;

GHC.Real.$tcFractional2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcFractional3];

GHC.Real.$tcFractional :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14968870971062750857##
                                    13774835939651899219##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcFractional2
                                    0#
                                    GHC.Real.$tcFractional1];

$krep32_r1j3J :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcFractional
                                              $krep6_r1j3j];

$krep33_r1j3K :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep19_r1j3w $krep32_r1j3J];

$krep34_r1j3L :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r1j3g $krep33_r1j3K];

$krep35_r1j3M :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep34_r1j3L];

GHC.Real.$tc'C:Fractional1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1j3o $krep35_r1j3M];

GHC.Real.$tc'C:Fractional3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Fractional"#;

GHC.Real.$tc'C:Fractional2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc'C:Fractional3];

GHC.Real.$tc'C:Fractional :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15706435530565718930##
                                    11021884564355505453##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc'C:Fractional2
                                    1#
                                    GHC.Real.$tc'C:Fractional1];

GHC.Real.$tcRealFrac2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "RealFrac"#;

GHC.Real.$tcRealFrac1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcRealFrac2];

GHC.Real.$tcRealFrac :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2318913099678420819##
                                    6373121509494083706##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcRealFrac1
                                    0#
                                    GHC.Real.$tcFractional1];

GHC.Real.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     a -> a -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jng ww_s1jnh ww1_s1jni ww2_s1jnj ww3_s1jnk]
        case
            GHC.Real.$p1Integral w_s1jng
        of
        $dReal_s1jnl [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jnm [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
                  :: GHC.Num.Num a_s1hBR
                [LclId] =
                    [$dReal_s1jnl] \u [] GHC.Real.$p1Real $dReal_s1jnl; } in
              let {
                sat_s1jnp [Occ=Once] :: a_s1hBR
                [LclId] =
                    [ww1_s1jni ww2_s1jnj $dNum_s1jnm] \u []
                        GHC.Num.* $dNum_s1jnm ww2_s1jnj ww1_s1jni; } in
              let {
                sat_s1jno [Occ=Once] :: a_s1hBR
                [LclId] =
                    [ww_s1jnh ww3_s1jnk $dNum_s1jnm] \u []
                        GHC.Num.* $dNum_s1jnm ww_s1jnh ww3_s1jnk;
              } in 
                case GHC.Real.$p2Real $dReal_s1jnl of sat_s1jnn {
                  __DEFAULT -> GHC.Classes.< sat_s1jnn sat_s1jno sat_s1jnp;
                };
        };

GHC.Real.$fOrdRatio_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jnq w1_s1jnr w2_s1jns]
        case w1_s1jnr of {
          GHC.Real.:% ww1_s1jnu [Occ=Once] ww2_s1jnv [Occ=Once] ->
              case w2_s1jns of {
                GHC.Real.:% ww4_s1jnx [Occ=Once] ww5_s1jny [Occ=Once] ->
                    GHC.Real.$w$c< w_s1jnq ww1_s1jnu ww2_s1jnv ww4_s1jnx ww5_s1jny;
              };
        };

GHC.Real.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     a -> a -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jnz ww_s1jnA ww1_s1jnB ww2_s1jnC ww3_s1jnD]
        case
            GHC.Real.$p1Integral w_s1jnz
        of
        $dReal_s1jnE [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jnF [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
                  :: GHC.Num.Num a_s1hC6
                [LclId] =
                    [$dReal_s1jnE] \u [] GHC.Real.$p1Real $dReal_s1jnE; } in
              let {
                sat_s1jnI [Occ=Once] :: a_s1hC6
                [LclId] =
                    [ww1_s1jnB ww2_s1jnC $dNum_s1jnF] \u []
                        GHC.Num.* $dNum_s1jnF ww2_s1jnC ww1_s1jnB; } in
              let {
                sat_s1jnH [Occ=Once] :: a_s1hC6
                [LclId] =
                    [ww_s1jnA ww3_s1jnD $dNum_s1jnF] \u []
                        GHC.Num.* $dNum_s1jnF ww_s1jnA ww3_s1jnD;
              } in 
                case GHC.Real.$p2Real $dReal_s1jnE of sat_s1jnG {
                  __DEFAULT -> GHC.Classes.<= sat_s1jnG sat_s1jnH sat_s1jnI;
                };
        };

GHC.Real.$fOrdRatio_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jnJ w1_s1jnK w2_s1jnL]
        case w1_s1jnK of {
          GHC.Real.:% ww1_s1jnN [Occ=Once] ww2_s1jnO [Occ=Once] ->
              case w2_s1jnL of {
                GHC.Real.:% ww4_s1jnQ [Occ=Once] ww5_s1jnR [Occ=Once] ->
                    GHC.Real.$w$c<= w_s1jnJ ww1_s1jnN ww2_s1jnO ww4_s1jnQ ww5_s1jnR;
              };
        };

GHC.Real.$fOrdRatio_$cmax
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jnS x_s1jnT y_s1jnU]
        case x_s1jnT of ww_s1jnV {
          GHC.Real.:% ww1_s1jnW [Occ=Once] ww2_s1jnX [Occ=Once] ->
              case y_s1jnU of ww3_s1jnY {
                GHC.Real.:% ww4_s1jnZ [Occ=Once] ww5_s1jo0 [Occ=Once] ->
                    case
                        GHC.Real.$w$c<=
                            $dIntegral_s1jnS ww1_s1jnW ww2_s1jnX ww4_s1jnZ ww5_s1jo0
                    of
                    { GHC.Types.False -> ww_s1jnV;
                      GHC.Types.True -> ww3_s1jnY;
                    };
              };
        };

GHC.Real.$fOrdRatio_$cmin
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jo2 x_s1jo3 y_s1jo4]
        case x_s1jo3 of ww_s1jo5 {
          GHC.Real.:% ww1_s1jo6 [Occ=Once] ww2_s1jo7 [Occ=Once] ->
              case y_s1jo4 of ww3_s1jo8 {
                GHC.Real.:% ww4_s1jo9 [Occ=Once] ww5_s1joa [Occ=Once] ->
                    case
                        GHC.Real.$w$c<=
                            $dIntegral_s1jo2 ww1_s1jo6 ww2_s1jo7 ww4_s1jo9 ww5_s1joa
                    of
                    { GHC.Types.False -> ww3_s1jo8;
                      GHC.Types.True -> ww_s1jo5;
                    };
              };
        };

GHC.Real.$w$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     a -> a -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(1*U(A,A,C(C1(U)),A,A,A,A),U(1*U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1joc ww_s1jod ww1_s1joe ww2_s1jof ww3_s1jog]
        case
            GHC.Real.$p1Integral w_s1joc
        of
        $dEq_s1joh [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p2Real $dEq_s1joh
              of
              $dEq1_s1joi [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Classes.$p1Ord $dEq1_s1joi
                    of
                    $dEq2_s1joj [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                    { __DEFAULT ->
                          case GHC.Classes.== $dEq2_s1joj ww_s1jod ww2_s1jof of {
                            GHC.Types.False ->
                                case
                                    GHC.Real.$w$c<= w_s1joc ww_s1jod ww1_s1joe ww2_s1jof ww3_s1jog
                                of
                                { GHC.Types.False -> GHC.Types.GT [];
                                  GHC.Types.True -> GHC.Types.LT [];
                                };
                            GHC.Types.True ->
                                case GHC.Classes.== $dEq2_s1joj ww1_s1joe ww3_s1jog of {
                                  GHC.Types.False ->
                                      case
                                          GHC.Real.$w$c<=
                                              w_s1joc ww_s1jod ww1_s1joe ww2_s1jof ww3_s1jog
                                      of
                                      { GHC.Types.False -> GHC.Types.GT [];
                                        GHC.Types.True -> GHC.Types.LT [];
                                      };
                                  GHC.Types.True -> GHC.Types.EQ [];
                                };
                          };
                    };
              };
        };

GHC.Real.$fOrdRatio_$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1joo w1_s1jop w2_s1joq]
        case w1_s1jop of {
          GHC.Real.:% ww1_s1jos [Occ=Once] ww2_s1jot [Occ=Once] ->
              case w2_s1joq of {
                GHC.Real.:% ww4_s1jov [Occ=Once] ww5_s1jow [Occ=Once] ->
                    GHC.Real.$w$ccompare
                        w_s1joo ww1_s1jos ww2_s1jot ww4_s1jov ww5_s1jow;
              };
        };

GHC.Real.$fOrdRatio_$c>
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jox x_s1joy y_s1joz]
        case x_s1joy of {
          GHC.Real.:% ww1_s1joB [Occ=Once] ww2_s1joC [Occ=Once] ->
              case y_s1joz of {
                GHC.Real.:% ww4_s1joE [Occ=Once] ww5_s1joF [Occ=Once] ->
                    case
                        GHC.Real.$w$ccompare
                            $dIntegral_s1jox ww1_s1joB ww2_s1joC ww4_s1joE ww5_s1joF
                    of
                    { __DEFAULT -> GHC.Types.False [];
                      GHC.Types.GT -> GHC.Types.True [];
                    };
              };
        };

GHC.Real.$fOrdRatio_$c>=
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1joH x_s1joI y_s1joJ]
        case x_s1joI of {
          GHC.Real.:% ww1_s1joL [Occ=Once] ww2_s1joM [Occ=Once] ->
              case y_s1joJ of {
                GHC.Real.:% ww4_s1joO [Occ=Once] ww5_s1joP [Occ=Once] ->
                    case
                        GHC.Real.$w$ccompare
                            $dIntegral_s1joH ww1_s1joL ww2_s1joM ww4_s1joO ww5_s1joP
                    of
                    { __DEFAULT -> GHC.Types.True [];
                      GHC.Types.LT -> GHC.Types.False [];
                    };
              };
        };

GHC.Real.$fOrdRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Classes.Ord (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>m] =
    [] \r [$dIntegral_s1joR]
        let {
          sat_s1joZ [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Real.Ratio a_a1eJ2
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$cmin $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joY [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Real.Ratio a_a1eJ2
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$cmax $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joX [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c>= $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joW [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c> $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joV [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c<= $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joU [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c< $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joT [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Ordering
          [LclId] =
              [$dIntegral_s1joR] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$ccompare $dIntegral_s1joR eta_B2 eta_B1; } in
        let {
          sat_s1joS [Occ=Once] :: GHC.Classes.Eq (GHC.Real.Ratio a_a1eJ2)
          [LclId] =
              [$dIntegral_s1joR] \u []
                  GHC.Real.$fOrdRatio_$cp1Ord $dIntegral_s1joR;
        } in 
          GHC.Classes.C:Ord [sat_s1joS
                             sat_s1joT
                             sat_s1joU
                             sat_s1joV
                             sat_s1joW
                             sat_s1joX
                             sat_s1joY
                             sat_s1joZ];

GHC.Real.$fNumRatio_$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LLLC(S)LLL)LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,1*C1(U),A,A,A),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jp0 w1_s1jp1]
        case w1_s1jp1 of {
          GHC.Real.:% ww1_s1jp3 [Occ=Once] ww2_s1jp4 [Occ=Once] ->
              case GHC.Real.$p1Integral w_s1jp0 of sat_s1jp5 {
                __DEFAULT ->
                    case GHC.Real.$p1Real sat_s1jp5 of sat_s1jp6 {
                      __DEFAULT ->
                          case GHC.Num.negate sat_s1jp6 ww1_s1jp3 of dt_s1jp7 {
                            __DEFAULT -> GHC.Real.:% [dt_s1jp7 ww2_s1jp4];
                          };
                    };
              };
        };

GHC.Real.$fNumRatio_$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LLLLC(S)LL)LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,1*C1(U),A,A),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jp8 w1_s1jp9]
        case w1_s1jp9 of {
          GHC.Real.:% ww1_s1jpb [Occ=Once] ww2_s1jpc [Occ=Once] ->
              case GHC.Real.$p1Integral w_s1jp8 of sat_s1jpd {
                __DEFAULT ->
                    case GHC.Real.$p1Real sat_s1jpd of sat_s1jpe {
                      __DEFAULT ->
                          case GHC.Num.abs sat_s1jpe ww1_s1jpb of dt_s1jpf {
                            __DEFAULT -> GHC.Real.:% [dt_s1jpf ww2_s1jpc];
                          };
                    };
              };
        };

GHC.Real.$w$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLC(S)C(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jpg ww_s1jph]
        case
            GHC.Real.$p1Integral w_s1jpg
        of
        $dReal_s1jpi [Dmd=<S(S(LLLLLC(S)C(S))LL),1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1jpi
              of
              $dNum_s1jpj [Dmd=<S(LLLLLC(S)C(S)),U(A,A,A,A,A,1*C1(U),1*C1(U))>]
              { __DEFAULT ->
                    case GHC.Num.signum $dNum_s1jpj ww_s1jph of dt_s1jpk {
                      __DEFAULT ->
                          case
                              GHC.Num.fromInteger $dNum_s1jpj GHC.Real.$fEnumRatio1
                          of
                          dt1_s1jpl
                          { __DEFAULT -> (#,#) [dt_s1jpk dt1_s1jpl];
                          };
                    };
              };
        };

GHC.Real.$fNumRatio_$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLC(S)C(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SL),1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jpm w1_s1jpn]
        case w1_s1jpn of {
          GHC.Real.:% ww1_s1jpp [Occ=Once] _ [Occ=Dead] ->
              case GHC.Real.$w$csignum w_s1jpm ww1_s1jpp of {
                (#,#) ww4_s1jps [Occ=Once] ww5_s1jpt [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jps ww5_s1jpt];
              };
        };

GHC.Real.$w$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jpu w1_s1jpv]
        case
            GHC.Real.$p1Integral w_s1jpu
        of
        $dReal_s1jpw [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1jpw
              of
              $dNum_s1jpx [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
              { __DEFAULT ->
                    case GHC.Num.fromInteger $dNum_s1jpx w1_s1jpv of dt_s1jpy {
                      __DEFAULT ->
                          case
                              GHC.Num.fromInteger $dNum_s1jpx GHC.Real.$fEnumRatio1
                          of
                          dt1_s1jpz
                          { __DEFAULT -> (#,#) [dt_s1jpy dt1_s1jpz];
                          };
                    };
              };
        };

GHC.Real.$fNumRatio_$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1jpA w1_s1jpB]
        case GHC.Real.$w$cfromInteger w_s1jpA w1_s1jpB of {
          (#,#) ww1_s1jpD [Occ=Once] ww2_s1jpE [Occ=Once] ->
              GHC.Real.:% [ww1_s1jpD ww2_s1jpE];
        };

GHC.Real.$fRealRatio_$s$ctoRational
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Real.Rational
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1jpF] ds_s1jpF;

GHC.Real.$fRealRatio_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Rational
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)),U(A,A,A,A,A,A,A,A,C(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jpG w1_s1jpH]
        case w1_s1jpH of {
          GHC.Real.:% ww1_s1jpJ [Occ=Once] ww2_s1jpK [Occ=Once] ->
              case GHC.Real.toInteger w_s1jpG ww1_s1jpJ of dt_s1jpL {
                __DEFAULT ->
                    case GHC.Real.toInteger w_s1jpG ww2_s1jpK of dt1_s1jpM {
                      __DEFAULT -> GHC.Real.:% [dt_s1jpL dt1_s1jpM];
                    };
              };
        };

GHC.Real.$w$crecip [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jpN ww_s1jpO ww1_s1jpP]
        case
            GHC.Real.$p1Integral w_s1jpN
        of
        $dReal_s1jpQ [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jpR [Dmd=<L,U(A,A,A,C(U),A,A,C(U))>] :: GHC.Num.Num a_s1hDt
                [LclId] =
                    [$dReal_s1jpQ] \u [] GHC.Real.$p1Real $dReal_s1jpQ;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1jpQ
                of
                $dOrd_s1jpS [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1jpU [Occ=Once] :: a_s1hDt
                        [LclId] =
                            [$dNum_s1jpR] \u [] GHC.Num.fromInteger $dNum_s1jpR GHC.Real.even1;
                      } in 
                        case GHC.Classes.$p1Ord $dOrd_s1jpS of sat_s1jpT {
                          __DEFAULT ->
                              case GHC.Classes.== sat_s1jpT ww_s1jpO sat_s1jpU of {
                                GHC.Types.False ->
                                    let {
                                      sat_s1jpW [Occ=Once] :: a_s1hDt
                                      [LclId] =
                                          [$dNum_s1jpR] \u []
                                              GHC.Num.fromInteger $dNum_s1jpR GHC.Real.even1;
                                    } in 
                                      case GHC.Classes.< $dOrd_s1jpS ww_s1jpO sat_s1jpW of {
                                        GHC.Types.False -> (#,#) [ww1_s1jpP ww_s1jpO];
                                        GHC.Types.True ->
                                            case GHC.Num.negate $dNum_s1jpR ww1_s1jpP of dt_s1jpY {
                                              __DEFAULT ->
                                                  case
                                                      GHC.Num.negate $dNum_s1jpR ww_s1jpO
                                                  of
                                                  dt1_s1jpZ
                                                  { __DEFAULT -> (#,#) [dt_s1jpY dt1_s1jpZ];
                                                  };
                                            };
                                      };
                                GHC.Types.True -> GHC.Real.ratioZeroDenominatorError;
                              };
                        };
                };
        };

GHC.Real.$fFractionalRatio_$crecip [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jq1 w1_s1jq2]
        case w1_s1jq2 of {
          GHC.Real.:% ww1_s1jq4 [Occ=Once] ww2_s1jq5 [Occ=Once] ->
              case GHC.Real.$w$crecip w_s1jq1 ww1_s1jq4 ww2_s1jq5 of {
                (#,#) ww4_s1jq7 [Occ=Once] ww5_s1jq8 [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jq7 ww5_s1jq8];
              };
        };

GHC.Real.$w$s$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# b, GHC.Real.Ratio GHC.Integer.Type.Integer #)
[GblId,
 Arity=3,
 Str=<L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jq9 ww_s1jqa ww1_s1jqb]
        let {
          ds_s1jqc [Dmd=<L,U(1*U,1*U)>]
            :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
          [LclId] =
              [ww_s1jqa ww1_s1jqb] \u []
                  case GHC.Integer.Type.eqInteger# ww1_s1jqb GHC.Real.even1 of {
                    __DEFAULT ->
                        case GHC.Integer.Type.quotRemInteger ww_s1jqa ww1_s1jqb of {
                          (#,#) ipv_s1jqf [Occ=Once] ipv1_s1jqg [Occ=Once] ->
                              (,) [ipv_s1jqf ipv1_s1jqg];
                        };
                    1# -> GHC.Real.divZeroError;
                  }; } in
        let {
          sat_s1jqs [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId] =
              [ww1_s1jqb ds_s1jqc] \u []
                  case ds_s1jqc of {
                    (,) _ [Occ=Dead] r_s1jqq [Occ=Once] ->
                        case r_s1jqq of dt_s1jqr {
                          __DEFAULT -> GHC.Real.:% [dt_s1jqr ww1_s1jqb];
                        };
                  }; } in
        let {
          sat_s1jqn [Occ=Once] :: b_s1hDF
          [LclId] =
              [w_s1jq9 ds_s1jqc] \u []
                  let {
                    sat_s1jqm [Occ=Once] :: GHC.Integer.Type.Integer
                    [LclId] =
                        [ds_s1jqc] \u []
                            case ds_s1jqc of {
                              (,) q_s1jqk [Occ=Once] _ [Occ=Dead] -> q_s1jqk;
                            };
                  } in 
                    case GHC.Real.$p1Integral w_s1jq9 of sat_s1jqh {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_s1jqh of sat_s1jqi {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1jqi sat_s1jqm;
                          };
                    };
        } in  (#,#) [sat_s1jqn sat_s1jqs];

GHC.Real.$fEnumRatio_$s$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer
     -> (b, GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jqt w1_s1jqu]
        case w1_s1jqu of {
          GHC.Real.:% ww1_s1jqw [Occ=Once] ww2_s1jqx [Occ=Once] ->
              case GHC.Real.$w$s$cproperFraction w_s1jqt ww1_s1jqw ww2_s1jqx of {
                (#,#) ww4_s1jqz [Occ=Once] ww5_s1jqA [Occ=Once] ->
                    (,) [ww4_s1jqz ww5_s1jqA];
              };
        };

GHC.Real.$w$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b.
     GHC.Real.Integral b =>
     a -> a -> (# b, GHC.Real.Ratio a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,1*C1(C1(U(1*U,1*U))),A,1*C1(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jqB w1_s1jqC ww_s1jqD ww1_s1jqE]
        let {
          ds_s1jqF [Dmd=<L,U(1*U,1*U)>] :: (a_s1hDR, a_s1hDR)
          [LclId] =
              [w_s1jqB ww_s1jqD ww1_s1jqE] \u []
                  GHC.Real.quotRem w_s1jqB ww_s1jqD ww1_s1jqE; } in
        let {
          sat_s1jqS [Occ=Once] :: GHC.Real.Ratio a_s1hDR
          [LclId] =
              [ww1_s1jqE ds_s1jqF] \u []
                  case ds_s1jqF of {
                    (,) _ [Occ=Dead] r_s1jqQ [Occ=Once] ->
                        case r_s1jqQ of dt_s1jqR {
                          __DEFAULT -> GHC.Real.:% [dt_s1jqR ww1_s1jqE];
                        };
                  }; } in
        let {
          sat_s1jqN [Occ=Once] :: b_s1hDT
          [LclId] =
              [w_s1jqB w1_s1jqC ds_s1jqF] \u []
                  let {
                    sat_s1jqM [Occ=Once] :: GHC.Integer.Type.Integer
                    [LclId] =
                        [w_s1jqB ds_s1jqF] \u []
                            let {
                              sat_s1jqL [Occ=Once] :: a_s1hDR
                              [LclId] =
                                  [ds_s1jqF] \u []
                                      case ds_s1jqF of {
                                        (,) q_s1jqJ [Occ=Once] _ [Occ=Dead] -> q_s1jqJ;
                                      };
                            } in  GHC.Real.toInteger w_s1jqB sat_s1jqL;
                  } in 
                    case GHC.Real.$p1Integral w1_s1jqC of sat_s1jqG {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_s1jqG of sat_s1jqH {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1jqH sat_s1jqM;
                          };
                    };
        } in  (#,#) [sat_s1jqN sat_s1jqS];

GHC.Real.$fEnumRatio_$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio a -> (b, GHC.Real.Ratio a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jqT w1_s1jqU w2_s1jqV]
        case w2_s1jqV of {
          GHC.Real.:% ww1_s1jqX [Occ=Once] ww2_s1jqY [Occ=Once] ->
              case
                  GHC.Real.$w$cproperFraction w_s1jqT w1_s1jqU ww1_s1jqX ww2_s1jqY
              of
              { (#,#) ww4_s1jr0 [Occ=Once] ww5_s1jr1 [Occ=Once] ->
                    (,) [ww4_s1jr0 ww5_s1jr1];
              };
        };

GHC.Real.$wreduce [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,A,A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jr2 w1_s1jr3 w2_s1jr4]
        case
            GHC.Real.$p1Integral w_s1jr2
        of
        $dReal_s1jr5 [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s1jr9 [Occ=Once] :: a_s1hE5
                [LclId] =
                    [$dReal_s1jr5] \u []
                        case GHC.Real.$p1Real $dReal_s1jr5 of sat_s1jr8 {
                          __DEFAULT -> GHC.Num.fromInteger sat_s1jr8 GHC.Real.even1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s1jr5 of sat_s1jr6 {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_s1jr6 of sat_s1jr7 {
                        __DEFAULT ->
                            case GHC.Classes.== sat_s1jr7 w2_s1jr4 sat_s1jr9 of {
                              GHC.Types.False ->
                                  let {
                                    d_s1jrb :: a_s1hE5
                                    [LclId] =
                                        [w_s1jr2 w1_s1jr3 w2_s1jr4] \u []
                                            GHC.Real.gcd w_s1jr2 w1_s1jr3 w2_s1jr4;
                                  } in 
                                    case GHC.Real.quot w_s1jr2 w1_s1jr3 d_s1jrb of dt_s1jrc {
                                      __DEFAULT ->
                                          case GHC.Real.quot w_s1jr2 w2_s1jr4 d_s1jrb of dt1_s1jrd {
                                            __DEFAULT -> (#,#) [dt_s1jrc dt1_s1jrd];
                                          };
                                    };
                              GHC.Types.True -> GHC.Real.ratioZeroDenominatorError;
                            };
                      };
                };
        };

GHC.Real.reduce [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,A,A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1jrf w1_s1jrg w2_s1jrh]
        case GHC.Real.$wreduce w_s1jrf w1_s1jrg w2_s1jrh of {
          (#,#) ww1_s1jrj [Occ=Once] ww2_s1jrk [Occ=Once] ->
              GHC.Real.:% [ww1_s1jrj ww2_s1jrk];
        };

GHC.Real.%_$s% [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>m, Unf=OtherCon []] =
    [] \r [w_s1jrl w1_s1jrm]
        case GHC.Real.$w$s$cfromRational w_s1jrl w1_s1jrm of {
          (#,#) ww1_s1jro [Occ=Once] ww2_s1jrp [Occ=Once] ->
              GHC.Real.:% [ww1_s1jro ww2_s1jrp];
        };

GHC.Real.$w% [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,1*C1(C1(U)),A,C(U),1*C1(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jrq w1_s1jrr w2_s1jrs]
        let {
          $dReal_s1jrt [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,A,1*C1(C1(U)),A,1*C1(U),1*C1(U),A),A,A)>]
            :: GHC.Real.Real a_s1hEj
          [LclId] =
              [w_s1jrq] \s [] GHC.Real.$p1Integral w_s1jrq; } in
        let {
          $dNum_s1jru [Dmd=<L,U(A,A,1*C1(C1(U)),A,1*C1(U),1*C1(U),A)>]
            :: GHC.Num.Num a_s1hEj
          [LclId] =
              [$dReal_s1jrt] \u [] GHC.Real.$p1Real $dReal_s1jrt; } in
        let {
          sat_s1jrx [Occ=Once] :: a_s1hEj
          [LclId] =
              [w2_s1jrs $dNum_s1jru] \u [] GHC.Num.abs $dNum_s1jru w2_s1jrs; } in
        let {
          sat_s1jrw [Occ=Once] :: a_s1hEj
          [LclId] =
              [w1_s1jrr w2_s1jrs $dNum_s1jru] \u []
                  let {
                    sat_s1jrv [Occ=Once] :: a_s1hEj
                    [LclId] =
                        [w2_s1jrs $dNum_s1jru] \u [] GHC.Num.signum $dNum_s1jru w2_s1jrs;
                  } in  GHC.Num.* $dNum_s1jru w1_s1jrr sat_s1jrv;
        } in  GHC.Real.$wreduce w_s1jrq sat_s1jrw sat_s1jrx;

GHC.Real.% [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1jry w1_s1jrz w2_s1jrA]
        case GHC.Real.$w% w_s1jry w1_s1jrz w2_s1jrA of {
          (#,#) ww1_s1jrC [Occ=Once] ww2_s1jrD [Occ=Once] ->
              GHC.Real.:% [ww1_s1jrC ww2_s1jrD];
        };

GHC.Real.$w$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jrE ww_s1jrF ww1_s1jrG ww2_s1jrH ww3_s1jrI]
        let {
          $dReal_s1jrJ [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hEr
          [LclId] =
              [w_s1jrE] \s [] GHC.Real.$p1Integral w_s1jrE; } in
        let {
          $dNum_s1jrK [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hEr
          [LclId] =
              [$dReal_s1jrJ] \u [] GHC.Real.$p1Real $dReal_s1jrJ; } in
        let {
          sat_s1jrM [Occ=Once] :: a_s1hEr
          [LclId] =
              [ww1_s1jrG ww2_s1jrH $dNum_s1jrK] \u []
                  GHC.Num.* $dNum_s1jrK ww1_s1jrG ww2_s1jrH; } in
        let {
          sat_s1jrL [Occ=Once] :: a_s1hEr
          [LclId] =
              [ww_s1jrF ww3_s1jrI $dNum_s1jrK] \u []
                  GHC.Num.* $dNum_s1jrK ww_s1jrF ww3_s1jrI;
        } in  GHC.Real.$w% w_s1jrE sat_s1jrL sat_s1jrM;

GHC.Real.$fFractionalRatio_$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jrN w1_s1jrO w2_s1jrP]
        case w1_s1jrO of {
          GHC.Real.:% ww1_s1jrR [Occ=Once] ww2_s1jrS [Occ=Once] ->
              case w2_s1jrP of {
                GHC.Real.:% ww4_s1jrU [Occ=Once] ww5_s1jrV [Occ=Once] ->
                    case
                        GHC.Real.$w$c/ w_s1jrN ww1_s1jrR ww2_s1jrS ww4_s1jrU ww5_s1jrV
                    of
                    { (#,#) ww7_s1jrX [Occ=Once] ww8_s1jrY [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jrX ww8_s1jrY];
                    };
              };
        };

GHC.Real.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jrZ ww_s1js0 ww1_s1js1]
        let {
          $dReal_s1js2 [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
            :: GHC.Real.Real a_s1hEJ
          [LclId] =
              [w_s1jrZ] \s [] GHC.Real.$p1Integral w_s1jrZ; } in
        let {
          $dNum_s1js3 [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_s1hEJ
          [LclId] =
              [$dReal_s1js2] \u [] GHC.Real.$p1Real $dReal_s1js2; } in
        let {
          sat_s1js5 [Occ=Once] :: a_s1hEJ
          [LclId] =
              [ww1_s1js1 $dNum_s1js3] \u []
                  GHC.Num.fromInteger $dNum_s1js3 ww1_s1js1; } in
        let {
          sat_s1js4 [Occ=Once] :: a_s1hEJ
          [LclId] =
              [ww_s1js0 $dNum_s1js3] \u []
                  GHC.Num.fromInteger $dNum_s1js3 ww_s1js0;
        } in  GHC.Real.$w% w_s1jrZ sat_s1js4 sat_s1js5;

GHC.Real.$fFractionalRatio_$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Rational -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1js6 w1_s1js7]
        case w1_s1js7 of {
          GHC.Real.:% ww1_s1js9 [Occ=Once] ww2_s1jsa [Occ=Once] ->
              case GHC.Real.$w$cfromRational w_s1js6 ww1_s1js9 ww2_s1jsa of {
                (#,#) ww4_s1jsc [Occ=Once] ww5_s1jsd [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jsc ww5_s1jsd];
              };
        };

GHC.Real.$w$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(1*C1(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jse ww_s1jsf ww1_s1jsg ww2_s1jsh ww3_s1jsi]
        let {
          $dReal_s1jsj [Occ=OnceL,
                        Dmd=<L,1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hEV
          [LclId] =
              [w_s1jse] \s [] GHC.Real.$p1Integral w_s1jse; } in
        let {
          $dNum_s1jsk [Dmd=<L,U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hEV
          [LclId] =
              [$dReal_s1jsj] \u [] GHC.Real.$p1Real $dReal_s1jsj; } in
        let {
          sat_s1jso [Occ=Once] :: a_s1hEV
          [LclId] =
              [ww1_s1jsg ww3_s1jsi $dNum_s1jsk] \u []
                  GHC.Num.* $dNum_s1jsk ww1_s1jsg ww3_s1jsi; } in
        let {
          sat_s1jsn [Occ=Once] :: a_s1hEV
          [LclId] =
              [ww_s1jsf ww1_s1jsg ww2_s1jsh ww3_s1jsi $dNum_s1jsk] \u []
                  let {
                    sat_s1jsm [Occ=Once] :: a_s1hEV
                    [LclId] =
                        [ww1_s1jsg ww2_s1jsh $dNum_s1jsk] \u []
                            GHC.Num.* $dNum_s1jsk ww2_s1jsh ww1_s1jsg; } in
                  let {
                    sat_s1jsl [Occ=Once] :: a_s1hEV
                    [LclId] =
                        [ww_s1jsf ww3_s1jsi $dNum_s1jsk] \u []
                            GHC.Num.* $dNum_s1jsk ww_s1jsf ww3_s1jsi;
                  } in  GHC.Num.+ $dNum_s1jsk sat_s1jsl sat_s1jsm;
        } in  GHC.Real.$wreduce w_s1jse sat_s1jsn sat_s1jso;

GHC.Real.$fNumRatio_$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jsp w1_s1jsq w2_s1jsr]
        case w1_s1jsq of {
          GHC.Real.:% ww1_s1jst [Occ=Once] ww2_s1jsu [Occ=Once] ->
              case w2_s1jsr of {
                GHC.Real.:% ww4_s1jsw [Occ=Once] ww5_s1jsx [Occ=Once] ->
                    case
                        GHC.Real.$w$c+ w_s1jsp ww1_s1jst ww2_s1jsu ww4_s1jsw ww5_s1jsx
                    of
                    { (#,#) ww7_s1jsz [Occ=Once] ww8_s1jsA [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jsz ww8_s1jsA];
                    };
              };
        };

GHC.Real.$w$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,1*C1(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jsB ww_s1jsC ww1_s1jsD ww2_s1jsE ww3_s1jsF]
        let {
          $dReal_s1jsG [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hFd
          [LclId] =
              [w_s1jsB] \s [] GHC.Real.$p1Integral w_s1jsB; } in
        let {
          $dNum_s1jsH [Dmd=<L,U(A,1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hFd
          [LclId] =
              [$dReal_s1jsG] \u [] GHC.Real.$p1Real $dReal_s1jsG; } in
        let {
          sat_s1jsL [Occ=Once] :: a_s1hFd
          [LclId] =
              [ww1_s1jsD ww3_s1jsF $dNum_s1jsH] \u []
                  GHC.Num.* $dNum_s1jsH ww1_s1jsD ww3_s1jsF; } in
        let {
          sat_s1jsK [Occ=Once] :: a_s1hFd
          [LclId] =
              [ww_s1jsC ww1_s1jsD ww2_s1jsE ww3_s1jsF $dNum_s1jsH] \u []
                  let {
                    sat_s1jsJ [Occ=Once] :: a_s1hFd
                    [LclId] =
                        [ww1_s1jsD ww2_s1jsE $dNum_s1jsH] \u []
                            GHC.Num.* $dNum_s1jsH ww2_s1jsE ww1_s1jsD; } in
                  let {
                    sat_s1jsI [Occ=Once] :: a_s1hFd
                    [LclId] =
                        [ww_s1jsC ww3_s1jsF $dNum_s1jsH] \u []
                            GHC.Num.* $dNum_s1jsH ww_s1jsC ww3_s1jsF;
                  } in  GHC.Num.- $dNum_s1jsH sat_s1jsI sat_s1jsJ;
        } in  GHC.Real.$wreduce w_s1jsB sat_s1jsK sat_s1jsL;

GHC.Real.$fNumRatio_$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jsM w1_s1jsN w2_s1jsO]
        case w1_s1jsN of {
          GHC.Real.:% ww1_s1jsQ [Occ=Once] ww2_s1jsR [Occ=Once] ->
              case w2_s1jsO of {
                GHC.Real.:% ww4_s1jsT [Occ=Once] ww5_s1jsU [Occ=Once] ->
                    case
                        GHC.Real.$w$c- w_s1jsM ww1_s1jsQ ww2_s1jsR ww4_s1jsT ww5_s1jsU
                    of
                    { (#,#) ww7_s1jsW [Occ=Once] ww8_s1jsX [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jsW ww8_s1jsX];
                    };
              };
        };

GHC.Real.$w$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jsY ww_s1jsZ ww1_s1jt0 ww2_s1jt1 ww3_s1jt2]
        let {
          $dReal_s1jt3 [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hFv
          [LclId] =
              [w_s1jsY] \s [] GHC.Real.$p1Integral w_s1jsY; } in
        let {
          $dNum_s1jt4 [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hFv
          [LclId] =
              [$dReal_s1jt3] \u [] GHC.Real.$p1Real $dReal_s1jt3; } in
        let {
          sat_s1jt6 [Occ=Once] :: a_s1hFv
          [LclId] =
              [ww1_s1jt0 ww3_s1jt2 $dNum_s1jt4] \u []
                  GHC.Num.* $dNum_s1jt4 ww1_s1jt0 ww3_s1jt2; } in
        let {
          sat_s1jt5 [Occ=Once] :: a_s1hFv
          [LclId] =
              [ww_s1jsZ ww2_s1jt1 $dNum_s1jt4] \u []
                  GHC.Num.* $dNum_s1jt4 ww_s1jsZ ww2_s1jt1;
        } in  GHC.Real.$wreduce w_s1jsY sat_s1jt5 sat_s1jt6;

GHC.Real.$fNumRatio_$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jt7 w1_s1jt8 w2_s1jt9]
        case w1_s1jt8 of {
          GHC.Real.:% ww1_s1jtb [Occ=Once] ww2_s1jtc [Occ=Once] ->
              case w2_s1jt9 of {
                GHC.Real.:% ww4_s1jte [Occ=Once] ww5_s1jtf [Occ=Once] ->
                    case
                        GHC.Real.$w$c* w_s1jt7 ww1_s1jtb ww2_s1jtc ww4_s1jte ww5_s1jtf
                    of
                    { (#,#) ww7_s1jth [Occ=Once] ww8_s1jti [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jth ww8_s1jti];
                    };
              };
        };

GHC.Real.$fNumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Real.Integral a => GHC.Num.Num (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dIntegral_s1jtj]
        let {
          sat_s1jtq [Occ=Once]
            :: GHC.Integer.Type.Integer -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B1]
                  GHC.Real.$fNumRatio_$cfromInteger $dIntegral_s1jtj eta_B1; } in
        let {
          sat_s1jtp [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B1]
                  GHC.Real.$fNumRatio_$csignum $dIntegral_s1jtj eta_B1; } in
        let {
          sat_s1jto [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B1]
                  GHC.Real.$fNumRatio_$cabs $dIntegral_s1jtj eta_B1; } in
        let {
          sat_s1jtn [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B1]
                  GHC.Real.$fNumRatio_$cnegate $dIntegral_s1jtj eta_B1; } in
        let {
          sat_s1jtm [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM
               -> GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B2 eta_B1]
                  GHC.Real.$fNumRatio_$c* $dIntegral_s1jtj eta_B2 eta_B1; } in
        let {
          sat_s1jtl [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM
               -> GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B2 eta_B1]
                  GHC.Real.$fNumRatio_$c- $dIntegral_s1jtj eta_B2 eta_B1; } in
        let {
          sat_s1jtk [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM
               -> GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1jtj] \r [eta_B2 eta_B1]
                  GHC.Real.$fNumRatio_$c+ $dIntegral_s1jtj eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [sat_s1jtk
                         sat_s1jtl
                         sat_s1jtm
                         sat_s1jtn
                         sat_s1jto
                         sat_s1jtp
                         sat_s1jtq];

GHC.Real.$fEnumRatio3 :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.$fEnumRatio1
                                GHC.Real.$fEnumRatio1];

GHC.Real.$fEnumRatio_$s$csucc
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [x_s1jtr]
        case x_s1jtr of {
          GHC.Real.:% ww1_s1jtt [Occ=Once] ww2_s1jtu [Occ=Once] ->
              case
                  GHC.Real.$w$s$c+
                      ww1_s1jtt ww2_s1jtu GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1jtw [Occ=Once] ww5_s1jtx [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jtw ww5_s1jtx];
              };
        };

GHC.Real.$fEnumRatio_$csucc
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jty x_s1jtz]
        case x_s1jtz of {
          GHC.Real.:% ww1_s1jtB [Occ=Once] ww2_s1jtC [Occ=Once] ->
              case
                  GHC.Real.$w$cfromInteger $dIntegral_s1jty GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1jtE [Occ=Once] ww5_s1jtF [Occ=Once] ->
                    case
                        GHC.Real.$w$c+
                            $dIntegral_s1jty ww1_s1jtB ww2_s1jtC ww4_s1jtE ww5_s1jtF
                    of
                    { (#,#) ww7_s1jtH [Occ=Once] ww8_s1jtI [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jtH ww8_s1jtI];
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$cpred
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [x_s1jtJ]
        case x_s1jtJ of {
          GHC.Real.:% ww1_s1jtL [Occ=Once] ww2_s1jtM [Occ=Once] ->
              case
                  GHC.Real.$w$s$c-
                      ww1_s1jtL ww2_s1jtM GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1jtO [Occ=Once] ww5_s1jtP [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jtO ww5_s1jtP];
              };
        };

GHC.Real.$fEnumRatio_$cpred
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jtQ x_s1jtR]
        case x_s1jtR of {
          GHC.Real.:% ww1_s1jtT [Occ=Once] ww2_s1jtU [Occ=Once] ->
              case
                  GHC.Real.$w$cfromInteger $dIntegral_s1jtQ GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1jtW [Occ=Once] ww5_s1jtX [Occ=Once] ->
                    case
                        GHC.Real.$w$c-
                            $dIntegral_s1jtQ ww1_s1jtT ww2_s1jtU ww4_s1jtW ww5_s1jtX
                    of
                    { (#,#) ww7_s1jtZ [Occ=Once] ww8_s1ju0 [Occ=Once] ->
                          GHC.Real.:% [ww7_s1jtZ ww8_s1ju0];
                    };
              };
        };

GHC.Real.$fFractionalRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Fractional (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dIntegral_s1ju1]
        let {
          sat_s1ju5 [Occ=Once] :: GHC.Real.Rational -> GHC.Real.Ratio a_a1eGy
          [LclId] =
              [$dIntegral_s1ju1] \r [eta_B1]
                  GHC.Real.$fFractionalRatio_$cfromRational
                      $dIntegral_s1ju1 eta_B1; } in
        let {
          sat_s1ju4 [Occ=Once]
            :: GHC.Real.Ratio a_a1eGy -> GHC.Real.Ratio a_a1eGy
          [LclId] =
              [$dIntegral_s1ju1] \r [eta_B1]
                  GHC.Real.$fFractionalRatio_$crecip $dIntegral_s1ju1 eta_B1; } in
        let {
          sat_s1ju3 [Occ=Once]
            :: GHC.Real.Ratio a_a1eGy
               -> GHC.Real.Ratio a_a1eGy -> GHC.Real.Ratio a_a1eGy
          [LclId] =
              [$dIntegral_s1ju1] \r [eta_B2 eta_B1]
                  GHC.Real.$fFractionalRatio_$c/ $dIntegral_s1ju1 eta_B2 eta_B1; } in
        let {
          sat_s1ju2 [Occ=Once] :: GHC.Num.Num (GHC.Real.Ratio a_a1eGy)
          [LclId] =
              [$dIntegral_s1ju1] \u [] GHC.Real.$fNumRatio $dIntegral_s1ju1;
        } in 
          GHC.Real.C:Fractional [sat_s1ju2 sat_s1ju3 sat_s1ju4 sat_s1ju5];

GHC.Real.$fEnumRatio_$cenumFrom
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1ju6]
        let {
          w_s1ju7 [Occ=OnceL, Dmd=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)>]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1ju6] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1ju6; } in
        let {
          sat_s1juc [Occ=OnceT[0]]
            :: GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [w_s1ju7] \r [w1_s1ju8]
                  case GHC.Real.$wnumericEnumFrom w_s1ju7 w1_s1ju8 of {
                    (#,#) ww1_s1jua [Occ=Once] ww2_s1jub [Occ=Once] ->
                        : [ww1_s1jua ww2_s1jub];
                  };
        } in  sat_s1juc;

GHC.Real.$fEnumRatio_$cenumFromThen
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jud]
        let {
          w_s1jue [Occ=OnceL,
                   Dmd=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)>]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1jud] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1jud; } in
        let {
          sat_s1juk [Occ=OnceT[0]]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [w_s1jue] \r [w1_s1juf w2_s1jug]
                  case GHC.Real.$wnumericEnumFromThen w_s1jue w1_s1juf w2_s1jug of {
                    (#,#) ww1_s1jui [Occ=Once] ww2_s1juj [Occ=Once] ->
                        : [ww1_s1jui ww2_s1juj];
                  };
        } in  sat_s1juk;

GHC.Real.$fEnumRatio_$cenumFromTo
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jul]
        let {
          sat_s1jun [Occ=Once]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1jul] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1jul; } in
        let {
          sat_s1jum [Occ=Once] :: GHC.Classes.Ord (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1jul] \u [] GHC.Real.$fOrdRatio $dIntegral_s1jul;
        } in  GHC.Real.numericEnumFromTo sat_s1jum sat_s1jun;

GHC.Real.$fEnumRatio_$cenumFromThenTo
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a
     -> GHC.Real.Ratio a -> GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1juo]
        let {
          sat_s1juq [Occ=Once]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1juo] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1juo; } in
        let {
          sat_s1jup [Occ=Once] :: GHC.Classes.Ord (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1juo] \u [] GHC.Real.$fOrdRatio $dIntegral_s1juo;
        } in  GHC.Real.numericEnumFromThenTo sat_s1jup sat_s1juq;

GHC.Real.$fRealFracRatio_$s$fRealRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Real.$fFractionalRatio_$s$fNumRatio
                                    GHC.Real.$fOrdRatio_$s$fOrdRatio
                                    GHC.Real.$fRealRatio_$s$ctoRational];

GHC.Real.$fRealRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Real (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,C(U))>m] =
    [] \r [$dIntegral_s1jur]
        let {
          sat_s1juu [Occ=Once] :: GHC.Real.Ratio a_a1eHn -> GHC.Real.Rational
          [LclId] =
              [$dIntegral_s1jur] \r [eta_B1]
                  GHC.Real.$fRealRatio_$ctoRational $dIntegral_s1jur eta_B1; } in
        let {
          sat_s1jut [Occ=Once] :: GHC.Classes.Ord (GHC.Real.Ratio a_a1eHn)
          [LclId] =
              [$dIntegral_s1jur] \u [] GHC.Real.$fOrdRatio $dIntegral_s1jur; } in
        let {
          sat_s1jus [Occ=Once] :: GHC.Num.Num (GHC.Real.Ratio a_a1eHn)
          [LclId] =
              [$dIntegral_s1jur] \u [] GHC.Real.$fNumRatio $dIntegral_s1jur;
        } in  GHC.Real.C:Real [sat_s1jus sat_s1jut sat_s1juu];

GHC.Real.$w$s$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(1*C1(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1juv ww_s1juw ww1_s1jux]
        case GHC.Real.$w$s$cproperFraction w_s1juv ww_s1juw ww1_s1jux of {
          (#,#) ww3_s1juz [Occ=Once*] ww4_s1juA [Occ=Once!] ->
              case ww4_s1juA of {
                GHC.Real.:% ww6_s1juC [Occ=Once] ww7_s1juD [Occ=Once] ->
                    case
                        GHC.Real.$w$s$ccompare
                            ww6_s1juC ww7_s1juD GHC.Real.even1 GHC.Real.$fEnumRatio1
                    of
                    { __DEFAULT -> ww3_s1juz;
                      GHC.Types.GT ->
                          case
                              GHC.Real.$p1Integral w_s1juv
                          of
                          $dReal_s1juF [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
                          { __DEFAULT ->
                                case
                                    GHC.Real.$p1Real $dReal_s1juF
                                of
                                $dNum_s1juG [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                                { __DEFAULT ->
                                      let {
                                        sat_s1juH [Occ=Once] :: b_s1hFX
                                        [LclId] =
                                            [$dNum_s1juG] \u []
                                                GHC.Num.fromInteger
                                                    $dNum_s1juG GHC.Real.$fEnumRatio1;
                                      } in  GHC.Num.+ $dNum_s1juG ww3_s1juz sat_s1juH;
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$s$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1juI w1_s1juJ]
        case w1_s1juJ of {
          GHC.Real.:% ww1_s1juL [Occ=Once] ww2_s1juM [Occ=Once] ->
              GHC.Real.$w$s$cceiling w_s1juI ww1_s1juL ww2_s1juM;
        };

GHC.Real.$w$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(1*C1(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1juN w1_s1juO ww_s1juP ww1_s1juQ]
        case
            GHC.Real.$w$cproperFraction w_s1juN w1_s1juO ww_s1juP ww1_s1juQ
        of
        { (#,#) ww3_s1juS [Occ=Once*] ww4_s1juT [Occ=Once!] ->
              case ww4_s1juT of {
                GHC.Real.:% ww6_s1juV [Occ=Once] ww7_s1juW [Occ=Once] ->
                    case GHC.Real.$w$cfromInteger w_s1juN GHC.Real.even1 of {
                      (#,#) ww9_s1juY [Occ=Once] ww10_s1juZ [Occ=Once] ->
                          case
                              GHC.Real.$w$ccompare
                                  w_s1juN ww6_s1juV ww7_s1juW ww9_s1juY ww10_s1juZ
                          of
                          { __DEFAULT -> ww3_s1juS;
                            GHC.Types.GT ->
                                case
                                    GHC.Real.$p1Integral w1_s1juO
                                of
                                $dReal_s1jv1 [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
                                { __DEFAULT ->
                                      case
                                          GHC.Real.$p1Real $dReal_s1jv1
                                      of
                                      $dNum_s1jv2 [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                                      { __DEFAULT ->
                                            let {
                                              sat_s1jv3 [Occ=Once] :: b_s1hGi
                                              [LclId] =
                                                  [$dNum_s1jv2] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s1jv2 GHC.Real.$fEnumRatio1;
                                            } in  GHC.Num.+ $dNum_s1jv2 ww3_s1juS sat_s1jv3;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jv4 w1_s1jv5 w2_s1jv6]
        case w2_s1jv6 of {
          GHC.Real.:% ww1_s1jv8 [Occ=Once] ww2_s1jv9 [Occ=Once] ->
              GHC.Real.$w$cceiling w_s1jv4 w1_s1jv5 ww1_s1jv8 ww2_s1jv9;
        };

GHC.Real.$w$s$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,1*C1(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jva ww_s1jvb ww1_s1jvc]
        case GHC.Real.$w$s$cproperFraction w_s1jva ww_s1jvb ww1_s1jvc of {
          (#,#) ww3_s1jve [Occ=Once*] ww4_s1jvf [Occ=Once!] ->
              case ww4_s1jvf of {
                GHC.Real.:% x_s1jvh [Occ=Once] y_s1jvi [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger GHC.Real.even1 y_s1jvi
                    of
                    sat_s1jvk
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger x_s1jvh GHC.Real.$fEnumRatio1
                          of
                          sat_s1jvj
                          { __DEFAULT ->
                                case GHC.Integer.Type.ltInteger# sat_s1jvj sat_s1jvk of {
                                  __DEFAULT -> ww3_s1jve;
                                  1# ->
                                      case
                                          GHC.Real.$p1Integral w_s1jva
                                      of
                                      $dReal_s1jvm [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                      { __DEFAULT ->
                                            case
                                                GHC.Real.$p1Real $dReal_s1jvm
                                            of
                                            $dNum_s1jvn [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                            { __DEFAULT ->
                                                  let {
                                                    sat_s1jvo [Occ=Once] :: b_s1hGr
                                                    [LclId] =
                                                        [$dNum_s1jvn] \u []
                                                            GHC.Num.fromInteger
                                                                $dNum_s1jvn GHC.Real.$fEnumRatio1;
                                                  } in  GHC.Num.- $dNum_s1jvn ww3_s1jve sat_s1jvo;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$s$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jvp w1_s1jvq]
        case w1_s1jvq of {
          GHC.Real.:% ww1_s1jvs [Occ=Once] ww2_s1jvt [Occ=Once] ->
              GHC.Real.$w$s$cfloor w_s1jvp ww1_s1jvs ww2_s1jvt;
        };

GHC.Real.$w$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLLLLC(S))S(LLC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(A,1*C1(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jvu w1_s1jvv ww_s1jvw ww1_s1jvx]
        case
            GHC.Real.$w$cproperFraction w_s1jvu w1_s1jvv ww_s1jvw ww1_s1jvx
        of
        { (#,#) ww3_s1jvz [Occ=Once*] ww4_s1jvA [Occ=Once!] ->
              case ww4_s1jvA of {
                GHC.Real.:% ww6_s1jvC [Occ=Once] ww7_s1jvD [Occ=Once] ->
                    case GHC.Real.$w$cfromInteger w_s1jvu GHC.Real.even1 of {
                      (#,#) ww9_s1jvF [Occ=Once] ww10_s1jvG [Occ=Once] ->
                          case
                              GHC.Real.$w$c< w_s1jvu ww6_s1jvC ww7_s1jvD ww9_s1jvF ww10_s1jvG
                          of
                          { GHC.Types.False -> ww3_s1jvz;
                            GHC.Types.True ->
                                case
                                    GHC.Real.$p1Integral w1_s1jvv
                                of
                                $dReal_s1jvI [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                { __DEFAULT ->
                                      case
                                          GHC.Real.$p1Real $dReal_s1jvI
                                      of
                                      $dNum_s1jvJ [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                      { __DEFAULT ->
                                            let {
                                              sat_s1jvK [Occ=Once] :: b_s1hGM
                                              [LclId] =
                                                  [$dNum_s1jvJ] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s1jvJ GHC.Real.$fEnumRatio1;
                                            } in  GHC.Num.- $dNum_s1jvJ ww3_s1jvz sat_s1jvK;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLLLLC(S))S(LLC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(A,A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jvL w1_s1jvM w2_s1jvN]
        case w2_s1jvN of {
          GHC.Real.:% ww1_s1jvP [Occ=Once] ww2_s1jvQ [Occ=Once] ->
              GHC.Real.$w$cfloor w_s1jvL w1_s1jvM ww1_s1jvP ww2_s1jvQ;
        };

sat_s1jvR :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s1jvS :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1jvR GHC.Types.[]];

GHC.Real.$fRealFracRatio2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.False sat_s1jvS;

GHC.Real.$w$s$cround [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jvT ww_s1jvU ww1_s1jvV]
        case GHC.Real.$w$s$cproperFraction w_s1jvT ww_s1jvU ww1_s1jvV of {
          (#,#) ww3_s1jvX ww4_s1jvY [Occ=Once!] ->
              case ww4_s1jvY of {
                GHC.Real.:% ww6_s1jw0 ww7_s1jw1 ->
                    case GHC.Integer.Type.absInteger ww6_s1jw0 of dt_s1jw2 {
                      __DEFAULT ->
                          case
                              GHC.Real.$w$s$c-
                                  dt_s1jw2 ww7_s1jw1 GHC.Real.$fEnumRatio1 GHC.Real.even2
                          of
                          { (#,#) ww9_s1jw4 [Occ=Once] _ [Occ=Dead] ->
                                case GHC.Integer.Type.signumInteger ww9_s1jw4 of dt1_s1jw6 {
                                  __DEFAULT ->
                                      case
                                          GHC.Integer.Type.eqInteger#
                                              dt1_s1jw6 GHC.Real.$fRealFracRatio2
                                      of
                                      { __DEFAULT ->
                                            let-no-escape {
                                              m_s1jw8 [Occ=Once*T[0], Dmd=<L,1*U>] :: b_s1hH5
                                              [LclId[JoinId(0)], Unf=OtherCon []] =
                                                  [w_s1jvT ww3_s1jvX ww6_s1jw0 ww7_s1jw1] \r []
                                                      case
                                                          GHC.Real.$p1Integral w_s1jvT
                                                      of
                                                      $dReal_s1jw9 [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                                      { __DEFAULT ->
                                                            case
                                                                GHC.Real.$p1Real $dReal_s1jw9
                                                            of
                                                            $dNum_s1jwa [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                                            { __DEFAULT ->
                                                                  case
                                                                      GHC.Integer.Type.timesInteger
                                                                          GHC.Real.even1 ww7_s1jw1
                                                                  of
                                                                  sat_s1jwc
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Integer.Type.timesInteger
                                                                                ww6_s1jw0
                                                                                GHC.Real.$fEnumRatio1
                                                                        of
                                                                        sat_s1jwb
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.ltInteger#
                                                                                      sat_s1jwb
                                                                                      sat_s1jwc
                                                                              of
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_s1jwe [Occ=Once]
                                                                                        :: b_s1hH5
                                                                                      [LclId] =
                                                                                          [$dNum_s1jwa] \u []
                                                                                              GHC.Num.fromInteger
                                                                                                  $dNum_s1jwa
                                                                                                  GHC.Real.$fEnumRatio1;
                                                                                    } in 
                                                                                      GHC.Num.+
                                                                                          $dNum_s1jwa
                                                                                          ww3_s1jvX
                                                                                          sat_s1jwe;
                                                                                1# ->
                                                                                    let {
                                                                                      sat_s1jwf [Occ=Once]
                                                                                        :: b_s1hH5
                                                                                      [LclId] =
                                                                                          [$dNum_s1jwa] \u []
                                                                                              GHC.Num.fromInteger
                                                                                                  $dNum_s1jwa
                                                                                                  GHC.Real.$fEnumRatio1;
                                                                                    } in 
                                                                                      GHC.Num.-
                                                                                          $dNum_s1jwa
                                                                                          ww3_s1jvX
                                                                                          sat_s1jwf;
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                            } in 
                                              case
                                                  GHC.Integer.Type.eqInteger#
                                                      dt1_s1jw6 GHC.Real.even1
                                              of
                                              { __DEFAULT ->
                                                    case
                                                        GHC.Integer.Type.eqInteger#
                                                            dt1_s1jw6 GHC.Real.$fEnumRatio1
                                                    of
                                                    { __DEFAULT -> GHC.Real.$fRealFracRatio1;
                                                      1# -> m_s1jw8;
                                                    };
                                                1# ->
                                                    case GHC.Real.even w_s1jvT ww3_s1jvX of {
                                                      GHC.Types.False -> m_s1jw8;
                                                      GHC.Types.True -> ww3_s1jvX;
                                                    };
                                              };
                                        1# -> ww3_s1jvX;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$s$cround [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jwj w1_s1jwk]
        case w1_s1jwk of {
          GHC.Real.:% ww1_s1jwm [Occ=Once] ww2_s1jwn [Occ=Once] ->
              GHC.Real.$w$s$cround w_s1jwj ww1_s1jwm ww2_s1jwn;
        };

GHC.Real.$w$cround [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLC(S)C(S)C(S)C(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),1*C1(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jwo w1_s1jwp ww_s1jwq ww1_s1jwr]
        case
            GHC.Real.$w$cproperFraction w_s1jwo w1_s1jwp ww_s1jwq ww1_s1jwr
        of
        { (#,#) ww3_s1jwt ww4_s1jwu [Occ=Once!] ->
              case ww4_s1jwu of {
                GHC.Real.:% ww6_s1jww ww7_s1jwx ->
                    case GHC.Real.$p1Integral w_s1jwo of sat_s1jwy {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_s1jwy of sat_s1jwz {
                            __DEFAULT ->
                                case GHC.Num.abs sat_s1jwz ww6_s1jww of dt_s1jwA {
                                  __DEFAULT ->
                                      case
                                          GHC.Real.$w$cfromRational
                                              w_s1jwo GHC.Real.$fEnumRatio1 GHC.Real.even2
                                      of
                                      { (#,#) ww9_s1jwC [Occ=Once] ww10_s1jwD [Occ=Once] ->
                                            case
                                                GHC.Real.$w$c-
                                                    w_s1jwo dt_s1jwA ww7_s1jwx ww9_s1jwC ww10_s1jwD
                                            of
                                            { (#,#) ww12_s1jwF [Occ=Once] _ [Occ=Dead] ->
                                                  case GHC.Real.$w$csignum w_s1jwo ww12_s1jwF of {
                                                    (#,#) ww15_s1jwI ww16_s1jwJ ->
                                                        case
                                                            GHC.Real.$w$cfromInteger
                                                                w_s1jwo GHC.Real.$fEnumRatio1
                                                        of
                                                        { (#,#) ww18_s1jwL ww19_s1jwM ->
                                                              case
                                                                  GHC.Real.$p1Integral w_s1jwo
                                                              of
                                                              sat_s1jwN
                                                              { __DEFAULT ->
                                                                    case
                                                                        GHC.Real.$p1Real sat_s1jwN
                                                                    of
                                                                    sat_s1jwO
                                                                    { __DEFAULT ->
                                                                          case
                                                                              GHC.Num.negate
                                                                                  sat_s1jwO
                                                                                  ww18_s1jwL
                                                                          of
                                                                          dt1_s1jwP
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    GHC.Real.$p1Integral
                                                                                        w_s1jwo
                                                                                of
                                                                                $dEq_s1jwQ [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          GHC.Real.$p2Real
                                                                                              $dEq_s1jwQ
                                                                                      of
                                                                                      $dEq1_s1jwR [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                GHC.Classes.$p1Ord
                                                                                                    $dEq1_s1jwR
                                                                                            of
                                                                                            $dEq2_s1jwS [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                                                                            { __DEFAULT ->
                                                                                                  let-no-escape {
                                                                                                    $j_s1jwT [Occ=Once*T[0],
                                                                                                              Dmd=<L,1*U>]
                                                                                                      :: b_s1hHq
                                                                                                    [LclId[JoinId(0)],
                                                                                                     Unf=OtherCon []] =
                                                                                                        [w_s1jwo
                                                                                                         w1_s1jwp
                                                                                                         ww3_s1jwt
                                                                                                         ww6_s1jww
                                                                                                         ww7_s1jwx
                                                                                                         ww15_s1jwI
                                                                                                         ww16_s1jwJ
                                                                                                         ww18_s1jwL
                                                                                                         ww19_s1jwM
                                                                                                         $dEq2_s1jwS] \r []
                                                                                                            case
                                                                                                                GHC.Real.$w$cfromInteger
                                                                                                                    w_s1jwo
                                                                                                                    GHC.Real.even1
                                                                                                            of
                                                                                                            { (#,#) ww21_s1jwV
                                                                                                                    ww22_s1jwW ->
                                                                                                                  let-no-escape {
                                                                                                                    m_s1jwX [Dmd=<L,1*U>]
                                                                                                                      :: b_s1hHq
                                                                                                                    [LclId[JoinId(0)],
                                                                                                                     Unf=OtherCon []] =
                                                                                                                        [w_s1jwo
                                                                                                                         w1_s1jwp
                                                                                                                         ww3_s1jwt
                                                                                                                         ww6_s1jww
                                                                                                                         ww7_s1jwx
                                                                                                                         ww21_s1jwV
                                                                                                                         ww22_s1jwW] \r []
                                                                                                                            case
                                                                                                                                GHC.Real.$p1Integral
                                                                                                                                    w1_s1jwp
                                                                                                                            of
                                                                                                                            $dReal_s1jwY [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      GHC.Real.$p1Real
                                                                                                                                          $dReal_s1jwY
                                                                                                                                  of
                                                                                                                                  $dNum_s1jwZ [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            GHC.Real.$w$c<
                                                                                                                                                w_s1jwo
                                                                                                                                                ww6_s1jww
                                                                                                                                                ww7_s1jwx
                                                                                                                                                ww21_s1jwV
                                                                                                                                                ww22_s1jwW
                                                                                                                                        of
                                                                                                                                        { GHC.Types.False ->
                                                                                                                                              let {
                                                                                                                                                sat_s1jx1 [Occ=Once]
                                                                                                                                                  :: b_s1hHq
                                                                                                                                                [LclId] =
                                                                                                                                                    [$dNum_s1jwZ] \u []
                                                                                                                                                        GHC.Num.fromInteger
                                                                                                                                                            $dNum_s1jwZ
                                                                                                                                                            GHC.Real.$fEnumRatio1;
                                                                                                                                              } in 
                                                                                                                                                GHC.Num.+
                                                                                                                                                    $dNum_s1jwZ
                                                                                                                                                    ww3_s1jwt
                                                                                                                                                    sat_s1jx1;
                                                                                                                                          GHC.Types.True ->
                                                                                                                                              let {
                                                                                                                                                sat_s1jx2 [Occ=Once]
                                                                                                                                                  :: b_s1hHq
                                                                                                                                                [LclId] =
                                                                                                                                                    [$dNum_s1jwZ] \u []
                                                                                                                                                        GHC.Num.fromInteger
                                                                                                                                                            $dNum_s1jwZ
                                                                                                                                                            GHC.Real.$fEnumRatio1;
                                                                                                                                              } in 
                                                                                                                                                GHC.Num.-
                                                                                                                                                    $dNum_s1jwZ
                                                                                                                                                    ww3_s1jwt
                                                                                                                                                    sat_s1jx2;
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                  } in 
                                                                                                                    let-no-escape {
                                                                                                                      $j1_s1jx3 [Occ=Once*T[0],
                                                                                                                                 Dmd=<L,1*U>]
                                                                                                                        :: b_s1hHq
                                                                                                                      [LclId[JoinId(0)],
                                                                                                                       Unf=OtherCon []] =
                                                                                                                          [ww15_s1jwI
                                                                                                                           ww16_s1jwJ
                                                                                                                           ww18_s1jwL
                                                                                                                           ww19_s1jwM
                                                                                                                           $dEq2_s1jwS
                                                                                                                           m_s1jwX] \r []
                                                                                                                              case
                                                                                                                                  GHC.Classes.==
                                                                                                                                      $dEq2_s1jwS
                                                                                                                                      ww15_s1jwI
                                                                                                                                      ww18_s1jwL
                                                                                                                              of
                                                                                                                              { GHC.Types.False ->
                                                                                                                                    GHC.Real.$fRealFracRatio1;
                                                                                                                                GHC.Types.True ->
                                                                                                                                    case
                                                                                                                                        GHC.Classes.==
                                                                                                                                            $dEq2_s1jwS
                                                                                                                                            ww16_s1jwJ
                                                                                                                                            ww19_s1jwM
                                                                                                                                    of
                                                                                                                                    { GHC.Types.False ->
                                                                                                                                          GHC.Real.$fRealFracRatio1;
                                                                                                                                      GHC.Types.True ->
                                                                                                                                          m_s1jwX;
                                                                                                                                    };
                                                                                                                              };
                                                                                                                    } in 
                                                                                                                      case
                                                                                                                          GHC.Classes.==
                                                                                                                              $dEq2_s1jwS
                                                                                                                              ww15_s1jwI
                                                                                                                              ww21_s1jwV
                                                                                                                      of
                                                                                                                      { GHC.Types.False ->
                                                                                                                            $j1_s1jx3;
                                                                                                                        GHC.Types.True ->
                                                                                                                            case
                                                                                                                                GHC.Classes.==
                                                                                                                                    $dEq2_s1jwS
                                                                                                                                    ww16_s1jwJ
                                                                                                                                    ww22_s1jwW
                                                                                                                            of
                                                                                                                            { GHC.Types.False ->
                                                                                                                                  $j1_s1jx3;
                                                                                                                              GHC.Types.True ->
                                                                                                                                  case
                                                                                                                                      GHC.Real.even
                                                                                                                                          w1_s1jwp
                                                                                                                                          ww3_s1jwt
                                                                                                                                  of
                                                                                                                                  { GHC.Types.False ->
                                                                                                                                        m_s1jwX;
                                                                                                                                    GHC.Types.True ->
                                                                                                                                        ww3_s1jwt;
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                            };
                                                                                                  } in 
                                                                                                    case
                                                                                                        GHC.Classes.==
                                                                                                            $dEq2_s1jwS
                                                                                                            ww15_s1jwI
                                                                                                            dt1_s1jwP
                                                                                                    of
                                                                                                    { GHC.Types.False ->
                                                                                                          $j_s1jwT;
                                                                                                      GHC.Types.True ->
                                                                                                          case
                                                                                                              GHC.Classes.==
                                                                                                                  $dEq2_s1jwS
                                                                                                                  ww16_s1jwJ
                                                                                                                  ww19_s1jwM
                                                                                                          of
                                                                                                          { GHC.Types.False ->
                                                                                                                $j_s1jwT;
                                                                                                            GHC.Types.True ->
                                                                                                                ww3_s1jwt;
                                                                                                          };
                                                                                                    };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$cround [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLC(S)C(S)C(S)C(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jxb w1_s1jxc w2_s1jxd]
        case w2_s1jxd of {
          GHC.Real.:% ww1_s1jxf [Occ=Once] ww2_s1jxg [Occ=Once] ->
              GHC.Real.$w$cround w_s1jxb w1_s1jxc ww1_s1jxf ww2_s1jxg;
        };

GHC.Real.$fRealFracRatio_$s$ctruncate [InlPrag=INLINE (sat-args=1)]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jxh x_s1jxi]
        case x_s1jxi of {
          GHC.Real.:% x1_s1jxk [Occ=Once] y_s1jxl ->
              let {
                sat_s1jxt [Occ=Once] :: GHC.Integer.Type.Integer
                [LclId] =
                    [x1_s1jxk y_s1jxl] \u []
                        case GHC.Integer.Type.eqInteger# y_s1jxl GHC.Real.even1 of {
                          __DEFAULT ->
                              case GHC.Integer.Type.quotRemInteger x1_s1jxk y_s1jxl of {
                                (#,#) ipv_s1jxq [Occ=Once] _ [Occ=Dead] -> ipv_s1jxq;
                              };
                          1# -> GHC.Real.divZeroError;
                        };
              } in 
                case GHC.Real.$p1Integral $dIntegral_s1jxh of sat_s1jxm {
                  __DEFAULT ->
                      case GHC.Real.$p1Real sat_s1jxm of sat_s1jxn {
                        __DEFAULT -> GHC.Num.fromInteger sat_s1jxn sat_s1jxt;
                      };
                };
        };

GHC.Real.$fRealFracRatio_$ctruncate [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jxu $dIntegral1_s1jxv x_s1jxw]
        case x_s1jxw of {
          GHC.Real.:% ww1_s1jxy [Occ=Once] ww2_s1jxz [Occ=Once] ->
              case
                  GHC.Real.$w$cproperFraction
                      $dIntegral_s1jxu $dIntegral1_s1jxv ww1_s1jxy ww2_s1jxz
              of
              { (#,#) ww4_s1jxB [Occ=Once] _ [Occ=Dead] -> ww4_s1jxB;
              };
        };

GHC.Real.$fRealFracRatio_$s$fRealFracRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.RealFrac (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:RealFrac! [GHC.Real.$fRealFracRatio_$s$fRealRatio
                                        GHC.Real.$fFractionalRatio_$s$fFractionalRatio
                                        GHC.Real.$fEnumRatio_$s$cproperFraction
                                        GHC.Real.$fRealFracRatio_$s$ctruncate
                                        GHC.Real.$fRealFracRatio_$s$cround
                                        GHC.Real.$fRealFracRatio_$s$cceiling
                                        GHC.Real.$fRealFracRatio_$s$cfloor];

GHC.Real.$fRealFracRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.RealFrac (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))>m] =
    [] \r [$dIntegral_s1jxD]
        let {
          sat_s1jxK [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1jxD] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$cfloor
                      $dIntegral_s1jxD eta_B2 eta_B1; } in
        let {
          sat_s1jxJ [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1jxD] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$cceiling
                      $dIntegral_s1jxD eta_B2 eta_B1; } in
        let {
          sat_s1jxI [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1jxD] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$cround
                      $dIntegral_s1jxD eta_B2 eta_B1; } in
        let {
          sat_s1jxH [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1jxD] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$ctruncate
                      $dIntegral_s1jxD eta_B2 eta_B1; } in
        let {
          sat_s1jxG [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               GHC.Real.Ratio a_a1eFc -> (b, GHC.Real.Ratio a_a1eFc)
          [LclId] =
              [$dIntegral_s1jxD] \r [eta_B2 eta_B1]
                  GHC.Real.$fEnumRatio_$cproperFraction
                      $dIntegral_s1jxD eta_B2 eta_B1; } in
        let {
          sat_s1jxF [Occ=Once]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eFc)
          [LclId] =
              [$dIntegral_s1jxD] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1jxD; } in
        let {
          sat_s1jxE [Occ=Once] :: GHC.Real.Real (GHC.Real.Ratio a_a1eFc)
          [LclId] =
              [$dIntegral_s1jxD] \u [] GHC.Real.$fRealRatio $dIntegral_s1jxD;
        } in 
          GHC.Real.C:RealFrac [sat_s1jxE
                               sat_s1jxF
                               sat_s1jxG
                               sat_s1jxH
                               sat_s1jxI
                               sat_s1jxJ
                               sat_s1jxK];

g_r1j3N
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
[GblId, Arity=3, Str=<S,U><S,U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [x_s1jxL y_s1jxM z_s1jxN]
        case
            GHC.Integer.Type.remInteger y_s1jxM GHC.Real.even2
        of
        sat_s1jxO
        { __DEFAULT ->
              case GHC.Integer.Type.eqInteger# sat_s1jxO GHC.Real.even1 of {
                __DEFAULT ->
                    case GHC.Integer.Type.eqInteger# y_s1jxM GHC.Real.$fEnumRatio1 of {
                      __DEFAULT ->
                          case GHC.Integer.Type.timesInteger x_s1jxL z_s1jxN of sat_s1jxT {
                            __DEFAULT ->
                                case
                                    GHC.Integer.Type.quotInteger y_s1jxM GHC.Real.even2
                                of
                                sat_s1jxS
                                { __DEFAULT ->
                                      case
                                          GHC.Integer.Type.timesInteger x_s1jxL x_s1jxL
                                      of
                                      sat_s1jxR
                                      { __DEFAULT -> g_r1j3N sat_s1jxR sat_s1jxS sat_s1jxT;
                                      };
                                };
                          };
                      1# -> GHC.Integer.Type.timesInteger x_s1jxL z_s1jxN;
                    };
                1# ->
                    case
                        GHC.Integer.Type.quotInteger y_s1jxM GHC.Real.even2
                    of
                    sat_s1jxV
                    { __DEFAULT ->
                          case GHC.Integer.Type.timesInteger x_s1jxL x_s1jxL of sat_s1jxU {
                            __DEFAULT -> g_r1j3N sat_s1jxU sat_s1jxV z_s1jxN;
                          };
                    };
              };
        };

GHC.Real.^_f [Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [x_s1jxW y_s1jxX]
        case
            GHC.Integer.Type.remInteger y_s1jxX GHC.Real.even2
        of
        sat_s1jxY
        { __DEFAULT ->
              case GHC.Integer.Type.eqInteger# sat_s1jxY GHC.Real.even1 of {
                __DEFAULT ->
                    case GHC.Integer.Type.eqInteger# y_s1jxX GHC.Real.$fEnumRatio1 of {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.quotInteger y_s1jxX GHC.Real.even2
                          of
                          sat_s1jy2
                          { __DEFAULT ->
                                case GHC.Integer.Type.timesInteger x_s1jxW x_s1jxW of sat_s1jy1 {
                                  __DEFAULT -> g_r1j3N sat_s1jy1 sat_s1jy2 x_s1jxW;
                                };
                          };
                      1# -> x_s1jxW;
                    };
                1# ->
                    case
                        GHC.Integer.Type.quotInteger y_s1jxX GHC.Real.even2
                    of
                    sat_s1jy4
                    { __DEFAULT ->
                          case GHC.Integer.Type.timesInteger x_s1jxW x_s1jxW of sat_s1jy3 {
                            __DEFAULT -> GHC.Real.^_f sat_s1jy3 sat_s1jy4;
                          };
                    };
              };
        };

lvl5_r1j3O :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Negative exponent"#;

GHC.Real.^1 :: GHC.Integer.Type.Integer
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1jy5 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1jy5;
        };

GHC.Real.^_$s^ [InlPrag=NOUSERINLINE[1]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [x0_s1jy6 y0_s1jy7]
        case GHC.Integer.Type.ltInteger# y0_s1jy7 GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.eqInteger# y0_s1jy7 GHC.Real.even1 of {
                __DEFAULT -> GHC.Real.^_f x0_s1jy6 y0_s1jy7;
                1# -> GHC.Real.$fEnumRatio1;
              };
          1# -> GHC.Real.^1;
        };

GHC.Real.$w$s$cfromEnum [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Prim.Int#
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1jya ww1_s1jyb]
        case GHC.Integer.Type.eqInteger# ww1_s1jyb GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.quotRemInteger ww_s1jya ww1_s1jyb of {
                (#,#) ipv_s1jye [Occ=Once] _ [Occ=Dead] ->
                    GHC.Integer.Type.integerToInt ipv_s1jye;
              };
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fEnumRatio_$s$cfromEnum [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Int
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_s1jyh]
        case w_s1jyh of {
          GHC.Real.:% ww1_s1jyj [Occ=Once] ww2_s1jyk [Occ=Once] ->
              case GHC.Real.$w$s$cfromEnum ww1_s1jyj ww2_s1jyk of ww3_s1jyl {
                __DEFAULT -> GHC.Types.I# [ww3_s1jyl];
              };
        };

GHC.Real.$fEnumRatio_$cfromEnum
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)),U(A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A,1*C1(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jym x_s1jyn]
        case x_s1jyn of {
          GHC.Real.:% ww1_s1jyp [Occ=Once] ww2_s1jyq [Occ=Once] ->
              let {
                sat_s1jyu [Occ=Once] :: a_a1eE0
                [LclId] =
                    [$dIntegral_s1jym ww1_s1jyp ww2_s1jyq] \u []
                        case GHC.Real.quotRem $dIntegral_s1jym ww1_s1jyp ww2_s1jyq of {
                          (,) q_s1jys [Occ=Once] _ [Occ=Dead] -> q_s1jys;
                        };
              } in 
                case GHC.Real.toInteger $dIntegral_s1jym sat_s1jyu of sat_s1jyv {
                  __DEFAULT ->
                      case GHC.Integer.Type.integerToInt sat_s1jyv of wild_s1jyw {
                        __DEFAULT -> GHC.Types.I# [wild_s1jyw];
                      };
                };
        };

GHC.Real.ratioPrec1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [8#];

GHC.Real.$fShowRatio2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    " % "#;

GHC.Real.$w$s$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Base.String
     -> (# GHC.Types.Char, [GHC.Types.Char] #)
[GblId, Arity=4, Str=<S,U><L,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1jyx ww1_s1jyy ww2_s1jyz w_s1jyA]
        case ># [ww_s1jyx 7#] of {
          __DEFAULT ->
              let {
                sat_s1jyG [Occ=Once] :: GHC.Base.String
                [LclId] =
                    [ww2_s1jyz w_s1jyA] \u []
                        let {
                          sat_s1jyF [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [ww2_s1jyz w_s1jyA] \u []
                                  case GHC.Show.$w$cshowsPrec4 8# ww2_s1jyz w_s1jyA of {
                                    (#,#) ww4_s1jyD [Occ=Once] ww5_s1jyE [Occ=Once] ->
                                        : [ww4_s1jyD ww5_s1jyE];
                                  };
                        } in 
                          GHC.CString.unpackAppendCString# GHC.Real.$fShowRatio2 sat_s1jyF;
              } in  GHC.Show.$w$cshowsPrec4 8# ww1_s1jyy sat_s1jyG;
          1# ->
              let {
                sat_s1jyQ [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [ww1_s1jyy ww2_s1jyz w_s1jyA] \u []
                        let {
                          sat_s1jyM [Occ=Once] :: GHC.Base.String
                          [LclId] =
                              [ww2_s1jyz w_s1jyA] \u []
                                  let {
                                    sat_s1jyL [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [ww2_s1jyz w_s1jyA] \u []
                                            let {
                                              sat_s1jyH [Occ=Once] :: GHC.Base.String
                                              [LclId] =
                                                  CCCS :! [GHC.Show.$fShow(,)2 w_s1jyA];
                                            } in 
                                              case
                                                  GHC.Show.$w$cshowsPrec4 8# ww2_s1jyz sat_s1jyH
                                              of
                                              { (#,#) ww4_s1jyJ [Occ=Once] ww5_s1jyK [Occ=Once] ->
                                                    : [ww4_s1jyJ ww5_s1jyK];
                                              };
                                  } in 
                                    GHC.CString.unpackAppendCString#
                                        GHC.Real.$fShowRatio2 sat_s1jyL;
                        } in 
                          case GHC.Show.$w$cshowsPrec4 8# ww1_s1jyy sat_s1jyM of {
                            (#,#) ww4_s1jyO [Occ=Once] ww5_s1jyP [Occ=Once] ->
                                : [ww4_s1jyO ww5_s1jyP];
                          };
              } in  (#,#) [GHC.Show.$fShow(,)4 sat_s1jyQ];
        };

GHC.Real.$fShowRatio_$s$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S(SS),1*U(U,U)><L,U>m2,
 Unf=OtherCon []] =
    [] \r [w_s1jyR w1_s1jyS w2_s1jyT]
        case w_s1jyR of {
          GHC.Types.I# ww1_s1jyV [Occ=Once] ->
              case w1_s1jyS of {
                GHC.Real.:% ww3_s1jyX [Occ=Once] ww4_s1jyY [Occ=Once] ->
                    case
                        GHC.Real.$w$s$cshowsPrec ww1_s1jyV ww3_s1jyX ww4_s1jyY w2_s1jyT
                    of
                    { (#,#) ww6_s1jz0 [Occ=Once] ww7_s1jz1 [Occ=Once] ->
                          : [ww6_s1jz0 ww7_s1jz1];
                    };
              };
        };

GHC.Real.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> a -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jz2 ww_s1jz3 ww1_s1jz4 ww2_s1jz5]
        let {
          f_s1jz6 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s1jz2 ww1_s1jz4] \u []
                  GHC.Show.showsPrec w_s1jz2 GHC.Real.ratioPrec1 ww1_s1jz4; } in
        let {
          g1_s1jz7 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s1jz2 ww2_s1jz5] \u []
                  GHC.Show.showsPrec w_s1jz2 GHC.Real.ratioPrec1 ww2_s1jz5;
        } in 
          case ># [ww_s1jz3 7#] of {
            __DEFAULT ->
                let {
                  sat_s1jzc [Occ=OnceT[0]] :: GHC.Base.String -> GHC.Base.String
                  [LclId] =
                      [f_s1jz6 g1_s1jz7] \r [x_s1jz9]
                          let {
                            sat_s1jzb [Occ=Once] :: GHC.Base.String
                            [LclId] =
                                [g1_s1jz7 x_s1jz9] \u []
                                    let {
                                      sat_s1jza [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g1_s1jz7 x_s1jz9] \u [] g1_s1jz7 x_s1jz9;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          GHC.Real.$fShowRatio2 sat_s1jza;
                          } in  f_s1jz6 sat_s1jzb;
                } in  sat_s1jzc;
            1# ->
                let {
                  sat_s1jzi [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s1jz6 g1_s1jz7] \r [x_s1jzd]
                          let {
                            sat_s1jzh [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s1jz6 g1_s1jz7 x_s1jzd] \u []
                                    let {
                                      sat_s1jzg [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          [g1_s1jz7 x_s1jzd] \u []
                                              let {
                                                sat_s1jzf [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_s1jz7 x_s1jzd] \u []
                                                        let {
                                                          sat_s1jze [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_s1jzd];
                                                        } in  g1_s1jz7 sat_s1jze;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    GHC.Real.$fShowRatio2 sat_s1jzf;
                                    } in  f_s1jz6 sat_s1jzg;
                          } in  : [GHC.Show.$fShow(,)4 sat_s1jzh];
                } in  sat_s1jzi;
          };

GHC.Real.$fShowRatio_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> GHC.Real.Ratio a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jzj w1_s1jzk w2_s1jzl]
        case w1_s1jzk of {
          GHC.Types.I# ww1_s1jzn [Occ=Once] ->
              case w2_s1jzl of {
                GHC.Real.:% ww3_s1jzp [Occ=Once] ww4_s1jzq [Occ=Once] ->
                    GHC.Real.$w$cshowsPrec w_s1jzj ww1_s1jzn ww3_s1jzp ww4_s1jzq;
              };
        };

GHC.Real.$fShowRatio1
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S(SS),1*U(U,U)><L,U>m2, Unf=OtherCon []] =
    [] \r [w_s1jzr w1_s1jzs]
        case w_s1jzr of {
          GHC.Real.:% ww1_s1jzu [Occ=Once] ww2_s1jzv [Occ=Once] ->
              case GHC.Real.$w$s$cshowsPrec 0# ww1_s1jzu ww2_s1jzv w1_s1jzs of {
                (#,#) ww4_s1jzx [Occ=Once] ww5_s1jzy [Occ=Once] ->
                    : [ww4_s1jzx ww5_s1jzy];
              };
        };

GHC.Real.$fShowRatio_$s$cshowList
  :: [GHC.Real.Ratio GHC.Integer.Type.Integer] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s1jzz s_s1jzA]
        GHC.Show.showList__ GHC.Real.$fShowRatio1 ls_s1jzz s_s1jzA;

GHC.Real.$fShowRatio_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [GHC.Real.Ratio a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s1jzB ls_s1jzC s_s1jzD]
        let {
          sat_s1jzI [Occ=Once] :: GHC.Real.Ratio a_a1ePl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s1jzB] \r [w_s1jzE]
                  case w_s1jzE of {
                    GHC.Real.:% ww1_s1jzG [Occ=Once] ww2_s1jzH [Occ=Once] ->
                        GHC.Real.$w$cshowsPrec $dShow_s1jzB 0# ww1_s1jzG ww2_s1jzH;
                  };
        } in  GHC.Show.showList__ sat_s1jzI ls_s1jzC s_s1jzD;

GHC.Real.$w$s$cshow [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Types.Char, [GHC.Types.Char] #)
[GblId, Arity=2, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1jzJ ww1_s1jzK]
        let {
          sat_s1jzP [Occ=Once] :: GHC.Base.String
          [LclId] =
              [ww1_s1jzK] \u []
                  let {
                    sat_s1jzO [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [ww1_s1jzK] \u []
                            case GHC.Show.$w$cshowsPrec4 8# ww1_s1jzK GHC.Types.[] of {
                              (#,#) ww3_s1jzM [Occ=Once] ww4_s1jzN [Occ=Once] ->
                                  : [ww3_s1jzM ww4_s1jzN];
                            };
                  } in 
                    GHC.CString.unpackAppendCString# GHC.Real.$fShowRatio2 sat_s1jzO;
        } in  GHC.Show.$w$cshowsPrec4 8# ww_s1jzJ sat_s1jzP;

GHC.Real.$fShowRatio_$s$cshow [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Base.String
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m2, Unf=OtherCon []] =
    [] \r [w_s1jzQ]
        case w_s1jzQ of {
          GHC.Real.:% ww1_s1jzS [Occ=Once] ww2_s1jzT [Occ=Once] ->
              case GHC.Real.$w$s$cshow ww1_s1jzS ww2_s1jzT of {
                (#,#) ww4_s1jzV [Occ=Once] ww5_s1jzW [Occ=Once] ->
                    : [ww4_s1jzV ww5_s1jzW];
              };
        };

GHC.Real.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Show.Show a => a -> a -> GHC.Base.String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jzX ww_s1jzY ww1_s1jzZ]
        let {
          sat_s1jA1 [Occ=Once] :: GHC.Base.String
          [LclId] =
              [w_s1jzX ww1_s1jzZ] \u []
                  let {
                    sat_s1jA0 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [w_s1jzX ww1_s1jzZ] \u []
                            GHC.Show.showsPrec
                                w_s1jzX GHC.Real.ratioPrec1 ww1_s1jzZ GHC.Types.[];
                  } in 
                    GHC.CString.unpackAppendCString# GHC.Real.$fShowRatio2 sat_s1jA0;
        } in 
          GHC.Show.showsPrec w_s1jzX GHC.Real.ratioPrec1 ww_s1jzY sat_s1jA1;

GHC.Real.$fShowRatio_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Show.Show a => GHC.Real.Ratio a -> GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jA2 w1_s1jA3]
        case w1_s1jA3 of {
          GHC.Real.:% ww1_s1jA5 [Occ=Once] ww2_s1jA6 [Occ=Once] ->
              GHC.Real.$w$cshow w_s1jA2 ww1_s1jA5 ww2_s1jA6;
        };

GHC.Real.$fShowRatio_$s$fShowRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [GHC.Real.$fShowRatio_$s$cshowsPrec
                                    GHC.Real.$fShowRatio_$s$cshow
                                    GHC.Real.$fShowRatio_$s$cshowList];

GHC.Real.$fShowRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => GHC.Show.Show (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s1jA7]
        let {
          sat_s1jAa [Occ=Once] :: [GHC.Real.Ratio a_a1ePl] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s1jA7] \r [eta_B2 eta_B1]
                  GHC.Real.$fShowRatio_$cshowList $dShow_s1jA7 eta_B2 eta_B1; } in
        let {
          sat_s1jA9 [Occ=Once] :: GHC.Real.Ratio a_a1ePl -> GHC.Base.String
          [LclId] =
              [$dShow_s1jA7] \r [eta_B1]
                  GHC.Real.$fShowRatio_$cshow $dShow_s1jA7 eta_B1; } in
        let {
          sat_s1jA8 [Occ=Once]
            :: GHC.Types.Int -> GHC.Real.Ratio a_a1ePl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s1jA7] \r [eta_B2 eta_B1]
                  GHC.Real.$fShowRatio_$cshowsPrec $dShow_s1jA7 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s1jA8 sat_s1jA9 sat_s1jAa];

GHC.Real.$w$slcm [InlPrag=NOINLINE[1]]
  :: GHC.Types.Word -> GHC.Prim.Word# -> GHC.Prim.Word#
[GblId, Arity=2, Str=<L,1*U(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [w_s1jAb ww_s1jAc]
        case ww_s1jAc of wild_s1jAd {
          __DEFAULT ->
              case w_s1jAb of wild1_s1jAe {
                GHC.Types.W# x_s1jAf [Occ=Once!] ->
                    case x_s1jAf of wild2_s1jAg {
                      __DEFAULT ->
                          let {
                            sat_s1jAh [Occ=Once] :: GHC.Types.Word
                            [LclId] =
                                CCCS GHC.Types.W#! [wild_s1jAd];
                          } in 
                            case
                                GHC.Real.gcd GHC.Real.$fIntegralWord wild1_s1jAe sat_s1jAh
                            of
                            { GHC.Types.W# y#_s1jAj [Occ=Once!] ->
                                  case y#_s1jAj of wild4_s1jAk {
                                    __DEFAULT ->
                                        case quotWord# [wild2_s1jAg wild4_s1jAk] of wild5_s1jAl {
                                          __DEFAULT -> timesWord# [wild5_s1jAl wild_s1jAd];
                                        };
                                    0## -> GHC.Real.divZeroError;
                                  };
                            };
                      0## -> 0##;
                    };
              };
          0## -> 0##;
        };

GHC.Real.lcm_$slcm [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1jAn w1_s1jAo]
        case w1_s1jAo of {
          GHC.Types.W# ww1_s1jAq [Occ=Once] ->
              case GHC.Real.$w$slcm w_s1jAn ww1_s1jAq of ww2_s1jAr {
                __DEFAULT -> GHC.Types.W# [ww2_s1jAr];
              };
        };

GHC.Real.$w$slcm1 [InlPrag=NOINLINE[1]]
  :: GHC.Types.Int -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Str=<L,1*U(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [w_s1jAs ww_s1jAt]
        case ww_s1jAt of wild_s1jAu {
          __DEFAULT ->
              case w_s1jAs of wild1_s1jAv {
                GHC.Types.I# x_s1jAw [Occ=Once!] ->
                    case x_s1jAw of wild2_s1jAx {
                      __DEFAULT ->
                          let-no-escape {
                            $j_s1jAy [Occ=Once*!T[1], Dmd=<C(S),1*C1(U)>]
                              :: GHC.Prim.Int# -> GHC.Prim.Int#
                            [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                sat-only [wild_s1jAu wild1_s1jAv wild2_s1jAx] \r [ww1_s1jAz]
                                    let {
                                      sat_s1jAC [Occ=Once, Dmd=<L,1*U(U)>] :: GHC.Types.Int
                                      [LclId] =
                                          [wild1_s1jAv wild2_s1jAx] \s []
                                              case >=# [wild2_s1jAx 0#] of {
                                                __DEFAULT ->
                                                    case negateInt# [wild2_s1jAx] of sat_s1jAB {
                                                      __DEFAULT -> GHC.Types.I# [sat_s1jAB];
                                                    };
                                                1# -> wild1_s1jAv;
                                              };
                                    } in 
                                      case GHC.Real.$wgcd' sat_s1jAC ww1_s1jAz of {
                                        GHC.Types.I# x1_s1jAE [Occ=Once!] ->
                                            case x1_s1jAE of wild4_s1jAF {
                                              __DEFAULT ->
                                                  case
                                                      quotInt# [wild2_s1jAx wild4_s1jAF]
                                                  of
                                                  wild5_s1jAG
                                                  { __DEFAULT ->
                                                        case
                                                            *# [wild5_s1jAG wild_s1jAu]
                                                        of
                                                        x2_s1jAH [Dmd=<S,U>]
                                                        { __DEFAULT ->
                                                              case >=# [x2_s1jAH 0#] of {
                                                                __DEFAULT -> negateInt# [x2_s1jAH];
                                                                1# -> x2_s1jAH;
                                                              };
                                                        };
                                                  };
                                              -1# ->
                                                  case wild2_s1jAx of wild5_s1jAJ {
                                                    __DEFAULT ->
                                                        case
                                                            quotInt# [wild5_s1jAJ -1#]
                                                        of
                                                        sat_s1jAL
                                                        { __DEFAULT ->
                                                              case
                                                                  *# [sat_s1jAL wild_s1jAu]
                                                              of
                                                              x2_s1jAK [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case >=# [x2_s1jAK 0#] of {
                                                                      __DEFAULT ->
                                                                          negateInt# [x2_s1jAK];
                                                                      1# -> x2_s1jAK;
                                                                    };
                                                              };
                                                        };
                                                    -9223372036854775808# -> GHC.Real.overflowError;
                                                  };
                                              0# -> GHC.Real.divZeroError;
                                            };
                                      };
                          } in 
                            case >=# [wild_s1jAu 0#] of {
                              __DEFAULT ->
                                  case negateInt# [wild_s1jAu] of sat_s1jAQ {
                                    __DEFAULT -> $j_s1jAy sat_s1jAQ;
                                  };
                              1# -> $j_s1jAy wild_s1jAu;
                            };
                      0# -> 0#;
                    };
              };
          0# -> 0#;
        };

GHC.Real.lcm_$slcm1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1jAR w1_s1jAS]
        case w1_s1jAS of {
          GHC.Types.I# ww1_s1jAU [Occ=Once] ->
              case GHC.Real.$w$slcm1 w_s1jAR ww1_s1jAU of ww2_s1jAV {
                __DEFAULT -> GHC.Types.I# [ww2_s1jAV];
              };
        };

GHC.Real.lcm [InlPrag=NOINLINE[1]]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(SS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,1*C1(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,1*C1(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1jAW eta_s1jAX eta1_s1jAY]
        case
            GHC.Real.$p1Integral $dIntegral_s1jAW
        of
        $dReal_s1jAZ [Dmd=<S(SS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,1*C1(C1(U)),A,1*C1(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1jAZ
              of
              $dNum_s1jB0 [Dmd=<S,U(A,A,1*C1(C1(U)),A,1*C1(U),A,C(U))>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p2Real $dReal_s1jAZ
                    of
                    $dOrd_s1jB1 [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                    { __DEFAULT ->
                          case
                              GHC.Classes.$p1Ord $dOrd_s1jB1
                          of
                          $dEq_s1jB2 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                          { __DEFAULT ->
                                let {
                                  sat_s1jB3 [Occ=Once] :: a_a1epg
                                  [LclId] =
                                      [$dNum_s1jB0] \u []
                                          GHC.Num.fromInteger $dNum_s1jB0 GHC.Real.even1;
                                } in 
                                  case GHC.Classes.== $dEq_s1jB2 eta1_s1jAY sat_s1jB3 of {
                                    GHC.Types.False ->
                                        let {
                                          sat_s1jB5 [Occ=Once] :: a_a1epg
                                          [LclId] =
                                              [$dNum_s1jB0] \u []
                                                  GHC.Num.fromInteger $dNum_s1jB0 GHC.Real.even1;
                                        } in 
                                          case GHC.Classes.== $dEq_s1jB2 eta_s1jAX sat_s1jB5 of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_s1jB9 [Occ=Once] :: a_a1epg
                                                  [LclId] =
                                                      [$dIntegral_s1jAW
                                                       eta_s1jAX
                                                       eta1_s1jAY
                                                       $dNum_s1jB0] \u []
                                                          let {
                                                            sat_s1jB8 [Occ=Once] :: a_a1epg
                                                            [LclId] =
                                                                [$dIntegral_s1jAW
                                                                 eta_s1jAX
                                                                 eta1_s1jAY] \u []
                                                                    let {
                                                                      sat_s1jB7 [Occ=Once]
                                                                        :: a_a1epg
                                                                      [LclId] =
                                                                          [$dIntegral_s1jAW
                                                                           eta_s1jAX
                                                                           eta1_s1jAY] \u []
                                                                              GHC.Real.gcd
                                                                                  $dIntegral_s1jAW
                                                                                  eta_s1jAX
                                                                                  eta1_s1jAY;
                                                                    } in 
                                                                      GHC.Real.quot
                                                                          $dIntegral_s1jAW
                                                                          eta_s1jAX
                                                                          sat_s1jB7;
                                                          } in 
                                                            GHC.Num.*
                                                                $dNum_s1jB0 sat_s1jB8 eta1_s1jAY;
                                                } in  GHC.Num.abs $dNum_s1jB0 sat_s1jB9;
                                            GHC.Types.True ->
                                                GHC.Num.fromInteger $dNum_s1jB0 GHC.Real.even1;
                                          };
                                    GHC.Types.True ->
                                        GHC.Num.fromInteger $dNum_s1jB0 GHC.Real.even1;
                                  };
                          };
                    };
              };
        };

GHC.Real.$w$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => GHC.Types.Int -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [w_s1jBa w1_s1jBb]
        case
            GHC.Real.$p1Integral w_s1jBa
        of
        $dReal_s1jBc [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1jBc
              of
              $dNum_s1jBd [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
              { __DEFAULT ->
                    let {
                      sat_s1jBg [Occ=Once] :: GHC.Integer.Type.Integer
                      [LclId] =
                          [w1_s1jBb] \u []
                              case w1_s1jBb of {
                                GHC.Types.I# i_s1jBf [Occ=Once] ->
                                    GHC.Integer.Type.smallInteger i_s1jBf;
                              };
                    } in 
                      case GHC.Num.fromInteger $dNum_s1jBd sat_s1jBg of dt_s1jBh {
                        __DEFAULT ->
                            case
                                GHC.Num.fromInteger $dNum_s1jBd GHC.Real.$fEnumRatio1
                            of
                            dt1_s1jBi
                            { __DEFAULT -> (#,#) [dt_s1jBh dt1_s1jBi];
                            };
                      };
              };
        };

GHC.Real.$fEnumRatio_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Types.Int -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jBj w1_s1jBk]
        case GHC.Real.$w$ctoEnum w_s1jBj w1_s1jBk of {
          (#,#) ww1_s1jBm [Occ=Once] ww2_s1jBn [Occ=Once] ->
              GHC.Real.:% [ww1_s1jBm ww2_s1jBn];
        };

GHC.Real.$fEnumRatio_$s$fEnumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Enum.Enum (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Enum! [GHC.Real.$fEnumRatio_$s$csucc
                                    GHC.Real.$fEnumRatio_$s$cpred
                                    GHC.Real.$fEnumRatio_$ctoRational
                                    GHC.Real.$fEnumRatio_$s$cfromEnum
                                    GHC.Real.$fEnumRatio_$snumericEnumFrom
                                    GHC.Real.$fEnumRatio_$snumericEnumFromThen
                                    GHC.Real.$fEnumRatio_$snumericEnumFromTo
                                    GHC.Real.$fEnumRatio_$snumericEnumFromThenTo];

GHC.Real.$fEnumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Enum.Enum (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,A))),A,C(U))>m] =
    [] \r [$dIntegral_s1jBo]
        let {
          sat_s1jBw [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0
               -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1jBo] \u []
                  GHC.Real.$fEnumRatio_$cenumFromThenTo $dIntegral_s1jBo; } in
        let {
          sat_s1jBv [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1jBo] \u []
                  GHC.Real.$fEnumRatio_$cenumFromTo $dIntegral_s1jBo; } in
        let {
          sat_s1jBu [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1jBo] \u []
                  GHC.Real.$fEnumRatio_$cenumFromThen $dIntegral_s1jBo; } in
        let {
          sat_s1jBt [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1jBo] \u []
                  GHC.Real.$fEnumRatio_$cenumFrom $dIntegral_s1jBo; } in
        let {
          sat_s1jBs [Occ=Once] :: GHC.Real.Ratio a_a1eE0 -> GHC.Types.Int
          [LclId] =
              [$dIntegral_s1jBo] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$cfromEnum $dIntegral_s1jBo eta_B1; } in
        let {
          sat_s1jBr [Occ=Once] :: GHC.Types.Int -> GHC.Real.Ratio a_a1eE0
          [LclId] =
              [$dIntegral_s1jBo] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$ctoEnum $dIntegral_s1jBo eta_B1; } in
        let {
          sat_s1jBq [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0 -> GHC.Real.Ratio a_a1eE0
          [LclId] =
              [$dIntegral_s1jBo] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$cpred $dIntegral_s1jBo eta_B1; } in
        let {
          sat_s1jBp [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0 -> GHC.Real.Ratio a_a1eE0
          [LclId] =
              [$dIntegral_s1jBo] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$csucc $dIntegral_s1jBo eta_B1;
        } in 
          GHC.Enum.C:Enum [sat_s1jBp
                           sat_s1jBq
                           sat_s1jBr
                           sat_s1jBs
                           sat_s1jBt
                           sat_s1jBu
                           sat_s1jBv
                           sat_s1jBw];

$wg_r1j3P
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><S,U><S,U>,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s1jBx ww1_s1jBy ww2_s1jBz]
        case remInt# [ww1_s1jBy 2#] of {
          __DEFAULT ->
              case ww1_s1jBy of wild1_s1jBB {
                __DEFAULT ->
                    case *# [ww_s1jBx ww2_s1jBz] of sat_s1jBE {
                      __DEFAULT ->
                          case quotInt# [wild1_s1jBB 2#] of sat_s1jBD {
                            __DEFAULT ->
                                case *# [ww_s1jBx ww_s1jBx] of sat_s1jBC {
                                  __DEFAULT -> $wg_r1j3P sat_s1jBC sat_s1jBD sat_s1jBE;
                                };
                          };
                    };
                1# -> *# [ww_s1jBx ww2_s1jBz];
              };
          0# ->
              case quotInt# [ww1_s1jBy 2#] of sat_s1jBG {
                __DEFAULT ->
                    case *# [ww_s1jBx ww_s1jBx] of sat_s1jBF {
                      __DEFAULT -> $wg_r1j3P sat_s1jBF sat_s1jBG ww2_s1jBz;
                    };
              };
        };

GHC.Real.$wf1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1jBH ww1_s1jBI]
        case remInt# [ww1_s1jBI 2#] of {
          __DEFAULT ->
              case ww1_s1jBI of wild1_s1jBK {
                __DEFAULT ->
                    case quotInt# [wild1_s1jBK 2#] of sat_s1jBM {
                      __DEFAULT ->
                          case *# [ww_s1jBH ww_s1jBH] of sat_s1jBL {
                            __DEFAULT -> $wg_r1j3P sat_s1jBL sat_s1jBM ww_s1jBH;
                          };
                    };
                1# -> ww_s1jBH;
              };
          0# ->
              case quotInt# [ww1_s1jBI 2#] of sat_s1jBO {
                __DEFAULT ->
                    case *# [ww_s1jBH ww_s1jBH] of sat_s1jBN {
                      __DEFAULT -> GHC.Real.$wf1 sat_s1jBN sat_s1jBO;
                    };
              };
        };

GHC.Real.^_f2 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1jBP w1_s1jBQ]
        case w_s1jBP of {
          GHC.Types.I# ww1_s1jBS [Occ=Once] ->
              case w1_s1jBQ of {
                GHC.Types.I# ww3_s1jBU [Occ=Once] ->
                    case GHC.Real.$wf1 ww1_s1jBS ww3_s1jBU of ww4_s1jBV {
                      __DEFAULT -> GHC.Types.I# [ww4_s1jBV];
                    };
              };
        };

GHC.Real.^3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

GHC.Real.^2 :: GHC.Types.Int
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1jBW {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1jBW;
        };

GHC.Real.^_$s^2 [InlPrag=NOUSERINLINE[1]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [x0_s1jBX y0_s1jBY]
        case y0_s1jBY of {
          GHC.Types.I# x_s1jC0 ->
              case <# [x_s1jC0 0#] of {
                __DEFAULT ->
                    case x_s1jC0 of wild1_s1jC2 {
                      __DEFAULT ->
                          case x0_s1jBX of {
                            GHC.Types.I# ww1_s1jC4 [Occ=Once] ->
                                case GHC.Real.$wf1 ww1_s1jC4 wild1_s1jC2 of ww2_s1jC5 {
                                  __DEFAULT -> GHC.Types.I# [ww2_s1jC5];
                                };
                          };
                      0# -> GHC.Real.^3;
                    };
                1# -> GHC.Real.^2;
              };
        };

$wg1_r1j3Q
  :: GHC.Integer.Type.Integer
     -> GHC.Prim.Int#
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
[GblId, Arity=3, Str=<S,U><S,U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_s1jC6 ww_s1jC7 w1_s1jC8]
        case remInt# [ww_s1jC7 2#] of {
          __DEFAULT ->
              case ww_s1jC7 of wild1_s1jCa {
                __DEFAULT ->
                    case GHC.Integer.Type.timesInteger w_s1jC6 w1_s1jC8 of sat_s1jCd {
                      __DEFAULT ->
                          case quotInt# [wild1_s1jCa 2#] of sat_s1jCc {
                            __DEFAULT ->
                                case GHC.Integer.Type.timesInteger w_s1jC6 w_s1jC6 of sat_s1jCb {
                                  __DEFAULT -> $wg1_r1j3Q sat_s1jCb sat_s1jCc sat_s1jCd;
                                };
                          };
                    };
                1# -> GHC.Integer.Type.timesInteger w_s1jC6 w1_s1jC8;
              };
          0# ->
              case quotInt# [ww_s1jC7 2#] of sat_s1jCf {
                __DEFAULT ->
                    case GHC.Integer.Type.timesInteger w_s1jC6 w_s1jC6 of sat_s1jCe {
                      __DEFAULT -> $wg1_r1j3Q sat_s1jCe sat_s1jCf w1_s1jC8;
                    };
              };
        };

GHC.Real.$wf [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Prim.Int# -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [w_s1jCg ww_s1jCh]
        case remInt# [ww_s1jCh 2#] of {
          __DEFAULT ->
              case ww_s1jCh of wild1_s1jCj {
                __DEFAULT ->
                    case quotInt# [wild1_s1jCj 2#] of sat_s1jCl {
                      __DEFAULT ->
                          case GHC.Integer.Type.timesInteger w_s1jCg w_s1jCg of sat_s1jCk {
                            __DEFAULT -> $wg1_r1j3Q sat_s1jCk sat_s1jCl w_s1jCg;
                          };
                    };
                1# -> w_s1jCg;
              };
          0# ->
              case quotInt# [ww_s1jCh 2#] of sat_s1jCn {
                __DEFAULT ->
                    case GHC.Integer.Type.timesInteger w_s1jCg w_s1jCg of sat_s1jCm {
                      __DEFAULT -> GHC.Real.$wf sat_s1jCm sat_s1jCn;
                    };
              };
        };

GHC.Real.^_f1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [w_s1jCo w1_s1jCp]
        case w1_s1jCp of {
          GHC.Types.I# ww1_s1jCr [Occ=Once] ->
              GHC.Real.$wf w_s1jCo ww1_s1jCr;
        };

GHC.Real.^_$s^1 [InlPrag=NOUSERINLINE[1]]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<L,U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x0_s1jCs y0_s1jCt]
        case y0_s1jCt of {
          GHC.Types.I# x_s1jCv ->
              case <# [x_s1jCv 0#] of {
                __DEFAULT ->
                    case x_s1jCv of wild1_s1jCx {
                      __DEFAULT -> GHC.Real.$wf x0_s1jCs wild1_s1jCx;
                      0# -> GHC.Real.$fEnumRatio1;
                    };
                1# -> GHC.Real.^1;
              };
        };

lvl6_r1j3R :: GHC.Real.Rational
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1jCy {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1jCy;
        };

lvl7_r1j3S :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1jCz {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1jCz;
        };

GHC.Real.^ [InlPrag=INLINABLE[1]]
  :: forall a b. (GHC.Num.Num a, GHC.Real.Integral b) => a -> b -> a
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))><S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s1jCA $dIntegral_s1jCB eta_s1jCC eta1_s1jCD]
        case
            GHC.Real.$p1Integral $dIntegral_s1jCB
        of
        $dReal_s1jCE [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum1_s1jCF [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num b_a1eqq
                [LclId] =
                    [$dReal_s1jCE] \u [] GHC.Real.$p1Real $dReal_s1jCE;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1jCE
                of
                $dOrd_s1jCG [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1jCH [Occ=Once] :: b_a1eqq
                        [LclId] =
                            [$dNum1_s1jCF] \u []
                                GHC.Num.fromInteger $dNum1_s1jCF GHC.Real.even1;
                      } in 
                        case GHC.Classes.< $dOrd_s1jCG eta1_s1jCD sat_s1jCH of {
                          GHC.Types.False ->
                              let {
                                sat_s1jCK [Occ=Once] :: b_a1eqq
                                [LclId] =
                                    [$dNum1_s1jCF] \u []
                                        GHC.Num.fromInteger $dNum1_s1jCF GHC.Real.even1;
                              } in 
                                case GHC.Classes.$p1Ord $dOrd_s1jCG of sat_s1jCJ {
                                  __DEFAULT ->
                                      case GHC.Classes.== sat_s1jCJ eta1_s1jCD sat_s1jCK of {
                                        GHC.Types.False ->
                                            let {
                                              lvl8_s1jCM :: b_a1eqq
                                              [LclId] =
                                                  [$dNum1_s1jCF] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum1_s1jCF GHC.Real.even2;
                                            } in 
                                              let-no-escape {
                                                exit_s1jCN [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                                  :: a_a1eqp -> b_a1eqq -> a_a1eqp
                                                [LclId[JoinId(2)],
                                                 Arity=2,
                                                 Str=<L,U><L,U>,
                                                 Unf=OtherCon []] =
                                                    sat-only [$dNum_s1jCA
                                                              $dIntegral_s1jCB
                                                              $dNum1_s1jCF
                                                              $dOrd_s1jCG
                                                              lvl8_s1jCM] \r [x_s1jCO y_s1jCP]
                                                        case
                                                            GHC.Classes.$p1Ord $dOrd_s1jCG
                                                        of
                                                        $dEq_s1jCQ [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                                        { __DEFAULT ->
                                                              let {
                                                                lvl9_s1jCR :: b_a1eqq
                                                                [LclId] =
                                                                    [$dNum1_s1jCF] \u []
                                                                        GHC.Num.fromInteger
                                                                            $dNum1_s1jCF
                                                                            GHC.Real.$fEnumRatio1;
                                                              } in 
                                                                case
                                                                    GHC.Classes.==
                                                                        $dEq_s1jCQ
                                                                        y_s1jCP
                                                                        lvl9_s1jCR
                                                                of
                                                                { GHC.Types.False ->
                                                                      let {
                                                                        sat_s1jD8 [Occ=Once]
                                                                          :: b_a1eqq
                                                                        [LclId] =
                                                                            [$dIntegral_s1jCB
                                                                             lvl8_s1jCM
                                                                             y_s1jCP] \u []
                                                                                GHC.Real.quot
                                                                                    $dIntegral_s1jCB
                                                                                    y_s1jCP
                                                                                    lvl8_s1jCM; } in
                                                                      let {
                                                                        sat_s1jD7 [Occ=Once]
                                                                          :: a_a1eqp
                                                                        [LclId] =
                                                                            [$dNum_s1jCA
                                                                             x_s1jCO] \u []
                                                                                GHC.Num.*
                                                                                    $dNum_s1jCA
                                                                                    x_s1jCO
                                                                                    x_s1jCO;
                                                                      } in 
                                                                        let-no-escape {
                                                                          exit1_s1jCT [Occ=OnceL!T[2],
                                                                                       Dmd=<C(C(S)),C(C1(U))>]
                                                                            :: a_a1eqp
                                                                               -> a_a1eqp -> a_a1eqp
                                                                          [LclId[JoinId(2)],
                                                                           Arity=2,
                                                                           Str=<L,U><L,U>,
                                                                           Unf=OtherCon []] =
                                                                              sat-only [$dNum_s1jCA] \r [x1_s1jCU
                                                                                                         z_s1jCV]
                                                                                  GHC.Num.*
                                                                                      $dNum_s1jCA
                                                                                      x1_s1jCU
                                                                                      z_s1jCV;
                                                                        } in 
                                                                          let-no-escape {
                                                                            g1_s1jCW [Occ=LoopBreakerT[3]]
                                                                              :: a_a1eqp
                                                                                 -> b_a1eqq
                                                                                 -> a_a1eqp
                                                                                 -> a_a1eqp
                                                                            [LclId[JoinId(3)],
                                                                             Arity=3,
                                                                             Str=<L,U><L,U><L,U>,
                                                                             Unf=OtherCon []] =
                                                                                sat-only [$dNum_s1jCA
                                                                                          $dIntegral_s1jCB
                                                                                          lvl8_s1jCM
                                                                                          $dEq_s1jCQ
                                                                                          lvl9_s1jCR
                                                                                          exit1_s1jCT
                                                                                          g1_s1jCW] \r [x1_s1jCX
                                                                                                        y1_s1jCY
                                                                                                        z_s1jCZ]
                                                                                    case
                                                                                        GHC.Real.even
                                                                                            $dIntegral_s1jCB
                                                                                            y1_s1jCY
                                                                                    of
                                                                                    { GHC.Types.False ->
                                                                                          case
                                                                                              GHC.Classes.==
                                                                                                  $dEq_s1jCQ
                                                                                                  y1_s1jCY
                                                                                                  lvl9_s1jCR
                                                                                          of
                                                                                          { GHC.Types.False ->
                                                                                                let {
                                                                                                  sat_s1jD4 [Occ=Once]
                                                                                                    :: a_a1eqp
                                                                                                  [LclId] =
                                                                                                      [$dNum_s1jCA
                                                                                                       x1_s1jCX
                                                                                                       z_s1jCZ] \u []
                                                                                                          GHC.Num.*
                                                                                                              $dNum_s1jCA
                                                                                                              x1_s1jCX
                                                                                                              z_s1jCZ; } in
                                                                                                let {
                                                                                                  sat_s1jD3 [Occ=Once]
                                                                                                    :: b_a1eqq
                                                                                                  [LclId] =
                                                                                                      [$dIntegral_s1jCB
                                                                                                       lvl8_s1jCM
                                                                                                       y1_s1jCY] \u []
                                                                                                          GHC.Real.quot
                                                                                                              $dIntegral_s1jCB
                                                                                                              y1_s1jCY
                                                                                                              lvl8_s1jCM; } in
                                                                                                let {
                                                                                                  sat_s1jD2 [Occ=Once]
                                                                                                    :: a_a1eqp
                                                                                                  [LclId] =
                                                                                                      [$dNum_s1jCA
                                                                                                       x1_s1jCX] \u []
                                                                                                          GHC.Num.*
                                                                                                              $dNum_s1jCA
                                                                                                              x1_s1jCX
                                                                                                              x1_s1jCX;
                                                                                                } in 
                                                                                                  g1_s1jCW
                                                                                                      sat_s1jD2
                                                                                                      sat_s1jD3
                                                                                                      sat_s1jD4;
                                                                                            GHC.Types.True ->
                                                                                                exit1_s1jCT
                                                                                                    x1_s1jCX
                                                                                                    z_s1jCZ;
                                                                                          };
                                                                                      GHC.Types.True ->
                                                                                          let {
                                                                                            sat_s1jD6 [Occ=Once]
                                                                                              :: b_a1eqq
                                                                                            [LclId] =
                                                                                                [$dIntegral_s1jCB
                                                                                                 lvl8_s1jCM
                                                                                                 y1_s1jCY] \u []
                                                                                                    GHC.Real.quot
                                                                                                        $dIntegral_s1jCB
                                                                                                        y1_s1jCY
                                                                                                        lvl8_s1jCM; } in
                                                                                          let {
                                                                                            sat_s1jD5 [Occ=Once]
                                                                                              :: a_a1eqp
                                                                                            [LclId] =
                                                                                                [$dNum_s1jCA
                                                                                                 x1_s1jCX] \u []
                                                                                                    GHC.Num.*
                                                                                                        $dNum_s1jCA
                                                                                                        x1_s1jCX
                                                                                                        x1_s1jCX;
                                                                                          } in 
                                                                                            g1_s1jCW
                                                                                                sat_s1jD5
                                                                                                sat_s1jD6
                                                                                                z_s1jCZ;
                                                                                    };
                                                                          } in 
                                                                            g1_s1jCW
                                                                                sat_s1jD7
                                                                                sat_s1jD8
                                                                                x_s1jCO;
                                                                  GHC.Types.True -> x_s1jCO;
                                                                };
                                                        };
                                              } in 
                                                let-no-escape {
                                                  f_s1jD9 [Occ=LoopBreakerT[2]]
                                                    :: a_a1eqp -> b_a1eqq -> a_a1eqp
                                                  [LclId[JoinId(2)],
                                                   Arity=2,
                                                   Str=<L,U><L,U>,
                                                   Unf=OtherCon []] =
                                                      sat-only [$dNum_s1jCA
                                                                $dIntegral_s1jCB
                                                                lvl8_s1jCM
                                                                exit_s1jCN
                                                                f_s1jD9] \r [x_s1jDa y_s1jDb]
                                                          case
                                                              GHC.Real.even $dIntegral_s1jCB y_s1jDb
                                                          of
                                                          { GHC.Types.False ->
                                                                exit_s1jCN x_s1jDa y_s1jDb;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_s1jDe [Occ=Once] :: b_a1eqq
                                                                  [LclId] =
                                                                      [$dIntegral_s1jCB
                                                                       lvl8_s1jCM
                                                                       y_s1jDb] \u []
                                                                          GHC.Real.quot
                                                                              $dIntegral_s1jCB
                                                                              y_s1jDb
                                                                              lvl8_s1jCM; } in
                                                                let {
                                                                  sat_s1jDd [Occ=Once] :: a_a1eqp
                                                                  [LclId] =
                                                                      [$dNum_s1jCA x_s1jDa] \u []
                                                                          GHC.Num.*
                                                                              $dNum_s1jCA
                                                                              x_s1jDa
                                                                              x_s1jDa;
                                                                } in  f_s1jD9 sat_s1jDd sat_s1jDe;
                                                          };
                                                } in  f_s1jD9 eta_s1jCC eta1_s1jCD;
                                        GHC.Types.True ->
                                            GHC.Num.fromInteger $dNum_s1jCA GHC.Real.$fEnumRatio1;
                                      };
                                };
                          GHC.Types.True -> lvl7_r1j3S;
                        };
                };
        };
GHC.Real.^%^ [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Rational -> a -> GHC.Real.Rational
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1jDf w1_s1jDg w2_s1jDh]
        case w1_s1jDg of {
          GHC.Real.:% ww1_s1jDj [Occ=Once] ww2_s1jDk [Occ=Once] ->
              case GHC.Real.$w^%^ w_s1jDf ww1_s1jDj ww2_s1jDk w2_s1jDh of {
                (#,#) ww4_s1jDm [Occ=Once] ww5_s1jDn [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jDm ww5_s1jDn];
              };
        };
GHC.Real.$w^%^ [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> a
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jDo ww_s1jDp ww1_s1jDq w1_s1jDr]
        case
            GHC.Real.$p1Integral w_s1jDo
        of
        $dReal_s1jDs [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jDt [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_s1hK5
                [LclId] =
                    [$dReal_s1jDs] \u [] GHC.Real.$p1Real $dReal_s1jDs;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1jDs
                of
                $dOrd_s1jDu [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1jDv [Occ=Once] :: a_s1hK5
                        [LclId] =
                            [$dNum_s1jDt] \u [] GHC.Num.fromInteger $dNum_s1jDt GHC.Real.even1;
                      } in 
                        case GHC.Classes.< $dOrd_s1jDu w1_s1jDr sat_s1jDv of {
                          GHC.Types.False ->
                              let {
                                sat_s1jDy [Occ=Once] :: a_s1hK5
                                [LclId] =
                                    [$dNum_s1jDt] \u []
                                        GHC.Num.fromInteger $dNum_s1jDt GHC.Real.even1;
                              } in 
                                case GHC.Classes.$p1Ord $dOrd_s1jDu of sat_s1jDx {
                                  __DEFAULT ->
                                      case GHC.Classes.== sat_s1jDx w1_s1jDr sat_s1jDy of {
                                        GHC.Types.False ->
                                            case
                                                GHC.Real.^
                                                    GHC.Num.$fNumInteger w_s1jDo ww_s1jDp w1_s1jDr
                                            of
                                            dt_s1jDA
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Real.^
                                                          GHC.Num.$fNumInteger
                                                          w_s1jDo
                                                          ww1_s1jDq
                                                          w1_s1jDr
                                                  of
                                                  dt1_s1jDB
                                                  { __DEFAULT -> (#,#) [dt_s1jDA dt1_s1jDB];
                                                  };
                                            };
                                        GHC.Types.True ->
                                            (#,#) [GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1];
                                      };
                                };
                          GHC.Types.True -> lvl6_r1j3R;
                        };
                };
        };

GHC.Real.$w^^%^^ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> a
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId,
 Arity=4,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLLLL),U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,1*C1(C1(U)),A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1jDD ww_s1jDE ww1_s1jDF w1_s1jDG]
        case
            GHC.Real.$p1Integral w_s1jDD
        of
        $dReal_s1jDH [Dmd=<S(LS(LLLLC(C(S))LLL)L),U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,1*C1(C1(U)),A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jDI [Dmd=<L,U(A,A,A,C(U),A,A,C(U))>] :: GHC.Num.Num a_s1hKi
                [LclId] =
                    [$dReal_s1jDH] \u [] GHC.Real.$p1Real $dReal_s1jDH;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1jDH
                of
                $dOrd_s1jDJ [Dmd=<S(LLLLC(C(S))LLL),U(1*U(1*C1(C1(U)),A),A,A,A,1*C1(C1(U)),A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1jDK [Occ=Once] :: a_s1hKi
                        [LclId] =
                            [$dNum_s1jDI] \u [] GHC.Num.fromInteger $dNum_s1jDI GHC.Real.even1;
                      } in 
                        case GHC.Classes.> $dOrd_s1jDJ w1_s1jDG sat_s1jDK of {
                          GHC.Types.False ->
                              let {
                                sat_s1jDN [Occ=Once] :: a_s1hKi
                                [LclId] =
                                    [$dNum_s1jDI] \u []
                                        GHC.Num.fromInteger $dNum_s1jDI GHC.Real.even1;
                              } in 
                                case GHC.Classes.$p1Ord $dOrd_s1jDJ of sat_s1jDM {
                                  __DEFAULT ->
                                      case GHC.Classes.== sat_s1jDM w1_s1jDG sat_s1jDN of {
                                        GHC.Types.False ->
                                            case
                                                GHC.Integer.Type.gtInteger# ww_s1jDE GHC.Real.even1
                                            of
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.eqInteger#
                                                          ww_s1jDE GHC.Real.even1
                                                  of
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_s1jDT [Occ=Once] :: a_s1hKi
                                                          [LclId] =
                                                              [w1_s1jDG $dNum_s1jDI] \u []
                                                                  GHC.Num.negate
                                                                      $dNum_s1jDI w1_s1jDG; } in
                                                        let {
                                                          sat_s1jDS [Occ=Once]
                                                            :: GHC.Integer.Type.Integer
                                                          [LclId] =
                                                              [ww_s1jDE] \u []
                                                                  GHC.Integer.Type.negateInteger
                                                                      ww_s1jDE;
                                                        } in 
                                                          case
                                                              GHC.Real.^
                                                                  GHC.Num.$fNumInteger
                                                                  w_s1jDD
                                                                  sat_s1jDS
                                                                  sat_s1jDT
                                                          of
                                                          dd_s1jDR [Dmd=<S,1*U>]
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1jDV [Occ=Once] :: a_s1hKi
                                                                  [LclId] =
                                                                      [w1_s1jDG $dNum_s1jDI] \u []
                                                                          GHC.Num.negate
                                                                              $dNum_s1jDI w1_s1jDG;
                                                                } in 
                                                                  case
                                                                      GHC.Real.^
                                                                          GHC.Num.$fNumInteger
                                                                          w_s1jDD
                                                                          ww1_s1jDF
                                                                          sat_s1jDV
                                                                  of
                                                                  nn_s1jDU [Dmd=<S,1*U>]
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Real.even
                                                                                w_s1jDD w1_s1jDG
                                                                        of
                                                                        { GHC.Types.False ->
                                                                              case
                                                                                  GHC.Integer.Type.negateInteger
                                                                                      nn_s1jDU
                                                                              of
                                                                              dt_s1jDX
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        dd_s1jDR
                                                                                    of
                                                                                    dt1_s1jDY
                                                                                    { __DEFAULT ->
                                                                                          (#,#) [dt_s1jDX
                                                                                                 dt1_s1jDY];
                                                                                    };
                                                                              };
                                                                          GHC.Types.True ->
                                                                              case
                                                                                  nn_s1jDU
                                                                              of
                                                                              dt_s1jDZ
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        dd_s1jDR
                                                                                    of
                                                                                    dt1_s1jE0
                                                                                    { __DEFAULT ->
                                                                                          (#,#) [dt_s1jDZ
                                                                                                 dt1_s1jE0];
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                          };
                                                    1# -> GHC.Real.ratioZeroDenominatorError;
                                                  };
                                              1# ->
                                                  let {
                                                    sat_s1jE2 [Occ=Once] :: a_s1hKi
                                                    [LclId] =
                                                        [w1_s1jDG $dNum_s1jDI] \u []
                                                            GHC.Num.negate $dNum_s1jDI w1_s1jDG;
                                                  } in 
                                                    case
                                                        GHC.Real.^
                                                            GHC.Num.$fNumInteger
                                                            w_s1jDD
                                                            ww1_s1jDF
                                                            sat_s1jE2
                                                    of
                                                    dt_s1jE3
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_s1jE4 [Occ=Once] :: a_s1hKi
                                                            [LclId] =
                                                                [w1_s1jDG $dNum_s1jDI] \u []
                                                                    GHC.Num.negate
                                                                        $dNum_s1jDI w1_s1jDG;
                                                          } in 
                                                            case
                                                                GHC.Real.^
                                                                    GHC.Num.$fNumInteger
                                                                    w_s1jDD
                                                                    ww_s1jDE
                                                                    sat_s1jE4
                                                            of
                                                            dt1_s1jE5
                                                            { __DEFAULT ->
                                                                  (#,#) [dt_s1jE3 dt1_s1jE5];
                                                            };
                                                    };
                                            };
                                        GHC.Types.True ->
                                            (#,#) [GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1];
                                      };
                                };
                          GHC.Types.True ->
                              case
                                  GHC.Real.^ GHC.Num.$fNumInteger w_s1jDD ww_s1jDE w1_s1jDG
                              of
                              dt_s1jE6
                              { __DEFAULT ->
                                    case
                                        GHC.Real.^ GHC.Num.$fNumInteger w_s1jDD ww1_s1jDF w1_s1jDG
                                    of
                                    dt1_s1jE7
                                    { __DEFAULT -> (#,#) [dt_s1jE6 dt1_s1jE7];
                                    };
                              };
                        };
                };
        };

GHC.Real.^^%^^ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Rational -> a -> GHC.Real.Rational
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLLLL),U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,C(C1(U)),A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1jE8 w1_s1jE9 w2_s1jEa]
        case w1_s1jE9 of {
          GHC.Real.:% ww1_s1jEc [Occ=Once] ww2_s1jEd [Occ=Once] ->
              case GHC.Real.$w^^%^^ w_s1jE8 ww1_s1jEc ww2_s1jEd w2_s1jEa of {
                (#,#) ww4_s1jEf [Occ=Once] ww5_s1jEg [Occ=Once] ->
                    GHC.Real.:% [ww4_s1jEf ww5_s1jEg];
              };
        };

GHC.Real.^^ [InlPrag=INLINABLE[1]]
  :: forall a b.
     (GHC.Real.Fractional a, GHC.Real.Integral b) =>
     a -> b -> a
[GblId,
 Arity=4,
 Str=<L,U(1*U(A,A,C(C1(U)),A,A,A,1*C1(U)),A,1*C1(U),A)><S(S(LS(LLLLLC(C(S))LL)L)LLLLLLLL),U(U(U(A,A,A,1*C1(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,1*C1(C1(U)),A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_s1jEh $dIntegral_s1jEi eta_s1jEj eta1_s1jEk]
        case
            GHC.Real.$p1Integral $dIntegral_s1jEi
        of
        $dReal_s1jEl [Dmd=<S(LS(LLLLLC(C(S))LL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,A,A,A,1*C1(C1(U)),A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1jEm [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>]
                  :: GHC.Num.Num b_a1etw
                [LclId] =
                    [$dReal_s1jEl] \u [] GHC.Real.$p1Real $dReal_s1jEl; } in
              let {
                sat_s1jEo [Occ=Once] :: b_a1etw
                [LclId] =
                    [$dNum_s1jEm] \u [] GHC.Num.fromInteger $dNum_s1jEm GHC.Real.even1;
              } in 
                case GHC.Real.$p2Real $dReal_s1jEl of sat_s1jEn {
                  __DEFAULT ->
                      case GHC.Classes.>= sat_s1jEn eta1_s1jEk sat_s1jEo of {
                        GHC.Types.False ->
                            let {
                              sat_s1jEs [Occ=Once] :: a_a1etv
                              [LclId] =
                                  [$dFractional_s1jEh
                                   $dIntegral_s1jEi
                                   eta_s1jEj
                                   eta1_s1jEk
                                   $dNum_s1jEm] \u []
                                      let {
                                        sat_s1jEr [Occ=Once] :: b_a1etw
                                        [LclId] =
                                            [eta1_s1jEk $dNum_s1jEm] \u []
                                                GHC.Num.negate $dNum_s1jEm eta1_s1jEk; } in
                                      let {
                                        sat_s1jEq [Occ=Once, Dmd=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>]
                                          :: GHC.Num.Num a_a1etv
                                        [LclId] =
                                            [$dFractional_s1jEh] \u []
                                                GHC.Real.$p1Fractional $dFractional_s1jEh;
                                      } in 
                                        GHC.Real.^ sat_s1jEq $dIntegral_s1jEi eta_s1jEj sat_s1jEr;
                            } in  GHC.Real.recip $dFractional_s1jEh sat_s1jEs;
                        GHC.Types.True ->
                            let {
                              sat_s1jEt [Occ=Once, Dmd=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>]
                                :: GHC.Num.Num a_a1etv
                              [LclId] =
                                  [$dFractional_s1jEh] \u []
                                      GHC.Real.$p1Fractional $dFractional_s1jEh;
                            } in  GHC.Real.^ sat_s1jEt $dIntegral_s1jEi eta_s1jEj eta1_s1jEk;
                      };
                };
        };

GHC.Real.C:Fractional
  :: forall a.
     GHC.Num.Num a =>
     (a -> a -> a)
     -> (a -> a) -> (GHC.Real.Rational -> a) -> GHC.Real.Fractional a
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Real.C:Fractional [eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Real.C:Integral
  :: forall a.
     (GHC.Real.Real a, GHC.Enum.Enum a) =>
     (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> (a, a))
     -> (a -> a -> (a, a))
     -> (a -> GHC.Integer.Type.Integer)
     -> GHC.Real.Integral a
[GblId[DataCon],
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B9
           eta_B8
           eta_B7
           eta_B6
           eta_B5
           eta_B4
           eta_B3
           eta_B2
           eta_B1]
        GHC.Real.C:Integral [eta_B9
                             eta_B8
                             eta_B7
                             eta_B6
                             eta_B5
                             eta_B4
                             eta_B3
                             eta_B2
                             eta_B1];

GHC.Real.C:Real
  :: forall a.
     (GHC.Num.Num a, GHC.Classes.Ord a) =>
     (a -> GHC.Real.Rational) -> GHC.Real.Real a
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Real.C:Real [eta_B3 eta_B2 eta_B1];

GHC.Real.C:RealFrac
  :: forall a.
     (GHC.Real.Real a, GHC.Real.Fractional a) =>
     (forall b. GHC.Real.Integral b => a -> (b, a))
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> GHC.Real.RealFrac a
[GblId[DataCon],
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Real.C:RealFrac [eta_B7
                             eta_B6
                             eta_B5
                             eta_B4
                             eta_B3
                             eta_B2
                             eta_B1];

GHC.Real.:% :: forall a. a -> a -> GHC.Real.Ratio a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Real.:% [eta_B2 eta_B1];


==================== Pre unarise: ====================
2018-03-16 15:56:15.574776067 UTC

GHC.Real.$p1Fractional
  :: forall a. GHC.Real.Fractional a => GHC.Num.Num a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_s1saL]
        case v_s1saL of {
          GHC.Real.C:Fractional v_s1saN [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_s1saN;
        };

GHC.Real./ :: forall a. GHC.Real.Fractional a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_s1saR]
        case v_s1saR of {
          GHC.Real.C:Fractional _ [Occ=Dead]
                                v_s1saU [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_s1saU;
        };

GHC.Real.recip :: forall a. GHC.Real.Fractional a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_s1saX]
        case v_s1saX of {
          GHC.Real.C:Fractional _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_s1sb1 [Occ=Once]
                                _ [Occ=Dead] ->
              v_s1sb1;
        };

GHC.Real.fromRational
  :: forall a. GHC.Real.Fractional a => GHC.Real.Rational -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_s1sb3]
        case v_s1sb3 of {
          GHC.Real.C:Fractional _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_s1sb8 [Occ=Once] ->
              v_s1sb8;
        };

GHC.Real.$p1Integral
  :: forall a. GHC.Real.Integral a => GHC.Real.Real a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLL),U(U,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1sb9]
        case v_s1sb9 of {
          GHC.Real.C:Integral v_s1sbb [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sbb;
        };

GHC.Real.$p2Integral
  :: forall a. GHC.Real.Integral a => GHC.Enum.Enum a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLL),U(A,U,A,A,A,A,A,A,A)>] =
    [] \r [v_s1sbk]
        case v_s1sbk of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              v_s1sbn [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sbn;
        };

GHC.Real.quot :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLL),U(A,A,U,A,A,A,A,A,A)>] =
    [] \r [v_s1sbv]
        case v_s1sbv of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sbz [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sbz;
        };

GHC.Real.rem :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLL),U(A,A,A,U,A,A,A,A,A)>] =
    [] \r [v_s1sbG]
        case v_s1sbG of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sbL [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sbL;
        };

GHC.Real.div :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLL),U(A,A,A,A,U,A,A,A,A)>] =
    [] \r [v_s1sbR]
        case v_s1sbR of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sbX [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sbX;
        };

GHC.Real.mod :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLL),U(A,A,A,A,A,U,A,A,A)>] =
    [] \r [v_s1sc2]
        case v_s1sc2 of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sc9 [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sc9;
        };

GHC.Real.quotRem
  :: forall a. GHC.Real.Integral a => a -> a -> (a, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLL),U(A,A,A,A,A,A,U,A,A)>] =
    [] \r [v_s1scd]
        case v_s1scd of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1scl [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1scl;
        };

GHC.Real.divMod
  :: forall a. GHC.Real.Integral a => a -> a -> (a, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSL),U(A,A,A,A,A,A,A,U,A)>] =
    [] \r [v_s1sco]
        case v_s1sco of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1scx [Occ=Once]
                              _ [Occ=Dead] ->
              v_s1scx;
        };

GHC.Real.toInteger
  :: forall a. GHC.Real.Integral a => a -> GHC.Integer.Type.Integer
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLS),U(A,A,A,A,A,A,A,A,U)>] =
    [] \r [v_s1scz]
        case v_s1scz of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1scJ [Occ=Once] ->
              v_s1scJ;
        };

GHC.Real.$p1Real :: forall a. GHC.Real.Real a => GHC.Num.Num a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_s1scK]
        case v_s1scK of {
          GHC.Real.C:Real v_s1scM [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
              v_s1scM;
        };

GHC.Real.$p2Real :: forall a. GHC.Real.Real a => GHC.Classes.Ord a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_s1scP]
        case v_s1scP of {
          GHC.Real.C:Real _ [Occ=Dead] v_s1scS [Occ=Once] _ [Occ=Dead] ->
              v_s1scS;
        };

GHC.Real.toRational
  :: forall a. GHC.Real.Real a => a -> GHC.Real.Rational
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_s1scU]
        case v_s1scU of {
          GHC.Real.C:Real _ [Occ=Dead] _ [Occ=Dead] v_s1scY [Occ=Once] ->
              v_s1scY;
        };

GHC.Real.$p1RealFrac
  :: forall a. GHC.Real.RealFrac a => GHC.Real.Real a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLL),U(U,A,A,A,A,A,A)>] =
    [] \r [v_s1scZ]
        case v_s1scZ of {
          GHC.Real.C:RealFrac v_s1sd1 [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sd1;
        };

GHC.Real.$p2RealFrac
  :: forall a. GHC.Real.RealFrac a => GHC.Real.Fractional a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLL),U(A,U,A,A,A,A,A)>] =
    [] \r [v_s1sd8]
        case v_s1sd8 of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              v_s1sdb [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sdb;
        };

GHC.Real.properFraction
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> (b, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLL),U(A,A,U,A,A,A,A)>] =
    [] \r [v_s1sdh]
        case v_s1sdh of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sdl [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sdl;
        };

GHC.Real.truncate
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLL),U(A,A,A,U,A,A,A)>] =
    [] \r [v_s1sdq]
        case v_s1sdq of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sdv [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sdv;
        };

GHC.Real.round
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLL),U(A,A,A,A,U,A,A)>] =
    [] \r [v_s1sdz]
        case v_s1sdz of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sdF [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sdF;
        };

GHC.Real.ceiling
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSL),U(A,A,A,A,A,U,A)>] =
    [] \r [v_s1sdI]
        case v_s1sdI of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sdP [Occ=Once]
                              _ [Occ=Dead] ->
              v_s1sdP;
        };

GHC.Real.floor
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLS),U(A,A,A,A,A,A,U)>] =
    [] \r [v_s1sdR]
        case v_s1sdR of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sdZ [Occ=Once] ->
              v_s1sdZ;
        };

GHC.Real.$W:% [InlPrag=INLINE[2]]
  :: forall a. a -> a -> GHC.Real.Ratio a
[GblId[DataConWrapper],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>m,
 Unf=OtherCon []] =
    [] \r [dt_s1se0 dt_s1se1]
        case dt_s1se0 of dt_s1se2 {
          __DEFAULT ->
              case dt_s1se1 of dt_s1se3 {
                __DEFAULT -> GHC.Real.:% [dt_s1se2 dt_s1se3];
              };
        };

GHC.Real.$fOrdRatio_$s$c< [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1se4 w1_s1se5]
        case w_s1se4 of {
          GHC.Real.:% ww1_s1se7 [Occ=Once] ww2_s1se8 [Occ=Once] ->
              case w1_s1se5 of {
                GHC.Real.:% ww4_s1sea [Occ=Once] ww5_s1seb [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1sea ww2_s1se8
                    of
                    sat_s1sed
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1se7 ww5_s1seb
                          of
                          sat_s1sec
                          { __DEFAULT ->
                                case
                                    GHC.Integer.Type.ltInteger# sat_s1sec sat_s1sed
                                of
                                wild_s1see
                                { __DEFAULT -> tagToEnum# [wild_s1see];
                                };
                          };
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$c<= [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sef w1_s1seg]
        case w_s1sef of {
          GHC.Real.:% ww1_s1sei [Occ=Once] ww2_s1sej [Occ=Once] ->
              case w1_s1seg of {
                GHC.Real.:% ww4_s1sel [Occ=Once] ww5_s1sem [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1sel ww2_s1sej
                    of
                    sat_s1seo
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1sei ww5_s1sem
                          of
                          sat_s1sen
                          { __DEFAULT ->
                                case
                                    GHC.Integer.Type.leInteger# sat_s1sen sat_s1seo
                                of
                                wild_s1sep
                                { __DEFAULT -> tagToEnum# [wild_s1sep];
                                };
                          };
                    };
              };
        };

GHC.Real.$w$s$ccompare [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Types.Ordering
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1seq ww1_s1ser ww2_s1ses ww3_s1set]
        case GHC.Integer.Type.eqInteger# ww_s1seq ww2_s1ses of wild_s1seu {
          __DEFAULT ->
              let-no-escape {
                $j_s1sev [Occ=Once*T[0], Dmd=<L,1*U>] :: GHC.Types.Ordering
                [LclId[JoinId(0)], Unf=OtherCon []] =
                    [ww_s1seq ww1_s1ser ww2_s1ses ww3_s1set] \r []
                        case
                            GHC.Integer.Type.timesInteger ww2_s1ses ww1_s1ser
                        of
                        sat_s1sex
                        { __DEFAULT ->
                              case
                                  GHC.Integer.Type.timesInteger ww_s1seq ww3_s1set
                              of
                              sat_s1sew
                              { __DEFAULT ->
                                    case GHC.Integer.Type.leInteger# sat_s1sew sat_s1sex of {
                                      __DEFAULT -> GHC.Types.GT [];
                                      1# -> GHC.Types.LT [];
                                    };
                              };
                        };
              } in 
                case wild_s1seu of {
                  __DEFAULT -> $j_s1sev;
                  1# ->
                      case GHC.Integer.Type.eqInteger# ww1_s1ser ww3_s1set of {
                        __DEFAULT -> $j_s1sev;
                        1# -> GHC.Types.EQ [];
                      };
                };
        };

GHC.Real.$fEnumRatio_$s$ccompare [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1seB w1_s1seC]
        case w_s1seB of {
          GHC.Real.:% ww1_s1seE [Occ=Once] ww2_s1seF [Occ=Once] ->
              case w1_s1seC of {
                GHC.Real.:% ww4_s1seH [Occ=Once] ww5_s1seI [Occ=Once] ->
                    GHC.Real.$w$s$ccompare ww1_s1seE ww2_s1seF ww4_s1seH ww5_s1seI;
              };
        };

GHC.Real.$fEnumRatio_$s$c>=
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [x_s1seJ y_s1seK]
        case x_s1seJ of {
          GHC.Real.:% ww1_s1seM [Occ=Once] ww2_s1seN [Occ=Once] ->
              case y_s1seK of {
                GHC.Real.:% ww4_s1seP [Occ=Once] ww5_s1seQ [Occ=Once] ->
                    case
                        GHC.Real.$w$s$ccompare ww1_s1seM ww2_s1seN ww4_s1seP ww5_s1seQ
                    of
                    { __DEFAULT -> GHC.Types.True [];
                      GHC.Types.LT -> GHC.Types.False [];
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$c>
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [x_s1seS y_s1seT]
        case x_s1seS of {
          GHC.Real.:% ww1_s1seV [Occ=Once] ww2_s1seW [Occ=Once] ->
              case y_s1seT of {
                GHC.Real.:% ww4_s1seY [Occ=Once] ww5_s1seZ [Occ=Once] ->
                    case
                        GHC.Real.$w$s$ccompare ww1_s1seV ww2_s1seW ww4_s1seY ww5_s1seZ
                    of
                    { __DEFAULT -> GHC.Types.False [];
                      GHC.Types.GT -> GHC.Types.True [];
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$cmin
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_s1sf1 y_s1sf2]
        case x_s1sf1 of ww_s1sf3 {
          GHC.Real.:% ww1_s1sf4 [Occ=Once] ww2_s1sf5 [Occ=Once] ->
              case y_s1sf2 of ww3_s1sf6 {
                GHC.Real.:% ww4_s1sf7 [Occ=Once] ww5_s1sf8 [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1sf7 ww2_s1sf5
                    of
                    sat_s1sfa
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1sf4 ww5_s1sf8
                          of
                          sat_s1sf9
                          { __DEFAULT ->
                                case GHC.Integer.Type.leInteger# sat_s1sf9 sat_s1sfa of {
                                  __DEFAULT -> ww3_s1sf6;
                                  1# -> ww_s1sf3;
                                };
                          };
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$cmax
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_s1sfc y_s1sfd]
        case x_s1sfc of ww_s1sfe {
          GHC.Real.:% ww1_s1sff [Occ=Once] ww2_s1sfg [Occ=Once] ->
              case y_s1sfd of ww3_s1sfh {
                GHC.Real.:% ww4_s1sfi [Occ=Once] ww5_s1sfj [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1sfi ww2_s1sfg
                    of
                    sat_s1sfl
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1sff ww5_s1sfj
                          of
                          sat_s1sfk
                          { __DEFAULT ->
                                case GHC.Integer.Type.leInteger# sat_s1sfk sat_s1sfl of {
                                  __DEFAULT -> ww_s1sfe;
                                  1# -> ww3_s1sfh;
                                };
                          };
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$cnegate
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1sfn]
        case ds_s1sfn of {
          GHC.Real.:% x_s1sfp [Occ=Once] y_s1sfq [Occ=Once] ->
              case GHC.Integer.Type.negateInteger x_s1sfp of dt_s1sfr {
                __DEFAULT -> GHC.Real.:% [dt_s1sfr y_s1sfq];
              };
        };

GHC.Real.$fFractionalRatio_$s$cabs
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1sfs]
        case ds_s1sfs of {
          GHC.Real.:% x_s1sfu [Occ=Once] y_s1sfv [Occ=Once] ->
              case GHC.Integer.Type.absInteger x_s1sfu of dt_s1sfw {
                __DEFAULT -> GHC.Real.:% [dt_s1sfw y_s1sfv];
              };
        };

sat_s1sfx :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s1sfy :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1sfx GHC.Types.[]];

GHC.Real.$fEnumRatio1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s1sfy;

GHC.Real.$fFractionalRatio_$s$csignum
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SL),1*U(U,A)>m, Unf=OtherCon []] =
    [] \r [ds_s1sfz]
        case ds_s1sfz of {
          GHC.Real.:% x_s1sfB [Occ=Once] _ [Occ=Dead] ->
              case GHC.Integer.Type.signumInteger x_s1sfB of dt_s1sfD {
                __DEFAULT -> GHC.Real.:% [dt_s1sfD GHC.Real.$fEnumRatio1];
              };
        };

GHC.Real.$fFractionalRatio_$s$cfromInteger
  :: GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [x_s1sfE]
        case x_s1sfE of dt_s1sfF {
          __DEFAULT -> GHC.Real.:% [dt_s1sfF GHC.Real.$fEnumRatio1];
        };

GHC.Real.$fRealInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real GHC.Integer.Type.Integer
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Num.$fNumInteger
                                    GHC.Integer.Type.$fOrdInteger
                                    GHC.Real.$fFractionalRatio_$s$cfromInteger];

GHC.Real.$fIntegralInt_$ctoInteger
  :: GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1sfG]
        case ds_s1sfG of {
          GHC.Types.I# i_s1sfI [Occ=Once] ->
              GHC.Integer.Type.smallInteger i_s1sfI;
        };

GHC.Real.$fEnumRatio_$ctoRational
  :: GHC.Types.Int -> GHC.Real.Rational
[GblId, Arity=1, Str=<S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [x_s1sfJ]
        case x_s1sfJ of {
          GHC.Types.I# i_s1sfL [Occ=Once] ->
              case GHC.Integer.Type.smallInteger i_s1sfL of dt_s1sfM {
                __DEFAULT -> GHC.Real.:% [dt_s1sfM GHC.Real.$fEnumRatio1];
              };
        };

GHC.Real.$fRealInt [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real GHC.Types.Int
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Num.$fNumInt
                                    GHC.Classes.$fOrdInt
                                    GHC.Real.$fEnumRatio_$ctoRational];

GHC.Real.$fIntegralWord_$ctoInteger
  :: GHC.Types.Word -> GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1sfN]
        case ds_s1sfN of {
          GHC.Types.W# x#_s1sfP [Occ=Once] ->
              GHC.Integer.Type.wordToInteger x#_s1sfP;
        };

GHC.Real.$fIntegralInteger_$ctoInteger
  :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [n_s1sfQ] n_s1sfQ;

GHC.Real.$fEqRatio_$s$c== [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sfR w1_s1sfS]
        case w_s1sfR of {
          GHC.Real.:% ww1_s1sfU [Occ=Once] ww2_s1sfV [Occ=Once] ->
              case w1_s1sfS of {
                GHC.Real.:% ww4_s1sfX [Occ=Once] ww5_s1sfY [Occ=Once] ->
                    case GHC.Integer.Type.eqInteger# ww1_s1sfU ww4_s1sfX of {
                      __DEFAULT -> GHC.Types.False [];
                      1# ->
                          case
                              GHC.Integer.Type.eqInteger# ww2_s1sfV ww5_s1sfY
                          of
                          wild1_s1sg0
                          { __DEFAULT -> tagToEnum# [wild1_s1sg0];
                          };
                    };
              };
        };

GHC.Real.$fEqRatio_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sg1 w1_s1sg2 w2_s1sg3]
        case w1_s1sg2 of {
          GHC.Real.:% ww1_s1sg5 [Occ=Once] ww2_s1sg6 [Occ=Once] ->
              case w2_s1sg3 of {
                GHC.Real.:% ww4_s1sg8 [Occ=Once] ww5_s1sg9 [Occ=Once] ->
                    case GHC.Classes.== w_s1sg1 ww1_s1sg5 ww4_s1sg8 of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> GHC.Classes.== w_s1sg1 ww2_s1sg6 ww5_s1sg9;
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$c/= [InlPrag=INLINE (sat-args=2)]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1sgb eta1_s1sgc]
        case eta_s1sgb of {
          GHC.Real.:% a1_s1sge [Occ=Once] a2_s1sgf [Occ=Once] ->
              case eta1_s1sgc of {
                GHC.Real.:% b1_s1sgh [Occ=Once] b2_s1sgi [Occ=Once] ->
                    case GHC.Integer.Type.eqInteger# a1_s1sge b1_s1sgh of {
                      __DEFAULT -> GHC.Types.True [];
                      1# ->
                          case GHC.Integer.Type.eqInteger# a2_s1sgf b2_s1sgi of {
                            __DEFAULT -> GHC.Types.True [];
                            1# -> GHC.Types.False [];
                          };
                    };
              };
        };

GHC.Real.$fEqRatio_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_s1sgl eta_s1sgm eta1_s1sgn]
        case eta_s1sgm of {
          GHC.Real.:% ww1_s1sgp [Occ=Once] ww2_s1sgq [Occ=Once] ->
              case eta1_s1sgn of {
                GHC.Real.:% ww4_s1sgs [Occ=Once] ww5_s1sgt [Occ=Once] ->
                    case GHC.Classes.== $dEq_s1sgl ww1_s1sgp ww4_s1sgs of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True ->
                          case GHC.Classes.== $dEq_s1sgl ww2_s1sgq ww5_s1sgt of {
                            GHC.Types.False -> GHC.Types.True [];
                            GHC.Types.True -> GHC.Types.False [];
                          };
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$fEqRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Real.$fEqRatio_$s$c==
                                     GHC.Real.$fOrdRatio_$s$c/=];

GHC.Real.$fEqRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Real.Ratio a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s1sgw]
        let {
          sat_s1sgy [Occ=Once]
            :: GHC.Real.Ratio a_a1eDJ
               -> GHC.Real.Ratio a_a1eDJ -> GHC.Types.Bool
          [LclId] =
              [$dEq_s1sgw] \r [eta_B2 eta_B1]
                  GHC.Real.$fEqRatio_$c/= $dEq_s1sgw eta_B2 eta_B1; } in
        let {
          sat_s1sgx [Occ=Once]
            :: GHC.Real.Ratio a_a1eDJ
               -> GHC.Real.Ratio a_a1eDJ -> GHC.Types.Bool
          [LclId] =
              [$dEq_s1sgw] \r [eta_B2 eta_B1]
                  GHC.Real.$fEqRatio_$c== $dEq_s1sgw eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s1sgx sat_s1sgy];

GHC.Real.$fOrdRatio_$s$fOrdRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [GHC.Real.$fOrdRatio_$s$fEqRatio
                                      GHC.Real.$fEnumRatio_$s$ccompare
                                      GHC.Real.$fOrdRatio_$s$c<
                                      GHC.Real.$fEnumRatio_$s$c<=
                                      GHC.Real.$fOrdRatio_$s$c>
                                      GHC.Real.$fEnumRatio_$s$c>=
                                      GHC.Real.$fOrdRatio_$s$cmax
                                      GHC.Real.$fOrdRatio_$s$cmin];

GHC.Real.$fOrdRatio_$cp1Ord
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Classes.Eq (GHC.Real.Ratio a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sgz]
        let {
          sat_s1sgC [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_a1eJ2
          [LclId] =
              [$dIntegral_s1sgz] \u []
                  case GHC.Real.$p1Integral $dIntegral_s1sgz of sat_s1sgA {
                    __DEFAULT ->
                        case GHC.Real.$p2Real sat_s1sgA of sat_s1sgB {
                          __DEFAULT -> GHC.Classes.$p1Ord sat_s1sgB;
                        };
                  };
        } in  GHC.Real.$fEqRatio sat_s1sgC;

GHC.Real.even1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

GHC.Real.$dmfloor
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U,U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1sgD eta_s1sgE eta1_s1sgF]
        let {
          ds_s1sgG [Dmd=<L,U(1*U,1*U)>] :: (b_a1eDd, a_a1dNs)
          [LclId] =
              [$dRealFrac_s1sgD eta_s1sgE eta1_s1sgF] \u []
                  GHC.Real.properFraction $dRealFrac_s1sgD eta_s1sgE eta1_s1sgF;
        } in 
          case
              GHC.Real.$p1RealFrac $dRealFrac_s1sgD
          of
          $dReal_s1sgH [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
          { __DEFAULT ->
                let {
                  sat_s1sgO [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [$dReal_s1sgH] \u []
                          case GHC.Real.$p1Real $dReal_s1sgH of sat_s1sgN {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1sgN GHC.Real.even1;
                          }; } in
                let {
                  sat_s1sgM [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [ds_s1sgG] \u []
                          case ds_s1sgG of {
                            (,) _ [Occ=Dead] r_s1sgL [Occ=Once] -> r_s1sgL;
                          };
                } in 
                  case GHC.Real.$p2Real $dReal_s1sgH of sat_s1sgI {
                    __DEFAULT ->
                        case GHC.Classes.< sat_s1sgI sat_s1sgM sat_s1sgO of {
                          GHC.Types.False ->
                              case ds_s1sgG of {
                                (,) n_s1sgR [Occ=Once] _ [Occ=Dead] -> n_s1sgR;
                              };
                          GHC.Types.True ->
                              case
                                  GHC.Real.$p1Integral eta_s1sgE
                              of
                              $dReal1_s1sgT [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                              { __DEFAULT ->
                                    case
                                        GHC.Real.$p1Real $dReal1_s1sgT
                                    of
                                    $dNum_s1sgU [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                    { __DEFAULT ->
                                          let {
                                            sat_s1sgZ [Occ=Once] :: b_a1eDd
                                            [LclId] =
                                                [$dNum_s1sgU] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_s1sgU GHC.Real.$fEnumRatio1; } in
                                          let {
                                            sat_s1sgY [Occ=Once] :: b_a1eDd
                                            [LclId] =
                                                [ds_s1sgG] \u []
                                                    case ds_s1sgG of {
                                                      (,) n_s1sgW [Occ=Once] _ [Occ=Dead] ->
                                                          n_s1sgW;
                                                    };
                                          } in  GHC.Num.- $dNum_s1sgU sat_s1sgY sat_s1sgZ;
                                    };
                              };
                        };
                  };
          };

GHC.Real.$dmceiling
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,A,1*C1(C1(U)),A,A,A),A),A,1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U,U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1sh0 eta_s1sh1 eta1_s1sh2]
        let {
          ds_s1sh3 [Dmd=<L,U(1*U,1*U)>] :: (b_a1eCG, a_a1dNs)
          [LclId] =
              [$dRealFrac_s1sh0 eta_s1sh1 eta1_s1sh2] \u []
                  GHC.Real.properFraction $dRealFrac_s1sh0 eta_s1sh1 eta1_s1sh2;
        } in 
          case
              GHC.Real.$p1RealFrac $dRealFrac_s1sh0
          of
          $dReal_s1sh4 [Dmd=<S(LS(LLLLC(C(S))LLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,A,1*C1(C1(U)),A,A,A),A)>]
          { __DEFAULT ->
                let {
                  sat_s1shb [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [$dReal_s1sh4] \u []
                          case GHC.Real.$p1Real $dReal_s1sh4 of sat_s1sha {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1sha GHC.Real.even1;
                          }; } in
                let {
                  sat_s1sh9 [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [ds_s1sh3] \u []
                          case ds_s1sh3 of {
                            (,) _ [Occ=Dead] r_s1sh8 [Occ=Once] -> r_s1sh8;
                          };
                } in 
                  case GHC.Real.$p2Real $dReal_s1sh4 of sat_s1sh5 {
                    __DEFAULT ->
                        case GHC.Classes.> sat_s1sh5 sat_s1sh9 sat_s1shb of {
                          GHC.Types.False ->
                              case ds_s1sh3 of {
                                (,) n_s1she [Occ=Once] _ [Occ=Dead] -> n_s1she;
                              };
                          GHC.Types.True ->
                              case
                                  GHC.Real.$p1Integral eta_s1sh1
                              of
                              $dReal1_s1shg [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
                              { __DEFAULT ->
                                    case
                                        GHC.Real.$p1Real $dReal1_s1shg
                                    of
                                    $dNum_s1shh [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                                    { __DEFAULT ->
                                          let {
                                            sat_s1shm [Occ=Once] :: b_a1eCG
                                            [LclId] =
                                                [$dNum_s1shh] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_s1shh GHC.Real.$fEnumRatio1; } in
                                          let {
                                            sat_s1shl [Occ=Once] :: b_a1eCG
                                            [LclId] =
                                                [ds_s1sh3] \u []
                                                    case ds_s1sh3 of {
                                                      (,) n_s1shj [Occ=Once] _ [Occ=Dead] ->
                                                          n_s1shj;
                                                    };
                                          } in  GHC.Num.+ $dNum_s1shh sat_s1shl sat_s1shm;
                                    };
                              };
                        };
                  };
          };

GHC.Real.$dmtruncate [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S(SL)))LLLL),1*U(A,A,1*C1(C1(U(1*U,A))),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1shn $dIntegral_s1sho x_s1shp]
        case
            GHC.Real.properFraction $dRealFrac_s1shn $dIntegral_s1sho x_s1shp
        of
        { (,) m_s1shr [Occ=Once] _ [Occ=Dead] -> m_s1shr;
        };

GHC.Real.$dmrecip [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Real.Fractional a => a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LL),U(1*U(A,A,A,A,A,A,1*C1(U)),1*C1(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_s1sht eta_s1shu]
        let {
          sat_s1shw [Occ=Once] :: a_a1dNK
          [LclId] =
              [$dFractional_s1sht] \u []
                  case GHC.Real.$p1Fractional $dFractional_s1sht of sat_s1shv {
                    __DEFAULT -> GHC.Num.fromInteger sat_s1shv GHC.Real.$fEnumRatio1;
                  };
        } in  GHC.Real./ $dFractional_s1sht sat_s1shw eta_s1shu;

GHC.Real.$dm/ [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Fractional a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLC(C(S))LLLL)LLL),U(1*U(A,A,1*C1(C1(U)),A,A,A,A),A,1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_s1shx eta_s1shy eta1_s1shz]
        let {
          sat_s1shB [Occ=Once] :: a_a1dNK
          [LclId] =
              [$dFractional_s1shx eta1_s1shz] \u []
                  GHC.Real.recip $dFractional_s1shx eta1_s1shz;
        } in 
          case GHC.Real.$p1Fractional $dFractional_s1shx of sat_s1shA {
            __DEFAULT -> GHC.Num.* sat_s1shA eta_s1shy sat_s1shB;
          };

GHC.Real.$dmdivMod
  :: forall a. GHC.Real.Integral a => a -> a -> (a, a)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,1*C1(C1(U(U,U))),A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1shC eta_s1shD eta1_s1shE]
        case
            GHC.Real.$p1Integral $dIntegral_s1shC
        of
        $dReal_s1shF [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1shG [Dmd=<L,U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U))>]
                  :: GHC.Num.Num a_a1dNO
                [LclId] =
                    [$dReal_s1shF] \u [] GHC.Real.$p1Real $dReal_s1shF; } in
              let {
                ds_s1shH [Dmd=<L,U(1*U(U,U),1*U,1*U)>]
                  :: ((a_a1dNO, a_a1dNO), a_a1dNO, a_a1dNO)
                [LclId] =
                    [$dIntegral_s1shC eta_s1shD eta1_s1shE] \u []
                        case
                            GHC.Real.quotRem $dIntegral_s1shC eta_s1shD eta1_s1shE
                        of
                        wild_s1shI
                        { (,) q_s1shJ [Occ=Once] r_s1shK [Occ=Once] ->
                              (,,) [wild_s1shI q_s1shJ r_s1shK];
                        }; } in
              let {
                r_s1shL :: a_a1dNO
                [LclId] =
                    [ds_s1shH] \u []
                        case ds_s1shH of {
                          (,,) _ [Occ=Dead] _ [Occ=Dead] r1_s1shP [Occ=Once] -> r1_s1shP;
                        }; } in
              let {
                sat_s1shU [Occ=Once] :: a_a1dNO
                [LclId] =
                    [eta1_s1shE $dNum_s1shG] \u []
                        let {
                          sat_s1shT [Occ=Once] :: a_a1dNO
                          [LclId] =
                              [eta1_s1shE $dNum_s1shG] \u []
                                  GHC.Num.signum $dNum_s1shG eta1_s1shE;
                        } in  GHC.Num.negate $dNum_s1shG sat_s1shT; } in
              let {
                sat_s1shS [Occ=Once] :: a_a1dNO
                [LclId] =
                    [$dNum_s1shG r_s1shL] \u [] GHC.Num.signum $dNum_s1shG r_s1shL;
              } in 
                case GHC.Real.$p2Real $dReal_s1shF of sat_s1shQ {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_s1shQ of sat_s1shR {
                        __DEFAULT ->
                            case GHC.Classes.== sat_s1shR sat_s1shS sat_s1shU of {
                              GHC.Types.False ->
                                  case ds_s1shH of {
                                    (,,) qr_s1shX [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> qr_s1shX;
                                  };
                              GHC.Types.True ->
                                  let {
                                    sat_s1si7 [Occ=Once] :: a_a1dNO
                                    [LclId] =
                                        [eta1_s1shE $dNum_s1shG r_s1shL] \u []
                                            GHC.Num.+ $dNum_s1shG r_s1shL eta1_s1shE; } in
                                  let {
                                    sat_s1si6 [Occ=Once] :: a_a1dNO
                                    [LclId] =
                                        [$dNum_s1shG ds_s1shH] \u []
                                            let {
                                              sat_s1si5 [Occ=Once] :: a_a1dNO
                                              [LclId] =
                                                  [$dNum_s1shG] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s1shG GHC.Real.$fEnumRatio1; } in
                                            let {
                                              sat_s1si4 [Occ=Once] :: a_a1dNO
                                              [LclId] =
                                                  [ds_s1shH] \u []
                                                      case ds_s1shH of {
                                                        (,,) _ [Occ=Dead]
                                                             q_s1si2 [Occ=Once]
                                                             _ [Occ=Dead] ->
                                                            q_s1si2;
                                                      };
                                            } in  GHC.Num.- $dNum_s1shG sat_s1si4 sat_s1si5;
                                  } in  (,) [sat_s1si6 sat_s1si7];
                            };
                      };
                };
        };

GHC.Real.$dmmod [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(S(LS)))L),1*U(A,A,A,A,A,A,A,1*C1(C1(U(A,1*U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1si8 n_s1si9 d_s1sia]
        case GHC.Real.divMod $dIntegral_s1si8 n_s1si9 d_s1sia of {
          (,) _ [Occ=Dead] r_s1sid [Occ=Once] -> r_s1sid;
        };

GHC.Real.$dmdiv [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(S(SL)))L),1*U(A,A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sie n_s1sif d_s1sig]
        case GHC.Real.divMod $dIntegral_s1sie n_s1sif d_s1sig of {
          (,) q_s1sii [Occ=Once] _ [Occ=Dead] -> q_s1sii;
        };

GHC.Real.$dmrem [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(LS)))LL),1*U(A,A,A,A,A,A,1*C1(C1(U(A,1*U))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sik n_s1sil d_s1sim]
        case GHC.Real.quotRem $dIntegral_s1sik n_s1sil d_s1sim of {
          (,) _ [Occ=Dead] r_s1sip [Occ=Once] -> r_s1sip;
        };

GHC.Real.$dmquot [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))LL),1*U(A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1siq n_s1sir d_s1sis]
        case GHC.Real.quotRem $dIntegral_s1siq n_s1sir d_s1sis of {
          (,) q_s1siu [Occ=Once] _ [Occ=Dead] -> q_s1siu;
        };

GHC.Real.divZeroError [InlPrag=NOINLINE] :: forall a. a
[GblId, Str=x] =
    [] \u [] raise# [GHC.Exception.divZeroException];

GHC.Real.$fIntegralInt1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

GHC.Real.$fIntegralInt_$cmod [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1siw w1_s1six]
        case w1_s1six of {
          GHC.Types.I# ww1_s1siz [Occ=Once!] ->
              case ww1_s1siz of wild_s1siA {
                __DEFAULT ->
                    case w_s1siw of {
                      GHC.Types.I# x_s1siC [Occ=Once] ->
                          case GHC.Classes.modInt# x_s1siC wild_s1siA of ww2_s1siD {
                            __DEFAULT -> GHC.Types.I# [ww2_s1siD];
                          };
                    };
                -1# -> GHC.Real.$fIntegralInt1;
                0# -> GHC.Real.divZeroError;
              };
        };

GHC.Real.$fIntegralInt_$crem
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [a_s1siF b_s1siG]
        case b_s1siG of {
          GHC.Types.I# x_s1siI [Occ=Once!] ->
              case x_s1siI of wild1_s1siJ {
                __DEFAULT ->
                    case a_s1siF of {
                      GHC.Types.I# x1_s1siL [Occ=Once] ->
                          case remInt# [x1_s1siL wild1_s1siJ] of wild3_s1siM {
                            __DEFAULT -> GHC.Types.I# [wild3_s1siM];
                          };
                    };
                -1# -> GHC.Real.$fIntegralInt1;
                0# -> GHC.Real.divZeroError;
              };
        };

GHC.Real.$fIntegralInteger_$cquot [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1siN eta1_s1siO]
        case GHC.Integer.Type.eqInteger# eta1_s1siO GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.quotInteger eta_s1siN eta1_s1siO;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$crem [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1siQ eta1_s1siR]
        case GHC.Integer.Type.eqInteger# eta1_s1siR GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.remInteger eta_s1siQ eta1_s1siR;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cdiv [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1siT eta1_s1siU]
        case GHC.Integer.Type.eqInteger# eta1_s1siU GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.divInteger eta_s1siT eta1_s1siU;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cmod [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1siW eta1_s1siX]
        case GHC.Integer.Type.eqInteger# eta1_s1siX GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.modInteger eta_s1siW eta1_s1siX;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cquotRem [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
[GblId, Arity=2, Str=<S,1*U><S,U>m, Unf=OtherCon []] =
    [] \r [eta_s1siZ eta1_s1sj0]
        case GHC.Integer.Type.eqInteger# eta1_s1sj0 GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.quotRemInteger eta_s1siZ eta1_s1sj0 of {
                (#,#) ipv_s1sj3 [Occ=Once] ipv1_s1sj4 [Occ=Once] ->
                    (,) [ipv_s1sj3 ipv1_s1sj4];
              };
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cdivMod [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
[GblId, Arity=2, Str=<S,1*U><S,U>m, Unf=OtherCon []] =
    [] \r [eta_s1sj5 eta1_s1sj6]
        case GHC.Integer.Type.eqInteger# eta1_s1sj6 GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.divModInteger eta_s1sj5 eta1_s1sj6 of {
                (#,#) ipv_s1sj9 [Occ=Once] ipv1_s1sja [Occ=Once] ->
                    (,) [ipv_s1sj9 ipv1_s1sja];
              };
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Integral GHC.Integer.Type.Integer
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Integral! [GHC.Real.$fRealInteger
                                        GHC.Enum.$fEnumInteger
                                        GHC.Real.$fIntegralInteger_$cquot
                                        GHC.Real.$fIntegralInteger_$crem
                                        GHC.Real.$fIntegralInteger_$cdiv
                                        GHC.Real.$fIntegralInteger_$cmod
                                        GHC.Real.$fIntegralInteger_$cquotRem
                                        GHC.Real.$fIntegralInteger_$cdivMod
                                        GHC.Real.$fIntegralInteger_$ctoInteger];

GHC.Real.$fIntegralWord_$cquot
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1sjb y_s1sjc]
        case ds_s1sjb of {
          GHC.Types.W# x#_s1sje [Occ=Once] ->
              case y_s1sjc of {
                GHC.Types.W# y#_s1sjg [Occ=Once!] ->
                    case y#_s1sjg of wild2_s1sjh {
                      __DEFAULT ->
                          case quotWord# [x#_s1sje wild2_s1sjh] of wild3_s1sji {
                            __DEFAULT -> GHC.Types.W# [wild3_s1sji];
                          };
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralWord_$crem
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1sjj y_s1sjk]
        case ds_s1sjj of {
          GHC.Types.W# x#_s1sjm [Occ=Once] ->
              case y_s1sjk of {
                GHC.Types.W# y#_s1sjo [Occ=Once!] ->
                    case y#_s1sjo of wild2_s1sjp {
                      __DEFAULT ->
                          case remWord# [x#_s1sjm wild2_s1sjp] of wild3_s1sjq {
                            __DEFAULT -> GHC.Types.W# [wild3_s1sjq];
                          };
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralWord_$cquotRem
  :: GHC.Types.Word
     -> GHC.Types.Word -> (GHC.Types.Word, GHC.Types.Word)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1sjr y_s1sjs]
        case ds_s1sjr of {
          GHC.Types.W# x#_s1sju [Occ=Once] ->
              case y_s1sjs of {
                GHC.Types.W# y#_s1sjw [Occ=Once!] ->
                    case y#_s1sjw of wild2_s1sjx {
                      __DEFAULT ->
                          case quotRemWord# [x#_s1sju wild2_s1sjx] of {
                            (#,#) ipv_s1sjz [Occ=Once] ipv1_s1sjA [Occ=Once] ->
                                let {
                                  sat_s1sjC [Occ=Once] :: GHC.Types.Word
                                  [LclId] =
                                      CCCS GHC.Types.W#! [ipv1_s1sjA]; } in
                                let {
                                  sat_s1sjB [Occ=Once] :: GHC.Types.Word
                                  [LclId] =
                                      CCCS GHC.Types.W#! [ipv_s1sjz];
                                } in  (,) [sat_s1sjB sat_s1sjC];
                          };
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralWord_$cdivMod
  :: GHC.Types.Word
     -> GHC.Types.Word -> (GHC.Types.Word, GHC.Types.Word)
[GblId, Arity=2, Str=<S,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [ds_s1sjD y_s1sjE]
        case ds_s1sjD of {
          GHC.Types.W# x#_s1sjG ->
              case y_s1sjE of {
                GHC.Types.W# y#_s1sjI [Occ=Once!] ->
                    case y#_s1sjI of wild2_s1sjJ {
                      __DEFAULT ->
                          let {
                            sat_s1sjN [Occ=Once] :: GHC.Types.Word
                            [LclId] =
                                [x#_s1sjG wild2_s1sjJ] \u []
                                    case remWord# [x#_s1sjG wild2_s1sjJ] of wild3_s1sjM {
                                      __DEFAULT -> GHC.Types.W# [wild3_s1sjM];
                                    }; } in
                          let {
                            sat_s1sjL [Occ=Once] :: GHC.Types.Word
                            [LclId] =
                                [x#_s1sjG wild2_s1sjJ] \u []
                                    case quotWord# [x#_s1sjG wild2_s1sjJ] of wild3_s1sjK {
                                      __DEFAULT -> GHC.Types.W# [wild3_s1sjK];
                                    };
                          } in  (,) [sat_s1sjL sat_s1sjN];
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.ratioZeroDenominatorError [InlPrag=NOINLINE]
  :: forall a. a
[GblId, Str=x] =
    [] \u [] raise# [GHC.Exception.ratioZeroDenomException];

GHC.Real.$fFractionalRatio_$s$crecip [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_s1sjO]
        case w_s1sjO of {
          GHC.Real.:% ww1_s1sjQ ww2_s1sjR [Occ=Once*] ->
              case GHC.Integer.Type.eqInteger# ww1_s1sjQ GHC.Real.even1 of {
                __DEFAULT ->
                    case GHC.Integer.Type.ltInteger# ww1_s1sjQ GHC.Real.even1 of {
                      __DEFAULT -> GHC.Real.:% [ww2_s1sjR ww1_s1sjQ];
                      1# ->
                          case GHC.Integer.Type.negateInteger ww2_s1sjR of dt_s1sjU {
                            __DEFAULT ->
                                case GHC.Integer.Type.negateInteger ww1_s1sjQ of dt1_s1sjV {
                                  __DEFAULT -> GHC.Real.:% [dt_s1sjU dt1_s1sjV];
                                };
                          };
                    };
                1# -> GHC.Real.ratioZeroDenominatorError;
              };
        };

GHC.Real.overflowError [InlPrag=NOINLINE] :: forall a. a
[GblId, Str=x] =
    [] \u [] raise# [GHC.Exception.overflowException];

lvl_r1j38 :: (GHC.Types.Int, GHC.Types.Int)
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Real.overflowError
                        GHC.Real.$fIntegralInt1];

GHC.Real.$fIntegralInt_$cdivMod [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1sjX w1_s1sjY]
        case w_s1sjX of {
          GHC.Types.I# ww1_s1sk0 ->
              case w1_s1sjY of {
                GHC.Types.I# ww3_s1sk2 [Occ=Once!] ->
                    case ww3_s1sk2 of wild_s1sk3 {
                      __DEFAULT ->
                          case ># [ww1_s1sk0 0#] of {
                            __DEFAULT ->
                                case <# [ww1_s1sk0 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww1_s1sk0 wild_s1sk3] of {
                                        (#,#) ipv_s1sk7 [Occ=Once] ipv1_s1sk8 [Occ=Once] ->
                                            let {
                                              sat_s1ska [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s1sk8]; } in
                                            let {
                                              sat_s1sk9 [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_s1sk7];
                                            } in  (,) [sat_s1sk9 sat_s1ska];
                                      };
                                  1# ->
                                      case ># [wild_s1sk3 0#] of {
                                        __DEFAULT ->
                                            case quotRemInt# [ww1_s1sk0 wild_s1sk3] of {
                                              (#,#) ipv_s1skd [Occ=Once] ipv1_s1ske [Occ=Once] ->
                                                  let {
                                                    sat_s1skg [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv1_s1ske]; } in
                                                  let {
                                                    sat_s1skf [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv_s1skd];
                                                  } in  (,) [sat_s1skf sat_s1skg];
                                            };
                                        1# ->
                                            case +# [ww1_s1sk0 1#] of sat_s1skh {
                                              __DEFAULT ->
                                                  case quotRemInt# [sat_s1skh wild_s1sk3] of {
                                                    (#,#) ipv_s1skj [Occ=Once]
                                                          ipv1_s1skk [Occ=Once] ->
                                                        case
                                                            +# [ipv1_s1skk wild_s1sk3]
                                                        of
                                                        sat_s1skn
                                                        { __DEFAULT ->
                                                              case -# [sat_s1skn 1#] of sat_s1sko {
                                                                __DEFAULT ->
                                                                    let {
                                                                      sat_s1skp [Occ=Once]
                                                                        :: GHC.Types.Int
                                                                      [LclId] =
                                                                          CCCS GHC.Types.I#! [sat_s1sko];
                                                                    } in 
                                                                      case
                                                                          -# [ipv_s1skj 1#]
                                                                      of
                                                                      sat_s1skl
                                                                      { __DEFAULT ->
                                                                            let {
                                                                              sat_s1skm [Occ=Once]
                                                                                :: GHC.Types.Int
                                                                              [LclId] =
                                                                                  CCCS GHC.Types.I#! [sat_s1skl];
                                                                            } in 
                                                                              (,) [sat_s1skm
                                                                                   sat_s1skp];
                                                                      };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            1# ->
                                case <# [wild_s1sk3 0#] of {
                                  __DEFAULT ->
                                      case <# [ww1_s1sk0 0#] of {
                                        __DEFAULT ->
                                            case quotRemInt# [ww1_s1sk0 wild_s1sk3] of {
                                              (#,#) ipv_s1skt [Occ=Once] ipv1_s1sku [Occ=Once] ->
                                                  let {
                                                    sat_s1skw [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv1_s1sku]; } in
                                                  let {
                                                    sat_s1skv [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv_s1skt];
                                                  } in  (,) [sat_s1skv sat_s1skw];
                                            };
                                        1# ->
                                            case ># [wild_s1sk3 0#] of {
                                              __DEFAULT ->
                                                  case quotRemInt# [ww1_s1sk0 wild_s1sk3] of {
                                                    (#,#) ipv_s1skz [Occ=Once]
                                                          ipv1_s1skA [Occ=Once] ->
                                                        let {
                                                          sat_s1skC [Occ=Once] :: GHC.Types.Int
                                                          [LclId] =
                                                              CCCS GHC.Types.I#! [ipv1_s1skA]; } in
                                                        let {
                                                          sat_s1skB [Occ=Once] :: GHC.Types.Int
                                                          [LclId] =
                                                              CCCS GHC.Types.I#! [ipv_s1skz];
                                                        } in  (,) [sat_s1skB sat_s1skC];
                                                  };
                                              1# ->
                                                  case +# [ww1_s1sk0 1#] of sat_s1skD {
                                                    __DEFAULT ->
                                                        case quotRemInt# [sat_s1skD wild_s1sk3] of {
                                                          (#,#) ipv_s1skF [Occ=Once]
                                                                ipv1_s1skG [Occ=Once] ->
                                                              case
                                                                  +# [ipv1_s1skG wild_s1sk3]
                                                              of
                                                              sat_s1skJ
                                                              { __DEFAULT ->
                                                                    case
                                                                        -# [sat_s1skJ 1#]
                                                                    of
                                                                    sat_s1skK
                                                                    { __DEFAULT ->
                                                                          let {
                                                                            sat_s1skL [Occ=Once]
                                                                              :: GHC.Types.Int
                                                                            [LclId] =
                                                                                CCCS GHC.Types.I#! [sat_s1skK];
                                                                          } in 
                                                                            case
                                                                                -# [ipv_s1skF 1#]
                                                                            of
                                                                            sat_s1skH
                                                                            { __DEFAULT ->
                                                                                  let {
                                                                                    sat_s1skI [Occ=Once]
                                                                                      :: GHC.Types.Int
                                                                                    [LclId] =
                                                                                        CCCS GHC.Types.I#! [sat_s1skH];
                                                                                  } in 
                                                                                    (,) [sat_s1skI
                                                                                         sat_s1skL];
                                                                            };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                  1# ->
                                      case -# [ww1_s1sk0 1#] of sat_s1skM {
                                        __DEFAULT ->
                                            case quotRemInt# [sat_s1skM wild_s1sk3] of {
                                              (#,#) ipv_s1skO [Occ=Once] ipv1_s1skP [Occ=Once] ->
                                                  case +# [ipv1_s1skP wild_s1sk3] of sat_s1skS {
                                                    __DEFAULT ->
                                                        case +# [sat_s1skS 1#] of sat_s1skT {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_s1skU [Occ=Once]
                                                                  :: GHC.Types.Int
                                                                [LclId] =
                                                                    CCCS GHC.Types.I#! [sat_s1skT];
                                                              } in 
                                                                case
                                                                    -# [ipv_s1skO 1#]
                                                                of
                                                                sat_s1skQ
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_s1skR [Occ=Once]
                                                                          :: GHC.Types.Int
                                                                        [LclId] =
                                                                            CCCS GHC.Types.I#! [sat_s1skQ];
                                                                      } in 
                                                                        (,) [sat_s1skR sat_s1skU];
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                      -1# ->
                          case ww1_s1sk0 of wild1_s1skV {
                            __DEFAULT ->
                                case ># [wild1_s1skV 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [wild1_s1skV -1#] of {
                                        (#,#) ipv_s1skY [Occ=Once] ipv1_s1skZ [Occ=Once] ->
                                            let {
                                              sat_s1sl1 [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s1skZ]; } in
                                            let {
                                              sat_s1sl0 [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_s1skY];
                                            } in  (,) [sat_s1sl0 sat_s1sl1];
                                      };
                                  1# ->
                                      case -# [wild1_s1skV 1#] of sat_s1sl2 {
                                        __DEFAULT ->
                                            case quotRemInt# [sat_s1sl2 -1#] of {
                                              (#,#) ipv_s1sl4 [Occ=Once] ipv1_s1sl5 [Occ=Once] ->
                                                  case +# [ipv1_s1sl5 -1#] of sat_s1sl8 {
                                                    __DEFAULT ->
                                                        case +# [sat_s1sl8 1#] of sat_s1sl9 {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_s1sla [Occ=Once]
                                                                  :: GHC.Types.Int
                                                                [LclId] =
                                                                    CCCS GHC.Types.I#! [sat_s1sl9];
                                                              } in 
                                                                case
                                                                    -# [ipv_s1sl4 1#]
                                                                of
                                                                sat_s1sl6
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_s1sl7 [Occ=Once]
                                                                          :: GHC.Types.Int
                                                                        [LclId] =
                                                                            CCCS GHC.Types.I#! [sat_s1sl6];
                                                                      } in 
                                                                        (,) [sat_s1sl7 sat_s1sla];
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            -9223372036854775808# -> lvl_r1j38;
                          };
                      0# -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralInt_$cquotRem [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1slc w1_s1sld]
        case w_s1slc of {
          GHC.Types.I# ww1_s1slf [Occ=Once*] ->
              case w1_s1sld of {
                GHC.Types.I# ww3_s1slh [Occ=Once!] ->
                    case ww3_s1slh of wild_s1sli {
                      __DEFAULT ->
                          case quotRemInt# [ww1_s1slf wild_s1sli] of {
                            (#,#) ipv_s1slk [Occ=Once] ipv1_s1sll [Occ=Once] ->
                                let {
                                  sat_s1sln [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s1sll]; } in
                                let {
                                  sat_s1slm [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv_s1slk];
                                } in  (,) [sat_s1slm sat_s1sln];
                          };
                      -1# ->
                          case ww1_s1slf of wild1_s1slo {
                            __DEFAULT ->
                                case quotRemInt# [wild1_s1slo -1#] of {
                                  (#,#) ipv_s1slq [Occ=Once] ipv1_s1slr [Occ=Once] ->
                                      let {
                                        sat_s1slt [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv1_s1slr]; } in
                                      let {
                                        sat_s1sls [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv_s1slq];
                                      } in  (,) [sat_s1sls sat_s1slt];
                                };
                            -9223372036854775808# -> lvl_r1j38;
                          };
                      0# -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$w$cdiv [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Str=<S,U><S,1*U>, Unf=OtherCon []] =
    [] \r [ww_s1slv ww1_s1slw]
        case ww1_s1slw of wild_s1slx {
          __DEFAULT -> GHC.Classes.divInt# ww_s1slv wild_s1slx;
          -1# ->
              case ww_s1slv of wild1_s1sly {
                __DEFAULT -> GHC.Classes.divInt# wild1_s1sly -1#;
                -9223372036854775808# -> GHC.Real.overflowError;
              };
          0# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInt_$cdiv [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1slB w1_s1slC]
        case w_s1slB of {
          GHC.Types.I# ww1_s1slE [Occ=Once] ->
              case w1_s1slC of {
                GHC.Types.I# ww3_s1slG [Occ=Once] ->
                    case GHC.Real.$w$cdiv ww1_s1slE ww3_s1slG of ww4_s1slH {
                      __DEFAULT -> GHC.Types.I# [ww4_s1slH];
                    };
              };
        };

GHC.Real.$fIntegralInt_$cquot [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1slI w1_s1slJ]
        case w_s1slI of {
          GHC.Types.I# ww1_s1slL [Occ=Once*] ->
              case w1_s1slJ of {
                GHC.Types.I# ww3_s1slN [Occ=Once!] ->
                    case ww3_s1slN of wild_s1slO {
                      __DEFAULT ->
                          case quotInt# [ww1_s1slL wild_s1slO] of ww4_s1slP {
                            __DEFAULT -> GHC.Types.I# [ww4_s1slP];
                          };
                      -1# ->
                          case ww1_s1slL of wild1_s1slQ {
                            __DEFAULT ->
                                case quotInt# [wild1_s1slQ -1#] of sat_s1slR {
                                  __DEFAULT -> GHC.Types.I# [sat_s1slR];
                                };
                            -9223372036854775808# -> GHC.Real.overflowError;
                          };
                      0# -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralInt [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Integral GHC.Types.Int
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Integral! [GHC.Real.$fRealInt
                                        GHC.Enum.$fEnumInt
                                        GHC.Real.$fIntegralInt_$cquot
                                        GHC.Real.$fIntegralInt_$crem
                                        GHC.Real.$fIntegralInt_$cdiv
                                        GHC.Real.$fIntegralInt_$cmod
                                        GHC.Real.$fIntegralInt_$cquotRem
                                        GHC.Real.$fIntegralInt_$cdivMod
                                        GHC.Real.$fIntegralInt_$ctoInteger];

lvl1_r1j39 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [-1#];

lvl2_r1j3a :: GHC.Types.Int
[GblId] =
    [] \u [] GHC.Real.$wgcd' lvl1_r1j39 0#;
GHC.Real.$wgcd' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: GHC.Types.Int -> GHC.Prim.Int# -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [w_s1slU ww_s1slV]
        case ww_s1slV of wild_s1slW {
          __DEFAULT ->
              case w_s1slU of {
                GHC.Types.I# x_s1slY [Occ=Once] ->
                    case remInt# [x_s1slY wild_s1slW] of wild2_s1slZ {
                      __DEFAULT ->
                          let {
                            sat_s1sm0 [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [wild_s1slW];
                          } in  GHC.Real.$wgcd' sat_s1sm0 wild2_s1slZ;
                    };
              };
          -1# -> lvl2_r1j3a;
          0# -> w_s1slU;
        };

GHC.Real.$fEnumRatio_gcd' [Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [a_s1sm1 ds_s1sm2]
        case GHC.Integer.Type.eqInteger# ds_s1sm2 GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.remInteger a_s1sm1 ds_s1sm2 of sat_s1sm4 {
                __DEFAULT -> GHC.Real.$fEnumRatio_gcd' ds_s1sm2 sat_s1sm4;
              };
          1# -> a_s1sm1;
        };

GHC.Real.gcd [InlPrag=NOINLINE[1]]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(U(A,A,A,A,C(U),A,1*C1(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sm5 eta_s1sm6 eta1_s1sm7]
        case
            GHC.Real.$p1Integral $dIntegral_s1sm5
        of
        $dReal_s1sm8 [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(U(A,A,A,A,C(U),A,1*C1(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                lvl8_s1sm9 [Occ=OnceL] :: a_a1eor
                [LclId] =
                    [$dReal_s1sm8] \u []
                        case GHC.Real.$p1Real $dReal_s1sm8 of sat_s1sma {
                          __DEFAULT -> GHC.Num.fromInteger sat_s1sma GHC.Real.even1;
                        };
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1sm8
                of
                $dEq_s1smb [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Classes.$p1Ord $dEq_s1smb
                      of
                      $dEq1_s1smc [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                      { __DEFAULT ->
                            let {
                              $dNum_s1smd [Dmd=<L,U(A,A,A,A,C(U),A,A)>] :: GHC.Num.Num a_a1eor
                              [LclId] =
                                  [$dReal_s1sm8] \u [] GHC.Real.$p1Real $dReal_s1sm8; } in
                            let {
                              sat_s1smk [Occ=Once] :: a_a1eor
                              [LclId] =
                                  [eta1_s1sm7 $dNum_s1smd] \u []
                                      GHC.Num.abs $dNum_s1smd eta1_s1sm7; } in
                            let {
                              sat_s1smj [Occ=Once] :: a_a1eor
                              [LclId] =
                                  [eta_s1sm6 $dNum_s1smd] \u [] GHC.Num.abs $dNum_s1smd eta_s1sm6;
                            } in 
                              let-no-escape {
                                gcd'_s1sme [Occ=LoopBreakerT[2]] :: a_a1eor -> a_a1eor -> a_a1eor
                                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                    sat-only [$dIntegral_s1sm5
                                              lvl8_s1sm9
                                              $dEq1_s1smc
                                              gcd'_s1sme] \r [a1_s1smf ds_s1smg]
                                        case GHC.Classes.== $dEq1_s1smc ds_s1smg lvl8_s1sm9 of {
                                          GHC.Types.False ->
                                              let {
                                                sat_s1smi [Occ=Once] :: a_a1eor
                                                [LclId] =
                                                    [$dIntegral_s1sm5 a1_s1smf ds_s1smg] \u []
                                                        GHC.Real.rem
                                                            $dIntegral_s1sm5 a1_s1smf ds_s1smg;
                                              } in  gcd'_s1sme ds_s1smg sat_s1smi;
                                          GHC.Types.True -> a1_s1smf;
                                        };
                              } in  gcd'_s1sme sat_s1smj sat_s1smk;
                      };
                };
        };

GHC.Real.$w$sreduce [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [w_s1sml w1_s1smm]
        case GHC.Integer.Type.eqInteger# w1_s1smm GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.absInteger w1_s1smm of sat_s1smq {
                __DEFAULT ->
                    case GHC.Integer.Type.absInteger w_s1sml of sat_s1smp {
                      __DEFAULT ->
                          case
                              GHC.Real.$fEnumRatio_gcd' sat_s1smp sat_s1smq
                          of
                          d_s1smo [Dmd=<S,U>]
                          { __DEFAULT ->
                                case GHC.Integer.Type.eqInteger# d_s1smo GHC.Real.even1 of {
                                  __DEFAULT ->
                                      case
                                          GHC.Integer.Type.quotInteger w_s1sml d_s1smo
                                      of
                                      dt_s1sms
                                      { __DEFAULT ->
                                            case
                                                GHC.Integer.Type.quotInteger w1_s1smm d_s1smo
                                            of
                                            dt1_s1smt
                                            { __DEFAULT -> (#,#) [dt_s1sms dt1_s1smt];
                                            };
                                      };
                                  1# -> GHC.Real.divZeroError;
                                };
                          };
                    };
              };
          1# -> GHC.Real.ratioZeroDenominatorError;
        };

GHC.Real.reduce_$sreduce [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S,U>m, Unf=OtherCon []] =
    [] \r [w_s1smw w1_s1smx]
        case GHC.Real.$w$sreduce w_s1smw w1_s1smx of {
          (#,#) ww1_s1smz [Occ=Once] ww2_s1smA [Occ=Once] ->
              GHC.Real.:% [ww1_s1smz ww2_s1smA];
        };

GHC.Real.$fRealWord_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Word -> GHC.Real.Rational
[GblId, Arity=1, Str=<S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1smB]
        case w_s1smB of {
          GHC.Types.W# ww1_s1smD [Occ=Once] ->
              case GHC.Integer.Type.wordToInteger ww1_s1smD of sat_s1smE {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger sat_s1smE GHC.Real.$fEnumRatio1
                    of
                    sat_s1smF
                    { __DEFAULT ->
                          case GHC.Real.$w$sreduce sat_s1smF GHC.Real.$fEnumRatio1 of {
                            (#,#) ww3_s1smH [Occ=Once] ww4_s1smI [Occ=Once] ->
                                GHC.Real.:% [ww3_s1smH ww4_s1smI];
                          };
                    };
              };
        };

GHC.Real.$fRealWord [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real GHC.Types.Word
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Num.$fNumWord
                                    GHC.Classes.$fOrdWord
                                    GHC.Real.$fRealWord_$ctoRational];

GHC.Real.$fIntegralWord [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Integral GHC.Types.Word
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Integral! [GHC.Real.$fRealWord
                                        GHC.Enum.$fEnumWord
                                        GHC.Real.$fIntegralWord_$cquot
                                        GHC.Real.$fIntegralWord_$crem
                                        GHC.Real.$fIntegralWord_$cquot
                                        GHC.Real.$fIntegralWord_$crem
                                        GHC.Real.$fIntegralWord_$cquotRem
                                        GHC.Real.$fIntegralWord_$cdivMod
                                        GHC.Real.$fIntegralWord_$ctoInteger];

GHC.Real.$fFractionalRatio_$s$c* [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1smJ w1_s1smK]
        case w_s1smJ of {
          GHC.Real.:% ww1_s1smM [Occ=Once] ww2_s1smN [Occ=Once] ->
              case w1_s1smK of {
                GHC.Real.:% ww4_s1smP [Occ=Once] ww5_s1smQ [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww2_s1smN ww5_s1smQ
                    of
                    sat_s1smS
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1smM ww4_s1smP
                          of
                          sat_s1smR
                          { __DEFAULT ->
                                case GHC.Real.$w$sreduce sat_s1smR sat_s1smS of {
                                  (#,#) ww7_s1smU [Occ=Once] ww8_s1smV [Occ=Once] ->
                                      GHC.Real.:% [ww7_s1smU ww8_s1smV];
                                };
                          };
                    };
              };
        };

GHC.Real.$w$s$c- [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=4, Str=<S,1*U><S,U><S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1smW ww1_s1smX ww2_s1smY ww3_s1smZ]
        case
            GHC.Integer.Type.timesInteger ww1_s1smX ww3_s1smZ
        of
        sat_s1sn3
        { __DEFAULT ->
              case
                  GHC.Integer.Type.timesInteger ww2_s1smY ww1_s1smX
              of
              sat_s1sn1
              { __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger ww_s1smW ww3_s1smZ
                    of
                    sat_s1sn0
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.minusInteger sat_s1sn0 sat_s1sn1
                          of
                          sat_s1sn2
                          { __DEFAULT -> GHC.Real.$w$sreduce sat_s1sn2 sat_s1sn3;
                          };
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$c- [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1sn4 w1_s1sn5]
        case w_s1sn4 of {
          GHC.Real.:% ww1_s1sn7 [Occ=Once] ww2_s1sn8 [Occ=Once] ->
              case w1_s1sn5 of {
                GHC.Real.:% ww4_s1sna [Occ=Once] ww5_s1snb [Occ=Once] ->
                    case GHC.Real.$w$s$c- ww1_s1sn7 ww2_s1sn8 ww4_s1sna ww5_s1snb of {
                      (#,#) ww7_s1snd [Occ=Once] ww8_s1sne [Occ=Once] ->
                          GHC.Real.:% [ww7_s1snd ww8_s1sne];
                    };
              };
        };

GHC.Real.$w$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=4, Str=<S,1*U><S,U><S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1snf ww1_s1sng ww2_s1snh ww3_s1sni]
        case
            GHC.Integer.Type.timesInteger ww1_s1sng ww3_s1sni
        of
        sat_s1snm
        { __DEFAULT ->
              case
                  GHC.Integer.Type.timesInteger ww2_s1snh ww1_s1sng
              of
              sat_s1snk
              { __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger ww_s1snf ww3_s1sni
                    of
                    sat_s1snj
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.plusInteger sat_s1snj sat_s1snk
                          of
                          sat_s1snl
                          { __DEFAULT -> GHC.Real.$w$sreduce sat_s1snl sat_s1snm;
                          };
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1snn w1_s1sno]
        case w_s1snn of {
          GHC.Real.:% ww1_s1snq [Occ=Once] ww2_s1snr [Occ=Once] ->
              case w1_s1sno of {
                GHC.Real.:% ww4_s1snt [Occ=Once] ww5_s1snu [Occ=Once] ->
                    case GHC.Real.$w$s$c+ ww1_s1snq ww2_s1snr ww4_s1snt ww5_s1snu of {
                      (#,#) ww7_s1snw [Occ=Once] ww8_s1snx [Occ=Once] ->
                          GHC.Real.:% [ww7_s1snw ww8_s1snx];
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$fNumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Num.Num (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Num.C:Num! [GHC.Real.$fEnumRatio_$s$c+
                                  GHC.Real.$fEnumRatio_$s$c-
                                  GHC.Real.$fFractionalRatio_$s$c*
                                  GHC.Real.$fFractionalRatio_$s$cnegate
                                  GHC.Real.$fFractionalRatio_$s$cabs
                                  GHC.Real.$fFractionalRatio_$s$csignum
                                  GHC.Real.$fFractionalRatio_$s$cfromInteger];

GHC.Real.$w$s$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1sny ww1_s1snz]
        case GHC.Integer.Type.absInteger ww1_s1snz of sat_s1snC {
          __DEFAULT ->
              case GHC.Integer.Type.signumInteger ww1_s1snz of sat_s1snA {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger ww_s1sny sat_s1snA
                    of
                    sat_s1snB
                    { __DEFAULT -> GHC.Real.$w$sreduce sat_s1snB sat_s1snC;
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Rational -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_s1snD]
        case w_s1snD of {
          GHC.Real.:% ww1_s1snF [Occ=Once] ww2_s1snG [Occ=Once] ->
              case GHC.Real.$w$s$cfromRational ww1_s1snF ww2_s1snG of {
                (#,#) ww4_s1snI [Occ=Once] ww5_s1snJ [Occ=Once] ->
                    GHC.Real.:% [ww4_s1snI ww5_s1snJ];
              };
        };

GHC.Real.$w$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId,
 Arity=4,
 Str=<S,1*U><S,1*U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_s1snK ww1_s1snL ww2_s1snM ww3_s1snN]
        case
            GHC.Integer.Type.timesInteger ww1_s1snL ww2_s1snM
        of
        y_s1snO [Dmd=<S,U>]
        { __DEFAULT ->
              case GHC.Integer.Type.absInteger y_s1snO of sat_s1snS {
                __DEFAULT ->
                    case GHC.Integer.Type.signumInteger y_s1snO of sat_s1snQ {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww_s1snK ww3_s1snN
                          of
                          sat_s1snP
                          { __DEFAULT ->
                                case
                                    GHC.Integer.Type.timesInteger sat_s1snP sat_s1snQ
                                of
                                sat_s1snR
                                { __DEFAULT -> GHC.Real.$w$sreduce sat_s1snR sat_s1snS;
                                };
                          };
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1snT w1_s1snU]
        case w_s1snT of {
          GHC.Real.:% ww1_s1snW [Occ=Once] ww2_s1snX [Occ=Once] ->
              case w1_s1snU of {
                GHC.Real.:% ww4_s1snZ [Occ=Once] ww5_s1so0 [Occ=Once] ->
                    case GHC.Real.$w$s$c/ ww1_s1snW ww2_s1snX ww4_s1snZ ww5_s1so0 of {
                      (#,#) ww7_s1so2 [Occ=Once] ww8_s1so3 [Occ=Once] ->
                          GHC.Real.:% [ww7_s1so2 ww8_s1so3];
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$fFractionalRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Fractional (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Fractional! [GHC.Real.$fFractionalRatio_$s$fNumRatio
                                          GHC.Real.$fFractionalRatio_$s$c/
                                          GHC.Real.$fFractionalRatio_$s$crecip
                                          GHC.Real.$fFractionalRatio_$s$cfromRational];

GHC.Real.ratioPrec :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [7#];

GHC.Real.infinity :: GHC.Real.Rational
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.$fEnumRatio1 GHC.Real.even1];

GHC.Real.notANumber :: GHC.Real.Rational
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.even1 GHC.Real.even1];

GHC.Real.numerator :: forall a. GHC.Real.Ratio a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_s1so4]
        case ds_s1so4 of {
          GHC.Real.:% x_s1so6 [Occ=Once] _ [Occ=Dead] -> x_s1so6;
        };

GHC.Real.denominator :: forall a. GHC.Real.Ratio a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1so8]
        case ds_s1so8 of {
          GHC.Real.:% _ [Occ=Dead] y_s1sob [Occ=Once] -> y_s1sob;
        };

GHC.Real.$w$snumericEnumFrom [InlPrag=NOUSERINLINE[0],
                              Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Real.Ratio GHC.Integer.Type.Integer,
           [GHC.Real.Ratio GHC.Integer.Type.Integer] #)
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1soc ww1_s1sod]
        let {
          sat_s1sol [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
          [LclId] =
              [ww_s1soc ww1_s1sod] \u []
                  case
                      GHC.Real.$w$s$c+
                          ww_s1soc ww1_s1sod GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
                  of
                  { (#,#) ww3_s1sog [Occ=Once] ww4_s1soh [Occ=Once] ->
                        case GHC.Real.$w$snumericEnumFrom ww3_s1sog ww4_s1soh of {
                          (#,#) ww6_s1soj [Occ=Once] ww7_s1sok [Occ=Once] ->
                              : [ww6_s1soj ww7_s1sok];
                        };
                  }; } in
        let {
          sat_s1soe [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId] =
              CCCS GHC.Real.:%! [ww_s1soc ww1_s1sod];
        } in  (#,#) [sat_s1soe sat_s1sol];

GHC.Real.$fEnumRatio_$snumericEnumFrom [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m2, Unf=OtherCon []] =
    [] \r [w_s1som]
        case w_s1som of {
          GHC.Real.:% ww1_s1soo [Occ=Once] ww2_s1sop [Occ=Once] ->
              case GHC.Real.$w$snumericEnumFrom ww1_s1soo ww2_s1sop of {
                (#,#) ww4_s1sor [Occ=Once] ww5_s1sos [Occ=Once] ->
                    : [ww4_s1sor ww5_s1sos];
              };
        };

GHC.Real.$wnumericEnumFrom [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: forall a. GHC.Real.Fractional a => a -> (# a, [a] #)
[GblId,
 Arity=2,
 Str=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1sot w1_s1sou]
        case w1_s1sou of n_s1sov {
          __DEFAULT ->
              let {
                sat_s1soC [Occ=Once] :: [a_s1hA7]
                [LclId] =
                    [w_s1sot n_s1sov] \u []
                        case
                            GHC.Real.$p1Fractional w_s1sot
                        of
                        $dNum_s1sow [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                        { __DEFAULT ->
                              let {
                                sat_s1sox [Occ=Once] :: a_s1hA7
                                [LclId] =
                                    [$dNum_s1sow] \u []
                                        GHC.Num.fromInteger $dNum_s1sow GHC.Real.$fEnumRatio1;
                              } in 
                                case GHC.Num.+ $dNum_s1sow n_s1sov sat_s1sox of sat_s1soy {
                                  __DEFAULT ->
                                      case GHC.Real.$wnumericEnumFrom w_s1sot sat_s1soy of {
                                        (#,#) ww1_s1soA [Occ=Once] ww2_s1soB [Occ=Once] ->
                                            : [ww1_s1soA ww2_s1soB];
                                      };
                                };
                        };
              } in  (#,#) [n_s1sov sat_s1soC];
        };

GHC.Real.numericEnumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Fractional a => a -> [a]
[GblId,
 Arity=2,
 Str=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_s1soD w1_s1soE]
        case GHC.Real.$wnumericEnumFrom w_s1soD w1_s1soE of {
          (#,#) ww1_s1soG [Occ=Once] ww2_s1soH [Occ=Once] ->
              : [ww1_s1soG ww2_s1soH];
        };

sat_s1soI :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_s1soJ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1soI GHC.Types.[]];

GHC.Real.even2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s1soJ;

GHC.Real.$fEnumRatio2 :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId] =
    [] \u []
        case
            GHC.Real.$w$s$c/
                GHC.Real.$fEnumRatio1
                GHC.Real.$fEnumRatio1
                GHC.Real.even2
                GHC.Real.$fEnumRatio1
        of
        { (#,#) ww1_s1soL [Occ=Once] ww2_s1soM [Occ=Once] ->
              GHC.Real.:% [ww1_s1soL ww2_s1soM];
        };

GHC.Real.$w$snumericEnumFromTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId, Arity=3, Str=<L,U><L,U><L,1*U(U,U)>, Unf=OtherCon []] =
    [] \r [ww_s1soN ww1_s1soO w_s1soP]
        case GHC.Real.$w$snumericEnumFrom ww_s1soN ww1_s1soO of {
          (#,#) ww3_s1soR [Occ=Once] ww4_s1soS [Occ=Once] ->
              let {
                sat_s1sp5 [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
                [LclId] =
                    CCCS :! [ww3_s1soR ww4_s1soS]; } in
              let {
                ds_s1soT [Occ=OnceL, Dmd=<L,U(U,U)>]
                  :: GHC.Real.Ratio GHC.Integer.Type.Integer
                [LclId] =
                    [w_s1soP] \u []
                        case w_s1soP of {
                          GHC.Real.:% ww6_s1soV [Occ=Once] ww7_s1soW [Occ=Once] ->
                              case GHC.Real.$fEnumRatio2 of {
                                GHC.Real.:% ww9_s1soY [Occ=Once] ww10_s1soZ [Occ=Once] ->
                                    case
                                        GHC.Real.$w$s$c+ ww6_s1soV ww7_s1soW ww9_s1soY ww10_s1soZ
                                    of
                                    { (#,#) ww12_s1sp1 [Occ=Once] ww13_s1sp2 [Occ=Once] ->
                                          GHC.Real.:% [ww12_s1sp1 ww13_s1sp2];
                                    };
                              };
                        }; } in
              let {
                sat_s1sp4 [Occ=Once]
                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                [LclId] =
                    [ds_s1soT] \r [ds1_s1sp3]
                        GHC.Real.$fEnumRatio_$s$c<= ds1_s1sp3 ds_s1soT;
              } in  GHC.List.takeWhile sat_s1sp4 sat_s1sp5;
        };

GHC.Real.$fEnumRatio_$snumericEnumFromTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sp6 w1_s1sp7]
        case w_s1sp6 of {
          GHC.Real.:% ww1_s1sp9 [Occ=Once] ww2_s1spa [Occ=Once] ->
              GHC.Real.$w$snumericEnumFromTo ww1_s1sp9 ww2_s1spa w1_s1sp7;
        };

GHC.Real.numericEnumFromTo
  :: forall a.
     (GHC.Classes.Ord a, GHC.Real.Fractional a) =>
     a -> a -> [a]
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U(U(C(C1(U)),A,A,A,A,A,C(U)),1*C1(C1(U)),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1spb $dFractional_s1spc eta_s1spd eta1_s1spe]
        case GHC.Real.$wnumericEnumFrom $dFractional_s1spc eta_s1spd of {
          (#,#) ww1_s1spg [Occ=Once] ww2_s1sph [Occ=Once] ->
              let {
                $dNum_s1spi [Dmd=<L,U(1*C1(C1(U)),A,A,A,A,A,C(U))>]
                  :: GHC.Num.Num a_a1ew7
                [LclId] =
                    [$dFractional_s1spc] \u []
                        GHC.Real.$p1Fractional $dFractional_s1spc; } in
              let {
                sat_s1spp [Occ=Once] :: [a_a1ew7]
                [LclId] =
                    CCCS :! [ww1_s1spg ww2_s1sph]; } in
              let {
                ds_s1spj [Occ=OnceL] :: a_a1ew7
                [LclId] =
                    [$dFractional_s1spc eta1_s1spe $dNum_s1spi] \u []
                        let {
                          sat_s1spm [Occ=Once] :: a_a1ew7
                          [LclId] =
                              [$dFractional_s1spc $dNum_s1spi] \u []
                                  let {
                                    sat_s1spl [Occ=Once] :: a_a1ew7
                                    [LclId] =
                                        [$dNum_s1spi] \u []
                                            GHC.Num.fromInteger $dNum_s1spi GHC.Real.even2; } in
                                  let {
                                    sat_s1spk [Occ=Once] :: a_a1ew7
                                    [LclId] =
                                        [$dNum_s1spi] \u []
                                            GHC.Num.fromInteger $dNum_s1spi GHC.Real.$fEnumRatio1;
                                  } in  GHC.Real./ $dFractional_s1spc sat_s1spk sat_s1spl;
                        } in  GHC.Num.+ $dNum_s1spi eta1_s1spe sat_s1spm; } in
              let {
                sat_s1spo [Occ=Once] :: a_a1ew7 -> GHC.Types.Bool
                [LclId] =
                    [$dOrd_s1spb ds_s1spj] \r [ds1_s1spn]
                        GHC.Classes.<= $dOrd_s1spb ds1_s1spn ds_s1spj;
              } in  GHC.List.takeWhile sat_s1spo sat_s1spp;
        };

GHC.Real.$w$snumericEnumFromThen [InlPrag=NOUSERINLINE[0],
                                  Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Real.Ratio GHC.Integer.Type.Integer,
           [GHC.Real.Ratio GHC.Integer.Type.Integer] #)
[GblId, Arity=4, Str=<L,U><L,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1spq ww1_s1spr ww2_s1sps ww3_s1spt]
        let {
          sat_s1spE [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
          [LclId] =
              [ww_s1spq ww1_s1spr ww2_s1sps ww3_s1spt] \u []
                  case GHC.Real.$w$s$c+ ww2_s1sps ww3_s1spt ww2_s1sps ww3_s1spt of {
                    (#,#) ww5_s1spw [Occ=Once] ww6_s1spx [Occ=Once] ->
                        case GHC.Real.$w$s$c- ww5_s1spw ww6_s1spx ww_s1spq ww1_s1spr of {
                          (#,#) ww8_s1spz [Occ=Once] ww9_s1spA [Occ=Once] ->
                              case
                                  GHC.Real.$w$snumericEnumFromThen
                                      ww2_s1sps ww3_s1spt ww8_s1spz ww9_s1spA
                              of
                              { (#,#) ww11_s1spC [Occ=Once] ww12_s1spD [Occ=Once] ->
                                    : [ww11_s1spC ww12_s1spD];
                              };
                        };
                  }; } in
        let {
          sat_s1spu [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId] =
              CCCS GHC.Real.:%! [ww_s1spq ww1_s1spr];
        } in  (#,#) [sat_s1spu sat_s1spE];

GHC.Real.$fEnumRatio_$snumericEnumFromThen [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s1spF w1_s1spG]
        case w_s1spF of {
          GHC.Real.:% ww1_s1spI [Occ=Once] ww2_s1spJ [Occ=Once] ->
              case w1_s1spG of {
                GHC.Real.:% ww4_s1spL [Occ=Once] ww5_s1spM [Occ=Once] ->
                    case
                        GHC.Real.$w$snumericEnumFromThen
                            ww1_s1spI ww2_s1spJ ww4_s1spL ww5_s1spM
                    of
                    { (#,#) ww7_s1spO [Occ=Once] ww8_s1spP [Occ=Once] ->
                          : [ww7_s1spO ww8_s1spP];
                    };
              };
        };

GHC.Real.$wnumericEnumFromThen [InlPrag=NOUSERINLINE[0],
                                Occ=LoopBreaker]
  :: forall a. GHC.Real.Fractional a => a -> a -> (# a, [a] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1spQ w1_s1spR w2_s1spS]
        case w1_s1spR of n_s1spT {
          __DEFAULT ->
              case w2_s1spS of m_s1spU {
                __DEFAULT ->
                    let {
                      sat_s1sq1 [Occ=Once] :: [a_s1hAH]
                      [LclId] =
                          [w_s1spQ n_s1spT m_s1spU] \u []
                              case
                                  GHC.Real.$p1Fractional w_s1spQ
                              of
                              $dNum_s1spV [Dmd=<S(LC(C(S))LLLLL),U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,A)>]
                              { __DEFAULT ->
                                    let {
                                      sat_s1spW [Occ=Once] :: a_s1hAH
                                      [LclId] =
                                          [m_s1spU $dNum_s1spV] \u []
                                              GHC.Num.+ $dNum_s1spV m_s1spU m_s1spU;
                                    } in 
                                      case GHC.Num.- $dNum_s1spV sat_s1spW n_s1spT of sat_s1spX {
                                        __DEFAULT ->
                                            case
                                                GHC.Real.$wnumericEnumFromThen
                                                    w_s1spQ m_s1spU sat_s1spX
                                            of
                                            { (#,#) ww1_s1spZ [Occ=Once] ww2_s1sq0 [Occ=Once] ->
                                                  : [ww1_s1spZ ww2_s1sq0];
                                            };
                                      };
                              };
                    } in  (#,#) [n_s1spT sat_s1sq1];
              };
        };

GHC.Real.numericEnumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Fractional a => a -> a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)><S,1*U><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_s1sq2 w1_s1sq3 w2_s1sq4]
        case GHC.Real.$wnumericEnumFromThen w_s1sq2 w1_s1sq3 w2_s1sq4 of {
          (#,#) ww1_s1sq6 [Occ=Once] ww2_s1sq7 [Occ=Once] ->
              : [ww1_s1sq6 ww2_s1sq7];
        };

GHC.Real.$w$snumericEnumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=5,
 Str=<L,U><L,U><L,U><L,U><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [ww_s1sq8 ww1_s1sq9 ww2_s1sqa ww3_s1sqb w_s1sqc]
        case
            GHC.Real.$w$snumericEnumFromThen
                ww_s1sq8 ww1_s1sq9 ww2_s1sqa ww3_s1sqb
        of
        { (#,#) ww5_s1sqe [Occ=Once] ww6_s1sqf [Occ=Once] ->
              let {
                sat_s1sqM [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
                [LclId] =
                    CCCS :! [ww5_s1sqe ww6_s1sqf]; } in
              let {
                sat_s1sqL [Occ=Once, Dmd=<L,C(U)>]
                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                [LclId] =
                    [ww_s1sq8 ww1_s1sq9 ww2_s1sqa ww3_s1sqb w_s1sqc] \u []
                        case
                            GHC.Real.$w$s$ccompare ww2_s1sqa ww3_s1sqb ww_s1sq8 ww1_s1sq9
                        of
                        { __DEFAULT ->
                              let {
                                ds_s1sqh [Occ=OnceL, Dmd=<L,U(U,U)>]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer
                                [LclId] =
                                    [ww_s1sq8 ww1_s1sq9 ww2_s1sqa ww3_s1sqb w_s1sqc] \u []
                                        case w_s1sqc of {
                                          GHC.Real.:% ww8_s1sqj [Occ=Once] ww9_s1sqk [Occ=Once] ->
                                              case
                                                  GHC.Real.$w$s$c-
                                                      ww2_s1sqa ww3_s1sqb ww_s1sq8 ww1_s1sq9
                                              of
                                              { (#,#) ww11_s1sqm [Occ=Once] ww12_s1sqn [Occ=Once] ->
                                                    case
                                                        GHC.Real.$w$s$c/
                                                            ww11_s1sqm
                                                            ww12_s1sqn
                                                            GHC.Real.even2
                                                            GHC.Real.$fEnumRatio1
                                                    of
                                                    { (#,#) ww14_s1sqp [Occ=Once]
                                                            ww15_s1sqq [Occ=Once] ->
                                                          case
                                                              GHC.Real.$w$s$c+
                                                                  ww8_s1sqj
                                                                  ww9_s1sqk
                                                                  ww14_s1sqp
                                                                  ww15_s1sqq
                                                          of
                                                          { (#,#) ww17_s1sqs [Occ=Once]
                                                                  ww18_s1sqt [Occ=Once] ->
                                                                GHC.Real.:% [ww17_s1sqs ww18_s1sqt];
                                                          };
                                                    };
                                              };
                                        }; } in
                              let {
                                sat_s1sqv [Occ=OnceT[0]]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                                [LclId] =
                                    [ds_s1sqh] \r [ds1_s1squ]
                                        GHC.Real.$fEnumRatio_$s$c<= ds1_s1squ ds_s1sqh;
                              } in  sat_s1sqv;
                          GHC.Types.LT ->
                              let {
                                ds_s1sqw [Occ=OnceL, Dmd=<L,U(U,U)>]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer
                                [LclId] =
                                    [ww_s1sq8 ww1_s1sq9 ww2_s1sqa ww3_s1sqb w_s1sqc] \u []
                                        case w_s1sqc of {
                                          GHC.Real.:% ww8_s1sqy [Occ=Once] ww9_s1sqz [Occ=Once] ->
                                              case
                                                  GHC.Real.$w$s$c-
                                                      ww2_s1sqa ww3_s1sqb ww_s1sq8 ww1_s1sq9
                                              of
                                              { (#,#) ww11_s1sqB [Occ=Once] ww12_s1sqC [Occ=Once] ->
                                                    case
                                                        GHC.Real.$w$s$c/
                                                            ww11_s1sqB
                                                            ww12_s1sqC
                                                            GHC.Real.even2
                                                            GHC.Real.$fEnumRatio1
                                                    of
                                                    { (#,#) ww14_s1sqE [Occ=Once]
                                                            ww15_s1sqF [Occ=Once] ->
                                                          case
                                                              GHC.Real.$w$s$c+
                                                                  ww8_s1sqy
                                                                  ww9_s1sqz
                                                                  ww14_s1sqE
                                                                  ww15_s1sqF
                                                          of
                                                          { (#,#) ww17_s1sqH [Occ=Once]
                                                                  ww18_s1sqI [Occ=Once] ->
                                                                GHC.Real.:% [ww17_s1sqH ww18_s1sqI];
                                                          };
                                                    };
                                              };
                                        }; } in
                              let {
                                sat_s1sqK [Occ=OnceT[0]]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                                [LclId] =
                                    [ds_s1sqw] \r [ds1_s1sqJ]
                                        GHC.Real.$fEnumRatio_$s$c>= ds1_s1sqJ ds_s1sqw;
                              } in  sat_s1sqK;
                        };
              } in  GHC.List.takeWhile sat_s1sqL sat_s1sqM;
        };

GHC.Real.$fEnumRatio_$snumericEnumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=3,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sqN w1_s1sqO w2_s1sqP]
        case w_s1sqN of {
          GHC.Real.:% ww1_s1sqR [Occ=Once] ww2_s1sqS [Occ=Once] ->
              case w1_s1sqO of {
                GHC.Real.:% ww4_s1sqU [Occ=Once] ww5_s1sqV [Occ=Once] ->
                    GHC.Real.$w$snumericEnumFromThenTo
                        ww1_s1sqR ww2_s1sqS ww4_s1sqU ww5_s1sqV w2_s1sqP;
              };
        };

GHC.Real.numericEnumFromThenTo
  :: forall a.
     (GHC.Classes.Ord a, GHC.Real.Fractional a) =>
     a -> a -> a -> [a]
[GblId,
 Arity=5,
 Str=<L,U(A,A,A,C(C1(U)),A,C(C1(U)),A,A)><L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,1*C1(U)),1*C1(C1(U)),A,A)><S,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1sqW
           $dFractional_s1sqX
           eta_s1sqY
           eta1_s1sqZ
           eta2_s1sr0]
        case
            GHC.Real.$wnumericEnumFromThen
                $dFractional_s1sqX eta_s1sqY eta1_s1sqZ
        of
        { (#,#) ww1_s1sr2 [Occ=Once] ww2_s1sr3 [Occ=Once] ->
              let {
                sat_s1srg [Occ=Once] :: [a_a1evf]
                [LclId] =
                    CCCS :! [ww1_s1sr2 ww2_s1sr3]; } in
              let {
                sat_s1srf [Occ=Once, Dmd=<L,C(U)>] :: a_a1evf -> GHC.Types.Bool
                [LclId] =
                    [$dOrd_s1sqW
                     $dFractional_s1sqX
                     eta_s1sqY
                     eta1_s1sqZ
                     eta2_s1sr0] \u []
                        let {
                          $dNum_s1sr4 [Dmd=<L,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                            :: GHC.Num.Num a_a1evf
                          [LclId] =
                              [$dFractional_s1sqX] \u []
                                  GHC.Real.$p1Fractional $dFractional_s1sqX; } in
                        let {
                          mid_s1sr5 [Occ=Once*] :: a_a1evf
                          [LclId] =
                              [$dFractional_s1sqX eta_s1sqY eta1_s1sqZ $dNum_s1sr4] \u []
                                  let {
                                    sat_s1sr7 [Occ=Once] :: a_a1evf
                                    [LclId] =
                                        [$dNum_s1sr4] \u []
                                            GHC.Num.fromInteger $dNum_s1sr4 GHC.Real.even2; } in
                                  let {
                                    sat_s1sr6 [Occ=Once] :: a_a1evf
                                    [LclId] =
                                        [eta_s1sqY eta1_s1sqZ $dNum_s1sr4] \u []
                                            GHC.Num.- $dNum_s1sr4 eta1_s1sqZ eta_s1sqY;
                                  } in  GHC.Real./ $dFractional_s1sqX sat_s1sr6 sat_s1sr7;
                        } in 
                          case GHC.Classes.>= $dOrd_s1sqW eta1_s1sqZ eta_s1sqY of {
                            GHC.Types.False ->
                                let {
                                  ds_s1sr9 [Occ=OnceL] :: a_a1evf
                                  [LclId] =
                                      [eta2_s1sr0 $dNum_s1sr4 mid_s1sr5] \u []
                                          GHC.Num.+ $dNum_s1sr4 eta2_s1sr0 mid_s1sr5; } in
                                let {
                                  sat_s1srb [Occ=OnceT[0]] :: a_a1evf -> GHC.Types.Bool
                                  [LclId] =
                                      [$dOrd_s1sqW ds_s1sr9] \r [ds1_s1sra]
                                          GHC.Classes.>= $dOrd_s1sqW ds1_s1sra ds_s1sr9;
                                } in  sat_s1srb;
                            GHC.Types.True ->
                                let {
                                  ds_s1src [Occ=OnceL] :: a_a1evf
                                  [LclId] =
                                      [eta2_s1sr0 $dNum_s1sr4 mid_s1sr5] \u []
                                          GHC.Num.+ $dNum_s1sr4 eta2_s1sr0 mid_s1sr5; } in
                                let {
                                  sat_s1sre [Occ=OnceT[0]] :: a_a1evf -> GHC.Types.Bool
                                  [LclId] =
                                      [$dOrd_s1sqW ds_s1src] \r [ds1_s1srd]
                                          GHC.Classes.<= $dOrd_s1sqW ds1_s1srd ds_s1src;
                                } in  sat_s1sre;
                          };
              } in  GHC.List.takeWhile sat_s1srf sat_s1srg;
        };

GHC.Real.fromIntegral [InlPrag=NOINLINE[1]]
  :: forall a b. (GHC.Real.Integral a, GHC.Num.Num b) => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U))><S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1srh $dNum_s1sri eta_s1srj]
        let {
          sat_s1srk [Occ=Once] :: GHC.Integer.Type.Integer
          [LclId] =
              [$dIntegral_s1srh eta_s1srj] \u []
                  GHC.Real.toInteger $dIntegral_s1srh eta_s1srj;
        } in  GHC.Num.fromInteger $dNum_s1sri sat_s1srk;

GHC.Real.realToFrac [InlPrag=NOINLINE[1]]
  :: forall a b. (GHC.Real.Real a, GHC.Real.Fractional b) => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(U))><S(LLLC(S)),1*U(A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_s1srl $dFractional_s1srm eta_s1srn]
        let {
          sat_s1sro [Occ=Once] :: GHC.Real.Rational
          [LclId] =
              [$dReal_s1srl eta_s1srn] \u []
                  GHC.Real.toRational $dReal_s1srl eta_s1srn;
        } in  GHC.Real.fromRational $dFractional_s1srm sat_s1sro;

GHC.Real.showSigned1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['-'#];

GHC.Real.showSigned
  :: forall a.
     GHC.Real.Real a =>
     (a -> GHC.Show.ShowS) -> GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)><L,1*C1(U)><L,1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_s1srp eta_s1srq eta1_s1srr eta2_s1srs]
        let {
          $dNum_s1srt [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>]
            :: GHC.Num.Num a_a1euj
          [LclId] =
              [$dReal_s1srp] \u [] GHC.Real.$p1Real $dReal_s1srp; } in
        let {
          sat_s1srv [Occ=Once] :: a_a1euj
          [LclId] =
              [$dNum_s1srt] \u [] GHC.Num.fromInteger $dNum_s1srt GHC.Real.even1;
        } in 
          case GHC.Real.$p2Real $dReal_s1srp of sat_s1sru {
            __DEFAULT ->
                case GHC.Classes.< sat_s1sru eta2_s1srs sat_s1srv of {
                  GHC.Types.False -> eta_s1srq eta2_s1srs;
                  GHC.Types.True ->
                      case eta1_s1srr of {
                        GHC.Types.I# x_s1sry [Occ=Once] ->
                            let {
                              g1_s1srz [Occ=OnceL*!, Dmd=<L,C(U)>]
                                :: GHC.Base.String -> GHC.Base.String
                              [LclId] =
                                  [eta_s1srq eta2_s1srs $dNum_s1srt] \u []
                                      let {
                                        sat_s1srA [Occ=Once] :: a_a1euj
                                        [LclId] =
                                            [eta2_s1srs $dNum_s1srt] \u []
                                                GHC.Num.negate $dNum_s1srt eta2_s1srs;
                                      } in  eta_s1srq sat_s1srA;
                            } in 
                              case ># [x_s1sry 6#] of {
                                __DEFAULT ->
                                    let {
                                      sat_s1srE [Occ=OnceT[0]]
                                        :: GHC.Base.String -> [GHC.Types.Char]
                                      [LclId] =
                                          [g1_s1srz] \r [x1_s1srC]
                                              let {
                                                sat_s1srD [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_s1srz x1_s1srC] \u [] g1_s1srz x1_s1srC;
                                              } in  : [GHC.Real.showSigned1 sat_s1srD];
                                    } in  sat_s1srE;
                                1# ->
                                    let {
                                      sat_s1srJ [Occ=OnceT[0]]
                                        :: GHC.Base.String -> [GHC.Types.Char]
                                      [LclId] =
                                          [g1_s1srz] \r [x1_s1srF]
                                              let {
                                                sat_s1srH [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_s1srz x1_s1srF] \u []
                                                        let {
                                                          sat_s1srG [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2
                                                                       x1_s1srF];
                                                        } in  g1_s1srz sat_s1srG; } in
                                              let {
                                                sat_s1srI [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    CCCS :! [GHC.Real.showSigned1 sat_s1srH];
                                              } in  : [GHC.Show.$fShow(,)4 sat_s1srI];
                                    } in  sat_s1srJ;
                              };
                      };
                };
          };

GHC.Real.even [InlPrag=INLINABLE]
  :: forall a. GHC.Real.Integral a => a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,1*C1(C1(U)),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1srK eta_s1srL]
        case
            GHC.Real.$p1Integral $dIntegral_s1srK
        of
        $dReal_s1srM [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1srN [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_a1eq0
                [LclId] =
                    [$dReal_s1srM] \u [] GHC.Real.$p1Real $dReal_s1srM; } in
              let {
                sat_s1srS [Occ=Once] :: a_a1eq0
                [LclId] =
                    [$dNum_s1srN] \u []
                        GHC.Num.fromInteger $dNum_s1srN GHC.Real.even1; } in
              let {
                sat_s1srR [Occ=Once] :: a_a1eq0
                [LclId] =
                    [$dIntegral_s1srK eta_s1srL $dNum_s1srN] \u []
                        let {
                          sat_s1srQ [Occ=Once] :: a_a1eq0
                          [LclId] =
                              [$dNum_s1srN] \u [] GHC.Num.fromInteger $dNum_s1srN GHC.Real.even2;
                        } in  GHC.Real.rem $dIntegral_s1srK eta_s1srL sat_s1srQ;
              } in 
                case GHC.Real.$p2Real $dReal_s1srM of sat_s1srO {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_s1srO of sat_s1srP {
                        __DEFAULT -> GHC.Classes.== sat_s1srP sat_s1srR sat_s1srS;
                      };
                };
        };

GHC.Real.odd [InlPrag=INLINABLE]
  :: forall a. GHC.Real.Integral a => a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1srT x_s1srU]
        case GHC.Real.even $dIntegral_s1srT x_s1srU of {
          GHC.Types.False -> GHC.Types.True [];
          GHC.Types.True -> GHC.Types.False [];
        };

lvl3_r1j3b :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.$fEnumRatio1 GHC.Real.even2];

lvl4_r1j3c :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "round default defn: Bad value"#;

GHC.Real.$fRealFracRatio1 :: forall b. b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl4_r1j3c of sat_s1srW {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1srW;
        };

GHC.Real.$dmround
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,A,A,1*C1(U)),1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U(U(U,U),U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1srX eta_s1srY eta1_s1srZ]
        let {
          ds_s1ss0 [Dmd=<L,U(1*U,1*U)>] :: (b_a1eBu, a_a1dNs)
          [LclId] =
              [$dRealFrac_s1srX eta_s1srY eta1_s1srZ] \u []
                  GHC.Real.properFraction $dRealFrac_s1srX eta_s1srY eta1_s1srZ;
        } in 
          case
              GHC.Real.$p1RealFrac $dRealFrac_s1srX
          of
          $dReal_s1ss1 [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p2Real $dReal_s1ss1
                of
                $dOrd_s1ss2 [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Classes.$p1Ord $dOrd_s1ss2
                      of
                      $dEq_s1ss3 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                      { __DEFAULT ->
                            let {
                              $dNum_s1ss4 [Dmd=<L,U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U))>]
                                :: GHC.Num.Num a_a1dNs
                              [LclId] =
                                  [$dReal_s1ss1] \u [] GHC.Real.$p1Real $dReal_s1ss1; } in
                            let {
                              r_s1ss5 :: a_a1dNs
                              [LclId] =
                                  [ds_s1ss0] \u []
                                      case ds_s1ss0 of {
                                        (,) _ [Occ=Dead] r1_s1ss8 [Occ=Once] -> r1_s1ss8;
                                      }; } in
                            let {
                              ds1_s1ss9 :: a_a1dNs
                              [LclId] =
                                  [$dRealFrac_s1srX $dNum_s1ss4 r_s1ss5] \u []
                                      let {
                                        sat_s1ssd [Occ=Once] :: a_a1dNs
                                        [LclId] =
                                            [$dRealFrac_s1srX $dNum_s1ss4 r_s1ss5] \u []
                                                let {
                                                  sat_s1ssc [Occ=Once] :: a_a1dNs
                                                  [LclId] =
                                                      [$dRealFrac_s1srX] \u []
                                                          case
                                                              GHC.Real.$p2RealFrac $dRealFrac_s1srX
                                                          of
                                                          sat_s1ssb
                                                          { __DEFAULT ->
                                                                GHC.Real.fromRational
                                                                    sat_s1ssb lvl3_r1j3b;
                                                          }; } in
                                                let {
                                                  sat_s1ssa [Occ=Once] :: a_a1dNs
                                                  [LclId] =
                                                      [$dNum_s1ss4 r_s1ss5] \u []
                                                          GHC.Num.abs $dNum_s1ss4 r_s1ss5;
                                                } in  GHC.Num.- $dNum_s1ss4 sat_s1ssa sat_s1ssc;
                                      } in  GHC.Num.signum $dNum_s1ss4 sat_s1ssd; } in
                            let {
                              n_s1sse :: b_a1eBu
                              [LclId] =
                                  [ds_s1ss0] \u []
                                      case ds_s1ss0 of {
                                        (,) n1_s1ssg [Occ=Once] _ [Occ=Dead] -> n1_s1ssg;
                                      }; } in
                            let {
                              sat_s1ssj [Occ=Once] :: a_a1dNs
                              [LclId] =
                                  [$dNum_s1ss4] \u []
                                      let {
                                        sat_s1ssi [Occ=Once] :: a_a1dNs
                                        [LclId] =
                                            [$dNum_s1ss4] \u []
                                                GHC.Num.fromInteger
                                                    $dNum_s1ss4 GHC.Real.$fEnumRatio1;
                                      } in  GHC.Num.negate $dNum_s1ss4 sat_s1ssi;
                            } in 
                              case GHC.Classes.== $dEq_s1ss3 ds1_s1ss9 sat_s1ssj of {
                                GHC.Types.False ->
                                    let {
                                      sat_s1sss [Occ=Once] :: a_a1dNs
                                      [LclId] =
                                          [$dNum_s1ss4] \u []
                                              GHC.Num.fromInteger $dNum_s1ss4 GHC.Real.even1;
                                    } in 
                                      let-no-escape {
                                        m_s1ssl [Occ=Once*T[0], Dmd=<L,1*U>] :: b_a1eBu
                                        [LclId[JoinId(0)], Unf=OtherCon []] =
                                            [eta_s1srY
                                             $dOrd_s1ss2
                                             $dNum_s1ss4
                                             r_s1ss5
                                             n_s1sse] \r []
                                                case
                                                    GHC.Real.$p1Integral eta_s1srY
                                                of
                                                $dReal1_s1ssm [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                                { __DEFAULT ->
                                                      case
                                                          GHC.Real.$p1Real $dReal1_s1ssm
                                                      of
                                                      $dNum1_s1ssn [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                                      { __DEFAULT ->
                                                            let {
                                                              sat_s1sso [Occ=Once] :: a_a1dNs
                                                              [LclId] =
                                                                  [$dNum_s1ss4] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_s1ss4
                                                                          GHC.Real.even1;
                                                            } in 
                                                              case
                                                                  GHC.Classes.<
                                                                      $dOrd_s1ss2 r_s1ss5 sat_s1sso
                                                              of
                                                              { GHC.Types.False ->
                                                                    let {
                                                                      sat_s1ssq [Occ=Once]
                                                                        :: b_a1eBu
                                                                      [LclId] =
                                                                          [$dNum1_s1ssn] \u []
                                                                              GHC.Num.fromInteger
                                                                                  $dNum1_s1ssn
                                                                                  GHC.Real.$fEnumRatio1;
                                                                    } in 
                                                                      GHC.Num.+
                                                                          $dNum1_s1ssn
                                                                          n_s1sse
                                                                          sat_s1ssq;
                                                                GHC.Types.True ->
                                                                    let {
                                                                      sat_s1ssr [Occ=Once]
                                                                        :: b_a1eBu
                                                                      [LclId] =
                                                                          [$dNum1_s1ssn] \u []
                                                                              GHC.Num.fromInteger
                                                                                  $dNum1_s1ssn
                                                                                  GHC.Real.$fEnumRatio1;
                                                                    } in 
                                                                      GHC.Num.-
                                                                          $dNum1_s1ssn
                                                                          n_s1sse
                                                                          sat_s1ssr;
                                                              };
                                                      };
                                                };
                                      } in 
                                        case GHC.Classes.== $dEq_s1ss3 ds1_s1ss9 sat_s1sss of {
                                          GHC.Types.False ->
                                              let {
                                                sat_s1ssu [Occ=Once] :: a_a1dNs
                                                [LclId] =
                                                    [$dNum_s1ss4] \u []
                                                        GHC.Num.fromInteger
                                                            $dNum_s1ss4 GHC.Real.$fEnumRatio1;
                                              } in 
                                                case
                                                    GHC.Classes.== $dEq_s1ss3 ds1_s1ss9 sat_s1ssu
                                                of
                                                { GHC.Types.False -> GHC.Real.$fRealFracRatio1;
                                                  GHC.Types.True -> m_s1ssl;
                                                };
                                          GHC.Types.True ->
                                              case GHC.Real.even eta_s1srY n_s1sse of {
                                                GHC.Types.False -> m_s1ssl;
                                                GHC.Types.True -> n_s1sse;
                                              };
                                        };
                                GHC.Types.True -> n_s1sse;
                              };
                      };
                };
          };

GHC.Real.integralEnumFrom
  :: forall a. (GHC.Real.Integral a, GHC.Enum.Bounded a) => a -> [a]
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,1*U(A,1*U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1ssx $dBounded_s1ssy eta_s1ssz]
        let {
          f_s1ssA [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
            :: GHC.Real.Real a_a1eoa
          [LclId] =
              [$dIntegral_s1ssx] \s []
                  GHC.Real.$p1Integral $dIntegral_s1ssx; } in
        let {
          f1_s1ssB [Occ=OnceL, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
            :: GHC.Num.Num a_a1eoa
          [LclId] =
              [f_s1ssA] \u [] GHC.Real.$p1Real f_s1ssA; } in
        let {
          sat_s1ssD [Occ=Once] :: a_a1eoa
          [LclId] =
              [$dBounded_s1ssy] \u [] GHC.Enum.maxBound $dBounded_s1ssy;
        } in 
          case
              GHC.Real.toInteger $dIntegral_s1ssx sat_s1ssD
          of
          lim_s1ssC [Dmd=<S,U>]
          { __DEFAULT ->
                let {
                  go_s1ssE [Occ=LoopBreaker] :: GHC.Integer.Type.Integer -> [a_a1eoa]
                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                      sat-only [f1_s1ssB lim_s1ssC go_s1ssE] \r [x_s1ssF]
                          case GHC.Integer.Type.gtInteger# x_s1ssF lim_s1ssC of {
                            __DEFAULT ->
                                let {
                                  sat_s1ssJ [Occ=Once] :: [a_a1eoa]
                                  [LclId] =
                                      [go_s1ssE x_s1ssF] \u []
                                          case
                                              GHC.Integer.Type.plusInteger
                                                  x_s1ssF GHC.Real.$fEnumRatio1
                                          of
                                          sat_s1ssI
                                          { __DEFAULT -> go_s1ssE sat_s1ssI;
                                          }; } in
                                let {
                                  sat_s1ssH [Occ=Once] :: a_a1eoa
                                  [LclId] =
                                      [f1_s1ssB x_s1ssF] \u [] GHC.Num.fromInteger f1_s1ssB x_s1ssF;
                                } in  : [sat_s1ssH sat_s1ssJ];
                            1# -> [] [];
                          };
                } in 
                  case GHC.Real.toInteger $dIntegral_s1ssx eta_s1ssz of sat_s1ssK {
                    __DEFAULT -> go_s1ssE sat_s1ssK;
                  };
          };

GHC.Real.integralEnumFromThen
  :: forall a.
     (GHC.Real.Integral a, GHC.Enum.Bounded a) =>
     a -> a -> [a]
[GblId,
 Arity=4,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,1*U(1*U,1*U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1ssL $dBounded_s1ssM eta_s1ssN eta1_s1ssO]
        case
            GHC.Real.toInteger $dIntegral_s1ssL eta1_s1ssO
        of
        i_n2_s1ssP [Dmd=<S,U>]
        { __DEFAULT ->
              case
                  GHC.Real.toInteger $dIntegral_s1ssL eta_s1ssN
              of
              i_n1_s1ssQ [Dmd=<S,U>]
              { __DEFAULT ->
                    case GHC.Integer.Type.geInteger# i_n2_s1ssP i_n1_s1ssQ of {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.minusInteger i_n2_s1ssP i_n1_s1ssQ
                          of
                          delta_s1ssS [Dmd=<S,U>]
                          { __DEFAULT ->
                                let {
                                  f_s1ssT [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
                                    :: GHC.Real.Real a_a1enm
                                  [LclId] =
                                      [$dIntegral_s1ssL] \s []
                                          GHC.Real.$p1Integral $dIntegral_s1ssL; } in
                                let {
                                  f1_s1ssU [Occ=OnceL*, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
                                    :: GHC.Num.Num a_a1enm
                                  [LclId] =
                                      [f_s1ssT] \u [] GHC.Real.$p1Real f_s1ssT;
                                } in 
                                  case GHC.Integer.Type.geInteger# delta_s1ssS GHC.Real.even1 of {
                                    __DEFAULT ->
                                        let {
                                          sat_s1ssX [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1ssM] \u []
                                                  GHC.Enum.minBound $dBounded_s1ssM;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1ssL sat_s1ssX
                                          of
                                          lim_s1ssW [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1ssY [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1ssS
                                                                f1_s1ssU
                                                                lim_s1ssW
                                                                go_s1ssY] \r [x_s1ssZ]
                                                          case
                                                              GHC.Integer.Type.ltInteger#
                                                                  x_s1ssZ lim_s1ssW
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1st3 [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1ssS
                                                                       go_s1ssY
                                                                       x_s1ssZ] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1ssZ
                                                                                  delta_s1ssS
                                                                          of
                                                                          sat_s1st2
                                                                          { __DEFAULT ->
                                                                                go_s1ssY sat_s1st2;
                                                                          }; } in
                                                                let {
                                                                  sat_s1st1 [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1ssU x_s1ssZ] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1ssU x_s1ssZ;
                                                                } in  : [sat_s1st1 sat_s1st3];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1ssY i_n1_s1ssQ;
                                          };
                                    1# ->
                                        let {
                                          sat_s1st5 [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1ssM] \u []
                                                  GHC.Enum.minBound $dBounded_s1ssM;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1ssL sat_s1st5
                                          of
                                          lim_s1st4 [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1st6 [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1ssS
                                                                f1_s1ssU
                                                                lim_s1st4
                                                                go_s1st6] \r [x_s1st7]
                                                          case
                                                              GHC.Integer.Type.gtInteger#
                                                                  x_s1st7 lim_s1st4
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1stb [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1ssS
                                                                       go_s1st6
                                                                       x_s1st7] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1st7
                                                                                  delta_s1ssS
                                                                          of
                                                                          sat_s1sta
                                                                          { __DEFAULT ->
                                                                                go_s1st6 sat_s1sta;
                                                                          }; } in
                                                                let {
                                                                  sat_s1st9 [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1ssU x_s1st7] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1ssU x_s1st7;
                                                                } in  : [sat_s1st9 sat_s1stb];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1st6 i_n1_s1ssQ;
                                          };
                                  };
                          };
                      1# ->
                          case
                              GHC.Integer.Type.minusInteger i_n2_s1ssP i_n1_s1ssQ
                          of
                          delta_s1stc [Dmd=<S,U>]
                          { __DEFAULT ->
                                let {
                                  f_s1std [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
                                    :: GHC.Real.Real a_a1enm
                                  [LclId] =
                                      [$dIntegral_s1ssL] \s []
                                          GHC.Real.$p1Integral $dIntegral_s1ssL; } in
                                let {
                                  f1_s1ste [Occ=OnceL*, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
                                    :: GHC.Num.Num a_a1enm
                                  [LclId] =
                                      [f_s1std] \u [] GHC.Real.$p1Real f_s1std;
                                } in 
                                  case GHC.Integer.Type.geInteger# delta_s1stc GHC.Real.even1 of {
                                    __DEFAULT ->
                                        let {
                                          sat_s1sth [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1ssM] \u []
                                                  GHC.Enum.maxBound $dBounded_s1ssM;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1ssL sat_s1sth
                                          of
                                          lim_s1stg [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1sti [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1stc
                                                                f1_s1ste
                                                                lim_s1stg
                                                                go_s1sti] \r [x_s1stj]
                                                          case
                                                              GHC.Integer.Type.ltInteger#
                                                                  x_s1stj lim_s1stg
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1stn [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1stc
                                                                       go_s1sti
                                                                       x_s1stj] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1stj
                                                                                  delta_s1stc
                                                                          of
                                                                          sat_s1stm
                                                                          { __DEFAULT ->
                                                                                go_s1sti sat_s1stm;
                                                                          }; } in
                                                                let {
                                                                  sat_s1stl [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1ste x_s1stj] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1ste x_s1stj;
                                                                } in  : [sat_s1stl sat_s1stn];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1sti i_n1_s1ssQ;
                                          };
                                    1# ->
                                        let {
                                          sat_s1stp [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1ssM] \u []
                                                  GHC.Enum.maxBound $dBounded_s1ssM;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1ssL sat_s1stp
                                          of
                                          lim_s1sto [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1stq [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1stc
                                                                f1_s1ste
                                                                lim_s1sto
                                                                go_s1stq] \r [x_s1str]
                                                          case
                                                              GHC.Integer.Type.gtInteger#
                                                                  x_s1str lim_s1sto
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1stv [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1stc
                                                                       go_s1stq
                                                                       x_s1str] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1str
                                                                                  delta_s1stc
                                                                          of
                                                                          sat_s1stu
                                                                          { __DEFAULT ->
                                                                                go_s1stq sat_s1stu;
                                                                          }; } in
                                                                let {
                                                                  sat_s1stt [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1ste x_s1str] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1ste x_s1str;
                                                                } in  : [sat_s1stt sat_s1stv];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1stq i_n1_s1ssQ;
                                          };
                                  };
                          };
                    };
              };
        };

GHC.Real.integralEnumFromTo
  :: forall a. GHC.Real.Integral a => a -> a -> [a]
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1stw eta_s1stx eta1_s1sty]
        let {
          f_s1stz [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
            :: GHC.Real.Real a_a1en9
          [LclId] =
              [$dIntegral_s1stw] \s []
                  GHC.Real.$p1Integral $dIntegral_s1stw; } in
        let {
          f1_s1stA [Occ=OnceL, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
            :: GHC.Num.Num a_a1en9
          [LclId] =
              [f_s1stz] \u [] GHC.Real.$p1Real f_s1stz;
        } in 
          case
              GHC.Real.toInteger $dIntegral_s1stw eta1_s1sty
          of
          lim_s1stB [Dmd=<S,U>]
          { __DEFAULT ->
                let {
                  go_s1stC [Occ=LoopBreaker] :: GHC.Integer.Type.Integer -> [a_a1en9]
                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                      sat-only [f1_s1stA lim_s1stB go_s1stC] \r [x_s1stD]
                          case GHC.Integer.Type.gtInteger# x_s1stD lim_s1stB of {
                            __DEFAULT ->
                                let {
                                  sat_s1stH [Occ=Once] :: [a_a1en9]
                                  [LclId] =
                                      [go_s1stC x_s1stD] \u []
                                          case
                                              GHC.Integer.Type.plusInteger
                                                  x_s1stD GHC.Real.$fEnumRatio1
                                          of
                                          sat_s1stG
                                          { __DEFAULT -> go_s1stC sat_s1stG;
                                          }; } in
                                let {
                                  sat_s1stF [Occ=Once] :: a_a1en9
                                  [LclId] =
                                      [f1_s1stA x_s1stD] \u [] GHC.Num.fromInteger f1_s1stA x_s1stD;
                                } in  : [sat_s1stF sat_s1stH];
                            1# -> [] [];
                          };
                } in 
                  case GHC.Real.toInteger $dIntegral_s1stw eta_s1stx of sat_s1stI {
                    __DEFAULT -> go_s1stC sat_s1stI;
                  };
          };

GHC.Real.integralEnumFromThenTo
  :: forall a. GHC.Real.Integral a => a -> a -> a -> [a]
[GblId,
 Arity=4,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1stJ eta_s1stK eta1_s1stL eta2_s1stM]
        case
            GHC.Real.toInteger $dIntegral_s1stJ eta_s1stK
        of
        x_s1stN [Dmd=<S,U>]
        { __DEFAULT ->
              case GHC.Real.toInteger $dIntegral_s1stJ eta1_s1stL of sat_s1stP {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.minusInteger sat_s1stP x_s1stN
                    of
                    delta_s1stO [Dmd=<S,U>]
                    { __DEFAULT ->
                          let {
                            f_s1stQ [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
                              :: GHC.Real.Real a_a1emS
                            [LclId] =
                                [$dIntegral_s1stJ] \s []
                                    GHC.Real.$p1Integral $dIntegral_s1stJ; } in
                          let {
                            f1_s1stR [Occ=OnceL*, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
                              :: GHC.Num.Num a_a1emS
                            [LclId] =
                                [f_s1stQ] \u [] GHC.Real.$p1Real f_s1stQ;
                          } in 
                            case GHC.Integer.Type.geInteger# delta_s1stO GHC.Real.even1 of {
                              __DEFAULT ->
                                  case
                                      GHC.Real.toInteger $dIntegral_s1stJ eta2_s1stM
                                  of
                                  lim_s1stT [Dmd=<S,U>]
                                  { __DEFAULT ->
                                        let {
                                          go_s1stU [Occ=LoopBreaker]
                                            :: GHC.Integer.Type.Integer -> [a_a1emS]
                                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                              sat-only [delta_s1stO
                                                        f1_s1stR
                                                        lim_s1stT
                                                        go_s1stU] \r [x1_s1stV]
                                                  case
                                                      GHC.Integer.Type.ltInteger# x1_s1stV lim_s1stT
                                                  of
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_s1stZ [Occ=Once] :: [a_a1emS]
                                                          [LclId] =
                                                              [delta_s1stO go_s1stU x1_s1stV] \u []
                                                                  case
                                                                      GHC.Integer.Type.plusInteger
                                                                          x1_s1stV delta_s1stO
                                                                  of
                                                                  sat_s1stY
                                                                  { __DEFAULT -> go_s1stU sat_s1stY;
                                                                  }; } in
                                                        let {
                                                          sat_s1stX [Occ=Once] :: a_a1emS
                                                          [LclId] =
                                                              [f1_s1stR x1_s1stV] \u []
                                                                  GHC.Num.fromInteger
                                                                      f1_s1stR x1_s1stV;
                                                        } in  : [sat_s1stX sat_s1stZ];
                                                    1# -> [] [];
                                                  };
                                        } in  go_s1stU x_s1stN;
                                  };
                              1# ->
                                  case
                                      GHC.Real.toInteger $dIntegral_s1stJ eta2_s1stM
                                  of
                                  lim_s1su0 [Dmd=<S,U>]
                                  { __DEFAULT ->
                                        let {
                                          go_s1su1 [Occ=LoopBreaker]
                                            :: GHC.Integer.Type.Integer -> [a_a1emS]
                                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                              sat-only [delta_s1stO
                                                        f1_s1stR
                                                        lim_s1su0
                                                        go_s1su1] \r [x1_s1su2]
                                                  case
                                                      GHC.Integer.Type.gtInteger# x1_s1su2 lim_s1su0
                                                  of
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_s1su6 [Occ=Once] :: [a_a1emS]
                                                          [LclId] =
                                                              [delta_s1stO go_s1su1 x1_s1su2] \u []
                                                                  case
                                                                      GHC.Integer.Type.plusInteger
                                                                          x1_s1su2 delta_s1stO
                                                                  of
                                                                  sat_s1su5
                                                                  { __DEFAULT -> go_s1su1 sat_s1su5;
                                                                  }; } in
                                                        let {
                                                          sat_s1su4 [Occ=Once] :: a_a1emS
                                                          [LclId] =
                                                              [f1_s1stR x1_s1su2] \u []
                                                                  GHC.Num.fromInteger
                                                                      f1_s1stR x1_s1su2;
                                                        } in  : [sat_s1su4 sat_s1su6];
                                                    1# -> [] [];
                                                  };
                                        } in  go_s1su1 x_s1stN;
                                  };
                            };
                    };
              };
        };

GHC.Real.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Real.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$trModule4];

GHC.Real.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Real"#;

GHC.Real.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$trModule2];

GHC.Real.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Real.$trModule3
                                     GHC.Real.$trModule1];

$krep_r1j3d :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Integer.Type.$tcInteger
                                              GHC.Types.[]];

$krep1_r1j3e :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.Real.$tcFractional1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*
                                         $krep1_r1j3e];

$krep2_r1j3f :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep3_r1j3g :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep2_r1j3f];

$krep4_r1j3h :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep3_r1j3g];

$krep5_r1j3i :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep_r1j3d];

$krep6_r1j3j :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_r1j3f GHC.Types.[]];

$krep7_r1j3k :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_r1j3f $krep6_r1j3j];

$krep8_r1j3l :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc(,)
                                              $krep7_r1j3k];

$krep9_r1j3m :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep8_r1j3l];

$krep10_r1j3n :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep9_r1j3m];

$krep11_r1j3o :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Num.$tcNum
                                              $krep6_r1j3j];

$krep12_r1j3p :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Enum.$tcEnum
                                              $krep6_r1j3j];

$krep13_r1j3q :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Classes.$tcOrd
                                              $krep6_r1j3j];

GHC.Real.$tcRatio2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Ratio"#;

GHC.Real.$tcRatio1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcRatio2];

GHC.Real.$tcRatio :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17658523810845794968##
                                    1271393732863050253##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcRatio1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep14_r1j3r :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcRatio
                                              $krep6_r1j3j];

$krep15_r1j3s :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep14_r1j3r];

GHC.Real.$tc':%1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep15_r1j3s];

GHC.Real.$tc':%3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "':%"#;

GHC.Real.$tc':%2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc':%3];

GHC.Real.$tc':% :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11952989868638128372##
                                    6861245286732044789##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc':%2
                                    1#
                                    GHC.Real.$tc':%1];

$krep16_r1j3t :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r1j3d GHC.Types.[]];

$krep17_r1j3u :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcRatio
                                              $krep16_r1j3t];

$krep18_r1j3v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep17_r1j3u];

$krep19_r1j3w :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep17_r1j3u $krep2_r1j3f];

GHC.Real.$tcReal2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Real"#;

GHC.Real.$tcReal1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcReal2];

GHC.Real.$tcReal :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1826502536394630182##
                                    14487785779892251413##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcReal1
                                    0#
                                    GHC.Real.$tcFractional1];

$krep20_r1j3x :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcReal
                                              $krep6_r1j3j];

$krep21_r1j3y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep18_r1j3v $krep20_r1j3x];

$krep22_r1j3z :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep13_r1j3q $krep21_r1j3y];

GHC.Real.$tc'C:Real1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1j3o $krep22_r1j3z];

GHC.Real.$tc'C:Real3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Real"#;

GHC.Real.$tc'C:Real2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc'C:Real3];

GHC.Real.$tc'C:Real :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5938283050841830427##
                                    8926187074226767634##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc'C:Real2
                                    1#
                                    GHC.Real.$tc'C:Real1];

GHC.Real.$tcIntegral2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Integral"#;

GHC.Real.$tcIntegral1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcIntegral2];

GHC.Real.$tcIntegral :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16601157811546713973##
                                    3304955164956033666##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcIntegral1
                                    0#
                                    GHC.Real.$tcFractional1];

$krep23_r1j3A :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcIntegral
                                              $krep6_r1j3j];

$krep24_r1j3B :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r1j3i $krep23_r1j3A];

$krep25_r1j3C :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_r1j3n $krep24_r1j3B];

$krep26_r1j3D :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_r1j3n $krep25_r1j3C];

$krep27_r1j3E :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep26_r1j3D];

$krep28_r1j3F :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep27_r1j3E];

$krep29_r1j3G :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep28_r1j3F];

$krep30_r1j3H :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep29_r1j3G];

$krep31_r1j3I :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep12_r1j3p $krep30_r1j3H];

GHC.Real.$tc'C:Integral1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep20_r1j3x $krep31_r1j3I];

GHC.Real.$tc'C:Integral3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Integral"#;

GHC.Real.$tc'C:Integral2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc'C:Integral3];

GHC.Real.$tc'C:Integral :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12141017740256829283##
                                    17564033539811245778##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc'C:Integral2
                                    1#
                                    GHC.Real.$tc'C:Integral1];

GHC.Real.$tcFractional3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Fractional"#;

GHC.Real.$tcFractional2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcFractional3];

GHC.Real.$tcFractional :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14968870971062750857##
                                    13774835939651899219##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcFractional2
                                    0#
                                    GHC.Real.$tcFractional1];

$krep32_r1j3J :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcFractional
                                              $krep6_r1j3j];

$krep33_r1j3K :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep19_r1j3w $krep32_r1j3J];

$krep34_r1j3L :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r1j3g $krep33_r1j3K];

$krep35_r1j3M :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep34_r1j3L];

GHC.Real.$tc'C:Fractional1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1j3o $krep35_r1j3M];

GHC.Real.$tc'C:Fractional3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Fractional"#;

GHC.Real.$tc'C:Fractional2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc'C:Fractional3];

GHC.Real.$tc'C:Fractional :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15706435530565718930##
                                    11021884564355505453##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc'C:Fractional2
                                    1#
                                    GHC.Real.$tc'C:Fractional1];

GHC.Real.$tcRealFrac2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "RealFrac"#;

GHC.Real.$tcRealFrac1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcRealFrac2];

GHC.Real.$tcRealFrac :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2318913099678420819##
                                    6373121509494083706##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcRealFrac1
                                    0#
                                    GHC.Real.$tcFractional1];

GHC.Real.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     a -> a -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1su7 ww_s1su8 ww1_s1su9 ww2_s1sua ww3_s1sub]
        case
            GHC.Real.$p1Integral w_s1su7
        of
        $dReal_s1suc [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1sud [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
                  :: GHC.Num.Num a_s1hBR
                [LclId] =
                    [$dReal_s1suc] \u [] GHC.Real.$p1Real $dReal_s1suc; } in
              let {
                sat_s1sug [Occ=Once] :: a_s1hBR
                [LclId] =
                    [ww1_s1su9 ww2_s1sua $dNum_s1sud] \u []
                        GHC.Num.* $dNum_s1sud ww2_s1sua ww1_s1su9; } in
              let {
                sat_s1suf [Occ=Once] :: a_s1hBR
                [LclId] =
                    [ww_s1su8 ww3_s1sub $dNum_s1sud] \u []
                        GHC.Num.* $dNum_s1sud ww_s1su8 ww3_s1sub;
              } in 
                case GHC.Real.$p2Real $dReal_s1suc of sat_s1sue {
                  __DEFAULT -> GHC.Classes.< sat_s1sue sat_s1suf sat_s1sug;
                };
        };

GHC.Real.$fOrdRatio_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1suh w1_s1sui w2_s1suj]
        case w1_s1sui of {
          GHC.Real.:% ww1_s1sul [Occ=Once] ww2_s1sum [Occ=Once] ->
              case w2_s1suj of {
                GHC.Real.:% ww4_s1suo [Occ=Once] ww5_s1sup [Occ=Once] ->
                    GHC.Real.$w$c< w_s1suh ww1_s1sul ww2_s1sum ww4_s1suo ww5_s1sup;
              };
        };

GHC.Real.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     a -> a -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1suq ww_s1sur ww1_s1sus ww2_s1sut ww3_s1suu]
        case
            GHC.Real.$p1Integral w_s1suq
        of
        $dReal_s1suv [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1suw [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
                  :: GHC.Num.Num a_s1hC6
                [LclId] =
                    [$dReal_s1suv] \u [] GHC.Real.$p1Real $dReal_s1suv; } in
              let {
                sat_s1suz [Occ=Once] :: a_s1hC6
                [LclId] =
                    [ww1_s1sus ww2_s1sut $dNum_s1suw] \u []
                        GHC.Num.* $dNum_s1suw ww2_s1sut ww1_s1sus; } in
              let {
                sat_s1suy [Occ=Once] :: a_s1hC6
                [LclId] =
                    [ww_s1sur ww3_s1suu $dNum_s1suw] \u []
                        GHC.Num.* $dNum_s1suw ww_s1sur ww3_s1suu;
              } in 
                case GHC.Real.$p2Real $dReal_s1suv of sat_s1sux {
                  __DEFAULT -> GHC.Classes.<= sat_s1sux sat_s1suy sat_s1suz;
                };
        };

GHC.Real.$fOrdRatio_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1suA w1_s1suB w2_s1suC]
        case w1_s1suB of {
          GHC.Real.:% ww1_s1suE [Occ=Once] ww2_s1suF [Occ=Once] ->
              case w2_s1suC of {
                GHC.Real.:% ww4_s1suH [Occ=Once] ww5_s1suI [Occ=Once] ->
                    GHC.Real.$w$c<= w_s1suA ww1_s1suE ww2_s1suF ww4_s1suH ww5_s1suI;
              };
        };

GHC.Real.$fOrdRatio_$cmax
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1suJ x_s1suK y_s1suL]
        case x_s1suK of ww_s1suM {
          GHC.Real.:% ww1_s1suN [Occ=Once] ww2_s1suO [Occ=Once] ->
              case y_s1suL of ww3_s1suP {
                GHC.Real.:% ww4_s1suQ [Occ=Once] ww5_s1suR [Occ=Once] ->
                    case
                        GHC.Real.$w$c<=
                            $dIntegral_s1suJ ww1_s1suN ww2_s1suO ww4_s1suQ ww5_s1suR
                    of
                    { GHC.Types.False -> ww_s1suM;
                      GHC.Types.True -> ww3_s1suP;
                    };
              };
        };

GHC.Real.$fOrdRatio_$cmin
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1suT x_s1suU y_s1suV]
        case x_s1suU of ww_s1suW {
          GHC.Real.:% ww1_s1suX [Occ=Once] ww2_s1suY [Occ=Once] ->
              case y_s1suV of ww3_s1suZ {
                GHC.Real.:% ww4_s1sv0 [Occ=Once] ww5_s1sv1 [Occ=Once] ->
                    case
                        GHC.Real.$w$c<=
                            $dIntegral_s1suT ww1_s1suX ww2_s1suY ww4_s1sv0 ww5_s1sv1
                    of
                    { GHC.Types.False -> ww3_s1suZ;
                      GHC.Types.True -> ww_s1suW;
                    };
              };
        };

GHC.Real.$w$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     a -> a -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(1*U(A,A,C(C1(U)),A,A,A,A),U(1*U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sv3 ww_s1sv4 ww1_s1sv5 ww2_s1sv6 ww3_s1sv7]
        case
            GHC.Real.$p1Integral w_s1sv3
        of
        $dEq_s1sv8 [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p2Real $dEq_s1sv8
              of
              $dEq1_s1sv9 [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Classes.$p1Ord $dEq1_s1sv9
                    of
                    $dEq2_s1sva [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                    { __DEFAULT ->
                          case GHC.Classes.== $dEq2_s1sva ww_s1sv4 ww2_s1sv6 of {
                            GHC.Types.False ->
                                case
                                    GHC.Real.$w$c<= w_s1sv3 ww_s1sv4 ww1_s1sv5 ww2_s1sv6 ww3_s1sv7
                                of
                                { GHC.Types.False -> GHC.Types.GT [];
                                  GHC.Types.True -> GHC.Types.LT [];
                                };
                            GHC.Types.True ->
                                case GHC.Classes.== $dEq2_s1sva ww1_s1sv5 ww3_s1sv7 of {
                                  GHC.Types.False ->
                                      case
                                          GHC.Real.$w$c<=
                                              w_s1sv3 ww_s1sv4 ww1_s1sv5 ww2_s1sv6 ww3_s1sv7
                                      of
                                      { GHC.Types.False -> GHC.Types.GT [];
                                        GHC.Types.True -> GHC.Types.LT [];
                                      };
                                  GHC.Types.True -> GHC.Types.EQ [];
                                };
                          };
                    };
              };
        };

GHC.Real.$fOrdRatio_$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1svf w1_s1svg w2_s1svh]
        case w1_s1svg of {
          GHC.Real.:% ww1_s1svj [Occ=Once] ww2_s1svk [Occ=Once] ->
              case w2_s1svh of {
                GHC.Real.:% ww4_s1svm [Occ=Once] ww5_s1svn [Occ=Once] ->
                    GHC.Real.$w$ccompare
                        w_s1svf ww1_s1svj ww2_s1svk ww4_s1svm ww5_s1svn;
              };
        };

GHC.Real.$fOrdRatio_$c>
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1svo x_s1svp y_s1svq]
        case x_s1svp of {
          GHC.Real.:% ww1_s1svs [Occ=Once] ww2_s1svt [Occ=Once] ->
              case y_s1svq of {
                GHC.Real.:% ww4_s1svv [Occ=Once] ww5_s1svw [Occ=Once] ->
                    case
                        GHC.Real.$w$ccompare
                            $dIntegral_s1svo ww1_s1svs ww2_s1svt ww4_s1svv ww5_s1svw
                    of
                    { __DEFAULT -> GHC.Types.False [];
                      GHC.Types.GT -> GHC.Types.True [];
                    };
              };
        };

GHC.Real.$fOrdRatio_$c>=
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1svy x_s1svz y_s1svA]
        case x_s1svz of {
          GHC.Real.:% ww1_s1svC [Occ=Once] ww2_s1svD [Occ=Once] ->
              case y_s1svA of {
                GHC.Real.:% ww4_s1svF [Occ=Once] ww5_s1svG [Occ=Once] ->
                    case
                        GHC.Real.$w$ccompare
                            $dIntegral_s1svy ww1_s1svC ww2_s1svD ww4_s1svF ww5_s1svG
                    of
                    { __DEFAULT -> GHC.Types.True [];
                      GHC.Types.LT -> GHC.Types.False [];
                    };
              };
        };

GHC.Real.$fOrdRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Classes.Ord (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>m] =
    [] \r [$dIntegral_s1svI]
        let {
          sat_s1svQ [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Real.Ratio a_a1eJ2
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$cmin $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svP [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Real.Ratio a_a1eJ2
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$cmax $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svO [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c>= $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svN [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c> $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svM [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c<= $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svL [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c< $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svK [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Ordering
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$ccompare $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svJ [Occ=Once] :: GHC.Classes.Eq (GHC.Real.Ratio a_a1eJ2)
          [LclId] =
              [$dIntegral_s1svI] \u []
                  GHC.Real.$fOrdRatio_$cp1Ord $dIntegral_s1svI;
        } in 
          GHC.Classes.C:Ord [sat_s1svJ
                             sat_s1svK
                             sat_s1svL
                             sat_s1svM
                             sat_s1svN
                             sat_s1svO
                             sat_s1svP
                             sat_s1svQ];

GHC.Real.$fNumRatio_$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LLLC(S)LLL)LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,1*C1(U),A,A,A),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1svR w1_s1svS]
        case w1_s1svS of {
          GHC.Real.:% ww1_s1svU [Occ=Once] ww2_s1svV [Occ=Once] ->
              case GHC.Real.$p1Integral w_s1svR of sat_s1svW {
                __DEFAULT ->
                    case GHC.Real.$p1Real sat_s1svW of sat_s1svX {
                      __DEFAULT ->
                          case GHC.Num.negate sat_s1svX ww1_s1svU of dt_s1svY {
                            __DEFAULT -> GHC.Real.:% [dt_s1svY ww2_s1svV];
                          };
                    };
              };
        };

GHC.Real.$fNumRatio_$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LLLLC(S)LL)LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,1*C1(U),A,A),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1svZ w1_s1sw0]
        case w1_s1sw0 of {
          GHC.Real.:% ww1_s1sw2 [Occ=Once] ww2_s1sw3 [Occ=Once] ->
              case GHC.Real.$p1Integral w_s1svZ of sat_s1sw4 {
                __DEFAULT ->
                    case GHC.Real.$p1Real sat_s1sw4 of sat_s1sw5 {
                      __DEFAULT ->
                          case GHC.Num.abs sat_s1sw5 ww1_s1sw2 of dt_s1sw6 {
                            __DEFAULT -> GHC.Real.:% [dt_s1sw6 ww2_s1sw3];
                          };
                    };
              };
        };

GHC.Real.$w$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLC(S)C(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sw7 ww_s1sw8]
        case
            GHC.Real.$p1Integral w_s1sw7
        of
        $dReal_s1sw9 [Dmd=<S(S(LLLLLC(S)C(S))LL),1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1sw9
              of
              $dNum_s1swa [Dmd=<S(LLLLLC(S)C(S)),U(A,A,A,A,A,1*C1(U),1*C1(U))>]
              { __DEFAULT ->
                    case GHC.Num.signum $dNum_s1swa ww_s1sw8 of dt_s1swb {
                      __DEFAULT ->
                          case
                              GHC.Num.fromInteger $dNum_s1swa GHC.Real.$fEnumRatio1
                          of
                          dt1_s1swc
                          { __DEFAULT -> (#,#) [dt_s1swb dt1_s1swc];
                          };
                    };
              };
        };

GHC.Real.$fNumRatio_$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLC(S)C(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SL),1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [w_s1swd w1_s1swe]
        case w1_s1swe of {
          GHC.Real.:% ww1_s1swg [Occ=Once] _ [Occ=Dead] ->
              case GHC.Real.$w$csignum w_s1swd ww1_s1swg of {
                (#,#) ww4_s1swj [Occ=Once] ww5_s1swk [Occ=Once] ->
                    GHC.Real.:% [ww4_s1swj ww5_s1swk];
              };
        };

GHC.Real.$w$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1swl w1_s1swm]
        case
            GHC.Real.$p1Integral w_s1swl
        of
        $dReal_s1swn [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1swn
              of
              $dNum_s1swo [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
              { __DEFAULT ->
                    case GHC.Num.fromInteger $dNum_s1swo w1_s1swm of dt_s1swp {
                      __DEFAULT ->
                          case
                              GHC.Num.fromInteger $dNum_s1swo GHC.Real.$fEnumRatio1
                          of
                          dt1_s1swq
                          { __DEFAULT -> (#,#) [dt_s1swp dt1_s1swq];
                          };
                    };
              };
        };

GHC.Real.$fNumRatio_$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1swr w1_s1sws]
        case GHC.Real.$w$cfromInteger w_s1swr w1_s1sws of {
          (#,#) ww1_s1swu [Occ=Once] ww2_s1swv [Occ=Once] ->
              GHC.Real.:% [ww1_s1swu ww2_s1swv];
        };

GHC.Real.$fRealRatio_$s$ctoRational
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Real.Rational
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1sww] ds_s1sww;

GHC.Real.$fRealRatio_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Rational
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)),U(A,A,A,A,A,A,A,A,C(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1swx w1_s1swy]
        case w1_s1swy of {
          GHC.Real.:% ww1_s1swA [Occ=Once] ww2_s1swB [Occ=Once] ->
              case GHC.Real.toInteger w_s1swx ww1_s1swA of dt_s1swC {
                __DEFAULT ->
                    case GHC.Real.toInteger w_s1swx ww2_s1swB of dt1_s1swD {
                      __DEFAULT -> GHC.Real.:% [dt_s1swC dt1_s1swD];
                    };
              };
        };

GHC.Real.$w$crecip [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1swE ww_s1swF ww1_s1swG]
        case
            GHC.Real.$p1Integral w_s1swE
        of
        $dReal_s1swH [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1swI [Dmd=<L,U(A,A,A,C(U),A,A,C(U))>] :: GHC.Num.Num a_s1hDt
                [LclId] =
                    [$dReal_s1swH] \u [] GHC.Real.$p1Real $dReal_s1swH;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1swH
                of
                $dOrd_s1swJ [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1swL [Occ=Once] :: a_s1hDt
                        [LclId] =
                            [$dNum_s1swI] \u [] GHC.Num.fromInteger $dNum_s1swI GHC.Real.even1;
                      } in 
                        case GHC.Classes.$p1Ord $dOrd_s1swJ of sat_s1swK {
                          __DEFAULT ->
                              case GHC.Classes.== sat_s1swK ww_s1swF sat_s1swL of {
                                GHC.Types.False ->
                                    let {
                                      sat_s1swN [Occ=Once] :: a_s1hDt
                                      [LclId] =
                                          [$dNum_s1swI] \u []
                                              GHC.Num.fromInteger $dNum_s1swI GHC.Real.even1;
                                    } in 
                                      case GHC.Classes.< $dOrd_s1swJ ww_s1swF sat_s1swN of {
                                        GHC.Types.False -> (#,#) [ww1_s1swG ww_s1swF];
                                        GHC.Types.True ->
                                            case GHC.Num.negate $dNum_s1swI ww1_s1swG of dt_s1swP {
                                              __DEFAULT ->
                                                  case
                                                      GHC.Num.negate $dNum_s1swI ww_s1swF
                                                  of
                                                  dt1_s1swQ
                                                  { __DEFAULT -> (#,#) [dt_s1swP dt1_s1swQ];
                                                  };
                                            };
                                      };
                                GHC.Types.True -> GHC.Real.ratioZeroDenominatorError;
                              };
                        };
                };
        };

GHC.Real.$fFractionalRatio_$crecip [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1swS w1_s1swT]
        case w1_s1swT of {
          GHC.Real.:% ww1_s1swV [Occ=Once] ww2_s1swW [Occ=Once] ->
              case GHC.Real.$w$crecip w_s1swS ww1_s1swV ww2_s1swW of {
                (#,#) ww4_s1swY [Occ=Once] ww5_s1swZ [Occ=Once] ->
                    GHC.Real.:% [ww4_s1swY ww5_s1swZ];
              };
        };

GHC.Real.$w$s$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# b, GHC.Real.Ratio GHC.Integer.Type.Integer #)
[GblId,
 Arity=3,
 Str=<L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sx0 ww_s1sx1 ww1_s1sx2]
        let {
          ds_s1sx3 [Dmd=<L,U(1*U,1*U)>]
            :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
          [LclId] =
              [ww_s1sx1 ww1_s1sx2] \u []
                  case GHC.Integer.Type.eqInteger# ww1_s1sx2 GHC.Real.even1 of {
                    __DEFAULT ->
                        case GHC.Integer.Type.quotRemInteger ww_s1sx1 ww1_s1sx2 of {
                          (#,#) ipv_s1sx6 [Occ=Once] ipv1_s1sx7 [Occ=Once] ->
                              (,) [ipv_s1sx6 ipv1_s1sx7];
                        };
                    1# -> GHC.Real.divZeroError;
                  }; } in
        let {
          sat_s1sxj [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId] =
              [ww1_s1sx2 ds_s1sx3] \u []
                  case ds_s1sx3 of {
                    (,) _ [Occ=Dead] r_s1sxh [Occ=Once] ->
                        case r_s1sxh of dt_s1sxi {
                          __DEFAULT -> GHC.Real.:% [dt_s1sxi ww1_s1sx2];
                        };
                  }; } in
        let {
          sat_s1sxe [Occ=Once] :: b_s1hDF
          [LclId] =
              [w_s1sx0 ds_s1sx3] \u []
                  let {
                    sat_s1sxd [Occ=Once] :: GHC.Integer.Type.Integer
                    [LclId] =
                        [ds_s1sx3] \u []
                            case ds_s1sx3 of {
                              (,) q_s1sxb [Occ=Once] _ [Occ=Dead] -> q_s1sxb;
                            };
                  } in 
                    case GHC.Real.$p1Integral w_s1sx0 of sat_s1sx8 {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_s1sx8 of sat_s1sx9 {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1sx9 sat_s1sxd;
                          };
                    };
        } in  (#,#) [sat_s1sxe sat_s1sxj];

GHC.Real.$fEnumRatio_$s$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer
     -> (b, GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1sxk w1_s1sxl]
        case w1_s1sxl of {
          GHC.Real.:% ww1_s1sxn [Occ=Once] ww2_s1sxo [Occ=Once] ->
              case GHC.Real.$w$s$cproperFraction w_s1sxk ww1_s1sxn ww2_s1sxo of {
                (#,#) ww4_s1sxq [Occ=Once] ww5_s1sxr [Occ=Once] ->
                    (,) [ww4_s1sxq ww5_s1sxr];
              };
        };

GHC.Real.$w$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b.
     GHC.Real.Integral b =>
     a -> a -> (# b, GHC.Real.Ratio a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,1*C1(C1(U(1*U,1*U))),A,1*C1(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sxs w1_s1sxt ww_s1sxu ww1_s1sxv]
        let {
          ds_s1sxw [Dmd=<L,U(1*U,1*U)>] :: (a_s1hDR, a_s1hDR)
          [LclId] =
              [w_s1sxs ww_s1sxu ww1_s1sxv] \u []
                  GHC.Real.quotRem w_s1sxs ww_s1sxu ww1_s1sxv; } in
        let {
          sat_s1sxJ [Occ=Once] :: GHC.Real.Ratio a_s1hDR
          [LclId] =
              [ww1_s1sxv ds_s1sxw] \u []
                  case ds_s1sxw of {
                    (,) _ [Occ=Dead] r_s1sxH [Occ=Once] ->
                        case r_s1sxH of dt_s1sxI {
                          __DEFAULT -> GHC.Real.:% [dt_s1sxI ww1_s1sxv];
                        };
                  }; } in
        let {
          sat_s1sxE [Occ=Once] :: b_s1hDT
          [LclId] =
              [w_s1sxs w1_s1sxt ds_s1sxw] \u []
                  let {
                    sat_s1sxD [Occ=Once] :: GHC.Integer.Type.Integer
                    [LclId] =
                        [w_s1sxs ds_s1sxw] \u []
                            let {
                              sat_s1sxC [Occ=Once] :: a_s1hDR
                              [LclId] =
                                  [ds_s1sxw] \u []
                                      case ds_s1sxw of {
                                        (,) q_s1sxA [Occ=Once] _ [Occ=Dead] -> q_s1sxA;
                                      };
                            } in  GHC.Real.toInteger w_s1sxs sat_s1sxC;
                  } in 
                    case GHC.Real.$p1Integral w1_s1sxt of sat_s1sxx {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_s1sxx of sat_s1sxy {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1sxy sat_s1sxD;
                          };
                    };
        } in  (#,#) [sat_s1sxE sat_s1sxJ];

GHC.Real.$fEnumRatio_$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio a -> (b, GHC.Real.Ratio a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1sxK w1_s1sxL w2_s1sxM]
        case w2_s1sxM of {
          GHC.Real.:% ww1_s1sxO [Occ=Once] ww2_s1sxP [Occ=Once] ->
              case
                  GHC.Real.$w$cproperFraction w_s1sxK w1_s1sxL ww1_s1sxO ww2_s1sxP
              of
              { (#,#) ww4_s1sxR [Occ=Once] ww5_s1sxS [Occ=Once] ->
                    (,) [ww4_s1sxR ww5_s1sxS];
              };
        };

GHC.Real.$wreduce [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,A,A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sxT w1_s1sxU w2_s1sxV]
        case
            GHC.Real.$p1Integral w_s1sxT
        of
        $dReal_s1sxW [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s1sy0 [Occ=Once] :: a_s1hE5
                [LclId] =
                    [$dReal_s1sxW] \u []
                        case GHC.Real.$p1Real $dReal_s1sxW of sat_s1sxZ {
                          __DEFAULT -> GHC.Num.fromInteger sat_s1sxZ GHC.Real.even1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s1sxW of sat_s1sxX {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_s1sxX of sat_s1sxY {
                        __DEFAULT ->
                            case GHC.Classes.== sat_s1sxY w2_s1sxV sat_s1sy0 of {
                              GHC.Types.False ->
                                  let {
                                    d_s1sy2 :: a_s1hE5
                                    [LclId] =
                                        [w_s1sxT w1_s1sxU w2_s1sxV] \u []
                                            GHC.Real.gcd w_s1sxT w1_s1sxU w2_s1sxV;
                                  } in 
                                    case GHC.Real.quot w_s1sxT w1_s1sxU d_s1sy2 of dt_s1sy3 {
                                      __DEFAULT ->
                                          case GHC.Real.quot w_s1sxT w2_s1sxV d_s1sy2 of dt1_s1sy4 {
                                            __DEFAULT -> (#,#) [dt_s1sy3 dt1_s1sy4];
                                          };
                                    };
                              GHC.Types.True -> GHC.Real.ratioZeroDenominatorError;
                            };
                      };
                };
        };

GHC.Real.reduce [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,A,A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1sy6 w1_s1sy7 w2_s1sy8]
        case GHC.Real.$wreduce w_s1sy6 w1_s1sy7 w2_s1sy8 of {
          (#,#) ww1_s1sya [Occ=Once] ww2_s1syb [Occ=Once] ->
              GHC.Real.:% [ww1_s1sya ww2_s1syb];
        };

GHC.Real.%_$s% [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>m, Unf=OtherCon []] =
    [] \r [w_s1syc w1_s1syd]
        case GHC.Real.$w$s$cfromRational w_s1syc w1_s1syd of {
          (#,#) ww1_s1syf [Occ=Once] ww2_s1syg [Occ=Once] ->
              GHC.Real.:% [ww1_s1syf ww2_s1syg];
        };

GHC.Real.$w% [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,1*C1(C1(U)),A,C(U),1*C1(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1syh w1_s1syi w2_s1syj]
        let {
          $dReal_s1syk [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,A,1*C1(C1(U)),A,1*C1(U),1*C1(U),A),A,A)>]
            :: GHC.Real.Real a_s1hEj
          [LclId] =
              [w_s1syh] \s [] GHC.Real.$p1Integral w_s1syh; } in
        let {
          $dNum_s1syl [Dmd=<L,U(A,A,1*C1(C1(U)),A,1*C1(U),1*C1(U),A)>]
            :: GHC.Num.Num a_s1hEj
          [LclId] =
              [$dReal_s1syk] \u [] GHC.Real.$p1Real $dReal_s1syk; } in
        let {
          sat_s1syo [Occ=Once] :: a_s1hEj
          [LclId] =
              [w2_s1syj $dNum_s1syl] \u [] GHC.Num.abs $dNum_s1syl w2_s1syj; } in
        let {
          sat_s1syn [Occ=Once] :: a_s1hEj
          [LclId] =
              [w1_s1syi w2_s1syj $dNum_s1syl] \u []
                  let {
                    sat_s1sym [Occ=Once] :: a_s1hEj
                    [LclId] =
                        [w2_s1syj $dNum_s1syl] \u [] GHC.Num.signum $dNum_s1syl w2_s1syj;
                  } in  GHC.Num.* $dNum_s1syl w1_s1syi sat_s1sym;
        } in  GHC.Real.$wreduce w_s1syh sat_s1syn sat_s1syo;

GHC.Real.% [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1syp w1_s1syq w2_s1syr]
        case GHC.Real.$w% w_s1syp w1_s1syq w2_s1syr of {
          (#,#) ww1_s1syt [Occ=Once] ww2_s1syu [Occ=Once] ->
              GHC.Real.:% [ww1_s1syt ww2_s1syu];
        };

GHC.Real.$w$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1syv ww_s1syw ww1_s1syx ww2_s1syy ww3_s1syz]
        let {
          $dReal_s1syA [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hEr
          [LclId] =
              [w_s1syv] \s [] GHC.Real.$p1Integral w_s1syv; } in
        let {
          $dNum_s1syB [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hEr
          [LclId] =
              [$dReal_s1syA] \u [] GHC.Real.$p1Real $dReal_s1syA; } in
        let {
          sat_s1syD [Occ=Once] :: a_s1hEr
          [LclId] =
              [ww1_s1syx ww2_s1syy $dNum_s1syB] \u []
                  GHC.Num.* $dNum_s1syB ww1_s1syx ww2_s1syy; } in
        let {
          sat_s1syC [Occ=Once] :: a_s1hEr
          [LclId] =
              [ww_s1syw ww3_s1syz $dNum_s1syB] \u []
                  GHC.Num.* $dNum_s1syB ww_s1syw ww3_s1syz;
        } in  GHC.Real.$w% w_s1syv sat_s1syC sat_s1syD;

GHC.Real.$fFractionalRatio_$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1syE w1_s1syF w2_s1syG]
        case w1_s1syF of {
          GHC.Real.:% ww1_s1syI [Occ=Once] ww2_s1syJ [Occ=Once] ->
              case w2_s1syG of {
                GHC.Real.:% ww4_s1syL [Occ=Once] ww5_s1syM [Occ=Once] ->
                    case
                        GHC.Real.$w$c/ w_s1syE ww1_s1syI ww2_s1syJ ww4_s1syL ww5_s1syM
                    of
                    { (#,#) ww7_s1syO [Occ=Once] ww8_s1syP [Occ=Once] ->
                          GHC.Real.:% [ww7_s1syO ww8_s1syP];
                    };
              };
        };

GHC.Real.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1syQ ww_s1syR ww1_s1syS]
        let {
          $dReal_s1syT [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
            :: GHC.Real.Real a_s1hEJ
          [LclId] =
              [w_s1syQ] \s [] GHC.Real.$p1Integral w_s1syQ; } in
        let {
          $dNum_s1syU [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_s1hEJ
          [LclId] =
              [$dReal_s1syT] \u [] GHC.Real.$p1Real $dReal_s1syT; } in
        let {
          sat_s1syW [Occ=Once] :: a_s1hEJ
          [LclId] =
              [ww1_s1syS $dNum_s1syU] \u []
                  GHC.Num.fromInteger $dNum_s1syU ww1_s1syS; } in
        let {
          sat_s1syV [Occ=Once] :: a_s1hEJ
          [LclId] =
              [ww_s1syR $dNum_s1syU] \u []
                  GHC.Num.fromInteger $dNum_s1syU ww_s1syR;
        } in  GHC.Real.$w% w_s1syQ sat_s1syV sat_s1syW;

GHC.Real.$fFractionalRatio_$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Rational -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1syX w1_s1syY]
        case w1_s1syY of {
          GHC.Real.:% ww1_s1sz0 [Occ=Once] ww2_s1sz1 [Occ=Once] ->
              case GHC.Real.$w$cfromRational w_s1syX ww1_s1sz0 ww2_s1sz1 of {
                (#,#) ww4_s1sz3 [Occ=Once] ww5_s1sz4 [Occ=Once] ->
                    GHC.Real.:% [ww4_s1sz3 ww5_s1sz4];
              };
        };

GHC.Real.$w$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(1*C1(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sz5 ww_s1sz6 ww1_s1sz7 ww2_s1sz8 ww3_s1sz9]
        let {
          $dReal_s1sza [Occ=OnceL,
                        Dmd=<L,1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hEV
          [LclId] =
              [w_s1sz5] \s [] GHC.Real.$p1Integral w_s1sz5; } in
        let {
          $dNum_s1szb [Dmd=<L,U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hEV
          [LclId] =
              [$dReal_s1sza] \u [] GHC.Real.$p1Real $dReal_s1sza; } in
        let {
          sat_s1szf [Occ=Once] :: a_s1hEV
          [LclId] =
              [ww1_s1sz7 ww3_s1sz9 $dNum_s1szb] \u []
                  GHC.Num.* $dNum_s1szb ww1_s1sz7 ww3_s1sz9; } in
        let {
          sat_s1sze [Occ=Once] :: a_s1hEV
          [LclId] =
              [ww_s1sz6 ww1_s1sz7 ww2_s1sz8 ww3_s1sz9 $dNum_s1szb] \u []
                  let {
                    sat_s1szd [Occ=Once] :: a_s1hEV
                    [LclId] =
                        [ww1_s1sz7 ww2_s1sz8 $dNum_s1szb] \u []
                            GHC.Num.* $dNum_s1szb ww2_s1sz8 ww1_s1sz7; } in
                  let {
                    sat_s1szc [Occ=Once] :: a_s1hEV
                    [LclId] =
                        [ww_s1sz6 ww3_s1sz9 $dNum_s1szb] \u []
                            GHC.Num.* $dNum_s1szb ww_s1sz6 ww3_s1sz9;
                  } in  GHC.Num.+ $dNum_s1szb sat_s1szc sat_s1szd;
        } in  GHC.Real.$wreduce w_s1sz5 sat_s1sze sat_s1szf;

GHC.Real.$fNumRatio_$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1szg w1_s1szh w2_s1szi]
        case w1_s1szh of {
          GHC.Real.:% ww1_s1szk [Occ=Once] ww2_s1szl [Occ=Once] ->
              case w2_s1szi of {
                GHC.Real.:% ww4_s1szn [Occ=Once] ww5_s1szo [Occ=Once] ->
                    case
                        GHC.Real.$w$c+ w_s1szg ww1_s1szk ww2_s1szl ww4_s1szn ww5_s1szo
                    of
                    { (#,#) ww7_s1szq [Occ=Once] ww8_s1szr [Occ=Once] ->
                          GHC.Real.:% [ww7_s1szq ww8_s1szr];
                    };
              };
        };

GHC.Real.$w$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,1*C1(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1szs ww_s1szt ww1_s1szu ww2_s1szv ww3_s1szw]
        let {
          $dReal_s1szx [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hFd
          [LclId] =
              [w_s1szs] \s [] GHC.Real.$p1Integral w_s1szs; } in
        let {
          $dNum_s1szy [Dmd=<L,U(A,1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hFd
          [LclId] =
              [$dReal_s1szx] \u [] GHC.Real.$p1Real $dReal_s1szx; } in
        let {
          sat_s1szC [Occ=Once] :: a_s1hFd
          [LclId] =
              [ww1_s1szu ww3_s1szw $dNum_s1szy] \u []
                  GHC.Num.* $dNum_s1szy ww1_s1szu ww3_s1szw; } in
        let {
          sat_s1szB [Occ=Once] :: a_s1hFd
          [LclId] =
              [ww_s1szt ww1_s1szu ww2_s1szv ww3_s1szw $dNum_s1szy] \u []
                  let {
                    sat_s1szA [Occ=Once] :: a_s1hFd
                    [LclId] =
                        [ww1_s1szu ww2_s1szv $dNum_s1szy] \u []
                            GHC.Num.* $dNum_s1szy ww2_s1szv ww1_s1szu; } in
                  let {
                    sat_s1szz [Occ=Once] :: a_s1hFd
                    [LclId] =
                        [ww_s1szt ww3_s1szw $dNum_s1szy] \u []
                            GHC.Num.* $dNum_s1szy ww_s1szt ww3_s1szw;
                  } in  GHC.Num.- $dNum_s1szy sat_s1szz sat_s1szA;
        } in  GHC.Real.$wreduce w_s1szs sat_s1szB sat_s1szC;

GHC.Real.$fNumRatio_$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1szD w1_s1szE w2_s1szF]
        case w1_s1szE of {
          GHC.Real.:% ww1_s1szH [Occ=Once] ww2_s1szI [Occ=Once] ->
              case w2_s1szF of {
                GHC.Real.:% ww4_s1szK [Occ=Once] ww5_s1szL [Occ=Once] ->
                    case
                        GHC.Real.$w$c- w_s1szD ww1_s1szH ww2_s1szI ww4_s1szK ww5_s1szL
                    of
                    { (#,#) ww7_s1szN [Occ=Once] ww8_s1szO [Occ=Once] ->
                          GHC.Real.:% [ww7_s1szN ww8_s1szO];
                    };
              };
        };

GHC.Real.$w$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1szP ww_s1szQ ww1_s1szR ww2_s1szS ww3_s1szT]
        let {
          $dReal_s1szU [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hFv
          [LclId] =
              [w_s1szP] \s [] GHC.Real.$p1Integral w_s1szP; } in
        let {
          $dNum_s1szV [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hFv
          [LclId] =
              [$dReal_s1szU] \u [] GHC.Real.$p1Real $dReal_s1szU; } in
        let {
          sat_s1szX [Occ=Once] :: a_s1hFv
          [LclId] =
              [ww1_s1szR ww3_s1szT $dNum_s1szV] \u []
                  GHC.Num.* $dNum_s1szV ww1_s1szR ww3_s1szT; } in
        let {
          sat_s1szW [Occ=Once] :: a_s1hFv
          [LclId] =
              [ww_s1szQ ww2_s1szS $dNum_s1szV] \u []
                  GHC.Num.* $dNum_s1szV ww_s1szQ ww2_s1szS;
        } in  GHC.Real.$wreduce w_s1szP sat_s1szW sat_s1szX;

GHC.Real.$fNumRatio_$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1szY w1_s1szZ w2_s1sA0]
        case w1_s1szZ of {
          GHC.Real.:% ww1_s1sA2 [Occ=Once] ww2_s1sA3 [Occ=Once] ->
              case w2_s1sA0 of {
                GHC.Real.:% ww4_s1sA5 [Occ=Once] ww5_s1sA6 [Occ=Once] ->
                    case
                        GHC.Real.$w$c* w_s1szY ww1_s1sA2 ww2_s1sA3 ww4_s1sA5 ww5_s1sA6
                    of
                    { (#,#) ww7_s1sA8 [Occ=Once] ww8_s1sA9 [Occ=Once] ->
                          GHC.Real.:% [ww7_s1sA8 ww8_s1sA9];
                    };
              };
        };

GHC.Real.$fNumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Real.Integral a => GHC.Num.Num (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dIntegral_s1sAa]
        let {
          sat_s1sAh [Occ=Once]
            :: GHC.Integer.Type.Integer -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B1]
                  GHC.Real.$fNumRatio_$cfromInteger $dIntegral_s1sAa eta_B1; } in
        let {
          sat_s1sAg [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B1]
                  GHC.Real.$fNumRatio_$csignum $dIntegral_s1sAa eta_B1; } in
        let {
          sat_s1sAf [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B1]
                  GHC.Real.$fNumRatio_$cabs $dIntegral_s1sAa eta_B1; } in
        let {
          sat_s1sAe [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B1]
                  GHC.Real.$fNumRatio_$cnegate $dIntegral_s1sAa eta_B1; } in
        let {
          sat_s1sAd [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM
               -> GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B2 eta_B1]
                  GHC.Real.$fNumRatio_$c* $dIntegral_s1sAa eta_B2 eta_B1; } in
        let {
          sat_s1sAc [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM
               -> GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B2 eta_B1]
                  GHC.Real.$fNumRatio_$c- $dIntegral_s1sAa eta_B2 eta_B1; } in
        let {
          sat_s1sAb [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM
               -> GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B2 eta_B1]
                  GHC.Real.$fNumRatio_$c+ $dIntegral_s1sAa eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [sat_s1sAb
                         sat_s1sAc
                         sat_s1sAd
                         sat_s1sAe
                         sat_s1sAf
                         sat_s1sAg
                         sat_s1sAh];

GHC.Real.$fEnumRatio3 :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.$fEnumRatio1
                                GHC.Real.$fEnumRatio1];

GHC.Real.$fEnumRatio_$s$csucc
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [x_s1sAi]
        case x_s1sAi of {
          GHC.Real.:% ww1_s1sAk [Occ=Once] ww2_s1sAl [Occ=Once] ->
              case
                  GHC.Real.$w$s$c+
                      ww1_s1sAk ww2_s1sAl GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1sAn [Occ=Once] ww5_s1sAo [Occ=Once] ->
                    GHC.Real.:% [ww4_s1sAn ww5_s1sAo];
              };
        };

GHC.Real.$fEnumRatio_$csucc
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sAp x_s1sAq]
        case x_s1sAq of {
          GHC.Real.:% ww1_s1sAs [Occ=Once] ww2_s1sAt [Occ=Once] ->
              case
                  GHC.Real.$w$cfromInteger $dIntegral_s1sAp GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1sAv [Occ=Once] ww5_s1sAw [Occ=Once] ->
                    case
                        GHC.Real.$w$c+
                            $dIntegral_s1sAp ww1_s1sAs ww2_s1sAt ww4_s1sAv ww5_s1sAw
                    of
                    { (#,#) ww7_s1sAy [Occ=Once] ww8_s1sAz [Occ=Once] ->
                          GHC.Real.:% [ww7_s1sAy ww8_s1sAz];
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$cpred
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [x_s1sAA]
        case x_s1sAA of {
          GHC.Real.:% ww1_s1sAC [Occ=Once] ww2_s1sAD [Occ=Once] ->
              case
                  GHC.Real.$w$s$c-
                      ww1_s1sAC ww2_s1sAD GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1sAF [Occ=Once] ww5_s1sAG [Occ=Once] ->
                    GHC.Real.:% [ww4_s1sAF ww5_s1sAG];
              };
        };

GHC.Real.$fEnumRatio_$cpred
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sAH x_s1sAI]
        case x_s1sAI of {
          GHC.Real.:% ww1_s1sAK [Occ=Once] ww2_s1sAL [Occ=Once] ->
              case
                  GHC.Real.$w$cfromInteger $dIntegral_s1sAH GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1sAN [Occ=Once] ww5_s1sAO [Occ=Once] ->
                    case
                        GHC.Real.$w$c-
                            $dIntegral_s1sAH ww1_s1sAK ww2_s1sAL ww4_s1sAN ww5_s1sAO
                    of
                    { (#,#) ww7_s1sAQ [Occ=Once] ww8_s1sAR [Occ=Once] ->
                          GHC.Real.:% [ww7_s1sAQ ww8_s1sAR];
                    };
              };
        };

GHC.Real.$fFractionalRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Fractional (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dIntegral_s1sAS]
        let {
          sat_s1sAW [Occ=Once] :: GHC.Real.Rational -> GHC.Real.Ratio a_a1eGy
          [LclId] =
              [$dIntegral_s1sAS] \r [eta_B1]
                  GHC.Real.$fFractionalRatio_$cfromRational
                      $dIntegral_s1sAS eta_B1; } in
        let {
          sat_s1sAV [Occ=Once]
            :: GHC.Real.Ratio a_a1eGy -> GHC.Real.Ratio a_a1eGy
          [LclId] =
              [$dIntegral_s1sAS] \r [eta_B1]
                  GHC.Real.$fFractionalRatio_$crecip $dIntegral_s1sAS eta_B1; } in
        let {
          sat_s1sAU [Occ=Once]
            :: GHC.Real.Ratio a_a1eGy
               -> GHC.Real.Ratio a_a1eGy -> GHC.Real.Ratio a_a1eGy
          [LclId] =
              [$dIntegral_s1sAS] \r [eta_B2 eta_B1]
                  GHC.Real.$fFractionalRatio_$c/ $dIntegral_s1sAS eta_B2 eta_B1; } in
        let {
          sat_s1sAT [Occ=Once] :: GHC.Num.Num (GHC.Real.Ratio a_a1eGy)
          [LclId] =
              [$dIntegral_s1sAS] \u [] GHC.Real.$fNumRatio $dIntegral_s1sAS;
        } in 
          GHC.Real.C:Fractional [sat_s1sAT sat_s1sAU sat_s1sAV sat_s1sAW];

GHC.Real.$fEnumRatio_$cenumFrom
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sAX]
        let {
          w_s1sAY [Occ=OnceL, Dmd=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)>]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1sAX] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1sAX; } in
        let {
          sat_s1sB3 [Occ=OnceT[0]]
            :: GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [w_s1sAY] \r [w1_s1sAZ]
                  case GHC.Real.$wnumericEnumFrom w_s1sAY w1_s1sAZ of {
                    (#,#) ww1_s1sB1 [Occ=Once] ww2_s1sB2 [Occ=Once] ->
                        : [ww1_s1sB1 ww2_s1sB2];
                  };
        } in  sat_s1sB3;

GHC.Real.$fEnumRatio_$cenumFromThen
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sB4]
        let {
          w_s1sB5 [Occ=OnceL,
                   Dmd=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)>]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1sB4] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1sB4; } in
        let {
          sat_s1sBb [Occ=OnceT[0]]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [w_s1sB5] \r [w1_s1sB6 w2_s1sB7]
                  case GHC.Real.$wnumericEnumFromThen w_s1sB5 w1_s1sB6 w2_s1sB7 of {
                    (#,#) ww1_s1sB9 [Occ=Once] ww2_s1sBa [Occ=Once] ->
                        : [ww1_s1sB9 ww2_s1sBa];
                  };
        } in  sat_s1sBb;

GHC.Real.$fEnumRatio_$cenumFromTo
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sBc]
        let {
          sat_s1sBe [Occ=Once]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1sBc] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1sBc; } in
        let {
          sat_s1sBd [Occ=Once] :: GHC.Classes.Ord (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1sBc] \u [] GHC.Real.$fOrdRatio $dIntegral_s1sBc;
        } in  GHC.Real.numericEnumFromTo sat_s1sBd sat_s1sBe;

GHC.Real.$fEnumRatio_$cenumFromThenTo
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a
     -> GHC.Real.Ratio a -> GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sBf]
        let {
          sat_s1sBh [Occ=Once]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1sBf] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1sBf; } in
        let {
          sat_s1sBg [Occ=Once] :: GHC.Classes.Ord (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1sBf] \u [] GHC.Real.$fOrdRatio $dIntegral_s1sBf;
        } in  GHC.Real.numericEnumFromThenTo sat_s1sBg sat_s1sBh;

GHC.Real.$fRealFracRatio_$s$fRealRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Real.$fFractionalRatio_$s$fNumRatio
                                    GHC.Real.$fOrdRatio_$s$fOrdRatio
                                    GHC.Real.$fRealRatio_$s$ctoRational];

GHC.Real.$fRealRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Real (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,C(U))>m] =
    [] \r [$dIntegral_s1sBi]
        let {
          sat_s1sBl [Occ=Once] :: GHC.Real.Ratio a_a1eHn -> GHC.Real.Rational
          [LclId] =
              [$dIntegral_s1sBi] \r [eta_B1]
                  GHC.Real.$fRealRatio_$ctoRational $dIntegral_s1sBi eta_B1; } in
        let {
          sat_s1sBk [Occ=Once] :: GHC.Classes.Ord (GHC.Real.Ratio a_a1eHn)
          [LclId] =
              [$dIntegral_s1sBi] \u [] GHC.Real.$fOrdRatio $dIntegral_s1sBi; } in
        let {
          sat_s1sBj [Occ=Once] :: GHC.Num.Num (GHC.Real.Ratio a_a1eHn)
          [LclId] =
              [$dIntegral_s1sBi] \u [] GHC.Real.$fNumRatio $dIntegral_s1sBi;
        } in  GHC.Real.C:Real [sat_s1sBj sat_s1sBk sat_s1sBl];

GHC.Real.$w$s$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(1*C1(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sBm ww_s1sBn ww1_s1sBo]
        case GHC.Real.$w$s$cproperFraction w_s1sBm ww_s1sBn ww1_s1sBo of {
          (#,#) ww3_s1sBq [Occ=Once*] ww4_s1sBr [Occ=Once!] ->
              case ww4_s1sBr of {
                GHC.Real.:% ww6_s1sBt [Occ=Once] ww7_s1sBu [Occ=Once] ->
                    case
                        GHC.Real.$w$s$ccompare
                            ww6_s1sBt ww7_s1sBu GHC.Real.even1 GHC.Real.$fEnumRatio1
                    of
                    { __DEFAULT -> ww3_s1sBq;
                      GHC.Types.GT ->
                          case
                              GHC.Real.$p1Integral w_s1sBm
                          of
                          $dReal_s1sBw [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
                          { __DEFAULT ->
                                case
                                    GHC.Real.$p1Real $dReal_s1sBw
                                of
                                $dNum_s1sBx [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                                { __DEFAULT ->
                                      let {
                                        sat_s1sBy [Occ=Once] :: b_s1hFX
                                        [LclId] =
                                            [$dNum_s1sBx] \u []
                                                GHC.Num.fromInteger
                                                    $dNum_s1sBx GHC.Real.$fEnumRatio1;
                                      } in  GHC.Num.+ $dNum_s1sBx ww3_s1sBq sat_s1sBy;
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$s$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sBz w1_s1sBA]
        case w1_s1sBA of {
          GHC.Real.:% ww1_s1sBC [Occ=Once] ww2_s1sBD [Occ=Once] ->
              GHC.Real.$w$s$cceiling w_s1sBz ww1_s1sBC ww2_s1sBD;
        };

GHC.Real.$w$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(1*C1(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sBE w1_s1sBF ww_s1sBG ww1_s1sBH]
        case
            GHC.Real.$w$cproperFraction w_s1sBE w1_s1sBF ww_s1sBG ww1_s1sBH
        of
        { (#,#) ww3_s1sBJ [Occ=Once*] ww4_s1sBK [Occ=Once!] ->
              case ww4_s1sBK of {
                GHC.Real.:% ww6_s1sBM [Occ=Once] ww7_s1sBN [Occ=Once] ->
                    case GHC.Real.$w$cfromInteger w_s1sBE GHC.Real.even1 of {
                      (#,#) ww9_s1sBP [Occ=Once] ww10_s1sBQ [Occ=Once] ->
                          case
                              GHC.Real.$w$ccompare
                                  w_s1sBE ww6_s1sBM ww7_s1sBN ww9_s1sBP ww10_s1sBQ
                          of
                          { __DEFAULT -> ww3_s1sBJ;
                            GHC.Types.GT ->
                                case
                                    GHC.Real.$p1Integral w1_s1sBF
                                of
                                $dReal_s1sBS [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
                                { __DEFAULT ->
                                      case
                                          GHC.Real.$p1Real $dReal_s1sBS
                                      of
                                      $dNum_s1sBT [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                                      { __DEFAULT ->
                                            let {
                                              sat_s1sBU [Occ=Once] :: b_s1hGi
                                              [LclId] =
                                                  [$dNum_s1sBT] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s1sBT GHC.Real.$fEnumRatio1;
                                            } in  GHC.Num.+ $dNum_s1sBT ww3_s1sBJ sat_s1sBU;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sBV w1_s1sBW w2_s1sBX]
        case w2_s1sBX of {
          GHC.Real.:% ww1_s1sBZ [Occ=Once] ww2_s1sC0 [Occ=Once] ->
              GHC.Real.$w$cceiling w_s1sBV w1_s1sBW ww1_s1sBZ ww2_s1sC0;
        };

GHC.Real.$w$s$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,1*C1(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sC1 ww_s1sC2 ww1_s1sC3]
        case GHC.Real.$w$s$cproperFraction w_s1sC1 ww_s1sC2 ww1_s1sC3 of {
          (#,#) ww3_s1sC5 [Occ=Once*] ww4_s1sC6 [Occ=Once!] ->
              case ww4_s1sC6 of {
                GHC.Real.:% x_s1sC8 [Occ=Once] y_s1sC9 [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger GHC.Real.even1 y_s1sC9
                    of
                    sat_s1sCb
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger x_s1sC8 GHC.Real.$fEnumRatio1
                          of
                          sat_s1sCa
                          { __DEFAULT ->
                                case GHC.Integer.Type.ltInteger# sat_s1sCa sat_s1sCb of {
                                  __DEFAULT -> ww3_s1sC5;
                                  1# ->
                                      case
                                          GHC.Real.$p1Integral w_s1sC1
                                      of
                                      $dReal_s1sCd [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                      { __DEFAULT ->
                                            case
                                                GHC.Real.$p1Real $dReal_s1sCd
                                            of
                                            $dNum_s1sCe [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                            { __DEFAULT ->
                                                  let {
                                                    sat_s1sCf [Occ=Once] :: b_s1hGr
                                                    [LclId] =
                                                        [$dNum_s1sCe] \u []
                                                            GHC.Num.fromInteger
                                                                $dNum_s1sCe GHC.Real.$fEnumRatio1;
                                                  } in  GHC.Num.- $dNum_s1sCe ww3_s1sC5 sat_s1sCf;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$s$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sCg w1_s1sCh]
        case w1_s1sCh of {
          GHC.Real.:% ww1_s1sCj [Occ=Once] ww2_s1sCk [Occ=Once] ->
              GHC.Real.$w$s$cfloor w_s1sCg ww1_s1sCj ww2_s1sCk;
        };

GHC.Real.$w$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLLLLC(S))S(LLC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(A,1*C1(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sCl w1_s1sCm ww_s1sCn ww1_s1sCo]
        case
            GHC.Real.$w$cproperFraction w_s1sCl w1_s1sCm ww_s1sCn ww1_s1sCo
        of
        { (#,#) ww3_s1sCq [Occ=Once*] ww4_s1sCr [Occ=Once!] ->
              case ww4_s1sCr of {
                GHC.Real.:% ww6_s1sCt [Occ=Once] ww7_s1sCu [Occ=Once] ->
                    case GHC.Real.$w$cfromInteger w_s1sCl GHC.Real.even1 of {
                      (#,#) ww9_s1sCw [Occ=Once] ww10_s1sCx [Occ=Once] ->
                          case
                              GHC.Real.$w$c< w_s1sCl ww6_s1sCt ww7_s1sCu ww9_s1sCw ww10_s1sCx
                          of
                          { GHC.Types.False -> ww3_s1sCq;
                            GHC.Types.True ->
                                case
                                    GHC.Real.$p1Integral w1_s1sCm
                                of
                                $dReal_s1sCz [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                { __DEFAULT ->
                                      case
                                          GHC.Real.$p1Real $dReal_s1sCz
                                      of
                                      $dNum_s1sCA [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                      { __DEFAULT ->
                                            let {
                                              sat_s1sCB [Occ=Once] :: b_s1hGM
                                              [LclId] =
                                                  [$dNum_s1sCA] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s1sCA GHC.Real.$fEnumRatio1;
                                            } in  GHC.Num.- $dNum_s1sCA ww3_s1sCq sat_s1sCB;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLLLLC(S))S(LLC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(A,A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sCC w1_s1sCD w2_s1sCE]
        case w2_s1sCE of {
          GHC.Real.:% ww1_s1sCG [Occ=Once] ww2_s1sCH [Occ=Once] ->
              GHC.Real.$w$cfloor w_s1sCC w1_s1sCD ww1_s1sCG ww2_s1sCH;
        };

sat_s1sCI :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s1sCJ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1sCI GHC.Types.[]];

GHC.Real.$fRealFracRatio2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.False sat_s1sCJ;

GHC.Real.$w$s$cround [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sCK ww_s1sCL ww1_s1sCM]
        case GHC.Real.$w$s$cproperFraction w_s1sCK ww_s1sCL ww1_s1sCM of {
          (#,#) ww3_s1sCO ww4_s1sCP [Occ=Once!] ->
              case ww4_s1sCP of {
                GHC.Real.:% ww6_s1sCR ww7_s1sCS ->
                    case GHC.Integer.Type.absInteger ww6_s1sCR of dt_s1sCT {
                      __DEFAULT ->
                          case
                              GHC.Real.$w$s$c-
                                  dt_s1sCT ww7_s1sCS GHC.Real.$fEnumRatio1 GHC.Real.even2
                          of
                          { (#,#) ww9_s1sCV [Occ=Once] _ [Occ=Dead] ->
                                case GHC.Integer.Type.signumInteger ww9_s1sCV of dt1_s1sCX {
                                  __DEFAULT ->
                                      case
                                          GHC.Integer.Type.eqInteger#
                                              dt1_s1sCX GHC.Real.$fRealFracRatio2
                                      of
                                      { __DEFAULT ->
                                            let-no-escape {
                                              m_s1sCZ [Occ=Once*T[0], Dmd=<L,1*U>] :: b_s1hH5
                                              [LclId[JoinId(0)], Unf=OtherCon []] =
                                                  [w_s1sCK ww3_s1sCO ww6_s1sCR ww7_s1sCS] \r []
                                                      case
                                                          GHC.Real.$p1Integral w_s1sCK
                                                      of
                                                      $dReal_s1sD0 [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                                      { __DEFAULT ->
                                                            case
                                                                GHC.Real.$p1Real $dReal_s1sD0
                                                            of
                                                            $dNum_s1sD1 [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                                            { __DEFAULT ->
                                                                  case
                                                                      GHC.Integer.Type.timesInteger
                                                                          GHC.Real.even1 ww7_s1sCS
                                                                  of
                                                                  sat_s1sD3
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Integer.Type.timesInteger
                                                                                ww6_s1sCR
                                                                                GHC.Real.$fEnumRatio1
                                                                        of
                                                                        sat_s1sD2
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.ltInteger#
                                                                                      sat_s1sD2
                                                                                      sat_s1sD3
                                                                              of
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_s1sD5 [Occ=Once]
                                                                                        :: b_s1hH5
                                                                                      [LclId] =
                                                                                          [$dNum_s1sD1] \u []
                                                                                              GHC.Num.fromInteger
                                                                                                  $dNum_s1sD1
                                                                                                  GHC.Real.$fEnumRatio1;
                                                                                    } in 
                                                                                      GHC.Num.+
                                                                                          $dNum_s1sD1
                                                                                          ww3_s1sCO
                                                                                          sat_s1sD5;
                                                                                1# ->
                                                                                    let {
                                                                                      sat_s1sD6 [Occ=Once]
                                                                                        :: b_s1hH5
                                                                                      [LclId] =
                                                                                          [$dNum_s1sD1] \u []
                                                                                              GHC.Num.fromInteger
                                                                                                  $dNum_s1sD1
                                                                                                  GHC.Real.$fEnumRatio1;
                                                                                    } in 
                                                                                      GHC.Num.-
                                                                                          $dNum_s1sD1
                                                                                          ww3_s1sCO
                                                                                          sat_s1sD6;
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                            } in 
                                              case
                                                  GHC.Integer.Type.eqInteger#
                                                      dt1_s1sCX GHC.Real.even1
                                              of
                                              { __DEFAULT ->
                                                    case
                                                        GHC.Integer.Type.eqInteger#
                                                            dt1_s1sCX GHC.Real.$fEnumRatio1
                                                    of
                                                    { __DEFAULT -> GHC.Real.$fRealFracRatio1;
                                                      1# -> m_s1sCZ;
                                                    };
                                                1# ->
                                                    case GHC.Real.even w_s1sCK ww3_s1sCO of {
                                                      GHC.Types.False -> m_s1sCZ;
                                                      GHC.Types.True -> ww3_s1sCO;
                                                    };
                                              };
                                        1# -> ww3_s1sCO;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$s$cround [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sDa w1_s1sDb]
        case w1_s1sDb of {
          GHC.Real.:% ww1_s1sDd [Occ=Once] ww2_s1sDe [Occ=Once] ->
              GHC.Real.$w$s$cround w_s1sDa ww1_s1sDd ww2_s1sDe;
        };

GHC.Real.$w$cround [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLC(S)C(S)C(S)C(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),1*C1(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sDf w1_s1sDg ww_s1sDh ww1_s1sDi]
        case
            GHC.Real.$w$cproperFraction w_s1sDf w1_s1sDg ww_s1sDh ww1_s1sDi
        of
        { (#,#) ww3_s1sDk ww4_s1sDl [Occ=Once!] ->
              case ww4_s1sDl of {
                GHC.Real.:% ww6_s1sDn ww7_s1sDo ->
                    case GHC.Real.$p1Integral w_s1sDf of sat_s1sDp {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_s1sDp of sat_s1sDq {
                            __DEFAULT ->
                                case GHC.Num.abs sat_s1sDq ww6_s1sDn of dt_s1sDr {
                                  __DEFAULT ->
                                      case
                                          GHC.Real.$w$cfromRational
                                              w_s1sDf GHC.Real.$fEnumRatio1 GHC.Real.even2
                                      of
                                      { (#,#) ww9_s1sDt [Occ=Once] ww10_s1sDu [Occ=Once] ->
                                            case
                                                GHC.Real.$w$c-
                                                    w_s1sDf dt_s1sDr ww7_s1sDo ww9_s1sDt ww10_s1sDu
                                            of
                                            { (#,#) ww12_s1sDw [Occ=Once] _ [Occ=Dead] ->
                                                  case GHC.Real.$w$csignum w_s1sDf ww12_s1sDw of {
                                                    (#,#) ww15_s1sDz ww16_s1sDA ->
                                                        case
                                                            GHC.Real.$w$cfromInteger
                                                                w_s1sDf GHC.Real.$fEnumRatio1
                                                        of
                                                        { (#,#) ww18_s1sDC ww19_s1sDD ->
                                                              case
                                                                  GHC.Real.$p1Integral w_s1sDf
                                                              of
                                                              sat_s1sDE
                                                              { __DEFAULT ->
                                                                    case
                                                                        GHC.Real.$p1Real sat_s1sDE
                                                                    of
                                                                    sat_s1sDF
                                                                    { __DEFAULT ->
                                                                          case
                                                                              GHC.Num.negate
                                                                                  sat_s1sDF
                                                                                  ww18_s1sDC
                                                                          of
                                                                          dt1_s1sDG
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    GHC.Real.$p1Integral
                                                                                        w_s1sDf
                                                                                of
                                                                                $dEq_s1sDH [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          GHC.Real.$p2Real
                                                                                              $dEq_s1sDH
                                                                                      of
                                                                                      $dEq1_s1sDI [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                GHC.Classes.$p1Ord
                                                                                                    $dEq1_s1sDI
                                                                                            of
                                                                                            $dEq2_s1sDJ [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                                                                            { __DEFAULT ->
                                                                                                  let-no-escape {
                                                                                                    $j_s1sDK [Occ=Once*T[0],
                                                                                                              Dmd=<L,1*U>]
                                                                                                      :: b_s1hHq
                                                                                                    [LclId[JoinId(0)],
                                                                                                     Unf=OtherCon []] =
                                                                                                        [w_s1sDf
                                                                                                         w1_s1sDg
                                                                                                         ww3_s1sDk
                                                                                                         ww6_s1sDn
                                                                                                         ww7_s1sDo
                                                                                                         ww15_s1sDz
                                                                                                         ww16_s1sDA
                                                                                                         ww18_s1sDC
                                                                                                         ww19_s1sDD
                                                                                                         $dEq2_s1sDJ] \r []
                                                                                                            case
                                                                                                                GHC.Real.$w$cfromInteger
                                                                                                                    w_s1sDf
                                                                                                                    GHC.Real.even1
                                                                                                            of
                                                                                                            { (#,#) ww21_s1sDM
                                                                                                                    ww22_s1sDN ->
                                                                                                                  let-no-escape {
                                                                                                                    m_s1sDO [Dmd=<L,1*U>]
                                                                                                                      :: b_s1hHq
                                                                                                                    [LclId[JoinId(0)],
                                                                                                                     Unf=OtherCon []] =
                                                                                                                        [w_s1sDf
                                                                                                                         w1_s1sDg
                                                                                                                         ww3_s1sDk
                                                                                                                         ww6_s1sDn
                                                                                                                         ww7_s1sDo
                                                                                                                         ww21_s1sDM
                                                                                                                         ww22_s1sDN] \r []
                                                                                                                            case
                                                                                                                                GHC.Real.$p1Integral
                                                                                                                                    w1_s1sDg
                                                                                                                            of
                                                                                                                            $dReal_s1sDP [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      GHC.Real.$p1Real
                                                                                                                                          $dReal_s1sDP
                                                                                                                                  of
                                                                                                                                  $dNum_s1sDQ [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            GHC.Real.$w$c<
                                                                                                                                                w_s1sDf
                                                                                                                                                ww6_s1sDn
                                                                                                                                                ww7_s1sDo
                                                                                                                                                ww21_s1sDM
                                                                                                                                                ww22_s1sDN
                                                                                                                                        of
                                                                                                                                        { GHC.Types.False ->
                                                                                                                                              let {
                                                                                                                                                sat_s1sDS [Occ=Once]
                                                                                                                                                  :: b_s1hHq
                                                                                                                                                [LclId] =
                                                                                                                                                    [$dNum_s1sDQ] \u []
                                                                                                                                                        GHC.Num.fromInteger
                                                                                                                                                            $dNum_s1sDQ
                                                                                                                                                            GHC.Real.$fEnumRatio1;
                                                                                                                                              } in 
                                                                                                                                                GHC.Num.+
                                                                                                                                                    $dNum_s1sDQ
                                                                                                                                                    ww3_s1sDk
                                                                                                                                                    sat_s1sDS;
                                                                                                                                          GHC.Types.True ->
                                                                                                                                              let {
                                                                                                                                                sat_s1sDT [Occ=Once]
                                                                                                                                                  :: b_s1hHq
                                                                                                                                                [LclId] =
                                                                                                                                                    [$dNum_s1sDQ] \u []
                                                                                                                                                        GHC.Num.fromInteger
                                                                                                                                                            $dNum_s1sDQ
                                                                                                                                                            GHC.Real.$fEnumRatio1;
                                                                                                                                              } in 
                                                                                                                                                GHC.Num.-
                                                                                                                                                    $dNum_s1sDQ
                                                                                                                                                    ww3_s1sDk
                                                                                                                                                    sat_s1sDT;
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                  } in 
                                                                                                                    let-no-escape {
                                                                                                                      $j1_s1sDU [Occ=Once*T[0],
                                                                                                                                 Dmd=<L,1*U>]
                                                                                                                        :: b_s1hHq
                                                                                                                      [LclId[JoinId(0)],
                                                                                                                       Unf=OtherCon []] =
                                                                                                                          [ww15_s1sDz
                                                                                                                           ww16_s1sDA
                                                                                                                           ww18_s1sDC
                                                                                                                           ww19_s1sDD
                                                                                                                           $dEq2_s1sDJ
                                                                                                                           m_s1sDO] \r []
                                                                                                                              case
                                                                                                                                  GHC.Classes.==
                                                                                                                                      $dEq2_s1sDJ
                                                                                                                                      ww15_s1sDz
                                                                                                                                      ww18_s1sDC
                                                                                                                              of
                                                                                                                              { GHC.Types.False ->
                                                                                                                                    GHC.Real.$fRealFracRatio1;
                                                                                                                                GHC.Types.True ->
                                                                                                                                    case
                                                                                                                                        GHC.Classes.==
                                                                                                                                            $dEq2_s1sDJ
                                                                                                                                            ww16_s1sDA
                                                                                                                                            ww19_s1sDD
                                                                                                                                    of
                                                                                                                                    { GHC.Types.False ->
                                                                                                                                          GHC.Real.$fRealFracRatio1;
                                                                                                                                      GHC.Types.True ->
                                                                                                                                          m_s1sDO;
                                                                                                                                    };
                                                                                                                              };
                                                                                                                    } in 
                                                                                                                      case
                                                                                                                          GHC.Classes.==
                                                                                                                              $dEq2_s1sDJ
                                                                                                                              ww15_s1sDz
                                                                                                                              ww21_s1sDM
                                                                                                                      of
                                                                                                                      { GHC.Types.False ->
                                                                                                                            $j1_s1sDU;
                                                                                                                        GHC.Types.True ->
                                                                                                                            case
                                                                                                                                GHC.Classes.==
                                                                                                                                    $dEq2_s1sDJ
                                                                                                                                    ww16_s1sDA
                                                                                                                                    ww22_s1sDN
                                                                                                                            of
                                                                                                                            { GHC.Types.False ->
                                                                                                                                  $j1_s1sDU;
                                                                                                                              GHC.Types.True ->
                                                                                                                                  case
                                                                                                                                      GHC.Real.even
                                                                                                                                          w1_s1sDg
                                                                                                                                          ww3_s1sDk
                                                                                                                                  of
                                                                                                                                  { GHC.Types.False ->
                                                                                                                                        m_s1sDO;
                                                                                                                                    GHC.Types.True ->
                                                                                                                                        ww3_s1sDk;
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                            };
                                                                                                  } in 
                                                                                                    case
                                                                                                        GHC.Classes.==
                                                                                                            $dEq2_s1sDJ
                                                                                                            ww15_s1sDz
                                                                                                            dt1_s1sDG
                                                                                                    of
                                                                                                    { GHC.Types.False ->
                                                                                                          $j_s1sDK;
                                                                                                      GHC.Types.True ->
                                                                                                          case
                                                                                                              GHC.Classes.==
                                                                                                                  $dEq2_s1sDJ
                                                                                                                  ww16_s1sDA
                                                                                                                  ww19_s1sDD
                                                                                                          of
                                                                                                          { GHC.Types.False ->
                                                                                                                $j_s1sDK;
                                                                                                            GHC.Types.True ->
                                                                                                                ww3_s1sDk;
                                                                                                          };
                                                                                                    };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$cround [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLC(S)C(S)C(S)C(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sE2 w1_s1sE3 w2_s1sE4]
        case w2_s1sE4 of {
          GHC.Real.:% ww1_s1sE6 [Occ=Once] ww2_s1sE7 [Occ=Once] ->
              GHC.Real.$w$cround w_s1sE2 w1_s1sE3 ww1_s1sE6 ww2_s1sE7;
        };

GHC.Real.$fRealFracRatio_$s$ctruncate [InlPrag=INLINE (sat-args=1)]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sE8 x_s1sE9]
        case x_s1sE9 of {
          GHC.Real.:% x1_s1sEb [Occ=Once] y_s1sEc ->
              let {
                sat_s1sEk [Occ=Once] :: GHC.Integer.Type.Integer
                [LclId] =
                    [x1_s1sEb y_s1sEc] \u []
                        case GHC.Integer.Type.eqInteger# y_s1sEc GHC.Real.even1 of {
                          __DEFAULT ->
                              case GHC.Integer.Type.quotRemInteger x1_s1sEb y_s1sEc of {
                                (#,#) ipv_s1sEh [Occ=Once] _ [Occ=Dead] -> ipv_s1sEh;
                              };
                          1# -> GHC.Real.divZeroError;
                        };
              } in 
                case GHC.Real.$p1Integral $dIntegral_s1sE8 of sat_s1sEd {
                  __DEFAULT ->
                      case GHC.Real.$p1Real sat_s1sEd of sat_s1sEe {
                        __DEFAULT -> GHC.Num.fromInteger sat_s1sEe sat_s1sEk;
                      };
                };
        };

GHC.Real.$fRealFracRatio_$ctruncate [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sEl $dIntegral1_s1sEm x_s1sEn]
        case x_s1sEn of {
          GHC.Real.:% ww1_s1sEp [Occ=Once] ww2_s1sEq [Occ=Once] ->
              case
                  GHC.Real.$w$cproperFraction
                      $dIntegral_s1sEl $dIntegral1_s1sEm ww1_s1sEp ww2_s1sEq
              of
              { (#,#) ww4_s1sEs [Occ=Once] _ [Occ=Dead] -> ww4_s1sEs;
              };
        };

GHC.Real.$fRealFracRatio_$s$fRealFracRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.RealFrac (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:RealFrac! [GHC.Real.$fRealFracRatio_$s$fRealRatio
                                        GHC.Real.$fFractionalRatio_$s$fFractionalRatio
                                        GHC.Real.$fEnumRatio_$s$cproperFraction
                                        GHC.Real.$fRealFracRatio_$s$ctruncate
                                        GHC.Real.$fRealFracRatio_$s$cround
                                        GHC.Real.$fRealFracRatio_$s$cceiling
                                        GHC.Real.$fRealFracRatio_$s$cfloor];

GHC.Real.$fRealFracRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.RealFrac (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))>m] =
    [] \r [$dIntegral_s1sEu]
        let {
          sat_s1sEB [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1sEu] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$cfloor
                      $dIntegral_s1sEu eta_B2 eta_B1; } in
        let {
          sat_s1sEA [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1sEu] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$cceiling
                      $dIntegral_s1sEu eta_B2 eta_B1; } in
        let {
          sat_s1sEz [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1sEu] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$cround
                      $dIntegral_s1sEu eta_B2 eta_B1; } in
        let {
          sat_s1sEy [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1sEu] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$ctruncate
                      $dIntegral_s1sEu eta_B2 eta_B1; } in
        let {
          sat_s1sEx [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               GHC.Real.Ratio a_a1eFc -> (b, GHC.Real.Ratio a_a1eFc)
          [LclId] =
              [$dIntegral_s1sEu] \r [eta_B2 eta_B1]
                  GHC.Real.$fEnumRatio_$cproperFraction
                      $dIntegral_s1sEu eta_B2 eta_B1; } in
        let {
          sat_s1sEw [Occ=Once]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eFc)
          [LclId] =
              [$dIntegral_s1sEu] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1sEu; } in
        let {
          sat_s1sEv [Occ=Once] :: GHC.Real.Real (GHC.Real.Ratio a_a1eFc)
          [LclId] =
              [$dIntegral_s1sEu] \u [] GHC.Real.$fRealRatio $dIntegral_s1sEu;
        } in 
          GHC.Real.C:RealFrac [sat_s1sEv
                               sat_s1sEw
                               sat_s1sEx
                               sat_s1sEy
                               sat_s1sEz
                               sat_s1sEA
                               sat_s1sEB];

g_r1j3N
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
[GblId, Arity=3, Str=<S,U><S,U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [x_s1sEC y_s1sED z_s1sEE]
        case
            GHC.Integer.Type.remInteger y_s1sED GHC.Real.even2
        of
        sat_s1sEF
        { __DEFAULT ->
              case GHC.Integer.Type.eqInteger# sat_s1sEF GHC.Real.even1 of {
                __DEFAULT ->
                    case GHC.Integer.Type.eqInteger# y_s1sED GHC.Real.$fEnumRatio1 of {
                      __DEFAULT ->
                          case GHC.Integer.Type.timesInteger x_s1sEC z_s1sEE of sat_s1sEK {
                            __DEFAULT ->
                                case
                                    GHC.Integer.Type.quotInteger y_s1sED GHC.Real.even2
                                of
                                sat_s1sEJ
                                { __DEFAULT ->
                                      case
                                          GHC.Integer.Type.timesInteger x_s1sEC x_s1sEC
                                      of
                                      sat_s1sEI
                                      { __DEFAULT -> g_r1j3N sat_s1sEI sat_s1sEJ sat_s1sEK;
                                      };
                                };
                          };
                      1# -> GHC.Integer.Type.timesInteger x_s1sEC z_s1sEE;
                    };
                1# ->
                    case
                        GHC.Integer.Type.quotInteger y_s1sED GHC.Real.even2
                    of
                    sat_s1sEM
                    { __DEFAULT ->
                          case GHC.Integer.Type.timesInteger x_s1sEC x_s1sEC of sat_s1sEL {
                            __DEFAULT -> g_r1j3N sat_s1sEL sat_s1sEM z_s1sEE;
                          };
                    };
              };
        };

GHC.Real.^_f [Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [x_s1sEN y_s1sEO]
        case
            GHC.Integer.Type.remInteger y_s1sEO GHC.Real.even2
        of
        sat_s1sEP
        { __DEFAULT ->
              case GHC.Integer.Type.eqInteger# sat_s1sEP GHC.Real.even1 of {
                __DEFAULT ->
                    case GHC.Integer.Type.eqInteger# y_s1sEO GHC.Real.$fEnumRatio1 of {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.quotInteger y_s1sEO GHC.Real.even2
                          of
                          sat_s1sET
                          { __DEFAULT ->
                                case GHC.Integer.Type.timesInteger x_s1sEN x_s1sEN of sat_s1sES {
                                  __DEFAULT -> g_r1j3N sat_s1sES sat_s1sET x_s1sEN;
                                };
                          };
                      1# -> x_s1sEN;
                    };
                1# ->
                    case
                        GHC.Integer.Type.quotInteger y_s1sEO GHC.Real.even2
                    of
                    sat_s1sEV
                    { __DEFAULT ->
                          case GHC.Integer.Type.timesInteger x_s1sEN x_s1sEN of sat_s1sEU {
                            __DEFAULT -> GHC.Real.^_f sat_s1sEU sat_s1sEV;
                          };
                    };
              };
        };

lvl5_r1j3O :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Negative exponent"#;

GHC.Real.^1 :: GHC.Integer.Type.Integer
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1sEW {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1sEW;
        };

GHC.Real.^_$s^ [InlPrag=NOUSERINLINE[1]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [x0_s1sEX y0_s1sEY]
        case GHC.Integer.Type.ltInteger# y0_s1sEY GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.eqInteger# y0_s1sEY GHC.Real.even1 of {
                __DEFAULT -> GHC.Real.^_f x0_s1sEX y0_s1sEY;
                1# -> GHC.Real.$fEnumRatio1;
              };
          1# -> GHC.Real.^1;
        };

GHC.Real.$w$s$cfromEnum [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Prim.Int#
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1sF1 ww1_s1sF2]
        case GHC.Integer.Type.eqInteger# ww1_s1sF2 GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.quotRemInteger ww_s1sF1 ww1_s1sF2 of {
                (#,#) ipv_s1sF5 [Occ=Once] _ [Occ=Dead] ->
                    GHC.Integer.Type.integerToInt ipv_s1sF5;
              };
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fEnumRatio_$s$cfromEnum [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Int
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_s1sF8]
        case w_s1sF8 of {
          GHC.Real.:% ww1_s1sFa [Occ=Once] ww2_s1sFb [Occ=Once] ->
              case GHC.Real.$w$s$cfromEnum ww1_s1sFa ww2_s1sFb of ww3_s1sFc {
                __DEFAULT -> GHC.Types.I# [ww3_s1sFc];
              };
        };

GHC.Real.$fEnumRatio_$cfromEnum
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)),U(A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A,1*C1(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sFd x_s1sFe]
        case x_s1sFe of {
          GHC.Real.:% ww1_s1sFg [Occ=Once] ww2_s1sFh [Occ=Once] ->
              let {
                sat_s1sFl [Occ=Once] :: a_a1eE0
                [LclId] =
                    [$dIntegral_s1sFd ww1_s1sFg ww2_s1sFh] \u []
                        case GHC.Real.quotRem $dIntegral_s1sFd ww1_s1sFg ww2_s1sFh of {
                          (,) q_s1sFj [Occ=Once] _ [Occ=Dead] -> q_s1sFj;
                        };
              } in 
                case GHC.Real.toInteger $dIntegral_s1sFd sat_s1sFl of sat_s1sFm {
                  __DEFAULT ->
                      case GHC.Integer.Type.integerToInt sat_s1sFm of wild_s1sFn {
                        __DEFAULT -> GHC.Types.I# [wild_s1sFn];
                      };
                };
        };

GHC.Real.ratioPrec1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [8#];

GHC.Real.$fShowRatio2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    " % "#;

GHC.Real.$w$s$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Base.String
     -> (# GHC.Types.Char, [GHC.Types.Char] #)
[GblId, Arity=4, Str=<S,U><L,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1sFo ww1_s1sFp ww2_s1sFq w_s1sFr]
        case ># [ww_s1sFo 7#] of {
          __DEFAULT ->
              let {
                sat_s1sFx [Occ=Once] :: GHC.Base.String
                [LclId] =
                    [ww2_s1sFq w_s1sFr] \u []
                        let {
                          sat_s1sFw [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [ww2_s1sFq w_s1sFr] \u []
                                  case GHC.Show.$w$cshowsPrec4 8# ww2_s1sFq w_s1sFr of {
                                    (#,#) ww4_s1sFu [Occ=Once] ww5_s1sFv [Occ=Once] ->
                                        : [ww4_s1sFu ww5_s1sFv];
                                  };
                        } in 
                          GHC.CString.unpackAppendCString# GHC.Real.$fShowRatio2 sat_s1sFw;
              } in  GHC.Show.$w$cshowsPrec4 8# ww1_s1sFp sat_s1sFx;
          1# ->
              let {
                sat_s1sFH [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [ww1_s1sFp ww2_s1sFq w_s1sFr] \u []
                        let {
                          sat_s1sFD [Occ=Once] :: GHC.Base.String
                          [LclId] =
                              [ww2_s1sFq w_s1sFr] \u []
                                  let {
                                    sat_s1sFC [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [ww2_s1sFq w_s1sFr] \u []
                                            let {
                                              sat_s1sFy [Occ=Once] :: GHC.Base.String
                                              [LclId] =
                                                  CCCS :! [GHC.Show.$fShow(,)2 w_s1sFr];
                                            } in 
                                              case
                                                  GHC.Show.$w$cshowsPrec4 8# ww2_s1sFq sat_s1sFy
                                              of
                                              { (#,#) ww4_s1sFA [Occ=Once] ww5_s1sFB [Occ=Once] ->
                                                    : [ww4_s1sFA ww5_s1sFB];
                                              };
                                  } in 
                                    GHC.CString.unpackAppendCString#
                                        GHC.Real.$fShowRatio2 sat_s1sFC;
                        } in 
                          case GHC.Show.$w$cshowsPrec4 8# ww1_s1sFp sat_s1sFD of {
                            (#,#) ww4_s1sFF [Occ=Once] ww5_s1sFG [Occ=Once] ->
                                : [ww4_s1sFF ww5_s1sFG];
                          };
              } in  (#,#) [GHC.Show.$fShow(,)4 sat_s1sFH];
        };

GHC.Real.$fShowRatio_$s$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S(SS),1*U(U,U)><L,U>m2,
 Unf=OtherCon []] =
    [] \r [w_s1sFI w1_s1sFJ w2_s1sFK]
        case w_s1sFI of {
          GHC.Types.I# ww1_s1sFM [Occ=Once] ->
              case w1_s1sFJ of {
                GHC.Real.:% ww3_s1sFO [Occ=Once] ww4_s1sFP [Occ=Once] ->
                    case
                        GHC.Real.$w$s$cshowsPrec ww1_s1sFM ww3_s1sFO ww4_s1sFP w2_s1sFK
                    of
                    { (#,#) ww6_s1sFR [Occ=Once] ww7_s1sFS [Occ=Once] ->
                          : [ww6_s1sFR ww7_s1sFS];
                    };
              };
        };

GHC.Real.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> a -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sFT ww_s1sFU ww1_s1sFV ww2_s1sFW]
        let {
          f_s1sFX [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s1sFT ww1_s1sFV] \u []
                  GHC.Show.showsPrec w_s1sFT GHC.Real.ratioPrec1 ww1_s1sFV; } in
        let {
          g1_s1sFY [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s1sFT ww2_s1sFW] \u []
                  GHC.Show.showsPrec w_s1sFT GHC.Real.ratioPrec1 ww2_s1sFW;
        } in 
          case ># [ww_s1sFU 7#] of {
            __DEFAULT ->
                let {
                  sat_s1sG3 [Occ=OnceT[0]] :: GHC.Base.String -> GHC.Base.String
                  [LclId] =
                      [f_s1sFX g1_s1sFY] \r [x_s1sG0]
                          let {
                            sat_s1sG2 [Occ=Once] :: GHC.Base.String
                            [LclId] =
                                [g1_s1sFY x_s1sG0] \u []
                                    let {
                                      sat_s1sG1 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g1_s1sFY x_s1sG0] \u [] g1_s1sFY x_s1sG0;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          GHC.Real.$fShowRatio2 sat_s1sG1;
                          } in  f_s1sFX sat_s1sG2;
                } in  sat_s1sG3;
            1# ->
                let {
                  sat_s1sG9 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s1sFX g1_s1sFY] \r [x_s1sG4]
                          let {
                            sat_s1sG8 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s1sFX g1_s1sFY x_s1sG4] \u []
                                    let {
                                      sat_s1sG7 [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          [g1_s1sFY x_s1sG4] \u []
                                              let {
                                                sat_s1sG6 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_s1sFY x_s1sG4] \u []
                                                        let {
                                                          sat_s1sG5 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_s1sG4];
                                                        } in  g1_s1sFY sat_s1sG5;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    GHC.Real.$fShowRatio2 sat_s1sG6;
                                    } in  f_s1sFX sat_s1sG7;
                          } in  : [GHC.Show.$fShow(,)4 sat_s1sG8];
                } in  sat_s1sG9;
          };

GHC.Real.$fShowRatio_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> GHC.Real.Ratio a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sGa w1_s1sGb w2_s1sGc]
        case w1_s1sGb of {
          GHC.Types.I# ww1_s1sGe [Occ=Once] ->
              case w2_s1sGc of {
                GHC.Real.:% ww3_s1sGg [Occ=Once] ww4_s1sGh [Occ=Once] ->
                    GHC.Real.$w$cshowsPrec w_s1sGa ww1_s1sGe ww3_s1sGg ww4_s1sGh;
              };
        };

GHC.Real.$fShowRatio1
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S(SS),1*U(U,U)><L,U>m2, Unf=OtherCon []] =
    [] \r [w_s1sGi w1_s1sGj]
        case w_s1sGi of {
          GHC.Real.:% ww1_s1sGl [Occ=Once] ww2_s1sGm [Occ=Once] ->
              case GHC.Real.$w$s$cshowsPrec 0# ww1_s1sGl ww2_s1sGm w1_s1sGj of {
                (#,#) ww4_s1sGo [Occ=Once] ww5_s1sGp [Occ=Once] ->
                    : [ww4_s1sGo ww5_s1sGp];
              };
        };

GHC.Real.$fShowRatio_$s$cshowList
  :: [GHC.Real.Ratio GHC.Integer.Type.Integer] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s1sGq s_s1sGr]
        GHC.Show.showList__ GHC.Real.$fShowRatio1 ls_s1sGq s_s1sGr;

GHC.Real.$fShowRatio_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [GHC.Real.Ratio a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s1sGs ls_s1sGt s_s1sGu]
        let {
          sat_s1sGz [Occ=Once] :: GHC.Real.Ratio a_a1ePl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s1sGs] \r [w_s1sGv]
                  case w_s1sGv of {
                    GHC.Real.:% ww1_s1sGx [Occ=Once] ww2_s1sGy [Occ=Once] ->
                        GHC.Real.$w$cshowsPrec $dShow_s1sGs 0# ww1_s1sGx ww2_s1sGy;
                  };
        } in  GHC.Show.showList__ sat_s1sGz ls_s1sGt s_s1sGu;

GHC.Real.$w$s$cshow [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Types.Char, [GHC.Types.Char] #)
[GblId, Arity=2, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1sGA ww1_s1sGB]
        let {
          sat_s1sGG [Occ=Once] :: GHC.Base.String
          [LclId] =
              [ww1_s1sGB] \u []
                  let {
                    sat_s1sGF [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [ww1_s1sGB] \u []
                            case GHC.Show.$w$cshowsPrec4 8# ww1_s1sGB GHC.Types.[] of {
                              (#,#) ww3_s1sGD [Occ=Once] ww4_s1sGE [Occ=Once] ->
                                  : [ww3_s1sGD ww4_s1sGE];
                            };
                  } in 
                    GHC.CString.unpackAppendCString# GHC.Real.$fShowRatio2 sat_s1sGF;
        } in  GHC.Show.$w$cshowsPrec4 8# ww_s1sGA sat_s1sGG;

GHC.Real.$fShowRatio_$s$cshow [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Base.String
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m2, Unf=OtherCon []] =
    [] \r [w_s1sGH]
        case w_s1sGH of {
          GHC.Real.:% ww1_s1sGJ [Occ=Once] ww2_s1sGK [Occ=Once] ->
              case GHC.Real.$w$s$cshow ww1_s1sGJ ww2_s1sGK of {
                (#,#) ww4_s1sGM [Occ=Once] ww5_s1sGN [Occ=Once] ->
                    : [ww4_s1sGM ww5_s1sGN];
              };
        };

GHC.Real.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Show.Show a => a -> a -> GHC.Base.String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sGO ww_s1sGP ww1_s1sGQ]
        let {
          sat_s1sGS [Occ=Once] :: GHC.Base.String
          [LclId] =
              [w_s1sGO ww1_s1sGQ] \u []
                  let {
                    sat_s1sGR [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [w_s1sGO ww1_s1sGQ] \u []
                            GHC.Show.showsPrec
                                w_s1sGO GHC.Real.ratioPrec1 ww1_s1sGQ GHC.Types.[];
                  } in 
                    GHC.CString.unpackAppendCString# GHC.Real.$fShowRatio2 sat_s1sGR;
        } in 
          GHC.Show.showsPrec w_s1sGO GHC.Real.ratioPrec1 ww_s1sGP sat_s1sGS;

GHC.Real.$fShowRatio_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Show.Show a => GHC.Real.Ratio a -> GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sGT w1_s1sGU]
        case w1_s1sGU of {
          GHC.Real.:% ww1_s1sGW [Occ=Once] ww2_s1sGX [Occ=Once] ->
              GHC.Real.$w$cshow w_s1sGT ww1_s1sGW ww2_s1sGX;
        };

GHC.Real.$fShowRatio_$s$fShowRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [GHC.Real.$fShowRatio_$s$cshowsPrec
                                    GHC.Real.$fShowRatio_$s$cshow
                                    GHC.Real.$fShowRatio_$s$cshowList];

GHC.Real.$fShowRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => GHC.Show.Show (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s1sGY]
        let {
          sat_s1sH1 [Occ=Once] :: [GHC.Real.Ratio a_a1ePl] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s1sGY] \r [eta_B2 eta_B1]
                  GHC.Real.$fShowRatio_$cshowList $dShow_s1sGY eta_B2 eta_B1; } in
        let {
          sat_s1sH0 [Occ=Once] :: GHC.Real.Ratio a_a1ePl -> GHC.Base.String
          [LclId] =
              [$dShow_s1sGY] \r [eta_B1]
                  GHC.Real.$fShowRatio_$cshow $dShow_s1sGY eta_B1; } in
        let {
          sat_s1sGZ [Occ=Once]
            :: GHC.Types.Int -> GHC.Real.Ratio a_a1ePl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s1sGY] \r [eta_B2 eta_B1]
                  GHC.Real.$fShowRatio_$cshowsPrec $dShow_s1sGY eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s1sGZ sat_s1sH0 sat_s1sH1];

GHC.Real.$w$slcm [InlPrag=NOINLINE[1]]
  :: GHC.Types.Word -> GHC.Prim.Word# -> GHC.Prim.Word#
[GblId, Arity=2, Str=<L,1*U(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [w_s1sH2 ww_s1sH3]
        case ww_s1sH3 of wild_s1sH4 {
          __DEFAULT ->
              case w_s1sH2 of wild1_s1sH5 {
                GHC.Types.W# x_s1sH6 [Occ=Once!] ->
                    case x_s1sH6 of wild2_s1sH7 {
                      __DEFAULT ->
                          let {
                            sat_s1sH8 [Occ=Once] :: GHC.Types.Word
                            [LclId] =
                                CCCS GHC.Types.W#! [wild_s1sH4];
                          } in 
                            case
                                GHC.Real.gcd GHC.Real.$fIntegralWord wild1_s1sH5 sat_s1sH8
                            of
                            { GHC.Types.W# y#_s1sHa [Occ=Once!] ->
                                  case y#_s1sHa of wild4_s1sHb {
                                    __DEFAULT ->
                                        case quotWord# [wild2_s1sH7 wild4_s1sHb] of wild5_s1sHc {
                                          __DEFAULT -> timesWord# [wild5_s1sHc wild_s1sH4];
                                        };
                                    0## -> GHC.Real.divZeroError;
                                  };
                            };
                      0## -> 0##;
                    };
              };
          0## -> 0##;
        };

GHC.Real.lcm_$slcm [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1sHe w1_s1sHf]
        case w1_s1sHf of {
          GHC.Types.W# ww1_s1sHh [Occ=Once] ->
              case GHC.Real.$w$slcm w_s1sHe ww1_s1sHh of ww2_s1sHi {
                __DEFAULT -> GHC.Types.W# [ww2_s1sHi];
              };
        };

GHC.Real.$w$slcm1 [InlPrag=NOINLINE[1]]
  :: GHC.Types.Int -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Str=<L,1*U(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [w_s1sHj ww_s1sHk]
        case ww_s1sHk of wild_s1sHl {
          __DEFAULT ->
              case w_s1sHj of wild1_s1sHm {
                GHC.Types.I# x_s1sHn [Occ=Once!] ->
                    case x_s1sHn of wild2_s1sHo {
                      __DEFAULT ->
                          let-no-escape {
                            $j_s1sHp [Occ=Once*!T[1], Dmd=<C(S),1*C1(U)>]
                              :: GHC.Prim.Int# -> GHC.Prim.Int#
                            [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                sat-only [wild_s1sHl wild1_s1sHm wild2_s1sHo] \r [ww1_s1sHq]
                                    let {
                                      sat_s1sHt [Occ=Once, Dmd=<L,1*U(U)>] :: GHC.Types.Int
                                      [LclId] =
                                          [wild1_s1sHm wild2_s1sHo] \s []
                                              case >=# [wild2_s1sHo 0#] of {
                                                __DEFAULT ->
                                                    case negateInt# [wild2_s1sHo] of sat_s1sHs {
                                                      __DEFAULT -> GHC.Types.I# [sat_s1sHs];
                                                    };
                                                1# -> wild1_s1sHm;
                                              };
                                    } in 
                                      case GHC.Real.$wgcd' sat_s1sHt ww1_s1sHq of {
                                        GHC.Types.I# x1_s1sHv [Occ=Once!] ->
                                            case x1_s1sHv of wild4_s1sHw {
                                              __DEFAULT ->
                                                  case
                                                      quotInt# [wild2_s1sHo wild4_s1sHw]
                                                  of
                                                  wild5_s1sHx
                                                  { __DEFAULT ->
                                                        case
                                                            *# [wild5_s1sHx wild_s1sHl]
                                                        of
                                                        x2_s1sHy [Dmd=<S,U>]
                                                        { __DEFAULT ->
                                                              case >=# [x2_s1sHy 0#] of {
                                                                __DEFAULT -> negateInt# [x2_s1sHy];
                                                                1# -> x2_s1sHy;
                                                              };
                                                        };
                                                  };
                                              -1# ->
                                                  case wild2_s1sHo of wild5_s1sHA {
                                                    __DEFAULT ->
                                                        case
                                                            quotInt# [wild5_s1sHA -1#]
                                                        of
                                                        sat_s1sHC
                                                        { __DEFAULT ->
                                                              case
                                                                  *# [sat_s1sHC wild_s1sHl]
                                                              of
                                                              x2_s1sHB [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case >=# [x2_s1sHB 0#] of {
                                                                      __DEFAULT ->
                                                                          negateInt# [x2_s1sHB];
                                                                      1# -> x2_s1sHB;
                                                                    };
                                                              };
                                                        };
                                                    -9223372036854775808# -> GHC.Real.overflowError;
                                                  };
                                              0# -> GHC.Real.divZeroError;
                                            };
                                      };
                          } in 
                            case >=# [wild_s1sHl 0#] of {
                              __DEFAULT ->
                                  case negateInt# [wild_s1sHl] of sat_s1sHH {
                                    __DEFAULT -> $j_s1sHp sat_s1sHH;
                                  };
                              1# -> $j_s1sHp wild_s1sHl;
                            };
                      0# -> 0#;
                    };
              };
          0# -> 0#;
        };

GHC.Real.lcm_$slcm1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1sHI w1_s1sHJ]
        case w1_s1sHJ of {
          GHC.Types.I# ww1_s1sHL [Occ=Once] ->
              case GHC.Real.$w$slcm1 w_s1sHI ww1_s1sHL of ww2_s1sHM {
                __DEFAULT -> GHC.Types.I# [ww2_s1sHM];
              };
        };

GHC.Real.lcm [InlPrag=NOINLINE[1]]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(SS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,1*C1(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,1*C1(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sHN eta_s1sHO eta1_s1sHP]
        case
            GHC.Real.$p1Integral $dIntegral_s1sHN
        of
        $dReal_s1sHQ [Dmd=<S(SS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,1*C1(C1(U)),A,1*C1(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1sHQ
              of
              $dNum_s1sHR [Dmd=<S,U(A,A,1*C1(C1(U)),A,1*C1(U),A,C(U))>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p2Real $dReal_s1sHQ
                    of
                    $dOrd_s1sHS [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                    { __DEFAULT ->
                          case
                              GHC.Classes.$p1Ord $dOrd_s1sHS
                          of
                          $dEq_s1sHT [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                          { __DEFAULT ->
                                let {
                                  sat_s1sHU [Occ=Once] :: a_a1epg
                                  [LclId] =
                                      [$dNum_s1sHR] \u []
                                          GHC.Num.fromInteger $dNum_s1sHR GHC.Real.even1;
                                } in 
                                  case GHC.Classes.== $dEq_s1sHT eta1_s1sHP sat_s1sHU of {
                                    GHC.Types.False ->
                                        let {
                                          sat_s1sHW [Occ=Once] :: a_a1epg
                                          [LclId] =
                                              [$dNum_s1sHR] \u []
                                                  GHC.Num.fromInteger $dNum_s1sHR GHC.Real.even1;
                                        } in 
                                          case GHC.Classes.== $dEq_s1sHT eta_s1sHO sat_s1sHW of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_s1sI0 [Occ=Once] :: a_a1epg
                                                  [LclId] =
                                                      [$dIntegral_s1sHN
                                                       eta_s1sHO
                                                       eta1_s1sHP
                                                       $dNum_s1sHR] \u []
                                                          let {
                                                            sat_s1sHZ [Occ=Once] :: a_a1epg
                                                            [LclId] =
                                                                [$dIntegral_s1sHN
                                                                 eta_s1sHO
                                                                 eta1_s1sHP] \u []
                                                                    let {
                                                                      sat_s1sHY [Occ=Once]
                                                                        :: a_a1epg
                                                                      [LclId] =
                                                                          [$dIntegral_s1sHN
                                                                           eta_s1sHO
                                                                           eta1_s1sHP] \u []
                                                                              GHC.Real.gcd
                                                                                  $dIntegral_s1sHN
                                                                                  eta_s1sHO
                                                                                  eta1_s1sHP;
                                                                    } in 
                                                                      GHC.Real.quot
                                                                          $dIntegral_s1sHN
                                                                          eta_s1sHO
                                                                          sat_s1sHY;
                                                          } in 
                                                            GHC.Num.*
                                                                $dNum_s1sHR sat_s1sHZ eta1_s1sHP;
                                                } in  GHC.Num.abs $dNum_s1sHR sat_s1sI0;
                                            GHC.Types.True ->
                                                GHC.Num.fromInteger $dNum_s1sHR GHC.Real.even1;
                                          };
                                    GHC.Types.True ->
                                        GHC.Num.fromInteger $dNum_s1sHR GHC.Real.even1;
                                  };
                          };
                    };
              };
        };

GHC.Real.$w$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => GHC.Types.Int -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sI1 w1_s1sI2]
        case
            GHC.Real.$p1Integral w_s1sI1
        of
        $dReal_s1sI3 [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1sI3
              of
              $dNum_s1sI4 [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
              { __DEFAULT ->
                    let {
                      sat_s1sI7 [Occ=Once] :: GHC.Integer.Type.Integer
                      [LclId] =
                          [w1_s1sI2] \u []
                              case w1_s1sI2 of {
                                GHC.Types.I# i_s1sI6 [Occ=Once] ->
                                    GHC.Integer.Type.smallInteger i_s1sI6;
                              };
                    } in 
                      case GHC.Num.fromInteger $dNum_s1sI4 sat_s1sI7 of dt_s1sI8 {
                        __DEFAULT ->
                            case
                                GHC.Num.fromInteger $dNum_s1sI4 GHC.Real.$fEnumRatio1
                            of
                            dt1_s1sI9
                            { __DEFAULT -> (#,#) [dt_s1sI8 dt1_s1sI9];
                            };
                      };
              };
        };

GHC.Real.$fEnumRatio_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Types.Int -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1sIa w1_s1sIb]
        case GHC.Real.$w$ctoEnum w_s1sIa w1_s1sIb of {
          (#,#) ww1_s1sId [Occ=Once] ww2_s1sIe [Occ=Once] ->
              GHC.Real.:% [ww1_s1sId ww2_s1sIe];
        };

GHC.Real.$fEnumRatio_$s$fEnumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Enum.Enum (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Enum! [GHC.Real.$fEnumRatio_$s$csucc
                                    GHC.Real.$fEnumRatio_$s$cpred
                                    GHC.Real.$fEnumRatio_$ctoRational
                                    GHC.Real.$fEnumRatio_$s$cfromEnum
                                    GHC.Real.$fEnumRatio_$snumericEnumFrom
                                    GHC.Real.$fEnumRatio_$snumericEnumFromThen
                                    GHC.Real.$fEnumRatio_$snumericEnumFromTo
                                    GHC.Real.$fEnumRatio_$snumericEnumFromThenTo];

GHC.Real.$fEnumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Enum.Enum (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,A))),A,C(U))>m] =
    [] \r [$dIntegral_s1sIf]
        let {
          sat_s1sIn [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0
               -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1sIf] \u []
                  GHC.Real.$fEnumRatio_$cenumFromThenTo $dIntegral_s1sIf; } in
        let {
          sat_s1sIm [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1sIf] \u []
                  GHC.Real.$fEnumRatio_$cenumFromTo $dIntegral_s1sIf; } in
        let {
          sat_s1sIl [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1sIf] \u []
                  GHC.Real.$fEnumRatio_$cenumFromThen $dIntegral_s1sIf; } in
        let {
          sat_s1sIk [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1sIf] \u []
                  GHC.Real.$fEnumRatio_$cenumFrom $dIntegral_s1sIf; } in
        let {
          sat_s1sIj [Occ=Once] :: GHC.Real.Ratio a_a1eE0 -> GHC.Types.Int
          [LclId] =
              [$dIntegral_s1sIf] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$cfromEnum $dIntegral_s1sIf eta_B1; } in
        let {
          sat_s1sIi [Occ=Once] :: GHC.Types.Int -> GHC.Real.Ratio a_a1eE0
          [LclId] =
              [$dIntegral_s1sIf] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$ctoEnum $dIntegral_s1sIf eta_B1; } in
        let {
          sat_s1sIh [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0 -> GHC.Real.Ratio a_a1eE0
          [LclId] =
              [$dIntegral_s1sIf] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$cpred $dIntegral_s1sIf eta_B1; } in
        let {
          sat_s1sIg [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0 -> GHC.Real.Ratio a_a1eE0
          [LclId] =
              [$dIntegral_s1sIf] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$csucc $dIntegral_s1sIf eta_B1;
        } in 
          GHC.Enum.C:Enum [sat_s1sIg
                           sat_s1sIh
                           sat_s1sIi
                           sat_s1sIj
                           sat_s1sIk
                           sat_s1sIl
                           sat_s1sIm
                           sat_s1sIn];

$wg_r1j3P
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><S,U><S,U>,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s1sIo ww1_s1sIp ww2_s1sIq]
        case remInt# [ww1_s1sIp 2#] of {
          __DEFAULT ->
              case ww1_s1sIp of wild1_s1sIs {
                __DEFAULT ->
                    case *# [ww_s1sIo ww2_s1sIq] of sat_s1sIv {
                      __DEFAULT ->
                          case quotInt# [wild1_s1sIs 2#] of sat_s1sIu {
                            __DEFAULT ->
                                case *# [ww_s1sIo ww_s1sIo] of sat_s1sIt {
                                  __DEFAULT -> $wg_r1j3P sat_s1sIt sat_s1sIu sat_s1sIv;
                                };
                          };
                    };
                1# -> *# [ww_s1sIo ww2_s1sIq];
              };
          0# ->
              case quotInt# [ww1_s1sIp 2#] of sat_s1sIx {
                __DEFAULT ->
                    case *# [ww_s1sIo ww_s1sIo] of sat_s1sIw {
                      __DEFAULT -> $wg_r1j3P sat_s1sIw sat_s1sIx ww2_s1sIq;
                    };
              };
        };

GHC.Real.$wf1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1sIy ww1_s1sIz]
        case remInt# [ww1_s1sIz 2#] of {
          __DEFAULT ->
              case ww1_s1sIz of wild1_s1sIB {
                __DEFAULT ->
                    case quotInt# [wild1_s1sIB 2#] of sat_s1sID {
                      __DEFAULT ->
                          case *# [ww_s1sIy ww_s1sIy] of sat_s1sIC {
                            __DEFAULT -> $wg_r1j3P sat_s1sIC sat_s1sID ww_s1sIy;
                          };
                    };
                1# -> ww_s1sIy;
              };
          0# ->
              case quotInt# [ww1_s1sIz 2#] of sat_s1sIF {
                __DEFAULT ->
                    case *# [ww_s1sIy ww_s1sIy] of sat_s1sIE {
                      __DEFAULT -> GHC.Real.$wf1 sat_s1sIE sat_s1sIF;
                    };
              };
        };

GHC.Real.^_f2 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1sIG w1_s1sIH]
        case w_s1sIG of {
          GHC.Types.I# ww1_s1sIJ [Occ=Once] ->
              case w1_s1sIH of {
                GHC.Types.I# ww3_s1sIL [Occ=Once] ->
                    case GHC.Real.$wf1 ww1_s1sIJ ww3_s1sIL of ww4_s1sIM {
                      __DEFAULT -> GHC.Types.I# [ww4_s1sIM];
                    };
              };
        };

GHC.Real.^3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

GHC.Real.^2 :: GHC.Types.Int
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1sIN {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1sIN;
        };

GHC.Real.^_$s^2 [InlPrag=NOUSERINLINE[1]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [x0_s1sIO y0_s1sIP]
        case y0_s1sIP of {
          GHC.Types.I# x_s1sIR ->
              case <# [x_s1sIR 0#] of {
                __DEFAULT ->
                    case x_s1sIR of wild1_s1sIT {
                      __DEFAULT ->
                          case x0_s1sIO of {
                            GHC.Types.I# ww1_s1sIV [Occ=Once] ->
                                case GHC.Real.$wf1 ww1_s1sIV wild1_s1sIT of ww2_s1sIW {
                                  __DEFAULT -> GHC.Types.I# [ww2_s1sIW];
                                };
                          };
                      0# -> GHC.Real.^3;
                    };
                1# -> GHC.Real.^2;
              };
        };

$wg1_r1j3Q
  :: GHC.Integer.Type.Integer
     -> GHC.Prim.Int#
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
[GblId, Arity=3, Str=<S,U><S,U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_s1sIX ww_s1sIY w1_s1sIZ]
        case remInt# [ww_s1sIY 2#] of {
          __DEFAULT ->
              case ww_s1sIY of wild1_s1sJ1 {
                __DEFAULT ->
                    case GHC.Integer.Type.timesInteger w_s1sIX w1_s1sIZ of sat_s1sJ4 {
                      __DEFAULT ->
                          case quotInt# [wild1_s1sJ1 2#] of sat_s1sJ3 {
                            __DEFAULT ->
                                case GHC.Integer.Type.timesInteger w_s1sIX w_s1sIX of sat_s1sJ2 {
                                  __DEFAULT -> $wg1_r1j3Q sat_s1sJ2 sat_s1sJ3 sat_s1sJ4;
                                };
                          };
                    };
                1# -> GHC.Integer.Type.timesInteger w_s1sIX w1_s1sIZ;
              };
          0# ->
              case quotInt# [ww_s1sIY 2#] of sat_s1sJ6 {
                __DEFAULT ->
                    case GHC.Integer.Type.timesInteger w_s1sIX w_s1sIX of sat_s1sJ5 {
                      __DEFAULT -> $wg1_r1j3Q sat_s1sJ5 sat_s1sJ6 w1_s1sIZ;
                    };
              };
        };

GHC.Real.$wf [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Prim.Int# -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [w_s1sJ7 ww_s1sJ8]
        case remInt# [ww_s1sJ8 2#] of {
          __DEFAULT ->
              case ww_s1sJ8 of wild1_s1sJa {
                __DEFAULT ->
                    case quotInt# [wild1_s1sJa 2#] of sat_s1sJc {
                      __DEFAULT ->
                          case GHC.Integer.Type.timesInteger w_s1sJ7 w_s1sJ7 of sat_s1sJb {
                            __DEFAULT -> $wg1_r1j3Q sat_s1sJb sat_s1sJc w_s1sJ7;
                          };
                    };
                1# -> w_s1sJ7;
              };
          0# ->
              case quotInt# [ww_s1sJ8 2#] of sat_s1sJe {
                __DEFAULT ->
                    case GHC.Integer.Type.timesInteger w_s1sJ7 w_s1sJ7 of sat_s1sJd {
                      __DEFAULT -> GHC.Real.$wf sat_s1sJd sat_s1sJe;
                    };
              };
        };

GHC.Real.^_f1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [w_s1sJf w1_s1sJg]
        case w1_s1sJg of {
          GHC.Types.I# ww1_s1sJi [Occ=Once] ->
              GHC.Real.$wf w_s1sJf ww1_s1sJi;
        };

GHC.Real.^_$s^1 [InlPrag=NOUSERINLINE[1]]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<L,U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x0_s1sJj y0_s1sJk]
        case y0_s1sJk of {
          GHC.Types.I# x_s1sJm ->
              case <# [x_s1sJm 0#] of {
                __DEFAULT ->
                    case x_s1sJm of wild1_s1sJo {
                      __DEFAULT -> GHC.Real.$wf x0_s1sJj wild1_s1sJo;
                      0# -> GHC.Real.$fEnumRatio1;
                    };
                1# -> GHC.Real.^1;
              };
        };

lvl6_r1j3R :: GHC.Real.Rational
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1sJp {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1sJp;
        };

lvl7_r1j3S :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1sJq {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1sJq;
        };

GHC.Real.^ [InlPrag=INLINABLE[1]]
  :: forall a b. (GHC.Num.Num a, GHC.Real.Integral b) => a -> b -> a
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))><S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s1sJr $dIntegral_s1sJs eta_s1sJt eta1_s1sJu]
        case
            GHC.Real.$p1Integral $dIntegral_s1sJs
        of
        $dReal_s1sJv [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum1_s1sJw [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num b_a1eqq
                [LclId] =
                    [$dReal_s1sJv] \u [] GHC.Real.$p1Real $dReal_s1sJv;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1sJv
                of
                $dOrd_s1sJx [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1sJy [Occ=Once] :: b_a1eqq
                        [LclId] =
                            [$dNum1_s1sJw] \u []
                                GHC.Num.fromInteger $dNum1_s1sJw GHC.Real.even1;
                      } in 
                        case GHC.Classes.< $dOrd_s1sJx eta1_s1sJu sat_s1sJy of {
                          GHC.Types.False ->
                              let {
                                sat_s1sJB [Occ=Once] :: b_a1eqq
                                [LclId] =
                                    [$dNum1_s1sJw] \u []
                                        GHC.Num.fromInteger $dNum1_s1sJw GHC.Real.even1;
                              } in 
                                case GHC.Classes.$p1Ord $dOrd_s1sJx of sat_s1sJA {
                                  __DEFAULT ->
                                      case GHC.Classes.== sat_s1sJA eta1_s1sJu sat_s1sJB of {
                                        GHC.Types.False ->
                                            let {
                                              lvl8_s1sJD :: b_a1eqq
                                              [LclId] =
                                                  [$dNum1_s1sJw] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum1_s1sJw GHC.Real.even2;
                                            } in 
                                              let-no-escape {
                                                exit_s1sJE [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                                  :: a_a1eqp -> b_a1eqq -> a_a1eqp
                                                [LclId[JoinId(2)],
                                                 Arity=2,
                                                 Str=<L,U><L,U>,
                                                 Unf=OtherCon []] =
                                                    sat-only [$dNum_s1sJr
                                                              $dIntegral_s1sJs
                                                              $dNum1_s1sJw
                                                              $dOrd_s1sJx
                                                              lvl8_s1sJD] \r [x_s1sJF y_s1sJG]
                                                        case
                                                            GHC.Classes.$p1Ord $dOrd_s1sJx
                                                        of
                                                        $dEq_s1sJH [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                                        { __DEFAULT ->
                                                              let {
                                                                lvl9_s1sJI :: b_a1eqq
                                                                [LclId] =
                                                                    [$dNum1_s1sJw] \u []
                                                                        GHC.Num.fromInteger
                                                                            $dNum1_s1sJw
                                                                            GHC.Real.$fEnumRatio1;
                                                              } in 
                                                                case
                                                                    GHC.Classes.==
                                                                        $dEq_s1sJH
                                                                        y_s1sJG
                                                                        lvl9_s1sJI
                                                                of
                                                                { GHC.Types.False ->
                                                                      let {
                                                                        sat_s1sJZ [Occ=Once]
                                                                          :: b_a1eqq
                                                                        [LclId] =
                                                                            [$dIntegral_s1sJs
                                                                             lvl8_s1sJD
                                                                             y_s1sJG] \u []
                                                                                GHC.Real.quot
                                                                                    $dIntegral_s1sJs
                                                                                    y_s1sJG
                                                                                    lvl8_s1sJD; } in
                                                                      let {
                                                                        sat_s1sJY [Occ=Once]
                                                                          :: a_a1eqp
                                                                        [LclId] =
                                                                            [$dNum_s1sJr
                                                                             x_s1sJF] \u []
                                                                                GHC.Num.*
                                                                                    $dNum_s1sJr
                                                                                    x_s1sJF
                                                                                    x_s1sJF;
                                                                      } in 
                                                                        let-no-escape {
                                                                          exit1_s1sJK [Occ=OnceL!T[2],
                                                                                       Dmd=<C(C(S)),C(C1(U))>]
                                                                            :: a_a1eqp
                                                                               -> a_a1eqp -> a_a1eqp
                                                                          [LclId[JoinId(2)],
                                                                           Arity=2,
                                                                           Str=<L,U><L,U>,
                                                                           Unf=OtherCon []] =
                                                                              sat-only [$dNum_s1sJr] \r [x1_s1sJL
                                                                                                         z_s1sJM]
                                                                                  GHC.Num.*
                                                                                      $dNum_s1sJr
                                                                                      x1_s1sJL
                                                                                      z_s1sJM;
                                                                        } in 
                                                                          let-no-escape {
                                                                            g1_s1sJN [Occ=LoopBreakerT[3]]
                                                                              :: a_a1eqp
                                                                                 -> b_a1eqq
                                                                                 -> a_a1eqp
                                                                                 -> a_a1eqp
                                                                            [LclId[JoinId(3)],
                                                                             Arity=3,
                                                                             Str=<L,U><L,U><L,U>,
                                                                             Unf=OtherCon []] =
                                                                                sat-only [$dNum_s1sJr
                                                                                          $dIntegral_s1sJs
                                                                                          lvl8_s1sJD
                                                                                          $dEq_s1sJH
                                                                                          lvl9_s1sJI
                                                                                          exit1_s1sJK
                                                                                          g1_s1sJN] \r [x1_s1sJO
                                                                                                        y1_s1sJP
                                                                                                        z_s1sJQ]
                                                                                    case
                                                                                        GHC.Real.even
                                                                                            $dIntegral_s1sJs
                                                                                            y1_s1sJP
                                                                                    of
                                                                                    { GHC.Types.False ->
                                                                                          case
                                                                                              GHC.Classes.==
                                                                                                  $dEq_s1sJH
                                                                                                  y1_s1sJP
                                                                                                  lvl9_s1sJI
                                                                                          of
                                                                                          { GHC.Types.False ->
                                                                                                let {
                                                                                                  sat_s1sJV [Occ=Once]
                                                                                                    :: a_a1eqp
                                                                                                  [LclId] =
                                                                                                      [$dNum_s1sJr
                                                                                                       x1_s1sJO
                                                                                                       z_s1sJQ] \u []
                                                                                                          GHC.Num.*
                                                                                                              $dNum_s1sJr
                                                                                                              x1_s1sJO
                                                                                                              z_s1sJQ; } in
                                                                                                let {
                                                                                                  sat_s1sJU [Occ=Once]
                                                                                                    :: b_a1eqq
                                                                                                  [LclId] =
                                                                                                      [$dIntegral_s1sJs
                                                                                                       lvl8_s1sJD
                                                                                                       y1_s1sJP] \u []
                                                                                                          GHC.Real.quot
                                                                                                              $dIntegral_s1sJs
                                                                                                              y1_s1sJP
                                                                                                              lvl8_s1sJD; } in
                                                                                                let {
                                                                                                  sat_s1sJT [Occ=Once]
                                                                                                    :: a_a1eqp
                                                                                                  [LclId] =
                                                                                                      [$dNum_s1sJr
                                                                                                       x1_s1sJO] \u []
                                                                                                          GHC.Num.*
                                                                                                              $dNum_s1sJr
                                                                                                              x1_s1sJO
                                                                                                              x1_s1sJO;
                                                                                                } in 
                                                                                                  g1_s1sJN
                                                                                                      sat_s1sJT
                                                                                                      sat_s1sJU
                                                                                                      sat_s1sJV;
                                                                                            GHC.Types.True ->
                                                                                                exit1_s1sJK
                                                                                                    x1_s1sJO
                                                                                                    z_s1sJQ;
                                                                                          };
                                                                                      GHC.Types.True ->
                                                                                          let {
                                                                                            sat_s1sJX [Occ=Once]
                                                                                              :: b_a1eqq
                                                                                            [LclId] =
                                                                                                [$dIntegral_s1sJs
                                                                                                 lvl8_s1sJD
                                                                                                 y1_s1sJP] \u []
                                                                                                    GHC.Real.quot
                                                                                                        $dIntegral_s1sJs
                                                                                                        y1_s1sJP
                                                                                                        lvl8_s1sJD; } in
                                                                                          let {
                                                                                            sat_s1sJW [Occ=Once]
                                                                                              :: a_a1eqp
                                                                                            [LclId] =
                                                                                                [$dNum_s1sJr
                                                                                                 x1_s1sJO] \u []
                                                                                                    GHC.Num.*
                                                                                                        $dNum_s1sJr
                                                                                                        x1_s1sJO
                                                                                                        x1_s1sJO;
                                                                                          } in 
                                                                                            g1_s1sJN
                                                                                                sat_s1sJW
                                                                                                sat_s1sJX
                                                                                                z_s1sJQ;
                                                                                    };
                                                                          } in 
                                                                            g1_s1sJN
                                                                                sat_s1sJY
                                                                                sat_s1sJZ
                                                                                x_s1sJF;
                                                                  GHC.Types.True -> x_s1sJF;
                                                                };
                                                        };
                                              } in 
                                                let-no-escape {
                                                  f_s1sK0 [Occ=LoopBreakerT[2]]
                                                    :: a_a1eqp -> b_a1eqq -> a_a1eqp
                                                  [LclId[JoinId(2)],
                                                   Arity=2,
                                                   Str=<L,U><L,U>,
                                                   Unf=OtherCon []] =
                                                      sat-only [$dNum_s1sJr
                                                                $dIntegral_s1sJs
                                                                lvl8_s1sJD
                                                                exit_s1sJE
                                                                f_s1sK0] \r [x_s1sK1 y_s1sK2]
                                                          case
                                                              GHC.Real.even $dIntegral_s1sJs y_s1sK2
                                                          of
                                                          { GHC.Types.False ->
                                                                exit_s1sJE x_s1sK1 y_s1sK2;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_s1sK5 [Occ=Once] :: b_a1eqq
                                                                  [LclId] =
                                                                      [$dIntegral_s1sJs
                                                                       lvl8_s1sJD
                                                                       y_s1sK2] \u []
                                                                          GHC.Real.quot
                                                                              $dIntegral_s1sJs
                                                                              y_s1sK2
                                                                              lvl8_s1sJD; } in
                                                                let {
                                                                  sat_s1sK4 [Occ=Once] :: a_a1eqp
                                                                  [LclId] =
                                                                      [$dNum_s1sJr x_s1sK1] \u []
                                                                          GHC.Num.*
                                                                              $dNum_s1sJr
                                                                              x_s1sK1
                                                                              x_s1sK1;
                                                                } in  f_s1sK0 sat_s1sK4 sat_s1sK5;
                                                          };
                                                } in  f_s1sK0 eta_s1sJt eta1_s1sJu;
                                        GHC.Types.True ->
                                            GHC.Num.fromInteger $dNum_s1sJr GHC.Real.$fEnumRatio1;
                                      };
                                };
                          GHC.Types.True -> lvl7_r1j3S;
                        };
                };
        };
GHC.Real.^%^ [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Rational -> a -> GHC.Real.Rational
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1sK6 w1_s1sK7 w2_s1sK8]
        case w1_s1sK7 of {
          GHC.Real.:% ww1_s1sKa [Occ=Once] ww2_s1sKb [Occ=Once] ->
              case GHC.Real.$w^%^ w_s1sK6 ww1_s1sKa ww2_s1sKb w2_s1sK8 of {
                (#,#) ww4_s1sKd [Occ=Once] ww5_s1sKe [Occ=Once] ->
                    GHC.Real.:% [ww4_s1sKd ww5_s1sKe];
              };
        };
GHC.Real.$w^%^ [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> a
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sKf ww_s1sKg ww1_s1sKh w1_s1sKi]
        case
            GHC.Real.$p1Integral w_s1sKf
        of
        $dReal_s1sKj [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1sKk [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_s1hK5
                [LclId] =
                    [$dReal_s1sKj] \u [] GHC.Real.$p1Real $dReal_s1sKj;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1sKj
                of
                $dOrd_s1sKl [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1sKm [Occ=Once] :: a_s1hK5
                        [LclId] =
                            [$dNum_s1sKk] \u [] GHC.Num.fromInteger $dNum_s1sKk GHC.Real.even1;
                      } in 
                        case GHC.Classes.< $dOrd_s1sKl w1_s1sKi sat_s1sKm of {
                          GHC.Types.False ->
                              let {
                                sat_s1sKp [Occ=Once] :: a_s1hK5
                                [LclId] =
                                    [$dNum_s1sKk] \u []
                                        GHC.Num.fromInteger $dNum_s1sKk GHC.Real.even1;
                              } in 
                                case GHC.Classes.$p1Ord $dOrd_s1sKl of sat_s1sKo {
                                  __DEFAULT ->
                                      case GHC.Classes.== sat_s1sKo w1_s1sKi sat_s1sKp of {
                                        GHC.Types.False ->
                                            case
                                                GHC.Real.^
                                                    GHC.Num.$fNumInteger w_s1sKf ww_s1sKg w1_s1sKi
                                            of
                                            dt_s1sKr
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Real.^
                                                          GHC.Num.$fNumInteger
                                                          w_s1sKf
                                                          ww1_s1sKh
                                                          w1_s1sKi
                                                  of
                                                  dt1_s1sKs
                                                  { __DEFAULT -> (#,#) [dt_s1sKr dt1_s1sKs];
                                                  };
                                            };
                                        GHC.Types.True ->
                                            (#,#) [GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1];
                                      };
                                };
                          GHC.Types.True -> lvl6_r1j3R;
                        };
                };
        };

GHC.Real.$w^^%^^ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> a
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId,
 Arity=4,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLLLL),U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,1*C1(C1(U)),A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sKu ww_s1sKv ww1_s1sKw w1_s1sKx]
        case
            GHC.Real.$p1Integral w_s1sKu
        of
        $dReal_s1sKy [Dmd=<S(LS(LLLLC(C(S))LLL)L),U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,1*C1(C1(U)),A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1sKz [Dmd=<L,U(A,A,A,C(U),A,A,C(U))>] :: GHC.Num.Num a_s1hKi
                [LclId] =
                    [$dReal_s1sKy] \u [] GHC.Real.$p1Real $dReal_s1sKy;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1sKy
                of
                $dOrd_s1sKA [Dmd=<S(LLLLC(C(S))LLL),U(1*U(1*C1(C1(U)),A),A,A,A,1*C1(C1(U)),A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1sKB [Occ=Once] :: a_s1hKi
                        [LclId] =
                            [$dNum_s1sKz] \u [] GHC.Num.fromInteger $dNum_s1sKz GHC.Real.even1;
                      } in 
                        case GHC.Classes.> $dOrd_s1sKA w1_s1sKx sat_s1sKB of {
                          GHC.Types.False ->
                              let {
                                sat_s1sKE [Occ=Once] :: a_s1hKi
                                [LclId] =
                                    [$dNum_s1sKz] \u []
                                        GHC.Num.fromInteger $dNum_s1sKz GHC.Real.even1;
                              } in 
                                case GHC.Classes.$p1Ord $dOrd_s1sKA of sat_s1sKD {
                                  __DEFAULT ->
                                      case GHC.Classes.== sat_s1sKD w1_s1sKx sat_s1sKE of {
                                        GHC.Types.False ->
                                            case
                                                GHC.Integer.Type.gtInteger# ww_s1sKv GHC.Real.even1
                                            of
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.eqInteger#
                                                          ww_s1sKv GHC.Real.even1
                                                  of
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_s1sKK [Occ=Once] :: a_s1hKi
                                                          [LclId] =
                                                              [w1_s1sKx $dNum_s1sKz] \u []
                                                                  GHC.Num.negate
                                                                      $dNum_s1sKz w1_s1sKx; } in
                                                        let {
                                                          sat_s1sKJ [Occ=Once]
                                                            :: GHC.Integer.Type.Integer
                                                          [LclId] =
                                                              [ww_s1sKv] \u []
                                                                  GHC.Integer.Type.negateInteger
                                                                      ww_s1sKv;
                                                        } in 
                                                          case
                                                              GHC.Real.^
                                                                  GHC.Num.$fNumInteger
                                                                  w_s1sKu
                                                                  sat_s1sKJ
                                                                  sat_s1sKK
                                                          of
                                                          dd_s1sKI [Dmd=<S,1*U>]
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1sKM [Occ=Once] :: a_s1hKi
                                                                  [LclId] =
                                                                      [w1_s1sKx $dNum_s1sKz] \u []
                                                                          GHC.Num.negate
                                                                              $dNum_s1sKz w1_s1sKx;
                                                                } in 
                                                                  case
                                                                      GHC.Real.^
                                                                          GHC.Num.$fNumInteger
                                                                          w_s1sKu
                                                                          ww1_s1sKw
                                                                          sat_s1sKM
                                                                  of
                                                                  nn_s1sKL [Dmd=<S,1*U>]
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Real.even
                                                                                w_s1sKu w1_s1sKx
                                                                        of
                                                                        { GHC.Types.False ->
                                                                              case
                                                                                  GHC.Integer.Type.negateInteger
                                                                                      nn_s1sKL
                                                                              of
                                                                              dt_s1sKO
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        dd_s1sKI
                                                                                    of
                                                                                    dt1_s1sKP
                                                                                    { __DEFAULT ->
                                                                                          (#,#) [dt_s1sKO
                                                                                                 dt1_s1sKP];
                                                                                    };
                                                                              };
                                                                          GHC.Types.True ->
                                                                              case
                                                                                  nn_s1sKL
                                                                              of
                                                                              dt_s1sKQ
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        dd_s1sKI
                                                                                    of
                                                                                    dt1_s1sKR
                                                                                    { __DEFAULT ->
                                                                                          (#,#) [dt_s1sKQ
                                                                                                 dt1_s1sKR];
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                          };
                                                    1# -> GHC.Real.ratioZeroDenominatorError;
                                                  };
                                              1# ->
                                                  let {
                                                    sat_s1sKT [Occ=Once] :: a_s1hKi
                                                    [LclId] =
                                                        [w1_s1sKx $dNum_s1sKz] \u []
                                                            GHC.Num.negate $dNum_s1sKz w1_s1sKx;
                                                  } in 
                                                    case
                                                        GHC.Real.^
                                                            GHC.Num.$fNumInteger
                                                            w_s1sKu
                                                            ww1_s1sKw
                                                            sat_s1sKT
                                                    of
                                                    dt_s1sKU
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_s1sKV [Occ=Once] :: a_s1hKi
                                                            [LclId] =
                                                                [w1_s1sKx $dNum_s1sKz] \u []
                                                                    GHC.Num.negate
                                                                        $dNum_s1sKz w1_s1sKx;
                                                          } in 
                                                            case
                                                                GHC.Real.^
                                                                    GHC.Num.$fNumInteger
                                                                    w_s1sKu
                                                                    ww_s1sKv
                                                                    sat_s1sKV
                                                            of
                                                            dt1_s1sKW
                                                            { __DEFAULT ->
                                                                  (#,#) [dt_s1sKU dt1_s1sKW];
                                                            };
                                                    };
                                            };
                                        GHC.Types.True ->
                                            (#,#) [GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1];
                                      };
                                };
                          GHC.Types.True ->
                              case
                                  GHC.Real.^ GHC.Num.$fNumInteger w_s1sKu ww_s1sKv w1_s1sKx
                              of
                              dt_s1sKX
                              { __DEFAULT ->
                                    case
                                        GHC.Real.^ GHC.Num.$fNumInteger w_s1sKu ww1_s1sKw w1_s1sKx
                                    of
                                    dt1_s1sKY
                                    { __DEFAULT -> (#,#) [dt_s1sKX dt1_s1sKY];
                                    };
                              };
                        };
                };
        };

GHC.Real.^^%^^ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Rational -> a -> GHC.Real.Rational
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLLLL),U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,C(C1(U)),A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1sKZ w1_s1sL0 w2_s1sL1]
        case w1_s1sL0 of {
          GHC.Real.:% ww1_s1sL3 [Occ=Once] ww2_s1sL4 [Occ=Once] ->
              case GHC.Real.$w^^%^^ w_s1sKZ ww1_s1sL3 ww2_s1sL4 w2_s1sL1 of {
                (#,#) ww4_s1sL6 [Occ=Once] ww5_s1sL7 [Occ=Once] ->
                    GHC.Real.:% [ww4_s1sL6 ww5_s1sL7];
              };
        };

GHC.Real.^^ [InlPrag=INLINABLE[1]]
  :: forall a b.
     (GHC.Real.Fractional a, GHC.Real.Integral b) =>
     a -> b -> a
[GblId,
 Arity=4,
 Str=<L,U(1*U(A,A,C(C1(U)),A,A,A,1*C1(U)),A,1*C1(U),A)><S(S(LS(LLLLLC(C(S))LL)L)LLLLLLLL),U(U(U(A,A,A,1*C1(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,1*C1(C1(U)),A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_s1sL8 $dIntegral_s1sL9 eta_s1sLa eta1_s1sLb]
        case
            GHC.Real.$p1Integral $dIntegral_s1sL9
        of
        $dReal_s1sLc [Dmd=<S(LS(LLLLLC(C(S))LL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,A,A,A,1*C1(C1(U)),A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1sLd [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>]
                  :: GHC.Num.Num b_a1etw
                [LclId] =
                    [$dReal_s1sLc] \u [] GHC.Real.$p1Real $dReal_s1sLc; } in
              let {
                sat_s1sLf [Occ=Once] :: b_a1etw
                [LclId] =
                    [$dNum_s1sLd] \u [] GHC.Num.fromInteger $dNum_s1sLd GHC.Real.even1;
              } in 
                case GHC.Real.$p2Real $dReal_s1sLc of sat_s1sLe {
                  __DEFAULT ->
                      case GHC.Classes.>= sat_s1sLe eta1_s1sLb sat_s1sLf of {
                        GHC.Types.False ->
                            let {
                              sat_s1sLj [Occ=Once] :: a_a1etv
                              [LclId] =
                                  [$dFractional_s1sL8
                                   $dIntegral_s1sL9
                                   eta_s1sLa
                                   eta1_s1sLb
                                   $dNum_s1sLd] \u []
                                      let {
                                        sat_s1sLi [Occ=Once] :: b_a1etw
                                        [LclId] =
                                            [eta1_s1sLb $dNum_s1sLd] \u []
                                                GHC.Num.negate $dNum_s1sLd eta1_s1sLb; } in
                                      let {
                                        sat_s1sLh [Occ=Once, Dmd=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>]
                                          :: GHC.Num.Num a_a1etv
                                        [LclId] =
                                            [$dFractional_s1sL8] \u []
                                                GHC.Real.$p1Fractional $dFractional_s1sL8;
                                      } in 
                                        GHC.Real.^ sat_s1sLh $dIntegral_s1sL9 eta_s1sLa sat_s1sLi;
                            } in  GHC.Real.recip $dFractional_s1sL8 sat_s1sLj;
                        GHC.Types.True ->
                            let {
                              sat_s1sLk [Occ=Once, Dmd=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>]
                                :: GHC.Num.Num a_a1etv
                              [LclId] =
                                  [$dFractional_s1sL8] \u []
                                      GHC.Real.$p1Fractional $dFractional_s1sL8;
                            } in  GHC.Real.^ sat_s1sLk $dIntegral_s1sL9 eta_s1sLa eta1_s1sLb;
                      };
                };
        };

GHC.Real.C:Fractional
  :: forall a.
     GHC.Num.Num a =>
     (a -> a -> a)
     -> (a -> a) -> (GHC.Real.Rational -> a) -> GHC.Real.Fractional a
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Real.C:Fractional [eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Real.C:Integral
  :: forall a.
     (GHC.Real.Real a, GHC.Enum.Enum a) =>
     (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> (a, a))
     -> (a -> a -> (a, a))
     -> (a -> GHC.Integer.Type.Integer)
     -> GHC.Real.Integral a
[GblId[DataCon],
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B9
           eta_B8
           eta_B7
           eta_B6
           eta_B5
           eta_B4
           eta_B3
           eta_B2
           eta_B1]
        GHC.Real.C:Integral [eta_B9
                             eta_B8
                             eta_B7
                             eta_B6
                             eta_B5
                             eta_B4
                             eta_B3
                             eta_B2
                             eta_B1];

GHC.Real.C:Real
  :: forall a.
     (GHC.Num.Num a, GHC.Classes.Ord a) =>
     (a -> GHC.Real.Rational) -> GHC.Real.Real a
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Real.C:Real [eta_B3 eta_B2 eta_B1];

GHC.Real.C:RealFrac
  :: forall a.
     (GHC.Real.Real a, GHC.Real.Fractional a) =>
     (forall b. GHC.Real.Integral b => a -> (b, a))
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> GHC.Real.RealFrac a
[GblId[DataCon],
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Real.C:RealFrac [eta_B7
                             eta_B6
                             eta_B5
                             eta_B4
                             eta_B3
                             eta_B2
                             eta_B1];

GHC.Real.:% :: forall a. a -> a -> GHC.Real.Ratio a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Real.:% [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 15:56:15.812317734 UTC

GHC.Real.$p1Fractional
  :: forall a. GHC.Real.Fractional a => GHC.Num.Num a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_s1saL]
        case v_s1saL of {
          GHC.Real.C:Fractional v_s1saN [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_s1saN;
        };

GHC.Real./ :: forall a. GHC.Real.Fractional a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_s1saR]
        case v_s1saR of {
          GHC.Real.C:Fractional _ [Occ=Dead]
                                v_s1saU [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_s1saU;
        };

GHC.Real.recip :: forall a. GHC.Real.Fractional a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_s1saX]
        case v_s1saX of {
          GHC.Real.C:Fractional _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_s1sb1 [Occ=Once]
                                _ [Occ=Dead] ->
              v_s1sb1;
        };

GHC.Real.fromRational
  :: forall a. GHC.Real.Fractional a => GHC.Real.Rational -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_s1sb3]
        case v_s1sb3 of {
          GHC.Real.C:Fractional _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_s1sb8 [Occ=Once] ->
              v_s1sb8;
        };

GHC.Real.$p1Integral
  :: forall a. GHC.Real.Integral a => GHC.Real.Real a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLL),U(U,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1sb9]
        case v_s1sb9 of {
          GHC.Real.C:Integral v_s1sbb [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sbb;
        };

GHC.Real.$p2Integral
  :: forall a. GHC.Real.Integral a => GHC.Enum.Enum a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLL),U(A,U,A,A,A,A,A,A,A)>] =
    [] \r [v_s1sbk]
        case v_s1sbk of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              v_s1sbn [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sbn;
        };

GHC.Real.quot :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLL),U(A,A,U,A,A,A,A,A,A)>] =
    [] \r [v_s1sbv]
        case v_s1sbv of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sbz [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sbz;
        };

GHC.Real.rem :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLL),U(A,A,A,U,A,A,A,A,A)>] =
    [] \r [v_s1sbG]
        case v_s1sbG of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sbL [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sbL;
        };

GHC.Real.div :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLL),U(A,A,A,A,U,A,A,A,A)>] =
    [] \r [v_s1sbR]
        case v_s1sbR of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sbX [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sbX;
        };

GHC.Real.mod :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLL),U(A,A,A,A,A,U,A,A,A)>] =
    [] \r [v_s1sc2]
        case v_s1sc2 of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sc9 [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sc9;
        };

GHC.Real.quotRem
  :: forall a. GHC.Real.Integral a => a -> a -> (a, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLL),U(A,A,A,A,A,A,U,A,A)>] =
    [] \r [v_s1scd]
        case v_s1scd of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1scl [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1scl;
        };

GHC.Real.divMod
  :: forall a. GHC.Real.Integral a => a -> a -> (a, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSL),U(A,A,A,A,A,A,A,U,A)>] =
    [] \r [v_s1sco]
        case v_s1sco of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1scx [Occ=Once]
                              _ [Occ=Dead] ->
              v_s1scx;
        };

GHC.Real.toInteger
  :: forall a. GHC.Real.Integral a => a -> GHC.Integer.Type.Integer
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLS),U(A,A,A,A,A,A,A,A,U)>] =
    [] \r [v_s1scz]
        case v_s1scz of {
          GHC.Real.C:Integral _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1scJ [Occ=Once] ->
              v_s1scJ;
        };

GHC.Real.$p1Real :: forall a. GHC.Real.Real a => GHC.Num.Num a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_s1scK]
        case v_s1scK of {
          GHC.Real.C:Real v_s1scM [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
              v_s1scM;
        };

GHC.Real.$p2Real :: forall a. GHC.Real.Real a => GHC.Classes.Ord a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_s1scP]
        case v_s1scP of {
          GHC.Real.C:Real _ [Occ=Dead] v_s1scS [Occ=Once] _ [Occ=Dead] ->
              v_s1scS;
        };

GHC.Real.toRational
  :: forall a. GHC.Real.Real a => a -> GHC.Real.Rational
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_s1scU]
        case v_s1scU of {
          GHC.Real.C:Real _ [Occ=Dead] _ [Occ=Dead] v_s1scY [Occ=Once] ->
              v_s1scY;
        };

GHC.Real.$p1RealFrac
  :: forall a. GHC.Real.RealFrac a => GHC.Real.Real a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLL),U(U,A,A,A,A,A,A)>] =
    [] \r [v_s1scZ]
        case v_s1scZ of {
          GHC.Real.C:RealFrac v_s1sd1 [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sd1;
        };

GHC.Real.$p2RealFrac
  :: forall a. GHC.Real.RealFrac a => GHC.Real.Fractional a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLL),U(A,U,A,A,A,A,A)>] =
    [] \r [v_s1sd8]
        case v_s1sd8 of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              v_s1sdb [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sdb;
        };

GHC.Real.properFraction
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> (b, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLL),U(A,A,U,A,A,A,A)>] =
    [] \r [v_s1sdh]
        case v_s1sdh of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sdl [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sdl;
        };

GHC.Real.truncate
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLL),U(A,A,A,U,A,A,A)>] =
    [] \r [v_s1sdq]
        case v_s1sdq of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sdv [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sdv;
        };

GHC.Real.round
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLL),U(A,A,A,A,U,A,A)>] =
    [] \r [v_s1sdz]
        case v_s1sdz of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sdF [Occ=Once]
                              _ [Occ=Dead]
                              _ [Occ=Dead] ->
              v_s1sdF;
        };

GHC.Real.ceiling
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSL),U(A,A,A,A,A,U,A)>] =
    [] \r [v_s1sdI]
        case v_s1sdI of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sdP [Occ=Once]
                              _ [Occ=Dead] ->
              v_s1sdP;
        };

GHC.Real.floor
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLS),U(A,A,A,A,A,A,U)>] =
    [] \r [v_s1sdR]
        case v_s1sdR of {
          GHC.Real.C:RealFrac _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              _ [Occ=Dead]
                              v_s1sdZ [Occ=Once] ->
              v_s1sdZ;
        };

GHC.Real.$W:% [InlPrag=INLINE[2]]
  :: forall a. a -> a -> GHC.Real.Ratio a
[GblId[DataConWrapper],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>m,
 Unf=OtherCon []] =
    [] \r [dt_s1se0 dt_s1se1]
        case dt_s1se0 of dt_s1se2 {
          __DEFAULT ->
              case dt_s1se1 of dt_s1se3 {
                __DEFAULT -> GHC.Real.:% [dt_s1se2 dt_s1se3];
              };
        };

GHC.Real.$fOrdRatio_$s$c< [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1se4 w1_s1se5]
        case w_s1se4 of {
          GHC.Real.:% ww1_s1se7 [Occ=Once] ww2_s1se8 [Occ=Once] ->
              case w1_s1se5 of {
                GHC.Real.:% ww4_s1sea [Occ=Once] ww5_s1seb [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1sea ww2_s1se8
                    of
                    sat_s1sed
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1se7 ww5_s1seb
                          of
                          sat_s1sec
                          { __DEFAULT ->
                                case
                                    GHC.Integer.Type.ltInteger# sat_s1sec sat_s1sed
                                of
                                wild_s1see
                                { __DEFAULT -> tagToEnum# [wild_s1see];
                                };
                          };
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$c<= [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sef w1_s1seg]
        case w_s1sef of {
          GHC.Real.:% ww1_s1sei [Occ=Once] ww2_s1sej [Occ=Once] ->
              case w1_s1seg of {
                GHC.Real.:% ww4_s1sel [Occ=Once] ww5_s1sem [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1sel ww2_s1sej
                    of
                    sat_s1seo
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1sei ww5_s1sem
                          of
                          sat_s1sen
                          { __DEFAULT ->
                                case
                                    GHC.Integer.Type.leInteger# sat_s1sen sat_s1seo
                                of
                                wild_s1sep
                                { __DEFAULT -> tagToEnum# [wild_s1sep];
                                };
                          };
                    };
              };
        };

GHC.Real.$w$s$ccompare [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Types.Ordering
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1seq ww1_s1ser ww2_s1ses ww3_s1set]
        case GHC.Integer.Type.eqInteger# ww_s1seq ww2_s1ses of wild_s1seu {
          __DEFAULT ->
              let-no-escape {
                $j_s1sev [Occ=Once*T[0], Dmd=<L,1*U>] :: GHC.Types.Ordering
                [LclId[JoinId(0)], Unf=OtherCon []] =
                    [ww_s1seq ww1_s1ser ww2_s1ses ww3_s1set] \r []
                        case
                            GHC.Integer.Type.timesInteger ww2_s1ses ww1_s1ser
                        of
                        sat_s1sex
                        { __DEFAULT ->
                              case
                                  GHC.Integer.Type.timesInteger ww_s1seq ww3_s1set
                              of
                              sat_s1sew
                              { __DEFAULT ->
                                    case GHC.Integer.Type.leInteger# sat_s1sew sat_s1sex of {
                                      __DEFAULT -> GHC.Types.GT [];
                                      1# -> GHC.Types.LT [];
                                    };
                              };
                        };
              } in 
                case wild_s1seu of {
                  __DEFAULT -> $j_s1sev;
                  1# ->
                      case GHC.Integer.Type.eqInteger# ww1_s1ser ww3_s1set of {
                        __DEFAULT -> $j_s1sev;
                        1# -> GHC.Types.EQ [];
                      };
                };
        };

GHC.Real.$fEnumRatio_$s$ccompare [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1seB w1_s1seC]
        case w_s1seB of {
          GHC.Real.:% ww1_s1seE [Occ=Once] ww2_s1seF [Occ=Once] ->
              case w1_s1seC of {
                GHC.Real.:% ww4_s1seH [Occ=Once] ww5_s1seI [Occ=Once] ->
                    GHC.Real.$w$s$ccompare ww1_s1seE ww2_s1seF ww4_s1seH ww5_s1seI;
              };
        };

GHC.Real.$fEnumRatio_$s$c>=
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [x_s1seJ y_s1seK]
        case x_s1seJ of {
          GHC.Real.:% ww1_s1seM [Occ=Once] ww2_s1seN [Occ=Once] ->
              case y_s1seK of {
                GHC.Real.:% ww4_s1seP [Occ=Once] ww5_s1seQ [Occ=Once] ->
                    case
                        GHC.Real.$w$s$ccompare ww1_s1seM ww2_s1seN ww4_s1seP ww5_s1seQ
                    of
                    { __DEFAULT -> GHC.Types.True [];
                      GHC.Types.LT -> GHC.Types.False [];
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$c>
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [x_s1seS y_s1seT]
        case x_s1seS of {
          GHC.Real.:% ww1_s1seV [Occ=Once] ww2_s1seW [Occ=Once] ->
              case y_s1seT of {
                GHC.Real.:% ww4_s1seY [Occ=Once] ww5_s1seZ [Occ=Once] ->
                    case
                        GHC.Real.$w$s$ccompare ww1_s1seV ww2_s1seW ww4_s1seY ww5_s1seZ
                    of
                    { __DEFAULT -> GHC.Types.False [];
                      GHC.Types.GT -> GHC.Types.True [];
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$cmin
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_s1sf1 y_s1sf2]
        case x_s1sf1 of ww_s1sf3 {
          GHC.Real.:% ww1_s1sf4 [Occ=Once] ww2_s1sf5 [Occ=Once] ->
              case y_s1sf2 of ww3_s1sf6 {
                GHC.Real.:% ww4_s1sf7 [Occ=Once] ww5_s1sf8 [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1sf7 ww2_s1sf5
                    of
                    sat_s1sfa
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1sf4 ww5_s1sf8
                          of
                          sat_s1sf9
                          { __DEFAULT ->
                                case GHC.Integer.Type.leInteger# sat_s1sf9 sat_s1sfa of {
                                  __DEFAULT -> ww3_s1sf6;
                                  1# -> ww_s1sf3;
                                };
                          };
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$cmax
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_s1sfc y_s1sfd]
        case x_s1sfc of ww_s1sfe {
          GHC.Real.:% ww1_s1sff [Occ=Once] ww2_s1sfg [Occ=Once] ->
              case y_s1sfd of ww3_s1sfh {
                GHC.Real.:% ww4_s1sfi [Occ=Once] ww5_s1sfj [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww4_s1sfi ww2_s1sfg
                    of
                    sat_s1sfl
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1sff ww5_s1sfj
                          of
                          sat_s1sfk
                          { __DEFAULT ->
                                case GHC.Integer.Type.leInteger# sat_s1sfk sat_s1sfl of {
                                  __DEFAULT -> ww_s1sfe;
                                  1# -> ww3_s1sfh;
                                };
                          };
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$cnegate
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1sfn]
        case ds_s1sfn of {
          GHC.Real.:% x_s1sfp [Occ=Once] y_s1sfq [Occ=Once] ->
              case GHC.Integer.Type.negateInteger x_s1sfp of dt_s1sfr {
                __DEFAULT -> GHC.Real.:% [dt_s1sfr y_s1sfq];
              };
        };

GHC.Real.$fFractionalRatio_$s$cabs
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1sfs]
        case ds_s1sfs of {
          GHC.Real.:% x_s1sfu [Occ=Once] y_s1sfv [Occ=Once] ->
              case GHC.Integer.Type.absInteger x_s1sfu of dt_s1sfw {
                __DEFAULT -> GHC.Real.:% [dt_s1sfw y_s1sfv];
              };
        };

sat_s1sfx :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s1sfy :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1sfx GHC.Types.[]];

GHC.Real.$fEnumRatio1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s1sfy;

GHC.Real.$fFractionalRatio_$s$csignum
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SL),1*U(U,A)>m, Unf=OtherCon []] =
    [] \r [ds_s1sfz]
        case ds_s1sfz of {
          GHC.Real.:% x_s1sfB [Occ=Once] _ [Occ=Dead] ->
              case GHC.Integer.Type.signumInteger x_s1sfB of dt_s1sfD {
                __DEFAULT -> GHC.Real.:% [dt_s1sfD GHC.Real.$fEnumRatio1];
              };
        };

GHC.Real.$fFractionalRatio_$s$cfromInteger
  :: GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [x_s1sfE]
        case x_s1sfE of dt_s1sfF {
          __DEFAULT -> GHC.Real.:% [dt_s1sfF GHC.Real.$fEnumRatio1];
        };

GHC.Real.$fRealInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real GHC.Integer.Type.Integer
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Num.$fNumInteger
                                    GHC.Integer.Type.$fOrdInteger
                                    GHC.Real.$fFractionalRatio_$s$cfromInteger];

GHC.Real.$fIntegralInt_$ctoInteger
  :: GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1sfG]
        case ds_s1sfG of {
          GHC.Types.I# i_s1sfI [Occ=Once] ->
              GHC.Integer.Type.smallInteger i_s1sfI;
        };

GHC.Real.$fEnumRatio_$ctoRational
  :: GHC.Types.Int -> GHC.Real.Rational
[GblId, Arity=1, Str=<S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [x_s1sfJ]
        case x_s1sfJ of {
          GHC.Types.I# i_s1sfL [Occ=Once] ->
              case GHC.Integer.Type.smallInteger i_s1sfL of dt_s1sfM {
                __DEFAULT -> GHC.Real.:% [dt_s1sfM GHC.Real.$fEnumRatio1];
              };
        };

GHC.Real.$fRealInt [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real GHC.Types.Int
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Num.$fNumInt
                                    GHC.Classes.$fOrdInt
                                    GHC.Real.$fEnumRatio_$ctoRational];

GHC.Real.$fIntegralWord_$ctoInteger
  :: GHC.Types.Word -> GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1sfN]
        case ds_s1sfN of {
          GHC.Types.W# x#_s1sfP [Occ=Once] ->
              GHC.Integer.Type.wordToInteger x#_s1sfP;
        };

GHC.Real.$fIntegralInteger_$ctoInteger
  :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [n_s1sfQ] n_s1sfQ;

GHC.Real.$fEqRatio_$s$c== [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sfR w1_s1sfS]
        case w_s1sfR of {
          GHC.Real.:% ww1_s1sfU [Occ=Once] ww2_s1sfV [Occ=Once] ->
              case w1_s1sfS of {
                GHC.Real.:% ww4_s1sfX [Occ=Once] ww5_s1sfY [Occ=Once] ->
                    case GHC.Integer.Type.eqInteger# ww1_s1sfU ww4_s1sfX of {
                      __DEFAULT -> GHC.Types.False [];
                      1# ->
                          case
                              GHC.Integer.Type.eqInteger# ww2_s1sfV ww5_s1sfY
                          of
                          wild1_s1sg0
                          { __DEFAULT -> tagToEnum# [wild1_s1sg0];
                          };
                    };
              };
        };

GHC.Real.$fEqRatio_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sg1 w1_s1sg2 w2_s1sg3]
        case w1_s1sg2 of {
          GHC.Real.:% ww1_s1sg5 [Occ=Once] ww2_s1sg6 [Occ=Once] ->
              case w2_s1sg3 of {
                GHC.Real.:% ww4_s1sg8 [Occ=Once] ww5_s1sg9 [Occ=Once] ->
                    case GHC.Classes.== w_s1sg1 ww1_s1sg5 ww4_s1sg8 of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> GHC.Classes.== w_s1sg1 ww2_s1sg6 ww5_s1sg9;
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$c/= [InlPrag=INLINE (sat-args=2)]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1sgb eta1_s1sgc]
        case eta_s1sgb of {
          GHC.Real.:% a1_s1sge [Occ=Once] a2_s1sgf [Occ=Once] ->
              case eta1_s1sgc of {
                GHC.Real.:% b1_s1sgh [Occ=Once] b2_s1sgi [Occ=Once] ->
                    case GHC.Integer.Type.eqInteger# a1_s1sge b1_s1sgh of {
                      __DEFAULT -> GHC.Types.True [];
                      1# ->
                          case GHC.Integer.Type.eqInteger# a2_s1sgf b2_s1sgi of {
                            __DEFAULT -> GHC.Types.True [];
                            1# -> GHC.Types.False [];
                          };
                    };
              };
        };

GHC.Real.$fEqRatio_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_s1sgl eta_s1sgm eta1_s1sgn]
        case eta_s1sgm of {
          GHC.Real.:% ww1_s1sgp [Occ=Once] ww2_s1sgq [Occ=Once] ->
              case eta1_s1sgn of {
                GHC.Real.:% ww4_s1sgs [Occ=Once] ww5_s1sgt [Occ=Once] ->
                    case GHC.Classes.== $dEq_s1sgl ww1_s1sgp ww4_s1sgs of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True ->
                          case GHC.Classes.== $dEq_s1sgl ww2_s1sgq ww5_s1sgt of {
                            GHC.Types.False -> GHC.Types.True [];
                            GHC.Types.True -> GHC.Types.False [];
                          };
                    };
              };
        };

GHC.Real.$fOrdRatio_$s$fEqRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Real.$fEqRatio_$s$c==
                                     GHC.Real.$fOrdRatio_$s$c/=];

GHC.Real.$fEqRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Real.Ratio a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s1sgw]
        let {
          sat_s1sgy [Occ=Once]
            :: GHC.Real.Ratio a_a1eDJ
               -> GHC.Real.Ratio a_a1eDJ -> GHC.Types.Bool
          [LclId] =
              [$dEq_s1sgw] \r [eta_B2 eta_B1]
                  GHC.Real.$fEqRatio_$c/= $dEq_s1sgw eta_B2 eta_B1; } in
        let {
          sat_s1sgx [Occ=Once]
            :: GHC.Real.Ratio a_a1eDJ
               -> GHC.Real.Ratio a_a1eDJ -> GHC.Types.Bool
          [LclId] =
              [$dEq_s1sgw] \r [eta_B2 eta_B1]
                  GHC.Real.$fEqRatio_$c== $dEq_s1sgw eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s1sgx sat_s1sgy];

GHC.Real.$fOrdRatio_$s$fOrdRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [GHC.Real.$fOrdRatio_$s$fEqRatio
                                      GHC.Real.$fEnumRatio_$s$ccompare
                                      GHC.Real.$fOrdRatio_$s$c<
                                      GHC.Real.$fEnumRatio_$s$c<=
                                      GHC.Real.$fOrdRatio_$s$c>
                                      GHC.Real.$fEnumRatio_$s$c>=
                                      GHC.Real.$fOrdRatio_$s$cmax
                                      GHC.Real.$fOrdRatio_$s$cmin];

GHC.Real.$fOrdRatio_$cp1Ord
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Classes.Eq (GHC.Real.Ratio a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sgz]
        let {
          sat_s1sgC [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_a1eJ2
          [LclId] =
              [$dIntegral_s1sgz] \u []
                  case GHC.Real.$p1Integral $dIntegral_s1sgz of sat_s1sgA {
                    __DEFAULT ->
                        case GHC.Real.$p2Real sat_s1sgA of sat_s1sgB {
                          __DEFAULT -> GHC.Classes.$p1Ord sat_s1sgB;
                        };
                  };
        } in  GHC.Real.$fEqRatio sat_s1sgC;

GHC.Real.even1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

GHC.Real.$dmfloor
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U,U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1sgD eta_s1sgE eta1_s1sgF]
        let {
          ds_s1sgG [Dmd=<L,U(1*U,1*U)>] :: (b_a1eDd, a_a1dNs)
          [LclId] =
              [$dRealFrac_s1sgD eta_s1sgE eta1_s1sgF] \u []
                  GHC.Real.properFraction $dRealFrac_s1sgD eta_s1sgE eta1_s1sgF;
        } in 
          case
              GHC.Real.$p1RealFrac $dRealFrac_s1sgD
          of
          $dReal_s1sgH [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
          { __DEFAULT ->
                let {
                  sat_s1sgO [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [$dReal_s1sgH] \u []
                          case GHC.Real.$p1Real $dReal_s1sgH of sat_s1sgN {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1sgN GHC.Real.even1;
                          }; } in
                let {
                  sat_s1sgM [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [ds_s1sgG] \u []
                          case ds_s1sgG of {
                            (,) _ [Occ=Dead] r_s1sgL [Occ=Once] -> r_s1sgL;
                          };
                } in 
                  case GHC.Real.$p2Real $dReal_s1sgH of sat_s1sgI {
                    __DEFAULT ->
                        case GHC.Classes.< sat_s1sgI sat_s1sgM sat_s1sgO of {
                          GHC.Types.False ->
                              case ds_s1sgG of {
                                (,) n_s1sgR [Occ=Once] _ [Occ=Dead] -> n_s1sgR;
                              };
                          GHC.Types.True ->
                              case
                                  GHC.Real.$p1Integral eta_s1sgE
                              of
                              $dReal1_s1sgT [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                              { __DEFAULT ->
                                    case
                                        GHC.Real.$p1Real $dReal1_s1sgT
                                    of
                                    $dNum_s1sgU [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                    { __DEFAULT ->
                                          let {
                                            sat_s1sgZ [Occ=Once] :: b_a1eDd
                                            [LclId] =
                                                [$dNum_s1sgU] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_s1sgU GHC.Real.$fEnumRatio1; } in
                                          let {
                                            sat_s1sgY [Occ=Once] :: b_a1eDd
                                            [LclId] =
                                                [ds_s1sgG] \u []
                                                    case ds_s1sgG of {
                                                      (,) n_s1sgW [Occ=Once] _ [Occ=Dead] ->
                                                          n_s1sgW;
                                                    };
                                          } in  GHC.Num.- $dNum_s1sgU sat_s1sgY sat_s1sgZ;
                                    };
                              };
                        };
                  };
          };

GHC.Real.$dmceiling
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,A,1*C1(C1(U)),A,A,A),A),A,1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U,U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1sh0 eta_s1sh1 eta1_s1sh2]
        let {
          ds_s1sh3 [Dmd=<L,U(1*U,1*U)>] :: (b_a1eCG, a_a1dNs)
          [LclId] =
              [$dRealFrac_s1sh0 eta_s1sh1 eta1_s1sh2] \u []
                  GHC.Real.properFraction $dRealFrac_s1sh0 eta_s1sh1 eta1_s1sh2;
        } in 
          case
              GHC.Real.$p1RealFrac $dRealFrac_s1sh0
          of
          $dReal_s1sh4 [Dmd=<S(LS(LLLLC(C(S))LLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,A,1*C1(C1(U)),A,A,A),A)>]
          { __DEFAULT ->
                let {
                  sat_s1shb [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [$dReal_s1sh4] \u []
                          case GHC.Real.$p1Real $dReal_s1sh4 of sat_s1sha {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1sha GHC.Real.even1;
                          }; } in
                let {
                  sat_s1sh9 [Occ=Once] :: a_a1dNs
                  [LclId] =
                      [ds_s1sh3] \u []
                          case ds_s1sh3 of {
                            (,) _ [Occ=Dead] r_s1sh8 [Occ=Once] -> r_s1sh8;
                          };
                } in 
                  case GHC.Real.$p2Real $dReal_s1sh4 of sat_s1sh5 {
                    __DEFAULT ->
                        case GHC.Classes.> sat_s1sh5 sat_s1sh9 sat_s1shb of {
                          GHC.Types.False ->
                              case ds_s1sh3 of {
                                (,) n_s1she [Occ=Once] _ [Occ=Dead] -> n_s1she;
                              };
                          GHC.Types.True ->
                              case
                                  GHC.Real.$p1Integral eta_s1sh1
                              of
                              $dReal1_s1shg [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
                              { __DEFAULT ->
                                    case
                                        GHC.Real.$p1Real $dReal1_s1shg
                                    of
                                    $dNum_s1shh [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                                    { __DEFAULT ->
                                          let {
                                            sat_s1shm [Occ=Once] :: b_a1eCG
                                            [LclId] =
                                                [$dNum_s1shh] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_s1shh GHC.Real.$fEnumRatio1; } in
                                          let {
                                            sat_s1shl [Occ=Once] :: b_a1eCG
                                            [LclId] =
                                                [ds_s1sh3] \u []
                                                    case ds_s1sh3 of {
                                                      (,) n_s1shj [Occ=Once] _ [Occ=Dead] ->
                                                          n_s1shj;
                                                    };
                                          } in  GHC.Num.+ $dNum_s1shh sat_s1shl sat_s1shm;
                                    };
                              };
                        };
                  };
          };

GHC.Real.$dmtruncate [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S(SL)))LLLL),1*U(A,A,1*C1(C1(U(1*U,A))),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1shn $dIntegral_s1sho x_s1shp]
        case
            GHC.Real.properFraction $dRealFrac_s1shn $dIntegral_s1sho x_s1shp
        of
        { (,) m_s1shr [Occ=Once] _ [Occ=Dead] -> m_s1shr;
        };

GHC.Real.$dmrecip [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Real.Fractional a => a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LL),U(1*U(A,A,A,A,A,A,1*C1(U)),1*C1(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_s1sht eta_s1shu]
        let {
          sat_s1shw [Occ=Once] :: a_a1dNK
          [LclId] =
              [$dFractional_s1sht] \u []
                  case GHC.Real.$p1Fractional $dFractional_s1sht of sat_s1shv {
                    __DEFAULT -> GHC.Num.fromInteger sat_s1shv GHC.Real.$fEnumRatio1;
                  };
        } in  GHC.Real./ $dFractional_s1sht sat_s1shw eta_s1shu;

GHC.Real.$dm/ [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Fractional a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLC(C(S))LLLL)LLL),U(1*U(A,A,1*C1(C1(U)),A,A,A,A),A,1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_s1shx eta_s1shy eta1_s1shz]
        let {
          sat_s1shB [Occ=Once] :: a_a1dNK
          [LclId] =
              [$dFractional_s1shx eta1_s1shz] \u []
                  GHC.Real.recip $dFractional_s1shx eta1_s1shz;
        } in 
          case GHC.Real.$p1Fractional $dFractional_s1shx of sat_s1shA {
            __DEFAULT -> GHC.Num.* sat_s1shA eta_s1shy sat_s1shB;
          };

GHC.Real.$dmdivMod
  :: forall a. GHC.Real.Integral a => a -> a -> (a, a)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,1*C1(C1(U(U,U))),A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1shC eta_s1shD eta1_s1shE]
        case
            GHC.Real.$p1Integral $dIntegral_s1shC
        of
        $dReal_s1shF [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1shG [Dmd=<L,U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U))>]
                  :: GHC.Num.Num a_a1dNO
                [LclId] =
                    [$dReal_s1shF] \u [] GHC.Real.$p1Real $dReal_s1shF; } in
              let {
                ds_s1shH [Dmd=<L,U(1*U(U,U),1*U,1*U)>]
                  :: ((a_a1dNO, a_a1dNO), a_a1dNO, a_a1dNO)
                [LclId] =
                    [$dIntegral_s1shC eta_s1shD eta1_s1shE] \u []
                        case
                            GHC.Real.quotRem $dIntegral_s1shC eta_s1shD eta1_s1shE
                        of
                        wild_s1shI
                        { (,) q_s1shJ [Occ=Once] r_s1shK [Occ=Once] ->
                              (,,) [wild_s1shI q_s1shJ r_s1shK];
                        }; } in
              let {
                r_s1shL :: a_a1dNO
                [LclId] =
                    [ds_s1shH] \u []
                        case ds_s1shH of {
                          (,,) _ [Occ=Dead] _ [Occ=Dead] r1_s1shP [Occ=Once] -> r1_s1shP;
                        }; } in
              let {
                sat_s1shU [Occ=Once] :: a_a1dNO
                [LclId] =
                    [eta1_s1shE $dNum_s1shG] \u []
                        let {
                          sat_s1shT [Occ=Once] :: a_a1dNO
                          [LclId] =
                              [eta1_s1shE $dNum_s1shG] \u []
                                  GHC.Num.signum $dNum_s1shG eta1_s1shE;
                        } in  GHC.Num.negate $dNum_s1shG sat_s1shT; } in
              let {
                sat_s1shS [Occ=Once] :: a_a1dNO
                [LclId] =
                    [$dNum_s1shG r_s1shL] \u [] GHC.Num.signum $dNum_s1shG r_s1shL;
              } in 
                case GHC.Real.$p2Real $dReal_s1shF of sat_s1shQ {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_s1shQ of sat_s1shR {
                        __DEFAULT ->
                            case GHC.Classes.== sat_s1shR sat_s1shS sat_s1shU of {
                              GHC.Types.False ->
                                  case ds_s1shH of {
                                    (,,) qr_s1shX [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> qr_s1shX;
                                  };
                              GHC.Types.True ->
                                  let {
                                    sat_s1si7 [Occ=Once] :: a_a1dNO
                                    [LclId] =
                                        [eta1_s1shE $dNum_s1shG r_s1shL] \u []
                                            GHC.Num.+ $dNum_s1shG r_s1shL eta1_s1shE; } in
                                  let {
                                    sat_s1si6 [Occ=Once] :: a_a1dNO
                                    [LclId] =
                                        [$dNum_s1shG ds_s1shH] \u []
                                            let {
                                              sat_s1si5 [Occ=Once] :: a_a1dNO
                                              [LclId] =
                                                  [$dNum_s1shG] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s1shG GHC.Real.$fEnumRatio1; } in
                                            let {
                                              sat_s1si4 [Occ=Once] :: a_a1dNO
                                              [LclId] =
                                                  [ds_s1shH] \u []
                                                      case ds_s1shH of {
                                                        (,,) _ [Occ=Dead]
                                                             q_s1si2 [Occ=Once]
                                                             _ [Occ=Dead] ->
                                                            q_s1si2;
                                                      };
                                            } in  GHC.Num.- $dNum_s1shG sat_s1si4 sat_s1si5;
                                  } in  (,) [sat_s1si6 sat_s1si7];
                            };
                      };
                };
        };

GHC.Real.$dmmod [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(S(LS)))L),1*U(A,A,A,A,A,A,A,1*C1(C1(U(A,1*U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1si8 n_s1si9 d_s1sia]
        case GHC.Real.divMod $dIntegral_s1si8 n_s1si9 d_s1sia of {
          (,) _ [Occ=Dead] r_s1sid [Occ=Once] -> r_s1sid;
        };

GHC.Real.$dmdiv [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(S(SL)))L),1*U(A,A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sie n_s1sif d_s1sig]
        case GHC.Real.divMod $dIntegral_s1sie n_s1sif d_s1sig of {
          (,) q_s1sii [Occ=Once] _ [Occ=Dead] -> q_s1sii;
        };

GHC.Real.$dmrem [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(LS)))LL),1*U(A,A,A,A,A,A,1*C1(C1(U(A,1*U))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sik n_s1sil d_s1sim]
        case GHC.Real.quotRem $dIntegral_s1sik n_s1sil d_s1sim of {
          (,) _ [Occ=Dead] r_s1sip [Occ=Once] -> r_s1sip;
        };

GHC.Real.$dmquot [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))LL),1*U(A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1siq n_s1sir d_s1sis]
        case GHC.Real.quotRem $dIntegral_s1siq n_s1sir d_s1sis of {
          (,) q_s1siu [Occ=Once] _ [Occ=Dead] -> q_s1siu;
        };

GHC.Real.divZeroError [InlPrag=NOINLINE] :: forall a. a
[GblId, Str=x] =
    [] \u [] raise# [GHC.Exception.divZeroException];

GHC.Real.$fIntegralInt1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

GHC.Real.$fIntegralInt_$cmod [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1siw w1_s1six]
        case w1_s1six of {
          GHC.Types.I# ww1_s1siz [Occ=Once!] ->
              case ww1_s1siz of wild_s1siA {
                __DEFAULT ->
                    case w_s1siw of {
                      GHC.Types.I# x_s1siC [Occ=Once] ->
                          case GHC.Classes.modInt# x_s1siC wild_s1siA of ww2_s1siD {
                            __DEFAULT -> GHC.Types.I# [ww2_s1siD];
                          };
                    };
                -1# -> GHC.Real.$fIntegralInt1;
                0# -> GHC.Real.divZeroError;
              };
        };

GHC.Real.$fIntegralInt_$crem
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [a_s1siF b_s1siG]
        case b_s1siG of {
          GHC.Types.I# x_s1siI [Occ=Once!] ->
              case x_s1siI of wild1_s1siJ {
                __DEFAULT ->
                    case a_s1siF of {
                      GHC.Types.I# x1_s1siL [Occ=Once] ->
                          case remInt# [x1_s1siL wild1_s1siJ] of wild3_s1siM {
                            __DEFAULT -> GHC.Types.I# [wild3_s1siM];
                          };
                    };
                -1# -> GHC.Real.$fIntegralInt1;
                0# -> GHC.Real.divZeroError;
              };
        };

GHC.Real.$fIntegralInteger_$cquot [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1siN eta1_s1siO]
        case GHC.Integer.Type.eqInteger# eta1_s1siO GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.quotInteger eta_s1siN eta1_s1siO;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$crem [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1siQ eta1_s1siR]
        case GHC.Integer.Type.eqInteger# eta1_s1siR GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.remInteger eta_s1siQ eta1_s1siR;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cdiv [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1siT eta1_s1siU]
        case GHC.Integer.Type.eqInteger# eta1_s1siU GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.divInteger eta_s1siT eta1_s1siU;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cmod [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [eta_s1siW eta1_s1siX]
        case GHC.Integer.Type.eqInteger# eta1_s1siX GHC.Real.even1 of {
          __DEFAULT -> GHC.Integer.Type.modInteger eta_s1siW eta1_s1siX;
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cquotRem [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
[GblId, Arity=2, Str=<S,1*U><S,U>m, Unf=OtherCon []] =
    [] \r [eta_s1siZ eta1_s1sj0]
        case GHC.Integer.Type.eqInteger# eta1_s1sj0 GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.quotRemInteger eta_s1siZ eta1_s1sj0 of {
                (#,#) ipv_s1sj3 [Occ=Once] ipv1_s1sj4 [Occ=Once] ->
                    (,) [ipv_s1sj3 ipv1_s1sj4];
              };
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger_$cdivMod [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
[GblId, Arity=2, Str=<S,1*U><S,U>m, Unf=OtherCon []] =
    [] \r [eta_s1sj5 eta1_s1sj6]
        case GHC.Integer.Type.eqInteger# eta1_s1sj6 GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.divModInteger eta_s1sj5 eta1_s1sj6 of {
                (#,#) ipv_s1sj9 [Occ=Once] ipv1_s1sja [Occ=Once] ->
                    (,) [ipv_s1sj9 ipv1_s1sja];
              };
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Integral GHC.Integer.Type.Integer
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Integral! [GHC.Real.$fRealInteger
                                        GHC.Enum.$fEnumInteger
                                        GHC.Real.$fIntegralInteger_$cquot
                                        GHC.Real.$fIntegralInteger_$crem
                                        GHC.Real.$fIntegralInteger_$cdiv
                                        GHC.Real.$fIntegralInteger_$cmod
                                        GHC.Real.$fIntegralInteger_$cquotRem
                                        GHC.Real.$fIntegralInteger_$cdivMod
                                        GHC.Real.$fIntegralInteger_$ctoInteger];

GHC.Real.$fIntegralWord_$cquot
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1sjb y_s1sjc]
        case ds_s1sjb of {
          GHC.Types.W# x#_s1sje [Occ=Once] ->
              case y_s1sjc of {
                GHC.Types.W# y#_s1sjg [Occ=Once!] ->
                    case y#_s1sjg of wild2_s1sjh {
                      __DEFAULT ->
                          case quotWord# [x#_s1sje wild2_s1sjh] of wild3_s1sji {
                            __DEFAULT -> GHC.Types.W# [wild3_s1sji];
                          };
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralWord_$crem
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1sjj y_s1sjk]
        case ds_s1sjj of {
          GHC.Types.W# x#_s1sjm [Occ=Once] ->
              case y_s1sjk of {
                GHC.Types.W# y#_s1sjo [Occ=Once!] ->
                    case y#_s1sjo of wild2_s1sjp {
                      __DEFAULT ->
                          case remWord# [x#_s1sjm wild2_s1sjp] of wild3_s1sjq {
                            __DEFAULT -> GHC.Types.W# [wild3_s1sjq];
                          };
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralWord_$cquotRem
  :: GHC.Types.Word
     -> GHC.Types.Word -> (GHC.Types.Word, GHC.Types.Word)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1sjr y_s1sjs]
        case ds_s1sjr of {
          GHC.Types.W# x#_s1sju [Occ=Once] ->
              case y_s1sjs of {
                GHC.Types.W# y#_s1sjw [Occ=Once!] ->
                    case y#_s1sjw of wild2_s1sjx {
                      __DEFAULT ->
                          case quotRemWord# [x#_s1sju wild2_s1sjx] of {
                            (#,#) ipv_s1sjz [Occ=Once] ipv1_s1sjA [Occ=Once] ->
                                let {
                                  sat_s1sjC [Occ=Once] :: GHC.Types.Word
                                  [LclId] =
                                      CCCS GHC.Types.W#! [ipv1_s1sjA]; } in
                                let {
                                  sat_s1sjB [Occ=Once] :: GHC.Types.Word
                                  [LclId] =
                                      CCCS GHC.Types.W#! [ipv_s1sjz];
                                } in  (,) [sat_s1sjB sat_s1sjC];
                          };
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralWord_$cdivMod
  :: GHC.Types.Word
     -> GHC.Types.Word -> (GHC.Types.Word, GHC.Types.Word)
[GblId, Arity=2, Str=<S,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [ds_s1sjD y_s1sjE]
        case ds_s1sjD of {
          GHC.Types.W# x#_s1sjG ->
              case y_s1sjE of {
                GHC.Types.W# y#_s1sjI [Occ=Once!] ->
                    case y#_s1sjI of wild2_s1sjJ {
                      __DEFAULT ->
                          let {
                            sat_s1sjN [Occ=Once] :: GHC.Types.Word
                            [LclId] =
                                [x#_s1sjG wild2_s1sjJ] \u []
                                    case remWord# [x#_s1sjG wild2_s1sjJ] of wild3_s1sjM {
                                      __DEFAULT -> GHC.Types.W# [wild3_s1sjM];
                                    }; } in
                          let {
                            sat_s1sjL [Occ=Once] :: GHC.Types.Word
                            [LclId] =
                                [x#_s1sjG wild2_s1sjJ] \u []
                                    case quotWord# [x#_s1sjG wild2_s1sjJ] of wild3_s1sjK {
                                      __DEFAULT -> GHC.Types.W# [wild3_s1sjK];
                                    };
                          } in  (,) [sat_s1sjL sat_s1sjN];
                      0## -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.ratioZeroDenominatorError [InlPrag=NOINLINE]
  :: forall a. a
[GblId, Str=x] =
    [] \u [] raise# [GHC.Exception.ratioZeroDenomException];

GHC.Real.$fFractionalRatio_$s$crecip [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_s1sjO]
        case w_s1sjO of {
          GHC.Real.:% ww1_s1sjQ ww2_s1sjR [Occ=Once*] ->
              case GHC.Integer.Type.eqInteger# ww1_s1sjQ GHC.Real.even1 of {
                __DEFAULT ->
                    case GHC.Integer.Type.ltInteger# ww1_s1sjQ GHC.Real.even1 of {
                      __DEFAULT -> GHC.Real.:% [ww2_s1sjR ww1_s1sjQ];
                      1# ->
                          case GHC.Integer.Type.negateInteger ww2_s1sjR of dt_s1sjU {
                            __DEFAULT ->
                                case GHC.Integer.Type.negateInteger ww1_s1sjQ of dt1_s1sjV {
                                  __DEFAULT -> GHC.Real.:% [dt_s1sjU dt1_s1sjV];
                                };
                          };
                    };
                1# -> GHC.Real.ratioZeroDenominatorError;
              };
        };

GHC.Real.overflowError [InlPrag=NOINLINE] :: forall a. a
[GblId, Str=x] =
    [] \u [] raise# [GHC.Exception.overflowException];

lvl_r1j38 :: (GHC.Types.Int, GHC.Types.Int)
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Real.overflowError
                        GHC.Real.$fIntegralInt1];

GHC.Real.$fIntegralInt_$cdivMod [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1sjX w1_s1sjY]
        case w_s1sjX of {
          GHC.Types.I# ww1_s1sk0 ->
              case w1_s1sjY of {
                GHC.Types.I# ww3_s1sk2 [Occ=Once!] ->
                    case ww3_s1sk2 of wild_s1sk3 {
                      __DEFAULT ->
                          case ># [ww1_s1sk0 0#] of {
                            __DEFAULT ->
                                case <# [ww1_s1sk0 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww1_s1sk0 wild_s1sk3] of {
                                        (#,#) ipv_s1sk7 [Occ=Once] ipv1_s1sk8 [Occ=Once] ->
                                            let {
                                              sat_s1ska [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s1sk8]; } in
                                            let {
                                              sat_s1sk9 [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_s1sk7];
                                            } in  (,) [sat_s1sk9 sat_s1ska];
                                      };
                                  1# ->
                                      case ># [wild_s1sk3 0#] of {
                                        __DEFAULT ->
                                            case quotRemInt# [ww1_s1sk0 wild_s1sk3] of {
                                              (#,#) ipv_s1skd [Occ=Once] ipv1_s1ske [Occ=Once] ->
                                                  let {
                                                    sat_s1skg [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv1_s1ske]; } in
                                                  let {
                                                    sat_s1skf [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv_s1skd];
                                                  } in  (,) [sat_s1skf sat_s1skg];
                                            };
                                        1# ->
                                            case +# [ww1_s1sk0 1#] of sat_s1skh {
                                              __DEFAULT ->
                                                  case quotRemInt# [sat_s1skh wild_s1sk3] of {
                                                    (#,#) ipv_s1skj [Occ=Once]
                                                          ipv1_s1skk [Occ=Once] ->
                                                        case
                                                            +# [ipv1_s1skk wild_s1sk3]
                                                        of
                                                        sat_s1skn
                                                        { __DEFAULT ->
                                                              case -# [sat_s1skn 1#] of sat_s1sko {
                                                                __DEFAULT ->
                                                                    let {
                                                                      sat_s1skp [Occ=Once]
                                                                        :: GHC.Types.Int
                                                                      [LclId] =
                                                                          CCCS GHC.Types.I#! [sat_s1sko];
                                                                    } in 
                                                                      case
                                                                          -# [ipv_s1skj 1#]
                                                                      of
                                                                      sat_s1skl
                                                                      { __DEFAULT ->
                                                                            let {
                                                                              sat_s1skm [Occ=Once]
                                                                                :: GHC.Types.Int
                                                                              [LclId] =
                                                                                  CCCS GHC.Types.I#! [sat_s1skl];
                                                                            } in 
                                                                              (,) [sat_s1skm
                                                                                   sat_s1skp];
                                                                      };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            1# ->
                                case <# [wild_s1sk3 0#] of {
                                  __DEFAULT ->
                                      case <# [ww1_s1sk0 0#] of {
                                        __DEFAULT ->
                                            case quotRemInt# [ww1_s1sk0 wild_s1sk3] of {
                                              (#,#) ipv_s1skt [Occ=Once] ipv1_s1sku [Occ=Once] ->
                                                  let {
                                                    sat_s1skw [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv1_s1sku]; } in
                                                  let {
                                                    sat_s1skv [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv_s1skt];
                                                  } in  (,) [sat_s1skv sat_s1skw];
                                            };
                                        1# ->
                                            case ># [wild_s1sk3 0#] of {
                                              __DEFAULT ->
                                                  case quotRemInt# [ww1_s1sk0 wild_s1sk3] of {
                                                    (#,#) ipv_s1skz [Occ=Once]
                                                          ipv1_s1skA [Occ=Once] ->
                                                        let {
                                                          sat_s1skC [Occ=Once] :: GHC.Types.Int
                                                          [LclId] =
                                                              CCCS GHC.Types.I#! [ipv1_s1skA]; } in
                                                        let {
                                                          sat_s1skB [Occ=Once] :: GHC.Types.Int
                                                          [LclId] =
                                                              CCCS GHC.Types.I#! [ipv_s1skz];
                                                        } in  (,) [sat_s1skB sat_s1skC];
                                                  };
                                              1# ->
                                                  case +# [ww1_s1sk0 1#] of sat_s1skD {
                                                    __DEFAULT ->
                                                        case quotRemInt# [sat_s1skD wild_s1sk3] of {
                                                          (#,#) ipv_s1skF [Occ=Once]
                                                                ipv1_s1skG [Occ=Once] ->
                                                              case
                                                                  +# [ipv1_s1skG wild_s1sk3]
                                                              of
                                                              sat_s1skJ
                                                              { __DEFAULT ->
                                                                    case
                                                                        -# [sat_s1skJ 1#]
                                                                    of
                                                                    sat_s1skK
                                                                    { __DEFAULT ->
                                                                          let {
                                                                            sat_s1skL [Occ=Once]
                                                                              :: GHC.Types.Int
                                                                            [LclId] =
                                                                                CCCS GHC.Types.I#! [sat_s1skK];
                                                                          } in 
                                                                            case
                                                                                -# [ipv_s1skF 1#]
                                                                            of
                                                                            sat_s1skH
                                                                            { __DEFAULT ->
                                                                                  let {
                                                                                    sat_s1skI [Occ=Once]
                                                                                      :: GHC.Types.Int
                                                                                    [LclId] =
                                                                                        CCCS GHC.Types.I#! [sat_s1skH];
                                                                                  } in 
                                                                                    (,) [sat_s1skI
                                                                                         sat_s1skL];
                                                                            };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                  1# ->
                                      case -# [ww1_s1sk0 1#] of sat_s1skM {
                                        __DEFAULT ->
                                            case quotRemInt# [sat_s1skM wild_s1sk3] of {
                                              (#,#) ipv_s1skO [Occ=Once] ipv1_s1skP [Occ=Once] ->
                                                  case +# [ipv1_s1skP wild_s1sk3] of sat_s1skS {
                                                    __DEFAULT ->
                                                        case +# [sat_s1skS 1#] of sat_s1skT {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_s1skU [Occ=Once]
                                                                  :: GHC.Types.Int
                                                                [LclId] =
                                                                    CCCS GHC.Types.I#! [sat_s1skT];
                                                              } in 
                                                                case
                                                                    -# [ipv_s1skO 1#]
                                                                of
                                                                sat_s1skQ
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_s1skR [Occ=Once]
                                                                          :: GHC.Types.Int
                                                                        [LclId] =
                                                                            CCCS GHC.Types.I#! [sat_s1skQ];
                                                                      } in 
                                                                        (,) [sat_s1skR sat_s1skU];
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                      -1# ->
                          case ww1_s1sk0 of wild1_s1skV {
                            __DEFAULT ->
                                case ># [wild1_s1skV 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [wild1_s1skV -1#] of {
                                        (#,#) ipv_s1skY [Occ=Once] ipv1_s1skZ [Occ=Once] ->
                                            let {
                                              sat_s1sl1 [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s1skZ]; } in
                                            let {
                                              sat_s1sl0 [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_s1skY];
                                            } in  (,) [sat_s1sl0 sat_s1sl1];
                                      };
                                  1# ->
                                      case -# [wild1_s1skV 1#] of sat_s1sl2 {
                                        __DEFAULT ->
                                            case quotRemInt# [sat_s1sl2 -1#] of {
                                              (#,#) ipv_s1sl4 [Occ=Once] ipv1_s1sl5 [Occ=Once] ->
                                                  case +# [ipv1_s1sl5 -1#] of sat_s1sl8 {
                                                    __DEFAULT ->
                                                        case +# [sat_s1sl8 1#] of sat_s1sl9 {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_s1sla [Occ=Once]
                                                                  :: GHC.Types.Int
                                                                [LclId] =
                                                                    CCCS GHC.Types.I#! [sat_s1sl9];
                                                              } in 
                                                                case
                                                                    -# [ipv_s1sl4 1#]
                                                                of
                                                                sat_s1sl6
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_s1sl7 [Occ=Once]
                                                                          :: GHC.Types.Int
                                                                        [LclId] =
                                                                            CCCS GHC.Types.I#! [sat_s1sl6];
                                                                      } in 
                                                                        (,) [sat_s1sl7 sat_s1sla];
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            -9223372036854775808# -> lvl_r1j38;
                          };
                      0# -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralInt_$cquotRem [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1slc w1_s1sld]
        case w_s1slc of {
          GHC.Types.I# ww1_s1slf [Occ=Once*] ->
              case w1_s1sld of {
                GHC.Types.I# ww3_s1slh [Occ=Once!] ->
                    case ww3_s1slh of wild_s1sli {
                      __DEFAULT ->
                          case quotRemInt# [ww1_s1slf wild_s1sli] of {
                            (#,#) ipv_s1slk [Occ=Once] ipv1_s1sll [Occ=Once] ->
                                let {
                                  sat_s1sln [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s1sll]; } in
                                let {
                                  sat_s1slm [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv_s1slk];
                                } in  (,) [sat_s1slm sat_s1sln];
                          };
                      -1# ->
                          case ww1_s1slf of wild1_s1slo {
                            __DEFAULT ->
                                case quotRemInt# [wild1_s1slo -1#] of {
                                  (#,#) ipv_s1slq [Occ=Once] ipv1_s1slr [Occ=Once] ->
                                      let {
                                        sat_s1slt [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv1_s1slr]; } in
                                      let {
                                        sat_s1sls [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv_s1slq];
                                      } in  (,) [sat_s1sls sat_s1slt];
                                };
                            -9223372036854775808# -> lvl_r1j38;
                          };
                      0# -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$w$cdiv [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Str=<S,U><S,1*U>, Unf=OtherCon []] =
    [] \r [ww_s1slv ww1_s1slw]
        case ww1_s1slw of wild_s1slx {
          __DEFAULT -> GHC.Classes.divInt# ww_s1slv wild_s1slx;
          -1# ->
              case ww_s1slv of wild1_s1sly {
                __DEFAULT -> GHC.Classes.divInt# wild1_s1sly -1#;
                -9223372036854775808# -> GHC.Real.overflowError;
              };
          0# -> GHC.Real.divZeroError;
        };

GHC.Real.$fIntegralInt_$cdiv [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1slB w1_s1slC]
        case w_s1slB of {
          GHC.Types.I# ww1_s1slE [Occ=Once] ->
              case w1_s1slC of {
                GHC.Types.I# ww3_s1slG [Occ=Once] ->
                    case GHC.Real.$w$cdiv ww1_s1slE ww3_s1slG of ww4_s1slH {
                      __DEFAULT -> GHC.Types.I# [ww4_s1slH];
                    };
              };
        };

GHC.Real.$fIntegralInt_$cquot [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1slI w1_s1slJ]
        case w_s1slI of {
          GHC.Types.I# ww1_s1slL [Occ=Once*] ->
              case w1_s1slJ of {
                GHC.Types.I# ww3_s1slN [Occ=Once!] ->
                    case ww3_s1slN of wild_s1slO {
                      __DEFAULT ->
                          case quotInt# [ww1_s1slL wild_s1slO] of ww4_s1slP {
                            __DEFAULT -> GHC.Types.I# [ww4_s1slP];
                          };
                      -1# ->
                          case ww1_s1slL of wild1_s1slQ {
                            __DEFAULT ->
                                case quotInt# [wild1_s1slQ -1#] of sat_s1slR {
                                  __DEFAULT -> GHC.Types.I# [sat_s1slR];
                                };
                            -9223372036854775808# -> GHC.Real.overflowError;
                          };
                      0# -> GHC.Real.divZeroError;
                    };
              };
        };

GHC.Real.$fIntegralInt [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Integral GHC.Types.Int
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Integral! [GHC.Real.$fRealInt
                                        GHC.Enum.$fEnumInt
                                        GHC.Real.$fIntegralInt_$cquot
                                        GHC.Real.$fIntegralInt_$crem
                                        GHC.Real.$fIntegralInt_$cdiv
                                        GHC.Real.$fIntegralInt_$cmod
                                        GHC.Real.$fIntegralInt_$cquotRem
                                        GHC.Real.$fIntegralInt_$cdivMod
                                        GHC.Real.$fIntegralInt_$ctoInteger];

lvl1_r1j39 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [-1#];

lvl2_r1j3a :: GHC.Types.Int
[GblId] =
    [] \u [] GHC.Real.$wgcd' lvl1_r1j39 0#;
GHC.Real.$wgcd' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: GHC.Types.Int -> GHC.Prim.Int# -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [w_s1slU ww_s1slV]
        case ww_s1slV of wild_s1slW {
          __DEFAULT ->
              case w_s1slU of {
                GHC.Types.I# x_s1slY [Occ=Once] ->
                    case remInt# [x_s1slY wild_s1slW] of wild2_s1slZ {
                      __DEFAULT ->
                          let {
                            sat_s1sm0 [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [wild_s1slW];
                          } in  GHC.Real.$wgcd' sat_s1sm0 wild2_s1slZ;
                    };
              };
          -1# -> lvl2_r1j3a;
          0# -> w_s1slU;
        };

GHC.Real.$fEnumRatio_gcd' [Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [a_s1sm1 ds_s1sm2]
        case GHC.Integer.Type.eqInteger# ds_s1sm2 GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.remInteger a_s1sm1 ds_s1sm2 of sat_s1sm4 {
                __DEFAULT -> GHC.Real.$fEnumRatio_gcd' ds_s1sm2 sat_s1sm4;
              };
          1# -> a_s1sm1;
        };

GHC.Real.gcd [InlPrag=NOINLINE[1]]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(U(A,A,A,A,C(U),A,1*C1(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sm5 eta_s1sm6 eta1_s1sm7]
        case
            GHC.Real.$p1Integral $dIntegral_s1sm5
        of
        $dReal_s1sm8 [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(U(A,A,A,A,C(U),A,1*C1(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                lvl8_s1sm9 [Occ=OnceL] :: a_a1eor
                [LclId] =
                    [$dReal_s1sm8] \u []
                        case GHC.Real.$p1Real $dReal_s1sm8 of sat_s1sma {
                          __DEFAULT -> GHC.Num.fromInteger sat_s1sma GHC.Real.even1;
                        };
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1sm8
                of
                $dEq_s1smb [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Classes.$p1Ord $dEq_s1smb
                      of
                      $dEq1_s1smc [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                      { __DEFAULT ->
                            let {
                              $dNum_s1smd [Dmd=<L,U(A,A,A,A,C(U),A,A)>] :: GHC.Num.Num a_a1eor
                              [LclId] =
                                  [$dReal_s1sm8] \u [] GHC.Real.$p1Real $dReal_s1sm8; } in
                            let {
                              sat_s1smk [Occ=Once] :: a_a1eor
                              [LclId] =
                                  [eta1_s1sm7 $dNum_s1smd] \u []
                                      GHC.Num.abs $dNum_s1smd eta1_s1sm7; } in
                            let {
                              sat_s1smj [Occ=Once] :: a_a1eor
                              [LclId] =
                                  [eta_s1sm6 $dNum_s1smd] \u [] GHC.Num.abs $dNum_s1smd eta_s1sm6;
                            } in 
                              let-no-escape {
                                gcd'_s1sme [Occ=LoopBreakerT[2]] :: a_a1eor -> a_a1eor -> a_a1eor
                                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                    sat-only [$dIntegral_s1sm5
                                              lvl8_s1sm9
                                              $dEq1_s1smc
                                              gcd'_s1sme] \r [a1_s1smf ds_s1smg]
                                        case GHC.Classes.== $dEq1_s1smc ds_s1smg lvl8_s1sm9 of {
                                          GHC.Types.False ->
                                              let {
                                                sat_s1smi [Occ=Once] :: a_a1eor
                                                [LclId] =
                                                    [$dIntegral_s1sm5 a1_s1smf ds_s1smg] \u []
                                                        GHC.Real.rem
                                                            $dIntegral_s1sm5 a1_s1smf ds_s1smg;
                                              } in  gcd'_s1sme ds_s1smg sat_s1smi;
                                          GHC.Types.True -> a1_s1smf;
                                        };
                              } in  gcd'_s1sme sat_s1smj sat_s1smk;
                      };
                };
        };

GHC.Real.$w$sreduce [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [w_s1sml w1_s1smm]
        case GHC.Integer.Type.eqInteger# w1_s1smm GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.absInteger w1_s1smm of sat_s1smq {
                __DEFAULT ->
                    case GHC.Integer.Type.absInteger w_s1sml of sat_s1smp {
                      __DEFAULT ->
                          case
                              GHC.Real.$fEnumRatio_gcd' sat_s1smp sat_s1smq
                          of
                          d_s1smo [Dmd=<S,U>]
                          { __DEFAULT ->
                                case GHC.Integer.Type.eqInteger# d_s1smo GHC.Real.even1 of {
                                  __DEFAULT ->
                                      case
                                          GHC.Integer.Type.quotInteger w_s1sml d_s1smo
                                      of
                                      dt_s1sms
                                      { __DEFAULT ->
                                            case
                                                GHC.Integer.Type.quotInteger w1_s1smm d_s1smo
                                            of
                                            dt1_s1smt
                                            { __DEFAULT -> (#,#) [dt_s1sms dt1_s1smt];
                                            };
                                      };
                                  1# -> GHC.Real.divZeroError;
                                };
                          };
                    };
              };
          1# -> GHC.Real.ratioZeroDenominatorError;
        };

GHC.Real.reduce_$sreduce [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S,U>m, Unf=OtherCon []] =
    [] \r [w_s1smw w1_s1smx]
        case GHC.Real.$w$sreduce w_s1smw w1_s1smx of {
          (#,#) ww1_s1smz [Occ=Once] ww2_s1smA [Occ=Once] ->
              GHC.Real.:% [ww1_s1smz ww2_s1smA];
        };

GHC.Real.$fRealWord_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Word -> GHC.Real.Rational
[GblId, Arity=1, Str=<S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1smB]
        case w_s1smB of {
          GHC.Types.W# ww1_s1smD [Occ=Once] ->
              case GHC.Integer.Type.wordToInteger ww1_s1smD of sat_s1smE {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger sat_s1smE GHC.Real.$fEnumRatio1
                    of
                    sat_s1smF
                    { __DEFAULT ->
                          case GHC.Real.$w$sreduce sat_s1smF GHC.Real.$fEnumRatio1 of {
                            (#,#) ww3_s1smH [Occ=Once] ww4_s1smI [Occ=Once] ->
                                GHC.Real.:% [ww3_s1smH ww4_s1smI];
                          };
                    };
              };
        };

GHC.Real.$fRealWord [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real GHC.Types.Word
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Num.$fNumWord
                                    GHC.Classes.$fOrdWord
                                    GHC.Real.$fRealWord_$ctoRational];

GHC.Real.$fIntegralWord [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Integral GHC.Types.Word
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Real.C:Integral! [GHC.Real.$fRealWord
                                        GHC.Enum.$fEnumWord
                                        GHC.Real.$fIntegralWord_$cquot
                                        GHC.Real.$fIntegralWord_$crem
                                        GHC.Real.$fIntegralWord_$cquot
                                        GHC.Real.$fIntegralWord_$crem
                                        GHC.Real.$fIntegralWord_$cquotRem
                                        GHC.Real.$fIntegralWord_$cdivMod
                                        GHC.Real.$fIntegralWord_$ctoInteger];

GHC.Real.$fFractionalRatio_$s$c* [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1smJ w1_s1smK]
        case w_s1smJ of {
          GHC.Real.:% ww1_s1smM [Occ=Once] ww2_s1smN [Occ=Once] ->
              case w1_s1smK of {
                GHC.Real.:% ww4_s1smP [Occ=Once] ww5_s1smQ [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger ww2_s1smN ww5_s1smQ
                    of
                    sat_s1smS
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww1_s1smM ww4_s1smP
                          of
                          sat_s1smR
                          { __DEFAULT ->
                                case GHC.Real.$w$sreduce sat_s1smR sat_s1smS of {
                                  (#,#) ww7_s1smU [Occ=Once] ww8_s1smV [Occ=Once] ->
                                      GHC.Real.:% [ww7_s1smU ww8_s1smV];
                                };
                          };
                    };
              };
        };

GHC.Real.$w$s$c- [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=4, Str=<S,1*U><S,U><S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1smW ww1_s1smX ww2_s1smY ww3_s1smZ]
        case
            GHC.Integer.Type.timesInteger ww1_s1smX ww3_s1smZ
        of
        sat_s1sn3
        { __DEFAULT ->
              case
                  GHC.Integer.Type.timesInteger ww2_s1smY ww1_s1smX
              of
              sat_s1sn1
              { __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger ww_s1smW ww3_s1smZ
                    of
                    sat_s1sn0
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.minusInteger sat_s1sn0 sat_s1sn1
                          of
                          sat_s1sn2
                          { __DEFAULT -> GHC.Real.$w$sreduce sat_s1sn2 sat_s1sn3;
                          };
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$c- [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1sn4 w1_s1sn5]
        case w_s1sn4 of {
          GHC.Real.:% ww1_s1sn7 [Occ=Once] ww2_s1sn8 [Occ=Once] ->
              case w1_s1sn5 of {
                GHC.Real.:% ww4_s1sna [Occ=Once] ww5_s1snb [Occ=Once] ->
                    case GHC.Real.$w$s$c- ww1_s1sn7 ww2_s1sn8 ww4_s1sna ww5_s1snb of {
                      (#,#) ww7_s1snd [Occ=Once] ww8_s1sne [Occ=Once] ->
                          GHC.Real.:% [ww7_s1snd ww8_s1sne];
                    };
              };
        };

GHC.Real.$w$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=4, Str=<S,1*U><S,U><S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1snf ww1_s1sng ww2_s1snh ww3_s1sni]
        case
            GHC.Integer.Type.timesInteger ww1_s1sng ww3_s1sni
        of
        sat_s1snm
        { __DEFAULT ->
              case
                  GHC.Integer.Type.timesInteger ww2_s1snh ww1_s1sng
              of
              sat_s1snk
              { __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger ww_s1snf ww3_s1sni
                    of
                    sat_s1snj
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.plusInteger sat_s1snj sat_s1snk
                          of
                          sat_s1snl
                          { __DEFAULT -> GHC.Real.$w$sreduce sat_s1snl sat_s1snm;
                          };
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1snn w1_s1sno]
        case w_s1snn of {
          GHC.Real.:% ww1_s1snq [Occ=Once] ww2_s1snr [Occ=Once] ->
              case w1_s1sno of {
                GHC.Real.:% ww4_s1snt [Occ=Once] ww5_s1snu [Occ=Once] ->
                    case GHC.Real.$w$s$c+ ww1_s1snq ww2_s1snr ww4_s1snt ww5_s1snu of {
                      (#,#) ww7_s1snw [Occ=Once] ww8_s1snx [Occ=Once] ->
                          GHC.Real.:% [ww7_s1snw ww8_s1snx];
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$fNumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Num.Num (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Num.C:Num! [GHC.Real.$fEnumRatio_$s$c+
                                  GHC.Real.$fEnumRatio_$s$c-
                                  GHC.Real.$fFractionalRatio_$s$c*
                                  GHC.Real.$fFractionalRatio_$s$cnegate
                                  GHC.Real.$fFractionalRatio_$s$cabs
                                  GHC.Real.$fFractionalRatio_$s$csignum
                                  GHC.Real.$fFractionalRatio_$s$cfromInteger];

GHC.Real.$w$s$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1sny ww1_s1snz]
        case GHC.Integer.Type.absInteger ww1_s1snz of sat_s1snC {
          __DEFAULT ->
              case GHC.Integer.Type.signumInteger ww1_s1snz of sat_s1snA {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger ww_s1sny sat_s1snA
                    of
                    sat_s1snB
                    { __DEFAULT -> GHC.Real.$w$sreduce sat_s1snB sat_s1snC;
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Rational -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_s1snD]
        case w_s1snD of {
          GHC.Real.:% ww1_s1snF [Occ=Once] ww2_s1snG [Occ=Once] ->
              case GHC.Real.$w$s$cfromRational ww1_s1snF ww2_s1snG of {
                (#,#) ww4_s1snI [Occ=Once] ww5_s1snJ [Occ=Once] ->
                    GHC.Real.:% [ww4_s1snI ww5_s1snJ];
              };
        };

GHC.Real.$w$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId,
 Arity=4,
 Str=<S,1*U><S,1*U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_s1snK ww1_s1snL ww2_s1snM ww3_s1snN]
        case
            GHC.Integer.Type.timesInteger ww1_s1snL ww2_s1snM
        of
        y_s1snO [Dmd=<S,U>]
        { __DEFAULT ->
              case GHC.Integer.Type.absInteger y_s1snO of sat_s1snS {
                __DEFAULT ->
                    case GHC.Integer.Type.signumInteger y_s1snO of sat_s1snQ {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger ww_s1snK ww3_s1snN
                          of
                          sat_s1snP
                          { __DEFAULT ->
                                case
                                    GHC.Integer.Type.timesInteger sat_s1snP sat_s1snQ
                                of
                                sat_s1snR
                                { __DEFAULT -> GHC.Real.$w$sreduce sat_s1snR sat_s1snS;
                                };
                          };
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1snT w1_s1snU]
        case w_s1snT of {
          GHC.Real.:% ww1_s1snW [Occ=Once] ww2_s1snX [Occ=Once] ->
              case w1_s1snU of {
                GHC.Real.:% ww4_s1snZ [Occ=Once] ww5_s1so0 [Occ=Once] ->
                    case GHC.Real.$w$s$c/ ww1_s1snW ww2_s1snX ww4_s1snZ ww5_s1so0 of {
                      (#,#) ww7_s1so2 [Occ=Once] ww8_s1so3 [Occ=Once] ->
                          GHC.Real.:% [ww7_s1so2 ww8_s1so3];
                    };
              };
        };

GHC.Real.$fFractionalRatio_$s$fFractionalRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Fractional (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Fractional! [GHC.Real.$fFractionalRatio_$s$fNumRatio
                                          GHC.Real.$fFractionalRatio_$s$c/
                                          GHC.Real.$fFractionalRatio_$s$crecip
                                          GHC.Real.$fFractionalRatio_$s$cfromRational];

GHC.Real.ratioPrec :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [7#];

GHC.Real.infinity :: GHC.Real.Rational
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.$fEnumRatio1 GHC.Real.even1];

GHC.Real.notANumber :: GHC.Real.Rational
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.even1 GHC.Real.even1];

GHC.Real.numerator :: forall a. GHC.Real.Ratio a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_s1so4]
        case ds_s1so4 of {
          GHC.Real.:% x_s1so6 [Occ=Once] _ [Occ=Dead] -> x_s1so6;
        };

GHC.Real.denominator :: forall a. GHC.Real.Ratio a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1so8]
        case ds_s1so8 of {
          GHC.Real.:% _ [Occ=Dead] y_s1sob [Occ=Once] -> y_s1sob;
        };

GHC.Real.$w$snumericEnumFrom [InlPrag=NOUSERINLINE[0],
                              Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Real.Ratio GHC.Integer.Type.Integer,
           [GHC.Real.Ratio GHC.Integer.Type.Integer] #)
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1soc ww1_s1sod]
        let {
          sat_s1sol [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
          [LclId] =
              [ww_s1soc ww1_s1sod] \u []
                  case
                      GHC.Real.$w$s$c+
                          ww_s1soc ww1_s1sod GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
                  of
                  { (#,#) ww3_s1sog [Occ=Once] ww4_s1soh [Occ=Once] ->
                        case GHC.Real.$w$snumericEnumFrom ww3_s1sog ww4_s1soh of {
                          (#,#) ww6_s1soj [Occ=Once] ww7_s1sok [Occ=Once] ->
                              : [ww6_s1soj ww7_s1sok];
                        };
                  }; } in
        let {
          sat_s1soe [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId] =
              CCCS GHC.Real.:%! [ww_s1soc ww1_s1sod];
        } in  (#,#) [sat_s1soe sat_s1sol];

GHC.Real.$fEnumRatio_$snumericEnumFrom [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m2, Unf=OtherCon []] =
    [] \r [w_s1som]
        case w_s1som of {
          GHC.Real.:% ww1_s1soo [Occ=Once] ww2_s1sop [Occ=Once] ->
              case GHC.Real.$w$snumericEnumFrom ww1_s1soo ww2_s1sop of {
                (#,#) ww4_s1sor [Occ=Once] ww5_s1sos [Occ=Once] ->
                    : [ww4_s1sor ww5_s1sos];
              };
        };

GHC.Real.$wnumericEnumFrom [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: forall a. GHC.Real.Fractional a => a -> (# a, [a] #)
[GblId,
 Arity=2,
 Str=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1sot w1_s1sou]
        case w1_s1sou of n_s1sov {
          __DEFAULT ->
              let {
                sat_s1soC [Occ=Once] :: [a_s1hA7]
                [LclId] =
                    [w_s1sot n_s1sov] \u []
                        case
                            GHC.Real.$p1Fractional w_s1sot
                        of
                        $dNum_s1sow [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                        { __DEFAULT ->
                              let {
                                sat_s1sox [Occ=Once] :: a_s1hA7
                                [LclId] =
                                    [$dNum_s1sow] \u []
                                        GHC.Num.fromInteger $dNum_s1sow GHC.Real.$fEnumRatio1;
                              } in 
                                case GHC.Num.+ $dNum_s1sow n_s1sov sat_s1sox of sat_s1soy {
                                  __DEFAULT ->
                                      case GHC.Real.$wnumericEnumFrom w_s1sot sat_s1soy of {
                                        (#,#) ww1_s1soA [Occ=Once] ww2_s1soB [Occ=Once] ->
                                            : [ww1_s1soA ww2_s1soB];
                                      };
                                };
                        };
              } in  (#,#) [n_s1sov sat_s1soC];
        };

GHC.Real.numericEnumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Fractional a => a -> [a]
[GblId,
 Arity=2,
 Str=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_s1soD w1_s1soE]
        case GHC.Real.$wnumericEnumFrom w_s1soD w1_s1soE of {
          (#,#) ww1_s1soG [Occ=Once] ww2_s1soH [Occ=Once] ->
              : [ww1_s1soG ww2_s1soH];
        };

sat_s1soI :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_s1soJ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1soI GHC.Types.[]];

GHC.Real.even2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s1soJ;

GHC.Real.$fEnumRatio2 :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId] =
    [] \u []
        case
            GHC.Real.$w$s$c/
                GHC.Real.$fEnumRatio1
                GHC.Real.$fEnumRatio1
                GHC.Real.even2
                GHC.Real.$fEnumRatio1
        of
        { (#,#) ww1_s1soL [Occ=Once] ww2_s1soM [Occ=Once] ->
              GHC.Real.:% [ww1_s1soL ww2_s1soM];
        };

GHC.Real.$w$snumericEnumFromTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId, Arity=3, Str=<L,U><L,U><L,1*U(U,U)>, Unf=OtherCon []] =
    [] \r [ww_s1soN ww1_s1soO w_s1soP]
        case GHC.Real.$w$snumericEnumFrom ww_s1soN ww1_s1soO of {
          (#,#) ww3_s1soR [Occ=Once] ww4_s1soS [Occ=Once] ->
              let {
                sat_s1sp5 [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
                [LclId] =
                    CCCS :! [ww3_s1soR ww4_s1soS]; } in
              let {
                ds_s1soT [Occ=OnceL, Dmd=<L,U(U,U)>]
                  :: GHC.Real.Ratio GHC.Integer.Type.Integer
                [LclId] =
                    [w_s1soP] \u []
                        case w_s1soP of {
                          GHC.Real.:% ww6_s1soV [Occ=Once] ww7_s1soW [Occ=Once] ->
                              case GHC.Real.$fEnumRatio2 of {
                                GHC.Real.:% ww9_s1soY [Occ=Once] ww10_s1soZ [Occ=Once] ->
                                    case
                                        GHC.Real.$w$s$c+ ww6_s1soV ww7_s1soW ww9_s1soY ww10_s1soZ
                                    of
                                    { (#,#) ww12_s1sp1 [Occ=Once] ww13_s1sp2 [Occ=Once] ->
                                          GHC.Real.:% [ww12_s1sp1 ww13_s1sp2];
                                    };
                              };
                        }; } in
              let {
                sat_s1sp4 [Occ=Once]
                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                [LclId] =
                    [ds_s1soT] \r [ds1_s1sp3]
                        GHC.Real.$fEnumRatio_$s$c<= ds1_s1sp3 ds_s1soT;
              } in  GHC.List.takeWhile sat_s1sp4 sat_s1sp5;
        };

GHC.Real.$fEnumRatio_$snumericEnumFromTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sp6 w1_s1sp7]
        case w_s1sp6 of {
          GHC.Real.:% ww1_s1sp9 [Occ=Once] ww2_s1spa [Occ=Once] ->
              GHC.Real.$w$snumericEnumFromTo ww1_s1sp9 ww2_s1spa w1_s1sp7;
        };

GHC.Real.numericEnumFromTo
  :: forall a.
     (GHC.Classes.Ord a, GHC.Real.Fractional a) =>
     a -> a -> [a]
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U(U(C(C1(U)),A,A,A,A,A,C(U)),1*C1(C1(U)),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1spb $dFractional_s1spc eta_s1spd eta1_s1spe]
        case GHC.Real.$wnumericEnumFrom $dFractional_s1spc eta_s1spd of {
          (#,#) ww1_s1spg [Occ=Once] ww2_s1sph [Occ=Once] ->
              let {
                $dNum_s1spi [Dmd=<L,U(1*C1(C1(U)),A,A,A,A,A,C(U))>]
                  :: GHC.Num.Num a_a1ew7
                [LclId] =
                    [$dFractional_s1spc] \u []
                        GHC.Real.$p1Fractional $dFractional_s1spc; } in
              let {
                sat_s1spp [Occ=Once] :: [a_a1ew7]
                [LclId] =
                    CCCS :! [ww1_s1spg ww2_s1sph]; } in
              let {
                ds_s1spj [Occ=OnceL] :: a_a1ew7
                [LclId] =
                    [$dFractional_s1spc eta1_s1spe $dNum_s1spi] \u []
                        let {
                          sat_s1spm [Occ=Once] :: a_a1ew7
                          [LclId] =
                              [$dFractional_s1spc $dNum_s1spi] \u []
                                  let {
                                    sat_s1spl [Occ=Once] :: a_a1ew7
                                    [LclId] =
                                        [$dNum_s1spi] \u []
                                            GHC.Num.fromInteger $dNum_s1spi GHC.Real.even2; } in
                                  let {
                                    sat_s1spk [Occ=Once] :: a_a1ew7
                                    [LclId] =
                                        [$dNum_s1spi] \u []
                                            GHC.Num.fromInteger $dNum_s1spi GHC.Real.$fEnumRatio1;
                                  } in  GHC.Real./ $dFractional_s1spc sat_s1spk sat_s1spl;
                        } in  GHC.Num.+ $dNum_s1spi eta1_s1spe sat_s1spm; } in
              let {
                sat_s1spo [Occ=Once] :: a_a1ew7 -> GHC.Types.Bool
                [LclId] =
                    [$dOrd_s1spb ds_s1spj] \r [ds1_s1spn]
                        GHC.Classes.<= $dOrd_s1spb ds1_s1spn ds_s1spj;
              } in  GHC.List.takeWhile sat_s1spo sat_s1spp;
        };

GHC.Real.$w$snumericEnumFromThen [InlPrag=NOUSERINLINE[0],
                                  Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Real.Ratio GHC.Integer.Type.Integer,
           [GHC.Real.Ratio GHC.Integer.Type.Integer] #)
[GblId, Arity=4, Str=<L,U><L,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1spq ww1_s1spr ww2_s1sps ww3_s1spt]
        let {
          sat_s1spE [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
          [LclId] =
              [ww_s1spq ww1_s1spr ww2_s1sps ww3_s1spt] \u []
                  case GHC.Real.$w$s$c+ ww2_s1sps ww3_s1spt ww2_s1sps ww3_s1spt of {
                    (#,#) ww5_s1spw [Occ=Once] ww6_s1spx [Occ=Once] ->
                        case GHC.Real.$w$s$c- ww5_s1spw ww6_s1spx ww_s1spq ww1_s1spr of {
                          (#,#) ww8_s1spz [Occ=Once] ww9_s1spA [Occ=Once] ->
                              case
                                  GHC.Real.$w$snumericEnumFromThen
                                      ww2_s1sps ww3_s1spt ww8_s1spz ww9_s1spA
                              of
                              { (#,#) ww11_s1spC [Occ=Once] ww12_s1spD [Occ=Once] ->
                                    : [ww11_s1spC ww12_s1spD];
                              };
                        };
                  }; } in
        let {
          sat_s1spu [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId] =
              CCCS GHC.Real.:%! [ww_s1spq ww1_s1spr];
        } in  (#,#) [sat_s1spu sat_s1spE];

GHC.Real.$fEnumRatio_$snumericEnumFromThen [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s1spF w1_s1spG]
        case w_s1spF of {
          GHC.Real.:% ww1_s1spI [Occ=Once] ww2_s1spJ [Occ=Once] ->
              case w1_s1spG of {
                GHC.Real.:% ww4_s1spL [Occ=Once] ww5_s1spM [Occ=Once] ->
                    case
                        GHC.Real.$w$snumericEnumFromThen
                            ww1_s1spI ww2_s1spJ ww4_s1spL ww5_s1spM
                    of
                    { (#,#) ww7_s1spO [Occ=Once] ww8_s1spP [Occ=Once] ->
                          : [ww7_s1spO ww8_s1spP];
                    };
              };
        };

GHC.Real.$wnumericEnumFromThen [InlPrag=NOUSERINLINE[0],
                                Occ=LoopBreaker]
  :: forall a. GHC.Real.Fractional a => a -> a -> (# a, [a] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1spQ w1_s1spR w2_s1spS]
        case w1_s1spR of n_s1spT {
          __DEFAULT ->
              case w2_s1spS of m_s1spU {
                __DEFAULT ->
                    let {
                      sat_s1sq1 [Occ=Once] :: [a_s1hAH]
                      [LclId] =
                          [w_s1spQ n_s1spT m_s1spU] \u []
                              case
                                  GHC.Real.$p1Fractional w_s1spQ
                              of
                              $dNum_s1spV [Dmd=<S(LC(C(S))LLLLL),U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,A)>]
                              { __DEFAULT ->
                                    let {
                                      sat_s1spW [Occ=Once] :: a_s1hAH
                                      [LclId] =
                                          [m_s1spU $dNum_s1spV] \u []
                                              GHC.Num.+ $dNum_s1spV m_s1spU m_s1spU;
                                    } in 
                                      case GHC.Num.- $dNum_s1spV sat_s1spW n_s1spT of sat_s1spX {
                                        __DEFAULT ->
                                            case
                                                GHC.Real.$wnumericEnumFromThen
                                                    w_s1spQ m_s1spU sat_s1spX
                                            of
                                            { (#,#) ww1_s1spZ [Occ=Once] ww2_s1sq0 [Occ=Once] ->
                                                  : [ww1_s1spZ ww2_s1sq0];
                                            };
                                      };
                              };
                    } in  (#,#) [n_s1spT sat_s1sq1];
              };
        };

GHC.Real.numericEnumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Fractional a => a -> a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)><S,1*U><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_s1sq2 w1_s1sq3 w2_s1sq4]
        case GHC.Real.$wnumericEnumFromThen w_s1sq2 w1_s1sq3 w2_s1sq4 of {
          (#,#) ww1_s1sq6 [Occ=Once] ww2_s1sq7 [Occ=Once] ->
              : [ww1_s1sq6 ww2_s1sq7];
        };

GHC.Real.$w$snumericEnumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=5,
 Str=<L,U><L,U><L,U><L,U><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [ww_s1sq8 ww1_s1sq9 ww2_s1sqa ww3_s1sqb w_s1sqc]
        case
            GHC.Real.$w$snumericEnumFromThen
                ww_s1sq8 ww1_s1sq9 ww2_s1sqa ww3_s1sqb
        of
        { (#,#) ww5_s1sqe [Occ=Once] ww6_s1sqf [Occ=Once] ->
              let {
                sat_s1sqM [Occ=Once] :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
                [LclId] =
                    CCCS :! [ww5_s1sqe ww6_s1sqf]; } in
              let {
                sat_s1sqL [Occ=Once, Dmd=<L,C(U)>]
                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                [LclId] =
                    [ww_s1sq8 ww1_s1sq9 ww2_s1sqa ww3_s1sqb w_s1sqc] \u []
                        case
                            GHC.Real.$w$s$ccompare ww2_s1sqa ww3_s1sqb ww_s1sq8 ww1_s1sq9
                        of
                        { __DEFAULT ->
                              let {
                                ds_s1sqh [Occ=OnceL, Dmd=<L,U(U,U)>]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer
                                [LclId] =
                                    [ww_s1sq8 ww1_s1sq9 ww2_s1sqa ww3_s1sqb w_s1sqc] \u []
                                        case w_s1sqc of {
                                          GHC.Real.:% ww8_s1sqj [Occ=Once] ww9_s1sqk [Occ=Once] ->
                                              case
                                                  GHC.Real.$w$s$c-
                                                      ww2_s1sqa ww3_s1sqb ww_s1sq8 ww1_s1sq9
                                              of
                                              { (#,#) ww11_s1sqm [Occ=Once] ww12_s1sqn [Occ=Once] ->
                                                    case
                                                        GHC.Real.$w$s$c/
                                                            ww11_s1sqm
                                                            ww12_s1sqn
                                                            GHC.Real.even2
                                                            GHC.Real.$fEnumRatio1
                                                    of
                                                    { (#,#) ww14_s1sqp [Occ=Once]
                                                            ww15_s1sqq [Occ=Once] ->
                                                          case
                                                              GHC.Real.$w$s$c+
                                                                  ww8_s1sqj
                                                                  ww9_s1sqk
                                                                  ww14_s1sqp
                                                                  ww15_s1sqq
                                                          of
                                                          { (#,#) ww17_s1sqs [Occ=Once]
                                                                  ww18_s1sqt [Occ=Once] ->
                                                                GHC.Real.:% [ww17_s1sqs ww18_s1sqt];
                                                          };
                                                    };
                                              };
                                        }; } in
                              let {
                                sat_s1sqv [Occ=OnceT[0]]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                                [LclId] =
                                    [ds_s1sqh] \r [ds1_s1squ]
                                        GHC.Real.$fEnumRatio_$s$c<= ds1_s1squ ds_s1sqh;
                              } in  sat_s1sqv;
                          GHC.Types.LT ->
                              let {
                                ds_s1sqw [Occ=OnceL, Dmd=<L,U(U,U)>]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer
                                [LclId] =
                                    [ww_s1sq8 ww1_s1sq9 ww2_s1sqa ww3_s1sqb w_s1sqc] \u []
                                        case w_s1sqc of {
                                          GHC.Real.:% ww8_s1sqy [Occ=Once] ww9_s1sqz [Occ=Once] ->
                                              case
                                                  GHC.Real.$w$s$c-
                                                      ww2_s1sqa ww3_s1sqb ww_s1sq8 ww1_s1sq9
                                              of
                                              { (#,#) ww11_s1sqB [Occ=Once] ww12_s1sqC [Occ=Once] ->
                                                    case
                                                        GHC.Real.$w$s$c/
                                                            ww11_s1sqB
                                                            ww12_s1sqC
                                                            GHC.Real.even2
                                                            GHC.Real.$fEnumRatio1
                                                    of
                                                    { (#,#) ww14_s1sqE [Occ=Once]
                                                            ww15_s1sqF [Occ=Once] ->
                                                          case
                                                              GHC.Real.$w$s$c+
                                                                  ww8_s1sqy
                                                                  ww9_s1sqz
                                                                  ww14_s1sqE
                                                                  ww15_s1sqF
                                                          of
                                                          { (#,#) ww17_s1sqH [Occ=Once]
                                                                  ww18_s1sqI [Occ=Once] ->
                                                                GHC.Real.:% [ww17_s1sqH ww18_s1sqI];
                                                          };
                                                    };
                                              };
                                        }; } in
                              let {
                                sat_s1sqK [Occ=OnceT[0]]
                                  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Bool
                                [LclId] =
                                    [ds_s1sqw] \r [ds1_s1sqJ]
                                        GHC.Real.$fEnumRatio_$s$c>= ds1_s1sqJ ds_s1sqw;
                              } in  sat_s1sqK;
                        };
              } in  GHC.List.takeWhile sat_s1sqL sat_s1sqM;
        };

GHC.Real.$fEnumRatio_$snumericEnumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
[GblId,
 Arity=3,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sqN w1_s1sqO w2_s1sqP]
        case w_s1sqN of {
          GHC.Real.:% ww1_s1sqR [Occ=Once] ww2_s1sqS [Occ=Once] ->
              case w1_s1sqO of {
                GHC.Real.:% ww4_s1sqU [Occ=Once] ww5_s1sqV [Occ=Once] ->
                    GHC.Real.$w$snumericEnumFromThenTo
                        ww1_s1sqR ww2_s1sqS ww4_s1sqU ww5_s1sqV w2_s1sqP;
              };
        };

GHC.Real.numericEnumFromThenTo
  :: forall a.
     (GHC.Classes.Ord a, GHC.Real.Fractional a) =>
     a -> a -> a -> [a]
[GblId,
 Arity=5,
 Str=<L,U(A,A,A,C(C1(U)),A,C(C1(U)),A,A)><L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,1*C1(U)),1*C1(C1(U)),A,A)><S,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1sqW
           $dFractional_s1sqX
           eta_s1sqY
           eta1_s1sqZ
           eta2_s1sr0]
        case
            GHC.Real.$wnumericEnumFromThen
                $dFractional_s1sqX eta_s1sqY eta1_s1sqZ
        of
        { (#,#) ww1_s1sr2 [Occ=Once] ww2_s1sr3 [Occ=Once] ->
              let {
                sat_s1srg [Occ=Once] :: [a_a1evf]
                [LclId] =
                    CCCS :! [ww1_s1sr2 ww2_s1sr3]; } in
              let {
                sat_s1srf [Occ=Once, Dmd=<L,C(U)>] :: a_a1evf -> GHC.Types.Bool
                [LclId] =
                    [$dOrd_s1sqW
                     $dFractional_s1sqX
                     eta_s1sqY
                     eta1_s1sqZ
                     eta2_s1sr0] \u []
                        let {
                          $dNum_s1sr4 [Dmd=<L,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                            :: GHC.Num.Num a_a1evf
                          [LclId] =
                              [$dFractional_s1sqX] \u []
                                  GHC.Real.$p1Fractional $dFractional_s1sqX; } in
                        let {
                          mid_s1sr5 [Occ=Once*] :: a_a1evf
                          [LclId] =
                              [$dFractional_s1sqX eta_s1sqY eta1_s1sqZ $dNum_s1sr4] \u []
                                  let {
                                    sat_s1sr7 [Occ=Once] :: a_a1evf
                                    [LclId] =
                                        [$dNum_s1sr4] \u []
                                            GHC.Num.fromInteger $dNum_s1sr4 GHC.Real.even2; } in
                                  let {
                                    sat_s1sr6 [Occ=Once] :: a_a1evf
                                    [LclId] =
                                        [eta_s1sqY eta1_s1sqZ $dNum_s1sr4] \u []
                                            GHC.Num.- $dNum_s1sr4 eta1_s1sqZ eta_s1sqY;
                                  } in  GHC.Real./ $dFractional_s1sqX sat_s1sr6 sat_s1sr7;
                        } in 
                          case GHC.Classes.>= $dOrd_s1sqW eta1_s1sqZ eta_s1sqY of {
                            GHC.Types.False ->
                                let {
                                  ds_s1sr9 [Occ=OnceL] :: a_a1evf
                                  [LclId] =
                                      [eta2_s1sr0 $dNum_s1sr4 mid_s1sr5] \u []
                                          GHC.Num.+ $dNum_s1sr4 eta2_s1sr0 mid_s1sr5; } in
                                let {
                                  sat_s1srb [Occ=OnceT[0]] :: a_a1evf -> GHC.Types.Bool
                                  [LclId] =
                                      [$dOrd_s1sqW ds_s1sr9] \r [ds1_s1sra]
                                          GHC.Classes.>= $dOrd_s1sqW ds1_s1sra ds_s1sr9;
                                } in  sat_s1srb;
                            GHC.Types.True ->
                                let {
                                  ds_s1src [Occ=OnceL] :: a_a1evf
                                  [LclId] =
                                      [eta2_s1sr0 $dNum_s1sr4 mid_s1sr5] \u []
                                          GHC.Num.+ $dNum_s1sr4 eta2_s1sr0 mid_s1sr5; } in
                                let {
                                  sat_s1sre [Occ=OnceT[0]] :: a_a1evf -> GHC.Types.Bool
                                  [LclId] =
                                      [$dOrd_s1sqW ds_s1src] \r [ds1_s1srd]
                                          GHC.Classes.<= $dOrd_s1sqW ds1_s1srd ds_s1src;
                                } in  sat_s1sre;
                          };
              } in  GHC.List.takeWhile sat_s1srf sat_s1srg;
        };

GHC.Real.fromIntegral [InlPrag=NOINLINE[1]]
  :: forall a b. (GHC.Real.Integral a, GHC.Num.Num b) => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U))><S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1srh $dNum_s1sri eta_s1srj]
        let {
          sat_s1srk [Occ=Once] :: GHC.Integer.Type.Integer
          [LclId] =
              [$dIntegral_s1srh eta_s1srj] \u []
                  GHC.Real.toInteger $dIntegral_s1srh eta_s1srj;
        } in  GHC.Num.fromInteger $dNum_s1sri sat_s1srk;

GHC.Real.realToFrac [InlPrag=NOINLINE[1]]
  :: forall a b. (GHC.Real.Real a, GHC.Real.Fractional b) => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(U))><S(LLLC(S)),1*U(A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_s1srl $dFractional_s1srm eta_s1srn]
        let {
          sat_s1sro [Occ=Once] :: GHC.Real.Rational
          [LclId] =
              [$dReal_s1srl eta_s1srn] \u []
                  GHC.Real.toRational $dReal_s1srl eta_s1srn;
        } in  GHC.Real.fromRational $dFractional_s1srm sat_s1sro;

GHC.Real.showSigned1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['-'#];

GHC.Real.showSigned
  :: forall a.
     GHC.Real.Real a =>
     (a -> GHC.Show.ShowS) -> GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)><L,1*C1(U)><L,1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_s1srp eta_s1srq eta1_s1srr eta2_s1srs]
        let {
          $dNum_s1srt [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>]
            :: GHC.Num.Num a_a1euj
          [LclId] =
              [$dReal_s1srp] \u [] GHC.Real.$p1Real $dReal_s1srp; } in
        let {
          sat_s1srv [Occ=Once] :: a_a1euj
          [LclId] =
              [$dNum_s1srt] \u [] GHC.Num.fromInteger $dNum_s1srt GHC.Real.even1;
        } in 
          case GHC.Real.$p2Real $dReal_s1srp of sat_s1sru {
            __DEFAULT ->
                case GHC.Classes.< sat_s1sru eta2_s1srs sat_s1srv of {
                  GHC.Types.False -> eta_s1srq eta2_s1srs;
                  GHC.Types.True ->
                      case eta1_s1srr of {
                        GHC.Types.I# x_s1sry [Occ=Once] ->
                            let {
                              g1_s1srz [Occ=OnceL*!, Dmd=<L,C(U)>]
                                :: GHC.Base.String -> GHC.Base.String
                              [LclId] =
                                  [eta_s1srq eta2_s1srs $dNum_s1srt] \u []
                                      let {
                                        sat_s1srA [Occ=Once] :: a_a1euj
                                        [LclId] =
                                            [eta2_s1srs $dNum_s1srt] \u []
                                                GHC.Num.negate $dNum_s1srt eta2_s1srs;
                                      } in  eta_s1srq sat_s1srA;
                            } in 
                              case ># [x_s1sry 6#] of {
                                __DEFAULT ->
                                    let {
                                      sat_s1srE [Occ=OnceT[0]]
                                        :: GHC.Base.String -> [GHC.Types.Char]
                                      [LclId] =
                                          [g1_s1srz] \r [x1_s1srC]
                                              let {
                                                sat_s1srD [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_s1srz x1_s1srC] \u [] g1_s1srz x1_s1srC;
                                              } in  : [GHC.Real.showSigned1 sat_s1srD];
                                    } in  sat_s1srE;
                                1# ->
                                    let {
                                      sat_s1srJ [Occ=OnceT[0]]
                                        :: GHC.Base.String -> [GHC.Types.Char]
                                      [LclId] =
                                          [g1_s1srz] \r [x1_s1srF]
                                              let {
                                                sat_s1srH [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_s1srz x1_s1srF] \u []
                                                        let {
                                                          sat_s1srG [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2
                                                                       x1_s1srF];
                                                        } in  g1_s1srz sat_s1srG; } in
                                              let {
                                                sat_s1srI [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    CCCS :! [GHC.Real.showSigned1 sat_s1srH];
                                              } in  : [GHC.Show.$fShow(,)4 sat_s1srI];
                                    } in  sat_s1srJ;
                              };
                      };
                };
          };

GHC.Real.even [InlPrag=INLINABLE]
  :: forall a. GHC.Real.Integral a => a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,1*C1(C1(U)),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1srK eta_s1srL]
        case
            GHC.Real.$p1Integral $dIntegral_s1srK
        of
        $dReal_s1srM [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1srN [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_a1eq0
                [LclId] =
                    [$dReal_s1srM] \u [] GHC.Real.$p1Real $dReal_s1srM; } in
              let {
                sat_s1srS [Occ=Once] :: a_a1eq0
                [LclId] =
                    [$dNum_s1srN] \u []
                        GHC.Num.fromInteger $dNum_s1srN GHC.Real.even1; } in
              let {
                sat_s1srR [Occ=Once] :: a_a1eq0
                [LclId] =
                    [$dIntegral_s1srK eta_s1srL $dNum_s1srN] \u []
                        let {
                          sat_s1srQ [Occ=Once] :: a_a1eq0
                          [LclId] =
                              [$dNum_s1srN] \u [] GHC.Num.fromInteger $dNum_s1srN GHC.Real.even2;
                        } in  GHC.Real.rem $dIntegral_s1srK eta_s1srL sat_s1srQ;
              } in 
                case GHC.Real.$p2Real $dReal_s1srM of sat_s1srO {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_s1srO of sat_s1srP {
                        __DEFAULT -> GHC.Classes.== sat_s1srP sat_s1srR sat_s1srS;
                      };
                };
        };

GHC.Real.odd [InlPrag=INLINABLE]
  :: forall a. GHC.Real.Integral a => a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1srT x_s1srU]
        case GHC.Real.even $dIntegral_s1srT x_s1srU of {
          GHC.Types.False -> GHC.Types.True [];
          GHC.Types.True -> GHC.Types.False [];
        };

lvl3_r1j3b :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.$fEnumRatio1 GHC.Real.even2];

lvl4_r1j3c :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "round default defn: Bad value"#;

GHC.Real.$fRealFracRatio1 :: forall b. b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl4_r1j3c of sat_s1srW {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1srW;
        };

GHC.Real.$dmround
  :: forall a.
     GHC.Real.RealFrac a =>
     forall b. GHC.Real.Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,A,A,1*C1(U)),1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U(U(U,U),U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s1srX eta_s1srY eta1_s1srZ]
        let {
          ds_s1ss0 [Dmd=<L,U(1*U,1*U)>] :: (b_a1eBu, a_a1dNs)
          [LclId] =
              [$dRealFrac_s1srX eta_s1srY eta1_s1srZ] \u []
                  GHC.Real.properFraction $dRealFrac_s1srX eta_s1srY eta1_s1srZ;
        } in 
          case
              GHC.Real.$p1RealFrac $dRealFrac_s1srX
          of
          $dReal_s1ss1 [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p2Real $dReal_s1ss1
                of
                $dOrd_s1ss2 [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Classes.$p1Ord $dOrd_s1ss2
                      of
                      $dEq_s1ss3 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                      { __DEFAULT ->
                            let {
                              $dNum_s1ss4 [Dmd=<L,U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U))>]
                                :: GHC.Num.Num a_a1dNs
                              [LclId] =
                                  [$dReal_s1ss1] \u [] GHC.Real.$p1Real $dReal_s1ss1; } in
                            let {
                              r_s1ss5 :: a_a1dNs
                              [LclId] =
                                  [ds_s1ss0] \u []
                                      case ds_s1ss0 of {
                                        (,) _ [Occ=Dead] r1_s1ss8 [Occ=Once] -> r1_s1ss8;
                                      }; } in
                            let {
                              ds1_s1ss9 :: a_a1dNs
                              [LclId] =
                                  [$dRealFrac_s1srX $dNum_s1ss4 r_s1ss5] \u []
                                      let {
                                        sat_s1ssd [Occ=Once] :: a_a1dNs
                                        [LclId] =
                                            [$dRealFrac_s1srX $dNum_s1ss4 r_s1ss5] \u []
                                                let {
                                                  sat_s1ssc [Occ=Once] :: a_a1dNs
                                                  [LclId] =
                                                      [$dRealFrac_s1srX] \u []
                                                          case
                                                              GHC.Real.$p2RealFrac $dRealFrac_s1srX
                                                          of
                                                          sat_s1ssb
                                                          { __DEFAULT ->
                                                                GHC.Real.fromRational
                                                                    sat_s1ssb lvl3_r1j3b;
                                                          }; } in
                                                let {
                                                  sat_s1ssa [Occ=Once] :: a_a1dNs
                                                  [LclId] =
                                                      [$dNum_s1ss4 r_s1ss5] \u []
                                                          GHC.Num.abs $dNum_s1ss4 r_s1ss5;
                                                } in  GHC.Num.- $dNum_s1ss4 sat_s1ssa sat_s1ssc;
                                      } in  GHC.Num.signum $dNum_s1ss4 sat_s1ssd; } in
                            let {
                              n_s1sse :: b_a1eBu
                              [LclId] =
                                  [ds_s1ss0] \u []
                                      case ds_s1ss0 of {
                                        (,) n1_s1ssg [Occ=Once] _ [Occ=Dead] -> n1_s1ssg;
                                      }; } in
                            let {
                              sat_s1ssj [Occ=Once] :: a_a1dNs
                              [LclId] =
                                  [$dNum_s1ss4] \u []
                                      let {
                                        sat_s1ssi [Occ=Once] :: a_a1dNs
                                        [LclId] =
                                            [$dNum_s1ss4] \u []
                                                GHC.Num.fromInteger
                                                    $dNum_s1ss4 GHC.Real.$fEnumRatio1;
                                      } in  GHC.Num.negate $dNum_s1ss4 sat_s1ssi;
                            } in 
                              case GHC.Classes.== $dEq_s1ss3 ds1_s1ss9 sat_s1ssj of {
                                GHC.Types.False ->
                                    let {
                                      sat_s1sss [Occ=Once] :: a_a1dNs
                                      [LclId] =
                                          [$dNum_s1ss4] \u []
                                              GHC.Num.fromInteger $dNum_s1ss4 GHC.Real.even1;
                                    } in 
                                      let-no-escape {
                                        m_s1ssl [Occ=Once*T[0], Dmd=<L,1*U>] :: b_a1eBu
                                        [LclId[JoinId(0)], Unf=OtherCon []] =
                                            [eta_s1srY
                                             $dOrd_s1ss2
                                             $dNum_s1ss4
                                             r_s1ss5
                                             n_s1sse] \r []
                                                case
                                                    GHC.Real.$p1Integral eta_s1srY
                                                of
                                                $dReal1_s1ssm [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                                { __DEFAULT ->
                                                      case
                                                          GHC.Real.$p1Real $dReal1_s1ssm
                                                      of
                                                      $dNum1_s1ssn [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                                      { __DEFAULT ->
                                                            let {
                                                              sat_s1sso [Occ=Once] :: a_a1dNs
                                                              [LclId] =
                                                                  [$dNum_s1ss4] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_s1ss4
                                                                          GHC.Real.even1;
                                                            } in 
                                                              case
                                                                  GHC.Classes.<
                                                                      $dOrd_s1ss2 r_s1ss5 sat_s1sso
                                                              of
                                                              { GHC.Types.False ->
                                                                    let {
                                                                      sat_s1ssq [Occ=Once]
                                                                        :: b_a1eBu
                                                                      [LclId] =
                                                                          [$dNum1_s1ssn] \u []
                                                                              GHC.Num.fromInteger
                                                                                  $dNum1_s1ssn
                                                                                  GHC.Real.$fEnumRatio1;
                                                                    } in 
                                                                      GHC.Num.+
                                                                          $dNum1_s1ssn
                                                                          n_s1sse
                                                                          sat_s1ssq;
                                                                GHC.Types.True ->
                                                                    let {
                                                                      sat_s1ssr [Occ=Once]
                                                                        :: b_a1eBu
                                                                      [LclId] =
                                                                          [$dNum1_s1ssn] \u []
                                                                              GHC.Num.fromInteger
                                                                                  $dNum1_s1ssn
                                                                                  GHC.Real.$fEnumRatio1;
                                                                    } in 
                                                                      GHC.Num.-
                                                                          $dNum1_s1ssn
                                                                          n_s1sse
                                                                          sat_s1ssr;
                                                              };
                                                      };
                                                };
                                      } in 
                                        case GHC.Classes.== $dEq_s1ss3 ds1_s1ss9 sat_s1sss of {
                                          GHC.Types.False ->
                                              let {
                                                sat_s1ssu [Occ=Once] :: a_a1dNs
                                                [LclId] =
                                                    [$dNum_s1ss4] \u []
                                                        GHC.Num.fromInteger
                                                            $dNum_s1ss4 GHC.Real.$fEnumRatio1;
                                              } in 
                                                case
                                                    GHC.Classes.== $dEq_s1ss3 ds1_s1ss9 sat_s1ssu
                                                of
                                                { GHC.Types.False -> GHC.Real.$fRealFracRatio1;
                                                  GHC.Types.True -> m_s1ssl;
                                                };
                                          GHC.Types.True ->
                                              case GHC.Real.even eta_s1srY n_s1sse of {
                                                GHC.Types.False -> m_s1ssl;
                                                GHC.Types.True -> n_s1sse;
                                              };
                                        };
                                GHC.Types.True -> n_s1sse;
                              };
                      };
                };
          };

GHC.Real.integralEnumFrom
  :: forall a. (GHC.Real.Integral a, GHC.Enum.Bounded a) => a -> [a]
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,1*U(A,1*U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1ssx $dBounded_s1ssy eta_s1ssz]
        let {
          f_s1ssA [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
            :: GHC.Real.Real a_a1eoa
          [LclId] =
              [$dIntegral_s1ssx] \s []
                  GHC.Real.$p1Integral $dIntegral_s1ssx; } in
        let {
          f1_s1ssB [Occ=OnceL, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
            :: GHC.Num.Num a_a1eoa
          [LclId] =
              [f_s1ssA] \u [] GHC.Real.$p1Real f_s1ssA; } in
        let {
          sat_s1ssD [Occ=Once] :: a_a1eoa
          [LclId] =
              [$dBounded_s1ssy] \u [] GHC.Enum.maxBound $dBounded_s1ssy;
        } in 
          case
              GHC.Real.toInteger $dIntegral_s1ssx sat_s1ssD
          of
          lim_s1ssC [Dmd=<S,U>]
          { __DEFAULT ->
                let {
                  go_s1ssE [Occ=LoopBreaker] :: GHC.Integer.Type.Integer -> [a_a1eoa]
                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                      sat-only [f1_s1ssB lim_s1ssC go_s1ssE] \r [x_s1ssF]
                          case GHC.Integer.Type.gtInteger# x_s1ssF lim_s1ssC of {
                            __DEFAULT ->
                                let {
                                  sat_s1ssJ [Occ=Once] :: [a_a1eoa]
                                  [LclId] =
                                      [go_s1ssE x_s1ssF] \u []
                                          case
                                              GHC.Integer.Type.plusInteger
                                                  x_s1ssF GHC.Real.$fEnumRatio1
                                          of
                                          sat_s1ssI
                                          { __DEFAULT -> go_s1ssE sat_s1ssI;
                                          }; } in
                                let {
                                  sat_s1ssH [Occ=Once] :: a_a1eoa
                                  [LclId] =
                                      [f1_s1ssB x_s1ssF] \u [] GHC.Num.fromInteger f1_s1ssB x_s1ssF;
                                } in  : [sat_s1ssH sat_s1ssJ];
                            1# -> [] [];
                          };
                } in 
                  case GHC.Real.toInteger $dIntegral_s1ssx eta_s1ssz of sat_s1ssK {
                    __DEFAULT -> go_s1ssE sat_s1ssK;
                  };
          };

GHC.Real.integralEnumFromThen
  :: forall a.
     (GHC.Real.Integral a, GHC.Enum.Bounded a) =>
     a -> a -> [a]
[GblId,
 Arity=4,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,1*U(1*U,1*U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1ssL $dBounded_s1ssM eta_s1ssN eta1_s1ssO]
        case
            GHC.Real.toInteger $dIntegral_s1ssL eta1_s1ssO
        of
        i_n2_s1ssP [Dmd=<S,U>]
        { __DEFAULT ->
              case
                  GHC.Real.toInteger $dIntegral_s1ssL eta_s1ssN
              of
              i_n1_s1ssQ [Dmd=<S,U>]
              { __DEFAULT ->
                    case GHC.Integer.Type.geInteger# i_n2_s1ssP i_n1_s1ssQ of {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.minusInteger i_n2_s1ssP i_n1_s1ssQ
                          of
                          delta_s1ssS [Dmd=<S,U>]
                          { __DEFAULT ->
                                let {
                                  f_s1ssT [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
                                    :: GHC.Real.Real a_a1enm
                                  [LclId] =
                                      [$dIntegral_s1ssL] \s []
                                          GHC.Real.$p1Integral $dIntegral_s1ssL; } in
                                let {
                                  f1_s1ssU [Occ=OnceL*, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
                                    :: GHC.Num.Num a_a1enm
                                  [LclId] =
                                      [f_s1ssT] \u [] GHC.Real.$p1Real f_s1ssT;
                                } in 
                                  case GHC.Integer.Type.geInteger# delta_s1ssS GHC.Real.even1 of {
                                    __DEFAULT ->
                                        let {
                                          sat_s1ssX [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1ssM] \u []
                                                  GHC.Enum.minBound $dBounded_s1ssM;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1ssL sat_s1ssX
                                          of
                                          lim_s1ssW [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1ssY [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1ssS
                                                                f1_s1ssU
                                                                lim_s1ssW
                                                                go_s1ssY] \r [x_s1ssZ]
                                                          case
                                                              GHC.Integer.Type.ltInteger#
                                                                  x_s1ssZ lim_s1ssW
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1st3 [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1ssS
                                                                       go_s1ssY
                                                                       x_s1ssZ] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1ssZ
                                                                                  delta_s1ssS
                                                                          of
                                                                          sat_s1st2
                                                                          { __DEFAULT ->
                                                                                go_s1ssY sat_s1st2;
                                                                          }; } in
                                                                let {
                                                                  sat_s1st1 [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1ssU x_s1ssZ] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1ssU x_s1ssZ;
                                                                } in  : [sat_s1st1 sat_s1st3];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1ssY i_n1_s1ssQ;
                                          };
                                    1# ->
                                        let {
                                          sat_s1st5 [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1ssM] \u []
                                                  GHC.Enum.minBound $dBounded_s1ssM;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1ssL sat_s1st5
                                          of
                                          lim_s1st4 [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1st6 [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1ssS
                                                                f1_s1ssU
                                                                lim_s1st4
                                                                go_s1st6] \r [x_s1st7]
                                                          case
                                                              GHC.Integer.Type.gtInteger#
                                                                  x_s1st7 lim_s1st4
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1stb [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1ssS
                                                                       go_s1st6
                                                                       x_s1st7] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1st7
                                                                                  delta_s1ssS
                                                                          of
                                                                          sat_s1sta
                                                                          { __DEFAULT ->
                                                                                go_s1st6 sat_s1sta;
                                                                          }; } in
                                                                let {
                                                                  sat_s1st9 [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1ssU x_s1st7] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1ssU x_s1st7;
                                                                } in  : [sat_s1st9 sat_s1stb];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1st6 i_n1_s1ssQ;
                                          };
                                  };
                          };
                      1# ->
                          case
                              GHC.Integer.Type.minusInteger i_n2_s1ssP i_n1_s1ssQ
                          of
                          delta_s1stc [Dmd=<S,U>]
                          { __DEFAULT ->
                                let {
                                  f_s1std [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
                                    :: GHC.Real.Real a_a1enm
                                  [LclId] =
                                      [$dIntegral_s1ssL] \s []
                                          GHC.Real.$p1Integral $dIntegral_s1ssL; } in
                                let {
                                  f1_s1ste [Occ=OnceL*, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
                                    :: GHC.Num.Num a_a1enm
                                  [LclId] =
                                      [f_s1std] \u [] GHC.Real.$p1Real f_s1std;
                                } in 
                                  case GHC.Integer.Type.geInteger# delta_s1stc GHC.Real.even1 of {
                                    __DEFAULT ->
                                        let {
                                          sat_s1sth [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1ssM] \u []
                                                  GHC.Enum.maxBound $dBounded_s1ssM;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1ssL sat_s1sth
                                          of
                                          lim_s1stg [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1sti [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1stc
                                                                f1_s1ste
                                                                lim_s1stg
                                                                go_s1sti] \r [x_s1stj]
                                                          case
                                                              GHC.Integer.Type.ltInteger#
                                                                  x_s1stj lim_s1stg
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1stn [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1stc
                                                                       go_s1sti
                                                                       x_s1stj] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1stj
                                                                                  delta_s1stc
                                                                          of
                                                                          sat_s1stm
                                                                          { __DEFAULT ->
                                                                                go_s1sti sat_s1stm;
                                                                          }; } in
                                                                let {
                                                                  sat_s1stl [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1ste x_s1stj] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1ste x_s1stj;
                                                                } in  : [sat_s1stl sat_s1stn];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1sti i_n1_s1ssQ;
                                          };
                                    1# ->
                                        let {
                                          sat_s1stp [Occ=Once] :: a_a1enm
                                          [LclId] =
                                              [$dBounded_s1ssM] \u []
                                                  GHC.Enum.maxBound $dBounded_s1ssM;
                                        } in 
                                          case
                                              GHC.Real.toInteger $dIntegral_s1ssL sat_s1stp
                                          of
                                          lim_s1sto [Dmd=<S,U>]
                                          { __DEFAULT ->
                                                let {
                                                  go_s1stq [Occ=LoopBreaker]
                                                    :: GHC.Integer.Type.Integer -> [a_a1enm]
                                                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                                      sat-only [delta_s1stc
                                                                f1_s1ste
                                                                lim_s1sto
                                                                go_s1stq] \r [x_s1str]
                                                          case
                                                              GHC.Integer.Type.gtInteger#
                                                                  x_s1str lim_s1sto
                                                          of
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1stv [Occ=Once] :: [a_a1enm]
                                                                  [LclId] =
                                                                      [delta_s1stc
                                                                       go_s1stq
                                                                       x_s1str] \u []
                                                                          case
                                                                              GHC.Integer.Type.plusInteger
                                                                                  x_s1str
                                                                                  delta_s1stc
                                                                          of
                                                                          sat_s1stu
                                                                          { __DEFAULT ->
                                                                                go_s1stq sat_s1stu;
                                                                          }; } in
                                                                let {
                                                                  sat_s1stt [Occ=Once] :: a_a1enm
                                                                  [LclId] =
                                                                      [f1_s1ste x_s1str] \u []
                                                                          GHC.Num.fromInteger
                                                                              f1_s1ste x_s1str;
                                                                } in  : [sat_s1stt sat_s1stv];
                                                            1# -> [] [];
                                                          };
                                                } in  go_s1stq i_n1_s1ssQ;
                                          };
                                  };
                          };
                    };
              };
        };

GHC.Real.integralEnumFromTo
  :: forall a. GHC.Real.Integral a => a -> a -> [a]
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1stw eta_s1stx eta1_s1sty]
        let {
          f_s1stz [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
            :: GHC.Real.Real a_a1en9
          [LclId] =
              [$dIntegral_s1stw] \s []
                  GHC.Real.$p1Integral $dIntegral_s1stw; } in
        let {
          f1_s1stA [Occ=OnceL, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
            :: GHC.Num.Num a_a1en9
          [LclId] =
              [f_s1stz] \u [] GHC.Real.$p1Real f_s1stz;
        } in 
          case
              GHC.Real.toInteger $dIntegral_s1stw eta1_s1sty
          of
          lim_s1stB [Dmd=<S,U>]
          { __DEFAULT ->
                let {
                  go_s1stC [Occ=LoopBreaker] :: GHC.Integer.Type.Integer -> [a_a1en9]
                  [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                      sat-only [f1_s1stA lim_s1stB go_s1stC] \r [x_s1stD]
                          case GHC.Integer.Type.gtInteger# x_s1stD lim_s1stB of {
                            __DEFAULT ->
                                let {
                                  sat_s1stH [Occ=Once] :: [a_a1en9]
                                  [LclId] =
                                      [go_s1stC x_s1stD] \u []
                                          case
                                              GHC.Integer.Type.plusInteger
                                                  x_s1stD GHC.Real.$fEnumRatio1
                                          of
                                          sat_s1stG
                                          { __DEFAULT -> go_s1stC sat_s1stG;
                                          }; } in
                                let {
                                  sat_s1stF [Occ=Once] :: a_a1en9
                                  [LclId] =
                                      [f1_s1stA x_s1stD] \u [] GHC.Num.fromInteger f1_s1stA x_s1stD;
                                } in  : [sat_s1stF sat_s1stH];
                            1# -> [] [];
                          };
                } in 
                  case GHC.Real.toInteger $dIntegral_s1stw eta_s1stx of sat_s1stI {
                    __DEFAULT -> go_s1stC sat_s1stI;
                  };
          };

GHC.Real.integralEnumFromThenTo
  :: forall a. GHC.Real.Integral a => a -> a -> a -> [a]
[GblId,
 Arity=4,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1stJ eta_s1stK eta1_s1stL eta2_s1stM]
        case
            GHC.Real.toInteger $dIntegral_s1stJ eta_s1stK
        of
        x_s1stN [Dmd=<S,U>]
        { __DEFAULT ->
              case GHC.Real.toInteger $dIntegral_s1stJ eta1_s1stL of sat_s1stP {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.minusInteger sat_s1stP x_s1stN
                    of
                    delta_s1stO [Dmd=<S,U>]
                    { __DEFAULT ->
                          let {
                            f_s1stQ [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
                              :: GHC.Real.Real a_a1emS
                            [LclId] =
                                [$dIntegral_s1stJ] \s []
                                    GHC.Real.$p1Integral $dIntegral_s1stJ; } in
                          let {
                            f1_s1stR [Occ=OnceL*, Dmd=<L,U(A,A,A,A,A,A,C(U))>]
                              :: GHC.Num.Num a_a1emS
                            [LclId] =
                                [f_s1stQ] \u [] GHC.Real.$p1Real f_s1stQ;
                          } in 
                            case GHC.Integer.Type.geInteger# delta_s1stO GHC.Real.even1 of {
                              __DEFAULT ->
                                  case
                                      GHC.Real.toInteger $dIntegral_s1stJ eta2_s1stM
                                  of
                                  lim_s1stT [Dmd=<S,U>]
                                  { __DEFAULT ->
                                        let {
                                          go_s1stU [Occ=LoopBreaker]
                                            :: GHC.Integer.Type.Integer -> [a_a1emS]
                                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                              sat-only [delta_s1stO
                                                        f1_s1stR
                                                        lim_s1stT
                                                        go_s1stU] \r [x1_s1stV]
                                                  case
                                                      GHC.Integer.Type.ltInteger# x1_s1stV lim_s1stT
                                                  of
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_s1stZ [Occ=Once] :: [a_a1emS]
                                                          [LclId] =
                                                              [delta_s1stO go_s1stU x1_s1stV] \u []
                                                                  case
                                                                      GHC.Integer.Type.plusInteger
                                                                          x1_s1stV delta_s1stO
                                                                  of
                                                                  sat_s1stY
                                                                  { __DEFAULT -> go_s1stU sat_s1stY;
                                                                  }; } in
                                                        let {
                                                          sat_s1stX [Occ=Once] :: a_a1emS
                                                          [LclId] =
                                                              [f1_s1stR x1_s1stV] \u []
                                                                  GHC.Num.fromInteger
                                                                      f1_s1stR x1_s1stV;
                                                        } in  : [sat_s1stX sat_s1stZ];
                                                    1# -> [] [];
                                                  };
                                        } in  go_s1stU x_s1stN;
                                  };
                              1# ->
                                  case
                                      GHC.Real.toInteger $dIntegral_s1stJ eta2_s1stM
                                  of
                                  lim_s1su0 [Dmd=<S,U>]
                                  { __DEFAULT ->
                                        let {
                                          go_s1su1 [Occ=LoopBreaker]
                                            :: GHC.Integer.Type.Integer -> [a_a1emS]
                                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                              sat-only [delta_s1stO
                                                        f1_s1stR
                                                        lim_s1su0
                                                        go_s1su1] \r [x1_s1su2]
                                                  case
                                                      GHC.Integer.Type.gtInteger# x1_s1su2 lim_s1su0
                                                  of
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_s1su6 [Occ=Once] :: [a_a1emS]
                                                          [LclId] =
                                                              [delta_s1stO go_s1su1 x1_s1su2] \u []
                                                                  case
                                                                      GHC.Integer.Type.plusInteger
                                                                          x1_s1su2 delta_s1stO
                                                                  of
                                                                  sat_s1su5
                                                                  { __DEFAULT -> go_s1su1 sat_s1su5;
                                                                  }; } in
                                                        let {
                                                          sat_s1su4 [Occ=Once] :: a_a1emS
                                                          [LclId] =
                                                              [f1_s1stR x1_s1su2] \u []
                                                                  GHC.Num.fromInteger
                                                                      f1_s1stR x1_s1su2;
                                                        } in  : [sat_s1su4 sat_s1su6];
                                                    1# -> [] [];
                                                  };
                                        } in  go_s1su1 x_s1stN;
                                  };
                            };
                    };
              };
        };

GHC.Real.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Real.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$trModule4];

GHC.Real.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Real"#;

GHC.Real.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$trModule2];

GHC.Real.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Real.$trModule3
                                     GHC.Real.$trModule1];

$krep_r1j3d :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Integer.Type.$tcInteger
                                              GHC.Types.[]];

$krep1_r1j3e :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.Real.$tcFractional1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*
                                         $krep1_r1j3e];

$krep2_r1j3f :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep3_r1j3g :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep2_r1j3f];

$krep4_r1j3h :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep3_r1j3g];

$krep5_r1j3i :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep_r1j3d];

$krep6_r1j3j :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_r1j3f GHC.Types.[]];

$krep7_r1j3k :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_r1j3f $krep6_r1j3j];

$krep8_r1j3l :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc(,)
                                              $krep7_r1j3k];

$krep9_r1j3m :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep8_r1j3l];

$krep10_r1j3n :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep9_r1j3m];

$krep11_r1j3o :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Num.$tcNum
                                              $krep6_r1j3j];

$krep12_r1j3p :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Enum.$tcEnum
                                              $krep6_r1j3j];

$krep13_r1j3q :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Classes.$tcOrd
                                              $krep6_r1j3j];

GHC.Real.$tcRatio2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Ratio"#;

GHC.Real.$tcRatio1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcRatio2];

GHC.Real.$tcRatio :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17658523810845794968##
                                    1271393732863050253##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcRatio1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep14_r1j3r :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcRatio
                                              $krep6_r1j3j];

$krep15_r1j3s :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep14_r1j3r];

GHC.Real.$tc':%1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep15_r1j3s];

GHC.Real.$tc':%3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "':%"#;

GHC.Real.$tc':%2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc':%3];

GHC.Real.$tc':% :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11952989868638128372##
                                    6861245286732044789##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc':%2
                                    1#
                                    GHC.Real.$tc':%1];

$krep16_r1j3t :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r1j3d GHC.Types.[]];

$krep17_r1j3u :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcRatio
                                              $krep16_r1j3t];

$krep18_r1j3v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r1j3f $krep17_r1j3u];

$krep19_r1j3w :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep17_r1j3u $krep2_r1j3f];

GHC.Real.$tcReal2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Real"#;

GHC.Real.$tcReal1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcReal2];

GHC.Real.$tcReal :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1826502536394630182##
                                    14487785779892251413##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcReal1
                                    0#
                                    GHC.Real.$tcFractional1];

$krep20_r1j3x :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcReal
                                              $krep6_r1j3j];

$krep21_r1j3y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep18_r1j3v $krep20_r1j3x];

$krep22_r1j3z :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep13_r1j3q $krep21_r1j3y];

GHC.Real.$tc'C:Real1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1j3o $krep22_r1j3z];

GHC.Real.$tc'C:Real3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Real"#;

GHC.Real.$tc'C:Real2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc'C:Real3];

GHC.Real.$tc'C:Real :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5938283050841830427##
                                    8926187074226767634##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc'C:Real2
                                    1#
                                    GHC.Real.$tc'C:Real1];

GHC.Real.$tcIntegral2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Integral"#;

GHC.Real.$tcIntegral1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcIntegral2];

GHC.Real.$tcIntegral :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16601157811546713973##
                                    3304955164956033666##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcIntegral1
                                    0#
                                    GHC.Real.$tcFractional1];

$krep23_r1j3A :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcIntegral
                                              $krep6_r1j3j];

$krep24_r1j3B :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r1j3i $krep23_r1j3A];

$krep25_r1j3C :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_r1j3n $krep24_r1j3B];

$krep26_r1j3D :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_r1j3n $krep25_r1j3C];

$krep27_r1j3E :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep26_r1j3D];

$krep28_r1j3F :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep27_r1j3E];

$krep29_r1j3G :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep28_r1j3F];

$krep30_r1j3H :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep29_r1j3G];

$krep31_r1j3I :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep12_r1j3p $krep30_r1j3H];

GHC.Real.$tc'C:Integral1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep20_r1j3x $krep31_r1j3I];

GHC.Real.$tc'C:Integral3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Integral"#;

GHC.Real.$tc'C:Integral2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc'C:Integral3];

GHC.Real.$tc'C:Integral :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12141017740256829283##
                                    17564033539811245778##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc'C:Integral2
                                    1#
                                    GHC.Real.$tc'C:Integral1];

GHC.Real.$tcFractional3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Fractional"#;

GHC.Real.$tcFractional2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcFractional3];

GHC.Real.$tcFractional :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14968870971062750857##
                                    13774835939651899219##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcFractional2
                                    0#
                                    GHC.Real.$tcFractional1];

$krep32_r1j3J :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Real.$tcFractional
                                              $krep6_r1j3j];

$krep33_r1j3K :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep19_r1j3w $krep32_r1j3J];

$krep34_r1j3L :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r1j3g $krep33_r1j3K];

$krep35_r1j3M :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r1j3h $krep34_r1j3L];

GHC.Real.$tc'C:Fractional1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1j3o $krep35_r1j3M];

GHC.Real.$tc'C:Fractional3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Fractional"#;

GHC.Real.$tc'C:Fractional2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tc'C:Fractional3];

GHC.Real.$tc'C:Fractional :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15706435530565718930##
                                    11021884564355505453##
                                    GHC.Real.$trModule
                                    GHC.Real.$tc'C:Fractional2
                                    1#
                                    GHC.Real.$tc'C:Fractional1];

GHC.Real.$tcRealFrac2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "RealFrac"#;

GHC.Real.$tcRealFrac1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Real.$tcRealFrac2];

GHC.Real.$tcRealFrac :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2318913099678420819##
                                    6373121509494083706##
                                    GHC.Real.$trModule
                                    GHC.Real.$tcRealFrac1
                                    0#
                                    GHC.Real.$tcFractional1];

GHC.Real.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     a -> a -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1su7 ww_s1su8 ww1_s1su9 ww2_s1sua ww3_s1sub]
        case
            GHC.Real.$p1Integral w_s1su7
        of
        $dReal_s1suc [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1sud [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
                  :: GHC.Num.Num a_s1hBR
                [LclId] =
                    [$dReal_s1suc] \u [] GHC.Real.$p1Real $dReal_s1suc; } in
              let {
                sat_s1sug [Occ=Once] :: a_s1hBR
                [LclId] =
                    [ww1_s1su9 ww2_s1sua $dNum_s1sud] \u []
                        GHC.Num.* $dNum_s1sud ww2_s1sua ww1_s1su9; } in
              let {
                sat_s1suf [Occ=Once] :: a_s1hBR
                [LclId] =
                    [ww_s1su8 ww3_s1sub $dNum_s1sud] \u []
                        GHC.Num.* $dNum_s1sud ww_s1su8 ww3_s1sub;
              } in 
                case GHC.Real.$p2Real $dReal_s1suc of sat_s1sue {
                  __DEFAULT -> GHC.Classes.< sat_s1sue sat_s1suf sat_s1sug;
                };
        };

GHC.Real.$fOrdRatio_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1suh w1_s1sui w2_s1suj]
        case w1_s1sui of {
          GHC.Real.:% ww1_s1sul [Occ=Once] ww2_s1sum [Occ=Once] ->
              case w2_s1suj of {
                GHC.Real.:% ww4_s1suo [Occ=Once] ww5_s1sup [Occ=Once] ->
                    GHC.Real.$w$c< w_s1suh ww1_s1sul ww2_s1sum ww4_s1suo ww5_s1sup;
              };
        };

GHC.Real.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     a -> a -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1suq ww_s1sur ww1_s1sus ww2_s1sut ww3_s1suu]
        case
            GHC.Real.$p1Integral w_s1suq
        of
        $dReal_s1suv [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1suw [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
                  :: GHC.Num.Num a_s1hC6
                [LclId] =
                    [$dReal_s1suv] \u [] GHC.Real.$p1Real $dReal_s1suv; } in
              let {
                sat_s1suz [Occ=Once] :: a_s1hC6
                [LclId] =
                    [ww1_s1sus ww2_s1sut $dNum_s1suw] \u []
                        GHC.Num.* $dNum_s1suw ww2_s1sut ww1_s1sus; } in
              let {
                sat_s1suy [Occ=Once] :: a_s1hC6
                [LclId] =
                    [ww_s1sur ww3_s1suu $dNum_s1suw] \u []
                        GHC.Num.* $dNum_s1suw ww_s1sur ww3_s1suu;
              } in 
                case GHC.Real.$p2Real $dReal_s1suv of sat_s1sux {
                  __DEFAULT -> GHC.Classes.<= sat_s1sux sat_s1suy sat_s1suz;
                };
        };

GHC.Real.$fOrdRatio_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1suA w1_s1suB w2_s1suC]
        case w1_s1suB of {
          GHC.Real.:% ww1_s1suE [Occ=Once] ww2_s1suF [Occ=Once] ->
              case w2_s1suC of {
                GHC.Real.:% ww4_s1suH [Occ=Once] ww5_s1suI [Occ=Once] ->
                    GHC.Real.$w$c<= w_s1suA ww1_s1suE ww2_s1suF ww4_s1suH ww5_s1suI;
              };
        };

GHC.Real.$fOrdRatio_$cmax
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1suJ x_s1suK y_s1suL]
        case x_s1suK of ww_s1suM {
          GHC.Real.:% ww1_s1suN [Occ=Once] ww2_s1suO [Occ=Once] ->
              case y_s1suL of ww3_s1suP {
                GHC.Real.:% ww4_s1suQ [Occ=Once] ww5_s1suR [Occ=Once] ->
                    case
                        GHC.Real.$w$c<=
                            $dIntegral_s1suJ ww1_s1suN ww2_s1suO ww4_s1suQ ww5_s1suR
                    of
                    { GHC.Types.False -> ww_s1suM;
                      GHC.Types.True -> ww3_s1suP;
                    };
              };
        };

GHC.Real.$fOrdRatio_$cmin
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1suT x_s1suU y_s1suV]
        case x_s1suU of ww_s1suW {
          GHC.Real.:% ww1_s1suX [Occ=Once] ww2_s1suY [Occ=Once] ->
              case y_s1suV of ww3_s1suZ {
                GHC.Real.:% ww4_s1sv0 [Occ=Once] ww5_s1sv1 [Occ=Once] ->
                    case
                        GHC.Real.$w$c<=
                            $dIntegral_s1suT ww1_s1suX ww2_s1suY ww4_s1sv0 ww5_s1sv1
                    of
                    { GHC.Types.False -> ww3_s1suZ;
                      GHC.Types.True -> ww_s1suW;
                    };
              };
        };

GHC.Real.$w$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     a -> a -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(1*U(A,A,C(C1(U)),A,A,A,A),U(1*U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sv3 ww_s1sv4 ww1_s1sv5 ww2_s1sv6 ww3_s1sv7]
        case
            GHC.Real.$p1Integral w_s1sv3
        of
        $dEq_s1sv8 [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p2Real $dEq_s1sv8
              of
              $dEq1_s1sv9 [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Classes.$p1Ord $dEq1_s1sv9
                    of
                    $dEq2_s1sva [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                    { __DEFAULT ->
                          case GHC.Classes.== $dEq2_s1sva ww_s1sv4 ww2_s1sv6 of {
                            GHC.Types.False ->
                                case
                                    GHC.Real.$w$c<= w_s1sv3 ww_s1sv4 ww1_s1sv5 ww2_s1sv6 ww3_s1sv7
                                of
                                { GHC.Types.False -> GHC.Types.GT [];
                                  GHC.Types.True -> GHC.Types.LT [];
                                };
                            GHC.Types.True ->
                                case GHC.Classes.== $dEq2_s1sva ww1_s1sv5 ww3_s1sv7 of {
                                  GHC.Types.False ->
                                      case
                                          GHC.Real.$w$c<=
                                              w_s1sv3 ww_s1sv4 ww1_s1sv5 ww2_s1sv6 ww3_s1sv7
                                      of
                                      { GHC.Types.False -> GHC.Types.GT [];
                                        GHC.Types.True -> GHC.Types.LT [];
                                      };
                                  GHC.Types.True -> GHC.Types.EQ [];
                                };
                          };
                    };
              };
        };

GHC.Real.$fOrdRatio_$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1svf w1_s1svg w2_s1svh]
        case w1_s1svg of {
          GHC.Real.:% ww1_s1svj [Occ=Once] ww2_s1svk [Occ=Once] ->
              case w2_s1svh of {
                GHC.Real.:% ww4_s1svm [Occ=Once] ww5_s1svn [Occ=Once] ->
                    GHC.Real.$w$ccompare
                        w_s1svf ww1_s1svj ww2_s1svk ww4_s1svm ww5_s1svn;
              };
        };

GHC.Real.$fOrdRatio_$c>
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1svo x_s1svp y_s1svq]
        case x_s1svp of {
          GHC.Real.:% ww1_s1svs [Occ=Once] ww2_s1svt [Occ=Once] ->
              case y_s1svq of {
                GHC.Real.:% ww4_s1svv [Occ=Once] ww5_s1svw [Occ=Once] ->
                    case
                        GHC.Real.$w$ccompare
                            $dIntegral_s1svo ww1_s1svs ww2_s1svt ww4_s1svv ww5_s1svw
                    of
                    { __DEFAULT -> GHC.Types.False [];
                      GHC.Types.GT -> GHC.Types.True [];
                    };
              };
        };

GHC.Real.$fOrdRatio_$c>=
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1svy x_s1svz y_s1svA]
        case x_s1svz of {
          GHC.Real.:% ww1_s1svC [Occ=Once] ww2_s1svD [Occ=Once] ->
              case y_s1svA of {
                GHC.Real.:% ww4_s1svF [Occ=Once] ww5_s1svG [Occ=Once] ->
                    case
                        GHC.Real.$w$ccompare
                            $dIntegral_s1svy ww1_s1svC ww2_s1svD ww4_s1svF ww5_s1svG
                    of
                    { __DEFAULT -> GHC.Types.True [];
                      GHC.Types.LT -> GHC.Types.False [];
                    };
              };
        };

GHC.Real.$fOrdRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Classes.Ord (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>m] =
    [] \r [$dIntegral_s1svI]
        let {
          sat_s1svQ [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Real.Ratio a_a1eJ2
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$cmin $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svP [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Real.Ratio a_a1eJ2
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$cmax $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svO [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c>= $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svN [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c> $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svM [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c<= $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svL [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Bool
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$c< $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svK [Occ=Once]
            :: GHC.Real.Ratio a_a1eJ2
               -> GHC.Real.Ratio a_a1eJ2 -> GHC.Types.Ordering
          [LclId] =
              [$dIntegral_s1svI] \r [eta_B2 eta_B1]
                  GHC.Real.$fOrdRatio_$ccompare $dIntegral_s1svI eta_B2 eta_B1; } in
        let {
          sat_s1svJ [Occ=Once] :: GHC.Classes.Eq (GHC.Real.Ratio a_a1eJ2)
          [LclId] =
              [$dIntegral_s1svI] \u []
                  GHC.Real.$fOrdRatio_$cp1Ord $dIntegral_s1svI;
        } in 
          GHC.Classes.C:Ord [sat_s1svJ
                             sat_s1svK
                             sat_s1svL
                             sat_s1svM
                             sat_s1svN
                             sat_s1svO
                             sat_s1svP
                             sat_s1svQ];

GHC.Real.$fNumRatio_$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LLLC(S)LLL)LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,1*C1(U),A,A,A),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1svR w1_s1svS]
        case w1_s1svS of {
          GHC.Real.:% ww1_s1svU [Occ=Once] ww2_s1svV [Occ=Once] ->
              case GHC.Real.$p1Integral w_s1svR of sat_s1svW {
                __DEFAULT ->
                    case GHC.Real.$p1Real sat_s1svW of sat_s1svX {
                      __DEFAULT ->
                          case GHC.Num.negate sat_s1svX ww1_s1svU of dt_s1svY {
                            __DEFAULT -> GHC.Real.:% [dt_s1svY ww2_s1svV];
                          };
                    };
              };
        };

GHC.Real.$fNumRatio_$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LLLLC(S)LL)LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,1*C1(U),A,A),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1svZ w1_s1sw0]
        case w1_s1sw0 of {
          GHC.Real.:% ww1_s1sw2 [Occ=Once] ww2_s1sw3 [Occ=Once] ->
              case GHC.Real.$p1Integral w_s1svZ of sat_s1sw4 {
                __DEFAULT ->
                    case GHC.Real.$p1Real sat_s1sw4 of sat_s1sw5 {
                      __DEFAULT ->
                          case GHC.Num.abs sat_s1sw5 ww1_s1sw2 of dt_s1sw6 {
                            __DEFAULT -> GHC.Real.:% [dt_s1sw6 ww2_s1sw3];
                          };
                    };
              };
        };

GHC.Real.$w$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLC(S)C(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sw7 ww_s1sw8]
        case
            GHC.Real.$p1Integral w_s1sw7
        of
        $dReal_s1sw9 [Dmd=<S(S(LLLLLC(S)C(S))LL),1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1sw9
              of
              $dNum_s1swa [Dmd=<S(LLLLLC(S)C(S)),U(A,A,A,A,A,1*C1(U),1*C1(U))>]
              { __DEFAULT ->
                    case GHC.Num.signum $dNum_s1swa ww_s1sw8 of dt_s1swb {
                      __DEFAULT ->
                          case
                              GHC.Num.fromInteger $dNum_s1swa GHC.Real.$fEnumRatio1
                          of
                          dt1_s1swc
                          { __DEFAULT -> (#,#) [dt_s1swb dt1_s1swc];
                          };
                    };
              };
        };

GHC.Real.$fNumRatio_$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLC(S)C(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SL),1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [w_s1swd w1_s1swe]
        case w1_s1swe of {
          GHC.Real.:% ww1_s1swg [Occ=Once] _ [Occ=Dead] ->
              case GHC.Real.$w$csignum w_s1swd ww1_s1swg of {
                (#,#) ww4_s1swj [Occ=Once] ww5_s1swk [Occ=Once] ->
                    GHC.Real.:% [ww4_s1swj ww5_s1swk];
              };
        };

GHC.Real.$w$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1swl w1_s1swm]
        case
            GHC.Real.$p1Integral w_s1swl
        of
        $dReal_s1swn [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1swn
              of
              $dNum_s1swo [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
              { __DEFAULT ->
                    case GHC.Num.fromInteger $dNum_s1swo w1_s1swm of dt_s1swp {
                      __DEFAULT ->
                          case
                              GHC.Num.fromInteger $dNum_s1swo GHC.Real.$fEnumRatio1
                          of
                          dt1_s1swq
                          { __DEFAULT -> (#,#) [dt_s1swp dt1_s1swq];
                          };
                    };
              };
        };

GHC.Real.$fNumRatio_$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1swr w1_s1sws]
        case GHC.Real.$w$cfromInteger w_s1swr w1_s1sws of {
          (#,#) ww1_s1swu [Occ=Once] ww2_s1swv [Occ=Once] ->
              GHC.Real.:% [ww1_s1swu ww2_s1swv];
        };

GHC.Real.$fRealRatio_$s$ctoRational
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Real.Rational
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1sww] ds_s1sww;

GHC.Real.$fRealRatio_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Rational
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)),U(A,A,A,A,A,A,A,A,C(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1swx w1_s1swy]
        case w1_s1swy of {
          GHC.Real.:% ww1_s1swA [Occ=Once] ww2_s1swB [Occ=Once] ->
              case GHC.Real.toInteger w_s1swx ww1_s1swA of dt_s1swC {
                __DEFAULT ->
                    case GHC.Real.toInteger w_s1swx ww2_s1swB of dt1_s1swD {
                      __DEFAULT -> GHC.Real.:% [dt_s1swC dt1_s1swD];
                    };
              };
        };

GHC.Real.$w$crecip [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1swE ww_s1swF ww1_s1swG]
        case
            GHC.Real.$p1Integral w_s1swE
        of
        $dReal_s1swH [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1swI [Dmd=<L,U(A,A,A,C(U),A,A,C(U))>] :: GHC.Num.Num a_s1hDt
                [LclId] =
                    [$dReal_s1swH] \u [] GHC.Real.$p1Real $dReal_s1swH;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1swH
                of
                $dOrd_s1swJ [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1swL [Occ=Once] :: a_s1hDt
                        [LclId] =
                            [$dNum_s1swI] \u [] GHC.Num.fromInteger $dNum_s1swI GHC.Real.even1;
                      } in 
                        case GHC.Classes.$p1Ord $dOrd_s1swJ of sat_s1swK {
                          __DEFAULT ->
                              case GHC.Classes.== sat_s1swK ww_s1swF sat_s1swL of {
                                GHC.Types.False ->
                                    let {
                                      sat_s1swN [Occ=Once] :: a_s1hDt
                                      [LclId] =
                                          [$dNum_s1swI] \u []
                                              GHC.Num.fromInteger $dNum_s1swI GHC.Real.even1;
                                    } in 
                                      case GHC.Classes.< $dOrd_s1swJ ww_s1swF sat_s1swN of {
                                        GHC.Types.False -> (#,#) [ww1_s1swG ww_s1swF];
                                        GHC.Types.True ->
                                            case GHC.Num.negate $dNum_s1swI ww1_s1swG of dt_s1swP {
                                              __DEFAULT ->
                                                  case
                                                      GHC.Num.negate $dNum_s1swI ww_s1swF
                                                  of
                                                  dt1_s1swQ
                                                  { __DEFAULT -> (#,#) [dt_s1swP dt1_s1swQ];
                                                  };
                                            };
                                      };
                                GHC.Types.True -> GHC.Real.ratioZeroDenominatorError;
                              };
                        };
                };
        };

GHC.Real.$fFractionalRatio_$crecip [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1swS w1_s1swT]
        case w1_s1swT of {
          GHC.Real.:% ww1_s1swV [Occ=Once] ww2_s1swW [Occ=Once] ->
              case GHC.Real.$w$crecip w_s1swS ww1_s1swV ww2_s1swW of {
                (#,#) ww4_s1swY [Occ=Once] ww5_s1swZ [Occ=Once] ->
                    GHC.Real.:% [ww4_s1swY ww5_s1swZ];
              };
        };

GHC.Real.$w$s$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# b, GHC.Real.Ratio GHC.Integer.Type.Integer #)
[GblId,
 Arity=3,
 Str=<L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sx0 ww_s1sx1 ww1_s1sx2]
        let {
          ds_s1sx3 [Dmd=<L,U(1*U,1*U)>]
            :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
          [LclId] =
              [ww_s1sx1 ww1_s1sx2] \u []
                  case GHC.Integer.Type.eqInteger# ww1_s1sx2 GHC.Real.even1 of {
                    __DEFAULT ->
                        case GHC.Integer.Type.quotRemInteger ww_s1sx1 ww1_s1sx2 of {
                          (#,#) ipv_s1sx6 [Occ=Once] ipv1_s1sx7 [Occ=Once] ->
                              (,) [ipv_s1sx6 ipv1_s1sx7];
                        };
                    1# -> GHC.Real.divZeroError;
                  }; } in
        let {
          sat_s1sxj [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId] =
              [ww1_s1sx2 ds_s1sx3] \u []
                  case ds_s1sx3 of {
                    (,) _ [Occ=Dead] r_s1sxh [Occ=Once] ->
                        case r_s1sxh of dt_s1sxi {
                          __DEFAULT -> GHC.Real.:% [dt_s1sxi ww1_s1sx2];
                        };
                  }; } in
        let {
          sat_s1sxe [Occ=Once] :: b_s1hDF
          [LclId] =
              [w_s1sx0 ds_s1sx3] \u []
                  let {
                    sat_s1sxd [Occ=Once] :: GHC.Integer.Type.Integer
                    [LclId] =
                        [ds_s1sx3] \u []
                            case ds_s1sx3 of {
                              (,) q_s1sxb [Occ=Once] _ [Occ=Dead] -> q_s1sxb;
                            };
                  } in 
                    case GHC.Real.$p1Integral w_s1sx0 of sat_s1sx8 {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_s1sx8 of sat_s1sx9 {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1sx9 sat_s1sxd;
                          };
                    };
        } in  (#,#) [sat_s1sxe sat_s1sxj];

GHC.Real.$fEnumRatio_$s$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer
     -> (b, GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1sxk w1_s1sxl]
        case w1_s1sxl of {
          GHC.Real.:% ww1_s1sxn [Occ=Once] ww2_s1sxo [Occ=Once] ->
              case GHC.Real.$w$s$cproperFraction w_s1sxk ww1_s1sxn ww2_s1sxo of {
                (#,#) ww4_s1sxq [Occ=Once] ww5_s1sxr [Occ=Once] ->
                    (,) [ww4_s1sxq ww5_s1sxr];
              };
        };

GHC.Real.$w$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b.
     GHC.Real.Integral b =>
     a -> a -> (# b, GHC.Real.Ratio a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,1*C1(C1(U(1*U,1*U))),A,1*C1(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sxs w1_s1sxt ww_s1sxu ww1_s1sxv]
        let {
          ds_s1sxw [Dmd=<L,U(1*U,1*U)>] :: (a_s1hDR, a_s1hDR)
          [LclId] =
              [w_s1sxs ww_s1sxu ww1_s1sxv] \u []
                  GHC.Real.quotRem w_s1sxs ww_s1sxu ww1_s1sxv; } in
        let {
          sat_s1sxJ [Occ=Once] :: GHC.Real.Ratio a_s1hDR
          [LclId] =
              [ww1_s1sxv ds_s1sxw] \u []
                  case ds_s1sxw of {
                    (,) _ [Occ=Dead] r_s1sxH [Occ=Once] ->
                        case r_s1sxH of dt_s1sxI {
                          __DEFAULT -> GHC.Real.:% [dt_s1sxI ww1_s1sxv];
                        };
                  }; } in
        let {
          sat_s1sxE [Occ=Once] :: b_s1hDT
          [LclId] =
              [w_s1sxs w1_s1sxt ds_s1sxw] \u []
                  let {
                    sat_s1sxD [Occ=Once] :: GHC.Integer.Type.Integer
                    [LclId] =
                        [w_s1sxs ds_s1sxw] \u []
                            let {
                              sat_s1sxC [Occ=Once] :: a_s1hDR
                              [LclId] =
                                  [ds_s1sxw] \u []
                                      case ds_s1sxw of {
                                        (,) q_s1sxA [Occ=Once] _ [Occ=Dead] -> q_s1sxA;
                                      };
                            } in  GHC.Real.toInteger w_s1sxs sat_s1sxC;
                  } in 
                    case GHC.Real.$p1Integral w1_s1sxt of sat_s1sxx {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_s1sxx of sat_s1sxy {
                            __DEFAULT -> GHC.Num.fromInteger sat_s1sxy sat_s1sxD;
                          };
                    };
        } in  (#,#) [sat_s1sxE sat_s1sxJ];

GHC.Real.$fEnumRatio_$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio a -> (b, GHC.Real.Ratio a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1sxK w1_s1sxL w2_s1sxM]
        case w2_s1sxM of {
          GHC.Real.:% ww1_s1sxO [Occ=Once] ww2_s1sxP [Occ=Once] ->
              case
                  GHC.Real.$w$cproperFraction w_s1sxK w1_s1sxL ww1_s1sxO ww2_s1sxP
              of
              { (#,#) ww4_s1sxR [Occ=Once] ww5_s1sxS [Occ=Once] ->
                    (,) [ww4_s1sxR ww5_s1sxS];
              };
        };

GHC.Real.$wreduce [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,A,A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sxT w1_s1sxU w2_s1sxV]
        case
            GHC.Real.$p1Integral w_s1sxT
        of
        $dReal_s1sxW [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s1sy0 [Occ=Once] :: a_s1hE5
                [LclId] =
                    [$dReal_s1sxW] \u []
                        case GHC.Real.$p1Real $dReal_s1sxW of sat_s1sxZ {
                          __DEFAULT -> GHC.Num.fromInteger sat_s1sxZ GHC.Real.even1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s1sxW of sat_s1sxX {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_s1sxX of sat_s1sxY {
                        __DEFAULT ->
                            case GHC.Classes.== sat_s1sxY w2_s1sxV sat_s1sy0 of {
                              GHC.Types.False ->
                                  let {
                                    d_s1sy2 :: a_s1hE5
                                    [LclId] =
                                        [w_s1sxT w1_s1sxU w2_s1sxV] \u []
                                            GHC.Real.gcd w_s1sxT w1_s1sxU w2_s1sxV;
                                  } in 
                                    case GHC.Real.quot w_s1sxT w1_s1sxU d_s1sy2 of dt_s1sy3 {
                                      __DEFAULT ->
                                          case GHC.Real.quot w_s1sxT w2_s1sxV d_s1sy2 of dt1_s1sy4 {
                                            __DEFAULT -> (#,#) [dt_s1sy3 dt1_s1sy4];
                                          };
                                    };
                              GHC.Types.True -> GHC.Real.ratioZeroDenominatorError;
                            };
                      };
                };
        };

GHC.Real.reduce [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,A,A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1sy6 w1_s1sy7 w2_s1sy8]
        case GHC.Real.$wreduce w_s1sy6 w1_s1sy7 w2_s1sy8 of {
          (#,#) ww1_s1sya [Occ=Once] ww2_s1syb [Occ=Once] ->
              GHC.Real.:% [ww1_s1sya ww2_s1syb];
        };

GHC.Real.%_$s% [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>m, Unf=OtherCon []] =
    [] \r [w_s1syc w1_s1syd]
        case GHC.Real.$w$s$cfromRational w_s1syc w1_s1syd of {
          (#,#) ww1_s1syf [Occ=Once] ww2_s1syg [Occ=Once] ->
              GHC.Real.:% [ww1_s1syf ww2_s1syg];
        };

GHC.Real.$w% [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,1*C1(C1(U)),A,C(U),1*C1(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1syh w1_s1syi w2_s1syj]
        let {
          $dReal_s1syk [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,A,1*C1(C1(U)),A,1*C1(U),1*C1(U),A),A,A)>]
            :: GHC.Real.Real a_s1hEj
          [LclId] =
              [w_s1syh] \s [] GHC.Real.$p1Integral w_s1syh; } in
        let {
          $dNum_s1syl [Dmd=<L,U(A,A,1*C1(C1(U)),A,1*C1(U),1*C1(U),A)>]
            :: GHC.Num.Num a_s1hEj
          [LclId] =
              [$dReal_s1syk] \u [] GHC.Real.$p1Real $dReal_s1syk; } in
        let {
          sat_s1syo [Occ=Once] :: a_s1hEj
          [LclId] =
              [w2_s1syj $dNum_s1syl] \u [] GHC.Num.abs $dNum_s1syl w2_s1syj; } in
        let {
          sat_s1syn [Occ=Once] :: a_s1hEj
          [LclId] =
              [w1_s1syi w2_s1syj $dNum_s1syl] \u []
                  let {
                    sat_s1sym [Occ=Once] :: a_s1hEj
                    [LclId] =
                        [w2_s1syj $dNum_s1syl] \u [] GHC.Num.signum $dNum_s1syl w2_s1syj;
                  } in  GHC.Num.* $dNum_s1syl w1_s1syi sat_s1sym;
        } in  GHC.Real.$wreduce w_s1syh sat_s1syn sat_s1syo;

GHC.Real.% [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1syp w1_s1syq w2_s1syr]
        case GHC.Real.$w% w_s1syp w1_s1syq w2_s1syr of {
          (#,#) ww1_s1syt [Occ=Once] ww2_s1syu [Occ=Once] ->
              GHC.Real.:% [ww1_s1syt ww2_s1syu];
        };

GHC.Real.$w$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1syv ww_s1syw ww1_s1syx ww2_s1syy ww3_s1syz]
        let {
          $dReal_s1syA [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hEr
          [LclId] =
              [w_s1syv] \s [] GHC.Real.$p1Integral w_s1syv; } in
        let {
          $dNum_s1syB [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hEr
          [LclId] =
              [$dReal_s1syA] \u [] GHC.Real.$p1Real $dReal_s1syA; } in
        let {
          sat_s1syD [Occ=Once] :: a_s1hEr
          [LclId] =
              [ww1_s1syx ww2_s1syy $dNum_s1syB] \u []
                  GHC.Num.* $dNum_s1syB ww1_s1syx ww2_s1syy; } in
        let {
          sat_s1syC [Occ=Once] :: a_s1hEr
          [LclId] =
              [ww_s1syw ww3_s1syz $dNum_s1syB] \u []
                  GHC.Num.* $dNum_s1syB ww_s1syw ww3_s1syz;
        } in  GHC.Real.$w% w_s1syv sat_s1syC sat_s1syD;

GHC.Real.$fFractionalRatio_$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1syE w1_s1syF w2_s1syG]
        case w1_s1syF of {
          GHC.Real.:% ww1_s1syI [Occ=Once] ww2_s1syJ [Occ=Once] ->
              case w2_s1syG of {
                GHC.Real.:% ww4_s1syL [Occ=Once] ww5_s1syM [Occ=Once] ->
                    case
                        GHC.Real.$w$c/ w_s1syE ww1_s1syI ww2_s1syJ ww4_s1syL ww5_s1syM
                    of
                    { (#,#) ww7_s1syO [Occ=Once] ww8_s1syP [Occ=Once] ->
                          GHC.Real.:% [ww7_s1syO ww8_s1syP];
                    };
              };
        };

GHC.Real.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1syQ ww_s1syR ww1_s1syS]
        let {
          $dReal_s1syT [Occ=OnceL, Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
            :: GHC.Real.Real a_s1hEJ
          [LclId] =
              [w_s1syQ] \s [] GHC.Real.$p1Integral w_s1syQ; } in
        let {
          $dNum_s1syU [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_s1hEJ
          [LclId] =
              [$dReal_s1syT] \u [] GHC.Real.$p1Real $dReal_s1syT; } in
        let {
          sat_s1syW [Occ=Once] :: a_s1hEJ
          [LclId] =
              [ww1_s1syS $dNum_s1syU] \u []
                  GHC.Num.fromInteger $dNum_s1syU ww1_s1syS; } in
        let {
          sat_s1syV [Occ=Once] :: a_s1hEJ
          [LclId] =
              [ww_s1syR $dNum_s1syU] \u []
                  GHC.Num.fromInteger $dNum_s1syU ww_s1syR;
        } in  GHC.Real.$w% w_s1syQ sat_s1syV sat_s1syW;

GHC.Real.$fFractionalRatio_$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Rational -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1syX w1_s1syY]
        case w1_s1syY of {
          GHC.Real.:% ww1_s1sz0 [Occ=Once] ww2_s1sz1 [Occ=Once] ->
              case GHC.Real.$w$cfromRational w_s1syX ww1_s1sz0 ww2_s1sz1 of {
                (#,#) ww4_s1sz3 [Occ=Once] ww5_s1sz4 [Occ=Once] ->
                    GHC.Real.:% [ww4_s1sz3 ww5_s1sz4];
              };
        };

GHC.Real.$w$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(1*C1(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sz5 ww_s1sz6 ww1_s1sz7 ww2_s1sz8 ww3_s1sz9]
        let {
          $dReal_s1sza [Occ=OnceL,
                        Dmd=<L,1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hEV
          [LclId] =
              [w_s1sz5] \s [] GHC.Real.$p1Integral w_s1sz5; } in
        let {
          $dNum_s1szb [Dmd=<L,U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hEV
          [LclId] =
              [$dReal_s1sza] \u [] GHC.Real.$p1Real $dReal_s1sza; } in
        let {
          sat_s1szf [Occ=Once] :: a_s1hEV
          [LclId] =
              [ww1_s1sz7 ww3_s1sz9 $dNum_s1szb] \u []
                  GHC.Num.* $dNum_s1szb ww1_s1sz7 ww3_s1sz9; } in
        let {
          sat_s1sze [Occ=Once] :: a_s1hEV
          [LclId] =
              [ww_s1sz6 ww1_s1sz7 ww2_s1sz8 ww3_s1sz9 $dNum_s1szb] \u []
                  let {
                    sat_s1szd [Occ=Once] :: a_s1hEV
                    [LclId] =
                        [ww1_s1sz7 ww2_s1sz8 $dNum_s1szb] \u []
                            GHC.Num.* $dNum_s1szb ww2_s1sz8 ww1_s1sz7; } in
                  let {
                    sat_s1szc [Occ=Once] :: a_s1hEV
                    [LclId] =
                        [ww_s1sz6 ww3_s1sz9 $dNum_s1szb] \u []
                            GHC.Num.* $dNum_s1szb ww_s1sz6 ww3_s1sz9;
                  } in  GHC.Num.+ $dNum_s1szb sat_s1szc sat_s1szd;
        } in  GHC.Real.$wreduce w_s1sz5 sat_s1sze sat_s1szf;

GHC.Real.$fNumRatio_$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1szg w1_s1szh w2_s1szi]
        case w1_s1szh of {
          GHC.Real.:% ww1_s1szk [Occ=Once] ww2_s1szl [Occ=Once] ->
              case w2_s1szi of {
                GHC.Real.:% ww4_s1szn [Occ=Once] ww5_s1szo [Occ=Once] ->
                    case
                        GHC.Real.$w$c+ w_s1szg ww1_s1szk ww2_s1szl ww4_s1szn ww5_s1szo
                    of
                    { (#,#) ww7_s1szq [Occ=Once] ww8_s1szr [Occ=Once] ->
                          GHC.Real.:% [ww7_s1szq ww8_s1szr];
                    };
              };
        };

GHC.Real.$w$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,1*C1(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1szs ww_s1szt ww1_s1szu ww2_s1szv ww3_s1szw]
        let {
          $dReal_s1szx [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hFd
          [LclId] =
              [w_s1szs] \s [] GHC.Real.$p1Integral w_s1szs; } in
        let {
          $dNum_s1szy [Dmd=<L,U(A,1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hFd
          [LclId] =
              [$dReal_s1szx] \u [] GHC.Real.$p1Real $dReal_s1szx; } in
        let {
          sat_s1szC [Occ=Once] :: a_s1hFd
          [LclId] =
              [ww1_s1szu ww3_s1szw $dNum_s1szy] \u []
                  GHC.Num.* $dNum_s1szy ww1_s1szu ww3_s1szw; } in
        let {
          sat_s1szB [Occ=Once] :: a_s1hFd
          [LclId] =
              [ww_s1szt ww1_s1szu ww2_s1szv ww3_s1szw $dNum_s1szy] \u []
                  let {
                    sat_s1szA [Occ=Once] :: a_s1hFd
                    [LclId] =
                        [ww1_s1szu ww2_s1szv $dNum_s1szy] \u []
                            GHC.Num.* $dNum_s1szy ww2_s1szv ww1_s1szu; } in
                  let {
                    sat_s1szz [Occ=Once] :: a_s1hFd
                    [LclId] =
                        [ww_s1szt ww3_s1szw $dNum_s1szy] \u []
                            GHC.Num.* $dNum_s1szy ww_s1szt ww3_s1szw;
                  } in  GHC.Num.- $dNum_s1szy sat_s1szz sat_s1szA;
        } in  GHC.Real.$wreduce w_s1szs sat_s1szB sat_s1szC;

GHC.Real.$fNumRatio_$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1szD w1_s1szE w2_s1szF]
        case w1_s1szE of {
          GHC.Real.:% ww1_s1szH [Occ=Once] ww2_s1szI [Occ=Once] ->
              case w2_s1szF of {
                GHC.Real.:% ww4_s1szK [Occ=Once] ww5_s1szL [Occ=Once] ->
                    case
                        GHC.Real.$w$c- w_s1szD ww1_s1szH ww2_s1szI ww4_s1szK ww5_s1szL
                    of
                    { (#,#) ww7_s1szN [Occ=Once] ww8_s1szO [Occ=Once] ->
                          GHC.Real.:% [ww7_s1szN ww8_s1szO];
                    };
              };
        };

GHC.Real.$w$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1szP ww_s1szQ ww1_s1szR ww2_s1szS ww3_s1szT]
        let {
          $dReal_s1szU [Occ=OnceL,
                        Dmd=<L,1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
            :: GHC.Real.Real a_s1hFv
          [LclId] =
              [w_s1szP] \s [] GHC.Real.$p1Integral w_s1szP; } in
        let {
          $dNum_s1szV [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>]
            :: GHC.Num.Num a_s1hFv
          [LclId] =
              [$dReal_s1szU] \u [] GHC.Real.$p1Real $dReal_s1szU; } in
        let {
          sat_s1szX [Occ=Once] :: a_s1hFv
          [LclId] =
              [ww1_s1szR ww3_s1szT $dNum_s1szV] \u []
                  GHC.Num.* $dNum_s1szV ww1_s1szR ww3_s1szT; } in
        let {
          sat_s1szW [Occ=Once] :: a_s1hFv
          [LclId] =
              [ww_s1szQ ww2_s1szS $dNum_s1szV] \u []
                  GHC.Num.* $dNum_s1szV ww_s1szQ ww2_s1szS;
        } in  GHC.Real.$wreduce w_s1szP sat_s1szW sat_s1szX;

GHC.Real.$fNumRatio_$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1szY w1_s1szZ w2_s1sA0]
        case w1_s1szZ of {
          GHC.Real.:% ww1_s1sA2 [Occ=Once] ww2_s1sA3 [Occ=Once] ->
              case w2_s1sA0 of {
                GHC.Real.:% ww4_s1sA5 [Occ=Once] ww5_s1sA6 [Occ=Once] ->
                    case
                        GHC.Real.$w$c* w_s1szY ww1_s1sA2 ww2_s1sA3 ww4_s1sA5 ww5_s1sA6
                    of
                    { (#,#) ww7_s1sA8 [Occ=Once] ww8_s1sA9 [Occ=Once] ->
                          GHC.Real.:% [ww7_s1sA8 ww8_s1sA9];
                    };
              };
        };

GHC.Real.$fNumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Real.Integral a => GHC.Num.Num (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dIntegral_s1sAa]
        let {
          sat_s1sAh [Occ=Once]
            :: GHC.Integer.Type.Integer -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B1]
                  GHC.Real.$fNumRatio_$cfromInteger $dIntegral_s1sAa eta_B1; } in
        let {
          sat_s1sAg [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B1]
                  GHC.Real.$fNumRatio_$csignum $dIntegral_s1sAa eta_B1; } in
        let {
          sat_s1sAf [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B1]
                  GHC.Real.$fNumRatio_$cabs $dIntegral_s1sAa eta_B1; } in
        let {
          sat_s1sAe [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B1]
                  GHC.Real.$fNumRatio_$cnegate $dIntegral_s1sAa eta_B1; } in
        let {
          sat_s1sAd [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM
               -> GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B2 eta_B1]
                  GHC.Real.$fNumRatio_$c* $dIntegral_s1sAa eta_B2 eta_B1; } in
        let {
          sat_s1sAc [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM
               -> GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B2 eta_B1]
                  GHC.Real.$fNumRatio_$c- $dIntegral_s1sAa eta_B2 eta_B1; } in
        let {
          sat_s1sAb [Occ=Once]
            :: GHC.Real.Ratio a_a1eHM
               -> GHC.Real.Ratio a_a1eHM -> GHC.Real.Ratio a_a1eHM
          [LclId] =
              [$dIntegral_s1sAa] \r [eta_B2 eta_B1]
                  GHC.Real.$fNumRatio_$c+ $dIntegral_s1sAa eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [sat_s1sAb
                         sat_s1sAc
                         sat_s1sAd
                         sat_s1sAe
                         sat_s1sAf
                         sat_s1sAg
                         sat_s1sAh];

GHC.Real.$fEnumRatio3 :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [GHC.Real.$fEnumRatio1
                                GHC.Real.$fEnumRatio1];

GHC.Real.$fEnumRatio_$s$csucc
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [x_s1sAi]
        case x_s1sAi of {
          GHC.Real.:% ww1_s1sAk [Occ=Once] ww2_s1sAl [Occ=Once] ->
              case
                  GHC.Real.$w$s$c+
                      ww1_s1sAk ww2_s1sAl GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1sAn [Occ=Once] ww5_s1sAo [Occ=Once] ->
                    GHC.Real.:% [ww4_s1sAn ww5_s1sAo];
              };
        };

GHC.Real.$fEnumRatio_$csucc
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sAp x_s1sAq]
        case x_s1sAq of {
          GHC.Real.:% ww1_s1sAs [Occ=Once] ww2_s1sAt [Occ=Once] ->
              case
                  GHC.Real.$w$cfromInteger $dIntegral_s1sAp GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1sAv [Occ=Once] ww5_s1sAw [Occ=Once] ->
                    case
                        GHC.Real.$w$c+
                            $dIntegral_s1sAp ww1_s1sAs ww2_s1sAt ww4_s1sAv ww5_s1sAw
                    of
                    { (#,#) ww7_s1sAy [Occ=Once] ww8_s1sAz [Occ=Once] ->
                          GHC.Real.:% [ww7_s1sAy ww8_s1sAz];
                    };
              };
        };

GHC.Real.$fEnumRatio_$s$cpred
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [x_s1sAA]
        case x_s1sAA of {
          GHC.Real.:% ww1_s1sAC [Occ=Once] ww2_s1sAD [Occ=Once] ->
              case
                  GHC.Real.$w$s$c-
                      ww1_s1sAC ww2_s1sAD GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1sAF [Occ=Once] ww5_s1sAG [Occ=Once] ->
                    GHC.Real.:% [ww4_s1sAF ww5_s1sAG];
              };
        };

GHC.Real.$fEnumRatio_$cpred
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sAH x_s1sAI]
        case x_s1sAI of {
          GHC.Real.:% ww1_s1sAK [Occ=Once] ww2_s1sAL [Occ=Once] ->
              case
                  GHC.Real.$w$cfromInteger $dIntegral_s1sAH GHC.Real.$fEnumRatio1
              of
              { (#,#) ww4_s1sAN [Occ=Once] ww5_s1sAO [Occ=Once] ->
                    case
                        GHC.Real.$w$c-
                            $dIntegral_s1sAH ww1_s1sAK ww2_s1sAL ww4_s1sAN ww5_s1sAO
                    of
                    { (#,#) ww7_s1sAQ [Occ=Once] ww8_s1sAR [Occ=Once] ->
                          GHC.Real.:% [ww7_s1sAQ ww8_s1sAR];
                    };
              };
        };

GHC.Real.$fFractionalRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Fractional (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dIntegral_s1sAS]
        let {
          sat_s1sAW [Occ=Once] :: GHC.Real.Rational -> GHC.Real.Ratio a_a1eGy
          [LclId] =
              [$dIntegral_s1sAS] \r [eta_B1]
                  GHC.Real.$fFractionalRatio_$cfromRational
                      $dIntegral_s1sAS eta_B1; } in
        let {
          sat_s1sAV [Occ=Once]
            :: GHC.Real.Ratio a_a1eGy -> GHC.Real.Ratio a_a1eGy
          [LclId] =
              [$dIntegral_s1sAS] \r [eta_B1]
                  GHC.Real.$fFractionalRatio_$crecip $dIntegral_s1sAS eta_B1; } in
        let {
          sat_s1sAU [Occ=Once]
            :: GHC.Real.Ratio a_a1eGy
               -> GHC.Real.Ratio a_a1eGy -> GHC.Real.Ratio a_a1eGy
          [LclId] =
              [$dIntegral_s1sAS] \r [eta_B2 eta_B1]
                  GHC.Real.$fFractionalRatio_$c/ $dIntegral_s1sAS eta_B2 eta_B1; } in
        let {
          sat_s1sAT [Occ=Once] :: GHC.Num.Num (GHC.Real.Ratio a_a1eGy)
          [LclId] =
              [$dIntegral_s1sAS] \u [] GHC.Real.$fNumRatio $dIntegral_s1sAS;
        } in 
          GHC.Real.C:Fractional [sat_s1sAT sat_s1sAU sat_s1sAV sat_s1sAW];

GHC.Real.$fEnumRatio_$cenumFrom
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sAX]
        let {
          w_s1sAY [Occ=OnceL, Dmd=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)>]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1sAX] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1sAX; } in
        let {
          sat_s1sB3 [Occ=OnceT[0]]
            :: GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [w_s1sAY] \r [w1_s1sAZ]
                  case GHC.Real.$wnumericEnumFrom w_s1sAY w1_s1sAZ of {
                    (#,#) ww1_s1sB1 [Occ=Once] ww2_s1sB2 [Occ=Once] ->
                        : [ww1_s1sB1 ww2_s1sB2];
                  };
        } in  sat_s1sB3;

GHC.Real.$fEnumRatio_$cenumFromThen
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sB4]
        let {
          w_s1sB5 [Occ=OnceL,
                   Dmd=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)>]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1sB4] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1sB4; } in
        let {
          sat_s1sBb [Occ=OnceT[0]]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [w_s1sB5] \r [w1_s1sB6 w2_s1sB7]
                  case GHC.Real.$wnumericEnumFromThen w_s1sB5 w1_s1sB6 w2_s1sB7 of {
                    (#,#) ww1_s1sB9 [Occ=Once] ww2_s1sBa [Occ=Once] ->
                        : [ww1_s1sB9 ww2_s1sBa];
                  };
        } in  sat_s1sBb;

GHC.Real.$fEnumRatio_$cenumFromTo
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sBc]
        let {
          sat_s1sBe [Occ=Once]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1sBc] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1sBc; } in
        let {
          sat_s1sBd [Occ=Once] :: GHC.Classes.Ord (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1sBc] \u [] GHC.Real.$fOrdRatio $dIntegral_s1sBc;
        } in  GHC.Real.numericEnumFromTo sat_s1sBd sat_s1sBe;

GHC.Real.$fEnumRatio_$cenumFromThenTo
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a
     -> GHC.Real.Ratio a -> GHC.Real.Ratio a -> [GHC.Real.Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sBf]
        let {
          sat_s1sBh [Occ=Once]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1sBf] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1sBf; } in
        let {
          sat_s1sBg [Occ=Once] :: GHC.Classes.Ord (GHC.Real.Ratio a_a1eE0)
          [LclId] =
              [$dIntegral_s1sBf] \u [] GHC.Real.$fOrdRatio $dIntegral_s1sBf;
        } in  GHC.Real.numericEnumFromThenTo sat_s1sBg sat_s1sBh;

GHC.Real.$fRealFracRatio_$s$fRealRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Real (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Real! [GHC.Real.$fFractionalRatio_$s$fNumRatio
                                    GHC.Real.$fOrdRatio_$s$fOrdRatio
                                    GHC.Real.$fRealRatio_$s$ctoRational];

GHC.Real.$fRealRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Real (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,C(U))>m] =
    [] \r [$dIntegral_s1sBi]
        let {
          sat_s1sBl [Occ=Once] :: GHC.Real.Ratio a_a1eHn -> GHC.Real.Rational
          [LclId] =
              [$dIntegral_s1sBi] \r [eta_B1]
                  GHC.Real.$fRealRatio_$ctoRational $dIntegral_s1sBi eta_B1; } in
        let {
          sat_s1sBk [Occ=Once] :: GHC.Classes.Ord (GHC.Real.Ratio a_a1eHn)
          [LclId] =
              [$dIntegral_s1sBi] \u [] GHC.Real.$fOrdRatio $dIntegral_s1sBi; } in
        let {
          sat_s1sBj [Occ=Once] :: GHC.Num.Num (GHC.Real.Ratio a_a1eHn)
          [LclId] =
              [$dIntegral_s1sBi] \u [] GHC.Real.$fNumRatio $dIntegral_s1sBi;
        } in  GHC.Real.C:Real [sat_s1sBj sat_s1sBk sat_s1sBl];

GHC.Real.$w$s$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(1*C1(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sBm ww_s1sBn ww1_s1sBo]
        case GHC.Real.$w$s$cproperFraction w_s1sBm ww_s1sBn ww1_s1sBo of {
          (#,#) ww3_s1sBq [Occ=Once*] ww4_s1sBr [Occ=Once!] ->
              case ww4_s1sBr of {
                GHC.Real.:% ww6_s1sBt [Occ=Once] ww7_s1sBu [Occ=Once] ->
                    case
                        GHC.Real.$w$s$ccompare
                            ww6_s1sBt ww7_s1sBu GHC.Real.even1 GHC.Real.$fEnumRatio1
                    of
                    { __DEFAULT -> ww3_s1sBq;
                      GHC.Types.GT ->
                          case
                              GHC.Real.$p1Integral w_s1sBm
                          of
                          $dReal_s1sBw [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
                          { __DEFAULT ->
                                case
                                    GHC.Real.$p1Real $dReal_s1sBw
                                of
                                $dNum_s1sBx [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                                { __DEFAULT ->
                                      let {
                                        sat_s1sBy [Occ=Once] :: b_s1hFX
                                        [LclId] =
                                            [$dNum_s1sBx] \u []
                                                GHC.Num.fromInteger
                                                    $dNum_s1sBx GHC.Real.$fEnumRatio1;
                                      } in  GHC.Num.+ $dNum_s1sBx ww3_s1sBq sat_s1sBy;
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$s$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sBz w1_s1sBA]
        case w1_s1sBA of {
          GHC.Real.:% ww1_s1sBC [Occ=Once] ww2_s1sBD [Occ=Once] ->
              GHC.Real.$w$s$cceiling w_s1sBz ww1_s1sBC ww2_s1sBD;
        };

GHC.Real.$w$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(1*C1(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sBE w1_s1sBF ww_s1sBG ww1_s1sBH]
        case
            GHC.Real.$w$cproperFraction w_s1sBE w1_s1sBF ww_s1sBG ww1_s1sBH
        of
        { (#,#) ww3_s1sBJ [Occ=Once*] ww4_s1sBK [Occ=Once!] ->
              case ww4_s1sBK of {
                GHC.Real.:% ww6_s1sBM [Occ=Once] ww7_s1sBN [Occ=Once] ->
                    case GHC.Real.$w$cfromInteger w_s1sBE GHC.Real.even1 of {
                      (#,#) ww9_s1sBP [Occ=Once] ww10_s1sBQ [Occ=Once] ->
                          case
                              GHC.Real.$w$ccompare
                                  w_s1sBE ww6_s1sBM ww7_s1sBN ww9_s1sBP ww10_s1sBQ
                          of
                          { __DEFAULT -> ww3_s1sBJ;
                            GHC.Types.GT ->
                                case
                                    GHC.Real.$p1Integral w1_s1sBF
                                of
                                $dReal_s1sBS [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
                                { __DEFAULT ->
                                      case
                                          GHC.Real.$p1Real $dReal_s1sBS
                                      of
                                      $dNum_s1sBT [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
                                      { __DEFAULT ->
                                            let {
                                              sat_s1sBU [Occ=Once] :: b_s1hGi
                                              [LclId] =
                                                  [$dNum_s1sBT] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s1sBT GHC.Real.$fEnumRatio1;
                                            } in  GHC.Num.+ $dNum_s1sBT ww3_s1sBJ sat_s1sBU;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sBV w1_s1sBW w2_s1sBX]
        case w2_s1sBX of {
          GHC.Real.:% ww1_s1sBZ [Occ=Once] ww2_s1sC0 [Occ=Once] ->
              GHC.Real.$w$cceiling w_s1sBV w1_s1sBW ww1_s1sBZ ww2_s1sC0;
        };

GHC.Real.$w$s$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,1*C1(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sC1 ww_s1sC2 ww1_s1sC3]
        case GHC.Real.$w$s$cproperFraction w_s1sC1 ww_s1sC2 ww1_s1sC3 of {
          (#,#) ww3_s1sC5 [Occ=Once*] ww4_s1sC6 [Occ=Once!] ->
              case ww4_s1sC6 of {
                GHC.Real.:% x_s1sC8 [Occ=Once] y_s1sC9 [Occ=Once] ->
                    case
                        GHC.Integer.Type.timesInteger GHC.Real.even1 y_s1sC9
                    of
                    sat_s1sCb
                    { __DEFAULT ->
                          case
                              GHC.Integer.Type.timesInteger x_s1sC8 GHC.Real.$fEnumRatio1
                          of
                          sat_s1sCa
                          { __DEFAULT ->
                                case GHC.Integer.Type.ltInteger# sat_s1sCa sat_s1sCb of {
                                  __DEFAULT -> ww3_s1sC5;
                                  1# ->
                                      case
                                          GHC.Real.$p1Integral w_s1sC1
                                      of
                                      $dReal_s1sCd [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                      { __DEFAULT ->
                                            case
                                                GHC.Real.$p1Real $dReal_s1sCd
                                            of
                                            $dNum_s1sCe [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                            { __DEFAULT ->
                                                  let {
                                                    sat_s1sCf [Occ=Once] :: b_s1hGr
                                                    [LclId] =
                                                        [$dNum_s1sCe] \u []
                                                            GHC.Num.fromInteger
                                                                $dNum_s1sCe GHC.Real.$fEnumRatio1;
                                                  } in  GHC.Num.- $dNum_s1sCe ww3_s1sC5 sat_s1sCf;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$s$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sCg w1_s1sCh]
        case w1_s1sCh of {
          GHC.Real.:% ww1_s1sCj [Occ=Once] ww2_s1sCk [Occ=Once] ->
              GHC.Real.$w$s$cfloor w_s1sCg ww1_s1sCj ww2_s1sCk;
        };

GHC.Real.$w$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLLLLC(S))S(LLC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(A,1*C1(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sCl w1_s1sCm ww_s1sCn ww1_s1sCo]
        case
            GHC.Real.$w$cproperFraction w_s1sCl w1_s1sCm ww_s1sCn ww1_s1sCo
        of
        { (#,#) ww3_s1sCq [Occ=Once*] ww4_s1sCr [Occ=Once!] ->
              case ww4_s1sCr of {
                GHC.Real.:% ww6_s1sCt [Occ=Once] ww7_s1sCu [Occ=Once] ->
                    case GHC.Real.$w$cfromInteger w_s1sCl GHC.Real.even1 of {
                      (#,#) ww9_s1sCw [Occ=Once] ww10_s1sCx [Occ=Once] ->
                          case
                              GHC.Real.$w$c< w_s1sCl ww6_s1sCt ww7_s1sCu ww9_s1sCw ww10_s1sCx
                          of
                          { GHC.Types.False -> ww3_s1sCq;
                            GHC.Types.True ->
                                case
                                    GHC.Real.$p1Integral w1_s1sCm
                                of
                                $dReal_s1sCz [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                { __DEFAULT ->
                                      case
                                          GHC.Real.$p1Real $dReal_s1sCz
                                      of
                                      $dNum_s1sCA [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                      { __DEFAULT ->
                                            let {
                                              sat_s1sCB [Occ=Once] :: b_s1hGM
                                              [LclId] =
                                                  [$dNum_s1sCA] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s1sCA GHC.Real.$fEnumRatio1;
                                            } in  GHC.Num.- $dNum_s1sCA ww3_s1sCq sat_s1sCB;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLLLLC(S))S(LLC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(A,A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sCC w1_s1sCD w2_s1sCE]
        case w2_s1sCE of {
          GHC.Real.:% ww1_s1sCG [Occ=Once] ww2_s1sCH [Occ=Once] ->
              GHC.Real.$w$cfloor w_s1sCC w1_s1sCD ww1_s1sCG ww2_s1sCH;
        };

sat_s1sCI :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s1sCJ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1sCI GHC.Types.[]];

GHC.Real.$fRealFracRatio2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.False sat_s1sCJ;

GHC.Real.$w$s$cround [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sCK ww_s1sCL ww1_s1sCM]
        case GHC.Real.$w$s$cproperFraction w_s1sCK ww_s1sCL ww1_s1sCM of {
          (#,#) ww3_s1sCO ww4_s1sCP [Occ=Once!] ->
              case ww4_s1sCP of {
                GHC.Real.:% ww6_s1sCR ww7_s1sCS ->
                    case GHC.Integer.Type.absInteger ww6_s1sCR of dt_s1sCT {
                      __DEFAULT ->
                          case
                              GHC.Real.$w$s$c-
                                  dt_s1sCT ww7_s1sCS GHC.Real.$fEnumRatio1 GHC.Real.even2
                          of
                          { (#,#) ww9_s1sCV [Occ=Once] _ [Occ=Dead] ->
                                case GHC.Integer.Type.signumInteger ww9_s1sCV of dt1_s1sCX {
                                  __DEFAULT ->
                                      case
                                          GHC.Integer.Type.eqInteger#
                                              dt1_s1sCX GHC.Real.$fRealFracRatio2
                                      of
                                      { __DEFAULT ->
                                            let-no-escape {
                                              m_s1sCZ [Occ=Once*T[0], Dmd=<L,1*U>] :: b_s1hH5
                                              [LclId[JoinId(0)], Unf=OtherCon []] =
                                                  [w_s1sCK ww3_s1sCO ww6_s1sCR ww7_s1sCS] \r []
                                                      case
                                                          GHC.Real.$p1Integral w_s1sCK
                                                      of
                                                      $dReal_s1sD0 [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                                      { __DEFAULT ->
                                                            case
                                                                GHC.Real.$p1Real $dReal_s1sD0
                                                            of
                                                            $dNum_s1sD1 [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                                            { __DEFAULT ->
                                                                  case
                                                                      GHC.Integer.Type.timesInteger
                                                                          GHC.Real.even1 ww7_s1sCS
                                                                  of
                                                                  sat_s1sD3
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Integer.Type.timesInteger
                                                                                ww6_s1sCR
                                                                                GHC.Real.$fEnumRatio1
                                                                        of
                                                                        sat_s1sD2
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.ltInteger#
                                                                                      sat_s1sD2
                                                                                      sat_s1sD3
                                                                              of
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_s1sD5 [Occ=Once]
                                                                                        :: b_s1hH5
                                                                                      [LclId] =
                                                                                          [$dNum_s1sD1] \u []
                                                                                              GHC.Num.fromInteger
                                                                                                  $dNum_s1sD1
                                                                                                  GHC.Real.$fEnumRatio1;
                                                                                    } in 
                                                                                      GHC.Num.+
                                                                                          $dNum_s1sD1
                                                                                          ww3_s1sCO
                                                                                          sat_s1sD5;
                                                                                1# ->
                                                                                    let {
                                                                                      sat_s1sD6 [Occ=Once]
                                                                                        :: b_s1hH5
                                                                                      [LclId] =
                                                                                          [$dNum_s1sD1] \u []
                                                                                              GHC.Num.fromInteger
                                                                                                  $dNum_s1sD1
                                                                                                  GHC.Real.$fEnumRatio1;
                                                                                    } in 
                                                                                      GHC.Num.-
                                                                                          $dNum_s1sD1
                                                                                          ww3_s1sCO
                                                                                          sat_s1sD6;
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                            } in 
                                              case
                                                  GHC.Integer.Type.eqInteger#
                                                      dt1_s1sCX GHC.Real.even1
                                              of
                                              { __DEFAULT ->
                                                    case
                                                        GHC.Integer.Type.eqInteger#
                                                            dt1_s1sCX GHC.Real.$fEnumRatio1
                                                    of
                                                    { __DEFAULT -> GHC.Real.$fRealFracRatio1;
                                                      1# -> m_s1sCZ;
                                                    };
                                                1# ->
                                                    case GHC.Real.even w_s1sCK ww3_s1sCO of {
                                                      GHC.Types.False -> m_s1sCZ;
                                                      GHC.Types.True -> ww3_s1sCO;
                                                    };
                                              };
                                        1# -> ww3_s1sCO;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$s$cround [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sDa w1_s1sDb]
        case w1_s1sDb of {
          GHC.Real.:% ww1_s1sDd [Occ=Once] ww2_s1sDe [Occ=Once] ->
              GHC.Real.$w$s$cround w_s1sDa ww1_s1sDd ww2_s1sDe;
        };

GHC.Real.$w$cround [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLC(S)C(S)C(S)C(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),1*C1(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sDf w1_s1sDg ww_s1sDh ww1_s1sDi]
        case
            GHC.Real.$w$cproperFraction w_s1sDf w1_s1sDg ww_s1sDh ww1_s1sDi
        of
        { (#,#) ww3_s1sDk ww4_s1sDl [Occ=Once!] ->
              case ww4_s1sDl of {
                GHC.Real.:% ww6_s1sDn ww7_s1sDo ->
                    case GHC.Real.$p1Integral w_s1sDf of sat_s1sDp {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_s1sDp of sat_s1sDq {
                            __DEFAULT ->
                                case GHC.Num.abs sat_s1sDq ww6_s1sDn of dt_s1sDr {
                                  __DEFAULT ->
                                      case
                                          GHC.Real.$w$cfromRational
                                              w_s1sDf GHC.Real.$fEnumRatio1 GHC.Real.even2
                                      of
                                      { (#,#) ww9_s1sDt [Occ=Once] ww10_s1sDu [Occ=Once] ->
                                            case
                                                GHC.Real.$w$c-
                                                    w_s1sDf dt_s1sDr ww7_s1sDo ww9_s1sDt ww10_s1sDu
                                            of
                                            { (#,#) ww12_s1sDw [Occ=Once] _ [Occ=Dead] ->
                                                  case GHC.Real.$w$csignum w_s1sDf ww12_s1sDw of {
                                                    (#,#) ww15_s1sDz ww16_s1sDA ->
                                                        case
                                                            GHC.Real.$w$cfromInteger
                                                                w_s1sDf GHC.Real.$fEnumRatio1
                                                        of
                                                        { (#,#) ww18_s1sDC ww19_s1sDD ->
                                                              case
                                                                  GHC.Real.$p1Integral w_s1sDf
                                                              of
                                                              sat_s1sDE
                                                              { __DEFAULT ->
                                                                    case
                                                                        GHC.Real.$p1Real sat_s1sDE
                                                                    of
                                                                    sat_s1sDF
                                                                    { __DEFAULT ->
                                                                          case
                                                                              GHC.Num.negate
                                                                                  sat_s1sDF
                                                                                  ww18_s1sDC
                                                                          of
                                                                          dt1_s1sDG
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    GHC.Real.$p1Integral
                                                                                        w_s1sDf
                                                                                of
                                                                                $dEq_s1sDH [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          GHC.Real.$p2Real
                                                                                              $dEq_s1sDH
                                                                                      of
                                                                                      $dEq1_s1sDI [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                GHC.Classes.$p1Ord
                                                                                                    $dEq1_s1sDI
                                                                                            of
                                                                                            $dEq2_s1sDJ [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                                                                            { __DEFAULT ->
                                                                                                  let-no-escape {
                                                                                                    $j_s1sDK [Occ=Once*T[0],
                                                                                                              Dmd=<L,1*U>]
                                                                                                      :: b_s1hHq
                                                                                                    [LclId[JoinId(0)],
                                                                                                     Unf=OtherCon []] =
                                                                                                        [w_s1sDf
                                                                                                         w1_s1sDg
                                                                                                         ww3_s1sDk
                                                                                                         ww6_s1sDn
                                                                                                         ww7_s1sDo
                                                                                                         ww15_s1sDz
                                                                                                         ww16_s1sDA
                                                                                                         ww18_s1sDC
                                                                                                         ww19_s1sDD
                                                                                                         $dEq2_s1sDJ] \r []
                                                                                                            case
                                                                                                                GHC.Real.$w$cfromInteger
                                                                                                                    w_s1sDf
                                                                                                                    GHC.Real.even1
                                                                                                            of
                                                                                                            { (#,#) ww21_s1sDM
                                                                                                                    ww22_s1sDN ->
                                                                                                                  let-no-escape {
                                                                                                                    m_s1sDO [Dmd=<L,1*U>]
                                                                                                                      :: b_s1hHq
                                                                                                                    [LclId[JoinId(0)],
                                                                                                                     Unf=OtherCon []] =
                                                                                                                        [w_s1sDf
                                                                                                                         w1_s1sDg
                                                                                                                         ww3_s1sDk
                                                                                                                         ww6_s1sDn
                                                                                                                         ww7_s1sDo
                                                                                                                         ww21_s1sDM
                                                                                                                         ww22_s1sDN] \r []
                                                                                                                            case
                                                                                                                                GHC.Real.$p1Integral
                                                                                                                                    w1_s1sDg
                                                                                                                            of
                                                                                                                            $dReal_s1sDP [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      GHC.Real.$p1Real
                                                                                                                                          $dReal_s1sDP
                                                                                                                                  of
                                                                                                                                  $dNum_s1sDQ [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            GHC.Real.$w$c<
                                                                                                                                                w_s1sDf
                                                                                                                                                ww6_s1sDn
                                                                                                                                                ww7_s1sDo
                                                                                                                                                ww21_s1sDM
                                                                                                                                                ww22_s1sDN
                                                                                                                                        of
                                                                                                                                        { GHC.Types.False ->
                                                                                                                                              let {
                                                                                                                                                sat_s1sDS [Occ=Once]
                                                                                                                                                  :: b_s1hHq
                                                                                                                                                [LclId] =
                                                                                                                                                    [$dNum_s1sDQ] \u []
                                                                                                                                                        GHC.Num.fromInteger
                                                                                                                                                            $dNum_s1sDQ
                                                                                                                                                            GHC.Real.$fEnumRatio1;
                                                                                                                                              } in 
                                                                                                                                                GHC.Num.+
                                                                                                                                                    $dNum_s1sDQ
                                                                                                                                                    ww3_s1sDk
                                                                                                                                                    sat_s1sDS;
                                                                                                                                          GHC.Types.True ->
                                                                                                                                              let {
                                                                                                                                                sat_s1sDT [Occ=Once]
                                                                                                                                                  :: b_s1hHq
                                                                                                                                                [LclId] =
                                                                                                                                                    [$dNum_s1sDQ] \u []
                                                                                                                                                        GHC.Num.fromInteger
                                                                                                                                                            $dNum_s1sDQ
                                                                                                                                                            GHC.Real.$fEnumRatio1;
                                                                                                                                              } in 
                                                                                                                                                GHC.Num.-
                                                                                                                                                    $dNum_s1sDQ
                                                                                                                                                    ww3_s1sDk
                                                                                                                                                    sat_s1sDT;
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                  } in 
                                                                                                                    let-no-escape {
                                                                                                                      $j1_s1sDU [Occ=Once*T[0],
                                                                                                                                 Dmd=<L,1*U>]
                                                                                                                        :: b_s1hHq
                                                                                                                      [LclId[JoinId(0)],
                                                                                                                       Unf=OtherCon []] =
                                                                                                                          [ww15_s1sDz
                                                                                                                           ww16_s1sDA
                                                                                                                           ww18_s1sDC
                                                                                                                           ww19_s1sDD
                                                                                                                           $dEq2_s1sDJ
                                                                                                                           m_s1sDO] \r []
                                                                                                                              case
                                                                                                                                  GHC.Classes.==
                                                                                                                                      $dEq2_s1sDJ
                                                                                                                                      ww15_s1sDz
                                                                                                                                      ww18_s1sDC
                                                                                                                              of
                                                                                                                              { GHC.Types.False ->
                                                                                                                                    GHC.Real.$fRealFracRatio1;
                                                                                                                                GHC.Types.True ->
                                                                                                                                    case
                                                                                                                                        GHC.Classes.==
                                                                                                                                            $dEq2_s1sDJ
                                                                                                                                            ww16_s1sDA
                                                                                                                                            ww19_s1sDD
                                                                                                                                    of
                                                                                                                                    { GHC.Types.False ->
                                                                                                                                          GHC.Real.$fRealFracRatio1;
                                                                                                                                      GHC.Types.True ->
                                                                                                                                          m_s1sDO;
                                                                                                                                    };
                                                                                                                              };
                                                                                                                    } in 
                                                                                                                      case
                                                                                                                          GHC.Classes.==
                                                                                                                              $dEq2_s1sDJ
                                                                                                                              ww15_s1sDz
                                                                                                                              ww21_s1sDM
                                                                                                                      of
                                                                                                                      { GHC.Types.False ->
                                                                                                                            $j1_s1sDU;
                                                                                                                        GHC.Types.True ->
                                                                                                                            case
                                                                                                                                GHC.Classes.==
                                                                                                                                    $dEq2_s1sDJ
                                                                                                                                    ww16_s1sDA
                                                                                                                                    ww22_s1sDN
                                                                                                                            of
                                                                                                                            { GHC.Types.False ->
                                                                                                                                  $j1_s1sDU;
                                                                                                                              GHC.Types.True ->
                                                                                                                                  case
                                                                                                                                      GHC.Real.even
                                                                                                                                          w1_s1sDg
                                                                                                                                          ww3_s1sDk
                                                                                                                                  of
                                                                                                                                  { GHC.Types.False ->
                                                                                                                                        m_s1sDO;
                                                                                                                                    GHC.Types.True ->
                                                                                                                                        ww3_s1sDk;
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                            };
                                                                                                  } in 
                                                                                                    case
                                                                                                        GHC.Classes.==
                                                                                                            $dEq2_s1sDJ
                                                                                                            ww15_s1sDz
                                                                                                            dt1_s1sDG
                                                                                                    of
                                                                                                    { GHC.Types.False ->
                                                                                                          $j_s1sDK;
                                                                                                      GHC.Types.True ->
                                                                                                          case
                                                                                                              GHC.Classes.==
                                                                                                                  $dEq2_s1sDJ
                                                                                                                  ww16_s1sDA
                                                                                                                  ww19_s1sDD
                                                                                                          of
                                                                                                          { GHC.Types.False ->
                                                                                                                $j_s1sDK;
                                                                                                            GHC.Types.True ->
                                                                                                                ww3_s1sDk;
                                                                                                          };
                                                                                                    };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Real.$fRealFracRatio_$cround [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLC(S)C(S)C(S)C(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sE2 w1_s1sE3 w2_s1sE4]
        case w2_s1sE4 of {
          GHC.Real.:% ww1_s1sE6 [Occ=Once] ww2_s1sE7 [Occ=Once] ->
              GHC.Real.$w$cround w_s1sE2 w1_s1sE3 ww1_s1sE6 ww2_s1sE7;
        };

GHC.Real.$fRealFracRatio_$s$ctruncate [InlPrag=INLINE (sat-args=1)]
  :: forall b.
     GHC.Real.Integral b =>
     GHC.Real.Ratio GHC.Integer.Type.Integer -> b
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sE8 x_s1sE9]
        case x_s1sE9 of {
          GHC.Real.:% x1_s1sEb [Occ=Once] y_s1sEc ->
              let {
                sat_s1sEk [Occ=Once] :: GHC.Integer.Type.Integer
                [LclId] =
                    [x1_s1sEb y_s1sEc] \u []
                        case GHC.Integer.Type.eqInteger# y_s1sEc GHC.Real.even1 of {
                          __DEFAULT ->
                              case GHC.Integer.Type.quotRemInteger x1_s1sEb y_s1sEc of {
                                (#,#) ipv_s1sEh [Occ=Once] _ [Occ=Dead] -> ipv_s1sEh;
                              };
                          1# -> GHC.Real.divZeroError;
                        };
              } in 
                case GHC.Real.$p1Integral $dIntegral_s1sE8 of sat_s1sEd {
                  __DEFAULT ->
                      case GHC.Real.$p1Real sat_s1sEd of sat_s1sEe {
                        __DEFAULT -> GHC.Num.fromInteger sat_s1sEe sat_s1sEk;
                      };
                };
        };

GHC.Real.$fRealFracRatio_$ctruncate [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Real.Integral a =>
     forall b. GHC.Real.Integral b => GHC.Real.Ratio a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sEl $dIntegral1_s1sEm x_s1sEn]
        case x_s1sEn of {
          GHC.Real.:% ww1_s1sEp [Occ=Once] ww2_s1sEq [Occ=Once] ->
              case
                  GHC.Real.$w$cproperFraction
                      $dIntegral_s1sEl $dIntegral1_s1sEm ww1_s1sEp ww2_s1sEq
              of
              { (#,#) ww4_s1sEs [Occ=Once] _ [Occ=Dead] -> ww4_s1sEs;
              };
        };

GHC.Real.$fRealFracRatio_$s$fRealFracRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.RealFrac (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:RealFrac! [GHC.Real.$fRealFracRatio_$s$fRealRatio
                                        GHC.Real.$fFractionalRatio_$s$fFractionalRatio
                                        GHC.Real.$fEnumRatio_$s$cproperFraction
                                        GHC.Real.$fRealFracRatio_$s$ctruncate
                                        GHC.Real.$fRealFracRatio_$s$cround
                                        GHC.Real.$fRealFracRatio_$s$cceiling
                                        GHC.Real.$fRealFracRatio_$s$cfloor];

GHC.Real.$fRealFracRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.RealFrac (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))>m] =
    [] \r [$dIntegral_s1sEu]
        let {
          sat_s1sEB [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1sEu] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$cfloor
                      $dIntegral_s1sEu eta_B2 eta_B1; } in
        let {
          sat_s1sEA [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1sEu] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$cceiling
                      $dIntegral_s1sEu eta_B2 eta_B1; } in
        let {
          sat_s1sEz [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1sEu] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$cround
                      $dIntegral_s1sEu eta_B2 eta_B1; } in
        let {
          sat_s1sEy [Occ=Once]
            :: forall b. GHC.Real.Integral b => GHC.Real.Ratio a_a1eFc -> b
          [LclId] =
              [$dIntegral_s1sEu] \r [eta_B2 eta_B1]
                  GHC.Real.$fRealFracRatio_$ctruncate
                      $dIntegral_s1sEu eta_B2 eta_B1; } in
        let {
          sat_s1sEx [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               GHC.Real.Ratio a_a1eFc -> (b, GHC.Real.Ratio a_a1eFc)
          [LclId] =
              [$dIntegral_s1sEu] \r [eta_B2 eta_B1]
                  GHC.Real.$fEnumRatio_$cproperFraction
                      $dIntegral_s1sEu eta_B2 eta_B1; } in
        let {
          sat_s1sEw [Occ=Once]
            :: GHC.Real.Fractional (GHC.Real.Ratio a_a1eFc)
          [LclId] =
              [$dIntegral_s1sEu] \u []
                  GHC.Real.$fFractionalRatio $dIntegral_s1sEu; } in
        let {
          sat_s1sEv [Occ=Once] :: GHC.Real.Real (GHC.Real.Ratio a_a1eFc)
          [LclId] =
              [$dIntegral_s1sEu] \u [] GHC.Real.$fRealRatio $dIntegral_s1sEu;
        } in 
          GHC.Real.C:RealFrac [sat_s1sEv
                               sat_s1sEw
                               sat_s1sEx
                               sat_s1sEy
                               sat_s1sEz
                               sat_s1sEA
                               sat_s1sEB];

g_r1j3N
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
[GblId, Arity=3, Str=<S,U><S,U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [x_s1sEC y_s1sED z_s1sEE]
        case
            GHC.Integer.Type.remInteger y_s1sED GHC.Real.even2
        of
        sat_s1sEF
        { __DEFAULT ->
              case GHC.Integer.Type.eqInteger# sat_s1sEF GHC.Real.even1 of {
                __DEFAULT ->
                    case GHC.Integer.Type.eqInteger# y_s1sED GHC.Real.$fEnumRatio1 of {
                      __DEFAULT ->
                          case GHC.Integer.Type.timesInteger x_s1sEC z_s1sEE of sat_s1sEK {
                            __DEFAULT ->
                                case
                                    GHC.Integer.Type.quotInteger y_s1sED GHC.Real.even2
                                of
                                sat_s1sEJ
                                { __DEFAULT ->
                                      case
                                          GHC.Integer.Type.timesInteger x_s1sEC x_s1sEC
                                      of
                                      sat_s1sEI
                                      { __DEFAULT -> g_r1j3N sat_s1sEI sat_s1sEJ sat_s1sEK;
                                      };
                                };
                          };
                      1# -> GHC.Integer.Type.timesInteger x_s1sEC z_s1sEE;
                    };
                1# ->
                    case
                        GHC.Integer.Type.quotInteger y_s1sED GHC.Real.even2
                    of
                    sat_s1sEM
                    { __DEFAULT ->
                          case GHC.Integer.Type.timesInteger x_s1sEC x_s1sEC of sat_s1sEL {
                            __DEFAULT -> g_r1j3N sat_s1sEL sat_s1sEM z_s1sEE;
                          };
                    };
              };
        };

GHC.Real.^_f [Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [x_s1sEN y_s1sEO]
        case
            GHC.Integer.Type.remInteger y_s1sEO GHC.Real.even2
        of
        sat_s1sEP
        { __DEFAULT ->
              case GHC.Integer.Type.eqInteger# sat_s1sEP GHC.Real.even1 of {
                __DEFAULT ->
                    case GHC.Integer.Type.eqInteger# y_s1sEO GHC.Real.$fEnumRatio1 of {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.quotInteger y_s1sEO GHC.Real.even2
                          of
                          sat_s1sET
                          { __DEFAULT ->
                                case GHC.Integer.Type.timesInteger x_s1sEN x_s1sEN of sat_s1sES {
                                  __DEFAULT -> g_r1j3N sat_s1sES sat_s1sET x_s1sEN;
                                };
                          };
                      1# -> x_s1sEN;
                    };
                1# ->
                    case
                        GHC.Integer.Type.quotInteger y_s1sEO GHC.Real.even2
                    of
                    sat_s1sEV
                    { __DEFAULT ->
                          case GHC.Integer.Type.timesInteger x_s1sEN x_s1sEN of sat_s1sEU {
                            __DEFAULT -> GHC.Real.^_f sat_s1sEU sat_s1sEV;
                          };
                    };
              };
        };

lvl5_r1j3O :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Negative exponent"#;

GHC.Real.^1 :: GHC.Integer.Type.Integer
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1sEW {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1sEW;
        };

GHC.Real.^_$s^ [InlPrag=NOUSERINLINE[1]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [x0_s1sEX y0_s1sEY]
        case GHC.Integer.Type.ltInteger# y0_s1sEY GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.eqInteger# y0_s1sEY GHC.Real.even1 of {
                __DEFAULT -> GHC.Real.^_f x0_s1sEX y0_s1sEY;
                1# -> GHC.Real.$fEnumRatio1;
              };
          1# -> GHC.Real.^1;
        };

GHC.Real.$w$s$cfromEnum [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Prim.Int#
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1sF1 ww1_s1sF2]
        case GHC.Integer.Type.eqInteger# ww1_s1sF2 GHC.Real.even1 of {
          __DEFAULT ->
              case GHC.Integer.Type.quotRemInteger ww_s1sF1 ww1_s1sF2 of {
                (#,#) ipv_s1sF5 [Occ=Once] _ [Occ=Dead] ->
                    GHC.Integer.Type.integerToInt ipv_s1sF5;
              };
          1# -> GHC.Real.divZeroError;
        };

GHC.Real.$fEnumRatio_$s$cfromEnum [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Types.Int
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_s1sF8]
        case w_s1sF8 of {
          GHC.Real.:% ww1_s1sFa [Occ=Once] ww2_s1sFb [Occ=Once] ->
              case GHC.Real.$w$s$cfromEnum ww1_s1sFa ww2_s1sFb of ww3_s1sFc {
                __DEFAULT -> GHC.Types.I# [ww3_s1sFc];
              };
        };

GHC.Real.$fEnumRatio_$cfromEnum
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Ratio a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)),U(A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A,1*C1(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sFd x_s1sFe]
        case x_s1sFe of {
          GHC.Real.:% ww1_s1sFg [Occ=Once] ww2_s1sFh [Occ=Once] ->
              let {
                sat_s1sFl [Occ=Once] :: a_a1eE0
                [LclId] =
                    [$dIntegral_s1sFd ww1_s1sFg ww2_s1sFh] \u []
                        case GHC.Real.quotRem $dIntegral_s1sFd ww1_s1sFg ww2_s1sFh of {
                          (,) q_s1sFj [Occ=Once] _ [Occ=Dead] -> q_s1sFj;
                        };
              } in 
                case GHC.Real.toInteger $dIntegral_s1sFd sat_s1sFl of sat_s1sFm {
                  __DEFAULT ->
                      case GHC.Integer.Type.integerToInt sat_s1sFm of wild_s1sFn {
                        __DEFAULT -> GHC.Types.I# [wild_s1sFn];
                      };
                };
        };

GHC.Real.ratioPrec1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [8#];

GHC.Real.$fShowRatio2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    " % "#;

GHC.Real.$w$s$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Base.String
     -> (# GHC.Types.Char, [GHC.Types.Char] #)
[GblId, Arity=4, Str=<S,U><L,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1sFo ww1_s1sFp ww2_s1sFq w_s1sFr]
        case ># [ww_s1sFo 7#] of {
          __DEFAULT ->
              let {
                sat_s1sFx [Occ=Once] :: GHC.Base.String
                [LclId] =
                    [ww2_s1sFq w_s1sFr] \u []
                        let {
                          sat_s1sFw [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [ww2_s1sFq w_s1sFr] \u []
                                  case GHC.Show.$w$cshowsPrec4 8# ww2_s1sFq w_s1sFr of {
                                    (#,#) ww4_s1sFu [Occ=Once] ww5_s1sFv [Occ=Once] ->
                                        : [ww4_s1sFu ww5_s1sFv];
                                  };
                        } in 
                          GHC.CString.unpackAppendCString# GHC.Real.$fShowRatio2 sat_s1sFw;
              } in  GHC.Show.$w$cshowsPrec4 8# ww1_s1sFp sat_s1sFx;
          1# ->
              let {
                sat_s1sFH [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [ww1_s1sFp ww2_s1sFq w_s1sFr] \u []
                        let {
                          sat_s1sFD [Occ=Once] :: GHC.Base.String
                          [LclId] =
                              [ww2_s1sFq w_s1sFr] \u []
                                  let {
                                    sat_s1sFC [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [ww2_s1sFq w_s1sFr] \u []
                                            let {
                                              sat_s1sFy [Occ=Once] :: GHC.Base.String
                                              [LclId] =
                                                  CCCS :! [GHC.Show.$fShow(,)2 w_s1sFr];
                                            } in 
                                              case
                                                  GHC.Show.$w$cshowsPrec4 8# ww2_s1sFq sat_s1sFy
                                              of
                                              { (#,#) ww4_s1sFA [Occ=Once] ww5_s1sFB [Occ=Once] ->
                                                    : [ww4_s1sFA ww5_s1sFB];
                                              };
                                  } in 
                                    GHC.CString.unpackAppendCString#
                                        GHC.Real.$fShowRatio2 sat_s1sFC;
                        } in 
                          case GHC.Show.$w$cshowsPrec4 8# ww1_s1sFp sat_s1sFD of {
                            (#,#) ww4_s1sFF [Occ=Once] ww5_s1sFG [Occ=Once] ->
                                : [ww4_s1sFF ww5_s1sFG];
                          };
              } in  (#,#) [GHC.Show.$fShow(,)4 sat_s1sFH];
        };

GHC.Real.$fShowRatio_$s$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int
     -> GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S(SS),1*U(U,U)><L,U>m2,
 Unf=OtherCon []] =
    [] \r [w_s1sFI w1_s1sFJ w2_s1sFK]
        case w_s1sFI of {
          GHC.Types.I# ww1_s1sFM [Occ=Once] ->
              case w1_s1sFJ of {
                GHC.Real.:% ww3_s1sFO [Occ=Once] ww4_s1sFP [Occ=Once] ->
                    case
                        GHC.Real.$w$s$cshowsPrec ww1_s1sFM ww3_s1sFO ww4_s1sFP w2_s1sFK
                    of
                    { (#,#) ww6_s1sFR [Occ=Once] ww7_s1sFS [Occ=Once] ->
                          : [ww6_s1sFR ww7_s1sFS];
                    };
              };
        };

GHC.Real.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> a -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sFT ww_s1sFU ww1_s1sFV ww2_s1sFW]
        let {
          f_s1sFX [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s1sFT ww1_s1sFV] \u []
                  GHC.Show.showsPrec w_s1sFT GHC.Real.ratioPrec1 ww1_s1sFV; } in
        let {
          g1_s1sFY [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s1sFT ww2_s1sFW] \u []
                  GHC.Show.showsPrec w_s1sFT GHC.Real.ratioPrec1 ww2_s1sFW;
        } in 
          case ># [ww_s1sFU 7#] of {
            __DEFAULT ->
                let {
                  sat_s1sG3 [Occ=OnceT[0]] :: GHC.Base.String -> GHC.Base.String
                  [LclId] =
                      [f_s1sFX g1_s1sFY] \r [x_s1sG0]
                          let {
                            sat_s1sG2 [Occ=Once] :: GHC.Base.String
                            [LclId] =
                                [g1_s1sFY x_s1sG0] \u []
                                    let {
                                      sat_s1sG1 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g1_s1sFY x_s1sG0] \u [] g1_s1sFY x_s1sG0;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          GHC.Real.$fShowRatio2 sat_s1sG1;
                          } in  f_s1sFX sat_s1sG2;
                } in  sat_s1sG3;
            1# ->
                let {
                  sat_s1sG9 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s1sFX g1_s1sFY] \r [x_s1sG4]
                          let {
                            sat_s1sG8 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s1sFX g1_s1sFY x_s1sG4] \u []
                                    let {
                                      sat_s1sG7 [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          [g1_s1sFY x_s1sG4] \u []
                                              let {
                                                sat_s1sG6 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_s1sFY x_s1sG4] \u []
                                                        let {
                                                          sat_s1sG5 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_s1sG4];
                                                        } in  g1_s1sFY sat_s1sG5;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    GHC.Real.$fShowRatio2 sat_s1sG6;
                                    } in  f_s1sFX sat_s1sG7;
                          } in  : [GHC.Show.$fShow(,)4 sat_s1sG8];
                } in  sat_s1sG9;
          };

GHC.Real.$fShowRatio_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> GHC.Real.Ratio a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sGa w1_s1sGb w2_s1sGc]
        case w1_s1sGb of {
          GHC.Types.I# ww1_s1sGe [Occ=Once] ->
              case w2_s1sGc of {
                GHC.Real.:% ww3_s1sGg [Occ=Once] ww4_s1sGh [Occ=Once] ->
                    GHC.Real.$w$cshowsPrec w_s1sGa ww1_s1sGe ww3_s1sGg ww4_s1sGh;
              };
        };

GHC.Real.$fShowRatio1
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S(SS),1*U(U,U)><L,U>m2, Unf=OtherCon []] =
    [] \r [w_s1sGi w1_s1sGj]
        case w_s1sGi of {
          GHC.Real.:% ww1_s1sGl [Occ=Once] ww2_s1sGm [Occ=Once] ->
              case GHC.Real.$w$s$cshowsPrec 0# ww1_s1sGl ww2_s1sGm w1_s1sGj of {
                (#,#) ww4_s1sGo [Occ=Once] ww5_s1sGp [Occ=Once] ->
                    : [ww4_s1sGo ww5_s1sGp];
              };
        };

GHC.Real.$fShowRatio_$s$cshowList
  :: [GHC.Real.Ratio GHC.Integer.Type.Integer] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s1sGq s_s1sGr]
        GHC.Show.showList__ GHC.Real.$fShowRatio1 ls_s1sGq s_s1sGr;

GHC.Real.$fShowRatio_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [GHC.Real.Ratio a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s1sGs ls_s1sGt s_s1sGu]
        let {
          sat_s1sGz [Occ=Once] :: GHC.Real.Ratio a_a1ePl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s1sGs] \r [w_s1sGv]
                  case w_s1sGv of {
                    GHC.Real.:% ww1_s1sGx [Occ=Once] ww2_s1sGy [Occ=Once] ->
                        GHC.Real.$w$cshowsPrec $dShow_s1sGs 0# ww1_s1sGx ww2_s1sGy;
                  };
        } in  GHC.Show.showList__ sat_s1sGz ls_s1sGt s_s1sGu;

GHC.Real.$w$s$cshow [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> (# GHC.Types.Char, [GHC.Types.Char] #)
[GblId, Arity=2, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s1sGA ww1_s1sGB]
        let {
          sat_s1sGG [Occ=Once] :: GHC.Base.String
          [LclId] =
              [ww1_s1sGB] \u []
                  let {
                    sat_s1sGF [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [ww1_s1sGB] \u []
                            case GHC.Show.$w$cshowsPrec4 8# ww1_s1sGB GHC.Types.[] of {
                              (#,#) ww3_s1sGD [Occ=Once] ww4_s1sGE [Occ=Once] ->
                                  : [ww3_s1sGD ww4_s1sGE];
                            };
                  } in 
                    GHC.CString.unpackAppendCString# GHC.Real.$fShowRatio2 sat_s1sGF;
        } in  GHC.Show.$w$cshowsPrec4 8# ww_s1sGA sat_s1sGG;

GHC.Real.$fShowRatio_$s$cshow [InlPrag=NOUSERINLINE[0]]
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Base.String
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m2, Unf=OtherCon []] =
    [] \r [w_s1sGH]
        case w_s1sGH of {
          GHC.Real.:% ww1_s1sGJ [Occ=Once] ww2_s1sGK [Occ=Once] ->
              case GHC.Real.$w$s$cshow ww1_s1sGJ ww2_s1sGK of {
                (#,#) ww4_s1sGM [Occ=Once] ww5_s1sGN [Occ=Once] ->
                    : [ww4_s1sGM ww5_s1sGN];
              };
        };

GHC.Real.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Show.Show a => a -> a -> GHC.Base.String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sGO ww_s1sGP ww1_s1sGQ]
        let {
          sat_s1sGS [Occ=Once] :: GHC.Base.String
          [LclId] =
              [w_s1sGO ww1_s1sGQ] \u []
                  let {
                    sat_s1sGR [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [w_s1sGO ww1_s1sGQ] \u []
                            GHC.Show.showsPrec
                                w_s1sGO GHC.Real.ratioPrec1 ww1_s1sGQ GHC.Types.[];
                  } in 
                    GHC.CString.unpackAppendCString# GHC.Real.$fShowRatio2 sat_s1sGR;
        } in 
          GHC.Show.showsPrec w_s1sGO GHC.Real.ratioPrec1 ww_s1sGP sat_s1sGS;

GHC.Real.$fShowRatio_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Show.Show a => GHC.Real.Ratio a -> GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sGT w1_s1sGU]
        case w1_s1sGU of {
          GHC.Real.:% ww1_s1sGW [Occ=Once] ww2_s1sGX [Occ=Once] ->
              GHC.Real.$w$cshow w_s1sGT ww1_s1sGW ww2_s1sGX;
        };

GHC.Real.$fShowRatio_$s$fShowRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [GHC.Real.$fShowRatio_$s$cshowsPrec
                                    GHC.Real.$fShowRatio_$s$cshow
                                    GHC.Real.$fShowRatio_$s$cshowList];

GHC.Real.$fShowRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => GHC.Show.Show (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s1sGY]
        let {
          sat_s1sH1 [Occ=Once] :: [GHC.Real.Ratio a_a1ePl] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s1sGY] \r [eta_B2 eta_B1]
                  GHC.Real.$fShowRatio_$cshowList $dShow_s1sGY eta_B2 eta_B1; } in
        let {
          sat_s1sH0 [Occ=Once] :: GHC.Real.Ratio a_a1ePl -> GHC.Base.String
          [LclId] =
              [$dShow_s1sGY] \r [eta_B1]
                  GHC.Real.$fShowRatio_$cshow $dShow_s1sGY eta_B1; } in
        let {
          sat_s1sGZ [Occ=Once]
            :: GHC.Types.Int -> GHC.Real.Ratio a_a1ePl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s1sGY] \r [eta_B2 eta_B1]
                  GHC.Real.$fShowRatio_$cshowsPrec $dShow_s1sGY eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s1sGZ sat_s1sH0 sat_s1sH1];

GHC.Real.$w$slcm [InlPrag=NOINLINE[1]]
  :: GHC.Types.Word -> GHC.Prim.Word# -> GHC.Prim.Word#
[GblId, Arity=2, Str=<L,1*U(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [w_s1sH2 ww_s1sH3]
        case ww_s1sH3 of wild_s1sH4 {
          __DEFAULT ->
              case w_s1sH2 of wild1_s1sH5 {
                GHC.Types.W# x_s1sH6 [Occ=Once!] ->
                    case x_s1sH6 of wild2_s1sH7 {
                      __DEFAULT ->
                          let {
                            sat_s1sH8 [Occ=Once] :: GHC.Types.Word
                            [LclId] =
                                CCCS GHC.Types.W#! [wild_s1sH4];
                          } in 
                            case
                                GHC.Real.gcd GHC.Real.$fIntegralWord wild1_s1sH5 sat_s1sH8
                            of
                            { GHC.Types.W# y#_s1sHa [Occ=Once!] ->
                                  case y#_s1sHa of wild4_s1sHb {
                                    __DEFAULT ->
                                        case quotWord# [wild2_s1sH7 wild4_s1sHb] of wild5_s1sHc {
                                          __DEFAULT -> timesWord# [wild5_s1sHc wild_s1sH4];
                                        };
                                    0## -> GHC.Real.divZeroError;
                                  };
                            };
                      0## -> 0##;
                    };
              };
          0## -> 0##;
        };

GHC.Real.lcm_$slcm [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1sHe w1_s1sHf]
        case w1_s1sHf of {
          GHC.Types.W# ww1_s1sHh [Occ=Once] ->
              case GHC.Real.$w$slcm w_s1sHe ww1_s1sHh of ww2_s1sHi {
                __DEFAULT -> GHC.Types.W# [ww2_s1sHi];
              };
        };

GHC.Real.$w$slcm1 [InlPrag=NOINLINE[1]]
  :: GHC.Types.Int -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Str=<L,1*U(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [w_s1sHj ww_s1sHk]
        case ww_s1sHk of wild_s1sHl {
          __DEFAULT ->
              case w_s1sHj of wild1_s1sHm {
                GHC.Types.I# x_s1sHn [Occ=Once!] ->
                    case x_s1sHn of wild2_s1sHo {
                      __DEFAULT ->
                          let-no-escape {
                            $j_s1sHp [Occ=Once*!T[1], Dmd=<C(S),1*C1(U)>]
                              :: GHC.Prim.Int# -> GHC.Prim.Int#
                            [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                sat-only [wild_s1sHl wild1_s1sHm wild2_s1sHo] \r [ww1_s1sHq]
                                    let {
                                      sat_s1sHt [Occ=Once, Dmd=<L,1*U(U)>] :: GHC.Types.Int
                                      [LclId] =
                                          [wild1_s1sHm wild2_s1sHo] \s []
                                              case >=# [wild2_s1sHo 0#] of {
                                                __DEFAULT ->
                                                    case negateInt# [wild2_s1sHo] of sat_s1sHs {
                                                      __DEFAULT -> GHC.Types.I# [sat_s1sHs];
                                                    };
                                                1# -> wild1_s1sHm;
                                              };
                                    } in 
                                      case GHC.Real.$wgcd' sat_s1sHt ww1_s1sHq of {
                                        GHC.Types.I# x1_s1sHv [Occ=Once!] ->
                                            case x1_s1sHv of wild4_s1sHw {
                                              __DEFAULT ->
                                                  case
                                                      quotInt# [wild2_s1sHo wild4_s1sHw]
                                                  of
                                                  wild5_s1sHx
                                                  { __DEFAULT ->
                                                        case
                                                            *# [wild5_s1sHx wild_s1sHl]
                                                        of
                                                        x2_s1sHy [Dmd=<S,U>]
                                                        { __DEFAULT ->
                                                              case >=# [x2_s1sHy 0#] of {
                                                                __DEFAULT -> negateInt# [x2_s1sHy];
                                                                1# -> x2_s1sHy;
                                                              };
                                                        };
                                                  };
                                              -1# ->
                                                  case wild2_s1sHo of wild5_s1sHA {
                                                    __DEFAULT ->
                                                        case
                                                            quotInt# [wild5_s1sHA -1#]
                                                        of
                                                        sat_s1sHC
                                                        { __DEFAULT ->
                                                              case
                                                                  *# [sat_s1sHC wild_s1sHl]
                                                              of
                                                              x2_s1sHB [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case >=# [x2_s1sHB 0#] of {
                                                                      __DEFAULT ->
                                                                          negateInt# [x2_s1sHB];
                                                                      1# -> x2_s1sHB;
                                                                    };
                                                              };
                                                        };
                                                    -9223372036854775808# -> GHC.Real.overflowError;
                                                  };
                                              0# -> GHC.Real.divZeroError;
                                            };
                                      };
                          } in 
                            case >=# [wild_s1sHl 0#] of {
                              __DEFAULT ->
                                  case negateInt# [wild_s1sHl] of sat_s1sHH {
                                    __DEFAULT -> $j_s1sHp sat_s1sHH;
                                  };
                              1# -> $j_s1sHp wild_s1sHl;
                            };
                      0# -> 0#;
                    };
              };
          0# -> 0#;
        };

GHC.Real.lcm_$slcm1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [w_s1sHI w1_s1sHJ]
        case w1_s1sHJ of {
          GHC.Types.I# ww1_s1sHL [Occ=Once] ->
              case GHC.Real.$w$slcm1 w_s1sHI ww1_s1sHL of ww2_s1sHM {
                __DEFAULT -> GHC.Types.I# [ww2_s1sHM];
              };
        };

GHC.Real.lcm [InlPrag=NOINLINE[1]]
  :: forall a. GHC.Real.Integral a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(SS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,1*C1(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,1*C1(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1sHN eta_s1sHO eta1_s1sHP]
        case
            GHC.Real.$p1Integral $dIntegral_s1sHN
        of
        $dReal_s1sHQ [Dmd=<S(SS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,1*C1(C1(U)),A,1*C1(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1sHQ
              of
              $dNum_s1sHR [Dmd=<S,U(A,A,1*C1(C1(U)),A,1*C1(U),A,C(U))>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p2Real $dReal_s1sHQ
                    of
                    $dOrd_s1sHS [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                    { __DEFAULT ->
                          case
                              GHC.Classes.$p1Ord $dOrd_s1sHS
                          of
                          $dEq_s1sHT [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                          { __DEFAULT ->
                                let {
                                  sat_s1sHU [Occ=Once] :: a_a1epg
                                  [LclId] =
                                      [$dNum_s1sHR] \u []
                                          GHC.Num.fromInteger $dNum_s1sHR GHC.Real.even1;
                                } in 
                                  case GHC.Classes.== $dEq_s1sHT eta1_s1sHP sat_s1sHU of {
                                    GHC.Types.False ->
                                        let {
                                          sat_s1sHW [Occ=Once] :: a_a1epg
                                          [LclId] =
                                              [$dNum_s1sHR] \u []
                                                  GHC.Num.fromInteger $dNum_s1sHR GHC.Real.even1;
                                        } in 
                                          case GHC.Classes.== $dEq_s1sHT eta_s1sHO sat_s1sHW of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_s1sI0 [Occ=Once] :: a_a1epg
                                                  [LclId] =
                                                      [$dIntegral_s1sHN
                                                       eta_s1sHO
                                                       eta1_s1sHP
                                                       $dNum_s1sHR] \u []
                                                          let {
                                                            sat_s1sHZ [Occ=Once] :: a_a1epg
                                                            [LclId] =
                                                                [$dIntegral_s1sHN
                                                                 eta_s1sHO
                                                                 eta1_s1sHP] \u []
                                                                    let {
                                                                      sat_s1sHY [Occ=Once]
                                                                        :: a_a1epg
                                                                      [LclId] =
                                                                          [$dIntegral_s1sHN
                                                                           eta_s1sHO
                                                                           eta1_s1sHP] \u []
                                                                              GHC.Real.gcd
                                                                                  $dIntegral_s1sHN
                                                                                  eta_s1sHO
                                                                                  eta1_s1sHP;
                                                                    } in 
                                                                      GHC.Real.quot
                                                                          $dIntegral_s1sHN
                                                                          eta_s1sHO
                                                                          sat_s1sHY;
                                                          } in 
                                                            GHC.Num.*
                                                                $dNum_s1sHR sat_s1sHZ eta1_s1sHP;
                                                } in  GHC.Num.abs $dNum_s1sHR sat_s1sI0;
                                            GHC.Types.True ->
                                                GHC.Num.fromInteger $dNum_s1sHR GHC.Real.even1;
                                          };
                                    GHC.Types.True ->
                                        GHC.Num.fromInteger $dNum_s1sHR GHC.Real.even1;
                                  };
                          };
                    };
              };
        };

GHC.Real.$w$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Real.Integral a => GHC.Types.Int -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [w_s1sI1 w1_s1sI2]
        case
            GHC.Real.$p1Integral w_s1sI1
        of
        $dReal_s1sI3 [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Real $dReal_s1sI3
              of
              $dNum_s1sI4 [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
              { __DEFAULT ->
                    let {
                      sat_s1sI7 [Occ=Once] :: GHC.Integer.Type.Integer
                      [LclId] =
                          [w1_s1sI2] \u []
                              case w1_s1sI2 of {
                                GHC.Types.I# i_s1sI6 [Occ=Once] ->
                                    GHC.Integer.Type.smallInteger i_s1sI6;
                              };
                    } in 
                      case GHC.Num.fromInteger $dNum_s1sI4 sat_s1sI7 of dt_s1sI8 {
                        __DEFAULT ->
                            case
                                GHC.Num.fromInteger $dNum_s1sI4 GHC.Real.$fEnumRatio1
                            of
                            dt1_s1sI9
                            { __DEFAULT -> (#,#) [dt_s1sI8 dt1_s1sI9];
                            };
                      };
              };
        };

GHC.Real.$fEnumRatio_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Types.Int -> GHC.Real.Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1sIa w1_s1sIb]
        case GHC.Real.$w$ctoEnum w_s1sIa w1_s1sIb of {
          (#,#) ww1_s1sId [Occ=Once] ww2_s1sIe [Occ=Once] ->
              GHC.Real.:% [ww1_s1sId ww2_s1sIe];
        };

GHC.Real.$fEnumRatio_$s$fEnumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Enum.Enum (GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Enum! [GHC.Real.$fEnumRatio_$s$csucc
                                    GHC.Real.$fEnumRatio_$s$cpred
                                    GHC.Real.$fEnumRatio_$ctoRational
                                    GHC.Real.$fEnumRatio_$s$cfromEnum
                                    GHC.Real.$fEnumRatio_$snumericEnumFrom
                                    GHC.Real.$fEnumRatio_$snumericEnumFromThen
                                    GHC.Real.$fEnumRatio_$snumericEnumFromTo
                                    GHC.Real.$fEnumRatio_$snumericEnumFromThenTo];

GHC.Real.$fEnumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Enum.Enum (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,A))),A,C(U))>m] =
    [] \r [$dIntegral_s1sIf]
        let {
          sat_s1sIn [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0
               -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1sIf] \u []
                  GHC.Real.$fEnumRatio_$cenumFromThenTo $dIntegral_s1sIf; } in
        let {
          sat_s1sIm [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1sIf] \u []
                  GHC.Real.$fEnumRatio_$cenumFromTo $dIntegral_s1sIf; } in
        let {
          sat_s1sIl [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0
               -> GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1sIf] \u []
                  GHC.Real.$fEnumRatio_$cenumFromThen $dIntegral_s1sIf; } in
        let {
          sat_s1sIk [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0 -> [GHC.Real.Ratio a_a1eE0]
          [LclId] =
              [$dIntegral_s1sIf] \u []
                  GHC.Real.$fEnumRatio_$cenumFrom $dIntegral_s1sIf; } in
        let {
          sat_s1sIj [Occ=Once] :: GHC.Real.Ratio a_a1eE0 -> GHC.Types.Int
          [LclId] =
              [$dIntegral_s1sIf] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$cfromEnum $dIntegral_s1sIf eta_B1; } in
        let {
          sat_s1sIi [Occ=Once] :: GHC.Types.Int -> GHC.Real.Ratio a_a1eE0
          [LclId] =
              [$dIntegral_s1sIf] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$ctoEnum $dIntegral_s1sIf eta_B1; } in
        let {
          sat_s1sIh [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0 -> GHC.Real.Ratio a_a1eE0
          [LclId] =
              [$dIntegral_s1sIf] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$cpred $dIntegral_s1sIf eta_B1; } in
        let {
          sat_s1sIg [Occ=Once]
            :: GHC.Real.Ratio a_a1eE0 -> GHC.Real.Ratio a_a1eE0
          [LclId] =
              [$dIntegral_s1sIf] \r [eta_B1]
                  GHC.Real.$fEnumRatio_$csucc $dIntegral_s1sIf eta_B1;
        } in 
          GHC.Enum.C:Enum [sat_s1sIg
                           sat_s1sIh
                           sat_s1sIi
                           sat_s1sIj
                           sat_s1sIk
                           sat_s1sIl
                           sat_s1sIm
                           sat_s1sIn];

$wg_r1j3P
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><S,U><S,U>,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s1sIo ww1_s1sIp ww2_s1sIq]
        case remInt# [ww1_s1sIp 2#] of {
          __DEFAULT ->
              case ww1_s1sIp of wild1_s1sIs {
                __DEFAULT ->
                    case *# [ww_s1sIo ww2_s1sIq] of sat_s1sIv {
                      __DEFAULT ->
                          case quotInt# [wild1_s1sIs 2#] of sat_s1sIu {
                            __DEFAULT ->
                                case *# [ww_s1sIo ww_s1sIo] of sat_s1sIt {
                                  __DEFAULT -> $wg_r1j3P sat_s1sIt sat_s1sIu sat_s1sIv;
                                };
                          };
                    };
                1# -> *# [ww_s1sIo ww2_s1sIq];
              };
          0# ->
              case quotInt# [ww1_s1sIp 2#] of sat_s1sIx {
                __DEFAULT ->
                    case *# [ww_s1sIo ww_s1sIo] of sat_s1sIw {
                      __DEFAULT -> $wg_r1j3P sat_s1sIw sat_s1sIx ww2_s1sIq;
                    };
              };
        };

GHC.Real.$wf1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_s1sIy ww1_s1sIz]
        case remInt# [ww1_s1sIz 2#] of {
          __DEFAULT ->
              case ww1_s1sIz of wild1_s1sIB {
                __DEFAULT ->
                    case quotInt# [wild1_s1sIB 2#] of sat_s1sID {
                      __DEFAULT ->
                          case *# [ww_s1sIy ww_s1sIy] of sat_s1sIC {
                            __DEFAULT -> $wg_r1j3P sat_s1sIC sat_s1sID ww_s1sIy;
                          };
                    };
                1# -> ww_s1sIy;
              };
          0# ->
              case quotInt# [ww1_s1sIz 2#] of sat_s1sIF {
                __DEFAULT ->
                    case *# [ww_s1sIy ww_s1sIy] of sat_s1sIE {
                      __DEFAULT -> GHC.Real.$wf1 sat_s1sIE sat_s1sIF;
                    };
              };
        };

GHC.Real.^_f2 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1sIG w1_s1sIH]
        case w_s1sIG of {
          GHC.Types.I# ww1_s1sIJ [Occ=Once] ->
              case w1_s1sIH of {
                GHC.Types.I# ww3_s1sIL [Occ=Once] ->
                    case GHC.Real.$wf1 ww1_s1sIJ ww3_s1sIL of ww4_s1sIM {
                      __DEFAULT -> GHC.Types.I# [ww4_s1sIM];
                    };
              };
        };

GHC.Real.^3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

GHC.Real.^2 :: GHC.Types.Int
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1sIN {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1sIN;
        };

GHC.Real.^_$s^2 [InlPrag=NOUSERINLINE[1]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=2, Str=<L,1*U(U)><S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [x0_s1sIO y0_s1sIP]
        case y0_s1sIP of {
          GHC.Types.I# x_s1sIR ->
              case <# [x_s1sIR 0#] of {
                __DEFAULT ->
                    case x_s1sIR of wild1_s1sIT {
                      __DEFAULT ->
                          case x0_s1sIO of {
                            GHC.Types.I# ww1_s1sIV [Occ=Once] ->
                                case GHC.Real.$wf1 ww1_s1sIV wild1_s1sIT of ww2_s1sIW {
                                  __DEFAULT -> GHC.Types.I# [ww2_s1sIW];
                                };
                          };
                      0# -> GHC.Real.^3;
                    };
                1# -> GHC.Real.^2;
              };
        };

$wg1_r1j3Q
  :: GHC.Integer.Type.Integer
     -> GHC.Prim.Int#
     -> GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
[GblId, Arity=3, Str=<S,U><S,U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_s1sIX ww_s1sIY w1_s1sIZ]
        case remInt# [ww_s1sIY 2#] of {
          __DEFAULT ->
              case ww_s1sIY of wild1_s1sJ1 {
                __DEFAULT ->
                    case GHC.Integer.Type.timesInteger w_s1sIX w1_s1sIZ of sat_s1sJ4 {
                      __DEFAULT ->
                          case quotInt# [wild1_s1sJ1 2#] of sat_s1sJ3 {
                            __DEFAULT ->
                                case GHC.Integer.Type.timesInteger w_s1sIX w_s1sIX of sat_s1sJ2 {
                                  __DEFAULT -> $wg1_r1j3Q sat_s1sJ2 sat_s1sJ3 sat_s1sJ4;
                                };
                          };
                    };
                1# -> GHC.Integer.Type.timesInteger w_s1sIX w1_s1sIZ;
              };
          0# ->
              case quotInt# [ww_s1sIY 2#] of sat_s1sJ6 {
                __DEFAULT ->
                    case GHC.Integer.Type.timesInteger w_s1sIX w_s1sIX of sat_s1sJ5 {
                      __DEFAULT -> $wg1_r1j3Q sat_s1sJ5 sat_s1sJ6 w1_s1sIZ;
                    };
              };
        };

GHC.Real.$wf [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer
     -> GHC.Prim.Int# -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [w_s1sJ7 ww_s1sJ8]
        case remInt# [ww_s1sJ8 2#] of {
          __DEFAULT ->
              case ww_s1sJ8 of wild1_s1sJa {
                __DEFAULT ->
                    case quotInt# [wild1_s1sJa 2#] of sat_s1sJc {
                      __DEFAULT ->
                          case GHC.Integer.Type.timesInteger w_s1sJ7 w_s1sJ7 of sat_s1sJb {
                            __DEFAULT -> $wg1_r1j3Q sat_s1sJb sat_s1sJc w_s1sJ7;
                          };
                    };
                1# -> w_s1sJ7;
              };
          0# ->
              case quotInt# [ww_s1sJ8 2#] of sat_s1sJe {
                __DEFAULT ->
                    case GHC.Integer.Type.timesInteger w_s1sJ7 w_s1sJ7 of sat_s1sJd {
                      __DEFAULT -> GHC.Real.$wf sat_s1sJd sat_s1sJe;
                    };
              };
        };

GHC.Real.^_f1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [w_s1sJf w1_s1sJg]
        case w1_s1sJg of {
          GHC.Types.I# ww1_s1sJi [Occ=Once] ->
              GHC.Real.$wf w_s1sJf ww1_s1sJi;
        };

GHC.Real.^_$s^1 [InlPrag=NOUSERINLINE[1]]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<L,U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x0_s1sJj y0_s1sJk]
        case y0_s1sJk of {
          GHC.Types.I# x_s1sJm ->
              case <# [x_s1sJm 0#] of {
                __DEFAULT ->
                    case x_s1sJm of wild1_s1sJo {
                      __DEFAULT -> GHC.Real.$wf x0_s1sJj wild1_s1sJo;
                      0# -> GHC.Real.$fEnumRatio1;
                    };
                1# -> GHC.Real.^1;
              };
        };

lvl6_r1j3R :: GHC.Real.Rational
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1sJp {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1sJp;
        };

lvl7_r1j3S :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r1j3O of sat_s1sJq {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s1sJq;
        };

GHC.Real.^ [InlPrag=INLINABLE[1]]
  :: forall a b. (GHC.Num.Num a, GHC.Real.Integral b) => a -> b -> a
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))><S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s1sJr $dIntegral_s1sJs eta_s1sJt eta1_s1sJu]
        case
            GHC.Real.$p1Integral $dIntegral_s1sJs
        of
        $dReal_s1sJv [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum1_s1sJw [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num b_a1eqq
                [LclId] =
                    [$dReal_s1sJv] \u [] GHC.Real.$p1Real $dReal_s1sJv;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1sJv
                of
                $dOrd_s1sJx [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1sJy [Occ=Once] :: b_a1eqq
                        [LclId] =
                            [$dNum1_s1sJw] \u []
                                GHC.Num.fromInteger $dNum1_s1sJw GHC.Real.even1;
                      } in 
                        case GHC.Classes.< $dOrd_s1sJx eta1_s1sJu sat_s1sJy of {
                          GHC.Types.False ->
                              let {
                                sat_s1sJB [Occ=Once] :: b_a1eqq
                                [LclId] =
                                    [$dNum1_s1sJw] \u []
                                        GHC.Num.fromInteger $dNum1_s1sJw GHC.Real.even1;
                              } in 
                                case GHC.Classes.$p1Ord $dOrd_s1sJx of sat_s1sJA {
                                  __DEFAULT ->
                                      case GHC.Classes.== sat_s1sJA eta1_s1sJu sat_s1sJB of {
                                        GHC.Types.False ->
                                            let {
                                              lvl8_s1sJD :: b_a1eqq
                                              [LclId] =
                                                  [$dNum1_s1sJw] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum1_s1sJw GHC.Real.even2;
                                            } in 
                                              let-no-escape {
                                                exit_s1sJE [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                                  :: a_a1eqp -> b_a1eqq -> a_a1eqp
                                                [LclId[JoinId(2)],
                                                 Arity=2,
                                                 Str=<L,U><L,U>,
                                                 Unf=OtherCon []] =
                                                    sat-only [$dNum_s1sJr
                                                              $dIntegral_s1sJs
                                                              $dNum1_s1sJw
                                                              $dOrd_s1sJx
                                                              lvl8_s1sJD] \r [x_s1sJF y_s1sJG]
                                                        case
                                                            GHC.Classes.$p1Ord $dOrd_s1sJx
                                                        of
                                                        $dEq_s1sJH [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                                        { __DEFAULT ->
                                                              let {
                                                                lvl9_s1sJI :: b_a1eqq
                                                                [LclId] =
                                                                    [$dNum1_s1sJw] \u []
                                                                        GHC.Num.fromInteger
                                                                            $dNum1_s1sJw
                                                                            GHC.Real.$fEnumRatio1;
                                                              } in 
                                                                case
                                                                    GHC.Classes.==
                                                                        $dEq_s1sJH
                                                                        y_s1sJG
                                                                        lvl9_s1sJI
                                                                of
                                                                { GHC.Types.False ->
                                                                      let {
                                                                        sat_s1sJZ [Occ=Once]
                                                                          :: b_a1eqq
                                                                        [LclId] =
                                                                            [$dIntegral_s1sJs
                                                                             lvl8_s1sJD
                                                                             y_s1sJG] \u []
                                                                                GHC.Real.quot
                                                                                    $dIntegral_s1sJs
                                                                                    y_s1sJG
                                                                                    lvl8_s1sJD; } in
                                                                      let {
                                                                        sat_s1sJY [Occ=Once]
                                                                          :: a_a1eqp
                                                                        [LclId] =
                                                                            [$dNum_s1sJr
                                                                             x_s1sJF] \u []
                                                                                GHC.Num.*
                                                                                    $dNum_s1sJr
                                                                                    x_s1sJF
                                                                                    x_s1sJF;
                                                                      } in 
                                                                        let-no-escape {
                                                                          exit1_s1sJK [Occ=OnceL!T[2],
                                                                                       Dmd=<C(C(S)),C(C1(U))>]
                                                                            :: a_a1eqp
                                                                               -> a_a1eqp -> a_a1eqp
                                                                          [LclId[JoinId(2)],
                                                                           Arity=2,
                                                                           Str=<L,U><L,U>,
                                                                           Unf=OtherCon []] =
                                                                              sat-only [$dNum_s1sJr] \r [x1_s1sJL
                                                                                                         z_s1sJM]
                                                                                  GHC.Num.*
                                                                                      $dNum_s1sJr
                                                                                      x1_s1sJL
                                                                                      z_s1sJM;
                                                                        } in 
                                                                          let-no-escape {
                                                                            g1_s1sJN [Occ=LoopBreakerT[3]]
                                                                              :: a_a1eqp
                                                                                 -> b_a1eqq
                                                                                 -> a_a1eqp
                                                                                 -> a_a1eqp
                                                                            [LclId[JoinId(3)],
                                                                             Arity=3,
                                                                             Str=<L,U><L,U><L,U>,
                                                                             Unf=OtherCon []] =
                                                                                sat-only [$dNum_s1sJr
                                                                                          $dIntegral_s1sJs
                                                                                          lvl8_s1sJD
                                                                                          $dEq_s1sJH
                                                                                          lvl9_s1sJI
                                                                                          exit1_s1sJK
                                                                                          g1_s1sJN] \r [x1_s1sJO
                                                                                                        y1_s1sJP
                                                                                                        z_s1sJQ]
                                                                                    case
                                                                                        GHC.Real.even
                                                                                            $dIntegral_s1sJs
                                                                                            y1_s1sJP
                                                                                    of
                                                                                    { GHC.Types.False ->
                                                                                          case
                                                                                              GHC.Classes.==
                                                                                                  $dEq_s1sJH
                                                                                                  y1_s1sJP
                                                                                                  lvl9_s1sJI
                                                                                          of
                                                                                          { GHC.Types.False ->
                                                                                                let {
                                                                                                  sat_s1sJV [Occ=Once]
                                                                                                    :: a_a1eqp
                                                                                                  [LclId] =
                                                                                                      [$dNum_s1sJr
                                                                                                       x1_s1sJO
                                                                                                       z_s1sJQ] \u []
                                                                                                          GHC.Num.*
                                                                                                              $dNum_s1sJr
                                                                                                              x1_s1sJO
                                                                                                              z_s1sJQ; } in
                                                                                                let {
                                                                                                  sat_s1sJU [Occ=Once]
                                                                                                    :: b_a1eqq
                                                                                                  [LclId] =
                                                                                                      [$dIntegral_s1sJs
                                                                                                       lvl8_s1sJD
                                                                                                       y1_s1sJP] \u []
                                                                                                          GHC.Real.quot
                                                                                                              $dIntegral_s1sJs
                                                                                                              y1_s1sJP
                                                                                                              lvl8_s1sJD; } in
                                                                                                let {
                                                                                                  sat_s1sJT [Occ=Once]
                                                                                                    :: a_a1eqp
                                                                                                  [LclId] =
                                                                                                      [$dNum_s1sJr
                                                                                                       x1_s1sJO] \u []
                                                                                                          GHC.Num.*
                                                                                                              $dNum_s1sJr
                                                                                                              x1_s1sJO
                                                                                                              x1_s1sJO;
                                                                                                } in 
                                                                                                  g1_s1sJN
                                                                                                      sat_s1sJT
                                                                                                      sat_s1sJU
                                                                                                      sat_s1sJV;
                                                                                            GHC.Types.True ->
                                                                                                exit1_s1sJK
                                                                                                    x1_s1sJO
                                                                                                    z_s1sJQ;
                                                                                          };
                                                                                      GHC.Types.True ->
                                                                                          let {
                                                                                            sat_s1sJX [Occ=Once]
                                                                                              :: b_a1eqq
                                                                                            [LclId] =
                                                                                                [$dIntegral_s1sJs
                                                                                                 lvl8_s1sJD
                                                                                                 y1_s1sJP] \u []
                                                                                                    GHC.Real.quot
                                                                                                        $dIntegral_s1sJs
                                                                                                        y1_s1sJP
                                                                                                        lvl8_s1sJD; } in
                                                                                          let {
                                                                                            sat_s1sJW [Occ=Once]
                                                                                              :: a_a1eqp
                                                                                            [LclId] =
                                                                                                [$dNum_s1sJr
                                                                                                 x1_s1sJO] \u []
                                                                                                    GHC.Num.*
                                                                                                        $dNum_s1sJr
                                                                                                        x1_s1sJO
                                                                                                        x1_s1sJO;
                                                                                          } in 
                                                                                            g1_s1sJN
                                                                                                sat_s1sJW
                                                                                                sat_s1sJX
                                                                                                z_s1sJQ;
                                                                                    };
                                                                          } in 
                                                                            g1_s1sJN
                                                                                sat_s1sJY
                                                                                sat_s1sJZ
                                                                                x_s1sJF;
                                                                  GHC.Types.True -> x_s1sJF;
                                                                };
                                                        };
                                              } in 
                                                let-no-escape {
                                                  f_s1sK0 [Occ=LoopBreakerT[2]]
                                                    :: a_a1eqp -> b_a1eqq -> a_a1eqp
                                                  [LclId[JoinId(2)],
                                                   Arity=2,
                                                   Str=<L,U><L,U>,
                                                   Unf=OtherCon []] =
                                                      sat-only [$dNum_s1sJr
                                                                $dIntegral_s1sJs
                                                                lvl8_s1sJD
                                                                exit_s1sJE
                                                                f_s1sK0] \r [x_s1sK1 y_s1sK2]
                                                          case
                                                              GHC.Real.even $dIntegral_s1sJs y_s1sK2
                                                          of
                                                          { GHC.Types.False ->
                                                                exit_s1sJE x_s1sK1 y_s1sK2;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_s1sK5 [Occ=Once] :: b_a1eqq
                                                                  [LclId] =
                                                                      [$dIntegral_s1sJs
                                                                       lvl8_s1sJD
                                                                       y_s1sK2] \u []
                                                                          GHC.Real.quot
                                                                              $dIntegral_s1sJs
                                                                              y_s1sK2
                                                                              lvl8_s1sJD; } in
                                                                let {
                                                                  sat_s1sK4 [Occ=Once] :: a_a1eqp
                                                                  [LclId] =
                                                                      [$dNum_s1sJr x_s1sK1] \u []
                                                                          GHC.Num.*
                                                                              $dNum_s1sJr
                                                                              x_s1sK1
                                                                              x_s1sK1;
                                                                } in  f_s1sK0 sat_s1sK4 sat_s1sK5;
                                                          };
                                                } in  f_s1sK0 eta_s1sJt eta1_s1sJu;
                                        GHC.Types.True ->
                                            GHC.Num.fromInteger $dNum_s1sJr GHC.Real.$fEnumRatio1;
                                      };
                                };
                          GHC.Types.True -> lvl7_r1j3S;
                        };
                };
        };
GHC.Real.^%^ [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Rational -> a -> GHC.Real.Rational
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1sK6 w1_s1sK7 w2_s1sK8]
        case w1_s1sK7 of {
          GHC.Real.:% ww1_s1sKa [Occ=Once] ww2_s1sKb [Occ=Once] ->
              case GHC.Real.$w^%^ w_s1sK6 ww1_s1sKa ww2_s1sKb w2_s1sK8 of {
                (#,#) ww4_s1sKd [Occ=Once] ww5_s1sKe [Occ=Once] ->
                    GHC.Real.:% [ww4_s1sKd ww5_s1sKe];
              };
        };
GHC.Real.$w^%^ [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> a
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sKf ww_s1sKg ww1_s1sKh w1_s1sKi]
        case
            GHC.Real.$p1Integral w_s1sKf
        of
        $dReal_s1sKj [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1sKk [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_s1hK5
                [LclId] =
                    [$dReal_s1sKj] \u [] GHC.Real.$p1Real $dReal_s1sKj;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1sKj
                of
                $dOrd_s1sKl [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1sKm [Occ=Once] :: a_s1hK5
                        [LclId] =
                            [$dNum_s1sKk] \u [] GHC.Num.fromInteger $dNum_s1sKk GHC.Real.even1;
                      } in 
                        case GHC.Classes.< $dOrd_s1sKl w1_s1sKi sat_s1sKm of {
                          GHC.Types.False ->
                              let {
                                sat_s1sKp [Occ=Once] :: a_s1hK5
                                [LclId] =
                                    [$dNum_s1sKk] \u []
                                        GHC.Num.fromInteger $dNum_s1sKk GHC.Real.even1;
                              } in 
                                case GHC.Classes.$p1Ord $dOrd_s1sKl of sat_s1sKo {
                                  __DEFAULT ->
                                      case GHC.Classes.== sat_s1sKo w1_s1sKi sat_s1sKp of {
                                        GHC.Types.False ->
                                            case
                                                GHC.Real.^
                                                    GHC.Num.$fNumInteger w_s1sKf ww_s1sKg w1_s1sKi
                                            of
                                            dt_s1sKr
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Real.^
                                                          GHC.Num.$fNumInteger
                                                          w_s1sKf
                                                          ww1_s1sKh
                                                          w1_s1sKi
                                                  of
                                                  dt1_s1sKs
                                                  { __DEFAULT -> (#,#) [dt_s1sKr dt1_s1sKs];
                                                  };
                                            };
                                        GHC.Types.True ->
                                            (#,#) [GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1];
                                      };
                                };
                          GHC.Types.True -> lvl6_r1j3R;
                        };
                };
        };

GHC.Real.$w^^%^^ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> a
     -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
[GblId,
 Arity=4,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLLLL),U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,1*C1(C1(U)),A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1sKu ww_s1sKv ww1_s1sKw w1_s1sKx]
        case
            GHC.Real.$p1Integral w_s1sKu
        of
        $dReal_s1sKy [Dmd=<S(LS(LLLLC(C(S))LLL)L),U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,1*C1(C1(U)),A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1sKz [Dmd=<L,U(A,A,A,C(U),A,A,C(U))>] :: GHC.Num.Num a_s1hKi
                [LclId] =
                    [$dReal_s1sKy] \u [] GHC.Real.$p1Real $dReal_s1sKy;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s1sKy
                of
                $dOrd_s1sKA [Dmd=<S(LLLLC(C(S))LLL),U(1*U(1*C1(C1(U)),A),A,A,A,1*C1(C1(U)),A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s1sKB [Occ=Once] :: a_s1hKi
                        [LclId] =
                            [$dNum_s1sKz] \u [] GHC.Num.fromInteger $dNum_s1sKz GHC.Real.even1;
                      } in 
                        case GHC.Classes.> $dOrd_s1sKA w1_s1sKx sat_s1sKB of {
                          GHC.Types.False ->
                              let {
                                sat_s1sKE [Occ=Once] :: a_s1hKi
                                [LclId] =
                                    [$dNum_s1sKz] \u []
                                        GHC.Num.fromInteger $dNum_s1sKz GHC.Real.even1;
                              } in 
                                case GHC.Classes.$p1Ord $dOrd_s1sKA of sat_s1sKD {
                                  __DEFAULT ->
                                      case GHC.Classes.== sat_s1sKD w1_s1sKx sat_s1sKE of {
                                        GHC.Types.False ->
                                            case
                                                GHC.Integer.Type.gtInteger# ww_s1sKv GHC.Real.even1
                                            of
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.eqInteger#
                                                          ww_s1sKv GHC.Real.even1
                                                  of
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_s1sKK [Occ=Once] :: a_s1hKi
                                                          [LclId] =
                                                              [w1_s1sKx $dNum_s1sKz] \u []
                                                                  GHC.Num.negate
                                                                      $dNum_s1sKz w1_s1sKx; } in
                                                        let {
                                                          sat_s1sKJ [Occ=Once]
                                                            :: GHC.Integer.Type.Integer
                                                          [LclId] =
                                                              [ww_s1sKv] \u []
                                                                  GHC.Integer.Type.negateInteger
                                                                      ww_s1sKv;
                                                        } in 
                                                          case
                                                              GHC.Real.^
                                                                  GHC.Num.$fNumInteger
                                                                  w_s1sKu
                                                                  sat_s1sKJ
                                                                  sat_s1sKK
                                                          of
                                                          dd_s1sKI [Dmd=<S,1*U>]
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_s1sKM [Occ=Once] :: a_s1hKi
                                                                  [LclId] =
                                                                      [w1_s1sKx $dNum_s1sKz] \u []
                                                                          GHC.Num.negate
                                                                              $dNum_s1sKz w1_s1sKx;
                                                                } in 
                                                                  case
                                                                      GHC.Real.^
                                                                          GHC.Num.$fNumInteger
                                                                          w_s1sKu
                                                                          ww1_s1sKw
                                                                          sat_s1sKM
                                                                  of
                                                                  nn_s1sKL [Dmd=<S,1*U>]
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Real.even
                                                                                w_s1sKu w1_s1sKx
                                                                        of
                                                                        { GHC.Types.False ->
                                                                              case
                                                                                  GHC.Integer.Type.negateInteger
                                                                                      nn_s1sKL
                                                                              of
                                                                              dt_s1sKO
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        dd_s1sKI
                                                                                    of
                                                                                    dt1_s1sKP
                                                                                    { __DEFAULT ->
                                                                                          (#,#) [dt_s1sKO
                                                                                                 dt1_s1sKP];
                                                                                    };
                                                                              };
                                                                          GHC.Types.True ->
                                                                              case
                                                                                  nn_s1sKL
                                                                              of
                                                                              dt_s1sKQ
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        dd_s1sKI
                                                                                    of
                                                                                    dt1_s1sKR
                                                                                    { __DEFAULT ->
                                                                                          (#,#) [dt_s1sKQ
                                                                                                 dt1_s1sKR];
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                          };
                                                    1# -> GHC.Real.ratioZeroDenominatorError;
                                                  };
                                              1# ->
                                                  let {
                                                    sat_s1sKT [Occ=Once] :: a_s1hKi
                                                    [LclId] =
                                                        [w1_s1sKx $dNum_s1sKz] \u []
                                                            GHC.Num.negate $dNum_s1sKz w1_s1sKx;
                                                  } in 
                                                    case
                                                        GHC.Real.^
                                                            GHC.Num.$fNumInteger
                                                            w_s1sKu
                                                            ww1_s1sKw
                                                            sat_s1sKT
                                                    of
                                                    dt_s1sKU
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_s1sKV [Occ=Once] :: a_s1hKi
                                                            [LclId] =
                                                                [w1_s1sKx $dNum_s1sKz] \u []
                                                                    GHC.Num.negate
                                                                        $dNum_s1sKz w1_s1sKx;
                                                          } in 
                                                            case
                                                                GHC.Real.^
                                                                    GHC.Num.$fNumInteger
                                                                    w_s1sKu
                                                                    ww_s1sKv
                                                                    sat_s1sKV
                                                            of
                                                            dt1_s1sKW
                                                            { __DEFAULT ->
                                                                  (#,#) [dt_s1sKU dt1_s1sKW];
                                                            };
                                                    };
                                            };
                                        GHC.Types.True ->
                                            (#,#) [GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1];
                                      };
                                };
                          GHC.Types.True ->
                              case
                                  GHC.Real.^ GHC.Num.$fNumInteger w_s1sKu ww_s1sKv w1_s1sKx
                              of
                              dt_s1sKX
                              { __DEFAULT ->
                                    case
                                        GHC.Real.^ GHC.Num.$fNumInteger w_s1sKu ww1_s1sKw w1_s1sKx
                                    of
                                    dt1_s1sKY
                                    { __DEFAULT -> (#,#) [dt_s1sKX dt1_s1sKY];
                                    };
                              };
                        };
                };
        };

GHC.Real.^^%^^ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Rational -> a -> GHC.Real.Rational
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLLLL),U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,C(C1(U)),A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1sKZ w1_s1sL0 w2_s1sL1]
        case w1_s1sL0 of {
          GHC.Real.:% ww1_s1sL3 [Occ=Once] ww2_s1sL4 [Occ=Once] ->
              case GHC.Real.$w^^%^^ w_s1sKZ ww1_s1sL3 ww2_s1sL4 w2_s1sL1 of {
                (#,#) ww4_s1sL6 [Occ=Once] ww5_s1sL7 [Occ=Once] ->
                    GHC.Real.:% [ww4_s1sL6 ww5_s1sL7];
              };
        };

GHC.Real.^^ [InlPrag=INLINABLE[1]]
  :: forall a b.
     (GHC.Real.Fractional a, GHC.Real.Integral b) =>
     a -> b -> a
[GblId,
 Arity=4,
 Str=<L,U(1*U(A,A,C(C1(U)),A,A,A,1*C1(U)),A,1*C1(U),A)><S(S(LS(LLLLLC(C(S))LL)L)LLLLLLLL),U(U(U(A,A,A,1*C1(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,1*C1(C1(U)),A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_s1sL8 $dIntegral_s1sL9 eta_s1sLa eta1_s1sLb]
        case
            GHC.Real.$p1Integral $dIntegral_s1sL9
        of
        $dReal_s1sLc [Dmd=<S(LS(LLLLLC(C(S))LL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,A,A,A,1*C1(C1(U)),A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s1sLd [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>]
                  :: GHC.Num.Num b_a1etw
                [LclId] =
                    [$dReal_s1sLc] \u [] GHC.Real.$p1Real $dReal_s1sLc; } in
              let {
                sat_s1sLf [Occ=Once] :: b_a1etw
                [LclId] =
                    [$dNum_s1sLd] \u [] GHC.Num.fromInteger $dNum_s1sLd GHC.Real.even1;
              } in 
                case GHC.Real.$p2Real $dReal_s1sLc of sat_s1sLe {
                  __DEFAULT ->
                      case GHC.Classes.>= sat_s1sLe eta1_s1sLb sat_s1sLf of {
                        GHC.Types.False ->
                            let {
                              sat_s1sLj [Occ=Once] :: a_a1etv
                              [LclId] =
                                  [$dFractional_s1sL8
                                   $dIntegral_s1sL9
                                   eta_s1sLa
                                   eta1_s1sLb
                                   $dNum_s1sLd] \u []
                                      let {
                                        sat_s1sLi [Occ=Once] :: b_a1etw
                                        [LclId] =
                                            [eta1_s1sLb $dNum_s1sLd] \u []
                                                GHC.Num.negate $dNum_s1sLd eta1_s1sLb; } in
                                      let {
                                        sat_s1sLh [Occ=Once, Dmd=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>]
                                          :: GHC.Num.Num a_a1etv
                                        [LclId] =
                                            [$dFractional_s1sL8] \u []
                                                GHC.Real.$p1Fractional $dFractional_s1sL8;
                                      } in 
                                        GHC.Real.^ sat_s1sLh $dIntegral_s1sL9 eta_s1sLa sat_s1sLi;
                            } in  GHC.Real.recip $dFractional_s1sL8 sat_s1sLj;
                        GHC.Types.True ->
                            let {
                              sat_s1sLk [Occ=Once, Dmd=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>]
                                :: GHC.Num.Num a_a1etv
                              [LclId] =
                                  [$dFractional_s1sL8] \u []
                                      GHC.Real.$p1Fractional $dFractional_s1sL8;
                            } in  GHC.Real.^ sat_s1sLk $dIntegral_s1sL9 eta_s1sLa eta1_s1sLb;
                      };
                };
        };

GHC.Real.C:Fractional
  :: forall a.
     GHC.Num.Num a =>
     (a -> a -> a)
     -> (a -> a) -> (GHC.Real.Rational -> a) -> GHC.Real.Fractional a
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Real.C:Fractional [eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Real.C:Integral
  :: forall a.
     (GHC.Real.Real a, GHC.Enum.Enum a) =>
     (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> (a, a))
     -> (a -> a -> (a, a))
     -> (a -> GHC.Integer.Type.Integer)
     -> GHC.Real.Integral a
[GblId[DataCon],
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B9
           eta_B8
           eta_B7
           eta_B6
           eta_B5
           eta_B4
           eta_B3
           eta_B2
           eta_B1]
        GHC.Real.C:Integral [eta_B9
                             eta_B8
                             eta_B7
                             eta_B6
                             eta_B5
                             eta_B4
                             eta_B3
                             eta_B2
                             eta_B1];

GHC.Real.C:Real
  :: forall a.
     (GHC.Num.Num a, GHC.Classes.Ord a) =>
     (a -> GHC.Real.Rational) -> GHC.Real.Real a
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Real.C:Real [eta_B3 eta_B2 eta_B1];

GHC.Real.C:RealFrac
  :: forall a.
     (GHC.Real.Real a, GHC.Real.Fractional a) =>
     (forall b. GHC.Real.Integral b => a -> (b, a))
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> (forall b. GHC.Real.Integral b => a -> b)
     -> GHC.Real.RealFrac a
[GblId[DataCon],
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Real.C:RealFrac [eta_B7
                             eta_B6
                             eta_B5
                             eta_B4
                             eta_B3
                             eta_B2
                             eta_B1];

GHC.Real.:% :: forall a. a -> a -> GHC.Real.Ratio a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Real.:% [eta_B2 eta_B1];

