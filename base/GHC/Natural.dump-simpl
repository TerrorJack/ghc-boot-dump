
==================== Tidy Core ====================
2018-03-16 15:59:03.891152275 UTC

Result size of Tidy Core
  = {terms: 629, types: 479, coercions: 464, joins: 1/8}

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Natural.$fNumNatural_$cabs [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Natural
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= \ (ds_d4baW [Occ=Once] :: Natural) -> ds_d4baW}]
GHC.Natural.$fNumNatural_$cabs
  = \ (ds_d4baW :: Natural) -> ds_d4baW

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
GHC.Natural.$fRealNatural_$ctoRational [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Rational
[GblId,
 Arity=1,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Real.$fFractionalRatio_$s$cfromInteger
               `cast` (Sym (GHC.Natural.N:Natural[0]) ->_R <Ratio Integer>_R
                       :: (Integer -> Ratio Integer :: *)
                          ~R# (Natural -> Ratio Integer :: *))}]
GHC.Natural.$fRealNatural_$ctoRational
  = GHC.Real.$fFractionalRatio_$s$cfromInteger
    `cast` (Sym (GHC.Natural.N:Natural[0]) ->_R <Ratio Integer>_R
            :: (Integer -> Ratio Integer :: *)
               ~R# (Natural -> Ratio Integer :: *))

-- RHS size: {terms: 1, types: 0, coercions: 4, joins: 0/0}
GHC.Natural.$fEnumNatural_$cfromEnum [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Enum.$fEnumInteger_$cfromEnum
               `cast` (Sym (GHC.Natural.N:Natural[0]) ->_R <Int>_R
                       :: (Integer -> Int :: *) ~R# (Natural -> Int :: *))}]
GHC.Natural.$fEnumNatural_$cfromEnum
  = GHC.Enum.$fEnumInteger_$cfromEnum
    `cast` (Sym (GHC.Natural.N:Natural[0]) ->_R <Int>_R
            :: (Integer -> Int :: *) ~R# (Natural -> Int :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_r4bvC :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl_r4bvC = "Natural.toEnum: negative"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
lvl1_r4bvD :: Natural
[GblId, Str=x]
lvl1_r4bvD
  = errorWithoutStackTrace
      @ 'LiftedRep @ Natural (unpackCString# lvl_r4bvC)

-- RHS size: {terms: 13, types: 4, coercions: 2, joins: 0/0}
GHC.Natural.$fEnumNatural_$ctoEnum [InlPrag=INLINE (sat-args=1)]
  :: Int -> Natural
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (n_a4aLL :: Int) ->
                 case ltInt n_a4aLL (GHC.Types.I# 0#) of {
                   False ->
                     (GHC.Enum.$fEnumInteger_$ctoEnum n_a4aLL)
                     `cast` (Sym (GHC.Natural.N:Natural[0])
                             :: (Integer :: *) ~R# (Natural :: *));
                   True ->
                     errorWithoutStackTrace
                       @ 'LiftedRep
                       @ Natural
                       (build
                          @ Char
                          (\ (@ b_i1AKE) ->
                             unpackFoldrCString# @ b_i1AKE "Natural.toEnum: negative"#))
                 }}]
GHC.Natural.$fEnumNatural_$ctoEnum
  = \ (eta_X24 :: Int) ->
      case eta_X24 of { I# x_alN9 ->
      case <# x_alN9 0# of {
        __DEFAULT ->
          (smallInteger x_alN9)
          `cast` (Sym (GHC.Natural.N:Natural[0])
                  :: (Integer :: *) ~R# (Natural :: *));
        1# -> lvl1_r4bvD
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$fBitsNatural1 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Natural.$fBitsNatural1 = 0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl2_r4bvE :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl2_r4bvE = "Natural.pred: 0"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
lvl3_r4bvF :: Natural
[GblId, Str=x]
lvl3_r4bvF
  = errorWithoutStackTrace
      @ 'LiftedRep @ Natural (unpackCString# lvl2_r4bvE)

-- RHS size: {terms: 10, types: 2, coercions: 4, joins: 0/0}
GHC.Natural.$fEnumNatural_$cpred [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Natural
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4b8S :: Natural) ->
                 case eqInteger#
                        (ds_d4b8S
                         `cast` (GHC.Natural.N:Natural[0]
                                 :: (Natural :: *) ~R# (Integer :: *)))
                        0
                 of {
                   __DEFAULT ->
                     (GHC.Enum.$fEnumInteger_$cpred
                        (ds_d4b8S
                         `cast` (GHC.Natural.N:Natural[0]
                                 :: (Natural :: *) ~R# (Integer :: *))))
                     `cast` (Sym (GHC.Natural.N:Natural[0])
                             :: (Integer :: *) ~R# (Natural :: *));
                   1# ->
                     errorWithoutStackTrace
                       @ 'LiftedRep
                       @ Natural
                       (build
                          @ Char
                          (\ (@ b_i1AKE) ->
                             unpackFoldrCString# @ b_i1AKE "Natural.pred: 0"#))
                 }}]
GHC.Natural.$fEnumNatural_$cpred
  = \ (eta_X25 :: Natural) ->
      case eqInteger#
             (eta_X25
              `cast` (GHC.Natural.N:Natural[0]
                      :: (Natural :: *) ~R# (Integer :: *)))
             GHC.Natural.$fBitsNatural1
      of {
        __DEFAULT ->
          (GHC.Enum.$fEnumInteger_$cpred
             (eta_X25
              `cast` (GHC.Natural.N:Natural[0]
                      :: (Natural :: *) ~R# (Integer :: *))))
          `cast` (Sym (GHC.Natural.N:Natural[0])
                  :: (Integer :: *) ~R# (Natural :: *));
        1# -> lvl3_r4bvF
      }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
GHC.Natural.$fEnumNatural_$csucc [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Natural
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Enum.$fEnumInteger_$csucc
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Integer :: *) ~R# (Natural -> Natural :: *))}]
GHC.Natural.$fEnumNatural_$csucc
  = GHC.Enum.$fEnumInteger_$csucc
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Integer :: *) ~R# (Natural -> Natural :: *))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$ctoInteger_r4bvG :: Natural -> Natural
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
$ctoInteger_r4bvG = \ (ds_d4b8K :: Natural) -> ds_d4b8K

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
GHC.Natural.$fIntegralNatural_$ctoInteger [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= (\ (ds_X4baS [Occ=Once] :: Natural) -> ds_X4baS)
               `cast` (<Natural>_R ->_R GHC.Natural.N:Natural[0]
                       :: (Natural -> Natural :: *) ~R# (Natural -> Integer :: *))}]
GHC.Natural.$fIntegralNatural_$ctoInteger
  = $ctoInteger_r4bvG
    `cast` (<Natural>_R ->_R GHC.Natural.N:Natural[0]
            :: (Natural -> Natural :: *) ~R# (Natural -> Integer :: *))

-- RHS size: {terms: 27, types: 30, coercions: 7, joins: 0/1}
GHC.Natural.$fIntegralNatural_$cdivMod [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Natural -> (Natural, Natural)
[GblId,
 Arity=2,
 Str=<L,1*U><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4b8t [Occ=Once] :: Natural) (ds1_d4b8u :: Natural) ->
                 let {
                   ds2_d4b8B :: (Integer, Integer)
                   [LclId]
                   ds2_d4b8B
                     = case eqInteger#
                              (ds1_d4b8u
                               `cast` (GHC.Natural.N:Natural[0]
                                       :: (Natural :: *) ~R# (Integer :: *)))
                              0
                       of {
                         __DEFAULT ->
                           case divModInteger
                                  (ds_d4b8t
                                   `cast` (GHC.Natural.N:Natural[0]
                                           :: (Natural :: *) ~R# (Integer :: *)))
                                  (ds1_d4b8u
                                   `cast` (GHC.Natural.N:Natural[0]
                                           :: (Natural :: *) ~R# (Integer :: *)))
                           of
                           { (# ipv_i4bcl [Occ=Once], ipv1_i4bcm [Occ=Once] #) ->
                           (ipv_i4bcl, ipv1_i4bcm)
                           };
                         1# -> divZeroError @ (Integer, Integer)
                       } } in
                 (case ds2_d4b8B of { (q_a4aXv [Occ=Once], _ [Occ=Dead]) ->
                  q_a4aXv
                  `cast` (Sym (GHC.Natural.N:Natural[0])
                          :: (Integer :: *) ~R# (Natural :: *))
                  },
                  case ds2_d4b8B of { (_ [Occ=Dead], r_a4aXx [Occ=Once]) ->
                  r_a4aXx
                  `cast` (Sym (GHC.Natural.N:Natural[0])
                          :: (Integer :: *) ~R# (Natural :: *))
                  })}]
GHC.Natural.$fIntegralNatural_$cdivMod
  = \ (ds_d4b8t :: Natural) (ds1_d4b8u :: Natural) ->
      let {
        ds2_s4bh9 [Dmd=<L,U(1*U,1*U)>] :: (Integer, Integer)
        [LclId]
        ds2_s4bh9
          = case eqInteger#
                   (ds1_d4b8u
                    `cast` (GHC.Natural.N:Natural[0]
                            :: (Natural :: *) ~R# (Integer :: *)))
                   GHC.Natural.$fBitsNatural1
            of {
              __DEFAULT ->
                case divModInteger
                       (ds_d4b8t
                        `cast` (GHC.Natural.N:Natural[0]
                                :: (Natural :: *) ~R# (Integer :: *)))
                       (ds1_d4b8u
                        `cast` (GHC.Natural.N:Natural[0]
                                :: (Natural :: *) ~R# (Integer :: *)))
                of
                { (# ipv_i4bcl, ipv1_i4bcm #) ->
                (ipv_i4bcl, ipv1_i4bcm)
                };
              1# -> divZeroError @ (Integer, Integer)
            } } in
      (case ds2_s4bh9 of { (q_a4aXv, r_a4aXx) ->
       q_a4aXv
       `cast` (Sym (GHC.Natural.N:Natural[0])
               :: (Integer :: *) ~R# (Natural :: *))
       },
       case ds2_s4bh9 of { (q_a4aXv, r_a4aXx) ->
       r_a4aXx
       `cast` (Sym (GHC.Natural.N:Natural[0])
               :: (Integer :: *) ~R# (Natural :: *))
       })

-- RHS size: {terms: 27, types: 30, coercions: 7, joins: 0/1}
GHC.Natural.$fIntegralNatural_$cquotRem [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Natural -> (Natural, Natural)
[GblId,
 Arity=2,
 Str=<L,1*U><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4b8c [Occ=Once] :: Natural) (ds1_d4b8d :: Natural) ->
                 let {
                   ds2_d4b8k :: (Integer, Integer)
                   [LclId]
                   ds2_d4b8k
                     = case eqInteger#
                              (ds1_d4b8d
                               `cast` (GHC.Natural.N:Natural[0]
                                       :: (Natural :: *) ~R# (Integer :: *)))
                              0
                       of {
                         __DEFAULT ->
                           case quotRemInteger
                                  (ds_d4b8c
                                   `cast` (GHC.Natural.N:Natural[0]
                                           :: (Natural :: *) ~R# (Integer :: *)))
                                  (ds1_d4b8d
                                   `cast` (GHC.Natural.N:Natural[0]
                                           :: (Natural :: *) ~R# (Integer :: *)))
                           of
                           { (# ipv_i2KJl [Occ=Once], ipv1_i2KJm [Occ=Once] #) ->
                           (ipv_i2KJl, ipv1_i2KJm)
                           };
                         1# -> divZeroError @ (Integer, Integer)
                       } } in
                 (case ds2_d4b8k of { (q_a4aXb [Occ=Once], _ [Occ=Dead]) ->
                  q_a4aXb
                  `cast` (Sym (GHC.Natural.N:Natural[0])
                          :: (Integer :: *) ~R# (Natural :: *))
                  },
                  case ds2_d4b8k of { (_ [Occ=Dead], r_a4aXd [Occ=Once]) ->
                  r_a4aXd
                  `cast` (Sym (GHC.Natural.N:Natural[0])
                          :: (Integer :: *) ~R# (Natural :: *))
                  })}]
GHC.Natural.$fIntegralNatural_$cquotRem
  = \ (ds_d4b8c :: Natural) (ds1_d4b8d :: Natural) ->
      let {
        ds2_s4bh7 [Dmd=<L,U(1*U,1*U)>] :: (Integer, Integer)
        [LclId]
        ds2_s4bh7
          = case eqInteger#
                   (ds1_d4b8d
                    `cast` (GHC.Natural.N:Natural[0]
                            :: (Natural :: *) ~R# (Integer :: *)))
                   GHC.Natural.$fBitsNatural1
            of {
              __DEFAULT ->
                case quotRemInteger
                       (ds_d4b8c
                        `cast` (GHC.Natural.N:Natural[0]
                                :: (Natural :: *) ~R# (Integer :: *)))
                       (ds1_d4b8d
                        `cast` (GHC.Natural.N:Natural[0]
                                :: (Natural :: *) ~R# (Integer :: *)))
                of
                { (# ipv_i2KJl, ipv1_i2KJm #) ->
                (ipv_i2KJl, ipv1_i2KJm)
                };
              1# -> divZeroError @ (Integer, Integer)
            } } in
      (case ds2_s4bh7 of { (q_a4aXb, r_a4aXd) ->
       q_a4aXb
       `cast` (Sym (GHC.Natural.N:Natural[0])
               :: (Integer :: *) ~R# (Natural :: *))
       },
       case ds2_s4bh7 of { (q_a4aXb, r_a4aXd) ->
       r_a4aXd
       `cast` (Sym (GHC.Natural.N:Natural[0])
               :: (Integer :: *) ~R# (Natural :: *))
       })

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
GHC.Natural.$fEqNatural [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq Natural
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: Natural
                        eqInteger
                        `cast` (Sym (GHC.Natural.N:Natural[0])
                                ->_R Sym (GHC.Natural.N:Natural[0])
                                ->_R <Bool>_R
                                :: (Integer -> Integer -> Bool :: *)
                                   ~R# (Natural -> Natural -> Bool :: *))
                        neqInteger
                        `cast` (Sym (GHC.Natural.N:Natural[0])
                                ->_R Sym (GHC.Natural.N:Natural[0])
                                ->_R <Bool>_R
                                :: (Integer -> Integer -> Bool :: *)
                                   ~R# (Natural -> Natural -> Bool :: *))]
GHC.Natural.$fEqNatural
  = GHC.Classes.C:Eq
      @ Natural
      (eqInteger
       `cast` (Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R <Bool>_R
               :: (Integer -> Integer -> Bool :: *)
                  ~R# (Natural -> Natural -> Bool :: *)))
      (neqInteger
       `cast` (Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R <Bool>_R
               :: (Integer -> Integer -> Bool :: *)
                  ~R# (Natural -> Natural -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
GHC.Natural.$fOrdNatural [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord Natural
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: Natural
                         GHC.Natural.$fEqNatural
                         compareInteger
                         `cast` (Sym (GHC.Natural.N:Natural[0])
                                 ->_R Sym (GHC.Natural.N:Natural[0])
                                 ->_R <Ordering>_R
                                 :: (Integer -> Integer -> Ordering :: *)
                                    ~R# (Natural -> Natural -> Ordering :: *))
                         ltInteger
                         `cast` (Sym (GHC.Natural.N:Natural[0])
                                 ->_R Sym (GHC.Natural.N:Natural[0])
                                 ->_R <Bool>_R
                                 :: (Integer -> Integer -> Bool :: *)
                                    ~R# (Natural -> Natural -> Bool :: *))
                         leInteger
                         `cast` (Sym (GHC.Natural.N:Natural[0])
                                 ->_R Sym (GHC.Natural.N:Natural[0])
                                 ->_R <Bool>_R
                                 :: (Integer -> Integer -> Bool :: *)
                                    ~R# (Natural -> Natural -> Bool :: *))
                         gtInteger
                         `cast` (Sym (GHC.Natural.N:Natural[0])
                                 ->_R Sym (GHC.Natural.N:Natural[0])
                                 ->_R <Bool>_R
                                 :: (Integer -> Integer -> Bool :: *)
                                    ~R# (Natural -> Natural -> Bool :: *))
                         geInteger
                         `cast` (Sym (GHC.Natural.N:Natural[0])
                                 ->_R Sym (GHC.Natural.N:Natural[0])
                                 ->_R <Bool>_R
                                 :: (Integer -> Integer -> Bool :: *)
                                    ~R# (Natural -> Natural -> Bool :: *))
                         integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger_$cmax
                         `cast` (Sym (GHC.Natural.N:Natural[0])
                                 ->_R Sym (GHC.Natural.N:Natural[0])
                                 ->_R Sym (GHC.Natural.N:Natural[0])
                                 :: (Integer -> Integer -> Integer :: *)
                                    ~R# (Natural -> Natural -> Natural :: *))
                         integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger_$cmin
                         `cast` (Sym (GHC.Natural.N:Natural[0])
                                 ->_R Sym (GHC.Natural.N:Natural[0])
                                 ->_R Sym (GHC.Natural.N:Natural[0])
                                 :: (Integer -> Integer -> Integer :: *)
                                    ~R# (Natural -> Natural -> Natural :: *))]
GHC.Natural.$fOrdNatural
  = GHC.Classes.C:Ord
      @ Natural
      GHC.Natural.$fEqNatural
      (compareInteger
       `cast` (Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R <Ordering>_R
               :: (Integer -> Integer -> Ordering :: *)
                  ~R# (Natural -> Natural -> Ordering :: *)))
      (ltInteger
       `cast` (Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R <Bool>_R
               :: (Integer -> Integer -> Bool :: *)
                  ~R# (Natural -> Natural -> Bool :: *)))
      (leInteger
       `cast` (Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R <Bool>_R
               :: (Integer -> Integer -> Bool :: *)
                  ~R# (Natural -> Natural -> Bool :: *)))
      (gtInteger
       `cast` (Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R <Bool>_R
               :: (Integer -> Integer -> Bool :: *)
                  ~R# (Natural -> Natural -> Bool :: *)))
      (geInteger
       `cast` (Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R <Bool>_R
               :: (Integer -> Integer -> Bool :: *)
                  ~R# (Natural -> Natural -> Bool :: *)))
      (integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger_$cmax
       `cast` (Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               :: (Integer -> Integer -> Integer :: *)
                  ~R# (Natural -> Natural -> Natural :: *)))
      (integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger_$cmin
       `cast` (Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               :: (Integer -> Integer -> Integer :: *)
                  ~R# (Natural -> Natural -> Natural :: *)))

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
underflowError [InlPrag=NOINLINE] :: forall a. a
[GblId, Str=x]
underflowError
  = \ (@ a_a4aSF) ->
      raise#
        @ GHC.Exception.SomeException
        @ 'LiftedRep
        @ a_a4aSF
        underflowException

-- RHS size: {terms: 13, types: 4, coercions: 3, joins: 0/1}
GHC.Natural.$fNumNatural_$cnegate [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Natural
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_i4baV [Occ=Once] :: Natural) ->
                 let {
                   result_a4aMc :: Integer
                   [LclId]
                   result_a4aMc
                     = minusInteger
                         0
                         (x_i4baV
                          `cast` (GHC.Natural.N:Natural[0]
                                  :: (Natural :: *) ~R# (Integer :: *))) } in
                 case ltInteger# result_a4aMc 0 of {
                   __DEFAULT ->
                     result_a4aMc
                     `cast` (Sym (GHC.Natural.N:Natural[0])
                             :: (Integer :: *) ~R# (Natural :: *));
                   1# -> underflowError @ Natural
                 }}]
GHC.Natural.$fNumNatural_$cnegate
  = \ (eta_X3a :: Natural) ->
      let {
        result_s4bgT [Dmd=<S,U>] :: Integer
        [LclId]
        result_s4bgT
          = minusInteger
              GHC.Natural.$fBitsNatural1
              (eta_X3a
               `cast` (GHC.Natural.N:Natural[0]
                       :: (Natural :: *) ~R# (Integer :: *))) } in
      case ltInteger# result_s4bgT GHC.Natural.$fBitsNatural1 of {
        __DEFAULT ->
          result_s4bgT
          `cast` (Sym (GHC.Natural.N:Natural[0])
                  :: (Integer :: *) ~R# (Natural :: *));
        1# -> underflowError @ Natural
      }

-- RHS size: {terms: 9, types: 3, coercions: 2, joins: 0/0}
naturalFromInteger [InlPrag=INLINE (sat-args=1)]
  :: Integer -> Natural
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (n_X4aOH :: Integer) ->
                 case geInteger# n_X4aOH 0 of {
                   __DEFAULT -> underflowError @ Natural;
                   1# ->
                     n_X4aOH
                     `cast` (Sym (GHC.Natural.N:Natural[0])
                             :: (Integer :: *) ~R# (Natural :: *))
                 }}]
naturalFromInteger
  = \ (n_X4aOH :: Integer) ->
      case geInteger# n_X4aOH GHC.Natural.$fBitsNatural1 of {
        __DEFAULT -> underflowError @ Natural;
        1# ->
          n_X4aOH
          `cast` (Sym (GHC.Natural.N:Natural[0])
                  :: (Integer :: *) ~R# (Natural :: *))
      }

-- RHS size: {terms: 14, types: 5, coercions: 4, joins: 0/1}
GHC.Natural.$fNumNatural_$c- [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Natural -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4baC [Occ=Once] :: Natural)
                 (ds1_d4baD [Occ=Once] :: Natural) ->
                 let {
                   result_a4aMc :: Integer
                   [LclId]
                   result_a4aMc
                     = minusInteger
                         (ds_d4baC
                          `cast` (GHC.Natural.N:Natural[0]
                                  :: (Natural :: *) ~R# (Integer :: *)))
                         (ds1_d4baD
                          `cast` (GHC.Natural.N:Natural[0]
                                  :: (Natural :: *) ~R# (Integer :: *))) } in
                 case ltInteger# result_a4aMc 0 of {
                   __DEFAULT ->
                     result_a4aMc
                     `cast` (Sym (GHC.Natural.N:Natural[0])
                             :: (Integer :: *) ~R# (Natural :: *));
                   1# -> underflowError @ Natural
                 }}]
GHC.Natural.$fNumNatural_$c-
  = \ (eta_B2 :: Natural) (eta1_X2T :: Natural) ->
      let {
        result_s4bh5 [Dmd=<S,U>] :: Integer
        [LclId]
        result_s4bh5
          = minusInteger
              (eta_B2
               `cast` (GHC.Natural.N:Natural[0]
                       :: (Natural :: *) ~R# (Integer :: *)))
              (eta1_X2T
               `cast` (GHC.Natural.N:Natural[0]
                       :: (Natural :: *) ~R# (Integer :: *))) } in
      case ltInteger# result_s4bh5 GHC.Natural.$fBitsNatural1 of {
        __DEFAULT ->
          result_s4bh5
          `cast` (Sym (GHC.Natural.N:Natural[0])
                  :: (Integer :: *) ~R# (Natural :: *));
        1# -> underflowError @ Natural
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
GHC.Natural.$fNumNatural_$c+ [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Natural -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= plusInteger
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Integer -> Integer :: *)
                          ~R# (Natural -> Natural -> Natural :: *))}]
GHC.Natural.$fNumNatural_$c+
  = plusInteger
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Integer -> Integer :: *)
               ~R# (Natural -> Natural -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
GHC.Natural.$fNumNatural_$c* [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Natural -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= timesInteger
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Integer -> Integer :: *)
                          ~R# (Natural -> Natural -> Natural :: *))}]
GHC.Natural.$fNumNatural_$c*
  = timesInteger
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Integer -> Integer :: *)
               ~R# (Natural -> Natural -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
GHC.Natural.$fNumNatural_$csignum [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Natural
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= signumInteger
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Integer :: *) ~R# (Natural -> Natural :: *))}]
GHC.Natural.$fNumNatural_$csignum
  = signumInteger
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Integer :: *) ~R# (Natural -> Natural :: *))

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Natural.$fNumNatural [InlPrag=NOUSERINLINE CONLIKE]
  :: Num Natural
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Natural
                     GHC.Natural.$fNumNatural_$c+
                     GHC.Natural.$fNumNatural_$c-
                     GHC.Natural.$fNumNatural_$c*
                     GHC.Natural.$fNumNatural_$cnegate
                     GHC.Natural.$fNumNatural_$cabs
                     GHC.Natural.$fNumNatural_$csignum
                     naturalFromInteger]
GHC.Natural.$fNumNatural
  = GHC.Num.C:Num
      @ Natural
      GHC.Natural.$fNumNatural_$c+
      GHC.Natural.$fNumNatural_$c-
      GHC.Natural.$fNumNatural_$c*
      GHC.Natural.$fNumNatural_$cnegate
      GHC.Natural.$fNumNatural_$cabs
      GHC.Natural.$fNumNatural_$csignum
      naturalFromInteger

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Natural.$fRealNatural [InlPrag=NOUSERINLINE CONLIKE]
  :: Real Natural
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Natural
                       GHC.Natural.$fNumNatural
                       GHC.Natural.$fOrdNatural
                       GHC.Natural.$fRealNatural_$ctoRational]
GHC.Natural.$fRealNatural
  = GHC.Real.C:Real
      @ Natural
      GHC.Natural.$fNumNatural
      GHC.Natural.$fOrdNatural
      GHC.Natural.$fRealNatural_$ctoRational

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
GHC.Natural.$fIntegralNatural_$cquot [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Natural -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Real.$fIntegralInteger_$cquot
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Integer -> Integer :: *)
                          ~R# (Natural -> Natural -> Natural :: *))}]
GHC.Natural.$fIntegralNatural_$cquot
  = GHC.Real.$fIntegralInteger_$cquot
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Integer -> Integer :: *)
               ~R# (Natural -> Natural -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
GHC.Natural.$fIntegralNatural_$crem [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Natural -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Real.$fIntegralInteger_$crem
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Integer -> Integer :: *)
                          ~R# (Natural -> Natural -> Natural :: *))}]
GHC.Natural.$fIntegralNatural_$crem
  = GHC.Real.$fIntegralInteger_$crem
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Integer -> Integer :: *)
               ~R# (Natural -> Natural -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
GHC.Natural.$fIntegralNatural_$cdiv [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Natural -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Real.$fIntegralInteger_$cdiv
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Integer -> Integer :: *)
                          ~R# (Natural -> Natural -> Natural :: *))}]
GHC.Natural.$fIntegralNatural_$cdiv
  = GHC.Real.$fIntegralInteger_$cdiv
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Integer -> Integer :: *)
               ~R# (Natural -> Natural -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
GHC.Natural.$fIntegralNatural_$cmod [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Natural -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Real.$fIntegralInteger_$cmod
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Integer -> Integer :: *)
                          ~R# (Natural -> Natural -> Natural :: *))}]
GHC.Natural.$fIntegralNatural_$cmod
  = GHC.Real.$fIntegralInteger_$cmod
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Integer -> Integer :: *)
               ~R# (Natural -> Natural -> Natural :: *))

-- RHS size: {terms: 17, types: 3, coercions: 13, joins: 0/0}
GHC.Natural.$fEnumNatural_$cenumFromThen
  :: Natural -> Natural -> [Natural]
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 150 0}]
GHC.Natural.$fEnumNatural_$cenumFromThen
  = \ (x_a4aLM :: Natural) (y_a4aLN :: Natural) ->
      case leInteger#
             (x_a4aLM
              `cast` (GHC.Natural.N:Natural[0]
                      :: (Natural :: *) ~R# (Integer :: *)))
             (y_a4aLN
              `cast` (GHC.Natural.N:Natural[0]
                      :: (Natural :: *) ~R# (Integer :: *)))
      of {
        __DEFAULT ->
          (GHC.Enum.enumDeltaToInteger
             (x_a4aLM
              `cast` (GHC.Natural.N:Natural[0]
                      :: (Natural :: *) ~R# (Integer :: *)))
             (minusInteger
                (y_a4aLN
                 `cast` (GHC.Natural.N:Natural[0]
                         :: (Natural :: *) ~R# (Integer :: *)))
                (x_a4aLM
                 `cast` (GHC.Natural.N:Natural[0]
                         :: (Natural :: *) ~R# (Integer :: *))))
             GHC.Natural.$fBitsNatural1)
          `cast` (([Sym (GHC.Natural.N:Natural[0])])_R
                  :: ([Integer] :: *) ~R# ([Natural] :: *));
        1# ->
          (GHC.Enum.$fEnumInteger_$cenumFromThen
             (x_a4aLM
              `cast` (GHC.Natural.N:Natural[0]
                      :: (Natural :: *) ~R# (Integer :: *)))
             (y_a4aLN
              `cast` (GHC.Natural.N:Natural[0]
                      :: (Natural :: *) ~R# (Integer :: *))))
          `cast` (([Sym (GHC.Natural.N:Natural[0])])_R
                  :: ([Integer] :: *) ~R# ([Natural] :: *))
      }

-- RHS size: {terms: 9, types: 1, coercions: 27, joins: 0/0}
GHC.Natural.$fEnumNatural [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum Natural
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Natural
                       GHC.Natural.$fEnumNatural_$csucc
                       GHC.Natural.$fEnumNatural_$cpred
                       GHC.Natural.$fEnumNatural_$ctoEnum
                       GHC.Natural.$fEnumNatural_$cfromEnum
                       GHC.Enum.$fEnumInteger_$cenumFrom
                       `cast` (Sym (GHC.Natural.N:Natural[0])
                               ->_R ([Sym (GHC.Natural.N:Natural[0])])_R
                               :: (Integer -> [Integer] :: *) ~R# (Natural -> [Natural] :: *))
                       GHC.Natural.$fEnumNatural_$cenumFromThen
                       GHC.Enum.$fEnumInteger_$cenumFromTo
                       `cast` (Sym (GHC.Natural.N:Natural[0])
                               ->_R Sym (GHC.Natural.N:Natural[0])
                               ->_R ([Sym (GHC.Natural.N:Natural[0])])_R
                               :: (Integer -> Integer -> [Integer] :: *)
                                  ~R# (Natural -> Natural -> [Natural] :: *))
                       GHC.Enum.$fEnumInteger_$cenumFromThenTo
                       `cast` (Sym (GHC.Natural.N:Natural[0])
                               ->_R Sym (GHC.Natural.N:Natural[0])
                               ->_R Sym (GHC.Natural.N:Natural[0])
                               ->_R ([Sym (GHC.Natural.N:Natural[0])])_R
                               :: (Integer -> Integer -> Integer -> [Integer] :: *)
                                  ~R# (Natural -> Natural -> Natural -> [Natural] :: *))]
GHC.Natural.$fEnumNatural
  = GHC.Enum.C:Enum
      @ Natural
      GHC.Natural.$fEnumNatural_$csucc
      GHC.Natural.$fEnumNatural_$cpred
      GHC.Natural.$fEnumNatural_$ctoEnum
      GHC.Natural.$fEnumNatural_$cfromEnum
      (GHC.Enum.$fEnumInteger_$cenumFrom
       `cast` (Sym (GHC.Natural.N:Natural[0])
               ->_R ([Sym (GHC.Natural.N:Natural[0])])_R
               :: (Integer -> [Integer] :: *) ~R# (Natural -> [Natural] :: *)))
      GHC.Natural.$fEnumNatural_$cenumFromThen
      (GHC.Enum.$fEnumInteger_$cenumFromTo
       `cast` (Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R ([Sym (GHC.Natural.N:Natural[0])])_R
               :: (Integer -> Integer -> [Integer] :: *)
                  ~R# (Natural -> Natural -> [Natural] :: *)))
      (GHC.Enum.$fEnumInteger_$cenumFromThenTo
       `cast` (Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R ([Sym (GHC.Natural.N:Natural[0])])_R
               :: (Integer -> Integer -> Integer -> [Integer] :: *)
                  ~R# (Natural -> Natural -> Natural -> [Natural] :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
GHC.Natural.$fIntegralNatural [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral Natural
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: Natural
                           GHC.Natural.$fRealNatural
                           GHC.Natural.$fEnumNatural
                           GHC.Natural.$fIntegralNatural_$cquot
                           GHC.Natural.$fIntegralNatural_$crem
                           GHC.Natural.$fIntegralNatural_$cdiv
                           GHC.Natural.$fIntegralNatural_$cmod
                           GHC.Natural.$fIntegralNatural_$cquotRem
                           GHC.Natural.$fIntegralNatural_$cdivMod
                           GHC.Natural.$fIntegralNatural_$ctoInteger]
GHC.Natural.$fIntegralNatural
  = GHC.Real.C:Integral
      @ Natural
      GHC.Natural.$fRealNatural
      GHC.Natural.$fEnumNatural
      GHC.Natural.$fIntegralNatural_$cquot
      GHC.Natural.$fIntegralNatural_$crem
      GHC.Natural.$fIntegralNatural_$cdiv
      GHC.Natural.$fIntegralNatural_$cmod
      GHC.Natural.$fIntegralNatural_$cquotRem
      GHC.Natural.$fIntegralNatural_$cdivMod
      GHC.Natural.$fIntegralNatural_$ctoInteger

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$seven_n :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Natural.$seven_n = 2

-- RHS size: {terms: 10, types: 12, coercions: 1, joins: 0/0}
GHC.Natural.$fShowNatural_$cshow :: Natural -> String
[GblId,
 Arity=1,
 Str=<S,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i1Jj2 [Occ=Once] :: Natural) ->
                 case GHC.Show.$w$cshowsPrec4
                        0#
                        (x_i1Jj2
                         `cast` (GHC.Natural.N:Natural[0]
                                 :: (Natural :: *) ~R# (Integer :: *)))
                        (GHC.Types.[] @ Char)
                 of
                 { (# ww3_i2pQo [Occ=Once], ww4_i2pQp [Occ=Once] #) ->
                 GHC.Types.: @ Char ww3_i2pQo ww4_i2pQp
                 }}]
GHC.Natural.$fShowNatural_$cshow
  = \ (x_i1Jj2 :: Natural) ->
      case GHC.Show.$w$cshowsPrec4
             0#
             (x_i1Jj2
              `cast` (GHC.Natural.N:Natural[0]
                      :: (Natural :: *) ~R# (Integer :: *)))
             (GHC.Types.[] @ Char)
      of
      { (# ww3_i2pQo, ww4_i2pQp #) ->
      GHC.Types.: @ Char ww3_i2pQo ww4_i2pQp
      }

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
GHC.Natural.$fShowNatural1 :: Integer -> ShowS
[GblId,
 Arity=2,
 Str=<S,U><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w1_i2pQf [Occ=Once] :: Integer)
                 (w2_i2pQg [Occ=Once] :: String) ->
                 case GHC.Show.$w$cshowsPrec4 0# w1_i2pQf w2_i2pQg of
                 { (# ww3_i2pQo [Occ=Once], ww4_i2pQp [Occ=Once] #) ->
                 GHC.Types.: @ Char ww3_i2pQo ww4_i2pQp
                 }}]
GHC.Natural.$fShowNatural1
  = \ (w1_i2pQf :: Integer) (w2_i2pQg :: String) ->
      case GHC.Show.$w$cshowsPrec4 0# w1_i2pQf w2_i2pQg of
      { (# ww3_i2pQo, ww4_i2pQp #) ->
      GHC.Types.: @ Char ww3_i2pQo ww4_i2pQp
      }

-- RHS size: {terms: 6, types: 4, coercions: 4, joins: 0/0}
GHC.Natural.$fShowNatural_$cshowList :: [Natural] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i1Mix [Occ=Once] :: [Natural])
                 (s_i1Miy [Occ=Once] :: String) ->
                 showList__
                   @ Natural
                   (GHC.Natural.$fShowNatural1
                    `cast` (Sym (GHC.Natural.N:Natural[0]) ->_R <ShowS>_R
                            :: (Integer -> ShowS :: *) ~R# (Natural -> ShowS :: *)))
                   ls_i1Mix
                   s_i1Miy}]
GHC.Natural.$fShowNatural_$cshowList
  = \ (ls_i1Mix :: [Natural]) (s_i1Miy :: String) ->
      showList__
        @ Natural
        (GHC.Natural.$fShowNatural1
         `cast` (Sym (GHC.Natural.N:Natural[0]) ->_R <ShowS>_R
                 :: (Integer -> ShowS :: *) ~R# (Natural -> ShowS :: *)))
        ls_i1Mix
        s_i1Miy

-- RHS size: {terms: 4, types: 1, coercions: 6, joins: 0/0}
GHC.Natural.$fShowNatural [InlPrag=NOUSERINLINE CONLIKE]
  :: Show Natural
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Natural
                       GHC.Show.$fShowInteger_$cshowsPrec
                       `cast` (<Int>_R ->_R Sym (GHC.Natural.N:Natural[0]) ->_R <ShowS>_R
                               :: (Int -> Integer -> ShowS :: *)
                                  ~R# (Int -> Natural -> ShowS :: *))
                       GHC.Natural.$fShowNatural_$cshow
                       GHC.Natural.$fShowNatural_$cshowList]
GHC.Natural.$fShowNatural
  = GHC.Show.C:Show
      @ Natural
      (GHC.Show.$fShowInteger_$cshowsPrec
       `cast` (<Int>_R ->_R Sym (GHC.Natural.N:Natural[0]) ->_R <ShowS>_R
               :: (Int -> Integer -> ShowS :: *)
                  ~R# (Int -> Natural -> ShowS :: *)))
      GHC.Natural.$fShowNatural_$cshow
      GHC.Natural.$fShowNatural_$cshowList

-- RHS size: {terms: 1, types: 0, coercions: 4, joins: 0/0}
GHC.Natural.$fBitsNatural_$cpopCount [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Int
[GblId,
 Arity=1,
 Str=<L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$cpopCount
               `cast` (Sym (GHC.Natural.N:Natural[0]) ->_R <Int>_R
                       :: (Integer -> Int :: *) ~R# (Natural -> Int :: *))}]
GHC.Natural.$fBitsNatural_$cpopCount
  = Data.Bits.$fBitsInteger_$cpopCount
    `cast` (Sym (GHC.Natural.N:Natural[0]) ->_R <Int>_R
            :: (Integer -> Int :: *) ~R# (Natural -> Int :: *))

-- RHS size: {terms: 1, types: 0, coercions: 7, joins: 0/0}
GHC.Natural.$fBitsNatural_$crotateR [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Int -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$crotateR
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R <Int>_R
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Int -> Integer :: *)
                          ~R# (Natural -> Int -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$crotateR
  = Data.Bits.$fBitsInteger_$crotateR
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R <Int>_R
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Int -> Integer :: *)
               ~R# (Natural -> Int -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 7, joins: 0/0}
GHC.Natural.$fBitsNatural_$crotateL [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Int -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$cshift
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R <Int>_R
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Int -> Integer :: *)
                          ~R# (Natural -> Int -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$crotateL
  = Data.Bits.$fBitsInteger_$cshift
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R <Int>_R
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Int -> Integer :: *)
               ~R# (Natural -> Int -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 7, joins: 0/0}
GHC.Natural.$fBitsNatural_$cshiftR [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Int -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$cshiftR
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R <Int>_R
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Int -> Integer :: *)
                          ~R# (Natural -> Int -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$cshiftR
  = Data.Bits.$fBitsInteger_$cshiftR
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R <Int>_R
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Int -> Integer :: *)
               ~R# (Natural -> Int -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 7, joins: 0/0}
GHC.Natural.$fBitsNatural_$cshiftL [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Int -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$cshift
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R <Int>_R
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Int -> Integer :: *)
                          ~R# (Natural -> Int -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$cshiftL
  = Data.Bits.$fBitsInteger_$cshift
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R <Int>_R
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Int -> Integer :: *)
               ~R# (Natural -> Int -> Natural :: *))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Natural.$fBitsNatural_$cisSigned [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.False}]
GHC.Natural.$fBitsNatural_$cisSigned
  = \ _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl4_r4bvH :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl4_r4bvH = "Natural: bitSize"#

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
GHC.Natural.$fBitsNatural_$cbitSize [InlPrag=INLINE (sat-args=0)]
  :: Natural -> Int
[GblId,
 Str=x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= errorWithoutStackTrace
                 @ 'LiftedRep
                 @ (Natural -> Int)
                 (build
                    @ Char
                    (\ (@ b_i1AKE) ->
                       unpackFoldrCString# @ b_i1AKE "Natural: bitSize"#))}]
GHC.Natural.$fBitsNatural_$cbitSize
  = errorWithoutStackTrace
      @ 'LiftedRep @ (Natural -> Int) (unpackCString# lvl4_r4bvH)

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
GHC.Natural.$fBitsNatural_$cbitSizeMaybe [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Maybe Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Base.Nothing @ Int}]
GHC.Natural.$fBitsNatural_$cbitSizeMaybe
  = \ _ [Occ=Dead] -> GHC.Base.Nothing @ Int

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
GHC.Natural.$fBitsNatural_$ctestBit [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$ctestBit
               `cast` (Sym (GHC.Natural.N:Natural[0]) ->_R <Int -> Bool>_R
                       :: (Integer -> Int -> Bool :: *)
                          ~R# (Natural -> Int -> Bool :: *))}]
GHC.Natural.$fBitsNatural_$ctestBit
  = Data.Bits.$fBitsInteger_$ctestBit
    `cast` (Sym (GHC.Natural.N:Natural[0]) ->_R <Int -> Bool>_R
            :: (Integer -> Int -> Bool :: *) ~R# (Natural -> Int -> Bool :: *))

-- RHS size: {terms: 1, types: 0, coercions: 7, joins: 0/0}
GHC.Natural.$fBitsNatural_$ccomplementBit [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Int -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$ccomplementBit
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R <Int>_R
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Int -> Integer :: *)
                          ~R# (Natural -> Int -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$ccomplementBit
  = Data.Bits.$fBitsInteger_$ccomplementBit
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R <Int>_R
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Int -> Integer :: *)
               ~R# (Natural -> Int -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 7, joins: 0/0}
GHC.Natural.$fBitsNatural_$cclearBit [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Int -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$cclearBit
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R <Int>_R
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Int -> Integer :: *)
                          ~R# (Natural -> Int -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$cclearBit
  = Data.Bits.$fBitsInteger_$cclearBit
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R <Int>_R
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Int -> Integer :: *)
               ~R# (Natural -> Int -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 7, joins: 0/0}
GHC.Natural.$fBitsNatural_$csetBit [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Int -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$csetBit
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R <Int>_R
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Int -> Integer :: *)
                          ~R# (Natural -> Int -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$csetBit
  = Data.Bits.$fBitsInteger_$csetBit
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R <Int>_R
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Int -> Integer :: *)
               ~R# (Natural -> Int -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 7, joins: 0/0}
GHC.Natural.$fBitsNatural_$crotate [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Int -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$cshift
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R <Int>_R
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Int -> Integer :: *)
                          ~R# (Natural -> Int -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$crotate
  = Data.Bits.$fBitsInteger_$cshift
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R <Int>_R
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Int -> Integer :: *)
               ~R# (Natural -> Int -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 7, joins: 0/0}
GHC.Natural.$fBitsNatural_$cshift [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Int -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$cshift
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R <Int>_R
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Int -> Integer :: *)
                          ~R# (Natural -> Int -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$cshift
  = Data.Bits.$fBitsInteger_$cshift
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R <Int>_R
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Int -> Integer :: *)
               ~R# (Natural -> Int -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl5_r4bvI :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl5_r4bvI = "Bits.complement: Natural complement undefined"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl6_r4bvJ :: [Char]
[GblId]
lvl6_r4bvJ = unpackCString# lvl5_r4bvI

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
GHC.Natural.$fBitsNatural_$ccomplement [InlPrag=INLINE (sat-args=1)]
  :: Natural -> Natural
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep
                   @ Natural
                   (build
                      @ Char
                      (\ (@ b_i1AKE) ->
                         unpackFoldrCString#
                           @ b_i1AKE "Bits.complement: Natural complement undefined"#))}]
GHC.Natural.$fBitsNatural_$ccomplement
  = \ _ [Occ=Dead] ->
      errorWithoutStackTrace @ 'LiftedRep @ Natural lvl6_r4bvJ

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
GHC.Natural.$fBitsNatural_$cxor [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Natural -> Natural
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= xorInteger
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Integer -> Integer :: *)
                          ~R# (Natural -> Natural -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$cxor
  = xorInteger
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Integer -> Integer :: *)
               ~R# (Natural -> Natural -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
GHC.Natural.$fBitsNatural_$c.|. [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Natural -> Natural
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= orInteger
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Integer -> Integer :: *)
                          ~R# (Natural -> Natural -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$c.|.
  = orInteger
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Integer -> Integer :: *)
               ~R# (Natural -> Natural -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
GHC.Natural.$fBitsNatural_$c.&. [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Natural -> Natural
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= andInteger
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Integer -> Integer :: *)
                          ~R# (Natural -> Natural -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$c.&.
  = andInteger
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Integer -> Integer :: *)
               ~R# (Natural -> Natural -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Natural.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Natural.$trModule3 = GHC.Types.TrNameS GHC.Natural.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Natural.$trModule2 = "GHC.Natural"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Natural.$trModule1 = GHC.Types.TrNameS GHC.Natural.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Natural.$trModule
  = GHC.Types.Module GHC.Natural.$trModule3 GHC.Natural.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_r4bvK :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_r4bvK
  = GHC.Types.KindRepTyConApp
      integer-simple-0.1.1.1:GHC.Integer.Type.$tcInteger
      (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$tcNatural2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Natural.$tcNatural2 = "Natural"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$tcNatural1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Natural.$tcNatural1 = GHC.Types.TrNameS GHC.Natural.$tcNatural2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$tcNatural :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Natural.$tcNatural
  = GHC.Types.TyCon
      18275189520134122949##
      2097940004095541788##
      GHC.Natural.$trModule
      GHC.Natural.$tcNatural1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_r4bvL :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_r4bvL
  = GHC.Types.KindRepTyConApp
      GHC.Natural.$tcNatural (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$tc'Natural1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Natural.$tc'Natural1
  = GHC.Types.KindRepFun $krep_r4bvK $krep1_r4bvL

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$tc'Natural3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Natural.$tc'Natural3 = "'Natural"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$tc'Natural2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Natural.$tc'Natural2
  = GHC.Types.TrNameS GHC.Natural.$tc'Natural3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$tc'Natural :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Natural.$tc'Natural
  = GHC.Types.TyCon
      11998593531750078056##
      1104420550366228074##
      GHC.Natural.$trModule
      GHC.Natural.$tc'Natural2
      0#
      GHC.Natural.$tc'Natural1

-- RHS size: {terms: 1, types: 0, coercions: 4, joins: 0/0}
wordToNatural :: Word -> Natural
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Real.$fIntegralWord_$ctoInteger
               `cast` (<Word>_R ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Word -> Integer :: *) ~R# (Word -> Natural :: *))}]
wordToNatural
  = GHC.Real.$fIntegralWord_$ctoInteger
    `cast` (<Word>_R ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Word -> Integer :: *) ~R# (Word -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.naturalToWordMaybe1 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Natural.naturalToWordMaybe1 = 18446744073709551615

-- RHS size: {terms: 15, types: 5, coercions: 2, joins: 0/0}
naturalToWordMaybe :: Natural -> Maybe Word
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 100 30}]
naturalToWordMaybe
  = \ (ds_d4b7r :: Natural) ->
      case leInteger#
             (ds_d4b7r
              `cast` (GHC.Natural.N:Natural[0]
                      :: (Natural :: *) ~R# (Integer :: *)))
             GHC.Natural.naturalToWordMaybe1
      of {
        __DEFAULT -> GHC.Base.Nothing @ Word;
        1# ->
          GHC.Base.Just
            @ Word
            (case integerToWord
                    (ds_d4b7r
                     `cast` (GHC.Natural.N:Natural[0]
                             :: (Natural :: *) ~R# (Integer :: *)))
             of wild1_i1AOf
             { __DEFAULT ->
             GHC.Types.W# wild1_i1AOf
             })
      }

Rec {
-- RHS size: {terms: 23, types: 29, coercions: 2, joins: 0/0}
GHC.Natural.$fReadNatural_go [Occ=LoopBreaker]
  :: [(Integer, String)] -> [(Natural, String)]
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
GHC.Natural.$fReadNatural_go
  = \ (ds_i1y1c :: [(Integer, String)]) ->
      case ds_i1y1c of {
        [] -> GHC.Types.[] @ (Natural, String);
        : y_i1y1h ys_i1y1i ->
          case y_i1y1h of { (x_a4aMk, ds1_d4bbm) ->
          case geInteger# x_a4aMk GHC.Natural.$fBitsNatural1 of {
            __DEFAULT -> GHC.Natural.$fReadNatural_go ys_i1y1i;
            1# ->
              GHC.Types.:
                @ (Natural, String)
                (x_a4aMk
                 `cast` (Sym (GHC.Natural.N:Natural[0])
                         :: (Integer :: *) ~R# (Natural :: *)),
                 ds1_d4bbm)
                (GHC.Natural.$fReadNatural_go ys_i1y1i)
          }
          }
      }
end Rec }

-- RHS size: {terms: 11, types: 7, coercions: 0, joins: 0/1}
GHC.Natural.$fReadNatural_$creadsPrec :: Int -> ReadS Natural
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 110 60}]
GHC.Natural.$fReadNatural_$creadsPrec
  = \ (d_a4aMh :: Int) ->
      let {
        g_s4bh0 :: Text.ParserCombinators.ReadP.P Integer
        [LclId]
        g_s4bh0
          = GHC.Read.$fReadInteger_$sreadNumber
              GHC.Read.$fReadInteger2
              d_a4aMh
              @ Integer
              (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ Integer) } in
      \ (x_X1Mkt :: String) ->
        GHC.Natural.$fReadNatural_go
          (Text.ParserCombinators.ReadP.run @ Integer g_s4bh0 x_X1Mkt)

-- RHS size: {terms: 21, types: 25, coercions: 0, joins: 0/2}
GHC.Natural.$fReadNatural4
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Natural -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 180 60}]
GHC.Natural.$fReadNatural4
  = \ (n_X3tpG :: Text.ParserCombinators.ReadPrec.Prec) ->
      let {
        g_s4bh0 :: Text.ParserCombinators.ReadP.P Integer
        [LclId]
        g_s4bh0
          = GHC.Read.$fReadInteger_$sreadNumber
              GHC.Read.$fReadInteger2
              n_X3tpG
              @ Integer
              (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ Integer) } in
      let {
        w_s4bgV [Dmd=<L,C(U)>] :: ReadS Natural
        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
        w_s4bgV
          = \ (x_X1Mkt :: String) ->
              GHC.Natural.$fReadNatural_go
                (Text.ParserCombinators.ReadP.run @ Integer g_s4bh0 x_X1Mkt) } in
      \ (@ b_s3ofG)
        (w1_s3ofH :: Natural -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
        case Text.ParserCombinators.ReadP.$wreadS_to_P
               @ Natural w_s4bgV @ b_s3ofG w1_s3ofH
        of
        { (# ww1_s3oiG #) ->
        Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
        }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.$fReadNatural3 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Natural.$fReadNatural3 = GHC.Types.I# 0#

-- RHS size: {terms: 4, types: 5, coercions: 15, joins: 0/0}
GHC.Natural.$fReadNatural2
  :: Text.ParserCombinators.ReadP.P [Natural]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
GHC.Natural.$fReadNatural2
  = ((((list
          @ Natural
          (GHC.Natural.$fReadNatural4
           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Natural>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Natural>_R)
                   :: (Text.ParserCombinators.ReadPrec.Prec
                       -> forall b.
                          (Natural -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)
                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Natural :: *))))
       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Natural]>_R
               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Natural] :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                       -> Text.ParserCombinators.ReadP.ReadP [Natural] :: *)))
        GHC.Natural.$fReadNatural3)
     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Natural]>_R
             :: (Text.ParserCombinators.ReadP.ReadP [Natural] :: *)
                ~R# (forall b.
                     ([Natural] -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b :: *)))
      @ [Natural]
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [Natural])

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
GHC.Natural.$fReadNatural_$creadList :: ReadS [Natural]
[GblId,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
GHC.Natural.$fReadNatural_$creadList
  = Text.ParserCombinators.ReadP.run
      @ [Natural] GHC.Natural.$fReadNatural2

-- RHS size: {terms: 10, types: 19, coercions: 0, joins: 0/0}
GHC.Natural.$fReadNatural1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([Natural] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,A><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_s3ofG)
                 (w1_s3ofH [Occ=Once]
                    :: [Natural] -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                        @ [Natural] GHC.Natural.$fReadNatural_$creadList @ b_s3ofG w1_s3ofH
                 of
                 { (# ww1_s3oiG [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
                 }}]
GHC.Natural.$fReadNatural1
  = \ _ [Occ=Dead]
      (@ b_s3ofG)
      (w1_s3ofH
         :: [Natural] -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
      case Text.ParserCombinators.ReadP.$wreadS_to_P
             @ [Natural] GHC.Natural.$fReadNatural_$creadList @ b_s3ofG w1_s3ofH
      of
      { (# ww1_s3oiG #) ->
      Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
      }

-- RHS size: {terms: 5, types: 1, coercions: 20, joins: 0/0}
GHC.Natural.$fReadNatural [InlPrag=NOUSERINLINE CONLIKE]
  :: Read Natural
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: Natural
                       GHC.Natural.$fReadNatural_$creadsPrec
                       GHC.Natural.$fReadNatural_$creadList
                       GHC.Natural.$fReadNatural4
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Natural>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       <Natural>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Natural -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Natural :: *))
                       GHC.Natural.$fReadNatural1
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Natural]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <[Natural]>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Natural] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [Natural] :: *))]
GHC.Natural.$fReadNatural
  = GHC.Read.C:Read
      @ Natural
      GHC.Natural.$fReadNatural_$creadsPrec
      GHC.Natural.$fReadNatural_$creadList
      (GHC.Natural.$fReadNatural4
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Natural>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <Natural>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Natural -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Natural :: *)))
      (GHC.Natural.$fReadNatural1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Natural]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                         <[Natural]>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Natural] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [Natural] :: *)))

-- RHS size: {terms: 8, types: 3, coercions: 1, joins: 0/0}
isValidNatural :: Natural -> Bool
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4b7C [Occ=Once] :: Natural) ->
                 case geInteger#
                        (ds_d4b7C
                         `cast` (GHC.Natural.N:Natural[0]
                                 :: (Natural :: *) ~R# (Integer :: *)))
                        GHC.Natural.$fBitsNatural1
                 of wild_aRJq
                 { __DEFAULT ->
                 tagToEnum# @ Bool wild_aRJq
                 }}]
isValidNatural
  = \ (ds_d4b7C :: Natural) ->
      case geInteger#
             (ds_d4b7C
              `cast` (GHC.Natural.N:Natural[0]
                      :: (Natural :: *) ~R# (Integer :: *)))
             GHC.Natural.$fBitsNatural1
      of wild_aRJq
      { __DEFAULT ->
      tagToEnum# @ Bool wild_aRJq
      }

-- RHS size: {terms: 13, types: 5, coercions: 2, joins: 0/0}
minusNaturalMaybe :: Natural -> Natural -> Maybe Natural
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4aMo :: Natural) (y_a4aMp :: Natural) ->
                 case geInteger#
                        (x_a4aMo
                         `cast` (GHC.Natural.N:Natural[0]
                                 :: (Natural :: *) ~R# (Integer :: *)))
                        (y_a4aMp
                         `cast` (GHC.Natural.N:Natural[0]
                                 :: (Natural :: *) ~R# (Integer :: *)))
                 of {
                   __DEFAULT -> GHC.Base.Nothing @ Natural;
                   1# ->
                     GHC.Base.Just
                       @ Natural (GHC.Natural.$fNumNatural_$c- x_a4aMo y_a4aMp)
                 }}]
minusNaturalMaybe
  = \ (x_a4aMo :: Natural) (y_a4aMp :: Natural) ->
      case geInteger#
             (x_a4aMo
              `cast` (GHC.Natural.N:Natural[0]
                      :: (Natural :: *) ~R# (Integer :: *)))
             (y_a4aMp
              `cast` (GHC.Natural.N:Natural[0]
                      :: (Natural :: *) ~R# (Integer :: *)))
      of {
        __DEFAULT -> GHC.Base.Nothing @ Natural;
        1# ->
          GHC.Base.Just
            @ Natural (GHC.Natural.$fNumNatural_$c- x_a4aMo y_a4aMp)
      }

-- RHS size: {terms: 8, types: 1, coercions: 53, joins: 0/0}
GHC.Natural.$fIxNatural [InlPrag=NOUSERINLINE CONLIKE]
  :: Ix Natural
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Arr.C:Ix TYPE: Natural
                    GHC.Natural.$fOrdNatural
                    GHC.Arr.$fIxInteger_$crange
                    `cast` (((,)
                               (Sym (GHC.Natural.N:Natural[0]))
                               (Sym (GHC.Natural.N:Natural[0])))_R
                            ->_R ([Sym (GHC.Natural.N:Natural[0])])_R
                            :: ((Integer, Integer) -> [Integer] :: *)
                               ~R# ((Natural, Natural) -> [Natural] :: *))
                    GHC.Arr.$fIxInteger_$cindex
                    `cast` (((,)
                               (Sym (GHC.Natural.N:Natural[0]))
                               (Sym (GHC.Natural.N:Natural[0])))_R
                            ->_R Sym (GHC.Natural.N:Natural[0])
                            ->_R <Int>_R
                            :: ((Integer, Integer) -> Integer -> Int :: *)
                               ~R# ((Natural, Natural) -> Natural -> Int :: *))
                    GHC.Arr.$fIxInteger_$cunsafeIndex
                    `cast` (((,)
                               (Sym (GHC.Natural.N:Natural[0]))
                               (Sym (GHC.Natural.N:Natural[0])))_R
                            ->_R Sym (GHC.Natural.N:Natural[0])
                            ->_R <Int>_R
                            :: ((Integer, Integer) -> Integer -> Int :: *)
                               ~R# ((Natural, Natural) -> Natural -> Int :: *))
                    GHC.Arr.$fIxInteger_$cinRange
                    `cast` (((,)
                               (Sym (GHC.Natural.N:Natural[0]))
                               (Sym (GHC.Natural.N:Natural[0])))_R
                            ->_R Sym (GHC.Natural.N:Natural[0])
                            ->_R <Bool>_R
                            :: ((Integer, Integer) -> Integer -> Bool :: *)
                               ~R# ((Natural, Natural) -> Natural -> Bool :: *))
                    GHC.Arr.$fIxInteger_$crangeSize
                    `cast` (((,)
                               (Sym (GHC.Natural.N:Natural[0]))
                               (Sym (GHC.Natural.N:Natural[0])))_R
                            ->_R <Int>_R
                            :: ((Integer, Integer) -> Int :: *)
                               ~R# ((Natural, Natural) -> Int :: *))
                    GHC.Arr.$fIxInteger_$cunsafeRangeSize
                    `cast` (((,)
                               (Sym (GHC.Natural.N:Natural[0]))
                               (Sym (GHC.Natural.N:Natural[0])))_R
                            ->_R <Int>_R
                            :: ((Integer, Integer) -> Int :: *)
                               ~R# ((Natural, Natural) -> Int :: *))]
GHC.Natural.$fIxNatural
  = GHC.Arr.C:Ix
      @ Natural
      GHC.Natural.$fOrdNatural
      (GHC.Arr.$fIxInteger_$crange
       `cast` (((,)
                  (Sym (GHC.Natural.N:Natural[0]))
                  (Sym (GHC.Natural.N:Natural[0])))_R
               ->_R ([Sym (GHC.Natural.N:Natural[0])])_R
               :: ((Integer, Integer) -> [Integer] :: *)
                  ~R# ((Natural, Natural) -> [Natural] :: *)))
      (GHC.Arr.$fIxInteger_$cindex
       `cast` (((,)
                  (Sym (GHC.Natural.N:Natural[0]))
                  (Sym (GHC.Natural.N:Natural[0])))_R
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R <Int>_R
               :: ((Integer, Integer) -> Integer -> Int :: *)
                  ~R# ((Natural, Natural) -> Natural -> Int :: *)))
      (GHC.Arr.$fIxInteger_$cunsafeIndex
       `cast` (((,)
                  (Sym (GHC.Natural.N:Natural[0]))
                  (Sym (GHC.Natural.N:Natural[0])))_R
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R <Int>_R
               :: ((Integer, Integer) -> Integer -> Int :: *)
                  ~R# ((Natural, Natural) -> Natural -> Int :: *)))
      (GHC.Arr.$fIxInteger_$cinRange
       `cast` (((,)
                  (Sym (GHC.Natural.N:Natural[0]))
                  (Sym (GHC.Natural.N:Natural[0])))_R
               ->_R Sym (GHC.Natural.N:Natural[0])
               ->_R <Bool>_R
               :: ((Integer, Integer) -> Integer -> Bool :: *)
                  ~R# ((Natural, Natural) -> Natural -> Bool :: *)))
      (GHC.Arr.$fIxInteger_$crangeSize
       `cast` (((,)
                  (Sym (GHC.Natural.N:Natural[0]))
                  (Sym (GHC.Natural.N:Natural[0])))_R
               ->_R <Int>_R
               :: ((Integer, Integer) -> Int :: *)
                  ~R# ((Natural, Natural) -> Int :: *)))
      (GHC.Arr.$fIxInteger_$cunsafeRangeSize
       `cast` (((,)
                  (Sym (GHC.Natural.N:Natural[0]))
                  (Sym (GHC.Natural.N:Natural[0])))_R
               ->_R <Int>_R
               :: ((Integer, Integer) -> Int :: *)
                  ~R# ((Natural, Natural) -> Int :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 7, joins: 0/0}
GHC.Natural.$fBitsNatural_$cunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Int -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$cshift
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R <Int>_R
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Int -> Integer :: *)
                          ~R# (Natural -> Int -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$cunsafeShiftL
  = Data.Bits.$fBitsInteger_$cshift
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R <Int>_R
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Int -> Integer :: *)
               ~R# (Natural -> Int -> Natural :: *))

-- RHS size: {terms: 1, types: 0, coercions: 7, joins: 0/0}
GHC.Natural.$fBitsNatural_$cunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: Natural -> Int -> Natural
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$cshiftR
               `cast` (Sym (GHC.Natural.N:Natural[0])
                       ->_R <Int>_R
                       ->_R Sym (GHC.Natural.N:Natural[0])
                       :: (Integer -> Int -> Integer :: *)
                          ~R# (Natural -> Int -> Natural :: *))}]
GHC.Natural.$fBitsNatural_$cunsafeShiftR
  = Data.Bits.$fBitsInteger_$cshiftR
    `cast` (Sym (GHC.Natural.N:Natural[0])
            ->_R <Int>_R
            ->_R Sym (GHC.Natural.N:Natural[0])
            :: (Integer -> Int -> Integer :: *)
               ~R# (Natural -> Int -> Natural :: *))

-- RHS size: {terms: 24, types: 1, coercions: 6, joins: 0/0}
GHC.Natural.$fBitsNatural [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits Natural
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: Natural
                        GHC.Natural.$fEqNatural
                        GHC.Natural.$fBitsNatural_$c.&.
                        GHC.Natural.$fBitsNatural_$c.|.
                        GHC.Natural.$fBitsNatural_$cxor
                        GHC.Natural.$fBitsNatural_$ccomplement
                        GHC.Natural.$fBitsNatural_$cshift
                        GHC.Natural.$fBitsNatural_$crotate
                        GHC.Natural.$fBitsNatural1
                        `cast` (Sym (GHC.Natural.N:Natural[0])
                                :: (Integer :: *) ~R# (Natural :: *))
                        Data.Bits.$fBitsInteger_$cbit
                        `cast` (<Int>_R ->_R Sym (GHC.Natural.N:Natural[0])
                                :: (Int -> Integer :: *) ~R# (Int -> Natural :: *))
                        GHC.Natural.$fBitsNatural_$csetBit
                        GHC.Natural.$fBitsNatural_$cclearBit
                        GHC.Natural.$fBitsNatural_$ccomplementBit
                        GHC.Natural.$fBitsNatural_$ctestBit
                        GHC.Natural.$fBitsNatural_$cbitSizeMaybe
                        GHC.Natural.$fBitsNatural_$cbitSize
                        GHC.Natural.$fBitsNatural_$cisSigned
                        GHC.Natural.$fBitsNatural_$cshiftL
                        GHC.Natural.$fBitsNatural_$cunsafeShiftL
                        GHC.Natural.$fBitsNatural_$cshiftR
                        GHC.Natural.$fBitsNatural_$cunsafeShiftR
                        GHC.Natural.$fBitsNatural_$crotateL
                        GHC.Natural.$fBitsNatural_$crotateR
                        GHC.Natural.$fBitsNatural_$cpopCount]
GHC.Natural.$fBitsNatural
  = Data.Bits.C:Bits
      @ Natural
      GHC.Natural.$fEqNatural
      GHC.Natural.$fBitsNatural_$c.&.
      GHC.Natural.$fBitsNatural_$c.|.
      GHC.Natural.$fBitsNatural_$cxor
      GHC.Natural.$fBitsNatural_$ccomplement
      GHC.Natural.$fBitsNatural_$cshift
      GHC.Natural.$fBitsNatural_$crotate
      (GHC.Natural.$fBitsNatural1
       `cast` (Sym (GHC.Natural.N:Natural[0])
               :: (Integer :: *) ~R# (Natural :: *)))
      (Data.Bits.$fBitsInteger_$cbit
       `cast` (<Int>_R ->_R Sym (GHC.Natural.N:Natural[0])
               :: (Int -> Integer :: *) ~R# (Int -> Natural :: *)))
      GHC.Natural.$fBitsNatural_$csetBit
      GHC.Natural.$fBitsNatural_$cclearBit
      GHC.Natural.$fBitsNatural_$ccomplementBit
      GHC.Natural.$fBitsNatural_$ctestBit
      GHC.Natural.$fBitsNatural_$cbitSizeMaybe
      GHC.Natural.$fBitsNatural_$cbitSize
      GHC.Natural.$fBitsNatural_$cisSigned
      GHC.Natural.$fBitsNatural_$cshiftL
      GHC.Natural.$fBitsNatural_$cunsafeShiftL
      GHC.Natural.$fBitsNatural_$cshiftR
      GHC.Natural.$fBitsNatural_$cunsafeShiftR
      GHC.Natural.$fBitsNatural_$crotateL
      GHC.Natural.$fBitsNatural_$crotateR
      GHC.Natural.$fBitsNatural_$cpopCount

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Natural.powModNatural1 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Natural.powModNatural1 = 1

-- RHS size: {terms: 88, types: 19, coercions: 34, joins: 1/1}
powModNatural :: Natural -> Natural -> Natural -> Natural
[GblId,
 Arity=3,
 Str=<L,U><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 654 0}]
powModNatural
  = \ (ds_d4b6y :: Natural)
      (ds1_d4b6z :: Natural)
      (ds2_d4b6A :: Natural) ->
      case eqInteger#
             (ds2_d4b6A
              `cast` (GHC.Natural.N:Natural[0]
                      :: (Natural :: *) ~R# (Integer :: *)))
             GHC.Natural.$fBitsNatural1
      of wild_a1foK {
        __DEFAULT ->
          case eqInteger#
                 (ds2_d4b6A
                  `cast` (GHC.Natural.N:Natural[0]
                          :: (Natural :: *) ~R# (Integer :: *)))
                 GHC.Natural.powModNatural1
          of {
            __DEFAULT ->
              case eqInteger#
                     (ds1_d4b6z
                      `cast` (GHC.Natural.N:Natural[0]
                              :: (Natural :: *) ~R# (Integer :: *)))
                     GHC.Natural.$fBitsNatural1
              of {
                __DEFAULT ->
                  case eqInteger#
                         (ds_d4b6y
                          `cast` (GHC.Natural.N:Natural[0]
                                  :: (Natural :: *) ~R# (Integer :: *)))
                         GHC.Natural.$fBitsNatural1
                  of {
                    __DEFAULT ->
                      case eqInteger#
                             (ds_d4b6y
                              `cast` (GHC.Natural.N:Natural[0]
                                      :: (Natural :: *) ~R# (Integer :: *)))
                             GHC.Natural.powModNatural1
                      of {
                        __DEFAULT ->
                          joinrec {
                            go_s4bgP [Occ=LoopBreaker]
                              :: Natural -> Natural -> Natural -> Natural
                            [LclId[JoinId(3)],
                             Arity=3,
                             Str=<S,1*U><S,U><S,1*U>,
                             Unf=OtherCon []]
                            go_s4bgP (b_a4aMx :: Natural)
                                     (e_a4aMy :: Natural)
                                     (r_a4aMz :: Natural)
                              = case b_a4aMx
                                     `cast` (GHC.Natural.N:Natural[0]
                                             :: (Natural :: *) ~R# (Integer :: *))
                                of nt_s4bev
                                { __DEFAULT ->
                                case eqInteger#
                                       (remInteger
                                          (e_a4aMy
                                           `cast` (GHC.Natural.N:Natural[0]
                                                   :: (Natural :: *) ~R# (Integer :: *)))
                                          GHC.Natural.$seven_n)
                                       GHC.Natural.$fBitsNatural1
                                of {
                                  __DEFAULT ->
                                    jump go_s4bgP
                                      ((modInteger
                                          (timesInteger nt_s4bev nt_s4bev)
                                          (ds2_d4b6A
                                           `cast` (GHC.Natural.N:Natural[0]
                                                   :: (Natural :: *) ~R# (Integer :: *))))
                                       `cast` (Sym (GHC.Natural.N:Natural[0])
                                               :: (Integer :: *) ~R# (Natural :: *)))
                                      ((shiftRInteger
                                          (e_a4aMy
                                           `cast` (GHC.Natural.N:Natural[0]
                                                   :: (Natural :: *) ~R# (Integer :: *)))
                                          1#)
                                       `cast` (Sym (GHC.Natural.N:Natural[0])
                                               :: (Integer :: *) ~R# (Natural :: *)))
                                      ((modInteger
                                          (timesInteger
                                             (r_a4aMz
                                              `cast` (GHC.Natural.N:Natural[0]
                                                      :: (Natural :: *) ~R# (Integer :: *)))
                                             nt_s4bev)
                                          (ds2_d4b6A
                                           `cast` (GHC.Natural.N:Natural[0]
                                                   :: (Natural :: *) ~R# (Integer :: *))))
                                       `cast` (Sym (GHC.Natural.N:Natural[0])
                                               :: (Integer :: *) ~R# (Natural :: *)));
                                  1# ->
                                    case eqInteger#
                                           (e_a4aMy
                                            `cast` (GHC.Natural.N:Natural[0]
                                                    :: (Natural :: *) ~R# (Integer :: *)))
                                           GHC.Natural.$fBitsNatural1
                                    of {
                                      __DEFAULT ->
                                        jump go_s4bgP
                                          ((modInteger
                                              (timesInteger nt_s4bev nt_s4bev)
                                              (ds2_d4b6A
                                               `cast` (GHC.Natural.N:Natural[0]
                                                       :: (Natural :: *) ~R# (Integer :: *))))
                                           `cast` (Sym (GHC.Natural.N:Natural[0])
                                                   :: (Integer :: *) ~R# (Natural :: *)))
                                          ((shiftRInteger
                                              (e_a4aMy
                                               `cast` (GHC.Natural.N:Natural[0]
                                                       :: (Natural :: *) ~R# (Integer :: *)))
                                              1#)
                                           `cast` (Sym (GHC.Natural.N:Natural[0])
                                                   :: (Integer :: *) ~R# (Natural :: *)))
                                          r_a4aMz;
                                      1# -> r_a4aMz
                                    }
                                }
                                }; } in
                          jump go_s4bgP
                            ds_d4b6y
                            ds1_d4b6z
                            (GHC.Natural.powModNatural1
                             `cast` (Sym (GHC.Natural.N:Natural[0])
                                     :: (Integer :: *) ~R# (Natural :: *)));
                        1# ->
                          GHC.Natural.powModNatural1
                          `cast` (Sym (GHC.Natural.N:Natural[0])
                                  :: (Integer :: *) ~R# (Natural :: *))
                      };
                    1# ->
                      GHC.Natural.$fBitsNatural1
                      `cast` (Sym (GHC.Natural.N:Natural[0])
                              :: (Integer :: *) ~R# (Natural :: *))
                  };
                1# ->
                  GHC.Natural.powModNatural1
                  `cast` (Sym (GHC.Natural.N:Natural[0])
                          :: (Integer :: *) ~R# (Natural :: *))
              };
            1# ->
              GHC.Natural.$fBitsNatural1
              `cast` (Sym (GHC.Natural.N:Natural[0])
                      :: (Integer :: *) ~R# (Natural :: *))
          };
        1# -> divZeroError @ Natural
      }


