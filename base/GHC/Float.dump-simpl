
==================== Tidy Core ====================
2018-03-16 15:57:27.497818007 UTC

Result size of Tidy Core
  = {terms: 10,478, types: 8,382, coercions: 0, joins: 66/252}

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
GHC.Float.$p1Floating :: forall a. Floating a => Fractional a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLLLLLLLLLLLLLLLL),U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for GHC.Float.$p1Floating: "Class op $p1Floating"]
GHC.Float.$p1Floating
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_B2
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
pi :: forall a. Floating a => a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLLLLLLLLLLLLLLLL),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for pi: "Class op pi"]
pi
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_B3
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
exp :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLLLLLLLLLLLLLLLL),U(A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for exp: "Class op exp"]
exp
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_B4
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
log :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLLLLLLLLLLLLLLLL),U(A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for log: "Class op log"]
log
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_B5
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
sqrt :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLLLLLLLLLLLLLLLL),U(A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for sqrt: "Class op sqrt"]
sqrt
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_B6
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
** :: forall a. Floating a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLLLLLLLLLLLLLLLL),U(A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for **: "Class op **"]
**
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_B7
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
logBase :: forall a. Floating a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLLLLLLLLLLLLLLLL),U(A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for logBase: "Class op logBase"]
logBase
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_B8
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
sin :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSLLLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for sin: "Class op sin"]
sin
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_B9
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
cos :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLSLLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for cos: "Class op cos"]
cos
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Ba
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
tan :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLSLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for tan: "Class op tan"]
tan
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Bb
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
asin :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLSLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for asin: "Class op asin"]
asin
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Bc
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
acos :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLSLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for acos: "Class op acos"]
acos
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Bd
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
atan :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLSLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for atan: "Class op atan"]
atan
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Be
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
sinh :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLSLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for sinh: "Class op sinh"]
sinh
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Bf
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
cosh :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLSLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for cosh: "Class op cosh"]
cosh
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Bg
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
tanh :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLSLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A)>,
 RULES: Built in rule for tanh: "Class op tanh"]
tanh
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Bh
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
asinh :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLSLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A)>,
 RULES: Built in rule for asinh: "Class op asinh"]
asinh
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Bi
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
acosh :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLSLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A)>,
 RULES: Built in rule for acosh: "Class op acosh"]
acosh
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Bj
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
atanh :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLSLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A)>,
 RULES: Built in rule for atanh: "Class op atanh"]
atanh
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Bk
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
log1p :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLSLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A)>,
 RULES: Built in rule for log1p: "Class op log1p"]
log1p
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Bl
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
expm1 :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLSLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A)>,
 RULES: Built in rule for expm1: "Class op expm1"]
expm1
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Bm
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
log1pexp :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A)>,
 RULES: Built in rule for log1pexp: "Class op log1pexp"]
log1pexp
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Bn
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
log1mexp :: forall a. Floating a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLLLS),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U)>,
 RULES: Built in rule for log1mexp: "Class op log1mexp"]
log1mexp
  = \ (@ a_a2HXU) (v_B1 :: Floating a_a2HXU) ->
      case v_B1 of v_B1
      { GHC.Float.C:Floating v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                             v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                             v_Bo ->
      v_Bo
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
GHC.Float.$p1RealFloat :: forall a. RealFloat a => RealFrac a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLLLLLLLLL),U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for GHC.Float.$p1RealFloat: "Class op $p1RealFloat"]
GHC.Float.$p1RealFloat
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B2
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
GHC.Float.$p2RealFloat :: forall a. RealFloat a => Floating a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLLLLLLLLL),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for GHC.Float.$p2RealFloat: "Class op $p2RealFloat"]
GHC.Float.$p2RealFloat
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B3
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
floatRadix :: forall a. RealFloat a => a -> Integer
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLLLLLLLLL),U(A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for floatRadix: "Class op floatRadix"]
floatRadix
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B4
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
floatDigits :: forall a. RealFloat a => a -> Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLLLLLLLLL),U(A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for floatDigits: "Class op floatDigits"]
floatDigits
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B5
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
floatRange :: forall a. RealFloat a => a -> (Int, Int)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLLLLLLLLL),U(A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for floatRange: "Class op floatRange"]
floatRange
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B6
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
decodeFloat :: forall a. RealFloat a => a -> (Integer, Int)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLLLLLLLLL),U(A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for decodeFloat: "Class op decodeFloat"]
decodeFloat
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B7
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
encodeFloat :: forall a. RealFloat a => Integer -> Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLLLLLLLLL),U(A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for encodeFloat: "Class op encodeFloat"]
encodeFloat
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B8
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
exponent :: forall a. RealFloat a => a -> Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSLLLLLLLL),U(A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for exponent: "Class op exponent"]
exponent
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B9
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
significand :: forall a. RealFloat a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLSLLLLLLL),U(A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A)>,
 RULES: Built in rule for significand: "Class op significand"]
significand
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Ba
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
scaleFloat :: forall a. RealFloat a => Int -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLSLLLLLL),U(A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A)>,
 RULES: Built in rule for scaleFloat: "Class op scaleFloat"]
scaleFloat
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Bb
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
isNaN :: forall a. RealFloat a => a -> Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLSLLLLL),U(A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A)>,
 RULES: Built in rule for isNaN: "Class op isNaN"]
isNaN
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Bc
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
isInfinite :: forall a. RealFloat a => a -> Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLSLLLL),U(A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A)>,
 RULES: Built in rule for isInfinite: "Class op isInfinite"]
isInfinite
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Bd
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
isDenormalized :: forall a. RealFloat a => a -> Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLSLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A)>,
 RULES: Built in rule for isDenormalized: "Class op isDenormalized"]
isDenormalized
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Be
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
isNegativeZero :: forall a. RealFloat a => a -> Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLSLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A)>,
 RULES: Built in rule for isNegativeZero: "Class op isNegativeZero"]
isNegativeZero
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Bf
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
isIEEE :: forall a. RealFloat a => a -> Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A)>,
 RULES: Built in rule for isIEEE: "Class op isIEEE"]
isIEEE
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Bg
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
atan2 :: forall a. RealFloat a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLS),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U)>,
 RULES: Built in rule for atan2: "Class op atan2"]
atan2
  = \ (@ a_a2HXC) (v_B1 :: RealFloat a_a2HXC) ->
      case v_B1 of v_B1
      { GHC.Float.C:RealFloat v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                              v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Bh
      }

-- RHS size: {terms: 12, types: 4, coercions: 0, joins: 0/0}
GHC.Float.$seven :: Int -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_i2K6A [Occ=Once!] :: Int) ->
                 case n_i2K6A of { I# x1_i2M5m [Occ=Once] ->
                 case remInt# x1_i2M5m 2# of {
                   __DEFAULT -> GHC.Types.False;
                   0# -> GHC.Types.True
                 }
                 }}]
GHC.Float.$seven
  = \ (n_i2K6A :: Int) ->
      case n_i2K6A of { I# x1_i2M5m ->
      case remInt# x1_i2M5m 2# of {
        __DEFAULT -> GHC.Types.False;
        0# -> GHC.Types.True
      }
      }

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.Float.$fNumFloat_$cfromInteger [InlPrag=INLINE (sat-args=1)]
  :: Integer -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (i_a2I0N [Occ=Once] :: Integer) ->
                 case floatFromInteger i_a2I0N of wild_X5a { __DEFAULT ->
                 GHC.Types.F# wild_X5a
                 }}]
GHC.Float.$fNumFloat_$cfromInteger
  = \ (i_a2I0N :: Integer) ->
      case floatFromInteger i_a2I0N of wild_X5a { __DEFAULT ->
      GHC.Types.F# wild_X5a
      }

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.Float.$fNumDouble_$cfromInteger [InlPrag=INLINE (sat-args=1)]
  :: Integer -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (i_a2HZs [Occ=Once] :: Integer) ->
                 case doubleFromInteger i_a2HZs of wild_X5c { __DEFAULT ->
                 GHC.Types.D# wild_X5c
                 }}]
GHC.Float.$fNumDouble_$cfromInteger
  = \ (i_a2HZs :: Integer) ->
      case doubleFromInteger i_a2HZs of wild_X5c { __DEFAULT ->
      GHC.Types.D# wild_X5c
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
plusFloat :: Float -> Float -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JNB [Occ=Once!] :: Float)
                 (ds1_d2JNC [Occ=Once!] :: Float) ->
                 case ds_d2JNB of { F# x_a2I3r [Occ=Once] ->
                 case ds1_d2JNC of { F# y_a2I3s [Occ=Once] ->
                 GHC.Types.F# (plusFloat# x_a2I3r y_a2I3s)
                 }
                 }}]
plusFloat
  = \ (ds_d2JNB :: Float) (ds1_d2JNC :: Float) ->
      case ds_d2JNB of { F# x_a2I3r ->
      case ds1_d2JNC of { F# y_a2I3s ->
      GHC.Types.F# (plusFloat# x_a2I3r y_a2I3s)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
minusFloat :: Float -> Float -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JNu [Occ=Once!] :: Float)
                 (ds1_d2JNv [Occ=Once!] :: Float) ->
                 case ds_d2JNu of { F# x_a2I3t [Occ=Once] ->
                 case ds1_d2JNv of { F# y_a2I3u [Occ=Once] ->
                 GHC.Types.F# (minusFloat# x_a2I3t y_a2I3u)
                 }
                 }}]
minusFloat
  = \ (ds_d2JNu :: Float) (ds1_d2JNv :: Float) ->
      case ds_d2JNu of { F# x_a2I3t ->
      case ds1_d2JNv of { F# y_a2I3u ->
      GHC.Types.F# (minusFloat# x_a2I3t y_a2I3u)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
timesFloat :: Float -> Float -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JNn [Occ=Once!] :: Float)
                 (ds1_d2JNo [Occ=Once!] :: Float) ->
                 case ds_d2JNn of { F# x_a2I3v [Occ=Once] ->
                 case ds1_d2JNo of { F# y_a2I3w [Occ=Once] ->
                 GHC.Types.F# (timesFloat# x_a2I3v y_a2I3w)
                 }
                 }}]
timesFloat
  = \ (ds_d2JNn :: Float) (ds1_d2JNo :: Float) ->
      case ds_d2JNn of { F# x_a2I3v ->
      case ds1_d2JNo of { F# y_a2I3w ->
      GHC.Types.F# (timesFloat# x_a2I3v y_a2I3w)
      }
      }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
divideFloat :: Float -> Float -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JNg [Occ=Once!] :: Float)
                 (ds1_d2JNh [Occ=Once!] :: Float) ->
                 case ds_d2JNg of { F# x_a2I3x [Occ=Once] ->
                 case ds1_d2JNh of { F# y_a2I3y [Occ=Once] ->
                 case divideFloat# x_a2I3x y_a2I3y of wild2_XH { __DEFAULT ->
                 GHC.Types.F# wild2_XH
                 }
                 }
                 }}]
divideFloat
  = \ (ds_d2JNg :: Float) (ds1_d2JNh :: Float) ->
      case ds_d2JNg of { F# x_a2I3x ->
      case ds1_d2JNh of { F# y_a2I3y ->
      case divideFloat# x_a2I3x y_a2I3y of wild2_XH { __DEFAULT ->
      GHC.Types.F# wild2_XH
      }
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
negateFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JNc [Occ=Once!] :: Float) ->
                 case ds_d2JNc of { F# x_a2I3z [Occ=Once] ->
                 GHC.Types.F# (negateFloat# x_a2I3z)
                 }}]
negateFloat
  = \ (ds_d2JNc :: Float) ->
      case ds_d2JNc of { F# x_a2I3z ->
      GHC.Types.F# (negateFloat# x_a2I3z)
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fNumFloat1 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fNumFloat1 = GHC.Types.F# 1.0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fNumFloat2 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fNumFloat2 = GHC.Types.F# -1.0#

-- RHS size: {terms: 19, types: 5, coercions: 0, joins: 0/0}
GHC.Float.$fNumFloat_$csignum :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2I0M [Occ=Once!] :: Float) ->
                 case x_a2I0M of wild_a2KCQ { F# x1_a2KCS ->
                 case gtFloat# x1_a2KCS 0.0# of {
                   __DEFAULT ->
                     case ltFloat# x1_a2KCS 0.0# of {
                       __DEFAULT -> wild_a2KCQ;
                       1# -> GHC.Float.$fNumFloat2
                     };
                   1# -> GHC.Float.$fNumFloat1
                 }
                 }}]
GHC.Float.$fNumFloat_$csignum
  = \ (x_a2I0M :: Float) ->
      case x_a2I0M of wild_a2KCQ { F# x1_a2KCS ->
      case gtFloat# x1_a2KCS 0.0# of {
        __DEFAULT ->
          case ltFloat# x1_a2KCS 0.0# of {
            __DEFAULT -> wild_a2KCQ;
            1# -> GHC.Float.$fNumFloat2
          };
        1# -> GHC.Float.$fNumFloat1
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fRealDouble1 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Float.$fRealDouble1 = 1

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
fabsFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JMu [Occ=Once!] :: Float) ->
                 case ds_d2JMu of { F# x_a2I3L [Occ=Once] ->
                 GHC.Types.F# (fabsFloat# x_a2I3L)
                 }}]
fabsFloat
  = \ (ds_d2JMu :: Float) ->
      case ds_d2JMu of { F# x_a2I3L ->
      GHC.Types.F# (fabsFloat# x_a2I3L)
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fNumFloat [InlPrag=NOUSERINLINE CONLIKE] :: Num Float
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Float
                     plusFloat
                     minusFloat
                     timesFloat
                     negateFloat
                     fabsFloat
                     GHC.Float.$fNumFloat_$csignum
                     GHC.Float.$fNumFloat_$cfromInteger]
GHC.Float.$fNumFloat
  = GHC.Num.C:Num
      @ Float
      plusFloat
      minusFloat
      timesFloat
      negateFloat
      fabsFloat
      GHC.Float.$fNumFloat_$csignum
      GHC.Float.$fNumFloat_$cfromInteger

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
plusDouble :: Double -> Double -> Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JLG [Occ=Once!] :: Double)
                 (ds1_d2JLH [Occ=Once!] :: Double) ->
                 case ds_d2JLG of { D# x_a2I3X [Occ=Once] ->
                 case ds1_d2JLH of { D# y_a2I3Y [Occ=Once] ->
                 GHC.Types.D# (+## x_a2I3X y_a2I3Y)
                 }
                 }}]
plusDouble
  = \ (ds_d2JLG :: Double) (ds1_d2JLH :: Double) ->
      case ds_d2JLG of { D# x_a2I3X ->
      case ds1_d2JLH of { D# y_a2I3Y ->
      GHC.Types.D# (+## x_a2I3X y_a2I3Y)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
minusDouble :: Double -> Double -> Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JLz [Occ=Once!] :: Double)
                 (ds1_d2JLA [Occ=Once!] :: Double) ->
                 case ds_d2JLz of { D# x_a2I3Z [Occ=Once] ->
                 case ds1_d2JLA of { D# y_a2I40 [Occ=Once] ->
                 GHC.Types.D# (-## x_a2I3Z y_a2I40)
                 }
                 }}]
minusDouble
  = \ (ds_d2JLz :: Double) (ds1_d2JLA :: Double) ->
      case ds_d2JLz of { D# x_a2I3Z ->
      case ds1_d2JLA of { D# y_a2I40 ->
      GHC.Types.D# (-## x_a2I3Z y_a2I40)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
timesDouble :: Double -> Double -> Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JLs [Occ=Once!] :: Double)
                 (ds1_d2JLt [Occ=Once!] :: Double) ->
                 case ds_d2JLs of { D# x_a2I41 [Occ=Once] ->
                 case ds1_d2JLt of { D# y_a2I42 [Occ=Once] ->
                 GHC.Types.D# (*## x_a2I41 y_a2I42)
                 }
                 }}]
timesDouble
  = \ (ds_d2JLs :: Double) (ds1_d2JLt :: Double) ->
      case ds_d2JLs of { D# x_a2I41 ->
      case ds1_d2JLt of { D# y_a2I42 ->
      GHC.Types.D# (*## x_a2I41 y_a2I42)
      }
      }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
divideDouble :: Double -> Double -> Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JLl [Occ=Once!] :: Double)
                 (ds1_d2JLm [Occ=Once!] :: Double) ->
                 case ds_d2JLl of { D# x_a2I43 [Occ=Once] ->
                 case ds1_d2JLm of { D# y_a2I44 [Occ=Once] ->
                 case /## x_a2I43 y_a2I44 of wild2_X1p { __DEFAULT ->
                 GHC.Types.D# wild2_X1p
                 }
                 }
                 }}]
divideDouble
  = \ (ds_d2JLl :: Double) (ds1_d2JLm :: Double) ->
      case ds_d2JLl of { D# x_a2I43 ->
      case ds1_d2JLm of { D# y_a2I44 ->
      case /## x_a2I43 y_a2I44 of wild2_X1p { __DEFAULT ->
      GHC.Types.D# wild2_X1p
      }
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
negateDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JLh [Occ=Once!] :: Double) ->
                 case ds_d2JLh of { D# x_a2I45 [Occ=Once] ->
                 GHC.Types.D# (negateDouble# x_a2I45)
                 }}]
negateDouble
  = \ (ds_d2JLh :: Double) ->
      case ds_d2JLh of { D# x_a2I45 ->
      GHC.Types.D# (negateDouble# x_a2I45)
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fNumDouble1 :: Double
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fNumDouble1 = GHC.Types.D# 1.0##

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fNumDouble2 :: Double
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fNumDouble2 = GHC.Types.D# -1.0##

-- RHS size: {terms: 19, types: 5, coercions: 0, joins: 0/0}
GHC.Float.$fNumDouble_$csignum :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HZr [Occ=Once!] :: Double) ->
                 case x_a2HZr of wild_a2KDV { D# x1_a2KDX ->
                 case >## x1_a2KDX 0.0## of {
                   __DEFAULT ->
                     case <## x1_a2KDX 0.0## of {
                       __DEFAULT -> wild_a2KDV;
                       1# -> GHC.Float.$fNumDouble2
                     };
                   1# -> GHC.Float.$fNumDouble1
                 }
                 }}]
GHC.Float.$fNumDouble_$csignum
  = \ (x_a2HZr :: Double) ->
      case x_a2HZr of wild_a2KDV { D# x1_a2KDX ->
      case >## x1_a2KDX 0.0## of {
        __DEFAULT ->
          case <## x1_a2KDX 0.0## of {
            __DEFAULT -> wild_a2KDV;
            1# -> GHC.Float.$fNumDouble2
          };
        1# -> GHC.Float.$fNumDouble1
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
fabsDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JKr [Occ=Once!] :: Double) ->
                 case ds_d2JKr of { D# x_a2I4j [Occ=Once] ->
                 GHC.Types.D# (fabsDouble# x_a2I4j)
                 }}]
fabsDouble
  = \ (ds_d2JKr :: Double) ->
      case ds_d2JKr of { D# x_a2I4j ->
      GHC.Types.D# (fabsDouble# x_a2I4j)
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fNumDouble [InlPrag=NOUSERINLINE CONLIKE] :: Num Double
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Double
                     plusDouble
                     minusDouble
                     timesDouble
                     negateDouble
                     fabsDouble
                     GHC.Float.$fNumDouble_$csignum
                     GHC.Float.$fNumDouble_$cfromInteger]
GHC.Float.$fNumDouble
  = GHC.Num.C:Num
      @ Double
      plusDouble
      minusDouble
      timesDouble
      negateDouble
      fabsDouble
      GHC.Float.$fNumDouble_$csignum
      GHC.Float.$fNumDouble_$cfromInteger

-- RHS size: {terms: 26, types: 5, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingDouble_$cacosh :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HZ5 [Occ=Once!] :: Double) ->
                 case x_a2HZ5 of { D# x1_a2I3X ->
                 case /## (-## x1_a2I3X 1.0##) (+## x1_a2I3X 1.0##) of wild1_X1p
                 { __DEFAULT ->
                 case logDouble#
                        (+## x1_a2I3X (*## (+## x1_a2I3X 1.0##) (sqrtDouble# wild1_X1p)))
                 of wild2_X1z
                 { __DEFAULT ->
                 GHC.Types.D# wild2_X1z
                 }
                 }
                 }}]
GHC.Float.$fFloatingDouble_$cacosh
  = \ (x_a2HZ5 :: Double) ->
      case x_a2HZ5 of { D# x1_a2I3X ->
      case /## (-## x1_a2I3X 1.0##) (+## x1_a2I3X 1.0##) of wild1_X1p
      { __DEFAULT ->
      case logDouble#
             (+## x1_a2I3X (*## (+## x1_a2I3X 1.0##) (sqrtDouble# wild1_X1p)))
      of wild2_X1z
      { __DEFAULT ->
      GHC.Types.D# wild2_X1z
      }
      }
      }

-- RHS size: {terms: 17, types: 4, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingDouble_$casinh :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HZ4 [Occ=Once!] :: Double) ->
                 case x_a2HZ4 of { D# x1_a2I3X ->
                 case logDouble#
                        (+## x1_a2I3X (sqrtDouble# (+## 1.0## (*## x1_a2I3X x1_a2I3X))))
                 of wild1_X1z
                 { __DEFAULT ->
                 GHC.Types.D# wild1_X1z
                 }
                 }}]
GHC.Float.$fFloatingDouble_$casinh
  = \ (x_a2HZ4 :: Double) ->
      case x_a2HZ4 of { D# x1_a2I3X ->
      case logDouble#
             (+## x1_a2I3X (sqrtDouble# (+## 1.0## (*## x1_a2I3X x1_a2I3X))))
      of wild1_X1z
      { __DEFAULT ->
      GHC.Types.D# wild1_X1z
      }
      }

-- RHS size: {terms: 11, types: 4, coercions: 0, joins: 0/0}
GHC.Float.$fFractionalDouble_$crecip :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HZd [Occ=Once!] :: Double) ->
                 case x_a2HZd of { D# y_a2I44 [Occ=Once] ->
                 case /## 1.0## y_a2I44 of wild1_X1p { __DEFAULT ->
                 GHC.Types.D# wild1_X1p
                 }
                 }}]
GHC.Float.$fFractionalDouble_$crecip
  = \ (x_a2HZd :: Double) ->
      case x_a2HZd of { D# y_a2I44 ->
      case /## 1.0## y_a2I44 of wild1_X1p { __DEFAULT ->
      GHC.Types.D# wild1_X1p
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.rationalToDouble5 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Float.rationalToDouble5 = 0

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
GHC.Float.rationalToDouble1 :: Double
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 11 20}]
GHC.Float.rationalToDouble1
  = case /## 0.0## 0.0## of v_B2 { __DEFAULT -> GHC.Types.D# v_B2 }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
GHC.Float.rationalToDouble2 :: Double
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 11 20}]
GHC.Float.rationalToDouble2
  = case /## -1.0## 0.0## of v_B2 { __DEFAULT -> GHC.Types.D# v_B2 }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
GHC.Float.rationalToDouble3 :: Double
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 11 20}]
GHC.Float.rationalToDouble3
  = case /## 1.0## 0.0## of v_B2 { __DEFAULT -> GHC.Types.D# v_B2 }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.rationalToDouble4 :: Double
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.rationalToDouble4 = GHC.Types.D# 0.0##

-- RHS size: {terms: 51, types: 17, coercions: 0, joins: 0/0}
$w$j_r2Upx :: Int# -> Integer -> Integer -> Double#
[GblId, Arity=3, Str=<S,U><S,1*U><S,U>, Unf=OtherCon []]
$w$j_r2Upx
  = \ (ww_s2Rux [OS=OneShot] :: Int#)
      (w_s2Rus [OS=OneShot] :: Integer)
      (w1_s2Rut [OS=OneShot] :: Integer) ->
      case eqInteger# w1_s2Rut GHC.Float.rationalToDouble5 of {
        __DEFAULT ->
          case quotRemInteger w_s2Rus w1_s2Rut of
          { (# ipv_i2KJl, ipv1_i2KJm #) ->
          case compareInteger (shiftLInteger ipv1_i2KJm 1#) w1_s2Rut of {
            LT -> encodeDoubleInteger ipv_i2KJl ww_s2Rux;
            EQ ->
              case integerToInt ipv_i2KJl of wild2_i1AOp { __DEFAULT ->
              case andI# wild2_i1AOp 1# of {
                __DEFAULT ->
                  encodeDoubleInteger
                    (plusInteger ipv_i2KJl GHC.Float.$fRealDouble1) ww_s2Rux;
                0# -> encodeDoubleInteger ipv_i2KJl ww_s2Rux
              }
              };
            GT ->
              encodeDoubleInteger
                (plusInteger ipv_i2KJl GHC.Float.$fRealDouble1) ww_s2Rux
          }
          };
        1# -> case divZeroError of wild1_00 { }
      }

-- RHS size: {terms: 415, types: 81, coercions: 0, joins: 6/13}
GHC.Float.$w$sfromRat'' [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> Integer -> Integer -> Double#
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []]
GHC.Float.$w$sfromRat''
  = \ (ww_s2RuV :: Int#)
      (ww1_s2RuZ :: Int#)
      (w_s2RuR :: Integer)
      (w1_s2RuS :: Integer) ->
      join {
        $j1_s2M7o [Dmd=<C(C(S)),1*C1(C1(U))>] :: Int# -> Int# -> Double#
        [LclId[JoinId(2)], Arity=2, Str=<S,U><S,1*U>, Unf=OtherCon []]
        $j1_s2M7o (ipv_s2KQd [OS=OneShot] :: Int#)
                  (ipv1_s2KQe [OS=OneShot] :: Int#)
          = case ipv1_s2KQe of {
              __DEFAULT ->
                join {
                  $j2_s2RG1 [Dmd=<C(S),1*C1(U)>] :: Int# -> Double#
                  [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                  $j2_s2RG1 (ww2_s2Ruk [OS=OneShot] :: Int#)
                    = join {
                        $j3_s2RFW [Dmd=<C(C(S)),1*C1(C1(U))>]
                          :: Integer -> Integer -> Double#
                        [LclId[JoinId(2)], Arity=2, Str=<S,U><S,U>, Unf=OtherCon []]
                        $j3_s2RFW (ww3_s2Ruo [OS=OneShot] :: Integer)
                                  (ww4_s2Rup [OS=OneShot] :: Integer)
                          = case >=# ww1_s2RuZ 0# of {
                              __DEFAULT ->
                                case leInteger#
                                       (shiftRInteger ww4_s2Rup (negateInt# ww1_s2RuZ)) ww3_s2Ruo
                                of {
                                  __DEFAULT ->
                                    $w$j_r2Upx (-# ww2_s2Ruk ww1_s2RuZ) ww3_s2Ruo ww4_s2Rup;
                                  1# ->
                                    $w$j_r2Upx
                                      (+# (-# ww2_s2Ruk ww1_s2RuZ) 1#)
                                      ww3_s2Ruo
                                      (shiftLInteger ww4_s2Rup 1#)
                                };
                              1# ->
                                case leInteger# (shiftLInteger ww4_s2Rup ww1_s2RuZ) ww3_s2Ruo of {
                                  __DEFAULT ->
                                    $w$j_r2Upx (-# ww2_s2Ruk ww1_s2RuZ) ww3_s2Ruo ww4_s2Rup;
                                  1# ->
                                    $w$j_r2Upx
                                      (+# (-# ww2_s2Ruk ww1_s2RuZ) 1#)
                                      ww3_s2Ruo
                                      (shiftLInteger ww4_s2Rup 1#)
                                }
                            } } in
                      case <# ww2_s2Ruk ww1_s2RuZ of {
                        __DEFAULT ->
                          case ==# ww2_s2Ruk ww1_s2RuZ of {
                            __DEFAULT ->
                              jump $j3_s2RFW
                                w_s2RuR
                                (let {
                                   ww3_X1Ce1 [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   ww3_X1Ce1 = -# ww2_s2Ruk ww1_s2RuZ } in
                                 case >=# ww3_X1Ce1 0# of {
                                   __DEFAULT -> shiftRInteger w1_s2RuS (negateInt# ww3_X1Ce1);
                                   1# -> shiftLInteger w1_s2RuS ww3_X1Ce1
                                 });
                            1# -> jump $j3_s2RFW w_s2RuR w1_s2RuS
                          };
                        1# ->
                          jump $j3_s2RFW
                            (let {
                               ww3_X1CdY [Dmd=<S,U>] :: Int#
                               [LclId]
                               ww3_X1CdY = -# ww1_s2RuZ ww2_s2Ruk } in
                             case >=# ww3_X1CdY 0# of {
                               __DEFAULT -> shiftRInteger w_s2RuR (negateInt# ww3_X1CdY);
                               1# -> shiftLInteger w_s2RuR ww3_X1CdY
                             })
                            w1_s2RuS
                      } } in
                case w_s2RuR of {
                  __DEFAULT ->
                    let {
                      y1_at5a [Dmd=<S,U>] :: Int#
                      [LclId]
                      y1_at5a = -# -1# ipv_s2KQd } in
                    case <=# ww_s2RuV y1_at5a of {
                      __DEFAULT -> jump $j2_s2RG1 ww_s2RuV;
                      1# -> jump $j2_s2RG1 y1_at5a
                    };
                  integer-simple-0.1.1.1:GHC.Integer.Type.Positive digits_a2JNS ->
                    case GHC.Integer.Logarithms.Internals.integerLog2#_step
                           0# digits_a2JNS
                    of wild2_X5c
                    { __DEFAULT ->
                    let {
                      y1_at5a [Dmd=<S,U>] :: Int#
                      [LclId]
                      y1_at5a = -# wild2_X5c ipv_s2KQd } in
                    case <=# ww_s2RuV y1_at5a of {
                      __DEFAULT -> jump $j2_s2RG1 ww_s2RuV;
                      1# -> jump $j2_s2RG1 y1_at5a
                    }
                    }
                };
              0# ->
                join {
                  $j2_s2M7i [Dmd=<C(S),1*C1(U)>] :: Int# -> Double#
                  [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                  $j2_s2M7i (ln#_a2I37 [OS=OneShot]
                               :: Int#
                               Unf=OtherCon [])
                    = case >=# ln#_a2I37 (-# (+# ipv_s2KQd ww_s2RuV) 1#) of {
                        __DEFAULT ->
                          let {
                            ld'#_s2LSj [Dmd=<S,U>] :: Int#
                            [LclId]
                            ld'#_s2LSj = +# ipv_s2KQd (-# ww_s2RuV ww1_s2RuZ) } in
                          case <=# ld'#_s2LSj 0# of {
                            __DEFAULT ->
                              case <=# ld'#_s2LSj ln#_a2I37 of {
                                __DEFAULT ->
                                  case ># ld'#_s2LSj (+# ln#_a2I37 1#) of {
                                    __DEFAULT ->
                                      case w_s2RuR of {
                                        __DEFAULT ->
                                          encodeDoubleInteger
                                            GHC.Float.$fRealDouble1 (-# ww_s2RuV ww1_s2RuZ);
                                        integer-simple-0.1.1.1:GHC.Integer.Type.Positive digits_a2JNL ->
                                          case GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe
                                                 0# digits_a2JNL
                                          of
                                          { (# ipv2_s2KQP, ipv3_s2KQQ #) ->
                                          case ipv3_s2KQQ of {
                                            __DEFAULT ->
                                              encodeDoubleInteger
                                                GHC.Float.$fRealDouble1 (-# ww_s2RuV ww1_s2RuZ);
                                            0# -> 0.0##
                                          }
                                          }
                                      };
                                    1# -> 0.0##
                                  };
                                1# ->
                                  let {
                                    i#_s2LSi [Dmd=<S,U>] :: Int#
                                    [LclId]
                                    i#_s2LSi = negateInt# ld'#_s2LSj } in
                                  join {
                                    $j3_s2RGm [Dmd=<C(S),1*C1(U)>] :: Integer -> Double#
                                    [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                                    $j3_s2RGm (n'_s2LSk [OS=OneShot] :: Integer)
                                      = case roundingMode# w_s2RuR (-# ld'#_s2LSj 1#) of {
                                          __DEFAULT ->
                                            encodeDoubleInteger
                                              (plusInteger n'_s2LSk GHC.Float.$fRealDouble1)
                                              (-# ww_s2RuV ww1_s2RuZ);
                                          0# ->
                                            encodeDoubleInteger n'_s2LSk (-# ww_s2RuV ww1_s2RuZ);
                                          1# ->
                                            case integerToInt n'_s2LSk of wild1_i1AOp { __DEFAULT ->
                                            case andI# wild1_i1AOp 1# of {
                                              __DEFAULT ->
                                                encodeDoubleInteger
                                                  (plusInteger n'_s2LSk GHC.Float.$fRealDouble1)
                                                  (-# ww_s2RuV ww1_s2RuZ);
                                              0# ->
                                                encodeDoubleInteger n'_s2LSk (-# ww_s2RuV ww1_s2RuZ)
                                            }
                                            }
                                        } } in
                                  case >=# i#_s2LSi 0# of {
                                    __DEFAULT ->
                                      jump $j3_s2RGm (shiftRInteger w_s2RuR (negateInt# i#_s2LSi));
                                    1# -> jump $j3_s2RGm (shiftLInteger w_s2RuR i#_s2LSi)
                                  }
                              };
                            1# ->
                              encodeDoubleInteger w_s2RuR (-# (-# ww_s2RuV ww1_s2RuZ) ld'#_s2LSj)
                          };
                        1# ->
                          case <# ln#_a2I37 ww1_s2RuZ of {
                            __DEFAULT ->
                              let {
                                i#_s2LSn [Dmd=<S,U>] :: Int#
                                [LclId]
                                i#_s2LSn = negateInt# (-# (+# ln#_a2I37 1#) ww1_s2RuZ) } in
                              join {
                                $j3_s2RGx [Dmd=<C(S),1*C1(U)>] :: Integer -> Double#
                                [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                                $j3_s2RGx (n'_s2LSo [OS=OneShot] :: Integer)
                                  = case roundingMode# w_s2RuR (-# ln#_a2I37 ww1_s2RuZ) of {
                                      __DEFAULT ->
                                        case integerToInt n'_s2LSo of wild1_i1AOp { __DEFAULT ->
                                        case andI# wild1_i1AOp 1# of {
                                          __DEFAULT ->
                                            encodeDoubleInteger
                                              (plusInteger n'_s2LSo GHC.Float.$fRealDouble1)
                                              (-# (+# (-# ln#_a2I37 ipv_s2KQd) 1#) ww1_s2RuZ);
                                          0# ->
                                            encodeDoubleInteger
                                              n'_s2LSo
                                              (-# (+# (-# ln#_a2I37 ipv_s2KQd) 1#) ww1_s2RuZ)
                                        }
                                        };
                                      0# ->
                                        encodeDoubleInteger
                                          n'_s2LSo (-# (+# (-# ln#_a2I37 ipv_s2KQd) 1#) ww1_s2RuZ);
                                      2# ->
                                        encodeDoubleInteger
                                          (plusInteger n'_s2LSo GHC.Float.$fRealDouble1)
                                          (-# (+# (-# ln#_a2I37 ipv_s2KQd) 1#) ww1_s2RuZ)
                                    } } in
                              case >=# i#_s2LSn 0# of {
                                __DEFAULT ->
                                  jump $j3_s2RGx (shiftRInteger w_s2RuR (negateInt# i#_s2LSn));
                                1# -> jump $j3_s2RGx (shiftLInteger w_s2RuR i#_s2LSn)
                              };
                            1# -> encodeDoubleInteger w_s2RuR (negateInt# ipv_s2KQd)
                          }
                      } } in
                case w_s2RuR of {
                  __DEFAULT -> jump $j2_s2M7i -1#;
                  integer-simple-0.1.1.1:GHC.Integer.Type.Positive digits_a2JNS ->
                    case GHC.Integer.Logarithms.Internals.integerLog2#_step
                           0# digits_a2JNS
                    of ln#_a2I37
                    { __DEFAULT ->
                    jump $j2_s2M7i ln#_a2I37
                    }
                }
            } } in
      case w1_s2RuS of {
        __DEFAULT -> jump $j1_s2M7o -1# 1#;
        integer-simple-0.1.1.1:GHC.Integer.Type.Positive digits_a2JNL ->
          case GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe
                 0# digits_a2JNL
          of
          { (# ipv_s2KQd, ipv1_s2KQe #) ->
          jump $j1_s2M7o ipv_s2KQd ipv1_s2KQe
          }
      }

-- RHS size: {terms: 19, types: 9, coercions: 0, joins: 0/0}
GHC.Float.fromRat''_$sfromRat''1 [InlPrag=NOUSERINLINE[0]]
  :: Int -> Int -> Integer -> Integer -> Double
[GblId,
 Arity=4,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2RuP [Occ=Once!] :: Int)
                 (w1_s2RuQ [Occ=Once!] :: Int)
                 (w2_s2RuR [Occ=Once] :: Integer)
                 (w3_s2RuS [Occ=Once] :: Integer) ->
                 case w_s2RuP of { I# ww1_s2RuV [Occ=Once] ->
                 case w1_s2RuQ of { I# ww3_s2RuZ [Occ=Once] ->
                 case GHC.Float.$w$sfromRat'' ww1_s2RuV ww3_s2RuZ w2_s2RuR w3_s2RuS
                 of ww4_s2Rv3
                 { __DEFAULT ->
                 GHC.Types.D# ww4_s2Rv3
                 }
                 }
                 }}]
GHC.Float.fromRat''_$sfromRat''1
  = \ (w_s2RuP :: Int)
      (w1_s2RuQ :: Int)
      (w2_s2RuR :: Integer)
      (w3_s2RuS :: Integer) ->
      case w_s2RuP of { I# ww1_s2RuV ->
      case w1_s2RuQ of { I# ww3_s2RuZ ->
      case GHC.Float.$w$sfromRat'' ww1_s2RuV ww3_s2RuZ w2_s2RuR w3_s2RuS
      of ww4_s2Rv3
      { __DEFAULT ->
      GHC.Types.D# ww4_s2Rv3
      }
      }
      }

-- RHS size: {terms: 56, types: 9, coercions: 0, joins: 0/0}
rationalToDouble [InlPrag=NOINLINE[1]]
  :: Integer -> Integer -> Double
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 411 40}]
rationalToDouble
  = \ (n_a2I11 :: Integer) (ds_d2Kfm :: Integer) ->
      case eqInteger# ds_d2Kfm GHC.Float.rationalToDouble5 of {
        __DEFAULT ->
          case eqInteger# n_a2I11 GHC.Float.rationalToDouble5 of {
            __DEFAULT ->
              case ltInteger# n_a2I11 GHC.Float.rationalToDouble5 of {
                __DEFAULT ->
                  case GHC.Float.$w$sfromRat'' -1021# 53# n_a2I11 ds_d2Kfm
                  of ww_s2Rv3
                  { __DEFAULT ->
                  GHC.Types.D# ww_s2Rv3
                  };
                1# ->
                  case GHC.Float.$w$sfromRat''
                         -1021# 53# (negateInteger n_a2I11) ds_d2Kfm
                  of ww_s2Rv3
                  { __DEFAULT ->
                  GHC.Types.D# (negateDouble# ww_s2Rv3)
                  }
              };
            1# -> GHC.Float.rationalToDouble4
          };
        1# ->
          case eqInteger# n_a2I11 GHC.Float.rationalToDouble5 of {
            __DEFAULT ->
              case ltInteger# n_a2I11 GHC.Float.rationalToDouble5 of {
                __DEFAULT -> GHC.Float.rationalToDouble3;
                1# -> GHC.Float.rationalToDouble2
              };
            1# -> GHC.Float.rationalToDouble1
          }
      }

-- RHS size: {terms: 7, types: 6, coercions: 0, joins: 0/0}
GHC.Float.$fFractionalDouble_$cfromRational [InlPrag=INLINE (sat-args=1)]
  :: Rational -> Double
[GblId,
 Arity=1,
 Str=<S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2Ksr [Occ=Once!] :: Ratio Integer) ->
                 case ds_d2Ksr of { :% n_a2HZb [Occ=Once] d_a2HZc [Occ=Once] ->
                 rationalToDouble n_a2HZb d_a2HZc
                 }}]
GHC.Float.$fFractionalDouble_$cfromRational
  = \ (ds_d2Ksr :: Ratio Integer) ->
      case ds_d2Ksr of { :% n_a2HZb d_a2HZc ->
      rationalToDouble n_a2HZb d_a2HZc
      }

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fFractionalDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Fractional Double
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Fractional TYPE: Double
                             GHC.Float.$fNumDouble
                             divideDouble
                             GHC.Float.$fFractionalDouble_$crecip
                             GHC.Float.$fFractionalDouble_$cfromRational]
GHC.Float.$fFractionalDouble
  = GHC.Real.C:Fractional
      @ Double
      GHC.Float.$fNumDouble
      divideDouble
      GHC.Float.$fFractionalDouble_$crecip
      GHC.Float.$fFractionalDouble_$cfromRational

-- RHS size: {terms: 11, types: 13, coercions: 0, joins: 0/0}
GHC.Float.$fEnumDouble_$snumericEnumFromThen [InlPrag=NOUSERINLINE[0]]
  :: Double -> Double -> [Double]
[GblId,
 Arity=2,
 Str=<S,1*U><S,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w1_i2Krp [Occ=Once] :: Double)
                 (w2_i2Krq [Occ=Once] :: Double) ->
                 case GHC.Real.$wnumericEnumFromThen
                        @ Double GHC.Float.$fFractionalDouble w1_i2Krp w2_i2Krq
                 of
                 { (# ww1_i2Kru [Occ=Once], ww2_i2Krv [Occ=Once] #) ->
                 GHC.Types.: @ Double ww1_i2Kru ww2_i2Krv
                 }}]
GHC.Float.$fEnumDouble_$snumericEnumFromThen
  = \ (w1_i2Krp :: Double) (w2_i2Krq :: Double) ->
      case GHC.Real.$wnumericEnumFromThen
             @ Double GHC.Float.$fFractionalDouble w1_i2Krp w2_i2Krq
      of
      { (# ww1_i2Kru, ww2_i2Krv #) ->
      GHC.Types.: @ Double ww1_i2Kru ww2_i2Krv
      }

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
GHC.Float.$fEnumDouble_$snumericEnumFrom [InlPrag=NOUSERINLINE[0]]
  :: Double -> [Double]
[GblId,
 Arity=1,
 Str=<S,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w1_i2Krf [Occ=Once] :: Double) ->
                 case GHC.Real.$wnumericEnumFrom
                        @ Double GHC.Float.$fFractionalDouble w1_i2Krf
                 of
                 { (# ww1_i2Krj [Occ=Once], ww2_i2Krk [Occ=Once] #) ->
                 GHC.Types.: @ Double ww1_i2Krj ww2_i2Krk
                 }}]
GHC.Float.$fEnumDouble_$snumericEnumFrom
  = \ (w1_i2Krf :: Double) ->
      case GHC.Real.$wnumericEnumFrom
             @ Double GHC.Float.$fFractionalDouble w1_i2Krf
      of
      { (# ww1_i2Krj, ww2_i2Krk #) ->
      GHC.Types.: @ Double ww1_i2Krj ww2_i2Krk
      }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
GHC.Float.rationalToFloat1 :: Float
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 11 20}]
GHC.Float.rationalToFloat1
  = case divideFloat# 0.0# 0.0# of v_B2 { __DEFAULT ->
    GHC.Types.F# v_B2
    }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
GHC.Float.rationalToFloat2 :: Float
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 11 20}]
GHC.Float.rationalToFloat2
  = case divideFloat# -1.0# 0.0# of v_B2 { __DEFAULT ->
    GHC.Types.F# v_B2
    }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
GHC.Float.rationalToFloat3 :: Float
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 11 20}]
GHC.Float.rationalToFloat3
  = case divideFloat# 1.0# 0.0# of v_B2 { __DEFAULT ->
    GHC.Types.F# v_B2
    }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.rationalToFloat4 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.rationalToFloat4 = GHC.Types.F# 0.0#

-- RHS size: {terms: 51, types: 17, coercions: 0, joins: 0/0}
$w$j1_r2Upy :: Int# -> Integer -> Integer -> Float#
[GblId, Arity=3, Str=<S,U><S,1*U><S,U>, Unf=OtherCon []]
$w$j1_r2Upy
  = \ (ww_s2Rvm [OS=OneShot] :: Int#)
      (w_s2Rvh [OS=OneShot] :: Integer)
      (w1_s2Rvi [OS=OneShot] :: Integer) ->
      case eqInteger# w1_s2Rvi GHC.Float.rationalToDouble5 of {
        __DEFAULT ->
          case quotRemInteger w_s2Rvh w1_s2Rvi of
          { (# ipv_i2KJl, ipv1_i2KJm #) ->
          case compareInteger (shiftLInteger ipv1_i2KJm 1#) w1_s2Rvi of {
            LT -> encodeFloatInteger ipv_i2KJl ww_s2Rvm;
            EQ ->
              case integerToInt ipv_i2KJl of wild2_i1AOp { __DEFAULT ->
              case andI# wild2_i1AOp 1# of {
                __DEFAULT ->
                  encodeFloatInteger
                    (plusInteger ipv_i2KJl GHC.Float.$fRealDouble1) ww_s2Rvm;
                0# -> encodeFloatInteger ipv_i2KJl ww_s2Rvm
              }
              };
            GT ->
              encodeFloatInteger
                (plusInteger ipv_i2KJl GHC.Float.$fRealDouble1) ww_s2Rvm
          }
          };
        1# -> case divZeroError of wild1_00 { }
      }

-- RHS size: {terms: 415, types: 81, coercions: 0, joins: 6/13}
GHC.Float.$w$sfromRat''1 [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> Integer -> Integer -> Float#
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []]
GHC.Float.$w$sfromRat''1
  = \ (ww_s2RvK :: Int#)
      (ww1_s2RvO :: Int#)
      (w_s2RvG :: Integer)
      (w1_s2RvH :: Integer) ->
      join {
        $j1_s2M8V [Dmd=<C(C(S)),1*C1(C1(U))>] :: Int# -> Int# -> Float#
        [LclId[JoinId(2)], Arity=2, Str=<S,U><S,1*U>, Unf=OtherCon []]
        $j1_s2M8V (ipv_s2KNV [OS=OneShot] :: Int#)
                  (ipv1_s2KNW [OS=OneShot] :: Int#)
          = case ipv1_s2KNW of {
              __DEFAULT ->
                join {
                  $j2_s2RHn [Dmd=<C(S),1*C1(U)>] :: Int# -> Float#
                  [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                  $j2_s2RHn (ww2_s2Rv9 [OS=OneShot] :: Int#)
                    = join {
                        $j3_s2RHi [Dmd=<C(C(S)),1*C1(C1(U))>]
                          :: Integer -> Integer -> Float#
                        [LclId[JoinId(2)], Arity=2, Str=<S,U><S,U>, Unf=OtherCon []]
                        $j3_s2RHi (ww3_s2Rvd [OS=OneShot] :: Integer)
                                  (ww4_s2Rve [OS=OneShot] :: Integer)
                          = case >=# ww1_s2RvO 0# of {
                              __DEFAULT ->
                                case leInteger#
                                       (shiftRInteger ww4_s2Rve (negateInt# ww1_s2RvO)) ww3_s2Rvd
                                of {
                                  __DEFAULT ->
                                    $w$j1_r2Upy (-# ww2_s2Rv9 ww1_s2RvO) ww3_s2Rvd ww4_s2Rve;
                                  1# ->
                                    $w$j1_r2Upy
                                      (+# (-# ww2_s2Rv9 ww1_s2RvO) 1#)
                                      ww3_s2Rvd
                                      (shiftLInteger ww4_s2Rve 1#)
                                };
                              1# ->
                                case leInteger# (shiftLInteger ww4_s2Rve ww1_s2RvO) ww3_s2Rvd of {
                                  __DEFAULT ->
                                    $w$j1_r2Upy (-# ww2_s2Rv9 ww1_s2RvO) ww3_s2Rvd ww4_s2Rve;
                                  1# ->
                                    $w$j1_r2Upy
                                      (+# (-# ww2_s2Rv9 ww1_s2RvO) 1#)
                                      ww3_s2Rvd
                                      (shiftLInteger ww4_s2Rve 1#)
                                }
                            } } in
                      case <# ww2_s2Rv9 ww1_s2RvO of {
                        __DEFAULT ->
                          case ==# ww2_s2Rv9 ww1_s2RvO of {
                            __DEFAULT ->
                              jump $j3_s2RHi
                                w_s2RvG
                                (let {
                                   ww3_X1Cew [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   ww3_X1Cew = -# ww2_s2Rv9 ww1_s2RvO } in
                                 case >=# ww3_X1Cew 0# of {
                                   __DEFAULT -> shiftRInteger w1_s2RvH (negateInt# ww3_X1Cew);
                                   1# -> shiftLInteger w1_s2RvH ww3_X1Cew
                                 });
                            1# -> jump $j3_s2RHi w_s2RvG w1_s2RvH
                          };
                        1# ->
                          jump $j3_s2RHi
                            (let {
                               ww3_X1Cet [Dmd=<S,U>] :: Int#
                               [LclId]
                               ww3_X1Cet = -# ww1_s2RvO ww2_s2Rv9 } in
                             case >=# ww3_X1Cet 0# of {
                               __DEFAULT -> shiftRInteger w_s2RvG (negateInt# ww3_X1Cet);
                               1# -> shiftLInteger w_s2RvG ww3_X1Cet
                             })
                            w1_s2RvH
                      } } in
                case w_s2RvG of {
                  __DEFAULT ->
                    let {
                      y1_at5a [Dmd=<S,U>] :: Int#
                      [LclId]
                      y1_at5a = -# -1# ipv_s2KNV } in
                    case <=# ww_s2RvK y1_at5a of {
                      __DEFAULT -> jump $j2_s2RHn ww_s2RvK;
                      1# -> jump $j2_s2RHn y1_at5a
                    };
                  integer-simple-0.1.1.1:GHC.Integer.Type.Positive digits_a2JNS ->
                    case GHC.Integer.Logarithms.Internals.integerLog2#_step
                           0# digits_a2JNS
                    of wild2_X5c
                    { __DEFAULT ->
                    let {
                      y1_at5a [Dmd=<S,U>] :: Int#
                      [LclId]
                      y1_at5a = -# wild2_X5c ipv_s2KNV } in
                    case <=# ww_s2RvK y1_at5a of {
                      __DEFAULT -> jump $j2_s2RHn ww_s2RvK;
                      1# -> jump $j2_s2RHn y1_at5a
                    }
                    }
                };
              0# ->
                join {
                  $j2_s2M8P [Dmd=<C(S),1*C1(U)>] :: Int# -> Float#
                  [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                  $j2_s2M8P (ln#_a2I37 [OS=OneShot]
                               :: Int#
                               Unf=OtherCon [])
                    = case >=# ln#_a2I37 (-# (+# ipv_s2KNV ww_s2RvK) 1#) of {
                        __DEFAULT ->
                          let {
                            ld'#_s2LRD [Dmd=<S,U>] :: Int#
                            [LclId]
                            ld'#_s2LRD = +# ipv_s2KNV (-# ww_s2RvK ww1_s2RvO) } in
                          case <=# ld'#_s2LRD 0# of {
                            __DEFAULT ->
                              case <=# ld'#_s2LRD ln#_a2I37 of {
                                __DEFAULT ->
                                  case ># ld'#_s2LRD (+# ln#_a2I37 1#) of {
                                    __DEFAULT ->
                                      case w_s2RvG of {
                                        __DEFAULT ->
                                          encodeFloatInteger
                                            GHC.Float.$fRealDouble1 (-# ww_s2RvK ww1_s2RvO);
                                        integer-simple-0.1.1.1:GHC.Integer.Type.Positive digits_a2JNL ->
                                          case GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe
                                                 0# digits_a2JNL
                                          of
                                          { (# ipv2_s2KOx, ipv3_s2KOy #) ->
                                          case ipv3_s2KOy of {
                                            __DEFAULT ->
                                              encodeFloatInteger
                                                GHC.Float.$fRealDouble1 (-# ww_s2RvK ww1_s2RvO);
                                            0# -> 0.0#
                                          }
                                          }
                                      };
                                    1# -> 0.0#
                                  };
                                1# ->
                                  let {
                                    i#_s2LRC [Dmd=<S,U>] :: Int#
                                    [LclId]
                                    i#_s2LRC = negateInt# ld'#_s2LRD } in
                                  join {
                                    $j3_s2RHI [Dmd=<C(S),1*C1(U)>] :: Integer -> Float#
                                    [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                                    $j3_s2RHI (n'_s2LRE [OS=OneShot] :: Integer)
                                      = case roundingMode# w_s2RvG (-# ld'#_s2LRD 1#) of {
                                          __DEFAULT ->
                                            encodeFloatInteger
                                              (plusInteger n'_s2LRE GHC.Float.$fRealDouble1)
                                              (-# ww_s2RvK ww1_s2RvO);
                                          0# -> encodeFloatInteger n'_s2LRE (-# ww_s2RvK ww1_s2RvO);
                                          1# ->
                                            case integerToInt n'_s2LRE of wild1_i1AOp { __DEFAULT ->
                                            case andI# wild1_i1AOp 1# of {
                                              __DEFAULT ->
                                                encodeFloatInteger
                                                  (plusInteger n'_s2LRE GHC.Float.$fRealDouble1)
                                                  (-# ww_s2RvK ww1_s2RvO);
                                              0# ->
                                                encodeFloatInteger n'_s2LRE (-# ww_s2RvK ww1_s2RvO)
                                            }
                                            }
                                        } } in
                                  case >=# i#_s2LRC 0# of {
                                    __DEFAULT ->
                                      jump $j3_s2RHI (shiftRInteger w_s2RvG (negateInt# i#_s2LRC));
                                    1# -> jump $j3_s2RHI (shiftLInteger w_s2RvG i#_s2LRC)
                                  }
                              };
                            1# ->
                              encodeFloatInteger w_s2RvG (-# (-# ww_s2RvK ww1_s2RvO) ld'#_s2LRD)
                          };
                        1# ->
                          case <# ln#_a2I37 ww1_s2RvO of {
                            __DEFAULT ->
                              let {
                                i#_s2LRH [Dmd=<S,U>] :: Int#
                                [LclId]
                                i#_s2LRH = negateInt# (-# (+# ln#_a2I37 1#) ww1_s2RvO) } in
                              join {
                                $j3_s2RHT [Dmd=<C(S),1*C1(U)>] :: Integer -> Float#
                                [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                                $j3_s2RHT (n'_s2LRI [OS=OneShot] :: Integer)
                                  = case roundingMode# w_s2RvG (-# ln#_a2I37 ww1_s2RvO) of {
                                      __DEFAULT ->
                                        case integerToInt n'_s2LRI of wild1_i1AOp { __DEFAULT ->
                                        case andI# wild1_i1AOp 1# of {
                                          __DEFAULT ->
                                            encodeFloatInteger
                                              (plusInteger n'_s2LRI GHC.Float.$fRealDouble1)
                                              (-# (+# (-# ln#_a2I37 ipv_s2KNV) 1#) ww1_s2RvO);
                                          0# ->
                                            encodeFloatInteger
                                              n'_s2LRI
                                              (-# (+# (-# ln#_a2I37 ipv_s2KNV) 1#) ww1_s2RvO)
                                        }
                                        };
                                      0# ->
                                        encodeFloatInteger
                                          n'_s2LRI (-# (+# (-# ln#_a2I37 ipv_s2KNV) 1#) ww1_s2RvO);
                                      2# ->
                                        encodeFloatInteger
                                          (plusInteger n'_s2LRI GHC.Float.$fRealDouble1)
                                          (-# (+# (-# ln#_a2I37 ipv_s2KNV) 1#) ww1_s2RvO)
                                    } } in
                              case >=# i#_s2LRH 0# of {
                                __DEFAULT ->
                                  jump $j3_s2RHT (shiftRInteger w_s2RvG (negateInt# i#_s2LRH));
                                1# -> jump $j3_s2RHT (shiftLInteger w_s2RvG i#_s2LRH)
                              };
                            1# -> encodeFloatInteger w_s2RvG (negateInt# ipv_s2KNV)
                          }
                      } } in
                case w_s2RvG of {
                  __DEFAULT -> jump $j2_s2M8P -1#;
                  integer-simple-0.1.1.1:GHC.Integer.Type.Positive digits_a2JNS ->
                    case GHC.Integer.Logarithms.Internals.integerLog2#_step
                           0# digits_a2JNS
                    of ln#_a2I37
                    { __DEFAULT ->
                    jump $j2_s2M8P ln#_a2I37
                    }
                }
            } } in
      case w1_s2RvH of {
        __DEFAULT -> jump $j1_s2M8V -1# 1#;
        integer-simple-0.1.1.1:GHC.Integer.Type.Positive digits_a2JNL ->
          case GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe
                 0# digits_a2JNL
          of
          { (# ipv_s2KNV, ipv1_s2KNW #) ->
          jump $j1_s2M8V ipv_s2KNV ipv1_s2KNW
          }
      }

-- RHS size: {terms: 19, types: 9, coercions: 0, joins: 0/0}
GHC.Float.fromRat''_$sfromRat'' [InlPrag=NOUSERINLINE[0]]
  :: Int -> Int -> Integer -> Integer -> Float
[GblId,
 Arity=4,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2RvE [Occ=Once!] :: Int)
                 (w1_s2RvF [Occ=Once!] :: Int)
                 (w2_s2RvG [Occ=Once] :: Integer)
                 (w3_s2RvH [Occ=Once] :: Integer) ->
                 case w_s2RvE of { I# ww1_s2RvK [Occ=Once] ->
                 case w1_s2RvF of { I# ww3_s2RvO [Occ=Once] ->
                 case GHC.Float.$w$sfromRat''1 ww1_s2RvK ww3_s2RvO w2_s2RvG w3_s2RvH
                 of ww4_s2RvS
                 { __DEFAULT ->
                 GHC.Types.F# ww4_s2RvS
                 }
                 }
                 }}]
GHC.Float.fromRat''_$sfromRat''
  = \ (w_s2RvE :: Int)
      (w1_s2RvF :: Int)
      (w2_s2RvG :: Integer)
      (w3_s2RvH :: Integer) ->
      case w_s2RvE of { I# ww1_s2RvK ->
      case w1_s2RvF of { I# ww3_s2RvO ->
      case GHC.Float.$w$sfromRat''1 ww1_s2RvK ww3_s2RvO w2_s2RvG w3_s2RvH
      of ww4_s2RvS
      { __DEFAULT ->
      GHC.Types.F# ww4_s2RvS
      }
      }
      }

-- RHS size: {terms: 56, types: 9, coercions: 0, joins: 0/0}
rationalToFloat [InlPrag=NOINLINE[1]]
  :: Integer -> Integer -> Float
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 411 40}]
rationalToFloat
  = \ (n_a2I0W :: Integer) (ds_d2KfA :: Integer) ->
      case eqInteger# ds_d2KfA GHC.Float.rationalToDouble5 of {
        __DEFAULT ->
          case eqInteger# n_a2I0W GHC.Float.rationalToDouble5 of {
            __DEFAULT ->
              case ltInteger# n_a2I0W GHC.Float.rationalToDouble5 of {
                __DEFAULT ->
                  case GHC.Float.$w$sfromRat''1 -125# 24# n_a2I0W ds_d2KfA
                  of ww_s2RvS
                  { __DEFAULT ->
                  GHC.Types.F# ww_s2RvS
                  };
                1# ->
                  case GHC.Float.$w$sfromRat''1
                         -125# 24# (negateInteger n_a2I0W) ds_d2KfA
                  of ww_s2RvS
                  { __DEFAULT ->
                  GHC.Types.F# (negateFloat# ww_s2RvS)
                  }
              };
            1# -> GHC.Float.rationalToFloat4
          };
        1# ->
          case eqInteger# n_a2I0W GHC.Float.rationalToDouble5 of {
            __DEFAULT ->
              case ltInteger# n_a2I0W GHC.Float.rationalToDouble5 of {
                __DEFAULT -> GHC.Float.rationalToFloat3;
                1# -> GHC.Float.rationalToFloat2
              };
            1# -> GHC.Float.rationalToFloat1
          }
      }

-- RHS size: {terms: 7, types: 6, coercions: 0, joins: 0/0}
GHC.Float.$fFractionalFloat_$cfromRational [InlPrag=INLINE (sat-args=1)]
  :: Rational -> Float
[GblId,
 Arity=1,
 Str=<S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2Kt7 [Occ=Once!] :: Ratio Integer) ->
                 case ds_d2Kt7 of { :% n_a2I0w [Occ=Once] d_a2I0x [Occ=Once] ->
                 rationalToFloat n_a2I0w d_a2I0x
                 }}]
GHC.Float.$fFractionalFloat_$cfromRational
  = \ (ds_d2Kt7 :: Ratio Integer) ->
      case ds_d2Kt7 of { :% n_a2I0w d_a2I0x ->
      rationalToFloat n_a2I0w d_a2I0x
      }

-- RHS size: {terms: 21, types: 5, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingFloat_$catanh :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2I07 [Occ=Once!] :: Float) ->
                 case x_a2I07 of { F# y_a2I3s ->
                 case divideFloat#
                        (plusFloat# 1.0# y_a2I3s) (minusFloat# 1.0# y_a2I3s)
                 of wild1_XH
                 { __DEFAULT ->
                 case logFloat# wild1_XH of wild2_XP { __DEFAULT ->
                 GHC.Types.F# (timesFloat# 0.5# wild2_XP)
                 }
                 }
                 }}]
GHC.Float.$fFloatingFloat_$catanh
  = \ (x_a2I07 :: Float) ->
      case x_a2I07 of { F# y_a2I3s ->
      case divideFloat#
             (plusFloat# 1.0# y_a2I3s) (minusFloat# 1.0# y_a2I3s)
      of wild1_XH
      { __DEFAULT ->
      case logFloat# wild1_XH of wild2_XP { __DEFAULT ->
      GHC.Types.F# (timesFloat# 0.5# wild2_XP)
      }
      }
      }

-- RHS size: {terms: 11, types: 4, coercions: 0, joins: 0/0}
GHC.Float.$fFractionalFloat_$crecip :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2I0y [Occ=Once!] :: Float) ->
                 case x_a2I0y of { F# y_a2I3y [Occ=Once] ->
                 case divideFloat# 1.0# y_a2I3y of wild1_XH { __DEFAULT ->
                 GHC.Types.F# wild1_XH
                 }
                 }}]
GHC.Float.$fFractionalFloat_$crecip
  = \ (x_a2I0y :: Float) ->
      case x_a2I0y of { F# y_a2I3y ->
      case divideFloat# 1.0# y_a2I3y of wild1_XH { __DEFAULT ->
      GHC.Types.F# wild1_XH
      }
      }

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fFractionalFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Fractional Float
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Fractional TYPE: Float
                             GHC.Float.$fNumFloat
                             divideFloat
                             GHC.Float.$fFractionalFloat_$crecip
                             GHC.Float.$fFractionalFloat_$cfromRational]
GHC.Float.$fFractionalFloat
  = GHC.Real.C:Fractional
      @ Float
      GHC.Float.$fNumFloat
      divideFloat
      GHC.Float.$fFractionalFloat_$crecip
      GHC.Float.$fFractionalFloat_$cfromRational

-- RHS size: {terms: 11, types: 13, coercions: 0, joins: 0/0}
GHC.Float.$fEnumFloat_$snumericEnumFromThen [InlPrag=NOUSERINLINE[0]]
  :: Float -> Float -> [Float]
[GblId,
 Arity=2,
 Str=<S,1*U><S,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w1_i2Krp [Occ=Once] :: Float)
                 (w2_i2Krq [Occ=Once] :: Float) ->
                 case GHC.Real.$wnumericEnumFromThen
                        @ Float GHC.Float.$fFractionalFloat w1_i2Krp w2_i2Krq
                 of
                 { (# ww1_i2Kru [Occ=Once], ww2_i2Krv [Occ=Once] #) ->
                 GHC.Types.: @ Float ww1_i2Kru ww2_i2Krv
                 }}]
GHC.Float.$fEnumFloat_$snumericEnumFromThen
  = \ (w1_i2Krp :: Float) (w2_i2Krq :: Float) ->
      case GHC.Real.$wnumericEnumFromThen
             @ Float GHC.Float.$fFractionalFloat w1_i2Krp w2_i2Krq
      of
      { (# ww1_i2Kru, ww2_i2Krv #) ->
      GHC.Types.: @ Float ww1_i2Kru ww2_i2Krv
      }

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
GHC.Float.$fEnumFloat_$snumericEnumFrom [InlPrag=NOUSERINLINE[0]]
  :: Float -> [Float]
[GblId,
 Arity=1,
 Str=<S,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w1_i2Krf [Occ=Once] :: Float) ->
                 case GHC.Real.$wnumericEnumFrom
                        @ Float GHC.Float.$fFractionalFloat w1_i2Krf
                 of
                 { (# ww1_i2Krj [Occ=Once], ww2_i2Krk [Occ=Once] #) ->
                 GHC.Types.: @ Float ww1_i2Krj ww2_i2Krk
                 }}]
GHC.Float.$fEnumFloat_$snumericEnumFrom
  = \ (w1_i2Krf :: Float) ->
      case GHC.Real.$wnumericEnumFrom
             @ Float GHC.Float.$fFractionalFloat w1_i2Krf
      of
      { (# ww1_i2Krj, ww2_i2Krk #) ->
      GHC.Types.: @ Float ww1_i2Krj ww2_i2Krk
      }

-- RHS size: {terms: 26, types: 5, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingFloat_$cacosh :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2I06 [Occ=Once!] :: Float) ->
                 case x_a2I06 of { F# x1_a2I3r ->
                 case divideFloat#
                        (minusFloat# x1_a2I3r 1.0#) (plusFloat# x1_a2I3r 1.0#)
                 of wild1_XH
                 { __DEFAULT ->
                 case logFloat#
                        (plusFloat#
                           x1_a2I3r
                           (timesFloat# (plusFloat# x1_a2I3r 1.0#) (sqrtFloat# wild1_XH)))
                 of wild2_XP
                 { __DEFAULT ->
                 GHC.Types.F# wild2_XP
                 }
                 }
                 }}]
GHC.Float.$fFloatingFloat_$cacosh
  = \ (x_a2I06 :: Float) ->
      case x_a2I06 of { F# x1_a2I3r ->
      case divideFloat#
             (minusFloat# x1_a2I3r 1.0#) (plusFloat# x1_a2I3r 1.0#)
      of wild1_XH
      { __DEFAULT ->
      case logFloat#
             (plusFloat#
                x1_a2I3r
                (timesFloat# (plusFloat# x1_a2I3r 1.0#) (sqrtFloat# wild1_XH)))
      of wild2_XP
      { __DEFAULT ->
      GHC.Types.F# wild2_XP
      }
      }
      }

-- RHS size: {terms: 17, types: 4, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingFloat_$casinh :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2I05 [Occ=Once!] :: Float) ->
                 case x_a2I05 of { F# x1_a2I3r ->
                 case logFloat#
                        (plusFloat#
                           x1_a2I3r
                           (sqrtFloat# (plusFloat# 1.0# (timesFloat# x1_a2I3r x1_a2I3r))))
                 of wild1_XP
                 { __DEFAULT ->
                 GHC.Types.F# wild1_XP
                 }
                 }}]
GHC.Float.$fFloatingFloat_$casinh
  = \ (x_a2I05 :: Float) ->
      case x_a2I05 of { F# x1_a2I3r ->
      case logFloat#
             (plusFloat#
                x1_a2I3r
                (sqrtFloat# (plusFloat# 1.0# (timesFloat# x1_a2I3r x1_a2I3r))))
      of wild1_XP
      { __DEFAULT ->
      GHC.Types.F# wild1_XP
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble5 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Float.$fRealFloatDouble5 = 2

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
minExpt :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
minExpt = GHC.Types.I# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fRealFracFloat2 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fRealFracFloat2 = GHC.Types.I# 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fRealFracFloat1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fRealFracFloat1 = GHC.Types.I# -1#

-- RHS size: {terms: 127, types: 49, coercions: 0, joins: 0/6}
GHC.Float.$w$cproperFraction1 [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Float# -> (# b, Float #)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 649 60}]
GHC.Float.$w$cproperFraction1
  = \ (@ b_s2RvW)
      (w_s2RvX :: Integral b_s2RvW)
      (ww_s2Rw1 :: Float#) ->
      case decodeFloat_Int# ww_s2Rw1 of { (# ipv_s2KM0, ipv1_s2KM1 #) ->
      let {
        $dReal_s2LRm [Dmd=<L,1*U(1*U(A,A,C(C1(U)),A,A,A,C(U)),A,A)>]
          :: Real b_s2RvW
        [LclId]
        $dReal_s2LRm = GHC.Real.$p1Integral @ b_s2RvW w_s2RvX } in
      let {
        $dNum_s2LRl [Dmd=<L,U(A,A,C(C1(U)),A,A,A,C(U))>] :: Num b_s2RvW
        [LclId]
        $dNum_s2LRl = GHC.Real.$p1Real @ b_s2RvW $dReal_s2LRm } in
      case >=# ipv1_s2KM1 0# of {
        __DEFAULT ->
          let {
            i_s2LRi [Dmd=<L,U(U)>] :: Int
            [LclId]
            i_s2LRi
              = case >=# ipv_s2KM0 0# of {
                  __DEFAULT ->
                    let {
                      ww3_s1C1u [Dmd=<S,U>] :: Int#
                      [LclId]
                      ww3_s1C1u = negateInt# ipv1_s2KM1 } in
                    case >=# ww3_s1C1u 64# of {
                      __DEFAULT ->
                        GHC.Types.I#
                          (negateInt# (uncheckedIShiftRA# (negateInt# ipv_s2KM0) ww3_s1C1u));
                      1# ->
                        case <# (negateInt# ipv_s2KM0) 0# of {
                          __DEFAULT -> minExpt;
                          1# -> GHC.Float.$fRealFracFloat2
                        }
                    };
                  1# ->
                    let {
                      ww3_s1C1u [Dmd=<S,U>] :: Int#
                      [LclId]
                      ww3_s1C1u = negateInt# ipv1_s2KM1 } in
                    case >=# ww3_s1C1u 64# of {
                      __DEFAULT -> GHC.Types.I# (uncheckedIShiftRA# ipv_s2KM0 ww3_s1C1u);
                      1# ->
                        case <# ipv_s2KM0 0# of {
                          __DEFAULT -> minExpt;
                          1# -> GHC.Float.$fRealFracFloat1
                        }
                    }
                } } in
          (# fromInteger
               @ b_s2RvW
               $dNum_s2LRl
               (case i_s2LRi of { I# i1_i2KYH -> smallInteger i1_i2KYH }),
             case i_s2LRi of { I# x#_a1A5P ->
             let {
               i#_s2LRh [Dmd=<S,U>] :: Int#
               [LclId]
               i#_s2LRh = negateInt# ipv1_s2KM1 } in
             case >=# i#_s2LRh 64# of {
               __DEFAULT ->
                 case encodeFloatInteger
                        (smallInteger (-# ipv_s2KM0 (uncheckedIShiftL# x#_a1A5P i#_s2LRh)))
                        ipv1_s2KM1
                 of wild1_Xc
                 { __DEFAULT ->
                 GHC.Types.F# wild1_Xc
                 };
               1# ->
                 case encodeFloatInteger (smallInteger ipv_s2KM0) ipv1_s2KM1
                 of wild1_Xc
                 { __DEFAULT ->
                 GHC.Types.F# wild1_Xc
                 }
             }
             } #);
        1# ->
          (# * @ b_s2RvW
               $dNum_s2LRl
               (fromInteger @ b_s2RvW $dNum_s2LRl (smallInteger ipv_s2KM0))
               (^ @ b_s2RvW
                  @ Int
                  $dNum_s2LRl
                  GHC.Real.$fIntegralInt
                  (fromInteger @ b_s2RvW $dNum_s2LRl GHC.Float.$fRealFloatDouble5)
                  (GHC.Types.I# ipv1_s2KM1)),
             GHC.Float.rationalToFloat4 #)
      }
      }

-- RHS size: {terms: 14, types: 17, coercions: 0, joins: 0/0}
GHC.Float.$fRealFracFloat_$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Float -> (b, Float)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_s2RvW)
                 (w_s2RvX [Occ=Once] :: Integral b_s2RvW)
                 (w1_s2RvY [Occ=Once!] :: Float) ->
                 case w1_s2RvY of { F# ww1_s2Rw1 [Occ=Once] ->
                 case GHC.Float.$w$cproperFraction1 @ b_s2RvW w_s2RvX ww1_s2Rw1 of
                 { (# ww3_s2RDO [Occ=Once], ww4_s2RDP [Occ=Once] #) ->
                 (ww3_s2RDO, ww4_s2RDP)
                 }
                 }}]
GHC.Float.$fRealFracFloat_$cproperFraction
  = \ (@ b_s2RvW)
      (w_s2RvX :: Integral b_s2RvW)
      (w1_s2RvY :: Float) ->
      case w1_s2RvY of { F# ww1_s2Rw1 ->
      case GHC.Float.$w$cproperFraction1 @ b_s2RvW w_s2RvX ww1_s2Rw1 of
      { (# ww3_s2RDO, ww4_s2RDP #) ->
      (ww3_s2RDO, ww4_s2RDP)
      }
      }

-- RHS size: {terms: 12, types: 15, coercions: 0, joins: 0/0}
GHC.Float.$fRealFracFloat_$ctruncate [InlPrag=INLINE[1] (sat-args=1)]
  :: forall b. Integral b => Float -> b
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ b_a2Jc7)
                 ($dIntegral_a2Jc9 [Occ=Once] :: Integral b_a2Jc7)
                 (x_a2I0h [Occ=Once] :: Float) ->
                 case GHC.Float.$fRealFracFloat_$cproperFraction
                        @ b_a2Jc7 $dIntegral_a2Jc9 x_a2I0h
                 of
                 { (n_a2I0i [Occ=Once], _ [Occ=Dead]) ->
                 n_a2I0i
                 }}]
GHC.Float.$fRealFracFloat_$ctruncate
  = \ (@ b_a2Jc7)
      ($dIntegral_a2Jc9 :: Integral b_a2Jc7)
      (x_a2I0h :: Float) ->
      case x_a2I0h of { F# ww1_s2Rw1 ->
      case GHC.Float.$w$cproperFraction1
             @ b_a2Jc7 $dIntegral_a2Jc9 ww1_s2Rw1
      of
      { (# ww3_s2RDO, ww4_s2RDP #) ->
      ww3_s2RDO
      }
      }

-- RHS size: {terms: 33, types: 26, coercions: 0, joins: 0/2}
GHC.Float.$fRealFracFloat_$cceiling [InlPrag=INLINE[1] (sat-args=1)]
  :: forall b. Integral b => Float -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(1*C1(C1(U)),A,C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ b_a2Jde) ($dIntegral_a2Jdg :: Integral b_a2Jde) ->
                 let {
                   $dReal_a2JyH [Occ=OnceL] :: Real b_a2Jde
                   [LclId]
                   $dReal_a2JyH = GHC.Real.$p1Integral @ b_a2Jde $dIntegral_a2Jdg } in
                 let {
                   $dNum_a2JyJ :: Num b_a2Jde
                   [LclId]
                   $dNum_a2JyJ = GHC.Real.$p1Real @ b_a2Jde $dReal_a2JyH } in
                 \ (x_a2I0o [Occ=Once] :: Float) ->
                   case GHC.Float.$fRealFracFloat_$cproperFraction
                          @ b_a2Jde $dIntegral_a2Jdg x_a2I0o
                   of
                   { (n_a2I0p [Occ=Once*], r_a2I0q [Occ=Once!]) ->
                   case r_a2I0q of { F# x1_a2KCS [Occ=Once] ->
                   case gtFloat# x1_a2KCS 0.0# of {
                     __DEFAULT -> n_a2I0p;
                     1# ->
                       + @ b_a2Jde
                         $dNum_a2JyJ
                         n_a2I0p
                         (fromInteger @ b_a2Jde $dNum_a2JyJ 1)
                   }
                   }
                   }}]
GHC.Float.$fRealFracFloat_$cceiling
  = \ (@ b_a2Jde)
      ($dIntegral_a2Jdg :: Integral b_a2Jde)
      (eta_B1 :: Float) ->
      case eta_B1 of { F# ww1_s2Rw1 ->
      case GHC.Float.$w$cproperFraction1
             @ b_a2Jde $dIntegral_a2Jdg ww1_s2Rw1
      of
      { (# ww3_s2RDO, ww4_s2RDP #) ->
      case ww4_s2RDP of { F# x_a2KCS ->
      case gtFloat# x_a2KCS 0.0# of {
        __DEFAULT -> ww3_s2RDO;
        1# ->
          let {
            $dReal_s2LR0 [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
              :: Real b_a2Jde
            [LclId]
            $dReal_s2LR0 = GHC.Real.$p1Integral @ b_a2Jde $dIntegral_a2Jdg } in
          let {
            $dNum_s2LQZ [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
              :: Num b_a2Jde
            [LclId]
            $dNum_s2LQZ = GHC.Real.$p1Real @ b_a2Jde $dReal_s2LR0 } in
          + @ b_a2Jde
            $dNum_s2LQZ
            ww3_s2RDO
            (fromInteger @ b_a2Jde $dNum_s2LQZ GHC.Float.$fRealDouble1)
      }
      }
      }
      }

-- RHS size: {terms: 33, types: 26, coercions: 0, joins: 0/2}
GHC.Float.$fRealFracFloat_$cfloor [InlPrag=INLINE[1] (sat-args=1)]
  :: forall b. Integral b => Float -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,1*C1(C1(U)),C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ b_a2Jdz) ($dIntegral_a2JdB :: Integral b_a2Jdz) ->
                 let {
                   $dReal_a2JyM [Occ=OnceL] :: Real b_a2Jdz
                   [LclId]
                   $dReal_a2JyM = GHC.Real.$p1Integral @ b_a2Jdz $dIntegral_a2JdB } in
                 let {
                   $dNum_a2JyO :: Num b_a2Jdz
                   [LclId]
                   $dNum_a2JyO = GHC.Real.$p1Real @ b_a2Jdz $dReal_a2JyM } in
                 \ (x_a2I0r [Occ=Once] :: Float) ->
                   case GHC.Float.$fRealFracFloat_$cproperFraction
                          @ b_a2Jdz $dIntegral_a2JdB x_a2I0r
                   of
                   { (n_a2I0s [Occ=Once*], r_a2I0t [Occ=Once!]) ->
                   case r_a2I0t of { F# x1_a2KD4 [Occ=Once] ->
                   case ltFloat# x1_a2KD4 0.0# of {
                     __DEFAULT -> n_a2I0s;
                     1# ->
                       - @ b_a2Jdz
                         $dNum_a2JyO
                         n_a2I0s
                         (fromInteger @ b_a2Jdz $dNum_a2JyO 1)
                   }
                   }
                   }}]
GHC.Float.$fRealFracFloat_$cfloor
  = \ (@ b_a2Jdz)
      ($dIntegral_a2JdB :: Integral b_a2Jdz)
      (eta_B1 :: Float) ->
      case eta_B1 of { F# ww1_s2Rw1 ->
      case GHC.Float.$w$cproperFraction1
             @ b_a2Jdz $dIntegral_a2JdB ww1_s2Rw1
      of
      { (# ww3_s2RDO, ww4_s2RDP #) ->
      case ww4_s2RDP of { F# x_a2KD4 ->
      case ltFloat# x_a2KD4 0.0# of {
        __DEFAULT -> ww3_s2RDO;
        1# ->
          let {
            $dReal_s2LR4 [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
              :: Real b_a2Jdz
            [LclId]
            $dReal_s2LR4 = GHC.Real.$p1Integral @ b_a2Jdz $dIntegral_a2JdB } in
          let {
            $dNum_s2LR3 [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
              :: Num b_a2Jdz
            [LclId]
            $dNum_s2LR3 = GHC.Real.$p1Real @ b_a2Jdz $dReal_s2LR4 } in
          - @ b_a2Jdz
            $dNum_s2LR3
            ww3_s2RDO
            (fromInteger @ b_a2Jdz $dNum_s2LR3 GHC.Float.$fRealDouble1)
      }
      }
      }
      }

-- RHS size: {terms: 63, types: 32, coercions: 0, joins: 1/4}
GHC.Float.$w$cround1 [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Float# -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 369 0}]
GHC.Float.$w$cround1
  = \ (@ b_s2Rw7)
      (w_s2Rw8 :: Integral b_s2Rw7)
      (ww_s2Rwc :: Float#) ->
      case GHC.Float.$w$cproperFraction1 @ b_s2Rw7 w_s2Rw8 ww_s2Rwc of
      { (# ww2_s2RDO, ww3_s2RDP #) ->
      case ww3_s2RDP of { F# x_a2I3L ->
      let {
        x1_a2KMh [Dmd=<S,U>] :: Float#
        [LclId]
        x1_a2KMh = minusFloat# (fabsFloat# x_a2I3L) 0.5# } in
      case ltFloat# x1_a2KMh 0.0# of {
        __DEFAULT ->
          join {
            m_s2LRa [Dmd=<L,1*U>] :: b_s2Rw7
            [LclId[JoinId(0)]]
            m_s2LRa
              = let {
                  $dReal_s2LR8 [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                    :: Real b_s2Rw7
                  [LclId]
                  $dReal_s2LR8 = GHC.Real.$p1Integral @ b_s2Rw7 w_s2Rw8 } in
                let {
                  $dNum_s2LR7 [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                    :: Num b_s2Rw7
                  [LclId]
                  $dNum_s2LR7 = GHC.Real.$p1Real @ b_s2Rw7 $dReal_s2LR8 } in
                case ltFloat# x_a2I3L 0.0# of {
                  __DEFAULT ->
                    + @ b_s2Rw7
                      $dNum_s2LR7
                      ww2_s2RDO
                      (fromInteger @ b_s2Rw7 $dNum_s2LR7 GHC.Float.$fRealDouble1);
                  1# ->
                    - @ b_s2Rw7
                      $dNum_s2LR7
                      ww2_s2RDO
                      (fromInteger @ b_s2Rw7 $dNum_s2LR7 GHC.Float.$fRealDouble1)
                } } in
          case eqFloat# x1_a2KMh 0.0# of {
            __DEFAULT -> jump m_s2LRa;
            1# ->
              case even @ b_s2Rw7 w_s2Rw8 ww2_s2RDO of {
                False -> jump m_s2LRa;
                True -> ww2_s2RDO
              }
          };
        1# -> ww2_s2RDO
      }
      }
      }

-- RHS size: {terms: 9, types: 8, coercions: 0, joins: 0/0}
GHC.Float.$fRealFracFloat_$cround [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Float -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_s2Rw7)
                 (w_s2Rw8 [Occ=Once] :: Integral b_s2Rw7)
                 (w1_s2Rw9 [Occ=Once!] :: Float) ->
                 case w1_s2Rw9 of { F# ww1_s2Rwc [Occ=Once] ->
                 GHC.Float.$w$cround1 @ b_s2Rw7 w_s2Rw8 ww1_s2Rwc
                 }}]
GHC.Float.$fRealFracFloat_$cround
  = \ (@ b_s2Rw7)
      (w_s2Rw8 :: Integral b_s2Rw7)
      (w1_s2Rw9 :: Float) ->
      case w1_s2Rw9 of { F# ww1_s2Rwc ->
      GHC.Float.$w$cround1 @ b_s2Rw7 w_s2Rw8 ww1_s2Rwc
      }

-- RHS size: {terms: 21, types: 5, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingDouble_$catanh :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HZ6 [Occ=Once!] :: Double) ->
                 case x_a2HZ6 of { D# y_a2I3Y ->
                 case /## (+## 1.0## y_a2I3Y) (-## 1.0## y_a2I3Y) of wild1_X1p
                 { __DEFAULT ->
                 case logDouble# wild1_X1p of wild2_X1z { __DEFAULT ->
                 GHC.Types.D# (*## 0.5## wild2_X1z)
                 }
                 }
                 }}]
GHC.Float.$fFloatingDouble_$catanh
  = \ (x_a2HZ6 :: Double) ->
      case x_a2HZ6 of { D# y_a2I3Y ->
      case /## (+## 1.0## y_a2I3Y) (-## 1.0## y_a2I3Y) of wild1_X1p
      { __DEFAULT ->
      case logDouble# wild1_X1p of wild2_X1z { __DEFAULT ->
      GHC.Types.D# (*## 0.5## wild2_X1z)
      }
      }
      }

-- RHS size: {terms: 57, types: 34, coercions: 0, joins: 0/0}
GHC.Float.$w$ctoRational1 [InlPrag=NOUSERINLINE[0]]
  :: Float# -> (# Integer, Integer #)
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 276 90}]
GHC.Float.$w$ctoRational1
  = \ (ww_s2Rwi :: Float#) ->
      case decodeFloat_Int# ww_s2Rwi of { (# ipv_s2KAi, ipv1_s2KAj #) ->
      case >=# ipv1_s2KAj 0# of {
        __DEFAULT ->
          case and# (int2Word# ipv_s2KAi) 1## of {
            __DEFAULT ->
              case smallInteger ipv_s2KAi of dt_X2pmK { __DEFAULT ->
              case shiftLInteger GHC.Float.$fRealDouble1 (negateInt# ipv1_s2KAj)
              of dt1_X2pmM
              { __DEFAULT ->
              (# dt_X2pmK, dt1_X2pmM #)
              }
              };
            0## ->
              case elimZerosInt# ipv_s2KAi (negateInt# ipv1_s2KAj) of
              { (# ipv2_s2KAp, ipv3_s2KAq #) ->
              case ipv2_s2KAp of dt_X2pmK { __DEFAULT ->
              case shiftLInteger GHC.Float.$fRealDouble1 ipv3_s2KAq of dt1_X2pmM
              { __DEFAULT ->
              (# dt_X2pmK, dt1_X2pmM #)
              }
              }
              }
          };
        1# ->
          case shiftLInteger (smallInteger ipv_s2KAi) ipv1_s2KAj of dt_X2pmK
          { __DEFAULT ->
          (# dt_X2pmK, GHC.Float.$fRealDouble1 #)
          }
      }
      }

-- RHS size: {terms: 11, types: 11, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloat_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: Float -> Rational
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2Rwf [Occ=Once!] :: Float) ->
                 case w_s2Rwf of { F# ww1_s2Rwi [Occ=Once] ->
                 case GHC.Float.$w$ctoRational1 ww1_s2Rwi of
                 { (# ww3_s2RDR [Occ=Once], ww4_s2RDS [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww3_s2RDR ww4_s2RDS
                 }
                 }}]
GHC.Float.$fRealFloat_$ctoRational
  = \ (w_s2Rwf :: Float) ->
      case w_s2Rwf of { F# ww1_s2Rwi ->
      case GHC.Float.$w$ctoRational1 ww1_s2Rwi of
      { (# ww3_s2RDR, ww4_s2RDS #) ->
      GHC.Real.:% @ Integer ww3_s2RDR ww4_s2RDS
      }
      }

-- RHS size: {terms: 62, types: 36, coercions: 0, joins: 0/0}
GHC.Float.$w$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: Double# -> (# Integer, Integer #)
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 314 90}]
GHC.Float.$w$ctoRational
  = \ (ww_s2Rwr :: Double#) ->
      case decodeDoubleInteger ww_s2Rwr of
      { (# ipv_s2KAy, ipv1_s2KAz #) ->
      case >=# ipv1_s2KAz 0# of {
        __DEFAULT ->
          case integerToWord ipv_s2KAy of wild_Xc { __DEFAULT ->
          case and# wild_Xc 1## of {
            __DEFAULT ->
              case ipv_s2KAy of dt_X2pmK { __DEFAULT ->
              case shiftLInteger GHC.Float.$fRealDouble1 (negateInt# ipv1_s2KAz)
              of dt1_X2pmM
              { __DEFAULT ->
              (# dt_X2pmK, dt1_X2pmM #)
              }
              };
            0## ->
              case integerToInt ipv_s2KAy of wild2_i2KsB { __DEFAULT ->
              case elimZerosInt# wild2_i2KsB (negateInt# ipv1_s2KAz) of
              { (# ipv2_s2KAI, ipv3_s2KAJ #) ->
              case ipv2_s2KAI of dt_X2pmK { __DEFAULT ->
              case shiftLInteger GHC.Float.$fRealDouble1 ipv3_s2KAJ of dt1_X2pmM
              { __DEFAULT ->
              (# dt_X2pmK, dt1_X2pmM #)
              }
              }
              }
              }
          }
          };
        1# ->
          case shiftLInteger ipv_s2KAy ipv1_s2KAz of dt_X2pmK { __DEFAULT ->
          (# dt_X2pmK, GHC.Float.$fRealDouble1 #)
          }
      }
      }

-- RHS size: {terms: 11, types: 11, coercions: 0, joins: 0/0}
GHC.Float.$fRealDouble_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: Double -> Rational
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2Rwo [Occ=Once!] :: Double) ->
                 case w_s2Rwo of { D# ww1_s2Rwr [Occ=Once] ->
                 case GHC.Float.$w$ctoRational ww1_s2Rwr of
                 { (# ww3_s2RDU [Occ=Once], ww4_s2RDV [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww3_s2RDU ww4_s2RDV
                 }
                 }}]
GHC.Float.$fRealDouble_$ctoRational
  = \ (w_s2Rwo :: Double) ->
      case w_s2Rwo of { D# ww1_s2Rwr ->
      case GHC.Float.$w$ctoRational ww1_s2Rwr of
      { (# ww3_s2RDU, ww4_s2RDV #) ->
      GHC.Real.:% @ Integer ww3_s2RDU ww4_s2RDV
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingFloat_$cpi :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fFloatingFloat_$cpi = GHC.Types.F# 3.1415927#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingDouble_$cpi :: Double
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fFloatingDouble_$cpi = GHC.Types.D# 3.141592653589793##

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$cisIEEE :: Float -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.True}]
GHC.Float.$fRealFloatFloat_$cisIEEE
  = \ _ [Occ=Dead] -> GHC.Types.True

-- RHS size: {terms: 12, types: 5, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$cencodeFloat :: Integer -> Int -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_a2HZx [Occ=Once] :: Integer)
                 (ds_d2Knl [Occ=Once!] :: Int) ->
                 case ds_d2Knl of { I# e_a2HZy [Occ=Once] ->
                 case encodeFloatInteger i_a2HZx e_a2HZy of wild1_Xc { __DEFAULT ->
                 GHC.Types.F# wild1_Xc
                 }
                 }}]
GHC.Float.$fRealFloatFloat_$cencodeFloat
  = \ (i_a2HZx :: Integer) (ds_d2Knl :: Int) ->
      case ds_d2Knl of { I# e_a2HZy ->
      case encodeFloatInteger i_a2HZx e_a2HZy of wild1_Xc { __DEFAULT ->
      GHC.Types.F# wild1_Xc
      }
      }

-- RHS size: {terms: 13, types: 12, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$cdecodeFloat :: Float -> (Integer, Int)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2Knc [Occ=Once!] :: Float) ->
                 case ds_d2Knc of { F# f#_a2HZu [Occ=Once] ->
                 case decodeFloat_Int# f#_a2HZu of
                 { (# ipv_s2KAQ [Occ=Once], ipv1_s2KAR [Occ=Once] #) ->
                 (smallInteger ipv_s2KAQ, GHC.Types.I# ipv1_s2KAR)
                 }
                 }}]
GHC.Float.$fRealFloatFloat_$cdecodeFloat
  = \ (ds_d2Knc :: Float) ->
      case ds_d2Knc of { F# f#_a2HZu ->
      case decodeFloat_Int# f#_a2HZu of { (# ipv_s2KAQ, ipv1_s2KAR #) ->
      (smallInteger ipv_s2KAQ, GHC.Types.I# ipv1_s2KAR)
      }
      }

-- RHS size: {terms: 16, types: 9, coercions: 0, joins: 0/0}
GHC.Float.$w$cexponent1 [InlPrag=NOUSERINLINE[0]] :: Float# -> Int#
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 83 0}]
GHC.Float.$w$cexponent1
  = \ (ww_s2RwA :: Float#) ->
      case decodeFloat_Int# ww_s2RwA of { (# ipv_s2KAQ, ipv1_s2KAR #) ->
      case eqInteger#
             (smallInteger ipv_s2KAQ) GHC.Float.rationalToDouble5
      of {
        __DEFAULT -> +# ipv1_s2KAR 24#;
        1# -> 0#
      }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$cexponent [InlPrag=NOUSERINLINE[0]]
  :: Float -> Int
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2Rwx [Occ=Once!] :: Float) ->
                 case w_s2Rwx of { F# ww1_s2RwA [Occ=Once] ->
                 case GHC.Float.$w$cexponent1 ww1_s2RwA of ww2_s2RwE { __DEFAULT ->
                 GHC.Types.I# ww2_s2RwE
                 }
                 }}]
GHC.Float.$fRealFloatFloat_$cexponent
  = \ (w_s2Rwx :: Float) ->
      case w_s2Rwx of { F# ww1_s2RwA ->
      case GHC.Float.$w$cexponent1 ww1_s2RwA of ww2_s2RwE { __DEFAULT ->
      GHC.Types.I# ww2_s2RwE
      }
      }

-- RHS size: {terms: 16, types: 11, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$csignificand [InlPrag=NOUSERINLINE[0]]
  :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2RwG [Occ=Once!] :: Float) ->
                 case w_s2RwG of { F# ww1_s2RwJ [Occ=Once] ->
                 case decodeFloat_Int# ww1_s2RwJ of
                 { (# ipv_s2KAQ [Occ=Once], _ [Occ=Dead] #) ->
                 case encodeFloatInteger (smallInteger ipv_s2KAQ) -24# of ww2_s2RwN
                 { __DEFAULT ->
                 GHC.Types.F# ww2_s2RwN
                 }
                 }
                 }}]
GHC.Float.$fRealFloatFloat_$csignificand
  = \ (w_s2RwG :: Float) ->
      case w_s2RwG of { F# ww1_s2RwJ ->
      case decodeFloat_Int# ww1_s2RwJ of { (# ipv_s2KAQ, ipv1_s2KAR #) ->
      case encodeFloatInteger (smallInteger ipv_s2KAQ) -24# of ww2_s2RwN
      { __DEFAULT ->
      GHC.Types.F# ww2_s2RwN
      }
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat4 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fRealFloatFloat4 = GHC.Types.I# 24#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$cfloatDigits :: Float -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Float.$fRealFloatFloat4}]
GHC.Float.$fRealFloatFloat_$cfloatDigits
  = \ _ [Occ=Dead] -> GHC.Float.$fRealFloatFloat4

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$cfloatRadix :: Float -> Integer
[GblId,
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Float.$fRealFloatDouble5}]
GHC.Float.$fRealFloatFloat_$cfloatRadix
  = \ _ [Occ=Dead] -> GHC.Float.$fRealFloatDouble5

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$cisIEEE :: Double -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.True}]
GHC.Float.$fRealFloatDouble_$cisIEEE
  = \ _ [Occ=Dead] -> GHC.Types.True

-- RHS size: {terms: 12, types: 5, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$cencodeFloat
  :: Integer -> Int -> Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_a2HYe [Occ=Once] :: Integer)
                 (ds_d2Kkv [Occ=Once!] :: Int) ->
                 case ds_d2Kkv of { I# j_a2HYf [Occ=Once] ->
                 case encodeDoubleInteger i_a2HYe j_a2HYf of wild1_Xh { __DEFAULT ->
                 GHC.Types.D# wild1_Xh
                 }
                 }}]
GHC.Float.$fRealFloatDouble_$cencodeFloat
  = \ (i_a2HYe :: Integer) (ds_d2Kkv :: Int) ->
      case ds_d2Kkv of { I# j_a2HYf ->
      case encodeDoubleInteger i_a2HYe j_a2HYf of wild1_Xh { __DEFAULT ->
      GHC.Types.D# wild1_Xh
      }
      }

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$cdecodeFloat
  :: Double -> (Integer, Int)
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2Kkm [Occ=Once!] :: Double) ->
                 case ds_d2Kkm of { D# x#_a2HYb [Occ=Once] ->
                 case decodeDoubleInteger x#_a2HYb of
                 { (# ipv_s2KAX [Occ=Once], ipv1_s2KAY [Occ=Once] #) ->
                 (ipv_s2KAX, GHC.Types.I# ipv1_s2KAY)
                 }
                 }}]
GHC.Float.$fRealFloatDouble_$cdecodeFloat
  = \ (ds_d2Kkm :: Double) ->
      case ds_d2Kkm of { D# x#_a2HYb ->
      case decodeDoubleInteger x#_a2HYb of
      { (# ipv_s2KAX, ipv1_s2KAY #) ->
      (ipv_s2KAX, GHC.Types.I# ipv1_s2KAY)
      }
      }

-- RHS size: {terms: 81, types: 56, coercions: 0, joins: 1/4}
GHC.Float.$w$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Double# -> (# b, Double #)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 521 30}]
GHC.Float.$w$cproperFraction
  = \ (@ b_s2RwP)
      (w_s2RwQ :: Integral b_s2RwP)
      (ww_s2RwU :: Double#) ->
      case decodeDoubleInteger ww_s2RwU of
      { (# ipv_s2KAX, ipv1_s2KAY #) ->
      let {
        $dReal_s2LS0 [Dmd=<L,1*U(1*U(A,A,C(C1(U)),A,A,A,C(U)),A,A)>]
          :: Real b_s2RwP
        [LclId]
        $dReal_s2LS0 = GHC.Real.$p1Integral @ b_s2RwP w_s2RwQ } in
      let {
        $dNum_s2LRZ [Dmd=<L,U(A,A,C(C1(U)),A,A,A,C(U))>] :: Num b_s2RwP
        [LclId]
        $dNum_s2LRZ = GHC.Real.$p1Real @ b_s2RwP $dReal_s2LS0 } in
      case >=# ipv1_s2KAY 0# of {
        __DEFAULT ->
          let {
            y0_s2Nx9 [Dmd=<S,U>] :: Int#
            [LclId]
            y0_s2Nx9 = negateInt# ipv1_s2KAY } in
          case <# y0_s2Nx9 0# of {
            __DEFAULT ->
              join {
                $j1_s2RKq [Dmd=<C(S),1*C1(U(U,U))>]
                  :: Integer -> (# b_s2RwP, Double #)
                [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                $j1_s2RKq (ds1_s2LS2 [OS=OneShot] :: Integer)
                  = case eqInteger# ds1_s2LS2 GHC.Float.rationalToDouble5 of {
                      __DEFAULT ->
                        case quotRemInteger ipv_s2KAX ds1_s2LS2 of
                        { (# ipv2_i2KJl, ipv3_i2KJm #) ->
                        (# fromInteger @ b_s2RwP $dNum_s2LRZ ipv2_i2KJl,
                           case encodeDoubleInteger ipv3_i2KJm ipv1_s2KAY of wild1_Xh
                           { __DEFAULT ->
                           GHC.Types.D# wild1_Xh
                           } #)
                        };
                      1# -> case divZeroError of wild1_00 { }
                    } } in
              case y0_s2Nx9 of wild1_i2Nx7 {
                __DEFAULT ->
                  jump $j1_s2RKq
                    (GHC.Real.$wf GHC.Float.$fRealFloatDouble5 wild1_i2Nx7);
                0# -> jump $j1_s2RKq GHC.Real.$fEnumRatio1
              };
            1# -> case GHC.Real.^1 of wild_00 { }
          };
        1# ->
          (# * @ b_s2RwP
               $dNum_s2LRZ
               (fromInteger @ b_s2RwP $dNum_s2LRZ ipv_s2KAX)
               (^ @ b_s2RwP
                  @ Int
                  $dNum_s2LRZ
                  GHC.Real.$fIntegralInt
                  (fromInteger @ b_s2RwP $dNum_s2LRZ GHC.Float.$fRealFloatDouble5)
                  (GHC.Types.I# ipv1_s2KAY)),
             GHC.Float.rationalToDouble4 #)
      }
      }

-- RHS size: {terms: 14, types: 17, coercions: 0, joins: 0/0}
GHC.Float.$fRealFracDouble_$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Double -> (b, Double)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_s2RwP)
                 (w_s2RwQ [Occ=Once] :: Integral b_s2RwP)
                 (w1_s2RwR [Occ=Once!] :: Double) ->
                 case w1_s2RwR of { D# ww1_s2RwU [Occ=Once] ->
                 case GHC.Float.$w$cproperFraction @ b_s2RwP w_s2RwQ ww1_s2RwU of
                 { (# ww3_s2RDX [Occ=Once], ww4_s2RDY [Occ=Once] #) ->
                 (ww3_s2RDX, ww4_s2RDY)
                 }
                 }}]
GHC.Float.$fRealFracDouble_$cproperFraction
  = \ (@ b_s2RwP)
      (w_s2RwQ :: Integral b_s2RwP)
      (w1_s2RwR :: Double) ->
      case w1_s2RwR of { D# ww1_s2RwU ->
      case GHC.Float.$w$cproperFraction @ b_s2RwP w_s2RwQ ww1_s2RwU of
      { (# ww3_s2RDX, ww4_s2RDY #) ->
      (ww3_s2RDX, ww4_s2RDY)
      }
      }

-- RHS size: {terms: 12, types: 15, coercions: 0, joins: 0/0}
GHC.Float.$fRealFracDouble_$ctruncate [InlPrag=INLINE[1] (sat-args=1)]
  :: forall b. Integral b => Double -> b
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ b_a2J66)
                 ($dIntegral_a2J68 [Occ=Once] :: Integral b_a2J66)
                 (x_a2HYB [Occ=Once] :: Double) ->
                 case GHC.Float.$fRealFracDouble_$cproperFraction
                        @ b_a2J66 $dIntegral_a2J68 x_a2HYB
                 of
                 { (n_a2HYC [Occ=Once], _ [Occ=Dead]) ->
                 n_a2HYC
                 }}]
GHC.Float.$fRealFracDouble_$ctruncate
  = \ (@ b_a2J66)
      ($dIntegral_a2J68 :: Integral b_a2J66)
      (x_a2HYB :: Double) ->
      case x_a2HYB of { D# ww1_s2RwU ->
      case GHC.Float.$w$cproperFraction
             @ b_a2J66 $dIntegral_a2J68 ww1_s2RwU
      of
      { (# ww3_s2RDX, ww4_s2RDY #) ->
      ww3_s2RDX
      }
      }

-- RHS size: {terms: 33, types: 26, coercions: 0, joins: 0/2}
GHC.Float.$fRealFracDouble_$cceiling [InlPrag=INLINE[1] (sat-args=1)]
  :: forall b. Integral b => Double -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(1*C1(C1(U)),A,C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ b_a2J7d) ($dIntegral_a2J7f :: Integral b_a2J7d) ->
                 let {
                   $dReal_a2Jyi [Occ=OnceL] :: Real b_a2J7d
                   [LclId]
                   $dReal_a2Jyi = GHC.Real.$p1Integral @ b_a2J7d $dIntegral_a2J7f } in
                 let {
                   $dNum_a2Jyk :: Num b_a2J7d
                   [LclId]
                   $dNum_a2Jyk = GHC.Real.$p1Real @ b_a2J7d $dReal_a2Jyi } in
                 \ (x_a2HYI [Occ=Once] :: Double) ->
                   case GHC.Float.$fRealFracDouble_$cproperFraction
                          @ b_a2J7d $dIntegral_a2J7f x_a2HYI
                   of
                   { (n_a2HYJ [Occ=Once*], r_a2HYK [Occ=Once!]) ->
                   case r_a2HYK of { D# x1_a2KDX [Occ=Once] ->
                   case >## x1_a2KDX 0.0## of {
                     __DEFAULT -> n_a2HYJ;
                     1# ->
                       + @ b_a2J7d
                         $dNum_a2Jyk
                         n_a2HYJ
                         (fromInteger @ b_a2J7d $dNum_a2Jyk 1)
                   }
                   }
                   }}]
GHC.Float.$fRealFracDouble_$cceiling
  = \ (@ b_a2J7d)
      ($dIntegral_a2J7f :: Integral b_a2J7d)
      (eta_B1 :: Double) ->
      case eta_B1 of { D# ww1_s2RwU ->
      case GHC.Float.$w$cproperFraction
             @ b_a2J7d $dIntegral_a2J7f ww1_s2RwU
      of
      { (# ww3_s2RDX, ww4_s2RDY #) ->
      case ww4_s2RDY of { D# x_a2KDX ->
      case >## x_a2KDX 0.0## of {
        __DEFAULT -> ww3_s2RDX;
        1# ->
          let {
            $dReal_s2LRM [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
              :: Real b_a2J7d
            [LclId]
            $dReal_s2LRM = GHC.Real.$p1Integral @ b_a2J7d $dIntegral_a2J7f } in
          let {
            $dNum_s2LRL [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
              :: Num b_a2J7d
            [LclId]
            $dNum_s2LRL = GHC.Real.$p1Real @ b_a2J7d $dReal_s2LRM } in
          + @ b_a2J7d
            $dNum_s2LRL
            ww3_s2RDX
            (fromInteger @ b_a2J7d $dNum_s2LRL GHC.Float.$fRealDouble1)
      }
      }
      }
      }

-- RHS size: {terms: 33, types: 26, coercions: 0, joins: 0/2}
GHC.Float.$fRealFracDouble_$cfloor [InlPrag=INLINE[1] (sat-args=1)]
  :: forall b. Integral b => Double -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,1*C1(C1(U)),C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ b_a2J7y) ($dIntegral_a2J7A :: Integral b_a2J7y) ->
                 let {
                   $dReal_a2Jyn [Occ=OnceL] :: Real b_a2J7y
                   [LclId]
                   $dReal_a2Jyn = GHC.Real.$p1Integral @ b_a2J7y $dIntegral_a2J7A } in
                 let {
                   $dNum_a2Jyp :: Num b_a2J7y
                   [LclId]
                   $dNum_a2Jyp = GHC.Real.$p1Real @ b_a2J7y $dReal_a2Jyn } in
                 \ (x_a2HYL [Occ=Once] :: Double) ->
                   case GHC.Float.$fRealFracDouble_$cproperFraction
                          @ b_a2J7y $dIntegral_a2J7A x_a2HYL
                   of
                   { (n_a2HYM [Occ=Once*], r_a2HYN [Occ=Once!]) ->
                   case r_a2HYN of { D# x1_a2KE9 [Occ=Once] ->
                   case <## x1_a2KE9 0.0## of {
                     __DEFAULT -> n_a2HYM;
                     1# ->
                       - @ b_a2J7y
                         $dNum_a2Jyp
                         n_a2HYM
                         (fromInteger @ b_a2J7y $dNum_a2Jyp 1)
                   }
                   }
                   }}]
GHC.Float.$fRealFracDouble_$cfloor
  = \ (@ b_a2J7y)
      ($dIntegral_a2J7A :: Integral b_a2J7y)
      (eta_B1 :: Double) ->
      case eta_B1 of { D# ww1_s2RwU ->
      case GHC.Float.$w$cproperFraction
             @ b_a2J7y $dIntegral_a2J7A ww1_s2RwU
      of
      { (# ww3_s2RDX, ww4_s2RDY #) ->
      case ww4_s2RDY of { D# x_a2KE9 ->
      case <## x_a2KE9 0.0## of {
        __DEFAULT -> ww3_s2RDX;
        1# ->
          let {
            $dReal_s2LRQ [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
              :: Real b_a2J7y
            [LclId]
            $dReal_s2LRQ = GHC.Real.$p1Integral @ b_a2J7y $dIntegral_a2J7A } in
          let {
            $dNum_s2LRP [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
              :: Num b_a2J7y
            [LclId]
            $dNum_s2LRP = GHC.Real.$p1Real @ b_a2J7y $dReal_s2LRQ } in
          - @ b_a2J7y
            $dNum_s2LRP
            ww3_s2RDX
            (fromInteger @ b_a2J7y $dNum_s2LRP GHC.Float.$fRealDouble1)
      }
      }
      }
      }

-- RHS size: {terms: 15, types: 9, coercions: 0, joins: 0/0}
GHC.Float.$w$cexponent [InlPrag=NOUSERINLINE[0]] :: Double# -> Int#
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 81 0}]
GHC.Float.$w$cexponent
  = \ (ww_s2Rx3 :: Double#) ->
      case decodeDoubleInteger ww_s2Rx3 of
      { (# ipv_s2KAX, ipv1_s2KAY #) ->
      case eqInteger# ipv_s2KAX GHC.Float.rationalToDouble5 of {
        __DEFAULT -> +# ipv1_s2KAY 53#;
        1# -> 0#
      }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$cexponent [InlPrag=NOUSERINLINE[0]]
  :: Double -> Int
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2Rx0 [Occ=Once!] :: Double) ->
                 case w_s2Rx0 of { D# ww1_s2Rx3 [Occ=Once] ->
                 case GHC.Float.$w$cexponent ww1_s2Rx3 of ww2_s2Rx7 { __DEFAULT ->
                 GHC.Types.I# ww2_s2Rx7
                 }
                 }}]
GHC.Float.$fRealFloatDouble_$cexponent
  = \ (w_s2Rx0 :: Double) ->
      case w_s2Rx0 of { D# ww1_s2Rx3 ->
      case GHC.Float.$w$cexponent ww1_s2Rx3 of ww2_s2Rx7 { __DEFAULT ->
      GHC.Types.I# ww2_s2Rx7
      }
      }

-- RHS size: {terms: 15, types: 11, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$csignificand [InlPrag=NOUSERINLINE[0]]
  :: Double -> Double
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2Rx9 [Occ=Once!] :: Double) ->
                 case w_s2Rx9 of { D# ww1_s2Rxc [Occ=Once] ->
                 case decodeDoubleInteger ww1_s2Rxc of
                 { (# ipv_s2KAX [Occ=Once], _ [Occ=Dead] #) ->
                 case encodeDoubleInteger ipv_s2KAX -53# of ww2_s2Rxg { __DEFAULT ->
                 GHC.Types.D# ww2_s2Rxg
                 }
                 }
                 }}]
GHC.Float.$fRealFloatDouble_$csignificand
  = \ (w_s2Rx9 :: Double) ->
      case w_s2Rx9 of { D# ww1_s2Rxc ->
      case decodeDoubleInteger ww1_s2Rxc of
      { (# ipv_s2KAX, ipv1_s2KAY #) ->
      case encodeDoubleInteger ipv_s2KAX -53# of ww2_s2Rxg { __DEFAULT ->
      GHC.Types.D# ww2_s2Rxg
      }
      }
      }

-- RHS size: {terms: 63, types: 32, coercions: 0, joins: 1/4}
GHC.Float.$w$cround [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Double# -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 369 0}]
GHC.Float.$w$cround
  = \ (@ b_s2Rxi)
      (w_s2Rxj :: Integral b_s2Rxi)
      (ww_s2Rxn :: Double#) ->
      case GHC.Float.$w$cproperFraction @ b_s2Rxi w_s2Rxj ww_s2Rxn of
      { (# ww2_s2RDX, ww3_s2RDY #) ->
      case ww3_s2RDY of { D# x_a2I4j ->
      let {
        x1_a2KPe [Dmd=<S,U>] :: Double#
        [LclId]
        x1_a2KPe = -## (fabsDouble# x_a2I4j) 0.5## } in
      case <## x1_a2KPe 0.0## of {
        __DEFAULT ->
          join {
            m_s2LRW [Dmd=<L,1*U>] :: b_s2Rxi
            [LclId[JoinId(0)]]
            m_s2LRW
              = let {
                  $dReal_s2LRU [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                    :: Real b_s2Rxi
                  [LclId]
                  $dReal_s2LRU = GHC.Real.$p1Integral @ b_s2Rxi w_s2Rxj } in
                let {
                  $dNum_s2LRT [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                    :: Num b_s2Rxi
                  [LclId]
                  $dNum_s2LRT = GHC.Real.$p1Real @ b_s2Rxi $dReal_s2LRU } in
                case <## x_a2I4j 0.0## of {
                  __DEFAULT ->
                    + @ b_s2Rxi
                      $dNum_s2LRT
                      ww2_s2RDX
                      (fromInteger @ b_s2Rxi $dNum_s2LRT GHC.Float.$fRealDouble1);
                  1# ->
                    - @ b_s2Rxi
                      $dNum_s2LRT
                      ww2_s2RDX
                      (fromInteger @ b_s2Rxi $dNum_s2LRT GHC.Float.$fRealDouble1)
                } } in
          case ==## x1_a2KPe 0.0## of {
            __DEFAULT -> jump m_s2LRW;
            1# ->
              case even @ b_s2Rxi w_s2Rxj ww2_s2RDX of {
                False -> jump m_s2LRW;
                True -> ww2_s2RDX
              }
          };
        1# -> ww2_s2RDX
      }
      }
      }

-- RHS size: {terms: 9, types: 8, coercions: 0, joins: 0/0}
GHC.Float.$fRealFracDouble_$cround [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Double -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_s2Rxi)
                 (w_s2Rxj [Occ=Once] :: Integral b_s2Rxi)
                 (w1_s2Rxk [Occ=Once!] :: Double) ->
                 case w1_s2Rxk of { D# ww1_s2Rxn [Occ=Once] ->
                 GHC.Float.$w$cround @ b_s2Rxi w_s2Rxj ww1_s2Rxn
                 }}]
GHC.Float.$fRealFracDouble_$cround
  = \ (@ b_s2Rxi)
      (w_s2Rxj :: Integral b_s2Rxi)
      (w1_s2Rxk :: Double) ->
      case w1_s2Rxk of { D# ww1_s2Rxn ->
      GHC.Float.$w$cround @ b_s2Rxi w_s2Rxj ww1_s2Rxn
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble4 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fRealFloatDouble4 = GHC.Types.I# 53#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$cfloatDigits :: Double -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Float.$fRealFloatDouble4}]
GHC.Float.$fRealFloatDouble_$cfloatDigits
  = \ _ [Occ=Dead] -> GHC.Float.$fRealFloatDouble4

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$cfloatRadix :: Double -> Integer
[GblId,
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Float.$fRealFloatDouble5}]
GHC.Float.$fRealFloatDouble_$cfloatRadix
  = \ _ [Occ=Dead] -> GHC.Float.$fRealFloatDouble5

-- RHS size: {terms: 235, types: 99, coercions: 0, joins: 6/12}
GHC.Float.$dmatan2 :: forall a. RealFloat a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(LLLLC(C(S))LLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(1*C1(C1(U)),A,A,C(U),A,A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A),A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A),1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,C(U),A,1*C1(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2HXC) ($dRealFloat_a2IZ3 :: RealFloat a_a2HXC) ->
                 let {
                   $dFloating_a2JxU :: Floating a_a2HXC
                   [LclId]
                   $dFloating_a2JxU
                     = GHC.Float.$p2RealFloat @ a_a2HXC $dRealFloat_a2IZ3 } in
                 let {
                   $dRealFrac_a2JxT :: RealFrac a_a2HXC
                   [LclId]
                   $dRealFrac_a2JxT
                     = GHC.Float.$p1RealFloat @ a_a2HXC $dRealFloat_a2IZ3 } in
                 let {
                   $dReal_a2JxV :: Real a_a2HXC
                   [LclId]
                   $dReal_a2JxV = GHC.Real.$p1RealFrac @ a_a2HXC $dRealFrac_a2JxT } in
                 let {
                   $dNum_a2JxX :: Num a_a2HXC
                   [LclId]
                   $dNum_a2JxX = GHC.Real.$p1Real @ a_a2HXC $dReal_a2JxV } in
                 let {
                   $dOrd_a2JxY :: Ord a_a2HXC
                   [LclId]
                   $dOrd_a2JxY = GHC.Real.$p2Real @ a_a2HXC $dReal_a2JxV } in
                 let {
                   $dEq_a2JxZ :: Eq a_a2HXC
                   [LclId]
                   $dEq_a2JxZ = GHC.Classes.$p1Ord @ a_a2HXC $dOrd_a2JxY } in
                 let {
                   $dFractional_a2JxW :: Fractional a_a2HXC
                   [LclId]
                   $dFractional_a2JxW
                     = GHC.Real.$p2RealFrac @ a_a2HXC $dRealFrac_a2JxT } in
                 \ (y_a2HXS :: a_a2HXC) (x_a2HXT :: a_a2HXC) ->
                   case > @ a_a2HXC
                          $dOrd_a2JxY
                          x_a2HXT
                          (fromInteger @ a_a2HXC $dNum_a2JxX 0)
                   of {
                     False ->
                       join {
                         $j1_s2Mcc [Occ=Once*T[0]] :: a_a2HXC
                         [LclId[JoinId(0)]]
                         $j1_s2Mcc
                           = join {
                               $j2_s2Mc8 [Occ=Once*T[0]] :: a_a2HXC
                               [LclId[JoinId(0)]]
                               $j2_s2Mc8
                                 = join {
                                     $j3_s2MbZ [Occ=Once*T[0]] :: a_a2HXC
                                     [LclId[JoinId(0)]]
                                     $j3_s2MbZ
                                       = join {
                                           $j4_s2MbV [Occ=Once*T[0]] :: a_a2HXC
                                           [LclId[JoinId(0)]]
                                           $j4_s2MbV
                                             = case ==
                                                      @ a_a2HXC
                                                      $dEq_a2JxZ
                                                      x_a2HXT
                                                      (fromInteger @ a_a2HXC $dNum_a2JxX 0)
                                               of {
                                                 False -> + @ a_a2HXC $dNum_a2JxX x_a2HXT y_a2HXS;
                                                 True ->
                                                   case ==
                                                          @ a_a2HXC
                                                          $dEq_a2JxZ
                                                          y_a2HXS
                                                          (fromInteger @ a_a2HXC $dNum_a2JxX 0)
                                                   of {
                                                     False ->
                                                       + @ a_a2HXC $dNum_a2JxX x_a2HXT y_a2HXS;
                                                     True -> y_a2HXS
                                                   }
                                               } } in
                                         case ==
                                                @ a_a2HXC
                                                $dEq_a2JxZ
                                                y_a2HXS
                                                (fromInteger @ a_a2HXC $dNum_a2JxX 0)
                                         of {
                                           False -> jump $j4_s2MbV;
                                           True ->
                                             case < @ a_a2HXC
                                                    $dOrd_a2JxY
                                                    x_a2HXT
                                                    (fromInteger @ a_a2HXC $dNum_a2JxX 0)
                                             of {
                                               False ->
                                                 case isNegativeZero
                                                        @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXT
                                                 of {
                                                   False -> jump $j4_s2MbV;
                                                   True -> pi @ a_a2HXC $dFloating_a2JxU
                                                 };
                                               True -> pi @ a_a2HXC $dFloating_a2JxU
                                             }
                                         } } in
                                   join {
                                     $j4_s2Mc5 [Occ=Once*T[0]] :: a_a2HXC
                                     [LclId[JoinId(0)]]
                                     $j4_s2Mc5
                                       = join {
                                           $j5_s2Mc2 [Occ=Once*T[0]] :: a_a2HXC
                                           [LclId[JoinId(0)]]
                                           $j5_s2Mc2
                                             = case isNegativeZero
                                                      @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXT
                                               of {
                                                 False -> jump $j3_s2MbZ;
                                                 True ->
                                                   case isNegativeZero
                                                          @ a_a2HXC $dRealFloat_a2IZ3 y_a2HXS
                                                   of {
                                                     False -> jump $j3_s2MbZ;
                                                     True ->
                                                       negate
                                                         @ a_a2HXC
                                                         $dNum_a2JxX
                                                         (atan2
                                                            @ a_a2HXC
                                                            $dRealFloat_a2IZ3
                                                            (negate @ a_a2HXC $dNum_a2JxX y_a2HXS)
                                                            x_a2HXT)
                                                   }
                                               } } in
                                         case < @ a_a2HXC
                                                $dOrd_a2JxY
                                                x_a2HXT
                                                (fromInteger @ a_a2HXC $dNum_a2JxX 0)
                                         of {
                                           False -> jump $j5_s2Mc2;
                                           True ->
                                             case isNegativeZero @ a_a2HXC $dRealFloat_a2IZ3 y_a2HXS
                                             of {
                                               False -> jump $j5_s2Mc2;
                                               True ->
                                                 negate
                                                   @ a_a2HXC
                                                   $dNum_a2JxX
                                                   (atan2
                                                      @ a_a2HXC
                                                      $dRealFloat_a2IZ3
                                                      (negate @ a_a2HXC $dNum_a2JxX y_a2HXS)
                                                      x_a2HXT)
                                             }
                                         } } in
                                   case <=
                                          @ a_a2HXC
                                          $dOrd_a2JxY
                                          x_a2HXT
                                          (fromInteger @ a_a2HXC $dNum_a2JxX 0)
                                   of {
                                     False -> jump $j4_s2Mc5;
                                     True ->
                                       case < @ a_a2HXC
                                              $dOrd_a2JxY
                                              y_a2HXS
                                              (fromInteger @ a_a2HXC $dNum_a2JxX 0)
                                       of {
                                         False -> jump $j4_s2Mc5;
                                         True ->
                                           negate
                                             @ a_a2HXC
                                             $dNum_a2JxX
                                             (atan2
                                                @ a_a2HXC
                                                $dRealFloat_a2IZ3
                                                (negate @ a_a2HXC $dNum_a2JxX y_a2HXS)
                                                x_a2HXT)
                                       }
                                   } } in
                             case < @ a_a2HXC
                                    $dOrd_a2JxY
                                    x_a2HXT
                                    (fromInteger @ a_a2HXC $dNum_a2JxX 0)
                             of {
                               False -> jump $j2_s2Mc8;
                               True ->
                                 case > @ a_a2HXC
                                        $dOrd_a2JxY
                                        y_a2HXS
                                        (fromInteger @ a_a2HXC $dNum_a2JxX 0)
                                 of {
                                   False -> jump $j2_s2Mc8;
                                   True ->
                                     + @ a_a2HXC
                                       $dNum_a2JxX
                                       (pi @ a_a2HXC $dFloating_a2JxU)
                                       (atan
                                          @ a_a2HXC
                                          $dFloating_a2JxU
                                          (/ @ a_a2HXC $dFractional_a2JxW y_a2HXS x_a2HXT))
                                 }
                             } } in
                       case ==
                              @ a_a2HXC $dEq_a2JxZ x_a2HXT (fromInteger @ a_a2HXC $dNum_a2JxX 0)
                       of {
                         False -> jump $j1_s2Mcc;
                         True ->
                           case > @ a_a2HXC
                                  $dOrd_a2JxY
                                  y_a2HXS
                                  (fromInteger @ a_a2HXC $dNum_a2JxX 0)
                           of {
                             False -> jump $j1_s2Mcc;
                             True ->
                               / @ a_a2HXC
                                 $dFractional_a2JxW
                                 (pi @ a_a2HXC $dFloating_a2JxU)
                                 (fromInteger @ a_a2HXC $dNum_a2JxX 2)
                           }
                       };
                     True ->
                       atan
                         @ a_a2HXC
                         $dFloating_a2JxU
                         (/ @ a_a2HXC $dFractional_a2JxW y_a2HXS x_a2HXT)
                   }}]
GHC.Float.$dmatan2
  = \ (@ a_a2HXC)
      ($dRealFloat_a2IZ3 :: RealFloat a_a2HXC)
      (eta_B2 :: a_a2HXC)
      (eta1_B1 :: a_a2HXC) ->
      let {
        $dRealFrac_s2LTF [Dmd=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLL),U(1*U(1*U(1*C1(C1(U)),A,A,C(U),A,A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A),A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A)>]
          :: RealFrac a_a2HXC
        [LclId]
        $dRealFrac_s2LTF
          = GHC.Float.$p1RealFloat @ a_a2HXC $dRealFloat_a2IZ3 } in
      let {
        $dReal_s2LTE [Dmd=<S(LS(LLLLC(C(S))LLL)L),U(1*U(1*C1(C1(U)),A,A,C(U),A,A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A),A)>]
          :: Real a_a2HXC
        [LclId]
        $dReal_s2LTE = GHC.Real.$p1RealFrac @ a_a2HXC $dRealFrac_s2LTF } in
      let {
        $dNum_s2LTD [Dmd=<L,U(1*C1(C1(U)),A,A,C(U),A,A,C(U))>]
          :: Num a_a2HXC
        [LclId]
        $dNum_s2LTD = GHC.Real.$p1Real @ a_a2HXC $dReal_s2LTE } in
      let {
        $dOrd_s2LTC [Dmd=<S(LLLLC(C(S))LLL),U(1*U(C(C1(U)),A),A,C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A)>]
          :: Ord a_a2HXC
        [LclId]
        $dOrd_s2LTC = GHC.Real.$p2Real @ a_a2HXC $dReal_s2LTE } in
      let {
        $dFloating_s2LTG [Dmd=<L,U(A,1*U,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A)>]
          :: Floating a_a2HXC
        [LclId]
        $dFloating_s2LTG
          = GHC.Float.$p2RealFloat @ a_a2HXC $dRealFloat_a2IZ3 } in
      case > @ a_a2HXC
             $dOrd_s2LTC
             eta1_B1
             (fromInteger @ a_a2HXC $dNum_s2LTD GHC.Float.rationalToDouble5)
      of {
        False ->
          let {
            $dEq_s2LTB [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq a_a2HXC
            [LclId]
            $dEq_s2LTB = GHC.Classes.$p1Ord @ a_a2HXC $dOrd_s2LTC } in
          join {
            $j1_s2MbP [Dmd=<L,1*U>] :: a_a2HXC
            [LclId[JoinId(0)]]
            $j1_s2MbP
              = join {
                  $j2_s2MbL [Dmd=<L,1*U>] :: a_a2HXC
                  [LclId[JoinId(0)]]
                  $j2_s2MbL
                    = join {
                        $j3_s2MbI [Dmd=<L,1*U>] :: a_a2HXC
                        [LclId[JoinId(0)]]
                        $j3_s2MbI
                          = join {
                              $j4_s2MbF [Dmd=<L,1*U>] :: a_a2HXC
                              [LclId[JoinId(0)]]
                              $j4_s2MbF
                                = join {
                                    $j5_s2MbC [Dmd=<L,1*U>] :: a_a2HXC
                                    [LclId[JoinId(0)]]
                                    $j5_s2MbC
                                      = join {
                                          $j6_s2Mby [Dmd=<L,1*U>] :: a_a2HXC
                                          [LclId[JoinId(0)]]
                                          $j6_s2Mby
                                            = case ==
                                                     @ a_a2HXC
                                                     $dEq_s2LTB
                                                     eta1_B1
                                                     (fromInteger
                                                        @ a_a2HXC
                                                        $dNum_s2LTD
                                                        GHC.Float.rationalToDouble5)
                                              of {
                                                False -> + @ a_a2HXC $dNum_s2LTD eta1_B1 eta_B2;
                                                True ->
                                                  case ==
                                                         @ a_a2HXC
                                                         $dEq_s2LTB
                                                         eta_B2
                                                         (fromInteger
                                                            @ a_a2HXC
                                                            $dNum_s2LTD
                                                            GHC.Float.rationalToDouble5)
                                                  of {
                                                    False -> + @ a_a2HXC $dNum_s2LTD eta1_B1 eta_B2;
                                                    True -> eta_B2
                                                  }
                                              } } in
                                        case ==
                                               @ a_a2HXC
                                               $dEq_s2LTB
                                               eta_B2
                                               (fromInteger
                                                  @ a_a2HXC $dNum_s2LTD GHC.Float.rationalToDouble5)
                                        of {
                                          False -> jump $j6_s2Mby;
                                          True ->
                                            case < @ a_a2HXC
                                                   $dOrd_s2LTC
                                                   eta1_B1
                                                   (fromInteger
                                                      @ a_a2HXC
                                                      $dNum_s2LTD
                                                      GHC.Float.rationalToDouble5)
                                            of {
                                              False ->
                                                case isNegativeZero
                                                       @ a_a2HXC $dRealFloat_a2IZ3 eta1_B1
                                                of {
                                                  False -> jump $j6_s2Mby;
                                                  True -> pi @ a_a2HXC $dFloating_s2LTG
                                                };
                                              True -> pi @ a_a2HXC $dFloating_s2LTG
                                            }
                                        } } in
                                  case isNegativeZero @ a_a2HXC $dRealFloat_a2IZ3 eta1_B1 of {
                                    False -> jump $j5_s2MbC;
                                    True ->
                                      case isNegativeZero @ a_a2HXC $dRealFloat_a2IZ3 eta_B2 of {
                                        False -> jump $j5_s2MbC;
                                        True ->
                                          negate
                                            @ a_a2HXC
                                            $dNum_s2LTD
                                            (atan2
                                               @ a_a2HXC
                                               $dRealFloat_a2IZ3
                                               (negate @ a_a2HXC $dNum_s2LTD eta_B2)
                                               eta1_B1)
                                      }
                                  } } in
                            case < @ a_a2HXC
                                   $dOrd_s2LTC
                                   eta1_B1
                                   (fromInteger @ a_a2HXC $dNum_s2LTD GHC.Float.rationalToDouble5)
                            of {
                              False -> jump $j4_s2MbF;
                              True ->
                                case isNegativeZero @ a_a2HXC $dRealFloat_a2IZ3 eta_B2 of {
                                  False -> jump $j4_s2MbF;
                                  True ->
                                    negate
                                      @ a_a2HXC
                                      $dNum_s2LTD
                                      (atan2
                                         @ a_a2HXC
                                         $dRealFloat_a2IZ3
                                         (negate @ a_a2HXC $dNum_s2LTD eta_B2)
                                         eta1_B1)
                                }
                            } } in
                      case <=
                             @ a_a2HXC
                             $dOrd_s2LTC
                             eta1_B1
                             (fromInteger @ a_a2HXC $dNum_s2LTD GHC.Float.rationalToDouble5)
                      of {
                        False -> jump $j3_s2MbI;
                        True ->
                          case < @ a_a2HXC
                                 $dOrd_s2LTC
                                 eta_B2
                                 (fromInteger @ a_a2HXC $dNum_s2LTD GHC.Float.rationalToDouble5)
                          of {
                            False -> jump $j3_s2MbI;
                            True ->
                              negate
                                @ a_a2HXC
                                $dNum_s2LTD
                                (atan2
                                   @ a_a2HXC
                                   $dRealFloat_a2IZ3
                                   (negate @ a_a2HXC $dNum_s2LTD eta_B2)
                                   eta1_B1)
                          }
                      } } in
                case < @ a_a2HXC
                       $dOrd_s2LTC
                       eta1_B1
                       (fromInteger @ a_a2HXC $dNum_s2LTD GHC.Float.rationalToDouble5)
                of {
                  False -> jump $j2_s2MbL;
                  True ->
                    case > @ a_a2HXC
                           $dOrd_s2LTC
                           eta_B2
                           (fromInteger @ a_a2HXC $dNum_s2LTD GHC.Float.rationalToDouble5)
                    of {
                      False -> jump $j2_s2MbL;
                      True ->
                        + @ a_a2HXC
                          $dNum_s2LTD
                          (pi @ a_a2HXC $dFloating_s2LTG)
                          (atan
                             @ a_a2HXC
                             $dFloating_s2LTG
                             (/ @ a_a2HXC
                                (GHC.Real.$p2RealFrac @ a_a2HXC $dRealFrac_s2LTF)
                                eta_B2
                                eta1_B1))
                    }
                } } in
          case ==
                 @ a_a2HXC
                 $dEq_s2LTB
                 eta1_B1
                 (fromInteger @ a_a2HXC $dNum_s2LTD GHC.Float.rationalToDouble5)
          of {
            False -> jump $j1_s2MbP;
            True ->
              case > @ a_a2HXC
                     $dOrd_s2LTC
                     eta_B2
                     (fromInteger @ a_a2HXC $dNum_s2LTD GHC.Float.rationalToDouble5)
              of {
                False -> jump $j1_s2MbP;
                True ->
                  / @ a_a2HXC
                    (GHC.Real.$p2RealFrac @ a_a2HXC $dRealFrac_s2LTF)
                    (pi @ a_a2HXC $dFloating_s2LTG)
                    (fromInteger @ a_a2HXC $dNum_s2LTD GHC.Float.$fRealFloatDouble5)
              }
          };
        True ->
          atan
            @ a_a2HXC
            $dFloating_s2LTG
            (/ @ a_a2HXC
               (GHC.Real.$p2RealFrac @ a_a2HXC $dRealFrac_s2LTF)
               eta_B2
               eta1_B1)
      }

-- RHS size: {terms: 12, types: 10, coercions: 0, joins: 0/0}
GHC.Float.$dmlog1mexp [InlPrag=INLINE (sat-args=1)]
  :: forall a. Floating a => a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(1*U(1*U(A,A,A,1*C1(U),A,A,A),A,A,A),A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2HXU) ($dFloating_a2IXN :: Floating a_a2HXU) ->
                 let {
                   $dNum_s2KBx [Occ=OnceL] :: Fractional a_a2HXU
                   [LclId]
                   $dNum_s2KBx = GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN } in
                 let {
                   $dNum1_a2IYZ [Occ=OnceL] :: Num a_a2HXU
                   [LclId]
                   $dNum1_a2IYZ = GHC.Real.$p1Fractional @ a_a2HXU $dNum_s2KBx } in
                 \ (x_a2HY5 [Occ=Once] :: a_a2HXU) ->
                   log1p
                     @ a_a2HXU
                     $dFloating_a2IXN
                     (negate
                        @ a_a2HXU $dNum1_a2IYZ (exp @ a_a2HXU $dFloating_a2IXN x_a2HY5))}]
GHC.Float.$dmlog1mexp
  = \ (@ a_a2HXU)
      ($dFloating_a2IXN :: Floating a_a2HXU)
      (eta_B1 :: a_a2HXU) ->
      log1p
        @ a_a2HXU
        $dFloating_a2IXN
        (negate
           @ a_a2HXU
           (GHC.Real.$p1Fractional
              @ a_a2HXU (GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN))
           (exp @ a_a2HXU $dFloating_a2IXN eta_B1))

-- RHS size: {terms: 8, types: 7, coercions: 0, joins: 0/0}
GHC.Float.$dmlog1pexp [InlPrag=INLINE (sat-args=1)]
  :: forall a. Floating a => a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2HXU)
                 ($dFloating_a2IXN :: Floating a_a2HXU)
                 (x_a2HY4 [Occ=Once] :: a_a2HXU) ->
                 log1p
                   @ a_a2HXU
                   $dFloating_a2IXN
                   (exp @ a_a2HXU $dFloating_a2IXN x_a2HY4)}]
GHC.Float.$dmlog1pexp
  = \ (@ a_a2HXU)
      ($dFloating_a2IXN :: Floating a_a2HXU)
      (x_a2HY4 :: a_a2HXU) ->
      log1p
        @ a_a2HXU $dFloating_a2IXN (exp @ a_a2HXU $dFloating_a2IXN x_a2HY4)

-- RHS size: {terms: 17, types: 14, coercions: 0, joins: 0/2}
GHC.Float.$dmexpm1 [InlPrag=INLINE (sat-args=1)]
  :: forall a. Floating a => a -> a
[GblId,
 Arity=2,
 Str=<S(S(S(LC(C(S))LLLLL)LLL)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A,A),A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2HXU) ($dFloating_a2IXN :: Floating a_a2HXU) ->
                 let {
                   $dFractional_a2Jxj [Occ=OnceL] :: Fractional a_a2HXU
                   [LclId]
                   $dFractional_a2Jxj
                     = GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN } in
                 let {
                   $dNum_a2Jxk :: Num a_a2HXU
                   [LclId]
                   $dNum_a2Jxk
                     = GHC.Real.$p1Fractional @ a_a2HXU $dFractional_a2Jxj } in
                 \ (x_a2HY3 [Occ=Once] :: a_a2HXU) ->
                   - @ a_a2HXU
                     $dNum_a2Jxk
                     (exp @ a_a2HXU $dFloating_a2IXN x_a2HY3)
                     (fromInteger @ a_a2HXU $dNum_a2Jxk 1)}]
GHC.Float.$dmexpm1
  = \ (@ a_a2HXU)
      ($dFloating_a2IXN :: Floating a_a2HXU)
      (eta_B1 :: a_a2HXU) ->
      let {
        $dFractional_s2LTu [Dmd=<S(S(LC(C(S))LLLLL)LLL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A,A)>]
          :: Fractional a_a2HXU
        [LclId]
        $dFractional_s2LTu
          = GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN } in
      let {
        $dNum_s2LTt [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
          :: Num a_a2HXU
        [LclId]
        $dNum_s2LTt
          = GHC.Real.$p1Fractional @ a_a2HXU $dFractional_s2LTu } in
      - @ a_a2HXU
        $dNum_s2LTt
        (exp @ a_a2HXU $dFloating_a2IXN eta_B1)
        (fromInteger @ a_a2HXU $dNum_s2LTt GHC.Float.$fRealDouble1)

-- RHS size: {terms: 17, types: 14, coercions: 0, joins: 0/2}
GHC.Float.$dmlog1p [InlPrag=INLINE (sat-args=1)]
  :: forall a. Floating a => a -> a
[GblId,
 Arity=2,
 Str=<S(LLLC(S)LLLLLLLLLLLLLLLLLLL),U(1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A),A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2HXU) ($dFloating_a2IXN :: Floating a_a2HXU) ->
                 let {
                   $dFractional_a2Jxh [Occ=OnceL] :: Fractional a_a2HXU
                   [LclId]
                   $dFractional_a2Jxh
                     = GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN } in
                 let {
                   $dNum_a2Jxi :: Num a_a2HXU
                   [LclId]
                   $dNum_a2Jxi
                     = GHC.Real.$p1Fractional @ a_a2HXU $dFractional_a2Jxh } in
                 \ (x_a2HY2 [Occ=Once] :: a_a2HXU) ->
                   log
                     @ a_a2HXU
                     $dFloating_a2IXN
                     (+ @ a_a2HXU
                        $dNum_a2Jxi
                        (fromInteger @ a_a2HXU $dNum_a2Jxi 1)
                        x_a2HY2)}]
GHC.Float.$dmlog1p
  = \ (@ a_a2HXU)
      ($dFloating_a2IXN :: Floating a_a2HXU)
      (eta_B1 :: a_a2HXU) ->
      log
        @ a_a2HXU
        $dFloating_a2IXN
        (let {
           $dFractional_s2LTq [Dmd=<S(S(C(C(S))LLLLLL)LLL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A)>]
             :: Fractional a_a2HXU
           [LclId]
           $dFractional_s2LTq
             = GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN } in
         let {
           $dNum_s2LTp [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
             :: Num a_a2HXU
           [LclId]
           $dNum_s2LTp
             = GHC.Real.$p1Fractional @ a_a2HXU $dFractional_s2LTq } in
         + @ a_a2HXU
           $dNum_s2LTp
           (fromInteger @ a_a2HXU $dNum_s2LTp GHC.Float.$fRealDouble1)
           eta_B1)

-- RHS size: {terms: 12, types: 9, coercions: 0, joins: 0/0}
GHC.Float.$dmtanh [InlPrag=INLINE (sat-args=1)]
  :: forall a. Floating a => a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S))LL)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2HXU) ($dFloating_a2IXN :: Floating a_a2HXU) ->
                 let {
                   $dFractional_a2IYp [Occ=OnceL] :: Fractional a_a2HXU
                   [LclId]
                   $dFractional_a2IYp
                     = GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN } in
                 \ (x_a2HY1 :: a_a2HXU) ->
                   / @ a_a2HXU
                     $dFractional_a2IYp
                     (sinh @ a_a2HXU $dFloating_a2IXN x_a2HY1)
                     (cosh @ a_a2HXU $dFloating_a2IXN x_a2HY1)}]
GHC.Float.$dmtanh
  = \ (@ a_a2HXU)
      ($dFloating_a2IXN :: Floating a_a2HXU)
      (eta_B1 :: a_a2HXU) ->
      / @ a_a2HXU
        (GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN)
        (sinh @ a_a2HXU $dFloating_a2IXN eta_B1)
        (cosh @ a_a2HXU $dFloating_a2IXN eta_B1)

-- RHS size: {terms: 12, types: 9, coercions: 0, joins: 0/0}
GHC.Float.$dmtan [InlPrag=INLINE (sat-args=1)]
  :: forall a. Floating a => a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S))LL)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2HXU) ($dFloating_a2IXN :: Floating a_a2HXU) ->
                 let {
                   $dFractional_a2IYg [Occ=OnceL] :: Fractional a_a2HXU
                   [LclId]
                   $dFractional_a2IYg
                     = GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN } in
                 \ (x_a2HY0 :: a_a2HXU) ->
                   / @ a_a2HXU
                     $dFractional_a2IYg
                     (sin @ a_a2HXU $dFloating_a2IXN x_a2HY0)
                     (cos @ a_a2HXU $dFloating_a2IXN x_a2HY0)}]
GHC.Float.$dmtan
  = \ (@ a_a2HXU)
      ($dFloating_a2IXN :: Floating a_a2HXU)
      (eta_B1 :: a_a2HXU) ->
      / @ a_a2HXU
        (GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN)
        (sin @ a_a2HXU $dFloating_a2IXN eta_B1)
        (cos @ a_a2HXU $dFloating_a2IXN eta_B1)

-- RHS size: {terms: 13, types: 10, coercions: 0, joins: 0/0}
GHC.Float.$dmlogBase [InlPrag=INLINE (sat-args=2)]
  :: forall a. Floating a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S))LL)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(A,1*C1(C1(U)),A,A),A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2HXU) ($dFloating_a2IXN :: Floating a_a2HXU) ->
                 let {
                   $dFractional_a2IY7 [Occ=OnceL] :: Fractional a_a2HXU
                   [LclId]
                   $dFractional_a2IY7
                     = GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN } in
                 \ (x_a2HXX [Occ=Once] :: a_a2HXU)
                   (y_a2HXY [Occ=Once] :: a_a2HXU) ->
                   / @ a_a2HXU
                     $dFractional_a2IY7
                     (log @ a_a2HXU $dFloating_a2IXN y_a2HXY)
                     (log @ a_a2HXU $dFloating_a2IXN x_a2HXX)}]
GHC.Float.$dmlogBase
  = \ (@ a_a2HXU)
      ($dFloating_a2IXN :: Floating a_a2HXU)
      (eta_B2 :: a_a2HXU)
      (eta1_B1 :: a_a2HXU) ->
      / @ a_a2HXU
        (GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN)
        (log @ a_a2HXU $dFloating_a2IXN eta1_B1)
        (log @ a_a2HXU $dFloating_a2IXN eta_B2)

-- RHS size: {terms: 14, types: 11, coercions: 0, joins: 0/0}
GHC.Float.$dm** [InlPrag=INLINE (sat-args=2)]
  :: forall a. Floating a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLLLLLLLLLLLLLLLLLLL),U(1*U(1*U(A,A,1*C1(C1(U)),A,A,A,A),A,A,A),A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2HXU) ($dFloating_a2IXN :: Floating a_a2HXU) ->
                 let {
                   $dNum_s2KBz [Occ=OnceL] :: Fractional a_a2HXU
                   [LclId]
                   $dNum_s2KBz = GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN } in
                 let {
                   $dNum1_a2IY0 [Occ=OnceL] :: Num a_a2HXU
                   [LclId]
                   $dNum1_a2IY0 = GHC.Real.$p1Fractional @ a_a2HXU $dNum_s2KBz } in
                 \ (x_a2HXV [Occ=Once] :: a_a2HXU)
                   (y_a2HXW [Occ=Once] :: a_a2HXU) ->
                   exp
                     @ a_a2HXU
                     $dFloating_a2IXN
                     (* @ a_a2HXU
                        $dNum1_a2IY0
                        (log @ a_a2HXU $dFloating_a2IXN x_a2HXV)
                        y_a2HXW)}]
GHC.Float.$dm**
  = \ (@ a_a2HXU)
      ($dFloating_a2IXN :: Floating a_a2HXU)
      (eta_B2 :: a_a2HXU)
      (eta1_B1 :: a_a2HXU) ->
      exp
        @ a_a2HXU
        $dFloating_a2IXN
        (* @ a_a2HXU
           (GHC.Real.$p1Fractional
              @ a_a2HXU (GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN))
           (log @ a_a2HXU $dFloating_a2IXN eta_B2)
           eta1_B1)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lvl1_r2Upz :: Ratio Integer
[GblId, Str=m, Unf=OtherCon []]
lvl1_r2Upz
  = GHC.Real.:%
      @ Integer GHC.Float.$fRealDouble1 GHC.Float.$fRealFloatDouble5

-- RHS size: {terms: 10, types: 8, coercions: 0, joins: 0/0}
GHC.Float.$dmsqrt [InlPrag=INLINE (sat-args=1)]
  :: forall a. Floating a => a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),U(1*U(A,A,A,1*C1(U)),A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2HXU) ($dFloating_a2IXN :: Floating a_a2HXU) ->
                 let {
                   $dFractional_a2IXT [Occ=OnceL] :: Fractional a_a2HXU
                   [LclId]
                   $dFractional_a2IXT
                     = GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN } in
                 \ (x_a2HXZ [Occ=Once] :: a_a2HXU) ->
                   **
                     @ a_a2HXU
                     $dFloating_a2IXN
                     x_a2HXZ
                     (fromRational
                        @ a_a2HXU $dFractional_a2IXT (GHC.Real.:% @ Integer 1 2))}]
GHC.Float.$dmsqrt
  = \ (@ a_a2HXU)
      ($dFloating_a2IXN :: Floating a_a2HXU)
      (eta_B1 :: a_a2HXU) ->
      **
        @ a_a2HXU
        $dFloating_a2IXN
        eta_B1
        (fromRational
           @ a_a2HXU
           (GHC.Float.$p1Floating @ a_a2HXU $dFloating_a2IXN)
           lvl1_r2Upz)

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Float.roundTo2 :: Int -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2K6f [Occ=Once!] :: Int) ->
                 case ds_d2K6f of { I# x_a22G [Occ=Once!] ->
                 case x_a22G of {
                   __DEFAULT -> GHC.Types.False;
                   0# -> GHC.Types.True
                 }
                 }}]
GHC.Float.roundTo2
  = \ (ds_d2K6f :: Int) ->
      case ds_d2K6f of { I# x_a22G ->
      case x_a22G of {
        __DEFAULT -> GHC.Types.False;
        0# -> GHC.Types.True
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl2_r2UpA :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl2_r2UpA = "roundTo: bad Value"#

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
GHC.Float.roundTo1 :: (Int, [Int])
[GblId, Str=x]
GHC.Float.roundTo1
  = errorWithoutStackTrace
      @ 'LiftedRep @ (Int, [Int]) (unpackCString# lvl2_r2UpA)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
lvl3_r2UpB :: [Int]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
lvl3_r2UpB = GHC.Types.: @ Int minExpt (GHC.Types.[] @ Int)

Rec {
-- RHS size: {terms: 12, types: 3, coercions: 0, joins: 0/0}
GHC.Float.$wxs [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: Int# -> [Int]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m2, Unf=OtherCon []]
GHC.Float.$wxs
  = \ (ww_s2Rxt :: Int#) ->
      case ww_s2Rxt of ds1_i2KC9 {
        __DEFAULT ->
          GHC.Types.: @ Int minExpt (GHC.Float.$wxs (-# ds1_i2KC9 1#));
        1# -> lvl3_r2UpB
      }
end Rec }

-- RHS size: {terms: 157, types: 124, coercions: 0, joins: 0/3}
GHC.Float.$wroundTo [InlPrag=NOUSERINLINE[0]]
  :: Int -> Int -> [Int] -> (# Int, [Int] #)
[GblId,
 Arity=3,
 Str=<L,U(U)><L,1*U(U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [40 0 0] 609 30}]
GHC.Float.$wroundTo
  = \ (w_s2RxD :: Int) (w1_s2RxE :: Int) (w2_s2RxF :: [Int]) ->
      let {
        b2_s2LTk [Dmd=<L,U(U)>] :: Int
        [LclId]
        b2_s2LTk
          = case w_s2RxD of { I# ww1_i2KBF ->
            GHC.Types.I# (quotInt# ww1_i2KBF 2#)
            } } in
      letrec {
        $wf1_s2RxC [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
          :: Int -> Bool -> [Int] -> (# Int, [Int] #)
        [LclId, Arity=3, Str=<L,1*U(U)><L,1*U><S,1*U>, Unf=OtherCon []]
        $wf1_s2RxC
          = \ (w3_s2Rxw :: Int) (w4_s2Rxx :: Bool) (w5_s2Rxy :: [Int]) ->
              case w5_s2Rxy of {
                [] ->
                  (# minExpt,
                     case w3_s2Rxw of { I# y_alNd ->
                     case <# 0# y_alNd of {
                       __DEFAULT -> GHC.Types.[] @ Int;
                       1# -> GHC.Float.$wxs y_alNd
                     }
                     } #);
                : ipv_s2KBQ ipv1_s2KCa ->
                  case w3_s2Rxw of { I# ds_d2K6o ->
                  case ds_d2K6o of ds1_X2K71 {
                    __DEFAULT ->
                      case $wf1_s2RxC
                             (GHC.Types.I# (-# ds1_X2K71 1#))
                             (GHC.Float.$seven ipv_s2KBQ)
                             ipv1_s2KCa
                      of
                      { (# ww1_s2RE0, ww2_s2RE1 #) ->
                      case ww1_s2RE0 of { I# x_i1AMi ->
                      case ipv_s2KBQ of { I# y_i1AMm ->
                      case w_s2RxD of { I# y1_a22K ->
                      let {
                        x1_a22G [Dmd=<S,U>] :: Int#
                        [LclId]
                        x1_a22G = +# x_i1AMi y_i1AMm } in
                      case ==# x1_a22G y1_a22K of {
                        __DEFAULT ->
                          (# minExpt, GHC.Types.: @ Int (GHC.Types.I# x1_a22G) ww2_s2RE1 #);
                        1# ->
                          (# GHC.Float.$fRealFracFloat2,
                             GHC.Types.: @ Int minExpt ww2_s2RE1 #)
                      }
                      }
                      }
                      }
                      };
                    0# ->
                      case ipv_s2KBQ of { I# x_a22G ->
                      case b2_s2LTk of { I# y_a22K ->
                      case ==# x_a22G y_a22K of {
                        __DEFAULT ->
                          (# case >=# x_a22G y_a22K of {
                               __DEFAULT -> minExpt;
                               1# -> GHC.Float.$fRealFracFloat2
                             },
                             GHC.Types.[] @ Int #);
                        1# ->
                          case w4_s2Rxx of {
                            False ->
                              (# case >=# x_a22G y_a22K of {
                                   __DEFAULT -> minExpt;
                                   1# -> GHC.Float.$fRealFracFloat2
                                 },
                                 GHC.Types.[] @ Int #);
                            True ->
                              case all @ Int GHC.Float.roundTo2 ipv1_s2KCa of {
                                False ->
                                  (# case >=# x_a22G y_a22K of {
                                       __DEFAULT -> minExpt;
                                       1# -> GHC.Float.$fRealFracFloat2
                                     },
                                     GHC.Types.[] @ Int #);
                                True -> (# minExpt, GHC.Types.[] @ Int #)
                              }
                          }
                      }
                      }
                      }
                  }
                  }
              }; } in
      case $wf1_s2RxC w1_s2RxE GHC.Types.True w2_s2RxF of ww_s2RxB
      { (# ww1_s2RE0, ww2_s2RE1 #) ->
      case ww1_s2RE0 of { I# ds_d2K5V ->
      case ds_d2K5V of {
        __DEFAULT -> case GHC.Float.roundTo1 of wild1_00 { };
        0# -> ww_s2RxB;
        1# ->
          (# GHC.Float.$fRealFracFloat2,
             GHC.Types.: @ Int GHC.Float.$fRealFracFloat2 ww2_s2RE1 #)
      }
      }
      }

-- RHS size: {terms: 12, types: 16, coercions: 0, joins: 0/0}
roundTo [InlPrag=NOUSERINLINE[0]]
  :: Int -> Int -> [Int] -> (Int, [Int])
[GblId,
 Arity=3,
 Str=<L,U(U)><L,1*U(U)><S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2RxD [Occ=Once] :: Int)
                 (w1_s2RxE [Occ=Once] :: Int)
                 (w2_s2RxF [Occ=Once] :: [Int]) ->
                 case GHC.Float.$wroundTo w_s2RxD w1_s2RxE w2_s2RxF of
                 { (# ww1_s2RE3 [Occ=Once], ww2_s2RE4 [Occ=Once] #) ->
                 (ww1_s2RE3, ww2_s2RE4)
                 }}]
roundTo
  = \ (w_s2RxD :: Int) (w1_s2RxE :: Int) (w2_s2RxF :: [Int]) ->
      case GHC.Float.$wroundTo w_s2RxD w1_s2RxE w2_s2RxF of
      { (# ww1_s2RE3, ww2_s2RE4 #) ->
      (ww1_s2RE3, ww2_s2RE4)
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
maxExpt :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
maxExpt = GHC.Types.I# 1100#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
maxExpt10 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
maxExpt10 = GHC.Types.I# 324#

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
gtFloat :: Float -> Float -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JN5 [Occ=Once!] :: Float)
                 (ds1_d2JN6 [Occ=Once!] :: Float) ->
                 case ds_d2JN5 of { F# x_a2I3A [Occ=Once] ->
                 case ds1_d2JN6 of { F# y_a2I3B [Occ=Once] ->
                 tagToEnum# @ Bool (gtFloat# x_a2I3A y_a2I3B)
                 }
                 }}]
gtFloat
  = \ (ds_d2JN5 :: Float) (ds1_d2JN6 :: Float) ->
      case ds_d2JN5 of { F# x_a2I3A ->
      case ds1_d2JN6 of { F# y_a2I3B ->
      tagToEnum# @ Bool (gtFloat# x_a2I3A y_a2I3B)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
geFloat :: Float -> Float -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JMY [Occ=Once!] :: Float)
                 (ds1_d2JMZ [Occ=Once!] :: Float) ->
                 case ds_d2JMY of { F# x_a2I3C [Occ=Once] ->
                 case ds1_d2JMZ of { F# y_a2I3D [Occ=Once] ->
                 tagToEnum# @ Bool (geFloat# x_a2I3C y_a2I3D)
                 }
                 }}]
geFloat
  = \ (ds_d2JMY :: Float) (ds1_d2JMZ :: Float) ->
      case ds_d2JMY of { F# x_a2I3C ->
      case ds1_d2JMZ of { F# y_a2I3D ->
      tagToEnum# @ Bool (geFloat# x_a2I3C y_a2I3D)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
ltFloat :: Float -> Float -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JMR [Occ=Once!] :: Float)
                 (ds1_d2JMS [Occ=Once!] :: Float) ->
                 case ds_d2JMR of { F# x_a2I3E [Occ=Once] ->
                 case ds1_d2JMS of { F# y_a2I3F [Occ=Once] ->
                 tagToEnum# @ Bool (ltFloat# x_a2I3E y_a2I3F)
                 }
                 }}]
ltFloat
  = \ (ds_d2JMR :: Float) (ds1_d2JMS :: Float) ->
      case ds_d2JMR of { F# x_a2I3E ->
      case ds1_d2JMS of { F# y_a2I3F ->
      tagToEnum# @ Bool (ltFloat# x_a2I3E y_a2I3F)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
leFloat :: Float -> Float -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JMK [Occ=Once!] :: Float)
                 (ds1_d2JML [Occ=Once!] :: Float) ->
                 case ds_d2JMK of { F# x_a2I3G [Occ=Once] ->
                 case ds1_d2JML of { F# y_a2I3H [Occ=Once] ->
                 tagToEnum# @ Bool (leFloat# x_a2I3G y_a2I3H)
                 }
                 }}]
leFloat
  = \ (ds_d2JMK :: Float) (ds1_d2JML :: Float) ->
      case ds_d2JMK of { F# x_a2I3G ->
      case ds1_d2JML of { F# y_a2I3H ->
      tagToEnum# @ Bool (leFloat# x_a2I3G y_a2I3H)
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
expFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JMG [Occ=Once!] :: Float) ->
                 case ds_d2JMG of { F# x_a2I3I [Occ=Once] ->
                 GHC.Types.F# (expFloat# x_a2I3I)
                 }}]
expFloat
  = \ (ds_d2JMG :: Float) ->
      case ds_d2JMG of { F# x_a2I3I -> GHC.Types.F# (expFloat# x_a2I3I) }

-- RHS size: {terms: 31, types: 16, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingFloat_$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (a_a2I09 [Occ=Once!] :: Float) ->
                 case a_a2I09 of wild_a2KKM { F# x_a2KKO ->
                 case leFloat# x_a2KKO 18.0# of {
                   __DEFAULT ->
                     case leFloat# x_a2KKO 100.0# of {
                       __DEFAULT -> wild_a2KKM;
                       1# ->
                         GHC.Types.F#
                           (plusFloat# x_a2KKO (expFloat# (negateFloat# x_a2KKO)))
                     };
                   1# ->
                     case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_d2Kuj
                            (expFloat# x_a2KKO) realWorld#
                     of
                     { (# _ [Occ=Dead], ds1_d2Kuh [Occ=Once] #) ->
                     GHC.Types.F# ds1_d2Kuh
                     }
                 }
                 }}]
GHC.Float.$fFloatingFloat_$clog1pexp
  = \ (eta_B1 :: Float) ->
      case eta_B1 of wild_a2KKM { F# x_a2KKO ->
      case leFloat# x_a2KKO 18.0# of {
        __DEFAULT ->
          case leFloat# x_a2KKO 100.0# of {
            __DEFAULT -> wild_a2KKM;
            1# ->
              GHC.Types.F#
                (plusFloat# x_a2KKO (expFloat# (negateFloat# x_a2KKO)))
          };
        1# ->
          case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_d2Kuj
                 (expFloat# x_a2KKO) realWorld#
          of
          { (# ds_d2Kui, ds1_d2Kuh #) ->
          GHC.Types.F# ds1_d2Kuh
          }
      }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
logFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JMC [Occ=Once!] :: Float) ->
                 case ds_d2JMC of { F# x_a2I3J [Occ=Once] ->
                 case logFloat# x_a2I3J of wild1_XP { __DEFAULT ->
                 GHC.Types.F# wild1_XP
                 }
                 }}]
logFloat
  = \ (ds_d2JMC :: Float) ->
      case ds_d2JMC of { F# x_a2I3J ->
      case logFloat# x_a2I3J of wild1_XP { __DEFAULT ->
      GHC.Types.F# wild1_XP
      }
      }

-- RHS size: {terms: 23, types: 9, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingFloat_$clogBase :: Float -> Float -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2I03 [Occ=Once!] :: Float)
                 (y_a2I04 [Occ=Once!] :: Float) ->
                 case y_a2I04 of { F# x1_a2I3J [Occ=Once] ->
                 case logFloat# x1_a2I3J of wild1_XP { __DEFAULT ->
                 case x_a2I03 of { F# x2_X2Im4 [Occ=Once] ->
                 case logFloat# x2_X2Im4 of wild3_Xjd { __DEFAULT ->
                 case divideFloat# wild1_XP wild3_Xjd of wild4_XH { __DEFAULT ->
                 GHC.Types.F# wild4_XH
                 }
                 }
                 }
                 }
                 }}]
GHC.Float.$fFloatingFloat_$clogBase
  = \ (x_a2I03 :: Float) (y_a2I04 :: Float) ->
      case y_a2I04 of { F# x1_a2I3J ->
      case logFloat# x1_a2I3J of wild1_XP { __DEFAULT ->
      case x_a2I03 of { F# x2_X2Im4 ->
      case logFloat# x2_X2Im4 of wild3_Xjd { __DEFAULT ->
      case divideFloat# wild1_XP wild3_Xjd of wild4_XH { __DEFAULT ->
      GHC.Types.F# wild4_XH
      }
      }
      }
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
sqrtFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JMy [Occ=Once!] :: Float) ->
                 case ds_d2JMy of { F# x_a2I3K [Occ=Once] ->
                 GHC.Types.F# (sqrtFloat# x_a2I3K)
                 }}]
sqrtFloat
  = \ (ds_d2JMy :: Float) ->
      case ds_d2JMy of { F# x_a2I3K ->
      GHC.Types.F# (sqrtFloat# x_a2I3K)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
sinFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JMq [Occ=Once!] :: Float) ->
                 case ds_d2JMq of { F# x_a2I3M [Occ=Once] ->
                 GHC.Types.F# (sinFloat# x_a2I3M)
                 }}]
sinFloat
  = \ (ds_d2JMq :: Float) ->
      case ds_d2JMq of { F# x_a2I3M -> GHC.Types.F# (sinFloat# x_a2I3M) }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
cosFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JMm [Occ=Once!] :: Float) ->
                 case ds_d2JMm of { F# x_a2I3N [Occ=Once] ->
                 GHC.Types.F# (cosFloat# x_a2I3N)
                 }}]
cosFloat
  = \ (ds_d2JMm :: Float) ->
      case ds_d2JMm of { F# x_a2I3N -> GHC.Types.F# (cosFloat# x_a2I3N) }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
tanFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JMi [Occ=Once!] :: Float) ->
                 case ds_d2JMi of { F# x_a2I3O [Occ=Once] ->
                 GHC.Types.F# (tanFloat# x_a2I3O)
                 }}]
tanFloat
  = \ (ds_d2JMi :: Float) ->
      case ds_d2JMi of { F# x_a2I3O -> GHC.Types.F# (tanFloat# x_a2I3O) }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
asinFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JMe [Occ=Once!] :: Float) ->
                 case ds_d2JMe of { F# x_a2I3P [Occ=Once] ->
                 case asinFloat# x_a2I3P of wild1_X12 { __DEFAULT ->
                 GHC.Types.F# wild1_X12
                 }
                 }}]
asinFloat
  = \ (ds_d2JMe :: Float) ->
      case ds_d2JMe of { F# x_a2I3P ->
      case asinFloat# x_a2I3P of wild1_X12 { __DEFAULT ->
      GHC.Types.F# wild1_X12
      }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
acosFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JMa [Occ=Once!] :: Float) ->
                 case ds_d2JMa of { F# x_a2I3Q [Occ=Once] ->
                 case acosFloat# x_a2I3Q of wild1_X14 { __DEFAULT ->
                 GHC.Types.F# wild1_X14
                 }
                 }}]
acosFloat
  = \ (ds_d2JMa :: Float) ->
      case ds_d2JMa of { F# x_a2I3Q ->
      case acosFloat# x_a2I3Q of wild1_X14 { __DEFAULT ->
      GHC.Types.F# wild1_X14
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
atanFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JM6 [Occ=Once!] :: Float) ->
                 case ds_d2JM6 of { F# x_a2I3R [Occ=Once] ->
                 GHC.Types.F# (atanFloat# x_a2I3R)
                 }}]
atanFloat
  = \ (ds_d2JM6 :: Float) ->
      case ds_d2JM6 of { F# x_a2I3R ->
      GHC.Types.F# (atanFloat# x_a2I3R)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
sinhFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JM2 [Occ=Once!] :: Float) ->
                 case ds_d2JM2 of { F# x_a2I3S [Occ=Once] ->
                 GHC.Types.F# (sinhFloat# x_a2I3S)
                 }}]
sinhFloat
  = \ (ds_d2JM2 :: Float) ->
      case ds_d2JM2 of { F# x_a2I3S ->
      GHC.Types.F# (sinhFloat# x_a2I3S)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
coshFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JLY [Occ=Once!] :: Float) ->
                 case ds_d2JLY of { F# x_a2I3T [Occ=Once] ->
                 GHC.Types.F# (coshFloat# x_a2I3T)
                 }}]
coshFloat
  = \ (ds_d2JLY :: Float) ->
      case ds_d2JLY of { F# x_a2I3T ->
      GHC.Types.F# (coshFloat# x_a2I3T)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
tanhFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JLU [Occ=Once!] :: Float) ->
                 case ds_d2JLU of { F# x_a2I3U [Occ=Once] ->
                 GHC.Types.F# (tanhFloat# x_a2I3U)
                 }}]
tanhFloat
  = \ (ds_d2JLU :: Float) ->
      case ds_d2JLU of { F# x_a2I3U ->
      GHC.Types.F# (tanhFloat# x_a2I3U)
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
powerFloat :: Float -> Float -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JLN [Occ=Once!] :: Float)
                 (ds1_d2JLO [Occ=Once!] :: Float) ->
                 case ds_d2JLN of { F# x_a2I3V [Occ=Once] ->
                 case ds1_d2JLO of { F# y_a2I3W [Occ=Once] ->
                 GHC.Types.F# (powerFloat# x_a2I3V y_a2I3W)
                 }
                 }}]
powerFloat
  = \ (ds_d2JLN :: Float) (ds1_d2JLO :: Float) ->
      case ds_d2JLN of { F# x_a2I3V ->
      case ds1_d2JLO of { F# y_a2I3W ->
      GHC.Types.F# (powerFloat# x_a2I3V y_a2I3W)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
gtDouble :: Double -> Double -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JLa [Occ=Once!] :: Double)
                 (ds1_d2JLb [Occ=Once!] :: Double) ->
                 case ds_d2JLa of { D# x_a2I46 [Occ=Once] ->
                 case ds1_d2JLb of { D# y_a2I47 [Occ=Once] ->
                 tagToEnum# @ Bool (>## x_a2I46 y_a2I47)
                 }
                 }}]
gtDouble
  = \ (ds_d2JLa :: Double) (ds1_d2JLb :: Double) ->
      case ds_d2JLa of { D# x_a2I46 ->
      case ds1_d2JLb of { D# y_a2I47 ->
      tagToEnum# @ Bool (>## x_a2I46 y_a2I47)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
geDouble :: Double -> Double -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JL3 [Occ=Once!] :: Double)
                 (ds1_d2JL4 [Occ=Once!] :: Double) ->
                 case ds_d2JL3 of { D# x_a2I48 [Occ=Once] ->
                 case ds1_d2JL4 of { D# y_a2I49 [Occ=Once] ->
                 tagToEnum# @ Bool (>=## x_a2I48 y_a2I49)
                 }
                 }}]
geDouble
  = \ (ds_d2JL3 :: Double) (ds1_d2JL4 :: Double) ->
      case ds_d2JL3 of { D# x_a2I48 ->
      case ds1_d2JL4 of { D# y_a2I49 ->
      tagToEnum# @ Bool (>=## x_a2I48 y_a2I49)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
ltDouble :: Double -> Double -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JKW [Occ=Once!] :: Double)
                 (ds1_d2JKX [Occ=Once!] :: Double) ->
                 case ds_d2JKW of { D# x_a2I4a [Occ=Once] ->
                 case ds1_d2JKX of { D# y_a2I4b [Occ=Once] ->
                 tagToEnum# @ Bool (<## x_a2I4a y_a2I4b)
                 }
                 }}]
ltDouble
  = \ (ds_d2JKW :: Double) (ds1_d2JKX :: Double) ->
      case ds_d2JKW of { D# x_a2I4a ->
      case ds1_d2JKX of { D# y_a2I4b ->
      tagToEnum# @ Bool (<## x_a2I4a y_a2I4b)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
leDouble :: Double -> Double -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JKP [Occ=Once!] :: Double)
                 (ds1_d2JKQ [Occ=Once!] :: Double) ->
                 case ds_d2JKP of { D# x_a2I4c [Occ=Once] ->
                 case ds1_d2JKQ of { D# y_a2I4d [Occ=Once] ->
                 tagToEnum# @ Bool (<=## x_a2I4c y_a2I4d)
                 }
                 }}]
leDouble
  = \ (ds_d2JKP :: Double) (ds1_d2JKQ :: Double) ->
      case ds_d2JKP of { D# x_a2I4c ->
      case ds1_d2JKQ of { D# y_a2I4d ->
      tagToEnum# @ Bool (<=## x_a2I4c y_a2I4d)
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
double2Float :: Double -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JKL [Occ=Once!] :: Double) ->
                 case ds_d2JKL of { D# x_a2I4e [Occ=Once] ->
                 GHC.Types.F# (double2Float# x_a2I4e)
                 }}]
double2Float
  = \ (ds_d2JKL :: Double) ->
      case ds_d2JKL of { D# x_a2I4e ->
      GHC.Types.F# (double2Float# x_a2I4e)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
float2Double :: Float -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JKH [Occ=Once!] :: Float) ->
                 case ds_d2JKH of { F# x_a2I4f [Occ=Once] ->
                 GHC.Types.D# (float2Double# x_a2I4f)
                 }}]
float2Double
  = \ (ds_d2JKH :: Float) ->
      case ds_d2JKH of { F# x_a2I4f ->
      GHC.Types.D# (float2Double# x_a2I4f)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
expDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JKD [Occ=Once!] :: Double) ->
                 case ds_d2JKD of { D# x_a2I4g [Occ=Once] ->
                 GHC.Types.D# (expDouble# x_a2I4g)
                 }}]
expDouble
  = \ (ds_d2JKD :: Double) ->
      case ds_d2JKD of { D# x_a2I4g ->
      GHC.Types.D# (expDouble# x_a2I4g)
      }

-- RHS size: {terms: 31, types: 16, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingDouble_$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (a_a2HZ8 [Occ=Once!] :: Double) ->
                 case a_a2HZ8 of wild_a2KK2 { D# x_a2KK4 ->
                 case <=## x_a2KK4 18.0## of {
                   __DEFAULT ->
                     case <=## x_a2KK4 100.0## of {
                       __DEFAULT -> wild_a2KK2;
                       1# ->
                         GHC.Types.D# (+## x_a2KK4 (expDouble# (negateDouble# x_a2KK4)))
                     };
                   1# ->
                     case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_d2Kux
                            (expDouble# x_a2KK4) realWorld#
                     of
                     { (# _ [Occ=Dead], ds1_d2Kuv [Occ=Once] #) ->
                     GHC.Types.D# ds1_d2Kuv
                     }
                 }
                 }}]
GHC.Float.$fFloatingDouble_$clog1pexp
  = \ (eta_B1 :: Double) ->
      case eta_B1 of wild_a2KK2 { D# x_a2KK4 ->
      case <=## x_a2KK4 18.0## of {
        __DEFAULT ->
          case <=## x_a2KK4 100.0## of {
            __DEFAULT -> wild_a2KK2;
            1# ->
              GHC.Types.D# (+## x_a2KK4 (expDouble# (negateDouble# x_a2KK4)))
          };
        1# ->
          case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_d2Kux
                 (expDouble# x_a2KK4) realWorld#
          of
          { (# ds_d2Kuw, ds1_d2Kuv #) ->
          GHC.Types.D# ds1_d2Kuv
          }
      }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
logDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JKz [Occ=Once!] :: Double) ->
                 case ds_d2JKz of { D# x_a2I4h [Occ=Once] ->
                 case logDouble# x_a2I4h of wild1_X1z { __DEFAULT ->
                 GHC.Types.D# wild1_X1z
                 }
                 }}]
logDouble
  = \ (ds_d2JKz :: Double) ->
      case ds_d2JKz of { D# x_a2I4h ->
      case logDouble# x_a2I4h of wild1_X1z { __DEFAULT ->
      GHC.Types.D# wild1_X1z
      }
      }

-- RHS size: {terms: 23, types: 9, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingDouble_$clogBase :: Double -> Double -> Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HZ2 [Occ=Once!] :: Double)
                 (y_a2HZ3 [Occ=Once!] :: Double) ->
                 case y_a2HZ3 of { D# x1_a2I4h [Occ=Once] ->
                 case logDouble# x1_a2I4h of wild1_X1z { __DEFAULT ->
                 case x_a2HZ2 of { D# x2_X2ImX [Occ=Once] ->
                 case logDouble# x2_X2ImX of wild3_Xki { __DEFAULT ->
                 case /## wild1_X1z wild3_Xki of wild4_X1p { __DEFAULT ->
                 GHC.Types.D# wild4_X1p
                 }
                 }
                 }
                 }
                 }}]
GHC.Float.$fFloatingDouble_$clogBase
  = \ (x_a2HZ2 :: Double) (y_a2HZ3 :: Double) ->
      case y_a2HZ3 of { D# x1_a2I4h ->
      case logDouble# x1_a2I4h of wild1_X1z { __DEFAULT ->
      case x_a2HZ2 of { D# x2_X2ImX ->
      case logDouble# x2_X2ImX of wild3_Xki { __DEFAULT ->
      case /## wild1_X1z wild3_Xki of wild4_X1p { __DEFAULT ->
      GHC.Types.D# wild4_X1p
      }
      }
      }
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
sqrtDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JKv [Occ=Once!] :: Double) ->
                 case ds_d2JKv of { D# x_a2I4i [Occ=Once] ->
                 GHC.Types.D# (sqrtDouble# x_a2I4i)
                 }}]
sqrtDouble
  = \ (ds_d2JKv :: Double) ->
      case ds_d2JKv of { D# x_a2I4i ->
      GHC.Types.D# (sqrtDouble# x_a2I4i)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
sinDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JKn [Occ=Once!] :: Double) ->
                 case ds_d2JKn of { D# x_a2I4k [Occ=Once] ->
                 GHC.Types.D# (sinDouble# x_a2I4k)
                 }}]
sinDouble
  = \ (ds_d2JKn :: Double) ->
      case ds_d2JKn of { D# x_a2I4k ->
      GHC.Types.D# (sinDouble# x_a2I4k)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
cosDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JKj [Occ=Once!] :: Double) ->
                 case ds_d2JKj of { D# x_a2I4l [Occ=Once] ->
                 GHC.Types.D# (cosDouble# x_a2I4l)
                 }}]
cosDouble
  = \ (ds_d2JKj :: Double) ->
      case ds_d2JKj of { D# x_a2I4l ->
      GHC.Types.D# (cosDouble# x_a2I4l)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
tanDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JKf [Occ=Once!] :: Double) ->
                 case ds_d2JKf of { D# x_a2I4m [Occ=Once] ->
                 GHC.Types.D# (tanDouble# x_a2I4m)
                 }}]
tanDouble
  = \ (ds_d2JKf :: Double) ->
      case ds_d2JKf of { D# x_a2I4m ->
      GHC.Types.D# (tanDouble# x_a2I4m)
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
asinDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JKb [Occ=Once!] :: Double) ->
                 case ds_d2JKb of { D# x_a2I4n [Occ=Once] ->
                 case asinDouble# x_a2I4n of wild1_X1M { __DEFAULT ->
                 GHC.Types.D# wild1_X1M
                 }
                 }}]
asinDouble
  = \ (ds_d2JKb :: Double) ->
      case ds_d2JKb of { D# x_a2I4n ->
      case asinDouble# x_a2I4n of wild1_X1M { __DEFAULT ->
      GHC.Types.D# wild1_X1M
      }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
acosDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JK7 [Occ=Once!] :: Double) ->
                 case ds_d2JK7 of { D# x_a2I4o [Occ=Once] ->
                 case acosDouble# x_a2I4o of wild1_X1O { __DEFAULT ->
                 GHC.Types.D# wild1_X1O
                 }
                 }}]
acosDouble
  = \ (ds_d2JK7 :: Double) ->
      case ds_d2JK7 of { D# x_a2I4o ->
      case acosDouble# x_a2I4o of wild1_X1O { __DEFAULT ->
      GHC.Types.D# wild1_X1O
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
atanDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JK3 [Occ=Once!] :: Double) ->
                 case ds_d2JK3 of { D# x_a2I4p [Occ=Once] ->
                 GHC.Types.D# (atanDouble# x_a2I4p)
                 }}]
atanDouble
  = \ (ds_d2JK3 :: Double) ->
      case ds_d2JK3 of { D# x_a2I4p ->
      GHC.Types.D# (atanDouble# x_a2I4p)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
sinhDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JJZ [Occ=Once!] :: Double) ->
                 case ds_d2JJZ of { D# x_a2I4q [Occ=Once] ->
                 GHC.Types.D# (sinhDouble# x_a2I4q)
                 }}]
sinhDouble
  = \ (ds_d2JJZ :: Double) ->
      case ds_d2JJZ of { D# x_a2I4q ->
      GHC.Types.D# (sinhDouble# x_a2I4q)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
coshDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JJV [Occ=Once!] :: Double) ->
                 case ds_d2JJV of { D# x_a2I4r [Occ=Once] ->
                 GHC.Types.D# (coshDouble# x_a2I4r)
                 }}]
coshDouble
  = \ (ds_d2JJV :: Double) ->
      case ds_d2JJV of { D# x_a2I4r ->
      GHC.Types.D# (coshDouble# x_a2I4r)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
tanhDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JJR [Occ=Once!] :: Double) ->
                 case ds_d2JJR of { D# x_a2I4s [Occ=Once] ->
                 GHC.Types.D# (tanhDouble# x_a2I4s)
                 }}]
tanhDouble
  = \ (ds_d2JJR :: Double) ->
      case ds_d2JJR of { D# x_a2I4s ->
      GHC.Types.D# (tanhDouble# x_a2I4s)
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
powerDouble :: Double -> Double -> Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JJK [Occ=Once!] :: Double)
                 (ds1_d2JJL [Occ=Once!] :: Double) ->
                 case ds_d2JJK of { D# x_a2I4t [Occ=Once] ->
                 case ds1_d2JJL of { D# y_a2I4u [Occ=Once] ->
                 GHC.Types.D# (**## x_a2I4t y_a2I4u)
                 }
                 }}]
powerDouble
  = \ (ds_d2JJK :: Double) (ds1_d2JJL :: Double) ->
      case ds_d2JJK of { D# x_a2I4t ->
      case ds1_d2JJL of { D# y_a2I4u ->
      GHC.Types.D# (**## x_a2I4t y_a2I4u)
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
word2Double :: Word -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JJG [Occ=Once!] :: Word) ->
                 case ds_d2JJG of { W# w_a2I4v [Occ=Once] ->
                 GHC.Types.D# (word2Double# w_a2I4v)
                 }}]
word2Double
  = \ (ds_d2JJG :: Word) ->
      case ds_d2JJG of { W# w_a2I4v ->
      GHC.Types.D# (word2Double# w_a2I4v)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
word2Float :: Word -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2JJC [Occ=Once!] :: Word) ->
                 case ds_d2JJC of { W# w_a2I4w [Occ=Once] ->
                 GHC.Types.F# (word2Float# w_a2I4w)
                 }}]
word2Float
  = \ (ds_d2JJC :: Word) ->
      case ds_d2JJC of { W# w_a2I4w ->
      GHC.Types.F# (word2Float# w_a2I4w)
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Float.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$trModule3 = GHC.Types.TrNameS GHC.Float.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Float.$trModule2 = "GHC.Float"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$trModule1 = GHC.Types.TrNameS GHC.Float.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Float.$trModule
  = GHC.Types.Module GHC.Float.$trModule3 GHC.Float.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_r2UpC :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_r2UpC
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcBool (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_r2UpD :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_r2UpD
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcInt (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep2_r2UpE :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep2_r2UpE
  = GHC.Types.KindRepTyConApp
      integer-simple-0.1.1.1:GHC.Integer.Type.$tcInteger
      (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep3_r2UpF :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep3_r2UpF
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep4_r2UpG :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep4_r2UpG
  = GHC.Types.: @ KindRep $krep1_r2UpD (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep5_r2UpH :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep5_r2UpH = GHC.Types.: @ KindRep $krep2_r2UpE $krep4_r2UpG

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6_r2UpI :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep6_r2UpI
  = GHC.Types.KindRepTyConApp GHC.Tuple.$tc(,) $krep5_r2UpH

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep7_r2UpJ :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep7_r2UpJ = GHC.Types.: @ KindRep $krep1_r2UpD $krep4_r2UpG

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8_r2UpK :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep8_r2UpK
  = GHC.Types.KindRepTyConApp GHC.Tuple.$tc(,) $krep7_r2UpJ

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tcFloating1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Float.$tcFloating1
  = GHC.Types.KindRepFun GHC.Types.krep$* $krep3_r2UpF

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep9_r2UpL :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep9_r2UpL = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10_r2UpM :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep10_r2UpM = GHC.Types.KindRepFun $krep9_r2UpL $krep9_r2UpL

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep11_r2UpN :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep11_r2UpN = GHC.Types.KindRepFun $krep1_r2UpD $krep10_r2UpM

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep12_r2UpO :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep12_r2UpO = GHC.Types.KindRepFun $krep9_r2UpL $krep10_r2UpM

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep13_r2UpP :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep13_r2UpP = GHC.Types.KindRepFun $krep9_r2UpL $krep8_r2UpK

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep14_r2UpQ :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep14_r2UpQ = GHC.Types.KindRepFun $krep9_r2UpL $krep6_r2UpI

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep15_r2UpR :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep15_r2UpR = GHC.Types.KindRepFun $krep9_r2UpL $krep2_r2UpE

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep16_r2UpS :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep16_r2UpS = GHC.Types.KindRepFun $krep9_r2UpL $krep1_r2UpD

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep17_r2UpT :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep17_r2UpT = GHC.Types.KindRepFun $krep9_r2UpL $krep_r2UpC

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep18_r2UpU :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep18_r2UpU = GHC.Types.KindRepFun $krep1_r2UpD $krep9_r2UpL

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep19_r2UpV :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep19_r2UpV = GHC.Types.KindRepFun $krep2_r2UpE $krep18_r2UpU

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep20_r2UpW :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep20_r2UpW
  = GHC.Types.: @ KindRep $krep9_r2UpL (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep21_r2UpX :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep21_r2UpX
  = GHC.Types.KindRepTyConApp GHC.Real.$tcRealFrac $krep20_r2UpW

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep22_r2UpY :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep22_r2UpY
  = GHC.Types.KindRepTyConApp GHC.Real.$tcFractional $krep20_r2UpW

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tcFloating3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Float.$tcFloating3 = "Floating"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tcFloating2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$tcFloating2 = GHC.Types.TrNameS GHC.Float.$tcFloating3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tcFloating :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Float.$tcFloating
  = GHC.Types.TyCon
      7129224378091624681##
      15164683064282921132##
      GHC.Float.$trModule
      GHC.Float.$tcFloating2
      0#
      GHC.Float.$tcFloating1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep23_r2UpZ :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep23_r2UpZ
  = GHC.Types.KindRepTyConApp GHC.Float.$tcFloating $krep20_r2UpW

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep24_r2Uq0 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep24_r2Uq0 = GHC.Types.KindRepFun $krep10_r2UpM $krep23_r2UpZ

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep25_r2Uq1 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep25_r2Uq1 = GHC.Types.KindRepFun $krep10_r2UpM $krep24_r2Uq0

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep26_r2Uq2 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep26_r2Uq2 = GHC.Types.KindRepFun $krep10_r2UpM $krep25_r2Uq1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep27_r2Uq3 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep27_r2Uq3 = GHC.Types.KindRepFun $krep10_r2UpM $krep26_r2Uq2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep28_r2Uq4 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep28_r2Uq4 = GHC.Types.KindRepFun $krep10_r2UpM $krep27_r2Uq3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep29_r2Uq5 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep29_r2Uq5 = GHC.Types.KindRepFun $krep10_r2UpM $krep28_r2Uq4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep30_r2Uq6 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep30_r2Uq6 = GHC.Types.KindRepFun $krep10_r2UpM $krep29_r2Uq5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep31_r2Uq7 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep31_r2Uq7 = GHC.Types.KindRepFun $krep10_r2UpM $krep30_r2Uq6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep32_r2Uq8 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep32_r2Uq8 = GHC.Types.KindRepFun $krep10_r2UpM $krep31_r2Uq7

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep33_r2Uq9 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep33_r2Uq9 = GHC.Types.KindRepFun $krep10_r2UpM $krep32_r2Uq8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep34_r2Uqa :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep34_r2Uqa = GHC.Types.KindRepFun $krep10_r2UpM $krep33_r2Uq9

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep35_r2Uqb :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep35_r2Uqb = GHC.Types.KindRepFun $krep10_r2UpM $krep34_r2Uqa

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep36_r2Uqc :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep36_r2Uqc = GHC.Types.KindRepFun $krep10_r2UpM $krep35_r2Uqb

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep37_r2Uqd :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep37_r2Uqd = GHC.Types.KindRepFun $krep10_r2UpM $krep36_r2Uqc

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep38_r2Uqe :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep38_r2Uqe = GHC.Types.KindRepFun $krep10_r2UpM $krep37_r2Uqd

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep39_r2Uqf :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep39_r2Uqf = GHC.Types.KindRepFun $krep10_r2UpM $krep38_r2Uqe

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep40_r2Uqg :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep40_r2Uqg = GHC.Types.KindRepFun $krep12_r2UpO $krep39_r2Uqf

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep41_r2Uqh :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep41_r2Uqh = GHC.Types.KindRepFun $krep12_r2UpO $krep40_r2Uqg

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep42_r2Uqi :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep42_r2Uqi = GHC.Types.KindRepFun $krep10_r2UpM $krep41_r2Uqh

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep43_r2Uqj :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep43_r2Uqj = GHC.Types.KindRepFun $krep10_r2UpM $krep42_r2Uqi

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep44_r2Uqk :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep44_r2Uqk = GHC.Types.KindRepFun $krep10_r2UpM $krep43_r2Uqj

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep45_r2Uql :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep45_r2Uql = GHC.Types.KindRepFun $krep9_r2UpL $krep44_r2Uqk

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'C:Floating1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Float.$tc'C:Floating1
  = GHC.Types.KindRepFun $krep22_r2UpY $krep45_r2Uql

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'C:Floating3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Float.$tc'C:Floating3 = "'C:Floating"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'C:Floating2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$tc'C:Floating2
  = GHC.Types.TrNameS GHC.Float.$tc'C:Floating3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'C:Floating :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Float.$tc'C:Floating
  = GHC.Types.TyCon
      13412984222799990155##
      5552297363459117532##
      GHC.Float.$trModule
      GHC.Float.$tc'C:Floating2
      1#
      GHC.Float.$tc'C:Floating1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tcRealFloat2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Float.$tcRealFloat2 = "RealFloat"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tcRealFloat1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$tcRealFloat1 = GHC.Types.TrNameS GHC.Float.$tcRealFloat2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tcRealFloat :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Float.$tcRealFloat
  = GHC.Types.TyCon
      3941731172860576649##
      6292609957384615911##
      GHC.Float.$trModule
      GHC.Float.$tcRealFloat1
      0#
      GHC.Float.$tcFloating1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep46_r2Uqm :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep46_r2Uqm
  = GHC.Types.KindRepTyConApp GHC.Float.$tcRealFloat $krep20_r2UpW

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep47_r2Uqn :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep47_r2Uqn = GHC.Types.KindRepFun $krep12_r2UpO $krep46_r2Uqm

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep48_r2Uqo :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep48_r2Uqo = GHC.Types.KindRepFun $krep17_r2UpT $krep47_r2Uqn

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep49_r2Uqp :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep49_r2Uqp = GHC.Types.KindRepFun $krep17_r2UpT $krep48_r2Uqo

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep50_r2Uqq :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep50_r2Uqq = GHC.Types.KindRepFun $krep17_r2UpT $krep49_r2Uqp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep51_r2Uqr :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep51_r2Uqr = GHC.Types.KindRepFun $krep17_r2UpT $krep50_r2Uqq

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep52_r2Uqs :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep52_r2Uqs = GHC.Types.KindRepFun $krep17_r2UpT $krep51_r2Uqr

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep53_r2Uqt :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep53_r2Uqt = GHC.Types.KindRepFun $krep11_r2UpN $krep52_r2Uqs

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep54_r2Uqu :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep54_r2Uqu = GHC.Types.KindRepFun $krep10_r2UpM $krep53_r2Uqt

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep55_r2Uqv :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep55_r2Uqv = GHC.Types.KindRepFun $krep16_r2UpS $krep54_r2Uqu

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep56_r2Uqw :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep56_r2Uqw = GHC.Types.KindRepFun $krep19_r2UpV $krep55_r2Uqv

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep57_r2Uqx :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep57_r2Uqx = GHC.Types.KindRepFun $krep14_r2UpQ $krep56_r2Uqw

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep58_r2Uqy :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep58_r2Uqy = GHC.Types.KindRepFun $krep13_r2UpP $krep57_r2Uqx

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep59_r2Uqz :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep59_r2Uqz = GHC.Types.KindRepFun $krep16_r2UpS $krep58_r2Uqy

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep60_r2UqA :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep60_r2UqA = GHC.Types.KindRepFun $krep15_r2UpR $krep59_r2Uqz

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep61_r2UqB :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep61_r2UqB = GHC.Types.KindRepFun $krep23_r2UpZ $krep60_r2UqA

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'C:RealFloat1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Float.$tc'C:RealFloat1
  = GHC.Types.KindRepFun $krep21_r2UpX $krep61_r2UqB

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'C:RealFloat3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Float.$tc'C:RealFloat3 = "'C:RealFloat"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'C:RealFloat2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$tc'C:RealFloat2
  = GHC.Types.TrNameS GHC.Float.$tc'C:RealFloat3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'C:RealFloat :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Float.$tc'C:RealFloat
  = GHC.Types.TyCon
      9049810847819341732##
      10151061231612833747##
      GHC.Float.$trModule
      GHC.Float.$tc'C:RealFloat2
      1#
      GHC.Float.$tc'C:RealFloat1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tcFFFormat2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Float.$tcFFFormat2 = "FFFormat"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tcFFFormat1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$tcFFFormat1 = GHC.Types.TrNameS GHC.Float.$tcFFFormat2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tcFFFormat :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Float.$tcFFFormat
  = GHC.Types.TyCon
      1010825520712496676##
      1474964314088479952##
      GHC.Float.$trModule
      GHC.Float.$tcFFFormat1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$tc'FFExponent1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
GHC.Float.$tc'FFExponent1
  = GHC.Types.KindRepTyConApp
      GHC.Float.$tcFFFormat (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'FFExponent3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Float.$tc'FFExponent3 = "'FFExponent"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'FFExponent2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$tc'FFExponent2
  = GHC.Types.TrNameS GHC.Float.$tc'FFExponent3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'FFExponent :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Float.$tc'FFExponent
  = GHC.Types.TyCon
      5889061327753760791##
      13581434975010194000##
      GHC.Float.$trModule
      GHC.Float.$tc'FFExponent2
      0#
      GHC.Float.$tc'FFExponent1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'FFFixed2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Float.$tc'FFFixed2 = "'FFFixed"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'FFFixed1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$tc'FFFixed1 = GHC.Types.TrNameS GHC.Float.$tc'FFFixed2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'FFFixed :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Float.$tc'FFFixed
  = GHC.Types.TyCon
      16973630707960676089##
      5471565003344425987##
      GHC.Float.$trModule
      GHC.Float.$tc'FFFixed1
      0#
      GHC.Float.$tc'FFExponent1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'FFGeneric2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Float.$tc'FFGeneric2 = "'FFGeneric"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'FFGeneric1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$tc'FFGeneric1
  = GHC.Types.TrNameS GHC.Float.$tc'FFGeneric2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$tc'FFGeneric :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Float.$tc'FFGeneric
  = GHC.Types.TyCon
      15786283387055545560##
      10263264619717801633##
      GHC.Float.$trModule
      GHC.Float.$tc'FFGeneric1
      0#
      GHC.Float.$tc'FFExponent1

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
isFloatNaN :: Float -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2KvA [Occ=Once!] :: Float) ->
                 case ds_d2KvA of { F# ds2_d2KvC [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KvF
                        ds2_d2KvC realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2KvD [Occ=Once] #) ->
                 GHC.Types.I# ds4_d2KvD
                 }
                 }}]
isFloatNaN
  = \ (ds_d2KvA :: Float) ->
      case ds_d2KvA of { F# ds2_d2KvC ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KvF
             ds2_d2KvC realWorld#
      of
      { (# ds3_d2KvE, ds4_d2KvD #) ->
      GHC.Types.I# ds4_d2KvD
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
isFloatInfinite :: Float -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2Kvt [Occ=Once!] :: Float) ->
                 case ds_d2Kvt of { F# ds2_d2Kvv [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvy
                        ds2_d2Kvv realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2Kvw [Occ=Once] #) ->
                 GHC.Types.I# ds4_d2Kvw
                 }
                 }}]
isFloatInfinite
  = \ (ds_d2Kvt :: Float) ->
      case ds_d2Kvt of { F# ds2_d2Kvv ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvy
             ds2_d2Kvv realWorld#
      of
      { (# ds3_d2Kvx, ds4_d2Kvw #) ->
      GHC.Types.I# ds4_d2Kvw
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
isFloatDenormalized :: Float -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2Kvm [Occ=Once!] :: Float) ->
                 case ds_d2Kvm of { F# ds2_d2Kvo [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvr
                        ds2_d2Kvo realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2Kvp [Occ=Once] #) ->
                 GHC.Types.I# ds4_d2Kvp
                 }
                 }}]
isFloatDenormalized
  = \ (ds_d2Kvm :: Float) ->
      case ds_d2Kvm of { F# ds2_d2Kvo ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvr
             ds2_d2Kvo realWorld#
      of
      { (# ds3_d2Kvq, ds4_d2Kvp #) ->
      GHC.Types.I# ds4_d2Kvp
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
isFloatNegativeZero :: Float -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2Kvf [Occ=Once!] :: Float) ->
                 case ds_d2Kvf of { F# ds2_d2Kvh [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvk
                        ds2_d2Kvh realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2Kvi [Occ=Once] #) ->
                 GHC.Types.I# ds4_d2Kvi
                 }
                 }}]
isFloatNegativeZero
  = \ (ds_d2Kvf :: Float) ->
      case ds_d2Kvf of { F# ds2_d2Kvh ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvk
             ds2_d2Kvh realWorld#
      of
      { (# ds3_d2Kvj, ds4_d2Kvi #) ->
      GHC.Types.I# ds4_d2Kvi
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
isFloatFinite :: Float -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2Kv8 [Occ=Once!] :: Float) ->
                 case ds_d2Kv8 of { F# ds2_d2Kva [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvd
                        ds2_d2Kva realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2Kvb [Occ=Once] #) ->
                 GHC.Types.I# ds4_d2Kvb
                 }
                 }}]
isFloatFinite
  = \ (ds_d2Kv8 :: Float) ->
      case ds_d2Kv8 of { F# ds2_d2Kva ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvd
             ds2_d2Kva realWorld#
      of
      { (# ds3_d2Kvc, ds4_d2Kvb #) ->
      GHC.Types.I# ds4_d2Kvb
      }
      }

-- RHS size: {terms: 58, types: 28, coercions: 0, joins: 1/1}
GHC.Float.$w$cscaleFloat1 [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Float# -> Float#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 245 0}]
GHC.Float.$w$cscaleFloat1
  = \ (ww_s2RxR :: Int#) (ww1_s2RxV :: Float#) ->
      case ww_s2RxR of ds_X2KsR {
        __DEFAULT ->
          case eqFloat# ww1_s2RxV 0.0# of {
            __DEFAULT ->
              case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvd
                     ww1_s2RxV realWorld#
              of
              { (# ds1_d2Kvc, ds2_d2Kvb #) ->
              case ds2_d2Kvb of {
                __DEFAULT ->
                  case decodeFloat_Int# ww1_s2RxV of { (# ipv_s2KAQ, ipv1_s2KAR #) ->
                  join {
                    $w$j2_s2RxM [InlPrag=NOUSERINLINE[0], Dmd=<C(S),1*C1(U)>]
                      :: Int# -> Float#
                    [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                    $w$j2_s2RxM (w_s2RxK [OS=OneShot] :: Int#)
                      = case <=# -349# w_s2RxK of {
                          __DEFAULT ->
                            encodeFloatInteger (smallInteger ipv_s2KAQ) (+# ipv1_s2KAR -349#);
                          1# ->
                            encodeFloatInteger (smallInteger ipv_s2KAQ) (+# ipv1_s2KAR w_s2RxK)
                        } } in
                  case <=# 349# ds_X2KsR of {
                    __DEFAULT -> jump $w$j2_s2RxM ds_X2KsR;
                    1# -> jump $w$j2_s2RxM 349#
                  }
                  };
                0# -> ww1_s2RxV
              }
              };
            1# -> ww1_s2RxV
          };
        0# -> ww1_s2RxV
      }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$cscaleFloat [InlPrag=NOUSERINLINE[0]]
  :: Int -> Float -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2RxN [Occ=Once!] :: Int)
                 (w1_s2RxO [Occ=Once!] :: Float) ->
                 case w_s2RxN of { I# ww1_s2RxR [Occ=Once] ->
                 case w1_s2RxO of { F# ww3_s2RxV [Occ=Once] ->
                 case GHC.Float.$w$cscaleFloat1 ww1_s2RxR ww3_s2RxV of ww4_s2RxZ
                 { __DEFAULT ->
                 GHC.Types.F# ww4_s2RxZ
                 }
                 }
                 }}]
GHC.Float.$fRealFloatFloat_$cscaleFloat
  = \ (w_s2RxN :: Int) (w1_s2RxO :: Float) ->
      case w_s2RxN of { I# ww1_s2RxR ->
      case w1_s2RxO of { F# ww3_s2RxV ->
      case GHC.Float.$w$cscaleFloat1 ww1_s2RxR ww3_s2RxV of ww4_s2RxZ
      { __DEFAULT ->
      GHC.Types.F# ww4_s2RxZ
      }
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
isDoubleNaN :: Double -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2Kv1 [Occ=Once!] :: Double) ->
                 case ds_d2Kv1 of { D# ds2_d2Kv3 [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kv6
                        ds2_d2Kv3 realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2Kv4 [Occ=Once] #) ->
                 GHC.Types.I# ds4_d2Kv4
                 }
                 }}]
isDoubleNaN
  = \ (ds_d2Kv1 :: Double) ->
      case ds_d2Kv1 of { D# ds2_d2Kv3 ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kv6
             ds2_d2Kv3 realWorld#
      of
      { (# ds3_d2Kv5, ds4_d2Kv4 #) ->
      GHC.Types.I# ds4_d2Kv4
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
isDoubleInfinite :: Double -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2KuU [Occ=Once!] :: Double) ->
                 case ds_d2KuU of { D# ds2_d2KuW [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuZ
                        ds2_d2KuW realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2KuX [Occ=Once] #) ->
                 GHC.Types.I# ds4_d2KuX
                 }
                 }}]
isDoubleInfinite
  = \ (ds_d2KuU :: Double) ->
      case ds_d2KuU of { D# ds2_d2KuW ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuZ
             ds2_d2KuW realWorld#
      of
      { (# ds3_d2KuY, ds4_d2KuX #) ->
      GHC.Types.I# ds4_d2KuX
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
isDoubleDenormalized :: Double -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2KuN [Occ=Once!] :: Double) ->
                 case ds_d2KuN of { D# ds2_d2KuP [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuS
                        ds2_d2KuP realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2KuQ [Occ=Once] #) ->
                 GHC.Types.I# ds4_d2KuQ
                 }
                 }}]
isDoubleDenormalized
  = \ (ds_d2KuN :: Double) ->
      case ds_d2KuN of { D# ds2_d2KuP ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuS
             ds2_d2KuP realWorld#
      of
      { (# ds3_d2KuR, ds4_d2KuQ #) ->
      GHC.Types.I# ds4_d2KuQ
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
isDoubleNegativeZero :: Double -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2KuG [Occ=Once!] :: Double) ->
                 case ds_d2KuG of { D# ds2_d2KuI [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuL
                        ds2_d2KuI realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2KuJ [Occ=Once] #) ->
                 GHC.Types.I# ds4_d2KuJ
                 }
                 }}]
isDoubleNegativeZero
  = \ (ds_d2KuG :: Double) ->
      case ds_d2KuG of { D# ds2_d2KuI ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuL
             ds2_d2KuI realWorld#
      of
      { (# ds3_d2KuK, ds4_d2KuJ #) ->
      GHC.Types.I# ds4_d2KuJ
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
isDoubleFinite :: Double -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2Kuz [Occ=Once!] :: Double) ->
                 case ds_d2Kuz of { D# ds2_d2KuB [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuE
                        ds2_d2KuB realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2KuC [Occ=Once] #) ->
                 GHC.Types.I# ds4_d2KuC
                 }
                 }}]
isDoubleFinite
  = \ (ds_d2Kuz :: Double) ->
      case ds_d2Kuz of { D# ds2_d2KuB ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuE
             ds2_d2KuB realWorld#
      of
      { (# ds3_d2KuD, ds4_d2KuC #) ->
      GHC.Types.I# ds4_d2KuC
      }
      }

-- RHS size: {terms: 56, types: 28, coercions: 0, joins: 1/1}
GHC.Float.$w$cscaleFloat [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Double# -> Double#
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 223 0}]
GHC.Float.$w$cscaleFloat
  = \ (ww_s2Ry8 :: Int#) (ww1_s2Ryc :: Double#) ->
      case ww_s2Ry8 of ds_X2Kq1 {
        __DEFAULT ->
          case ==## ww1_s2Ryc 0.0## of {
            __DEFAULT ->
              case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuE
                     ww1_s2Ryc realWorld#
              of
              { (# ds1_d2KuD, ds2_d2KuC #) ->
              case ds2_d2KuC of {
                __DEFAULT ->
                  case decodeDoubleInteger ww1_s2Ryc of
                  { (# ipv_s2KAX, ipv1_s2KAY #) ->
                  join {
                    $w$j2_s2Ry3 [InlPrag=NOUSERINLINE[0], Dmd=<C(S),1*C1(U)>]
                      :: Int# -> Double#
                    [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                    $w$j2_s2Ry3 (w_s2Ry1 [OS=OneShot] :: Int#)
                      = case <=# -2257# w_s2Ry1 of {
                          __DEFAULT -> encodeDoubleInteger ipv_s2KAX (+# ipv1_s2KAY -2257#);
                          1# -> encodeDoubleInteger ipv_s2KAX (+# ipv1_s2KAY w_s2Ry1)
                        } } in
                  case <=# 2257# ds_X2Kq1 of {
                    __DEFAULT -> jump $w$j2_s2Ry3 ds_X2Kq1;
                    1# -> jump $w$j2_s2Ry3 2257#
                  }
                  };
                0# -> ww1_s2Ryc
              }
              };
            1# -> ww1_s2Ryc
          };
        0# -> ww1_s2Ryc
      }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$cscaleFloat [InlPrag=NOUSERINLINE[0]]
  :: Int -> Double -> Double
[GblId,
 Arity=2,
 Str=<S(S),1*U(1*U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2Ry4 [Occ=Once!] :: Int)
                 (w1_s2Ry5 [Occ=Once!] :: Double) ->
                 case w_s2Ry4 of { I# ww1_s2Ry8 [Occ=Once] ->
                 case w1_s2Ry5 of { D# ww3_s2Ryc [Occ=Once] ->
                 case GHC.Float.$w$cscaleFloat ww1_s2Ry8 ww3_s2Ryc of ww4_s2Ryg
                 { __DEFAULT ->
                 GHC.Types.D# ww4_s2Ryg
                 }
                 }
                 }}]
GHC.Float.$fRealFloatDouble_$cscaleFloat
  = \ (w_s2Ry4 :: Int) (w1_s2Ry5 :: Double) ->
      case w_s2Ry4 of { I# ww1_s2Ry8 ->
      case w1_s2Ry5 of { D# ww3_s2Ryc ->
      case GHC.Float.$w$cscaleFloat ww1_s2Ry8 ww3_s2Ryc of ww4_s2Ryg
      { __DEFAULT ->
      GHC.Types.D# ww4_s2Ryg
      }
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
log1pDouble :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2Kus [Occ=Once!] :: Double) ->
                 case ds_d2Kus of { D# ds2_d2Kuu [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_d2Kux
                        ds2_d2Kuu realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2Kuv [Occ=Once] #) ->
                 GHC.Types.D# ds4_d2Kuv
                 }
                 }}]
log1pDouble
  = \ (ds_d2Kus :: Double) ->
      case ds_d2Kus of { D# ds2_d2Kuu ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_d2Kux
             ds2_d2Kuu realWorld#
      of
      { (# ds3_d2Kuw, ds4_d2Kuv #) ->
      GHC.Types.D# ds4_d2Kuv
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
expm1Double :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2Kul [Occ=Once!] :: Double) ->
                 case ds_d2Kul of { D# ds2_d2Kun [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_d2Kuq
                        ds2_d2Kun realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2Kuo [Occ=Once] #) ->
                 GHC.Types.D# ds4_d2Kuo
                 }
                 }}]
expm1Double
  = \ (ds_d2Kul :: Double) ->
      case ds_d2Kul of { D# ds2_d2Kun ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_d2Kuq
             ds2_d2Kun realWorld#
      of
      { (# ds3_d2Kup, ds4_d2Kuo #) ->
      GHC.Types.D# ds4_d2Kuo
      }
      }

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
lvl4_r2UqC :: Double
[GblId]
lvl4_r2UqC
  = case logDouble# 2.0## of v_B2 { __DEFAULT -> GHC.Types.D# v_B2 }

-- RHS size: {terms: 34, types: 29, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingDouble_$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: Double -> Double
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (a_a2HZ7 [Occ=Once!] :: Double) ->
                 case a_a2HZ7 of { D# x_a2KK4 ->
                 case logDouble# 2.0## of wild1_X1z { __DEFAULT ->
                 case <=## x_a2KK4 wild1_X1z of {
                   __DEFAULT ->
                     case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_d2Kux
                            (negateDouble# (expDouble# x_a2KK4)) realWorld#
                     of
                     { (# _ [Occ=Dead], ds1_d2Kuv [Occ=Once] #) ->
                     GHC.Types.D# ds1_d2Kuv
                     };
                   1# ->
                     case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_d2Kuq
                            x_a2KK4 realWorld#
                     of
                     { (# _ [Occ=Dead], ds1_d2Kuo [Occ=Once] #) ->
                     case logDouble# (negateDouble# ds1_d2Kuo) of wild3_Xmz
                     { __DEFAULT ->
                     GHC.Types.D# wild3_Xmz
                     }
                     }
                 }
                 }
                 }}]
GHC.Float.$fFloatingDouble_$clog1mexp
  = \ (eta_B1 :: Double) ->
      case eta_B1 of { D# x_a2KK4 ->
      case lvl4_r2UqC of { D# v1_B2 ->
      case <=## x_a2KK4 v1_B2 of {
        __DEFAULT ->
          case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_d2Kux
                 (negateDouble# (expDouble# x_a2KK4)) realWorld#
          of
          { (# ds_d2Kuw, ds1_d2Kuv #) ->
          GHC.Types.D# ds1_d2Kuv
          };
        1# ->
          case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_d2Kuq
                 x_a2KK4 realWorld#
          of
          { (# ds_d2Kup, ds1_d2Kuo #) ->
          case logDouble# (negateDouble# ds1_d2Kuo) of wild2_XmC
          { __DEFAULT ->
          GHC.Types.D# wild2_XmC
          }
          }
      }
      }
      }

-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Floating Double
[GblId[DFunId],
 Unf=DFun: \ ->
       GHC.Float.C:Floating TYPE: Double
                            GHC.Float.$fFractionalDouble
                            GHC.Float.$fFloatingDouble_$cpi
                            expDouble
                            logDouble
                            sqrtDouble
                            powerDouble
                            GHC.Float.$fFloatingDouble_$clogBase
                            sinDouble
                            cosDouble
                            tanDouble
                            asinDouble
                            acosDouble
                            atanDouble
                            sinhDouble
                            coshDouble
                            tanhDouble
                            GHC.Float.$fFloatingDouble_$casinh
                            GHC.Float.$fFloatingDouble_$cacosh
                            GHC.Float.$fFloatingDouble_$catanh
                            log1pDouble
                            expm1Double
                            GHC.Float.$fFloatingDouble_$clog1pexp
                            GHC.Float.$fFloatingDouble_$clog1mexp]
GHC.Float.$fFloatingDouble
  = GHC.Float.C:Floating
      @ Double
      GHC.Float.$fFractionalDouble
      GHC.Float.$fFloatingDouble_$cpi
      expDouble
      logDouble
      sqrtDouble
      powerDouble
      GHC.Float.$fFloatingDouble_$clogBase
      sinDouble
      cosDouble
      tanDouble
      asinDouble
      acosDouble
      atanDouble
      sinhDouble
      coshDouble
      tanhDouble
      GHC.Float.$fFloatingDouble_$casinh
      GHC.Float.$fFloatingDouble_$cacosh
      GHC.Float.$fFloatingDouble_$catanh
      log1pDouble
      expm1Double
      GHC.Float.$fFloatingDouble_$clog1pexp
      GHC.Float.$fFloatingDouble_$clog1mexp

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
log1pFloat :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2Kue [Occ=Once!] :: Float) ->
                 case ds_d2Kue of { F# ds2_d2Kug [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_d2Kuj
                        ds2_d2Kug realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2Kuh [Occ=Once] #) ->
                 GHC.Types.F# ds4_d2Kuh
                 }
                 }}]
log1pFloat
  = \ (ds_d2Kue :: Float) ->
      case ds_d2Kue of { F# ds2_d2Kug ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_d2Kuj
             ds2_d2Kug realWorld#
      of
      { (# ds3_d2Kui, ds4_d2Kuh #) ->
      GHC.Types.F# ds4_d2Kuh
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
expm1Float :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2Ku7 [Occ=Once!] :: Float) ->
                 case ds_d2Ku7 of { F# ds2_d2Ku9 [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_d2Kuc
                        ds2_d2Ku9 realWorld#
                 of
                 { (# _ [Occ=Dead], ds4_d2Kua [Occ=Once] #) ->
                 GHC.Types.F# ds4_d2Kua
                 }
                 }}]
expm1Float
  = \ (ds_d2Ku7 :: Float) ->
      case ds_d2Ku7 of { F# ds2_d2Ku9 ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_d2Kuc
             ds2_d2Ku9 realWorld#
      of
      { (# ds3_d2Kub, ds4_d2Kua #) ->
      GHC.Types.F# ds4_d2Kua
      }
      }

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
lvl5_r2UqD :: Float
[GblId]
lvl5_r2UqD
  = case logFloat# 2.0# of v_B2 { __DEFAULT -> GHC.Types.F# v_B2 }

-- RHS size: {terms: 34, types: 29, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingFloat_$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: Float -> Float
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (a_a2I08 [Occ=Once!] :: Float) ->
                 case a_a2I08 of { F# x_a2KKO ->
                 case logFloat# 2.0# of wild1_XP { __DEFAULT ->
                 case leFloat# x_a2KKO wild1_XP of {
                   __DEFAULT ->
                     case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_d2Kuj
                            (negateFloat# (expFloat# x_a2KKO)) realWorld#
                     of
                     { (# _ [Occ=Dead], ds1_d2Kuh [Occ=Once] #) ->
                     GHC.Types.F# ds1_d2Kuh
                     };
                   1# ->
                     case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_d2Kuc
                            x_a2KKO realWorld#
                     of
                     { (# _ [Occ=Dead], ds1_d2Kua [Occ=Once] #) ->
                     case logFloat# (negateFloat# ds1_d2Kua) of wild3_XlU { __DEFAULT ->
                     GHC.Types.F# wild3_XlU
                     }
                     }
                 }
                 }
                 }}]
GHC.Float.$fFloatingFloat_$clog1mexp
  = \ (eta_B1 :: Float) ->
      case eta_B1 of { F# x_a2KKO ->
      case lvl5_r2UqD of { F# v1_B2 ->
      case leFloat# x_a2KKO v1_B2 of {
        __DEFAULT ->
          case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_d2Kuj
                 (negateFloat# (expFloat# x_a2KKO)) realWorld#
          of
          { (# ds_d2Kui, ds1_d2Kuh #) ->
          GHC.Types.F# ds1_d2Kuh
          };
        1# ->
          case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_d2Kuc
                 x_a2KKO realWorld#
          of
          { (# ds_d2Kub, ds1_d2Kua #) ->
          case logFloat# (negateFloat# ds1_d2Kua) of wild2_XlX { __DEFAULT ->
          GHC.Types.F# wild2_XlX
          }
          }
      }
      }
      }

-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fFloatingFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Floating Float
[GblId[DFunId],
 Unf=DFun: \ ->
       GHC.Float.C:Floating TYPE: Float
                            GHC.Float.$fFractionalFloat
                            GHC.Float.$fFloatingFloat_$cpi
                            expFloat
                            logFloat
                            sqrtFloat
                            powerFloat
                            GHC.Float.$fFloatingFloat_$clogBase
                            sinFloat
                            cosFloat
                            tanFloat
                            asinFloat
                            acosFloat
                            atanFloat
                            sinhFloat
                            coshFloat
                            tanhFloat
                            GHC.Float.$fFloatingFloat_$casinh
                            GHC.Float.$fFloatingFloat_$cacosh
                            GHC.Float.$fFloatingFloat_$catanh
                            log1pFloat
                            expm1Float
                            GHC.Float.$fFloatingFloat_$clog1pexp
                            GHC.Float.$fFloatingFloat_$clog1mexp]
GHC.Float.$fFloatingFloat
  = GHC.Float.C:Floating
      @ Float
      GHC.Float.$fFractionalFloat
      GHC.Float.$fFloatingFloat_$cpi
      expFloat
      logFloat
      sqrtFloat
      powerFloat
      GHC.Float.$fFloatingFloat_$clogBase
      sinFloat
      cosFloat
      tanFloat
      asinFloat
      acosFloat
      atanFloat
      sinhFloat
      coshFloat
      tanhFloat
      GHC.Float.$fFloatingFloat_$casinh
      GHC.Float.$fFloatingFloat_$cacosh
      GHC.Float.$fFloatingFloat_$catanh
      log1pFloat
      expm1Float
      GHC.Float.$fFloatingFloat_$clog1pexp
      GHC.Float.$fFloatingFloat_$clog1mexp

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
stgWord32ToFloat :: Word# -> Float#
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= {__pkg_ccall_GC base-4.11.0.0 "stg_word32ToFloatzh" Word#
                                                    -> Float#}_d2Ku6}]
stgWord32ToFloat
  = {__pkg_ccall_GC base-4.11.0.0 "stg_word32ToFloatzh" Word#
                                                    -> Float#}_d2Ku6

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
castWord32ToFloat [InlPrag=INLINE (sat-args=1)] :: Word32 -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2JJk [Occ=Once!] :: Word32) ->
                 case ds_d2JJk of { W32# w#_a2I4C [Occ=Once] ->
                 case {__pkg_ccall_GC base-4.11.0.0 "stg_word32ToFloatzh" Word#
                                                    -> Float#}_d2Ku6
                        w#_a2I4C
                 of wild1_X4
                 { __DEFAULT ->
                 GHC.Types.F# wild1_X4
                 }
                 }}]
castWord32ToFloat
  = \ (ds_d2JJk :: Word32) ->
      case ds_d2JJk of { W32# w#_a2I4C ->
      case {__pkg_ccall_GC base-4.11.0.0 "stg_word32ToFloatzh" Word#
                                                    -> Float#}_d2Ku6
             w#_a2I4C
      of wild1_X3q
      { __DEFAULT ->
      GHC.Types.F# wild1_X3q
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
stgFloatToWord32 :: Float# -> Word#
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= {__pkg_ccall_GC base-4.11.0.0 "stg_floatToWord32zh" Float#
                                                    -> Word#}_d2Ku4}]
stgFloatToWord32
  = {__pkg_ccall_GC base-4.11.0.0 "stg_floatToWord32zh" Float#
                                                    -> Word#}_d2Ku4

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
castFloatToWord32 [InlPrag=INLINE (sat-args=1)] :: Float -> Word32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2JJg [Occ=Once!] :: Float) ->
                 case ds_d2JJg of { F# f#_a2I4D [Occ=Once] ->
                 case {__pkg_ccall_GC base-4.11.0.0 "stg_floatToWord32zh" Float#
                                                    -> Word#}_d2Ku4
                        f#_a2I4D
                 of wild1_X4
                 { __DEFAULT ->
                 GHC.Word.W32# wild1_X4
                 }
                 }}]
castFloatToWord32
  = \ (ds_d2JJg :: Float) ->
      case ds_d2JJg of { F# f#_a2I4D ->
      case {__pkg_ccall_GC base-4.11.0.0 "stg_floatToWord32zh" Float#
                                                    -> Word#}_d2Ku4
             f#_a2I4D
      of wild1_X3s
      { __DEFAULT ->
      GHC.Word.W32# wild1_X3s
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
stgWord64ToDouble :: Word# -> Double#
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= {__pkg_ccall_GC base-4.11.0.0 "stg_word64ToDoublezh" Word#
                                                     -> Double#}_d2Ku2}]
stgWord64ToDouble
  = {__pkg_ccall_GC base-4.11.0.0 "stg_word64ToDoublezh" Word#
                                                     -> Double#}_d2Ku2

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
castWord64ToDouble [InlPrag=INLINE (sat-args=1)]
  :: Word64 -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2JJc [Occ=Once!] :: Word64) ->
                 case ds_d2JJc of { W64# w_a2I4E [Occ=Once] ->
                 case {__pkg_ccall_GC base-4.11.0.0 "stg_word64ToDoublezh" Word#
                                                     -> Double#}_d2Ku2
                        w_a2I4E
                 of wild1_X4
                 { __DEFAULT ->
                 GHC.Types.D# wild1_X4
                 }
                 }}]
castWord64ToDouble
  = \ (ds_d2JJc :: Word64) ->
      case ds_d2JJc of { W64# w_a2I4E ->
      case {__pkg_ccall_GC base-4.11.0.0 "stg_word64ToDoublezh" Word#
                                                     -> Double#}_d2Ku2
             w_a2I4E
      of wild1_X3u
      { __DEFAULT ->
      GHC.Types.D# wild1_X3u
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
stgDoubleToWord64 :: Double# -> Word#
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= {__pkg_ccall_GC base-4.11.0.0 "stg_doubleToWord64zh" Double#
                                                     -> Word#}_d2Ku0}]
stgDoubleToWord64
  = {__pkg_ccall_GC base-4.11.0.0 "stg_doubleToWord64zh" Double#
                                                     -> Word#}_d2Ku0

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
castDoubleToWord64 [InlPrag=INLINE (sat-args=1)]
  :: Double -> Word64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2JJ8 [Occ=Once!] :: Double) ->
                 case ds_d2JJ8 of { D# d#_a2I4F [Occ=Once] ->
                 case {__pkg_ccall_GC base-4.11.0.0 "stg_doubleToWord64zh" Double#
                                                     -> Word#}_d2Ku0
                        d#_a2I4F
                 of wild1_X4
                 { __DEFAULT ->
                 GHC.Word.W64# wild1_X4
                 }
                 }}]
castDoubleToWord64
  = \ (ds_d2JJ8 :: Double) ->
      case ds_d2JJ8 of { D# d#_a2I4F ->
      case {__pkg_ccall_GC base-4.11.0.0 "stg_doubleToWord64zh" Double#
                                                     -> Word#}_d2Ku0
             d#_a2I4F
      of wild1_X3w
      { __DEFAULT ->
      GHC.Word.W64# wild1_X3w
      }
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Float.$fEnumFloat_$csucc :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HY8 [Occ=Once!] :: Float) ->
                 case x_a2HY8 of { F# x1_a2I3r [Occ=Once] ->
                 GHC.Types.F# (plusFloat# x1_a2I3r 1.0#)
                 }}]
GHC.Float.$fEnumFloat_$csucc
  = \ (x_a2HY8 :: Float) ->
      case x_a2HY8 of { F# x1_a2I3r ->
      GHC.Types.F# (plusFloat# x1_a2I3r 1.0#)
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Float.$fEnumFloat_$cpred :: Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HY9 [Occ=Once!] :: Float) ->
                 case x_a2HY9 of { F# x1_a2I3t [Occ=Once] ->
                 GHC.Types.F# (minusFloat# x1_a2I3t 1.0#)
                 }}]
GHC.Float.$fEnumFloat_$cpred
  = \ (x_a2HY9 :: Float) ->
      case x_a2HY9 of { F# x1_a2I3t ->
      GHC.Types.F# (minusFloat# x1_a2I3t 1.0#)
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloat [InlPrag=NOUSERINLINE CONLIKE] :: Real Float
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Float
                       GHC.Float.$fNumFloat
                       GHC.Classes.$fOrdFloat
                       GHC.Float.$fRealFloat_$ctoRational]
GHC.Float.$fRealFloat
  = GHC.Real.C:Real
      @ Float
      GHC.Float.$fNumFloat
      GHC.Classes.$fOrdFloat
      GHC.Float.$fRealFloat_$ctoRational

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealFracFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: RealFrac Float
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:RealFrac TYPE: Float
                           GHC.Float.$fRealFloat
                           GHC.Float.$fFractionalFloat
                           GHC.Float.$fRealFracFloat_$cproperFraction
                           GHC.Float.$fRealFracFloat_$ctruncate
                           GHC.Float.$fRealFracFloat_$cround
                           GHC.Float.$fRealFracFloat_$cceiling
                           GHC.Float.$fRealFracFloat_$cfloor]
GHC.Float.$fRealFracFloat
  = GHC.Real.C:RealFrac
      @ Float
      GHC.Float.$fRealFloat
      GHC.Float.$fFractionalFloat
      GHC.Float.$fRealFracFloat_$cproperFraction
      GHC.Float.$fRealFracFloat_$ctruncate
      GHC.Float.$fRealFracFloat_$cround
      GHC.Float.$fRealFracFloat_$cceiling
      GHC.Float.$fRealFracFloat_$cfloor

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Float.$fEnumDouble_$csucc :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HY6 [Occ=Once!] :: Double) ->
                 case x_a2HY6 of { D# x1_a2I3X [Occ=Once] ->
                 GHC.Types.D# (+## x1_a2I3X 1.0##)
                 }}]
GHC.Float.$fEnumDouble_$csucc
  = \ (x_a2HY6 :: Double) ->
      case x_a2HY6 of { D# x1_a2I3X ->
      GHC.Types.D# (+## x1_a2I3X 1.0##)
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Float.$fEnumDouble_$cpred :: Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HY7 [Occ=Once!] :: Double) ->
                 case x_a2HY7 of { D# x1_a2I3Z [Occ=Once] ->
                 GHC.Types.D# (-## x1_a2I3Z 1.0##)
                 }}]
GHC.Float.$fEnumDouble_$cpred
  = \ (x_a2HY7 :: Double) ->
      case x_a2HY7 of { D# x1_a2I3Z ->
      GHC.Types.D# (-## x1_a2I3Z 1.0##)
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Real Double
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Double
                       GHC.Float.$fNumDouble
                       GHC.Classes.$fOrdDouble
                       GHC.Float.$fRealDouble_$ctoRational]
GHC.Float.$fRealDouble
  = GHC.Real.C:Real
      @ Double
      GHC.Float.$fNumDouble
      GHC.Classes.$fOrdDouble
      GHC.Float.$fRealDouble_$ctoRational

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealFracDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: RealFrac Double
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:RealFrac TYPE: Double
                           GHC.Float.$fRealDouble
                           GHC.Float.$fFractionalDouble
                           GHC.Float.$fRealFracDouble_$cproperFraction
                           GHC.Float.$fRealFracDouble_$ctruncate
                           GHC.Float.$fRealFracDouble_$cround
                           GHC.Float.$fRealFracDouble_$cceiling
                           GHC.Float.$fRealFracDouble_$cfloor]
GHC.Float.$fRealFracDouble
  = GHC.Real.C:RealFrac
      @ Double
      GHC.Float.$fRealDouble
      GHC.Float.$fFractionalDouble
      GHC.Float.$fRealFracDouble_$cproperFraction
      GHC.Float.$fRealFracDouble_$ctruncate
      GHC.Float.$fRealFracDouble_$cround
      GHC.Float.$fRealFracDouble_$cceiling
      GHC.Float.$fRealFracDouble_$cfloor

-- RHS size: {terms: 15, types: 15, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$cisNaN :: Double -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HYs [Occ=Once!] :: Double) ->
                 case x_a2HYs of { D# ds1_d2Kv3 [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kv6
                        ds1_d2Kv3 realWorld#
                 of
                 { (# _ [Occ=Dead], ds3_d2Kv4 [Occ=Once!] #) ->
                 case ds3_d2Kv4 of {
                   __DEFAULT -> GHC.Types.True;
                   0# -> GHC.Types.False
                 }
                 }
                 }}]
GHC.Float.$fRealFloatDouble_$cisNaN
  = \ (x_a2HYs :: Double) ->
      case x_a2HYs of { D# ds1_d2Kv3 ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kv6
             ds1_d2Kv3 realWorld#
      of
      { (# ds2_d2Kv5, ds3_d2Kv4 #) ->
      case ds3_d2Kv4 of {
        __DEFAULT -> GHC.Types.True;
        0# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 15, types: 15, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$cisInfinite :: Double -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HYt [Occ=Once!] :: Double) ->
                 case x_a2HYt of { D# ds1_d2KuW [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuZ
                        ds1_d2KuW realWorld#
                 of
                 { (# _ [Occ=Dead], ds3_d2KuX [Occ=Once!] #) ->
                 case ds3_d2KuX of {
                   __DEFAULT -> GHC.Types.True;
                   0# -> GHC.Types.False
                 }
                 }
                 }}]
GHC.Float.$fRealFloatDouble_$cisInfinite
  = \ (x_a2HYt :: Double) ->
      case x_a2HYt of { D# ds1_d2KuW ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuZ
             ds1_d2KuW realWorld#
      of
      { (# ds2_d2KuY, ds3_d2KuX #) ->
      case ds3_d2KuX of {
        __DEFAULT -> GHC.Types.True;
        0# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 15, types: 15, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$cisDenormalized :: Double -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HYu [Occ=Once!] :: Double) ->
                 case x_a2HYu of { D# ds1_d2KuP [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuS
                        ds1_d2KuP realWorld#
                 of
                 { (# _ [Occ=Dead], ds3_d2KuQ [Occ=Once!] #) ->
                 case ds3_d2KuQ of {
                   __DEFAULT -> GHC.Types.True;
                   0# -> GHC.Types.False
                 }
                 }
                 }}]
GHC.Float.$fRealFloatDouble_$cisDenormalized
  = \ (x_a2HYu :: Double) ->
      case x_a2HYu of { D# ds1_d2KuP ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuS
             ds1_d2KuP realWorld#
      of
      { (# ds2_d2KuR, ds3_d2KuQ #) ->
      case ds3_d2KuQ of {
        __DEFAULT -> GHC.Types.True;
        0# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 15, types: 15, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$cisNegativeZero :: Double -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HYv [Occ=Once!] :: Double) ->
                 case x_a2HYv of { D# ds1_d2KuI [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuL
                        ds1_d2KuI realWorld#
                 of
                 { (# _ [Occ=Dead], ds3_d2KuJ [Occ=Once!] #) ->
                 case ds3_d2KuJ of {
                   __DEFAULT -> GHC.Types.True;
                   0# -> GHC.Types.False
                 }
                 }
                 }}]
GHC.Float.$fRealFloatDouble_$cisNegativeZero
  = \ (x_a2HYv :: Double) ->
      case x_a2HYv of { D# ds1_d2KuI ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuL
             ds1_d2KuI realWorld#
      of
      { (# ds2_d2KuK, ds3_d2KuJ #) ->
      case ds3_d2KuJ of {
        __DEFAULT -> GHC.Types.True;
        0# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 15, types: 15, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$cisNaN :: Float -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HZL [Occ=Once!] :: Float) ->
                 case x_a2HZL of { F# ds1_d2KvC [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KvF
                        ds1_d2KvC realWorld#
                 of
                 { (# _ [Occ=Dead], ds3_d2KvD [Occ=Once!] #) ->
                 case ds3_d2KvD of {
                   __DEFAULT -> GHC.Types.True;
                   0# -> GHC.Types.False
                 }
                 }
                 }}]
GHC.Float.$fRealFloatFloat_$cisNaN
  = \ (x_a2HZL :: Float) ->
      case x_a2HZL of { F# ds1_d2KvC ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KvF
             ds1_d2KvC realWorld#
      of
      { (# ds2_d2KvE, ds3_d2KvD #) ->
      case ds3_d2KvD of {
        __DEFAULT -> GHC.Types.True;
        0# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 15, types: 15, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$cisInfinite :: Float -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HZM [Occ=Once!] :: Float) ->
                 case x_a2HZM of { F# ds1_d2Kvv [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvy
                        ds1_d2Kvv realWorld#
                 of
                 { (# _ [Occ=Dead], ds3_d2Kvw [Occ=Once!] #) ->
                 case ds3_d2Kvw of {
                   __DEFAULT -> GHC.Types.True;
                   0# -> GHC.Types.False
                 }
                 }
                 }}]
GHC.Float.$fRealFloatFloat_$cisInfinite
  = \ (x_a2HZM :: Float) ->
      case x_a2HZM of { F# ds1_d2Kvv ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvy
             ds1_d2Kvv realWorld#
      of
      { (# ds2_d2Kvx, ds3_d2Kvw #) ->
      case ds3_d2Kvw of {
        __DEFAULT -> GHC.Types.True;
        0# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 15, types: 15, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$cisDenormalized :: Float -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HZN [Occ=Once!] :: Float) ->
                 case x_a2HZN of { F# ds1_d2Kvo [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvr
                        ds1_d2Kvo realWorld#
                 of
                 { (# _ [Occ=Dead], ds3_d2Kvp [Occ=Once!] #) ->
                 case ds3_d2Kvp of {
                   __DEFAULT -> GHC.Types.True;
                   0# -> GHC.Types.False
                 }
                 }
                 }}]
GHC.Float.$fRealFloatFloat_$cisDenormalized
  = \ (x_a2HZN :: Float) ->
      case x_a2HZN of { F# ds1_d2Kvo ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvr
             ds1_d2Kvo realWorld#
      of
      { (# ds2_d2Kvq, ds3_d2Kvp #) ->
      case ds3_d2Kvp of {
        __DEFAULT -> GHC.Types.True;
        0# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 15, types: 15, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$cisNegativeZero :: Float -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HZO [Occ=Once!] :: Float) ->
                 case x_a2HZO of { F# ds1_d2Kvh [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvk
                        ds1_d2Kvh realWorld#
                 of
                 { (# _ [Occ=Dead], ds3_d2Kvi [Occ=Once!] #) ->
                 case ds3_d2Kvi of {
                   __DEFAULT -> GHC.Types.True;
                   0# -> GHC.Types.False
                 }
                 }
                 }}]
GHC.Float.$fRealFloatFloat_$cisNegativeZero
  = \ (x_a2HZO :: Float) ->
      case x_a2HZO of { F# ds1_d2Kvh ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvk
             ds1_d2Kvh realWorld#
      of
      { (# ds2_d2Kvj, ds3_d2Kvi #) ->
      case ds3_d2Kvi of {
        __DEFAULT -> GHC.Types.True;
        0# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl6_r2UqE :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl6_r2UqE = "Int"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl7_r2UqF :: [Char]
[GblId]
lvl7_r2UqF = unpackCString# lvl6_r2UqE

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Float.expts2 :: Int# -> Int
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Float.expts2
  = \ (x_i1MGD :: Int#) ->
      GHC.Arr.$windexError
        @ Int
        @ Int
        GHC.Show.$fShowInt
        minExpt
        maxExpt
        (GHC.Types.I# x_i1MGD)
        lvl7_r2UqF

-- RHS size: {terms: 77, types: 87, coercions: 0, joins: 2/2}
GHC.Float.expts1
  :: State# RealWorld -> (# State# RealWorld, Array Int Integer #)
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 211 0}]
GHC.Float.expts1
  = \ (s1#_a1KX3 [OS=OneShot] :: State# RealWorld) ->
      case newArray#
             @ Integer @ RealWorld 1101# (arrEleBottom @ Integer) s1#_a1KX3
      of
      { (# ipv_s1MFb, ipv1_s1MFc #) ->
      join {
        exit_Xbl [Dmd=<C(S),C(U(U,U))>]
          :: State# RealWorld -> (# State# RealWorld, Array Int Integer #)
        [LclId[JoinId(1)], Arity=1, Str=<S,U>]
        exit_Xbl (s2#_a1KXb [OS=OneShot]
                    :: State# RealWorld
                    Unf=OtherCon [])
          = case unsafeFreezeArray#
                   @ RealWorld @ Integer ipv1_s1MFc s2#_a1KXb
            of
            { (# ipv2_s1MEX, ipv3_s1MEY #) ->
            (# ipv2_s1MEX,
               GHC.Arr.Array @ Int @ Integer minExpt maxExpt 1101# ipv3_s1MEY #)
            } } in
      joinrec {
        go_i1MGC [Occ=LoopBreaker]
          :: Int#
             -> State# RealWorld -> (# State# RealWorld, Array Int Integer #)
        [LclId[JoinId(2)], Arity=2, Str=<S,U><S,U>, Unf=OtherCon []]
        go_i1MGC (x_i1MGD :: Int#) (eta_B1 :: State# RealWorld)
          = case <=# 0# x_i1MGD of {
              __DEFAULT -> case GHC.Float.expts2 x_i1MGD of wild_00 { };
              1# ->
                case <=# x_i1MGD 1100# of {
                  __DEFAULT -> case GHC.Float.expts2 x_i1MGD of wild_00 { };
                  1# ->
                    case writeArray#
                           @ RealWorld
                           @ Integer
                           ipv1_s1MFc
                           x_i1MGD
                           (case <# x_i1MGD 0# of {
                              __DEFAULT ->
                                case x_i1MGD of wild1_i2Nx7 {
                                  __DEFAULT ->
                                    GHC.Real.$wf GHC.Float.$fRealFloatDouble5 wild1_i2Nx7;
                                  0# -> GHC.Real.$fEnumRatio1
                                };
                              1# -> GHC.Real.^1
                            })
                           eta_B1
                    of s2#_a1KXb
                    { __DEFAULT ->
                    case x_i1MGD of wild_XhX {
                      __DEFAULT -> jump go_i1MGC (+# wild_XhX 1#) s2#_a1KXb;
                      1100# -> jump exit_Xbl s2#_a1KXb
                    }
                    }
                }
            }; } in
      jump go_i1MGC 0# ipv_s1MFb
      }

-- RHS size: {terms: 5, types: 36, coercions: 0, joins: 0/0}
expts :: Array Int Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
expts
  = case runRW#
           @ ('TupleRep '['TupleRep '[], 'LiftedRep])
           @ (# State# RealWorld, Array Int Integer #)
           GHC.Float.expts1
    of
    { (# ipv_s1JmS, ipv1_s1JmT #) ->
    ipv1_s1JmT
    }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.expts4 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Float.expts4 = 10

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Float.expts5 :: Int# -> Int
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Float.expts5
  = \ (x_i1MGD :: Int#) ->
      GHC.Arr.$windexError
        @ Int
        @ Int
        GHC.Show.$fShowInt
        minExpt
        maxExpt10
        (GHC.Types.I# x_i1MGD)
        lvl7_r2UqF

-- RHS size: {terms: 77, types: 87, coercions: 0, joins: 2/2}
GHC.Float.expts3
  :: State# RealWorld -> (# State# RealWorld, Array Int Integer #)
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 211 0}]
GHC.Float.expts3
  = \ (s1#_a1KX3 [OS=OneShot] :: State# RealWorld) ->
      case newArray#
             @ Integer @ RealWorld 325# (arrEleBottom @ Integer) s1#_a1KX3
      of
      { (# ipv_s1MFb, ipv1_s1MFc #) ->
      join {
        exit_Xbl [Dmd=<C(S),C(U(U,U))>]
          :: State# RealWorld -> (# State# RealWorld, Array Int Integer #)
        [LclId[JoinId(1)], Arity=1, Str=<S,U>]
        exit_Xbl (s2#_a1KXb [OS=OneShot]
                    :: State# RealWorld
                    Unf=OtherCon [])
          = case unsafeFreezeArray#
                   @ RealWorld @ Integer ipv1_s1MFc s2#_a1KXb
            of
            { (# ipv2_s1MEX, ipv3_s1MEY #) ->
            (# ipv2_s1MEX,
               GHC.Arr.Array @ Int @ Integer minExpt maxExpt10 325# ipv3_s1MEY #)
            } } in
      joinrec {
        go_i1MGC [Occ=LoopBreaker]
          :: Int#
             -> State# RealWorld -> (# State# RealWorld, Array Int Integer #)
        [LclId[JoinId(2)], Arity=2, Str=<S,U><S,U>, Unf=OtherCon []]
        go_i1MGC (x_i1MGD :: Int#) (eta_B1 :: State# RealWorld)
          = case <=# 0# x_i1MGD of {
              __DEFAULT -> case GHC.Float.expts5 x_i1MGD of wild_00 { };
              1# ->
                case <=# x_i1MGD 324# of {
                  __DEFAULT -> case GHC.Float.expts5 x_i1MGD of wild_00 { };
                  1# ->
                    case writeArray#
                           @ RealWorld
                           @ Integer
                           ipv1_s1MFc
                           x_i1MGD
                           (case <# x_i1MGD 0# of {
                              __DEFAULT ->
                                case x_i1MGD of wild1_i2Nx7 {
                                  __DEFAULT -> GHC.Real.$wf GHC.Float.expts4 wild1_i2Nx7;
                                  0# -> GHC.Real.$fEnumRatio1
                                };
                              1# -> GHC.Real.^1
                            })
                           eta_B1
                    of s2#_a1KXb
                    { __DEFAULT ->
                    case x_i1MGD of wild_Xi2 {
                      __DEFAULT -> jump go_i1MGC (+# wild_Xi2 1#) s2#_a1KXb;
                      324# -> jump exit_Xbl s2#_a1KXb
                    }
                    }
                }
            }; } in
      jump go_i1MGC 0# ipv_s1MFb
      }

-- RHS size: {terms: 5, types: 36, coercions: 0, joins: 0/0}
expts10 :: Array Int Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
expts10
  = case runRW#
           @ ('TupleRep '['TupleRep '[], 'LiftedRep])
           @ (# State# RealWorld, Array Int Integer #)
           GHC.Float.expts3
    of
    { (# ipv_s1JmS, ipv1_s1JmT #) ->
    ipv1_s1JmT
    }

-- RHS size: {terms: 26, types: 6, coercions: 0, joins: 0/0}
GHC.Float.$wintegerLogBase [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Integer -> Int#
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 30] 180 0}]
GHC.Float.$wintegerLogBase
  = \ (w_s2Rym :: Integer) (w1_s2Ryn :: Integer) ->
      case ltInteger# w1_s2Ryn w_s2Rym of {
        __DEFAULT ->
          case eqInteger# w_s2Rym GHC.Float.$fRealFloatDouble5 of {
            __DEFAULT -> integerLogBase# w_s2Rym w1_s2Ryn;
            1# ->
              case w1_s2Ryn of {
                __DEFAULT -> -1#;
                integer-simple-0.1.1.1:GHC.Integer.Type.Positive digits_a2JNS ->
                  GHC.Integer.Logarithms.Internals.integerLog2#_step 0# digits_a2JNS
              }
          };
        1# -> 0#
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
integerLogBase [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Integer -> Int
[GblId,
 Arity=2,
 Str=<S,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2Rym [Occ=Once] :: Integer)
                 (w1_s2Ryn [Occ=Once] :: Integer) ->
                 case GHC.Float.$wintegerLogBase w_s2Rym w1_s2Ryn of ww_s2Ryq
                 { __DEFAULT ->
                 GHC.Types.I# ww_s2Ryq
                 }}]
integerLogBase
  = \ (w_s2Rym :: Integer) (w1_s2Ryn :: Integer) ->
      case GHC.Float.$wintegerLogBase w_s2Rym w1_s2Ryn of ww_s2Ryq
      { __DEFAULT ->
      GHC.Types.I# ww_s2Ryq
      }

-- RHS size: {terms: 27, types: 17, coercions: 0, joins: 0/0}
GHC.Float.$dmexponent :: forall a. RealFloat a => a -> Int
[GblId,
 Arity=2,
 Str=<S(LLLLLC(S(SL))LLLLLLLLLL),U(A,A,A,1*C1(U(U)),A,1*C1(U(1*U,1*U(U))),A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2HXC)
                 ($dRealFloat_a2IZ3 :: RealFloat a_a2HXC)
                 (x_a2HXD :: a_a2HXC) ->
                 case decodeFloat @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXD of
                 { (m_a2IZc [Occ=Once], n_a2IZe [Occ=Once!]) ->
                 case eqInteger# m_a2IZc 0 of {
                   __DEFAULT ->
                     case n_a2IZe of { I# x1_i1AMi [Occ=Once] ->
                     case floatDigits @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXD of
                     { I# y_i1AMm [Occ=Once] ->
                     GHC.Types.I# (+# x1_i1AMi y_i1AMm)
                     }
                     };
                   1# -> GHC.Types.I# 0#
                 }
                 }}]
GHC.Float.$dmexponent
  = \ (@ a_a2HXC)
      ($dRealFloat_a2IZ3 :: RealFloat a_a2HXC)
      (x_a2HXD :: a_a2HXC) ->
      case decodeFloat @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXD of
      { (m_a2IZc, n_a2IZe) ->
      case eqInteger# m_a2IZc GHC.Float.rationalToDouble5 of {
        __DEFAULT ->
          case n_a2IZe of { I# x1_i1AMi ->
          case floatDigits @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXD of
          { I# y_i1AMm ->
          GHC.Types.I# (+# x1_i1AMi y_i1AMm)
          }
          };
        1# -> minExpt
      }
      }

-- RHS size: {terms: 19, types: 15, coercions: 0, joins: 0/0}
GHC.Float.$dmsignificand :: forall a. RealFloat a => a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLL),U(A,A,A,1*C1(U(U)),A,1*C1(U(1*U,A)),1*C1(C1(U)),A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2HXC)
                 ($dRealFloat_a2IZ3 :: RealFloat a_a2HXC)
                 (x_a2HXG :: a_a2HXC) ->
                 encodeFloat
                   @ a_a2HXC
                   $dRealFloat_a2IZ3
                   (case decodeFloat @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXG of
                    { (m_a2IZD [Occ=Once], _ [Occ=Dead]) ->
                    m_a2IZD
                    })
                   (case floatDigits @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXG of
                    { I# x1_i1AMT [Occ=Once] ->
                    GHC.Types.I# (negateInt# x1_i1AMT)
                    })}]
GHC.Float.$dmsignificand
  = \ (@ a_a2HXC)
      ($dRealFloat_a2IZ3 :: RealFloat a_a2HXC)
      (x_a2HXG :: a_a2HXC) ->
      encodeFloat
        @ a_a2HXC
        $dRealFloat_a2IZ3
        (case decodeFloat @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXG of
         { (m_a2IZD, ds_d2KhG) ->
         m_a2IZD
         })
        (case floatDigits @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXG of
         { I# x1_i1AMT ->
         GHC.Types.I# (negateInt# x1_i1AMT)
         })

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble3 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fRealFloatDouble3 = GHC.Types.I# -1021#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble2 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fRealFloatDouble2 = GHC.Types.I# 1024#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble1 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Float.$fRealFloatDouble1
  = (GHC.Float.$fRealFloatDouble3, GHC.Float.$fRealFloatDouble2)

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$cfloatRange :: Double -> (Int, Int)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Float.$fRealFloatDouble1}]
GHC.Float.$fRealFloatDouble_$cfloatRange
  = \ _ [Occ=Dead] -> GHC.Float.$fRealFloatDouble1

Rec {
-- RHS size: {terms: 173, types: 73, coercions: 0, joins: 6/6}
GHC.Float.$w$catan2 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: Double -> Double# -> Double#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U(U)><S,U>, Unf=OtherCon []]
GHC.Float.$w$catan2
  = \ (w_s2Rys :: Double) (ww_s2Ryw :: Double#) ->
      case >## ww_s2Ryw 0.0## of {
        __DEFAULT ->
          join {
            $j1_s2MhJ [Dmd=<L,1*U>] :: Double#
            [LclId[JoinId(0)]]
            $j1_s2MhJ
              = join {
                  $j2_s2MhC [Dmd=<L,1*U>] :: Double#
                  [LclId[JoinId(0)]]
                  $j2_s2MhC
                    = join {
                        $j3_s2Mhi [Dmd=<L,1*U>] :: Double#
                        [LclId[JoinId(0)]]
                        $j3_s2Mhi
                          = case GHC.Float.$w$catan2 (negateDouble w_s2Rys) ww_s2Ryw
                            of ww1_s2RyA
                            { __DEFAULT ->
                            negateDouble# ww1_s2RyA
                            } } in
                      join {
                        $j4_s2Mhu [Dmd=<L,1*U>] :: Double#
                        [LclId[JoinId(0)]]
                        $j4_s2Mhu
                          = join {
                              $j5_s2Mho [Dmd=<L,1*U>] :: Double#
                              [LclId[JoinId(0)]]
                              $j5_s2Mho
                                = case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuL
                                         ww_s2Ryw realWorld#
                                  of
                                  { (# ds_d2KuK, ds1_d2KuJ #) ->
                                  join {
                                    $j6_s2Mhh [Dmd=<L,1*U>] :: Double#
                                    [LclId[JoinId(0)]]
                                    $j6_s2Mhh
                                      = case w_s2Rys of { D# x_a2KPU ->
                                        case ==## x_a2KPU 0.0## of {
                                          __DEFAULT -> +## ww_s2Ryw x_a2KPU;
                                          1# ->
                                            case <## ww_s2Ryw 0.0## of {
                                              __DEFAULT ->
                                                case ds1_d2KuJ of {
                                                  __DEFAULT -> 3.141592653589793##;
                                                  0# ->
                                                    case ==## ww_s2Ryw 0.0## of {
                                                      __DEFAULT -> +## ww_s2Ryw x_a2KPU;
                                                      1# -> x_a2KPU
                                                    }
                                                };
                                              1# -> 3.141592653589793##
                                            }
                                        }
                                        } } in
                                  case ds1_d2KuJ of {
                                    __DEFAULT ->
                                      case w_s2Rys of { D# ds3_X2KQY ->
                                      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuL
                                             ds3_X2KQY realWorld#
                                      of
                                      { (# ds4_X2KR5, ds5_X2Ldr #) ->
                                      case ds5_X2Ldr of {
                                        __DEFAULT -> jump $j3_s2Mhi;
                                        0# -> jump $j6_s2Mhh
                                      }
                                      }
                                      };
                                    0# -> jump $j6_s2Mhh
                                  }
                                  } } in
                            case <## ww_s2Ryw 0.0## of {
                              __DEFAULT -> jump $j5_s2Mho;
                              1# ->
                                case w_s2Rys of { D# ds1_d2KuI ->
                                case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuL
                                       ds1_d2KuI realWorld#
                                of
                                { (# ds2_d2KuK, ds3_d2KuJ #) ->
                                case ds3_d2KuJ of {
                                  __DEFAULT -> jump $j3_s2Mhi;
                                  0# -> jump $j5_s2Mho
                                }
                                }
                                }
                            } } in
                      case <=## ww_s2Ryw 0.0## of {
                        __DEFAULT -> jump $j4_s2Mhu;
                        1# ->
                          case w_s2Rys of { D# x_X2L0f ->
                          case <## x_X2L0f 0.0## of {
                            __DEFAULT -> jump $j4_s2Mhu;
                            1# -> jump $j3_s2Mhi
                          }
                          }
                      } } in
                case <## ww_s2Ryw 0.0## of {
                  __DEFAULT -> jump $j2_s2MhC;
                  1# ->
                    case w_s2Rys of { D# x_X2KZZ ->
                    case >## x_X2KZZ 0.0## of {
                      __DEFAULT -> jump $j2_s2MhC;
                      1# ->
                        case /## x_X2KZZ ww_s2Ryw of wild1_X1p { __DEFAULT ->
                        +## 3.141592653589793## (atanDouble# wild1_X1p)
                        }
                    }
                    }
                } } in
          case ==## ww_s2Ryw 0.0## of {
            __DEFAULT -> jump $j1_s2MhJ;
            1# ->
              case w_s2Rys of { D# x_X2KZV ->
              case >## x_X2KZV 0.0## of {
                __DEFAULT -> jump $j1_s2MhJ;
                1# -> 1.5707963267948966##
              }
              }
          };
        1# ->
          case w_s2Rys of { D# x_a2I43 ->
          case /## x_a2I43 ww_s2Ryw of wild1_X1p { __DEFAULT ->
          atanDouble# wild1_X1p
          }
          }
      }
end Rec }

-- RHS size: {terms: 12, types: 5, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble_$catan2 [InlPrag=NOUSERINLINE[0]]
  :: Double -> Double -> Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2Rys [Occ=Once] :: Double)
                 (w1_s2Ryt [Occ=Once!] :: Double) ->
                 case w1_s2Ryt of { D# ww1_s2Ryw [Occ=Once] ->
                 case GHC.Float.$w$catan2 w_s2Rys ww1_s2Ryw of ww2_s2RyA
                 { __DEFAULT ->
                 GHC.Types.D# ww2_s2RyA
                 }
                 }}]
GHC.Float.$fRealFloatDouble_$catan2
  = \ (w_s2Rys :: Double) (w1_s2Ryt :: Double) ->
      case w1_s2Ryt of { D# ww1_s2Ryw ->
      case GHC.Float.$w$catan2 w_s2Rys ww1_s2Ryw of ww2_s2RyA
      { __DEFAULT ->
      GHC.Types.D# ww2_s2RyA
      }
      }

-- RHS size: {terms: 17, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: RealFloat Double
[GblId[DFunId],
 Unf=DFun: \ ->
       GHC.Float.C:RealFloat TYPE: Double
                             GHC.Float.$fRealFracDouble
                             GHC.Float.$fFloatingDouble
                             GHC.Float.$fRealFloatDouble_$cfloatRadix
                             GHC.Float.$fRealFloatDouble_$cfloatDigits
                             GHC.Float.$fRealFloatDouble_$cfloatRange
                             GHC.Float.$fRealFloatDouble_$cdecodeFloat
                             GHC.Float.$fRealFloatDouble_$cencodeFloat
                             GHC.Float.$fRealFloatDouble_$cexponent
                             GHC.Float.$fRealFloatDouble_$csignificand
                             GHC.Float.$fRealFloatDouble_$cscaleFloat
                             GHC.Float.$fRealFloatDouble_$cisNaN
                             GHC.Float.$fRealFloatDouble_$cisInfinite
                             GHC.Float.$fRealFloatDouble_$cisDenormalized
                             GHC.Float.$fRealFloatDouble_$cisNegativeZero
                             GHC.Float.$fRealFloatDouble_$cisIEEE
                             GHC.Float.$fRealFloatDouble_$catan2]
GHC.Float.$fRealFloatDouble
  = GHC.Float.C:RealFloat
      @ Double
      GHC.Float.$fRealFracDouble
      GHC.Float.$fFloatingDouble
      GHC.Float.$fRealFloatDouble_$cfloatRadix
      GHC.Float.$fRealFloatDouble_$cfloatDigits
      GHC.Float.$fRealFloatDouble_$cfloatRange
      GHC.Float.$fRealFloatDouble_$cdecodeFloat
      GHC.Float.$fRealFloatDouble_$cencodeFloat
      GHC.Float.$fRealFloatDouble_$cexponent
      GHC.Float.$fRealFloatDouble_$csignificand
      GHC.Float.$fRealFloatDouble_$cscaleFloat
      GHC.Float.$fRealFloatDouble_$cisNaN
      GHC.Float.$fRealFloatDouble_$cisInfinite
      GHC.Float.$fRealFloatDouble_$cisDenormalized
      GHC.Float.$fRealFloatDouble_$cisNegativeZero
      GHC.Float.$fRealFloatDouble_$cisIEEE
      GHC.Float.$fRealFloatDouble_$catan2

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat3 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fRealFloatFloat3 = GHC.Types.I# -125#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat2 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fRealFloatFloat2 = GHC.Types.I# 128#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat1 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Float.$fRealFloatFloat1
  = (GHC.Float.$fRealFloatFloat3, GHC.Float.$fRealFloatFloat2)

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$cfloatRange :: Float -> (Int, Int)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Float.$fRealFloatFloat1}]
GHC.Float.$fRealFloatFloat_$cfloatRange
  = \ _ [Occ=Dead] -> GHC.Float.$fRealFloatFloat1

Rec {
-- RHS size: {terms: 173, types: 73, coercions: 0, joins: 6/6}
GHC.Float.$w$catan1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: Float -> Float# -> Float#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U(U)><S,U>, Unf=OtherCon []]
GHC.Float.$w$catan1
  = \ (w_s2RyC :: Float) (ww_s2RyG :: Float#) ->
      case gtFloat# ww_s2RyG 0.0# of {
        __DEFAULT ->
          join {
            $j1_s2Miw [Dmd=<L,1*U>] :: Float#
            [LclId[JoinId(0)]]
            $j1_s2Miw
              = join {
                  $j2_s2Mip [Dmd=<L,1*U>] :: Float#
                  [LclId[JoinId(0)]]
                  $j2_s2Mip
                    = join {
                        $j3_s2Mi5 [Dmd=<L,1*U>] :: Float#
                        [LclId[JoinId(0)]]
                        $j3_s2Mi5
                          = case GHC.Float.$w$catan1 (negateFloat w_s2RyC) ww_s2RyG
                            of ww1_s2RyK
                            { __DEFAULT ->
                            negateFloat# ww1_s2RyK
                            } } in
                      join {
                        $j4_s2Mih [Dmd=<L,1*U>] :: Float#
                        [LclId[JoinId(0)]]
                        $j4_s2Mih
                          = join {
                              $j5_s2Mib [Dmd=<L,1*U>] :: Float#
                              [LclId[JoinId(0)]]
                              $j5_s2Mib
                                = case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvk
                                         ww_s2RyG realWorld#
                                  of
                                  { (# ds_d2Kvj, ds1_d2Kvi #) ->
                                  join {
                                    $j6_s2Mi4 [Dmd=<L,1*U>] :: Float#
                                    [LclId[JoinId(0)]]
                                    $j6_s2Mi4
                                      = case w_s2RyC of { F# x_a2KLI ->
                                        case eqFloat# x_a2KLI 0.0# of {
                                          __DEFAULT -> plusFloat# ww_s2RyG x_a2KLI;
                                          1# ->
                                            case ltFloat# ww_s2RyG 0.0# of {
                                              __DEFAULT ->
                                                case ds1_d2Kvi of {
                                                  __DEFAULT -> 3.1415927#;
                                                  0# ->
                                                    case eqFloat# ww_s2RyG 0.0# of {
                                                      __DEFAULT -> plusFloat# ww_s2RyG x_a2KLI;
                                                      1# -> x_a2KLI
                                                    }
                                                };
                                              1# -> 3.1415927#
                                            }
                                        }
                                        } } in
                                  case ds1_d2Kvi of {
                                    __DEFAULT ->
                                      case w_s2RyC of { F# ds3_X2KRI ->
                                      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvk
                                             ds3_X2KRI realWorld#
                                      of
                                      { (# ds4_X2KRP, ds5_X2Lem #) ->
                                      case ds5_X2Lem of {
                                        __DEFAULT -> jump $j3_s2Mi5;
                                        0# -> jump $j6_s2Mi4
                                      }
                                      }
                                      };
                                    0# -> jump $j6_s2Mi4
                                  }
                                  } } in
                            case ltFloat# ww_s2RyG 0.0# of {
                              __DEFAULT -> jump $j5_s2Mib;
                              1# ->
                                case w_s2RyC of { F# ds1_d2Kvh ->
                                case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvk
                                       ds1_d2Kvh realWorld#
                                of
                                { (# ds2_d2Kvj, ds3_d2Kvi #) ->
                                case ds3_d2Kvi of {
                                  __DEFAULT -> jump $j3_s2Mi5;
                                  0# -> jump $j5_s2Mib
                                }
                                }
                                }
                            } } in
                      case leFloat# ww_s2RyG 0.0# of {
                        __DEFAULT -> jump $j4_s2Mih;
                        1# ->
                          case w_s2RyC of { F# x_X2KZl ->
                          case ltFloat# x_X2KZl 0.0# of {
                            __DEFAULT -> jump $j4_s2Mih;
                            1# -> jump $j3_s2Mi5
                          }
                          }
                      } } in
                case ltFloat# ww_s2RyG 0.0# of {
                  __DEFAULT -> jump $j2_s2Mip;
                  1# ->
                    case w_s2RyC of { F# x_X2KZ5 ->
                    case gtFloat# x_X2KZ5 0.0# of {
                      __DEFAULT -> jump $j2_s2Mip;
                      1# ->
                        case divideFloat# x_X2KZ5 ww_s2RyG of wild1_XH { __DEFAULT ->
                        plusFloat# 3.1415927# (atanFloat# wild1_XH)
                        }
                    }
                    }
                } } in
          case eqFloat# ww_s2RyG 0.0# of {
            __DEFAULT -> jump $j1_s2Miw;
            1# ->
              case w_s2RyC of { F# x_X2KZ1 ->
              case gtFloat# x_X2KZ1 0.0# of {
                __DEFAULT -> jump $j1_s2Miw;
                1# -> 1.5707964#
              }
              }
          };
        1# ->
          case w_s2RyC of { F# x_a2I3x ->
          case divideFloat# x_a2I3x ww_s2RyG of wild1_XH { __DEFAULT ->
          atanFloat# wild1_XH
          }
          }
      }
end Rec }

-- RHS size: {terms: 12, types: 5, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat_$catan2 [InlPrag=NOUSERINLINE[0]]
  :: Float -> Float -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2RyC [Occ=Once] :: Float)
                 (w1_s2RyD [Occ=Once!] :: Float) ->
                 case w1_s2RyD of { F# ww1_s2RyG [Occ=Once] ->
                 case GHC.Float.$w$catan1 w_s2RyC ww1_s2RyG of ww2_s2RyK
                 { __DEFAULT ->
                 GHC.Types.F# ww2_s2RyK
                 }
                 }}]
GHC.Float.$fRealFloatFloat_$catan2
  = \ (w_s2RyC :: Float) (w1_s2RyD :: Float) ->
      case w1_s2RyD of { F# ww1_s2RyG ->
      case GHC.Float.$w$catan1 w_s2RyC ww1_s2RyG of ww2_s2RyK
      { __DEFAULT ->
      GHC.Types.F# ww2_s2RyK
      }
      }

-- RHS size: {terms: 17, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fRealFloatFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: RealFloat Float
[GblId[DFunId],
 Unf=DFun: \ ->
       GHC.Float.C:RealFloat TYPE: Float
                             GHC.Float.$fRealFracFloat
                             GHC.Float.$fFloatingFloat
                             GHC.Float.$fRealFloatFloat_$cfloatRadix
                             GHC.Float.$fRealFloatFloat_$cfloatDigits
                             GHC.Float.$fRealFloatFloat_$cfloatRange
                             GHC.Float.$fRealFloatFloat_$cdecodeFloat
                             GHC.Float.$fRealFloatFloat_$cencodeFloat
                             GHC.Float.$fRealFloatFloat_$cexponent
                             GHC.Float.$fRealFloatFloat_$csignificand
                             GHC.Float.$fRealFloatFloat_$cscaleFloat
                             GHC.Float.$fRealFloatFloat_$cisNaN
                             GHC.Float.$fRealFloatFloat_$cisInfinite
                             GHC.Float.$fRealFloatFloat_$cisDenormalized
                             GHC.Float.$fRealFloatFloat_$cisNegativeZero
                             GHC.Float.$fRealFloatFloat_$cisIEEE
                             GHC.Float.$fRealFloatFloat_$catan2]
GHC.Float.$fRealFloatFloat
  = GHC.Float.C:RealFloat
      @ Float
      GHC.Float.$fRealFracFloat
      GHC.Float.$fFloatingFloat
      GHC.Float.$fRealFloatFloat_$cfloatRadix
      GHC.Float.$fRealFloatFloat_$cfloatDigits
      GHC.Float.$fRealFloatFloat_$cfloatRange
      GHC.Float.$fRealFloatFloat_$cdecodeFloat
      GHC.Float.$fRealFloatFloat_$cencodeFloat
      GHC.Float.$fRealFloatFloat_$cexponent
      GHC.Float.$fRealFloatFloat_$csignificand
      GHC.Float.$fRealFloatFloat_$cscaleFloat
      GHC.Float.$fRealFloatFloat_$cisNaN
      GHC.Float.$fRealFloatFloat_$cisInfinite
      GHC.Float.$fRealFloatFloat_$cisDenormalized
      GHC.Float.$fRealFloatFloat_$cisNegativeZero
      GHC.Float.$fRealFloatFloat_$cisIEEE
      GHC.Float.$fRealFloatFloat_$catan2

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.$fShowDouble3 :: Char
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.$fShowDouble3 = GHC.Types.C# '-'#

-- RHS size: {terms: 52, types: 29, coercions: 0, joins: 1/2}
GHC.Float.$w$sshowSignedFloat1 [InlPrag=NOUSERINLINE[0]]
  :: (Float -> ShowS) -> Int -> Float# -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*U(U)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 20 0] 267 0}]
GHC.Float.$w$sshowSignedFloat1
  = \ (w_s2RyM :: Float -> ShowS)
      (w1_s2RyN :: Int)
      (ww_s2RyR :: Float#) ->
      join {
        $j1_s2MiG [Dmd=<L,1*U>] :: ShowS
        [LclId[JoinId(0)]]
        $j1_s2MiG
          = case w1_s2RyN of { I# x_aA1E ->
            let {
              g_s2LT5 [Dmd=<L,C(U)>] :: String -> String
              [LclId]
              g_s2LT5 = w_s2RyM (GHC.Types.F# (negateFloat# ww_s2RyR)) } in
            case ># x_aA1E 6# of {
              __DEFAULT ->
                \ (x1_i1Mhr :: String) ->
                  GHC.Types.: @ Char GHC.Float.$fShowDouble3 (g_s2LT5 x1_i1Mhr);
              1# ->
                \ (x1_i1Mhy :: String) ->
                  GHC.Types.:
                    @ Char
                    GHC.Show.$fShow(,)4
                    (GHC.Types.:
                       @ Char
                       GHC.Float.$fShowDouble3
                       (g_s2LT5 (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x1_i1Mhy)))
            }
            } } in
      case ltFloat# ww_s2RyR 0.0# of {
        __DEFAULT ->
          case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvk
                 ww_s2RyR realWorld#
          of
          { (# ds_d2Kvj, ds1_d2Kvi #) ->
          case ds1_d2Kvi of {
            __DEFAULT -> jump $j1_s2MiG;
            0# -> w_s2RyM (GHC.Types.F# ww_s2RyR)
          }
          };
        1# -> jump $j1_s2MiG
      }

-- RHS size: {terms: 10, types: 6, coercions: 0, joins: 0/0}
GHC.Float.$fShowFloat_$sshowSignedFloat [InlPrag=NOUSERINLINE[0]]
  :: (Float -> ShowS) -> Int -> Float -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2RyM [Occ=Once] :: Float -> ShowS)
                 (w1_s2RyN [Occ=Once] :: Int)
                 (w2_s2RyO [Occ=Once!] :: Float) ->
                 case w2_s2RyO of { F# ww1_s2RyR [Occ=Once] ->
                 GHC.Float.$w$sshowSignedFloat1 w_s2RyM w1_s2RyN ww1_s2RyR
                 }}]
GHC.Float.$fShowFloat_$sshowSignedFloat
  = \ (w_s2RyM :: Float -> ShowS)
      (w1_s2RyN :: Int)
      (w2_s2RyO :: Float) ->
      case w2_s2RyO of { F# ww1_s2RyR ->
      GHC.Float.$w$sshowSignedFloat1 w_s2RyM w1_s2RyN ww1_s2RyR
      }

-- RHS size: {terms: 52, types: 29, coercions: 0, joins: 1/2}
GHC.Float.$w$sshowSignedFloat [InlPrag=NOUSERINLINE[0]]
  :: (Double -> ShowS) -> Int -> Double# -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*U(U)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 20 0] 267 0}]
GHC.Float.$w$sshowSignedFloat
  = \ (w_s2RyU :: Double -> ShowS)
      (w1_s2RyV :: Int)
      (ww_s2RyZ :: Double#) ->
      join {
        $j1_s2MiN [Dmd=<L,1*U>] :: ShowS
        [LclId[JoinId(0)]]
        $j1_s2MiN
          = case w1_s2RyV of { I# x_aA1E ->
            let {
              g_s2LST [Dmd=<L,C(U)>] :: String -> String
              [LclId]
              g_s2LST = w_s2RyU (GHC.Types.D# (negateDouble# ww_s2RyZ)) } in
            case ># x_aA1E 6# of {
              __DEFAULT ->
                \ (x1_i1Mhr :: String) ->
                  GHC.Types.: @ Char GHC.Float.$fShowDouble3 (g_s2LST x1_i1Mhr);
              1# ->
                \ (x1_i1Mhy :: String) ->
                  GHC.Types.:
                    @ Char
                    GHC.Show.$fShow(,)4
                    (GHC.Types.:
                       @ Char
                       GHC.Float.$fShowDouble3
                       (g_s2LST (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x1_i1Mhy)))
            }
            } } in
      case <## ww_s2RyZ 0.0## of {
        __DEFAULT ->
          case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuL
                 ww_s2RyZ realWorld#
          of
          { (# ds_d2KuK, ds1_d2KuJ #) ->
          case ds1_d2KuJ of {
            __DEFAULT -> jump $j1_s2MiN;
            0# -> w_s2RyU (GHC.Types.D# ww_s2RyZ)
          }
          };
        1# -> jump $j1_s2MiN
      }

-- RHS size: {terms: 10, types: 6, coercions: 0, joins: 0/0}
GHC.Float.$fShowDouble_$sshowSignedFloat [InlPrag=NOUSERINLINE[0]]
  :: (Double -> ShowS) -> Int -> Double -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2RyU [Occ=Once] :: Double -> ShowS)
                 (w1_s2RyV [Occ=Once] :: Int)
                 (w2_s2RyW [Occ=Once!] :: Double) ->
                 case w2_s2RyW of { D# ww1_s2RyZ [Occ=Once] ->
                 GHC.Float.$w$sshowSignedFloat w_s2RyU w1_s2RyV ww1_s2RyZ
                 }}]
GHC.Float.$fShowDouble_$sshowSignedFloat
  = \ (w_s2RyU :: Double -> ShowS)
      (w1_s2RyV :: Int)
      (w2_s2RyW :: Double) ->
      case w2_s2RyW of { D# ww1_s2RyZ ->
      GHC.Float.$w$sshowSignedFloat w_s2RyU w1_s2RyV ww1_s2RyZ
      }

-- RHS size: {terms: 63, types: 36, coercions: 0, joins: 1/5}
showSignedFloat
  :: forall a. RealFloat a => (a -> ShowS) -> Int -> a -> ShowS
[GblId,
 Arity=4,
 Str=<S(S(S(LS(LLC(C(S))LLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A)><L,1*C1(U)><L,1*U(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 20 0] 465 0}]
showSignedFloat
  = \ (@ a_a2Iuw)
      ($dRealFloat_a2Iuy :: RealFloat a_a2Iuw)
      (eta_B3 :: a_a2Iuw -> ShowS)
      (eta1_B2 :: Int)
      (eta2_B1 :: a_a2Iuw) ->
      let {
        $dRealFrac_s2LSE [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A)>]
          :: RealFrac a_a2Iuw
        [LclId]
        $dRealFrac_s2LSE
          = GHC.Float.$p1RealFloat @ a_a2Iuw $dRealFloat_a2Iuy } in
      let {
        $dReal_s2LSD [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
          :: Real a_a2Iuw
        [LclId]
        $dReal_s2LSD = GHC.Real.$p1RealFrac @ a_a2Iuw $dRealFrac_s2LSE } in
      let {
        $dNum_s2LSC [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>] :: Num a_a2Iuw
        [LclId]
        $dNum_s2LSC = GHC.Real.$p1Real @ a_a2Iuw $dReal_s2LSD } in
      join {
        $j1_s2MiT [Dmd=<L,1*U>] :: ShowS
        [LclId[JoinId(0)]]
        $j1_s2MiT
          = case eta1_B2 of { I# x_aA1E ->
            let {
              g_s2LSH [Dmd=<L,C(U)>] :: String -> String
              [LclId]
              g_s2LSH = eta_B3 (negate @ a_a2Iuw $dNum_s2LSC eta2_B1) } in
            case ># x_aA1E 6# of {
              __DEFAULT ->
                \ (x1_i1Mhr :: String) ->
                  GHC.Types.: @ Char GHC.Float.$fShowDouble3 (g_s2LSH x1_i1Mhr);
              1# ->
                \ (x1_i1Mhy :: String) ->
                  GHC.Types.:
                    @ Char
                    GHC.Show.$fShow(,)4
                    (GHC.Types.:
                       @ Char
                       GHC.Float.$fShowDouble3
                       (g_s2LSH (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x1_i1Mhy)))
            }
            } } in
      case < @ a_a2Iuw
             (GHC.Real.$p2Real @ a_a2Iuw $dReal_s2LSD)
             eta2_B1
             (fromInteger @ a_a2Iuw $dNum_s2LSC GHC.Float.rationalToDouble5)
      of {
        False ->
          case isNegativeZero @ a_a2Iuw $dRealFloat_a2Iuy eta2_B1 of {
            False -> eta_B3 eta2_B1;
            True -> jump $j1_s2MiT
          };
        True -> jump $j1_s2MiT
      }

-- RHS size: {terms: 35, types: 10, coercions: 0, joins: 0/1}
clamp [InlPrag=NOUSERINLINE[0]] :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2Rz7 [Occ=Once!] :: Int)
                 (w1_s2Rz8 [Occ=Once!] :: Int) ->
                 case w_s2Rz7 of { I# ww1_s2Rzb ->
                 case w1_s2Rz8 of { I# ww3_s2Rzf ->
                 let {
                   x1_at56 [Dmd=<S,U>] :: Int#
                   [LclId]
                   x1_at56 = negateInt# ww1_s2Rzb } in
                 case <=# ww1_s2Rzb ww3_s2Rzf of {
                   __DEFAULT ->
                     case <=# x1_at56 ww3_s2Rzf of {
                       __DEFAULT -> GHC.Types.I# x1_at56;
                       1# -> GHC.Types.I# ww3_s2Rzf
                     };
                   1# ->
                     case <=# x1_at56 ww1_s2Rzb of {
                       __DEFAULT -> GHC.Types.I# x1_at56;
                       1# -> GHC.Types.I# ww1_s2Rzb
                     }
                 }
                 }
                 }}]
clamp
  = \ (w_s2Rz7 :: Int) (w1_s2Rz8 :: Int) ->
      case w_s2Rz7 of ww_s2Rza { I# ww1_s2Rzb ->
      case w1_s2Rz8 of ww2_s2Rze { I# ww3_s2Rzf ->
      let {
        x1_at56 [Dmd=<S,U>] :: Int#
        [LclId]
        x1_at56 = negateInt# ww1_s2Rzb } in
      case <=# ww1_s2Rzb ww3_s2Rzf of {
        __DEFAULT ->
          case <=# x1_at56 ww3_s2Rzf of {
            __DEFAULT -> GHC.Types.I# x1_at56;
            1# -> ww2_s2Rze
          };
        1# ->
          case <=# x1_at56 ww1_s2Rzb of {
            __DEFAULT -> GHC.Types.I# x1_at56;
            1# -> ww_s2Rza
          }
      }
      }
      }

-- RHS size: {terms: 122, types: 60, coercions: 0, joins: 0/5}
GHC.Float.$dmscaleFloat :: forall a. RealFloat a => Int -> a -> a
[GblId,
 Arity=3,
 Str=<L,U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,A,1*C1(U(U)),1*C1(U(1*U(U),1*U(U))),1*C1(U(1*U,1*U(U))),1*C1(C1(U)),A,A,A,1*C1(U),1*C1(U),A,A,A,A)><S(S),1*U(1*U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2HXC) ($dRealFloat_a2IZ3 :: RealFloat a_a2HXC) ->
                 let {
                   $dRealFrac_a2JxJ [Occ=OnceL] :: RealFrac a_a2HXC
                   [LclId]
                   $dRealFrac_a2JxJ
                     = GHC.Float.$p1RealFloat @ a_a2HXC $dRealFloat_a2IZ3 } in
                 let {
                   $dReal_a2JxL :: Real a_a2HXC
                   [LclId]
                   $dReal_a2JxL = GHC.Real.$p1RealFrac @ a_a2HXC $dRealFrac_a2JxJ } in
                 let {
                   $dNum_a2JxN [Occ=OnceL] :: Num a_a2HXC
                   [LclId]
                   $dNum_a2JxN = GHC.Real.$p1Real @ a_a2HXC $dReal_a2JxL } in
                 let {
                   $dOrd_a2JxO [Occ=OnceL] :: Ord a_a2HXC
                   [LclId]
                   $dOrd_a2JxO = GHC.Real.$p2Real @ a_a2HXC $dReal_a2JxL } in
                 let {
                   $dEq_a2JxP [Occ=OnceL] :: Eq a_a2HXC
                   [LclId]
                   $dEq_a2JxP = GHC.Classes.$p1Ord @ a_a2HXC $dOrd_a2JxO } in
                 \ (ds_d2KhH [Occ=Once!] :: Int) (x_a2HXI :: a_a2HXC) ->
                   case ds_d2KhH of { I# ds1_d2KhW [Occ=Once!] ->
                   case ds1_d2KhW of ds2_X2Ki8 {
                     __DEFAULT ->
                       let {
                         ds3_d2Kia :: (Integer, Int)
                         [LclId]
                         ds3_d2Kia = decodeFloat @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXI } in
                       case ==
                              @ a_a2HXC $dEq_a2JxP x_a2HXI (fromInteger @ a_a2HXC $dNum_a2JxN 0)
                       of {
                         False ->
                           case isNaN @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXI of {
                             False ->
                               case isInfinite @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXI of {
                                 False ->
                                   encodeFloat
                                     @ a_a2HXC
                                     $dRealFloat_a2IZ3
                                     (case ds3_d2Kia of { (m_a2J0Y [Occ=Once], _ [Occ=Dead]) ->
                                      m_a2J0Y
                                      })
                                     (case ds3_d2Kia of { (_ [Occ=Dead], n_a2J10 [Occ=Once!]) ->
                                      case n_a2J10 of { I# x1_i1AMi [Occ=Once*] ->
                                      case floatRange @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXI of
                                      { (l_a2J0s [Occ=Once!], h_a2J0u [Occ=Once!]) ->
                                      case h_a2J0u of { I# x2_i1AMw [Occ=Once] ->
                                      case l_a2J0s of { I# y_i1AMA [Occ=Once] ->
                                      case floatDigits @ a_a2HXC $dRealFloat_a2IZ3 x_a2HXI of
                                      { I# y1_i1MAH [Occ=Once] ->
                                      let {
                                        x3_i1AMT :: Int#
                                        [LclId]
                                        x3_i1AMT = +# (-# x2_i1AMw y_i1AMA) (*# 4# y1_i1MAH) } in
                                      let {
                                        x4_at56 :: Int#
                                        [LclId]
                                        x4_at56 = negateInt# x3_i1AMT } in
                                      case <=# x3_i1AMT ds2_X2Ki8 of {
                                        __DEFAULT ->
                                          case <=# x4_at56 ds2_X2Ki8 of {
                                            __DEFAULT -> GHC.Types.I# (+# x1_i1AMi x4_at56);
                                            1# -> GHC.Types.I# (+# x1_i1AMi ds2_X2Ki8)
                                          };
                                        1# ->
                                          case <=# x4_at56 x3_i1AMT of {
                                            __DEFAULT -> GHC.Types.I# (+# x1_i1AMi x4_at56);
                                            1# -> GHC.Types.I# (+# x1_i1AMi x3_i1AMT)
                                          }
                                      }
                                      }
                                      }
                                      }
                                      }
                                      }
                                      });
                                 True -> x_a2HXI
                               };
                             True -> x_a2HXI
                           };
                         True -> x_a2HXI
                       };
                     0# -> x_a2HXI
                   }
                   }}]
GHC.Float.$dmscaleFloat
  = \ (@ a_a2HXC)
      ($dRealFloat_a2IZ3 :: RealFloat a_a2HXC)
      (eta_B2 :: Int)
      (eta1_B1 :: a_a2HXC) ->
      case eta_B2 of { I# ds_d2KhW ->
      case ds_d2KhW of ds1_X2KlY {
        __DEFAULT ->
          let {
            $dRealFrac_s2LSy [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A)>]
              :: RealFrac a_a2HXC
            [LclId]
            $dRealFrac_s2LSy
              = GHC.Float.$p1RealFloat @ a_a2HXC $dRealFloat_a2IZ3 } in
          let {
            $dReal_s2LSx [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
              :: Real a_a2HXC
            [LclId]
            $dReal_s2LSx = GHC.Real.$p1RealFrac @ a_a2HXC $dRealFrac_s2LSy } in
          case ==
                 @ a_a2HXC
                 (GHC.Classes.$p1Ord
                    @ a_a2HXC (GHC.Real.$p2Real @ a_a2HXC $dReal_s2LSx))
                 eta1_B1
                 (fromInteger
                    @ a_a2HXC
                    (GHC.Real.$p1Real @ a_a2HXC $dReal_s2LSx)
                    GHC.Float.rationalToDouble5)
          of {
            False ->
              case isNaN @ a_a2HXC $dRealFloat_a2IZ3 eta1_B1 of {
                False ->
                  case isInfinite @ a_a2HXC $dRealFloat_a2IZ3 eta1_B1 of {
                    False ->
                      let {
                        ds2_s2LSv [Dmd=<L,U(1*U,1*U(U))>] :: (Integer, Int)
                        [LclId]
                        ds2_s2LSv = decodeFloat @ a_a2HXC $dRealFloat_a2IZ3 eta1_B1 } in
                      encodeFloat
                        @ a_a2HXC
                        $dRealFloat_a2IZ3
                        (case ds2_s2LSv of { (m_a2J0Y, n_a2J10) -> m_a2J0Y })
                        (case ds2_s2LSv of { (m_a2J0Y, n_a2J10) ->
                         case n_a2J10 of { I# x_i1AMi ->
                         case floatRange @ a_a2HXC $dRealFloat_a2IZ3 eta1_B1 of
                         { (l_a2J0s, h_a2J0u) ->
                         case h_a2J0u of { I# x1_i1AMw ->
                         case l_a2J0s of { I# y_i1AMA ->
                         case floatDigits @ a_a2HXC $dRealFloat_a2IZ3 eta1_B1 of
                         { I# y1_i1MAH ->
                         let {
                           x2_i1AMT [Dmd=<S,U>] :: Int#
                           [LclId]
                           x2_i1AMT = +# (-# x1_i1AMw y_i1AMA) (*# 4# y1_i1MAH) } in
                         let {
                           x3_at56 [Dmd=<S,U>] :: Int#
                           [LclId]
                           x3_at56 = negateInt# x2_i1AMT } in
                         case <=# x2_i1AMT ds1_X2KlY of {
                           __DEFAULT ->
                             case <=# x3_at56 ds1_X2KlY of {
                               __DEFAULT -> GHC.Types.I# (+# x_i1AMi x3_at56);
                               1# -> GHC.Types.I# (+# x_i1AMi ds1_X2KlY)
                             };
                           1# ->
                             case <=# x3_at56 x2_i1AMT of {
                               __DEFAULT -> GHC.Types.I# (+# x_i1AMi x3_at56);
                               1# -> GHC.Types.I# (+# x_i1AMi x2_i1AMT)
                             }
                         }
                         }
                         }
                         }
                         }
                         }
                         });
                    True -> eta1_B1
                  };
                True -> eta1_B1
              };
            True -> eta1_B1
          };
        0# -> eta1_B1
      }
      }

-- RHS size: {terms: 468, types: 145, coercions: 0, joins: 5/14}
GHC.Float.$wfromRat'' [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Int# -> Int# -> Integer -> Integer -> a
[GblId,
 Arity=5,
 Str=<S(LLLLLLC(C(S))LLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><S,U>,
 Unf=OtherCon []]
GHC.Float.$wfromRat''
  = \ (@ a_s2Rzx)
      (w_s2Rzy :: RealFloat a_s2Rzx)
      (ww_s2RzF :: Int#)
      (ww1_s2RzJ :: Int#)
      (w1_s2RzB :: Integer)
      (w2_s2RzC :: Integer) ->
      join {
        $j1_s2Mkl [Dmd=<C(C(S)),1*C1(C1(U))>] :: Int# -> Int# -> a_s2Rzx
        [LclId[JoinId(2)], Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []]
        $j1_s2Mkl (ipv_s2KIU [OS=OneShot] :: Int#)
                  (ipv1_s2KIV [OS=OneShot] :: Int#)
          = case ipv1_s2KIV of {
              __DEFAULT ->
                let {
                  ds_s2LQG [Dmd=<L,U(1*U,1*U,U)>] :: (Int, Integer, Integer)
                  [LclId]
                  ds_s2LQG
                    = join {
                        $j2_s2RUo [Dmd=<C(S),1*C1(U(1*U,1*U,U))>]
                          :: Int# -> (Int, Integer, Integer)
                        [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []]
                        $j2_s2RUo (ww2_s2Rzn [OS=OneShot] :: Int#)
                          = join {
                              $j3_s2RUj [Dmd=<C(C(S)),1*C1(C1(U(1*U,1*U,U)))>]
                                :: Integer -> Integer -> (Int, Integer, Integer)
                              [LclId[JoinId(2)], Arity=2, Str=<S,U><S,U>m, Unf=OtherCon []]
                              $j3_s2RUj (ww3_s2Rzr [OS=OneShot] :: Integer)
                                        (ww4_s2Rzs [OS=OneShot] :: Integer)
                                = case >=# ww1_s2RzJ 0# of {
                                    __DEFAULT ->
                                      case leInteger#
                                             (shiftRInteger ww4_s2Rzs (negateInt# ww1_s2RzJ))
                                             ww3_s2Rzr
                                      of {
                                        __DEFAULT ->
                                          (GHC.Types.I# (-# ww2_s2Rzn ww1_s2RzJ), ww3_s2Rzr,
                                           ww4_s2Rzs);
                                        1# ->
                                          (GHC.Types.I# (+# (-# ww2_s2Rzn ww1_s2RzJ) 1#), ww3_s2Rzr,
                                           shiftLInteger ww4_s2Rzs 1#)
                                      };
                                    1# ->
                                      case leInteger# (shiftLInteger ww4_s2Rzs ww1_s2RzJ) ww3_s2Rzr
                                      of {
                                        __DEFAULT ->
                                          (GHC.Types.I# (-# ww2_s2Rzn ww1_s2RzJ), ww3_s2Rzr,
                                           ww4_s2Rzs);
                                        1# ->
                                          (GHC.Types.I# (+# (-# ww2_s2Rzn ww1_s2RzJ) 1#), ww3_s2Rzr,
                                           shiftLInteger ww4_s2Rzs 1#)
                                      }
                                  } } in
                            case <# ww2_s2Rzn ww1_s2RzJ of {
                              __DEFAULT ->
                                case ==# ww2_s2Rzn ww1_s2RzJ of {
                                  __DEFAULT ->
                                    jump $j3_s2RUj
                                      w1_s2RzB
                                      (let {
                                         ww3_X1Ckj [Dmd=<S,U>] :: Int#
                                         [LclId]
                                         ww3_X1Ckj = -# ww2_s2Rzn ww1_s2RzJ } in
                                       case >=# ww3_X1Ckj 0# of {
                                         __DEFAULT -> shiftRInteger w2_s2RzC (negateInt# ww3_X1Ckj);
                                         1# -> shiftLInteger w2_s2RzC ww3_X1Ckj
                                       });
                                  1# -> jump $j3_s2RUj w1_s2RzB w2_s2RzC
                                };
                              1# ->
                                jump $j3_s2RUj
                                  (let {
                                     ww3_X1Ckg [Dmd=<S,U>] :: Int#
                                     [LclId]
                                     ww3_X1Ckg = -# ww1_s2RzJ ww2_s2Rzn } in
                                   case >=# ww3_X1Ckg 0# of {
                                     __DEFAULT -> shiftRInteger w1_s2RzB (negateInt# ww3_X1Ckg);
                                     1# -> shiftLInteger w1_s2RzB ww3_X1Ckg
                                   })
                                  w2_s2RzC
                            } } in
                      case w1_s2RzB of {
                        __DEFAULT ->
                          let {
                            y1_at5a [Dmd=<S,U>] :: Int#
                            [LclId]
                            y1_at5a = -# -1# ipv_s2KIU } in
                          case <=# ww_s2RzF y1_at5a of {
                            __DEFAULT -> jump $j2_s2RUo ww_s2RzF;
                            1# -> jump $j2_s2RUo y1_at5a
                          };
                        integer-simple-0.1.1.1:GHC.Integer.Type.Positive digits_a2JNS ->
                          case GHC.Integer.Logarithms.Internals.integerLog2#_step
                                 0# digits_a2JNS
                          of wild2_X5e
                          { __DEFAULT ->
                          let {
                            y1_at5a [Dmd=<S,U>] :: Int#
                            [LclId]
                            y1_at5a = -# wild2_X5e ipv_s2KIU } in
                          case <=# ww_s2RzF y1_at5a of {
                            __DEFAULT -> jump $j2_s2RUo ww_s2RzF;
                            1# -> jump $j2_s2RUo y1_at5a
                          }
                          }
                      } } in
                encodeFloat
                  @ a_s2Rzx
                  w_s2Rzy
                  (case ds_s2LQG of { (p'_a2Izj, n''_a2Izl, d''_a2Izn) ->
                   case eqInteger# d''_a2Izn GHC.Float.rationalToDouble5 of {
                     __DEFAULT ->
                       case quotRemInteger n''_a2Izl d''_a2Izn of
                       { (# ipv2_i2KJl, ipv3_i2KJm #) ->
                       case compareInteger (shiftLInteger ipv3_i2KJm 1#) d''_a2Izn of {
                         LT -> ipv2_i2KJl;
                         EQ ->
                           case integerToInt ipv2_i2KJl of wild4_i1AOp { __DEFAULT ->
                           case andI# wild4_i1AOp 1# of {
                             __DEFAULT -> plusInteger ipv2_i2KJl GHC.Float.$fRealDouble1;
                             0# -> ipv2_i2KJl
                           }
                           };
                         GT -> plusInteger ipv2_i2KJl GHC.Float.$fRealDouble1
                       }
                       };
                     1# -> case divZeroError of wild3_00 { }
                   }
                   })
                  (case ds_s2LQG of { (p'_a2Izj, n''_a2Izl, d''_a2Izn) ->
                   p'_a2Izj
                   });
              0# ->
                join {
                  $j2_s2Mkf [Dmd=<C(S),1*C1(U)>] :: Int# -> a_s2Rzx
                  [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                  $j2_s2Mkf (ln#_a2I37 [OS=OneShot]
                               :: Int#
                               Unf=OtherCon [])
                    = case >=# ln#_a2I37 (-# (+# ipv_s2KIU ww_s2RzF) 1#) of {
                        __DEFAULT ->
                          let {
                            ld'#_s2LQR [Dmd=<S,U>] :: Int#
                            [LclId]
                            ld'#_s2LQR = +# ipv_s2KIU (-# ww_s2RzF ww1_s2RzJ) } in
                          case <=# ld'#_s2LQR 0# of {
                            __DEFAULT ->
                              case <=# ld'#_s2LQR ln#_a2I37 of {
                                __DEFAULT ->
                                  case ># ld'#_s2LQR (+# ln#_a2I37 1#) of {
                                    __DEFAULT ->
                                      case w1_s2RzB of {
                                        __DEFAULT ->
                                          encodeFloat
                                            @ a_s2Rzx
                                            w_s2Rzy
                                            GHC.Float.$fRealDouble1
                                            (GHC.Types.I# (-# ww_s2RzF ww1_s2RzJ));
                                        integer-simple-0.1.1.1:GHC.Integer.Type.Positive digits_a2JNL ->
                                          case GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe
                                                 0# digits_a2JNL
                                          of
                                          { (# ipv2_s2KJC, ipv3_s2KJD #) ->
                                          case ipv3_s2KJD of {
                                            __DEFAULT ->
                                              encodeFloat
                                                @ a_s2Rzx
                                                w_s2Rzy
                                                GHC.Float.$fRealDouble1
                                                (GHC.Types.I# (-# ww_s2RzF ww1_s2RzJ));
                                            0# ->
                                              encodeFloat
                                                @ a_s2Rzx
                                                w_s2Rzy
                                                GHC.Float.rationalToDouble5
                                                minExpt
                                          }
                                          }
                                      };
                                    1# ->
                                      encodeFloat
                                        @ a_s2Rzx w_s2Rzy GHC.Float.rationalToDouble5 minExpt
                                  };
                                1# ->
                                  let {
                                    n'_s2LQS :: Integer
                                    [LclId]
                                    n'_s2LQS
                                      = let {
                                          i#_s2LQQ [Dmd=<S,U>] :: Int#
                                          [LclId]
                                          i#_s2LQQ = negateInt# ld'#_s2LQR } in
                                        case >=# i#_s2LQQ 0# of {
                                          __DEFAULT -> shiftRInteger w1_s2RzB (negateInt# i#_s2LQQ);
                                          1# -> shiftLInteger w1_s2RzB i#_s2LQQ
                                        } } in
                                  case roundingMode# w1_s2RzB (-# ld'#_s2LQR 1#) of {
                                    __DEFAULT ->
                                      encodeFloat
                                        @ a_s2Rzx
                                        w_s2Rzy
                                        (plusInteger n'_s2LQS GHC.Float.$fRealDouble1)
                                        (GHC.Types.I# (-# ww_s2RzF ww1_s2RzJ));
                                    0# ->
                                      encodeFloat
                                        @ a_s2Rzx
                                        w_s2Rzy
                                        n'_s2LQS
                                        (GHC.Types.I# (-# ww_s2RzF ww1_s2RzJ));
                                    1# ->
                                      case integerToInt n'_s2LQS of wild1_i1AOp { __DEFAULT ->
                                      case andI# wild1_i1AOp 1# of {
                                        __DEFAULT ->
                                          encodeFloat
                                            @ a_s2Rzx
                                            w_s2Rzy
                                            (plusInteger n'_s2LQS GHC.Float.$fRealDouble1)
                                            (GHC.Types.I# (-# ww_s2RzF ww1_s2RzJ));
                                        0# ->
                                          encodeFloat
                                            @ a_s2Rzx
                                            w_s2Rzy
                                            n'_s2LQS
                                            (GHC.Types.I# (-# ww_s2RzF ww1_s2RzJ))
                                      }
                                      }
                                  }
                              };
                            1# ->
                              encodeFloat
                                @ a_s2Rzx
                                w_s2Rzy
                                w1_s2RzB
                                (GHC.Types.I# (-# (-# ww_s2RzF ww1_s2RzJ) ld'#_s2LQR))
                          };
                        1# ->
                          case <# ln#_a2I37 ww1_s2RzJ of {
                            __DEFAULT ->
                              encodeFloat
                                @ a_s2Rzx
                                w_s2Rzy
                                (let {
                                   i#_s2LQV [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   i#_s2LQV = negateInt# (-# (+# ln#_a2I37 1#) ww1_s2RzJ) } in
                                 join {
                                   $j3_s2RUP [Dmd=<C(S),1*C1(U)>] :: Integer -> Integer
                                   [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   $j3_s2RUP (n'_s2LQW [OS=OneShot] :: Integer)
                                     = case roundingMode# w1_s2RzB (-# ln#_a2I37 ww1_s2RzJ) of {
                                         __DEFAULT ->
                                           case integerToInt n'_s2LQW of wild1_i1AOp { __DEFAULT ->
                                           case andI# wild1_i1AOp 1# of {
                                             __DEFAULT ->
                                               plusInteger n'_s2LQW GHC.Float.$fRealDouble1;
                                             0# -> n'_s2LQW
                                           }
                                           };
                                         0# -> n'_s2LQW;
                                         2# -> plusInteger n'_s2LQW GHC.Float.$fRealDouble1
                                       } } in
                                 case >=# i#_s2LQV 0# of {
                                   __DEFAULT ->
                                     jump $j3_s2RUP (shiftRInteger w1_s2RzB (negateInt# i#_s2LQV));
                                   1# -> jump $j3_s2RUP (shiftLInteger w1_s2RzB i#_s2LQV)
                                 })
                                (GHC.Types.I# (-# (+# (-# ln#_a2I37 ipv_s2KIU) 1#) ww1_s2RzJ));
                            1# ->
                              encodeFloat
                                @ a_s2Rzx w_s2Rzy w1_s2RzB (GHC.Types.I# (negateInt# ipv_s2KIU))
                          }
                      } } in
                case w1_s2RzB of {
                  __DEFAULT -> jump $j2_s2Mkf -1#;
                  integer-simple-0.1.1.1:GHC.Integer.Type.Positive digits_a2JNS ->
                    case GHC.Integer.Logarithms.Internals.integerLog2#_step
                           0# digits_a2JNS
                    of ln#_a2I37
                    { __DEFAULT ->
                    jump $j2_s2Mkf ln#_a2I37
                    }
                }
            } } in
      case w2_s2RzC of {
        __DEFAULT -> jump $j1_s2Mkl -1# 1#;
        integer-simple-0.1.1.1:GHC.Integer.Type.Positive digits_a2JNL ->
          case GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe
                 0# digits_a2JNL
          of
          { (# ipv_s2KIU, ipv1_s2KIV #) ->
          jump $j1_s2Mkl ipv_s2KIU ipv1_s2KIV
          }
      }

-- RHS size: {terms: 18, types: 13, coercions: 0, joins: 0/0}
fromRat'' [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Int -> Int -> Integer -> Integer -> a
[GblId,
 Arity=5,
 Str=<S(LLLLLLC(C(S))LLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A)><S(S),1*U(U)><S(S),1*U(U)><L,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s2Rzx)
                 (w_s2Rzy [Occ=Once] :: RealFloat a_s2Rzx)
                 (w1_s2Rzz [Occ=Once!] :: Int)
                 (w2_s2RzA [Occ=Once!] :: Int)
                 (w3_s2RzB [Occ=Once] :: Integer)
                 (w4_s2RzC [Occ=Once] :: Integer) ->
                 case w1_s2Rzz of { I# ww1_s2RzF [Occ=Once] ->
                 case w2_s2RzA of { I# ww3_s2RzJ [Occ=Once] ->
                 GHC.Float.$wfromRat''
                   @ a_s2Rzx w_s2Rzy ww1_s2RzF ww3_s2RzJ w3_s2RzB w4_s2RzC
                 }
                 }}]
fromRat''
  = \ (@ a_s2Rzx)
      (w_s2Rzy :: RealFloat a_s2Rzx)
      (w1_s2Rzz :: Int)
      (w2_s2RzA :: Int)
      (w3_s2RzB :: Integer)
      (w4_s2RzC :: Integer) ->
      case w1_s2Rzz of { I# ww1_s2RzF ->
      case w2_s2RzA of { I# ww3_s2RzJ ->
      GHC.Float.$wfromRat''
        @ a_s2Rzx w_s2Rzy ww1_s2RzF ww3_s2RzJ w3_s2RzB w4_s2RzC
      }
      }

-- RHS size: {terms: 47, types: 14, coercions: 0, joins: 0/1}
GHC.Float.$w$cfromEnum [InlPrag=NOUSERINLINE[0]] :: Double# -> Int#
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 256 0}]
GHC.Float.$w$cfromEnum
  = \ (ww_s2RzP :: Double#) ->
      case decodeDoubleInteger ww_s2RzP of
      { (# ipv_i2Kwd, ipv1_i2Kwe #) ->
      case <# ipv1_i2Kwe 0# of {
        __DEFAULT -> integerToInt (shiftLInteger ipv_i2Kwd ipv1_i2Kwe);
        1# ->
          let {
            s_s2LQA [Dmd=<S,U>] :: Int#
            [LclId]
            s_s2LQA = negateInt# ipv1_i2Kwe } in
          case ># s_s2LQA 52# of {
            __DEFAULT ->
              case ltInteger# ipv_i2Kwd GHC.Float.rationalToDouble5 of {
                __DEFAULT ->
                  case integerToInt ipv_i2Kwd of n_i2Kwk { __DEFAULT ->
                  uncheckedIShiftRA# n_i2Kwk s_s2LQA
                  };
                1# ->
                  case integerToInt (negateInteger ipv_i2Kwd) of n_i2Kwl
                  { __DEFAULT ->
                  negateInt# (uncheckedIShiftRA# n_i2Kwl s_s2LQA)
                  }
              };
            1# -> 0#
          }
      }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Float.$fEnumDouble_$cfromEnum [InlPrag=NOUSERINLINE[0]]
  :: Double -> Int
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2RzM [Occ=Once!] :: Double) ->
                 case w_s2RzM of { D# ww1_s2RzP [Occ=Once] ->
                 case GHC.Float.$w$cfromEnum ww1_s2RzP of ww2_s2RzT { __DEFAULT ->
                 GHC.Types.I# ww2_s2RzT
                 }
                 }}]
GHC.Float.$fEnumDouble_$cfromEnum
  = \ (w_s2RzM :: Double) ->
      case w_s2RzM of { D# ww1_s2RzP ->
      case GHC.Float.$w$cfromEnum ww1_s2RzP of ww2_s2RzT { __DEFAULT ->
      GHC.Types.I# ww2_s2RzT
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fEnumDouble_$cenumFromTo :: Double -> Double -> [Double]
[GblId,
 Arity=2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 60}]
GHC.Float.$fEnumDouble_$cenumFromTo
  = numericEnumFromTo
      @ Double GHC.Classes.$fOrdDouble GHC.Float.$fFractionalDouble

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fEnumDouble_$cenumFromThenTo
  :: Double -> Double -> Double -> [Double]
[GblId,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 60}]
GHC.Float.$fEnumDouble_$cenumFromThenTo
  = numericEnumFromThenTo
      @ Double GHC.Classes.$fOrdDouble GHC.Float.$fFractionalDouble

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fEnumDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum Double
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Double
                       GHC.Float.$fEnumDouble_$csucc
                       GHC.Float.$fEnumDouble_$cpred
                       int2Double
                       GHC.Float.$fEnumDouble_$cfromEnum
                       GHC.Float.$fEnumDouble_$snumericEnumFrom
                       GHC.Float.$fEnumDouble_$snumericEnumFromThen
                       GHC.Float.$fEnumDouble_$cenumFromTo
                       GHC.Float.$fEnumDouble_$cenumFromThenTo]
GHC.Float.$fEnumDouble
  = GHC.Enum.C:Enum
      @ Double
      GHC.Float.$fEnumDouble_$csucc
      GHC.Float.$fEnumDouble_$cpred
      int2Double
      GHC.Float.$fEnumDouble_$cfromEnum
      GHC.Float.$fEnumDouble_$snumericEnumFrom
      GHC.Float.$fEnumDouble_$snumericEnumFromThen
      GHC.Float.$fEnumDouble_$cenumFromTo
      GHC.Float.$fEnumDouble_$cenumFromThenTo

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fEnumFloat_$cenumFromTo :: Float -> Float -> [Float]
[GblId,
 Arity=2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 60}]
GHC.Float.$fEnumFloat_$cenumFromTo
  = numericEnumFromTo
      @ Float GHC.Classes.$fOrdFloat GHC.Float.$fFractionalFloat

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fEnumFloat_$cenumFromThenTo
  :: Float -> Float -> Float -> [Float]
[GblId,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 60}]
GHC.Float.$fEnumFloat_$cenumFromThenTo
  = numericEnumFromThenTo
      @ Float GHC.Classes.$fOrdFloat GHC.Float.$fFractionalFloat

-- RHS size: {terms: 40, types: 12, coercions: 0, joins: 0/1}
GHC.Float.$w$cfromEnum1 [InlPrag=NOUSERINLINE[0]] :: Float# -> Int#
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
GHC.Float.$w$cfromEnum1
  = \ (ww_s2RzY :: Float#) ->
      case decodeFloat_Int# ww_s2RzY of { (# ipv_i2Ky9, ipv1_i2Kya #) ->
      case <# ipv1_i2Kya 0# of {
        __DEFAULT ->
          integerToInt (shiftLInteger (smallInteger ipv_i2Ky9) ipv1_i2Kya);
        1# ->
          let {
            s_s2LQy [Dmd=<S,U>] :: Int#
            [LclId]
            s_s2LQy = negateInt# ipv1_i2Kya } in
          case ># s_s2LQy 23# of {
            __DEFAULT ->
              case <# ipv_i2Ky9 0# of {
                __DEFAULT -> uncheckedIShiftRL# ipv_i2Ky9 s_s2LQy;
                1# ->
                  negateInt# (uncheckedIShiftRA# (negateInt# ipv_i2Ky9) s_s2LQy)
              };
            1# -> 0#
          }
      }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Float.$fEnumFloat_$cfromEnum [InlPrag=NOUSERINLINE[0]]
  :: Float -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2RzV [Occ=Once!] :: Float) ->
                 case w_s2RzV of { F# ww1_s2RzY [Occ=Once] ->
                 case GHC.Float.$w$cfromEnum1 ww1_s2RzY of ww2_s2RA2 { __DEFAULT ->
                 GHC.Types.I# ww2_s2RA2
                 }
                 }}]
GHC.Float.$fEnumFloat_$cfromEnum
  = \ (w_s2RzV :: Float) ->
      case w_s2RzV of { F# ww1_s2RzY ->
      case GHC.Float.$w$cfromEnum1 ww1_s2RzY of ww2_s2RA2 { __DEFAULT ->
      GHC.Types.I# ww2_s2RA2
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fEnumFloat [InlPrag=NOUSERINLINE CONLIKE] :: Enum Float
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Float
                       GHC.Float.$fEnumFloat_$csucc
                       GHC.Float.$fEnumFloat_$cpred
                       int2Float
                       GHC.Float.$fEnumFloat_$cfromEnum
                       GHC.Float.$fEnumFloat_$snumericEnumFrom
                       GHC.Float.$fEnumFloat_$snumericEnumFromThen
                       GHC.Float.$fEnumFloat_$cenumFromTo
                       GHC.Float.$fEnumFloat_$cenumFromThenTo]
GHC.Float.$fEnumFloat
  = GHC.Enum.C:Enum
      @ Float
      GHC.Float.$fEnumFloat_$csucc
      GHC.Float.$fEnumFloat_$cpred
      int2Float
      GHC.Float.$fEnumFloat_$cfromEnum
      GHC.Float.$fEnumFloat_$snumericEnumFrom
      GHC.Float.$fEnumFloat_$snumericEnumFromThen
      GHC.Float.$fEnumFloat_$cenumFromTo
      GHC.Float.$fEnumFloat_$cenumFromThenTo

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
GHC.Float.expt1 :: Int -> Int -> Int -> Int
[GblId, Arity=3, Str=<B,U><B,U><B,U>x, Unf=OtherCon []]
GHC.Float.expt1
  = \ (u_a1KXA :: Int) (l_a1KXz :: Int) (n_a2I2U :: Int) ->
      GHC.Arr.$windexError
        @ Int @ Int GHC.Show.$fShowInt l_a1KXz u_a1KXA n_a2I2U lvl7_r2UqF

-- RHS size: {terms: 150, types: 56, coercions: 0, joins: 1/2}
GHC.Float.$wexpt [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Int# -> Integer
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 60] 649 0}]
GHC.Float.$wexpt
  = \ (w_s2RA4 :: Integer) (ww_s2RA8 :: Int#) ->
      case eqInteger# w_s2RA4 GHC.Float.$fRealFloatDouble5 of wild_a1foK
      { __DEFAULT ->
      let {
        n_a2I2U :: Int
        [LclId, Unf=OtherCon []]
        n_a2I2U = GHC.Types.I# ww_s2RA8 } in
      join {
        $j1_s2MkY [Dmd=<L,1*U>] :: Integer
        [LclId[JoinId(0)]]
        $j1_s2MkY
          = case eqInteger# w_s2RA4 GHC.Float.expts4 of {
              __DEFAULT ->
                case <# ww_s2RA8 0# of {
                  __DEFAULT ->
                    case ww_s2RA8 of wild2_i2Nx7 {
                      __DEFAULT -> GHC.Real.$wf w_s2RA4 wild2_i2Nx7;
                      0# -> GHC.Real.$fEnumRatio1
                    };
                  1# -> GHC.Real.^1
                };
              1# ->
                case <=# ww_s2RA8 324# of {
                  __DEFAULT ->
                    case <# ww_s2RA8 0# of {
                      __DEFAULT ->
                        case ww_s2RA8 of wild2_i2Nx7 {
                          __DEFAULT -> GHC.Real.$wf w_s2RA4 wild2_i2Nx7;
                          0# -> GHC.Real.$fEnumRatio1
                        };
                      1# -> GHC.Real.^1
                    };
                  1# ->
                    case expts10 of { Array l_a1KXz u_a1KXA dt_d1MtM ds_d1MbY ->
                    case l_a1KXz of wild3_s2SPw { I# m_s2SPx ->
                    case u_a1KXA of wild4_s2SPz { I# n1_s2SPA ->
                    case <=# m_s2SPx ww_s2RA8 of {
                      __DEFAULT ->
                        case GHC.Float.expt1 wild4_s2SPz wild3_s2SPw n_a2I2U of wild5_00 {
                        };
                      1# ->
                        case <=# ww_s2RA8 n1_s2SPA of {
                          __DEFAULT ->
                            case GHC.Float.expt1 wild4_s2SPz wild3_s2SPw n_a2I2U of wild5_00 {
                            };
                          1# ->
                            case indexArray# @ Integer ds_d1MbY (-# ww_s2RA8 m_s2SPx) of
                            { (# ipv_s1MGr #) ->
                            ipv_s1MGr
                            }
                        }
                    }
                    }
                    }
                    }
                }
            } } in
      case wild_a1foK of {
        __DEFAULT -> jump $j1_s2MkY;
        1# ->
          case >=# ww_s2RA8 0# of {
            __DEFAULT -> jump $j1_s2MkY;
            1# ->
              case <=# ww_s2RA8 1100# of {
                __DEFAULT -> jump $j1_s2MkY;
                1# ->
                  case expts of { Array l_a1KXz u_a1KXA dt_d1MtM ds_d1MbY ->
                  case l_a1KXz of wild2_s2SPE { I# m_s2SPF ->
                  case u_a1KXA of wild3_s2SPH { I# n1_s2SPI ->
                  case <=# m_s2SPF ww_s2RA8 of {
                    __DEFAULT ->
                      case GHC.Float.expt1 wild3_s2SPH wild2_s2SPE n_a2I2U of wild4_00 {
                      };
                    1# ->
                      case <=# ww_s2RA8 n1_s2SPI of {
                        __DEFAULT ->
                          case GHC.Float.expt1 wild3_s2SPH wild2_s2SPE n_a2I2U of wild4_00 {
                          };
                        1# ->
                          case indexArray# @ Integer ds_d1MbY (-# ww_s2RA8 m_s2SPF) of
                          { (# ipv_s1MGr #) ->
                          ipv_s1MGr
                          }
                      }
                  }
                  }
                  }
                  }
              }
          }
      }
      }

-- RHS size: {terms: 8, types: 4, coercions: 0, joins: 0/0}
expt [InlPrag=NOUSERINLINE[0]] :: Integer -> Int -> Integer
[GblId,
 Arity=2,
 Str=<S,U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2RA4 [Occ=Once] :: Integer)
                 (w1_s2RA5 [Occ=Once!] :: Int) ->
                 case w1_s2RA5 of { I# ww1_s2RA8 [Occ=Once] ->
                 GHC.Float.$wexpt w_s2RA4 ww1_s2RA8
                 }}]
expt
  = \ (w_s2RA4 :: Integer) (w1_s2RA5 :: Int) ->
      case w1_s2RA5 of { I# ww1_s2RA8 ->
      GHC.Float.$wexpt w_s2RA4 ww1_s2RA8
      }

-- RHS size: {terms: 157, types: 98, coercions: 0, joins: 2/7}
fromRat' :: forall a. RealFloat a => Rational -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(C(S))LLLLLLLLL),U(A,A,C(U),C(U(U)),C(U(1*U(U),A)),A,C(C1(U)),A,A,A,A,A,A,A,A,A)><L,U(U,U)>,
 Unf=OtherCon []]
fromRat'
  = \ (@ a_a2IBO)
      ($dRealFloat_a2IBQ :: RealFloat a_a2IBO)
      (x_a2I2H :: Rational) ->
      letrec {
        r_s2LQp :: a_a2IBO
        [LclId]
        r_s2LQp
          = encodeFloat
              @ a_a2IBO
              $dRealFloat_a2IBQ
              (case ds_s2LQo of { (x'_X2IHx, p'_X2IHA) ->
               case x'_X2IHx of { :% ww1_i2KTp ww2_i2KTq ->
               GHC.Real.$w$s$cround
                 @ Integer GHC.Real.$fIntegralInteger ww1_i2KTp ww2_i2KTq
               }
               })
              (case ds_s2LQo of { (x'_X2IHx, p'_X2IHA) -> p'_X2IHA });
        b_s2LQn :: Integer
        [LclId]
        b_s2LQn = floatRadix @ a_a2IBO $dRealFloat_a2IBQ r_s2LQp;
        ds_s2LQo [Occ=LoopBreaker] :: (Rational, Int)
        [LclId]
        ds_s2LQo
          = case floatDigits @ a_a2IBO $dRealFloat_a2IBQ r_s2LQp of
            { I# ww1_s2RA8 ->
            case GHC.Float.$wexpt b_s2LQn ww1_s2RA8 of dt_i2KUr { __DEFAULT ->
            case x_a2I2H of { :% x1_i2JWY ds1_i2JWZ ->
            case GHC.Float.$wintegerLogBase b_s2LQn x1_i2JWY of ww2_s2Ryq
            { __DEFAULT ->
            case GHC.Float.$wintegerLogBase b_s2LQn ds1_i2JWZ of ww3_X2RSg
            { __DEFAULT ->
            case floatRange @ a_a2IBO $dRealFloat_a2IBQ r_s2LQp of
            { (minExp0_X2IHS, ds2_d2JXV) ->
            case minExp0_X2IHS of { I# x2_X1Ba2 ->
            let {
              x3_at56 [Dmd=<S,U>] :: Int#
              [LclId]
              x3_at56 = -# (-# ww2_s2Ryq ww3_X2RSg) ww1_s2RA8 } in
            let {
              y1_at5a [Dmd=<S,U>] :: Int#
              [LclId]
              y1_at5a = -# x2_X1Ba2 ww1_s2RA8 } in
            join {
              $j1_s2PHv [Dmd=<C(C(S)),1*C1(C1(U(U,U)))>]
                :: Int# -> Int -> (Rational, Int)
              [LclId[JoinId(2)], Arity=2, Str=<S,U><L,U>m, Unf=OtherCon []]
              $j1_s2PHv (x4_alN9 [OS=OneShot] :: Int#)
                        (wild3_alN7 [OS=OneShot]
                           :: Int
                           Unf=OtherCon [])
                = join {
                    $j2_s2PmA [Dmd=<C(C(C(S))),1*C1(C1(C1(U(U,U))))>]
                      :: Integer -> Integer -> Ratio Integer -> (Rational, Int)
                    [LclId[JoinId(3)], Arity=3, Str=<S,U><S,U><L,U>m, Unf=OtherCon []]
                    $j2_s2PmA (ww4_i2KUg [OS=OneShot]
                                 :: Integer
                                 Unf=OtherCon [])
                              (ww5_i2KUh [OS=OneShot]
                                 :: Integer
                                 Unf=OtherCon [])
                              (ww6_i2KUe [OS=OneShot]
                                 :: Ratio Integer
                                 Unf=OtherCon [])
                      = case GHC.Real.$w$s$ccompare
                               ww4_i2KUg ww5_i2KUh dt_i2KUr GHC.Real.$fEnumRatio1
                        of {
                          __DEFAULT ->
                            (case GHC.Real.$w$s$c/
                                    ww4_i2KUg ww5_i2KUh b_s2LQn GHC.Real.$fEnumRatio1
                             of
                             { (# ww8_i2KTT, ww9_i2KTU #) ->
                             GHC.Real.:% @ Integer ww8_i2KTT ww9_i2KTU
                             },
                             GHC.Types.I# (+# x4_alN9 1#));
                          LT -> (ww6_i2KUe, wild3_alN7)
                        } } in
                  case <# x4_alN9 0# of {
                    __DEFAULT ->
                      case GHC.Float.$wexpt b_s2LQn x4_alN9 of dt1_X2pmK { __DEFAULT ->
                      case GHC.Real.$w$s$c/
                             x1_i2JWY ds1_i2JWZ dt1_X2pmK GHC.Float.$fRealDouble1
                      of
                      { (# ww7_i2KTT, ww8_i2KTU #) ->
                      jump $j2_s2PmA
                        ww7_i2KTT ww8_i2KTU (GHC.Real.:% @ Integer ww7_i2KTT ww8_i2KTU)
                      }
                      };
                    1# ->
                      case GHC.Float.$wexpt b_s2LQn (negateInt# x4_alN9) of dt1_X2pmM
                      { __DEFAULT ->
                      case GHC.Real.$w$s$c/
                             x1_i2JWY ds1_i2JWZ GHC.Float.$fRealDouble1 dt1_X2pmM
                      of
                      { (# ww7_i2KTT, ww8_i2KTU #) ->
                      jump $j2_s2PmA
                        ww7_i2KTT ww8_i2KTU (GHC.Real.:% @ Integer ww7_i2KTT ww8_i2KTU)
                      }
                      }
                  } } in
            case <=# x3_at56 y1_at5a of {
              __DEFAULT -> jump $j1_s2PHv x3_at56 (GHC.Types.I# x3_at56);
              1# -> jump $j1_s2PHv y1_at5a (GHC.Types.I# y1_at5a)
            }
            }
            }
            }
            }
            }
            }
            }; } in
      r_s2LQp

-- RHS size: {terms: 92, types: 40, coercions: 0, joins: 0/3}
GHC.Float.$wfromRat [InlPrag=NOINLINE[1]]
  :: forall a. RealFloat a => Integer -> Integer -> a
[GblId,
 Arity=3,
 Str=<L,U(1*U(1*U(1*U(A,A,A,1*C1(U),A,A,C(U)),A,A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),A,C(C1(U)),A,A,A,A,A,A,A,A,A)><S,U><S,U>,
 Unf=OtherCon []]
GHC.Float.$wfromRat
  = \ (@ a_s2RAj)
      (w_s2RAk :: RealFloat a_s2RAj)
      (ww_s2RAo
         :: Integer
         Unf=OtherCon [])
      (ww1_s2RAp
         :: Integer
         Unf=OtherCon []) ->
      let {
        $dRealFrac_s2LQl [Dmd=<L,U(1*U(1*U(A,A,A,1*C1(U),A,A,C(U)),A,A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A)>]
          :: RealFrac a_s2RAj
        [LclId]
        $dRealFrac_s2LQl = GHC.Float.$p1RealFloat @ a_s2RAj w_s2RAk } in
      let {
        $dReal_s2LQk [Dmd=<L,1*U(1*U(A,A,A,1*C1(U),A,A,C(U)),A,A)>]
          :: Real a_s2RAj
        [LclId]
        $dReal_s2LQk = GHC.Real.$p1RealFrac @ a_s2RAj $dRealFrac_s2LQl } in
      let {
        $dNum_s2LQj [Dmd=<L,U(A,A,A,1*C1(U),A,A,C(U))>] :: Num a_s2RAj
        [LclId]
        $dNum_s2LQj = GHC.Real.$p1Real @ a_s2RAj $dReal_s2LQk } in
      case eqInteger# ww1_s2RAp GHC.Float.rationalToDouble5 of {
        __DEFAULT ->
          case gtInteger# ww_s2RAo GHC.Float.rationalToDouble5 of {
            __DEFAULT ->
              case ltInteger# ww_s2RAo GHC.Float.rationalToDouble5 of {
                __DEFAULT ->
                  encodeFloat @ a_s2RAj w_s2RAk GHC.Float.rationalToDouble5 minExpt;
                1# ->
                  negate
                    @ a_s2RAj
                    $dNum_s2LQj
                    (fromRat'
                       @ a_s2RAj
                       w_s2RAk
                       (case negateInteger ww_s2RAo of dt_X2pmK { __DEFAULT ->
                        GHC.Real.:% @ Integer dt_X2pmK ww1_s2RAp
                        }))
              };
            1# ->
              fromRat'
                @ a_s2RAj w_s2RAk (GHC.Real.:% @ Integer ww_s2RAo ww1_s2RAp)
          };
        1# ->
          case gtInteger# ww_s2RAo GHC.Float.rationalToDouble5 of {
            __DEFAULT ->
              case ltInteger# ww_s2RAo GHC.Float.rationalToDouble5 of {
                __DEFAULT ->
                  / @ a_s2RAj
                    (GHC.Real.$p2RealFrac @ a_s2RAj $dRealFrac_s2LQl)
                    (fromInteger @ a_s2RAj $dNum_s2LQj GHC.Float.rationalToDouble5)
                    (fromInteger @ a_s2RAj $dNum_s2LQj GHC.Float.rationalToDouble5);
                1# ->
                  negate
                    @ a_s2RAj
                    $dNum_s2LQj
                    (/ @ a_s2RAj
                       (GHC.Real.$p2RealFrac @ a_s2RAj $dRealFrac_s2LQl)
                       (fromInteger @ a_s2RAj $dNum_s2LQj GHC.Float.$fRealDouble1)
                       (fromInteger @ a_s2RAj $dNum_s2LQj GHC.Float.rationalToDouble5))
              };
            1# ->
              / @ a_s2RAj
                (GHC.Real.$p2RealFrac @ a_s2RAj $dRealFrac_s2LQl)
                (fromInteger @ a_s2RAj $dNum_s2LQj GHC.Float.$fRealDouble1)
                (fromInteger @ a_s2RAj $dNum_s2LQj GHC.Float.rationalToDouble5)
          }
      }

-- RHS size: {terms: 10, types: 9, coercions: 0, joins: 0/0}
fromRat [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Rational -> a
[GblId,
 Arity=2,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),A,C(C1(U)),A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s2RAj)
                 (w_s2RAk [Occ=Once] :: RealFloat a_s2RAj)
                 (w1_s2RAl [Occ=Once!] :: Rational) ->
                 case w1_s2RAl of { :% ww1_s2RAo [Occ=Once] ww2_s2RAp [Occ=Once] ->
                 GHC.Float.$wfromRat @ a_s2RAj w_s2RAk ww1_s2RAo ww2_s2RAp
                 }}]
fromRat
  = \ (@ a_s2RAj)
      (w_s2RAk :: RealFloat a_s2RAj)
      (w1_s2RAl :: Rational) ->
      case w1_s2RAl of { :% ww1_s2RAo ww2_s2RAp ->
      GHC.Float.$wfromRat @ a_s2RAj w_s2RAk ww1_s2RAo ww2_s2RAp
      }

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
lvl8_r2UqG :: Integer -> Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []]
lvl8_r2UqG
  = \ (eta_i1AE2 :: Integer) ->
      case integerToInt eta_i1AE2 of wild_i1AOp { __DEFAULT ->
      GHC.Types.I# wild_i1AOp
      }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
lvl9_r2UqH :: Integer
[GblId]
lvl9_r2UqH = GHC.Float.$wexpt GHC.Float.$fRealFloatDouble5 23#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl10_r2UqI :: Integer
[GblId, Unf=OtherCon []]
lvl10_r2UqI = 4

-- RHS size: {terms: 435, types: 219, coercions: 0, joins: 2/20}
GHC.Float.$w$sfloatToDigits1 [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Float# -> (# [Int], Int #)
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []]
GHC.Float.$w$sfloatToDigits1
  = \ (w_s2RAI :: Integer) (ww_s2RAM :: Float#) ->
      case eqFloat# ww_s2RAM 0.0# of {
        __DEFAULT ->
          let {
            ds_s2LPJ [Dmd=<L,U(U,U(U))>] :: (Integer, Int)
            [LclId]
            ds_s2LPJ
              = case decodeFloat_Int# ww_s2RAM of
                { (# ipv_s2KAQ, ipv1_s2KAR #) ->
                (smallInteger ipv_s2KAQ, GHC.Types.I# ipv1_s2KAR)
                } } in
          let {
            ds1_s2LPH [Dmd=<L,U(1*U,U(U))>] :: (Integer, Int)
            [LclId]
            ds1_s2LPH
              = case ds_s2LPJ of wild_X5t { (f0_a2IHy, e0_a2IHA) ->
                case e0_a2IHA of { I# y_i1AMA ->
                let {
                  x_aA1E [Dmd=<S,U>] :: Int#
                  [LclId]
                  x_aA1E = -# -149# y_i1AMA } in
                case ># x_aA1E 0# of {
                  __DEFAULT -> wild_X5t;
                  1# ->
                    (let {
                       ds2_s2LQ4 [Dmd=<S,U>] :: Integer
                       [LclId]
                       ds2_s2LQ4
                         = GHC.Float.$wexpt GHC.Float.$fRealFloatDouble5 x_aA1E } in
                     case eqInteger# ds2_s2LQ4 GHC.Float.rationalToDouble5 of {
                       __DEFAULT -> quotInteger f0_a2IHy ds2_s2LQ4;
                       1# -> divZeroError @ Integer
                     },
                     GHC.Types.I# (+# y_i1AMA x_aA1E))
                }
                }
                } } in
          let {
            f_s2LPG :: Integer
            [LclId]
            f_s2LPG
              = case ds1_s2LPH of { (f1_a2IHO, e_a2IHQ) -> f1_a2IHO } } in
          let {
            ds2_s2LPE [Dmd=<L,U(1*U,1*U,1*U,1*U)>]
              :: (Integer, Integer, Integer, Integer)
            [LclId]
            ds2_s2LPE
              = case ds1_s2LPH of { (f1_a2IHO, e_a2IHQ) ->
                case e_a2IHQ of { I# x_alMY ->
                case >=# x_alMY 0# of {
                  __DEFAULT ->
                    join {
                      $j1_s2Mmc [Dmd=<L,1*U(1*U,1*U,1*U,1*U)>]
                        :: (Integer, Integer, Integer, Integer)
                      [LclId[JoinId(0)], Str=m, Unf=OtherCon []]
                      $j1_s2Mmc
                        = (timesInteger f_s2LPG GHC.Float.$fRealFloatDouble5,
                           timesInteger
                             (GHC.Float.$wexpt GHC.Float.$fRealFloatDouble5 (negateInt# x_alMY))
                             GHC.Float.$fRealFloatDouble5,
                           GHC.Float.$fRealDouble1, GHC.Float.$fRealDouble1) } in
                    case ># x_alMY -149# of {
                      __DEFAULT -> jump $j1_s2Mmc;
                      1# ->
                        case eqInteger# f_s2LPG lvl9_r2UqH of {
                          __DEFAULT -> jump $j1_s2Mmc;
                          1# ->
                            (timesInteger
                               (timesInteger f_s2LPG GHC.Float.$fRealFloatDouble5)
                               GHC.Float.$fRealFloatDouble5,
                             timesInteger
                               (GHC.Float.$wexpt
                                  GHC.Float.$fRealFloatDouble5 (+# (negateInt# x_alMY) 1#))
                               GHC.Float.$fRealFloatDouble5,
                             GHC.Float.$fRealFloatDouble5, GHC.Float.$fRealDouble1)
                        }
                    };
                  1# ->
                    let {
                      be_s2LQ0 :: Integer
                      [LclId]
                      be_s2LQ0
                        = GHC.Float.$wexpt GHC.Float.$fRealFloatDouble5 x_alMY } in
                    case eqInteger# f_s2LPG lvl9_r2UqH of {
                      __DEFAULT ->
                        (timesInteger
                           (timesInteger f_s2LPG be_s2LQ0) GHC.Float.$fRealFloatDouble5,
                         GHC.Float.$fRealFloatDouble5, be_s2LQ0, be_s2LQ0);
                      1# ->
                        (timesInteger
                           (timesInteger
                              (timesInteger f_s2LPG be_s2LQ0) GHC.Float.$fRealFloatDouble5)
                           GHC.Float.$fRealFloatDouble5,
                         lvl10_r2UqI, timesInteger be_s2LQ0 GHC.Float.$fRealFloatDouble5,
                         be_s2LQ0)
                    }
                }
                }
                } } in
          let {
            s_s2LPC :: Integer
            [LclId]
            s_s2LPC
              = case ds2_s2LPE of { (r_a2IIm, s1_a2IIo, mUp_a2IIq, mDn_a2IIs) ->
                s1_a2IIo
                } } in
          let {
            r_s2LPD :: Integer
            [LclId]
            r_s2LPD
              = case ds2_s2LPE of { (r1_a2IIm, s1_a2IIo, mUp_a2IIq, mDn_a2IIs) ->
                r1_a2IIm
                } } in
          let {
            mUp_s2LPB :: Integer
            [LclId]
            mUp_s2LPB
              = case ds2_s2LPE of
                { (r1_a2IIm, s1_a2IIo, mUp1_a2IIq, mDn_a2IIs) ->
                mUp1_a2IIq
                } } in
          let {
            k_s2LPA [Dmd=<L,U(U)>] :: Int
            [LclId]
            k_s2LPA
              = let {
                  lvl38_s2LZS [Dmd=<S,U>] :: Integer
                  [LclId]
                  lvl38_s2LZS = plusInteger r_s2LPD mUp_s2LPB } in
                joinrec {
                  $wfixup_s2RAx [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                    :: Int# -> Int
                  [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []]
                  $wfixup_s2RAx (ww1_s2RAv :: Int#)
                    = case >=# ww1_s2RAv 0# of {
                        __DEFAULT ->
                          case leInteger#
                                 (timesInteger
                                    (GHC.Float.$wexpt w_s2RAI (negateInt# ww1_s2RAv)) lvl38_s2LZS)
                                 s_s2LPC
                          of {
                            __DEFAULT -> jump $wfixup_s2RAx (+# ww1_s2RAv 1#);
                            1# -> GHC.Types.I# ww1_s2RAv
                          };
                        1# ->
                          case leInteger#
                                 lvl38_s2LZS
                                 (timesInteger (GHC.Float.$wexpt w_s2RAI ww1_s2RAv) s_s2LPC)
                          of {
                            __DEFAULT -> jump $wfixup_s2RAx (+# ww1_s2RAv 1#);
                            1# -> GHC.Types.I# ww1_s2RAv
                          }
                      }; } in
                case eqInteger# w_s2RAI GHC.Float.expts4 of {
                  __DEFAULT ->
                    case floatFromInteger (plusInteger f_s2LPG GHC.Float.$fRealDouble1)
                    of wild1_X5a
                    { __DEFAULT ->
                    case logFloat# wild1_X5a of wild2_XP { __DEFAULT ->
                    case ds1_s2LPH of { (f1_a2IHO, e_a2IHQ) ->
                    case e_a2IHQ of { I# i_i2Ksf ->
                    case lvl5_r2UqD of { F# v1_B2 ->
                    case floatFromInteger w_s2RAI of wild5_Xu4 { __DEFAULT ->
                    case logFloat# wild5_Xu4 of wild6_XpN { __DEFAULT ->
                    case divideFloat#
                           (plusFloat# wild2_XP (timesFloat# (int2Float# i_i2Ksf) v1_B2))
                           wild6_XpN
                    of wild7_XH
                    { __DEFAULT ->
                    let {
                      n_s2LPU [Dmd=<S,U>] :: Int#
                      [LclId]
                      n_s2LPU = float2Int# wild7_XH } in
                    case ltFloat# (int2Float# n_s2LPU) wild7_XH of {
                      __DEFAULT -> jump $wfixup_s2RAx n_s2LPU;
                      1# -> jump $wfixup_s2RAx (+# n_s2LPU 1#)
                    }
                    }
                    }
                    }
                    }
                    }
                    }
                    }
                    };
                  1# ->
                    case ds_s2LPJ of { (f0_a2IHy, e0_a2IHA) ->
                    case e0_a2IHA of { I# y_i1AMm ->
                    let {
                      x_alMY [Dmd=<S,U>] :: Int#
                      [LclId]
                      x_alMY = +# 23# y_i1AMm } in
                    case >=# x_alMY 0# of {
                      __DEFAULT ->
                        jump $wfixup_s2RAx (quotInt# (*# x_alMY 8651#) 28738#);
                      1# ->
                        jump $wfixup_s2RAx (+# (quotInt# (*# x_alMY 8651#) 28738#) 1#)
                    }
                    }
                    }
                } } in
          (# case k_s2LPA of { I# x_alMY ->
             letrec {
               gen_s2LPm [Occ=LoopBreaker]
                 :: [Integer]
                    -> Integer -> Integer -> Integer -> Integer -> [Integer]
               [LclId,
                Arity=5,
                Str=<L,U><S,1*U><S,U><S,1*U><S,1*U>,
                Unf=OtherCon []]
               gen_s2LPm
                 = \ (ds3_a2I2u :: [Integer])
                     (rn_a2I2v :: Integer)
                     (sN_a2I2w :: Integer)
                     (mUpN_a2I2x :: Integer)
                     (mDnN_a2I2y :: Integer) ->
                     case eqInteger# sN_a2I2w GHC.Float.rationalToDouble5 of {
                       __DEFAULT ->
                         case quotRemInteger (timesInteger rn_a2I2v w_s2RAI) sN_a2I2w of
                         { (# ipv_i2KJl, ipv1_i2KJm #) ->
                         let {
                           mUpN'_s2LQd [Dmd=<S,U>] :: Integer
                           [LclId]
                           mUpN'_s2LQd = timesInteger mUpN_a2I2x w_s2RAI } in
                         case gtInteger# (plusInteger ipv1_i2KJm mUpN'_s2LQd) sN_a2I2w
                         of wild2_aA2K
                         { __DEFAULT ->
                         let {
                           mDnN'_s2LQe [Dmd=<S,U>] :: Integer
                           [LclId]
                           mDnN'_s2LQe = timesInteger mDnN_a2I2y w_s2RAI } in
                         case ltInteger# ipv1_i2KJm mDnN'_s2LQe of {
                           __DEFAULT ->
                             case wild2_aA2K of {
                               __DEFAULT ->
                                 gen_s2LPm
                                   (GHC.Types.: @ Integer ipv_i2KJl ds3_a2I2u)
                                   ipv1_i2KJm
                                   sN_a2I2w
                                   mUpN'_s2LQd
                                   mDnN'_s2LQe;
                               1# ->
                                 GHC.Types.:
                                   @ Integer
                                   (plusInteger ipv_i2KJl GHC.Float.$fRealDouble1)
                                   ds3_a2I2u
                             };
                           1# ->
                             case wild2_aA2K of {
                               __DEFAULT -> GHC.Types.: @ Integer ipv_i2KJl ds3_a2I2u;
                               1# ->
                                 case ltInteger#
                                        (timesInteger ipv1_i2KJm GHC.Float.$fRealFloatDouble5)
                                        sN_a2I2w
                                 of {
                                   __DEFAULT ->
                                     GHC.Types.:
                                       @ Integer
                                       (plusInteger ipv_i2KJl GHC.Float.$fRealDouble1)
                                       ds3_a2I2u;
                                   1# -> GHC.Types.: @ Integer ipv_i2KJl ds3_a2I2u
                                 }
                             }
                         }
                         }
                         };
                       1# -> case divZeroError of wild2_00 { }
                     }; } in
             case >=# x_alMY 0# of {
               __DEFAULT ->
                 case ds2_s2LPE of { (r1_a2IIm, s1_a2IIo, mUp1_a2IIq, mDn_a2IIs) ->
                 let {
                   bk_s2LPQ [Dmd=<S,U>] :: Integer
                   [LclId]
                   bk_s2LPQ = GHC.Float.$wexpt w_s2RAI (negateInt# x_alMY) } in
                 map
                   @ Integer
                   @ Int
                   lvl8_r2UqG
                   (GHC.List.reverse1
                      @ Integer
                      (gen_s2LPm
                         (GHC.Types.[] @ Integer)
                         (timesInteger r_s2LPD bk_s2LPQ)
                         s_s2LPC
                         (timesInteger mUp_s2LPB bk_s2LPQ)
                         (timesInteger mDn_a2IIs bk_s2LPQ))
                      (GHC.Types.[] @ Integer))
                 };
               1# ->
                 case ds2_s2LPE of { (r1_a2IIm, s1_a2IIo, mUp1_a2IIq, mDn_a2IIs) ->
                 map
                   @ Integer
                   @ Int
                   lvl8_r2UqG
                   (GHC.List.reverse1
                      @ Integer
                      (gen_s2LPm
                         (GHC.Types.[] @ Integer)
                         r_s2LPD
                         (timesInteger s_s2LPC (GHC.Float.$wexpt w_s2RAI x_alMY))
                         mUp_s2LPB
                         mDn_a2IIs)
                      (GHC.Types.[] @ Integer))
                 }
             }
             },
             k_s2LPA #);
        1# -> (# lvl3_r2UpB, minExpt #)
      }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
lvl11_r2UqJ :: Integer
[GblId]
lvl11_r2UqJ = GHC.Float.$wexpt GHC.Float.$fRealFloatDouble5 52#

-- RHS size: {terms: 434, types: 219, coercions: 0, joins: 2/20}
GHC.Float.$w$sfloatToDigits [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Double# -> (# [Int], Int #)
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []]
GHC.Float.$w$sfloatToDigits
  = \ (w_s2RB8 :: Integer) (ww_s2RBc :: Double#) ->
      case ==## ww_s2RBc 0.0## of {
        __DEFAULT ->
          let {
            ds_s2LOK [Dmd=<L,U(U,U(U))>] :: (Integer, Int)
            [LclId]
            ds_s2LOK
              = case decodeDoubleInteger ww_s2RBc of
                { (# ipv_s2KAX, ipv1_s2KAY #) ->
                (ipv_s2KAX, GHC.Types.I# ipv1_s2KAY)
                } } in
          let {
            ds1_s2LOI [Dmd=<L,U(1*U,U(U))>] :: (Integer, Int)
            [LclId]
            ds1_s2LOI
              = case ds_s2LOK of wild_X5t { (f0_a2IHy, e0_a2IHA) ->
                case e0_a2IHA of { I# y_i1AMA ->
                let {
                  x_aA1E [Dmd=<S,U>] :: Int#
                  [LclId]
                  x_aA1E = -# -1074# y_i1AMA } in
                case ># x_aA1E 0# of {
                  __DEFAULT -> wild_X5t;
                  1# ->
                    (let {
                       ds2_s2LP5 [Dmd=<S,U>] :: Integer
                       [LclId]
                       ds2_s2LP5
                         = GHC.Float.$wexpt GHC.Float.$fRealFloatDouble5 x_aA1E } in
                     case eqInteger# ds2_s2LP5 GHC.Float.rationalToDouble5 of {
                       __DEFAULT -> quotInteger f0_a2IHy ds2_s2LP5;
                       1# -> divZeroError @ Integer
                     },
                     GHC.Types.I# (+# y_i1AMA x_aA1E))
                }
                }
                } } in
          let {
            f_s2LOH :: Integer
            [LclId]
            f_s2LOH
              = case ds1_s2LOI of { (f1_a2IHO, e_a2IHQ) -> f1_a2IHO } } in
          let {
            ds2_s2LOF [Dmd=<L,U(1*U,1*U,1*U,1*U)>]
              :: (Integer, Integer, Integer, Integer)
            [LclId]
            ds2_s2LOF
              = case ds1_s2LOI of { (f1_a2IHO, e_a2IHQ) ->
                case e_a2IHQ of { I# x_alMY ->
                case >=# x_alMY 0# of {
                  __DEFAULT ->
                    join {
                      $j1_s2Mnt [Dmd=<L,1*U(1*U,1*U,1*U,1*U)>]
                        :: (Integer, Integer, Integer, Integer)
                      [LclId[JoinId(0)], Str=m, Unf=OtherCon []]
                      $j1_s2Mnt
                        = (timesInteger f_s2LOH GHC.Float.$fRealFloatDouble5,
                           timesInteger
                             (GHC.Float.$wexpt GHC.Float.$fRealFloatDouble5 (negateInt# x_alMY))
                             GHC.Float.$fRealFloatDouble5,
                           GHC.Float.$fRealDouble1, GHC.Float.$fRealDouble1) } in
                    case ># x_alMY -1074# of {
                      __DEFAULT -> jump $j1_s2Mnt;
                      1# ->
                        case eqInteger# f_s2LOH lvl11_r2UqJ of {
                          __DEFAULT -> jump $j1_s2Mnt;
                          1# ->
                            (timesInteger
                               (timesInteger f_s2LOH GHC.Float.$fRealFloatDouble5)
                               GHC.Float.$fRealFloatDouble5,
                             timesInteger
                               (GHC.Float.$wexpt
                                  GHC.Float.$fRealFloatDouble5 (+# (negateInt# x_alMY) 1#))
                               GHC.Float.$fRealFloatDouble5,
                             GHC.Float.$fRealFloatDouble5, GHC.Float.$fRealDouble1)
                        }
                    };
                  1# ->
                    let {
                      be_s2LP1 :: Integer
                      [LclId]
                      be_s2LP1
                        = GHC.Float.$wexpt GHC.Float.$fRealFloatDouble5 x_alMY } in
                    case eqInteger# f_s2LOH lvl11_r2UqJ of {
                      __DEFAULT ->
                        (timesInteger
                           (timesInteger f_s2LOH be_s2LP1) GHC.Float.$fRealFloatDouble5,
                         GHC.Float.$fRealFloatDouble5, be_s2LP1, be_s2LP1);
                      1# ->
                        (timesInteger
                           (timesInteger
                              (timesInteger f_s2LOH be_s2LP1) GHC.Float.$fRealFloatDouble5)
                           GHC.Float.$fRealFloatDouble5,
                         lvl10_r2UqI, timesInteger be_s2LP1 GHC.Float.$fRealFloatDouble5,
                         be_s2LP1)
                    }
                }
                }
                } } in
          let {
            s_s2LOD :: Integer
            [LclId]
            s_s2LOD
              = case ds2_s2LOF of { (r_a2IIm, s1_a2IIo, mUp_a2IIq, mDn_a2IIs) ->
                s1_a2IIo
                } } in
          let {
            r_s2LOE :: Integer
            [LclId]
            r_s2LOE
              = case ds2_s2LOF of { (r1_a2IIm, s1_a2IIo, mUp_a2IIq, mDn_a2IIs) ->
                r1_a2IIm
                } } in
          let {
            mUp_s2LOC :: Integer
            [LclId]
            mUp_s2LOC
              = case ds2_s2LOF of
                { (r1_a2IIm, s1_a2IIo, mUp1_a2IIq, mDn_a2IIs) ->
                mUp1_a2IIq
                } } in
          let {
            k_s2LOB [Dmd=<L,U(U)>] :: Int
            [LclId]
            k_s2LOB
              = let {
                  lvl38_s2M0w [Dmd=<S,U>] :: Integer
                  [LclId]
                  lvl38_s2M0w = plusInteger r_s2LOE mUp_s2LOC } in
                joinrec {
                  $wfixup_s2RAX [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                    :: Int# -> Int
                  [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []]
                  $wfixup_s2RAX (ww1_s2RAV :: Int#)
                    = case >=# ww1_s2RAV 0# of {
                        __DEFAULT ->
                          case leInteger#
                                 (timesInteger
                                    (GHC.Float.$wexpt w_s2RB8 (negateInt# ww1_s2RAV)) lvl38_s2M0w)
                                 s_s2LOD
                          of {
                            __DEFAULT -> jump $wfixup_s2RAX (+# ww1_s2RAV 1#);
                            1# -> GHC.Types.I# ww1_s2RAV
                          };
                        1# ->
                          case leInteger#
                                 lvl38_s2M0w
                                 (timesInteger (GHC.Float.$wexpt w_s2RB8 ww1_s2RAV) s_s2LOD)
                          of {
                            __DEFAULT -> jump $wfixup_s2RAX (+# ww1_s2RAV 1#);
                            1# -> GHC.Types.I# ww1_s2RAV
                          }
                      }; } in
                case eqInteger# w_s2RB8 GHC.Float.expts4 of {
                  __DEFAULT ->
                    case floatFromInteger (plusInteger f_s2LOH GHC.Float.$fRealDouble1)
                    of wild1_X5a
                    { __DEFAULT ->
                    case logFloat# wild1_X5a of wild2_XP { __DEFAULT ->
                    case ds1_s2LOI of { (f1_a2IHO, e_a2IHQ) ->
                    case e_a2IHQ of { I# i_i2Ksf ->
                    case lvl5_r2UqD of { F# v1_B2 ->
                    case floatFromInteger w_s2RB8 of wild5_XuC { __DEFAULT ->
                    case logFloat# wild5_XuC of wild6_Xql { __DEFAULT ->
                    case divideFloat#
                           (plusFloat# wild2_XP (timesFloat# (int2Float# i_i2Ksf) v1_B2))
                           wild6_Xql
                    of wild7_XH
                    { __DEFAULT ->
                    let {
                      n_s2LOV [Dmd=<S,U>] :: Int#
                      [LclId]
                      n_s2LOV = float2Int# wild7_XH } in
                    case ltFloat# (int2Float# n_s2LOV) wild7_XH of {
                      __DEFAULT -> jump $wfixup_s2RAX n_s2LOV;
                      1# -> jump $wfixup_s2RAX (+# n_s2LOV 1#)
                    }
                    }
                    }
                    }
                    }
                    }
                    }
                    }
                    };
                  1# ->
                    case ds_s2LOK of { (f0_a2IHy, e0_a2IHA) ->
                    case e0_a2IHA of { I# y_i1AMm ->
                    let {
                      x_alMY [Dmd=<S,U>] :: Int#
                      [LclId]
                      x_alMY = +# 52# y_i1AMm } in
                    case >=# x_alMY 0# of {
                      __DEFAULT ->
                        jump $wfixup_s2RAX (quotInt# (*# x_alMY 8651#) 28738#);
                      1# ->
                        jump $wfixup_s2RAX (+# (quotInt# (*# x_alMY 8651#) 28738#) 1#)
                    }
                    }
                    }
                } } in
          (# case k_s2LOB of { I# x_alMY ->
             letrec {
               gen_s2LOn [Occ=LoopBreaker]
                 :: [Integer]
                    -> Integer -> Integer -> Integer -> Integer -> [Integer]
               [LclId,
                Arity=5,
                Str=<L,U><S,1*U><S,U><S,1*U><S,1*U>,
                Unf=OtherCon []]
               gen_s2LOn
                 = \ (ds3_a2I2u :: [Integer])
                     (rn_a2I2v :: Integer)
                     (sN_a2I2w :: Integer)
                     (mUpN_a2I2x :: Integer)
                     (mDnN_a2I2y :: Integer) ->
                     case eqInteger# sN_a2I2w GHC.Float.rationalToDouble5 of {
                       __DEFAULT ->
                         case quotRemInteger (timesInteger rn_a2I2v w_s2RB8) sN_a2I2w of
                         { (# ipv_i2KJl, ipv1_i2KJm #) ->
                         let {
                           mUpN'_s2LPe [Dmd=<S,U>] :: Integer
                           [LclId]
                           mUpN'_s2LPe = timesInteger mUpN_a2I2x w_s2RB8 } in
                         case gtInteger# (plusInteger ipv1_i2KJm mUpN'_s2LPe) sN_a2I2w
                         of wild2_aA2K
                         { __DEFAULT ->
                         let {
                           mDnN'_s2LPf [Dmd=<S,U>] :: Integer
                           [LclId]
                           mDnN'_s2LPf = timesInteger mDnN_a2I2y w_s2RB8 } in
                         case ltInteger# ipv1_i2KJm mDnN'_s2LPf of {
                           __DEFAULT ->
                             case wild2_aA2K of {
                               __DEFAULT ->
                                 gen_s2LOn
                                   (GHC.Types.: @ Integer ipv_i2KJl ds3_a2I2u)
                                   ipv1_i2KJm
                                   sN_a2I2w
                                   mUpN'_s2LPe
                                   mDnN'_s2LPf;
                               1# ->
                                 GHC.Types.:
                                   @ Integer
                                   (plusInteger ipv_i2KJl GHC.Float.$fRealDouble1)
                                   ds3_a2I2u
                             };
                           1# ->
                             case wild2_aA2K of {
                               __DEFAULT -> GHC.Types.: @ Integer ipv_i2KJl ds3_a2I2u;
                               1# ->
                                 case ltInteger#
                                        (timesInteger ipv1_i2KJm GHC.Float.$fRealFloatDouble5)
                                        sN_a2I2w
                                 of {
                                   __DEFAULT ->
                                     GHC.Types.:
                                       @ Integer
                                       (plusInteger ipv_i2KJl GHC.Float.$fRealDouble1)
                                       ds3_a2I2u;
                                   1# -> GHC.Types.: @ Integer ipv_i2KJl ds3_a2I2u
                                 }
                             }
                         }
                         }
                         };
                       1# -> case divZeroError of wild2_00 { }
                     }; } in
             case >=# x_alMY 0# of {
               __DEFAULT ->
                 case ds2_s2LOF of { (r1_a2IIm, s1_a2IIo, mUp1_a2IIq, mDn_a2IIs) ->
                 let {
                   bk_s2LOR [Dmd=<S,U>] :: Integer
                   [LclId]
                   bk_s2LOR = GHC.Float.$wexpt w_s2RB8 (negateInt# x_alMY) } in
                 map
                   @ Integer
                   @ Int
                   lvl8_r2UqG
                   (GHC.List.reverse1
                      @ Integer
                      (gen_s2LOn
                         (GHC.Types.[] @ Integer)
                         (timesInteger r_s2LOE bk_s2LOR)
                         s_s2LOD
                         (timesInteger mUp_s2LOC bk_s2LOR)
                         (timesInteger mDn_a2IIs bk_s2LOR))
                      (GHC.Types.[] @ Integer))
                 };
               1# ->
                 case ds2_s2LOF of { (r1_a2IIm, s1_a2IIo, mUp1_a2IIq, mDn_a2IIs) ->
                 map
                   @ Integer
                   @ Int
                   lvl8_r2UqG
                   (GHC.List.reverse1
                      @ Integer
                      (gen_s2LOn
                         (GHC.Types.[] @ Integer)
                         r_s2LOE
                         (timesInteger s_s2LOD (GHC.Float.$wexpt w_s2RB8 x_alMY))
                         mUp_s2LOC
                         mDn_a2IIs)
                      (GHC.Types.[] @ Integer))
                 }
             }
             },
             k_s2LOB #);
        1# -> (# lvl3_r2UpB, minExpt #)
      }

-- RHS size: {terms: 511, types: 254, coercions: 0, joins: 3/26}
GHC.Float.$wfloatToDigits [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Integer -> a -> (# [Int], Int #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,1*C1(U),1*C1(U(U)),1*C1(U(1*U(U),A)),1*C1(U(U,U(U))),A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []]
GHC.Float.$wfloatToDigits
  = \ (@ a_s2RBy)
      (w_s2RBz :: RealFloat a_s2RBy)
      (w1_s2RBA :: Integer)
      (w2_s2RBB :: a_s2RBy) ->
      let {
        $dRealFrac_s2LNR [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A)>]
          :: RealFrac a_s2RBy
        [LclId]
        $dRealFrac_s2LNR = GHC.Float.$p1RealFloat @ a_s2RBy w_s2RBz } in
      let {
        $dReal_s2LNQ [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
          :: Real a_s2RBy
        [LclId]
        $dReal_s2LNQ = GHC.Real.$p1RealFrac @ a_s2RBy $dRealFrac_s2LNR } in
      case ==
             @ a_s2RBy
             (GHC.Classes.$p1Ord
                @ a_s2RBy (GHC.Real.$p2Real @ a_s2RBy $dReal_s2LNQ))
             w2_s2RBB
             (fromInteger
                @ a_s2RBy
                (GHC.Real.$p1Real @ a_s2RBy $dReal_s2LNQ)
                GHC.Float.rationalToDouble5)
      of {
        False ->
          let {
            b_s2LNP :: Integer
            [LclId]
            b_s2LNP = floatRadix @ a_s2RBy w_s2RBz w2_s2RBB } in
          let {
            p_s2LNO [Dmd=<L,U(U)>] :: Int
            [LclId]
            p_s2LNO = floatDigits @ a_s2RBy w_s2RBz w2_s2RBB } in
          let {
            minExp_s2LNN [Dmd=<L,U(U)>] :: Int
            [LclId]
            minExp_s2LNN
              = case floatRange @ a_s2RBy w_s2RBz w2_s2RBB of
                { (minExp0_a2IHc, ds_d2K3B) ->
                case minExp0_a2IHc of { I# x_i1AMw ->
                case p_s2LNO of { I# y_i1AMA -> GHC.Types.I# (-# x_i1AMw y_i1AMA) }
                }
                } } in
          let {
            ds_s2LNM [Dmd=<L,U(U,U(U))>] :: (Integer, Int)
            [LclId]
            ds_s2LNM = decodeFloat @ a_s2RBy w_s2RBz w2_s2RBB } in
          let {
            ds1_s2LNK [Dmd=<L,U(1*U,U(U))>] :: (Integer, Int)
            [LclId]
            ds1_s2LNK
              = case minExp_s2LNN of { I# x_i1AMw ->
                case ds_s2LNM of wild2_X5t { (f0_a2IHy, e0_a2IHA) ->
                case e0_a2IHA of { I# y_i1AMA ->
                let {
                  x1_aA1E [Dmd=<S,U>] :: Int#
                  [LclId]
                  x1_aA1E = -# x_i1AMw y_i1AMA } in
                case ># x1_aA1E 0# of {
                  __DEFAULT -> wild2_X5t;
                  1# ->
                    (let {
                       ds2_s2LO7 [Dmd=<S,U>] :: Integer
                       [LclId]
                       ds2_s2LO7 = GHC.Float.$wexpt b_s2LNP x1_aA1E } in
                     case eqInteger# ds2_s2LO7 GHC.Float.rationalToDouble5 of {
                       __DEFAULT -> quotInteger f0_a2IHy ds2_s2LO7;
                       1# -> divZeroError @ Integer
                     },
                     GHC.Types.I# (+# y_i1AMA x1_aA1E))
                }
                }
                }
                } } in
          let {
            f_s2LNJ :: Integer
            [LclId]
            f_s2LNJ
              = case ds1_s2LNK of { (f1_a2IHO, e_a2IHQ) -> f1_a2IHO } } in
          let {
            ds2_s2LNH [Dmd=<L,U(1*U,1*U,1*U,1*U)>]
              :: (Integer, Integer, Integer, Integer)
            [LclId]
            ds2_s2LNH
              = case ds1_s2LNK of { (f1_a2IHO, e_a2IHQ) ->
                case e_a2IHQ of { I# x_alMY ->
                case >=# x_alMY 0# of {
                  __DEFAULT ->
                    case minExp_s2LNN of { I# y_aA1I ->
                    join {
                      $j1_s2MoM [Dmd=<L,1*U(1*U,1*U,1*U,1*U)>]
                        :: (Integer, Integer, Integer, Integer)
                      [LclId[JoinId(0)], Str=m, Unf=OtherCon []]
                      $j1_s2MoM
                        = (timesInteger f_s2LNJ GHC.Float.$fRealFloatDouble5,
                           timesInteger
                             (GHC.Float.$wexpt b_s2LNP (negateInt# x_alMY))
                             GHC.Float.$fRealFloatDouble5,
                           GHC.Float.$fRealDouble1, GHC.Float.$fRealDouble1) } in
                    case ># x_alMY y_aA1I of {
                      __DEFAULT -> jump $j1_s2MoM;
                      1# ->
                        case p_s2LNO of { I# x1_i1AMw ->
                        case eqInteger# f_s2LNJ (GHC.Float.$wexpt b_s2LNP (-# x1_i1AMw 1#))
                        of {
                          __DEFAULT -> jump $j1_s2MoM;
                          1# ->
                            (timesInteger
                               (timesInteger f_s2LNJ b_s2LNP) GHC.Float.$fRealFloatDouble5,
                             timesInteger
                               (GHC.Float.$wexpt b_s2LNP (+# (negateInt# x_alMY) 1#))
                               GHC.Float.$fRealFloatDouble5,
                             b_s2LNP, GHC.Float.$fRealDouble1)
                        }
                        }
                    }
                    };
                  1# ->
                    case p_s2LNO of { I# x1_i1AMw ->
                    let {
                      be_s2LO3 :: Integer
                      [LclId]
                      be_s2LO3 = GHC.Float.$wexpt b_s2LNP x_alMY } in
                    case eqInteger# f_s2LNJ (GHC.Float.$wexpt b_s2LNP (-# x1_i1AMw 1#))
                    of {
                      __DEFAULT ->
                        (timesInteger
                           (timesInteger f_s2LNJ be_s2LO3) GHC.Float.$fRealFloatDouble5,
                         GHC.Float.$fRealFloatDouble5, be_s2LO3, be_s2LO3);
                      1# ->
                        (timesInteger
                           (timesInteger (timesInteger f_s2LNJ be_s2LO3) b_s2LNP)
                           GHC.Float.$fRealFloatDouble5,
                         timesInteger GHC.Float.$fRealFloatDouble5 b_s2LNP,
                         timesInteger be_s2LO3 b_s2LNP, be_s2LO3)
                    }
                    }
                }
                }
                } } in
          let {
            s_s2LNF :: Integer
            [LclId]
            s_s2LNF
              = case ds2_s2LNH of { (r_a2IIm, s1_a2IIo, mUp_a2IIq, mDn_a2IIs) ->
                s1_a2IIo
                } } in
          let {
            r_s2LNG :: Integer
            [LclId]
            r_s2LNG
              = case ds2_s2LNH of { (r1_a2IIm, s1_a2IIo, mUp_a2IIq, mDn_a2IIs) ->
                r1_a2IIm
                } } in
          let {
            mUp_s2LNE :: Integer
            [LclId]
            mUp_s2LNE
              = case ds2_s2LNH of
                { (r1_a2IIm, s1_a2IIo, mUp1_a2IIq, mDn_a2IIs) ->
                mUp1_a2IIq
                } } in
          let {
            k_s2LND [Dmd=<L,U(U)>] :: Int
            [LclId]
            k_s2LND
              = case eqInteger# b_s2LNP GHC.Float.$fRealFloatDouble5
                of wild1_a1foK
                { __DEFAULT ->
                let {
                  lvl38_s2M14 [Dmd=<S,U>] :: Integer
                  [LclId]
                  lvl38_s2M14 = plusInteger r_s2LNG mUp_s2LNE } in
                joinrec {
                  $wfixup_s2RBn [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                    :: Int# -> Int
                  [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []]
                  $wfixup_s2RBn (ww_s2RBl :: Int#)
                    = case >=# ww_s2RBl 0# of {
                        __DEFAULT ->
                          case leInteger#
                                 (timesInteger
                                    (GHC.Float.$wexpt w1_s2RBA (negateInt# ww_s2RBl)) lvl38_s2M14)
                                 s_s2LNF
                          of {
                            __DEFAULT -> jump $wfixup_s2RBn (+# ww_s2RBl 1#);
                            1# -> GHC.Types.I# ww_s2RBl
                          };
                        1# ->
                          case leInteger#
                                 lvl38_s2M14
                                 (timesInteger (GHC.Float.$wexpt w1_s2RBA ww_s2RBl) s_s2LNF)
                          of {
                            __DEFAULT -> jump $wfixup_s2RBn (+# ww_s2RBl 1#);
                            1# -> GHC.Types.I# ww_s2RBl
                          }
                      }; } in
                join {
                  $j1_s2Mpt [Dmd=<L,1*U(U)>] :: Int
                  [LclId[JoinId(0)], Str=m]
                  $j1_s2Mpt
                    = case floatFromInteger
                             (plusInteger f_s2LNJ GHC.Float.$fRealDouble1)
                      of wild2_X5a
                      { __DEFAULT ->
                      case logFloat# wild2_X5a of wild3_XP { __DEFAULT ->
                      case ds1_s2LNK of { (f1_a2IHO, e_a2IHQ) ->
                      case e_a2IHQ of { I# i_i2Ksf ->
                      case floatFromInteger b_s2LNP of wild6_Xv6 { __DEFAULT ->
                      case logFloat# wild6_Xv6 of wild7_XqP { __DEFAULT ->
                      case floatFromInteger w1_s2RBA of wild8_Xvg { __DEFAULT ->
                      case logFloat# wild8_Xvg of wild9_XqZ { __DEFAULT ->
                      case divideFloat#
                             (plusFloat# wild3_XP (timesFloat# (int2Float# i_i2Ksf) wild7_XqP))
                             wild9_XqZ
                      of wild10_XH
                      { __DEFAULT ->
                      let {
                        n_s2LNX [Dmd=<S,U>] :: Int#
                        [LclId]
                        n_s2LNX = float2Int# wild10_XH } in
                      case ltFloat# (int2Float# n_s2LNX) wild10_XH of {
                        __DEFAULT -> jump $wfixup_s2RBn n_s2LNX;
                        1# -> jump $wfixup_s2RBn (+# n_s2LNX 1#)
                      }
                      }
                      }
                      }
                      }
                      }
                      }
                      }
                      }
                      } } in
                case wild1_a1foK of {
                  __DEFAULT -> jump $j1_s2Mpt;
                  1# ->
                    case eqInteger# w1_s2RBA GHC.Float.expts4 of {
                      __DEFAULT -> jump $j1_s2Mpt;
                      1# ->
                        case p_s2LNO of { I# x_i1AMw ->
                        case ds_s2LNM of { (f0_a2IHy, e0_a2IHA) ->
                        case e0_a2IHA of { I# y_i1AMm ->
                        let {
                          x1_alMY [Dmd=<S,U>] :: Int#
                          [LclId]
                          x1_alMY = +# (-# x_i1AMw 1#) y_i1AMm } in
                        case >=# x1_alMY 0# of {
                          __DEFAULT ->
                            jump $wfixup_s2RBn (quotInt# (*# x1_alMY 8651#) 28738#);
                          1# ->
                            jump $wfixup_s2RBn (+# (quotInt# (*# x1_alMY 8651#) 28738#) 1#)
                        }
                        }
                        }
                        }
                    }
                }
                } } in
          (# case k_s2LND of { I# x_alMY ->
             letrec {
               gen_s2LNp [Occ=LoopBreaker]
                 :: [Integer]
                    -> Integer -> Integer -> Integer -> Integer -> [Integer]
               [LclId,
                Arity=5,
                Str=<L,U><S,1*U><S,U><S,1*U><S,1*U>,
                Unf=OtherCon []]
               gen_s2LNp
                 = \ (ds3_a2I2u :: [Integer])
                     (rn_a2I2v :: Integer)
                     (sN_a2I2w :: Integer)
                     (mUpN_a2I2x :: Integer)
                     (mDnN_a2I2y :: Integer) ->
                     case eqInteger# sN_a2I2w GHC.Float.rationalToDouble5 of {
                       __DEFAULT ->
                         case quotRemInteger (timesInteger rn_a2I2v w1_s2RBA) sN_a2I2w of
                         { (# ipv_i2KJl, ipv1_i2KJm #) ->
                         let {
                           mUpN'_s2LOg [Dmd=<S,U>] :: Integer
                           [LclId]
                           mUpN'_s2LOg = timesInteger mUpN_a2I2x w1_s2RBA } in
                         case gtInteger# (plusInteger ipv1_i2KJm mUpN'_s2LOg) sN_a2I2w
                         of wild3_aA2K
                         { __DEFAULT ->
                         let {
                           mDnN'_s2LOh [Dmd=<S,U>] :: Integer
                           [LclId]
                           mDnN'_s2LOh = timesInteger mDnN_a2I2y w1_s2RBA } in
                         case ltInteger# ipv1_i2KJm mDnN'_s2LOh of {
                           __DEFAULT ->
                             case wild3_aA2K of {
                               __DEFAULT ->
                                 gen_s2LNp
                                   (GHC.Types.: @ Integer ipv_i2KJl ds3_a2I2u)
                                   ipv1_i2KJm
                                   sN_a2I2w
                                   mUpN'_s2LOg
                                   mDnN'_s2LOh;
                               1# ->
                                 GHC.Types.:
                                   @ Integer
                                   (plusInteger ipv_i2KJl GHC.Float.$fRealDouble1)
                                   ds3_a2I2u
                             };
                           1# ->
                             case wild3_aA2K of {
                               __DEFAULT -> GHC.Types.: @ Integer ipv_i2KJl ds3_a2I2u;
                               1# ->
                                 case ltInteger#
                                        (timesInteger ipv1_i2KJm GHC.Float.$fRealFloatDouble5)
                                        sN_a2I2w
                                 of {
                                   __DEFAULT ->
                                     GHC.Types.:
                                       @ Integer
                                       (plusInteger ipv_i2KJl GHC.Float.$fRealDouble1)
                                       ds3_a2I2u;
                                   1# -> GHC.Types.: @ Integer ipv_i2KJl ds3_a2I2u
                                 }
                             }
                         }
                         }
                         };
                       1# -> case divZeroError of wild3_00 { }
                     }; } in
             case >=# x_alMY 0# of {
               __DEFAULT ->
                 case ds2_s2LNH of { (r1_a2IIm, s1_a2IIo, mUp1_a2IIq, mDn_a2IIs) ->
                 let {
                   bk_s2LNT [Dmd=<S,U>] :: Integer
                   [LclId]
                   bk_s2LNT = GHC.Float.$wexpt w1_s2RBA (negateInt# x_alMY) } in
                 map
                   @ Integer
                   @ Int
                   lvl8_r2UqG
                   (GHC.List.reverse1
                      @ Integer
                      (gen_s2LNp
                         (GHC.Types.[] @ Integer)
                         (timesInteger r_s2LNG bk_s2LNT)
                         s_s2LNF
                         (timesInteger mUp_s2LNE bk_s2LNT)
                         (timesInteger mDn_a2IIs bk_s2LNT))
                      (GHC.Types.[] @ Integer))
                 };
               1# ->
                 case ds2_s2LNH of { (r1_a2IIm, s1_a2IIo, mUp1_a2IIq, mDn_a2IIs) ->
                 map
                   @ Integer
                   @ Int
                   lvl8_r2UqG
                   (GHC.List.reverse1
                      @ Integer
                      (gen_s2LNp
                         (GHC.Types.[] @ Integer)
                         r_s2LNG
                         (timesInteger s_s2LNF (GHC.Float.$wexpt w1_s2RBA x_alMY))
                         mUp_s2LNE
                         mDn_a2IIs)
                      (GHC.Types.[] @ Integer))
                 }
             }
             },
             k_s2LND #);
        True -> (# lvl3_r2UpB, minExpt #)
      }

-- RHS size: {terms: 13, types: 19, coercions: 0, joins: 0/0}
floatToDigits [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Integer -> a -> ([Int], Int)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,A,A,A,A,A,A)><L,U><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s2RBy)
                 (w_s2RBz [Occ=Once] :: RealFloat a_s2RBy)
                 (w1_s2RBA [Occ=Once] :: Integer)
                 (w2_s2RBB [Occ=Once] :: a_s2RBy) ->
                 case GHC.Float.$wfloatToDigits @ a_s2RBy w_s2RBz w1_s2RBA w2_s2RBB
                 of
                 { (# ww1_s2REc [Occ=Once], ww2_s2REd [Occ=Once] #) ->
                 (ww1_s2REc, ww2_s2REd)
                 }}]
floatToDigits
  = \ (@ a_s2RBy)
      (w_s2RBz :: RealFloat a_s2RBy)
      (w1_s2RBA :: Integer)
      (w2_s2RBB :: a_s2RBy) ->
      case GHC.Float.$wfloatToDigits @ a_s2RBy w_s2RBz w1_s2RBA w2_s2RBB
      of
      { (# ww1_s2REc, ww2_s2REd #) ->
      (ww1_s2REc, ww2_s2REd)
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
base_r2UqK :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
base_r2UqK = GHC.Types.I# 10#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl12_r2UqL :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl12_r2UqL = "formatRealFloat/doFmt/FFExponent: []"#

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
lvl13_r2UqM :: [Char]
[GblId, Str=x]
lvl13_r2UqM
  = errorWithoutStackTrace
      @ 'LiftedRep @ [Char] (unpackCString# lvl12_r2UqL)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl14_r2UqN :: Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl14_r2UqN = GHC.Types.C# '.'#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl15_r2UqO :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl15_r2UqO = "0.0e0"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl16_r2UqP :: [Char]
[GblId]
lvl16_r2UqP = unpackCString# lvl15_r2UqO

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl17_r2UqQ :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl17_r2UqQ = "GHC/Float.hs:692:12-70|d : ds'"#

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
lvl18_r2UqR :: (Char, [Char])
[GblId, Str=x]
lvl18_r2UqR
  = Control.Exception.Base.patError
      @ 'LiftedRep @ (Char, [Char]) lvl17_r2UqQ

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl19_r2UqS :: Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl19_r2UqS = GHC.Types.C# 'e'#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl20_r2UqT :: Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl20_r2UqT = GHC.Types.C# '0'#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl21_r2UqU :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl21_r2UqU = "e0"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl22_r2UqV :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl22_r2UqV = "0"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl23_r2UqW :: [Char]
[GblId]
lvl23_r2UqW = unpackCString# lvl22_r2UqV

Rec {
-- RHS size: {terms: 53, types: 35, coercions: 0, joins: 0/0}
$wf_r2UqX :: Int# -> [Char] -> [Char] -> [Char]
[GblId, Arity=3, Str=<S,1*U><L,U><L,1*U>, Unf=OtherCon []]
$wf_r2UqX
  = \ (ww_s2RBL :: Int#) (w_s2RBH :: [Char]) (w1_s2RBI :: [Char]) ->
      case ww_s2RBL of wild_XmI {
        __DEFAULT ->
          case w1_s2RBI of {
            [] ->
              $wf_r2UqX
                (-# wild_XmI 1#)
                (GHC.Types.: @ Char lvl20_r2UqT w_s2RBH)
                (GHC.Types.[] @ Char);
            : r_a2I1D rs_a2I1E ->
              $wf_r2UqX
                (-# wild_XmI 1#) (GHC.Types.: @ Char r_a2I1D w_s2RBH) rs_a2I1E
          };
        0# ->
          case GHC.List.reverse1 @ Char w_s2RBH (GHC.Types.[] @ Char)
          of wild1_Xh5 {
            [] ->
              ++
                @ Char
                lvl23_r2UqW
                (GHC.Types.:
                   @ Char
                   lvl14_r2UqN
                   (case w1_s2RBI of wild2_XBU {
                      [] -> lvl23_r2UqW;
                      : ipv_s2KXk ipv1_s2KXl -> wild2_XBU
                    }));
            : ipv_s2KXk ipv1_s2KXl ->
              ++
                @ Char
                wild1_Xh5
                (GHC.Types.:
                   @ Char
                   lvl14_r2UqN
                   (case w1_s2RBI of wild2_XBW {
                      [] -> lvl23_r2UqW;
                      : ipv2_X2Lid ipv3_X2Lif -> wild2_XBW
                    }))
          }
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl24_r2UqY :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl24_r2UqY = "GHC/Float.hs:720:11-64|d : ds'"#

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
lvl25_r2UqZ :: (Char, [Char])
[GblId, Str=x]
lvl25_r2UqZ
  = Control.Exception.Base.patError
      @ 'LiftedRep @ (Char, [Char]) lvl24_r2UqY

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl26_r2Ur0 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl26_r2Ur0 = "Infinity"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl27_r2Ur1 :: [Char]
[GblId]
lvl27_r2Ur1 = unpackCString# lvl26_r2Ur0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl28_r2Ur2 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl28_r2Ur2 = "-Infinity"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl29_r2Ur3 :: [Char]
[GblId]
lvl29_r2Ur3 = unpackCString# lvl28_r2Ur2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl30_r2Ur4 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl30_r2Ur4 = "NaN"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl31_r2Ur5 :: [Char]
[GblId]
lvl31_r2Ur5 = unpackCString# lvl30_r2Ur4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl32_r2Ur6 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl32_r2Ur6 = ".0e"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl33_r2Ur7 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl33_r2Ur7 = "e"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl34_r2Ur8 :: [Char]
[GblId]
lvl34_r2Ur8 = unpackCString# lvl21_r2UqU

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lvl35_r2Ur9 :: [Char]
[GblId, Str=m2, Unf=OtherCon []]
lvl35_r2Ur9 = GHC.Types.: @ Char lvl20_r2UqT lvl34_r2Ur8

Rec {
-- RHS size: {terms: 12, types: 3, coercions: 0, joins: 0/0}
$wxs1_r2Ura :: Int# -> [Char]
[GblId, Arity=1, Str=<S,1*U>m2, Unf=OtherCon []]
$wxs1_r2Ura
  = \ (ww_s2RBT :: Int#) ->
      case ww_s2RBT of ds1_i2KC9 {
        __DEFAULT ->
          GHC.Types.: @ Char lvl20_r2UqT ($wxs1_r2Ura (-# ds1_i2KC9 1#));
        1# -> lvl35_r2Ur9
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl36_r2Urb :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl36_r2Urb = "0."#

-- RHS size: {terms: 33, types: 27, coercions: 0, joins: 0/0}
$j_r2Urc :: Int -> [Int] -> (Char, [Char])
[GblId, Arity=2, Str=<S(S),1*U(U)><L,U>m, Unf=OtherCon []]
$j_r2Urc
  = \ (ww_s2RE3 [OS=OneShot] :: Int)
      (ww1_s2RE4 [OS=OneShot] :: [Int]) ->
      case ww_s2RE3 of { I# x_aA1E ->
      case ># x_aA1E 0# of {
        __DEFAULT ->
          case map
                 @ Int @ Char intToDigit (GHC.Types.: @ Int minExpt ww1_s2RE4)
          of {
            [] -> lvl25_r2UqZ;
            : d_a2IUk ds'_a2IUm -> (d_a2IUk, ds'_a2IUm)
          };
        1# ->
          case map @ Int @ Char intToDigit ww1_s2RE4 of {
            [] -> lvl25_r2UqZ;
            : d_a2IUk ds'_a2IUm -> (d_a2IUk, ds'_a2IUm)
          }
      }
      }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
lvl37_r2Urd :: [Char]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
lvl37_r2Urd = GHC.Types.: @ Char lvl14_r2UqN (GHC.Types.[] @ Char)

-- RHS size: {terms: 555, types: 407, coercions: 0, joins: 3/17}
GHC.Float.$w$sformatRealFloatAlt1 [InlPrag=NOUSERINLINE[0]]
  :: FFFormat -> Maybe Int -> Bool -> Float# -> [Char]
[GblId, Arity=4, Str=<L,1*U><L,U><L,U><S,U>, Unf=OtherCon []]
GHC.Float.$w$sformatRealFloatAlt1
  = \ (w_s2RCg :: FFFormat)
      (w1_s2RCh :: Maybe Int)
      (w2_s2RCi :: Bool)
      (ww_s2RCm :: Float#) ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KvF
             ww_s2RCm realWorld#
      of
      { (# ds_d2KvE, ds1_d2KvD #) ->
      case ds1_d2KvD of {
        __DEFAULT -> lvl31_r2Ur5;
        0# ->
          case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvy
                 ww_s2RCm realWorld#
          of
          { (# ds2_d2Kvx, ds3_d2Kvw #) ->
          case ds3_d2Kvw of {
            __DEFAULT ->
              case ltFloat# ww_s2RCm 0.0# of {
                __DEFAULT -> lvl27_r2Ur1;
                1# -> lvl29_r2Ur3
              };
            0# ->
              letrec {
                $wdoFmt_s2RCf [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                  :: FFFormat -> [Int] -> Int -> [Char]
                [LclId, Arity=3, Str=<S,1*U><L,U><L,1*U(U)>, Unf=OtherCon []]
                $wdoFmt_s2RCf
                  = \ (w3_s2RC8 :: FFFormat)
                      (ww1_s2RCc :: [Int])
                      (ww2_s2RCd :: Int) ->
                      case w3_s2RC8 of {
                        FFExponent ->
                          case w1_s2RCh of {
                            Nothing ->
                              case map @ Int @ Char intToDigit ww1_s2RCc of {
                                [] -> lvl13_r2UqM;
                                : ds4_d2K7A ds5_d2K7B ->
                                  case ds4_d2K7A of wild7_X5E { C# ds6_d2K7C ->
                                  join {
                                    fail_s2LMP [Dmd=<L,1*C1(U)>] :: Void# -> [Char]
                                    [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                                    fail_s2LMP _ [Occ=Dead, OS=OneShot]
                                      = let {
                                          show_e'_s2LMQ :: String
                                          [LclId]
                                          show_e'_s2LMQ
                                            = case ww2_s2RCd of { I# x_i1AMw ->
                                              case GHC.Show.$wshowSignedInt
                                                     0# (-# x_i1AMw 1#) (GHC.Types.[] @ Char)
                                              of
                                              { (# ww5_i1MP4, ww6_i1MP5 #) ->
                                              GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                                              }
                                              } } in
                                        case ds5_d2K7B of wild8_Xr5 {
                                          [] ->
                                            GHC.Types.:
                                              @ Char
                                              wild7_X5E
                                              (unpackAppendCString# lvl32_r2Ur6 show_e'_s2LMQ);
                                          : ipv_s2KWc ipv1_s2KWd ->
                                            GHC.Types.:
                                              @ Char
                                              wild7_X5E
                                              (GHC.Types.:
                                                 @ Char
                                                 lvl14_r2UqN
                                                 (++
                                                    @ Char
                                                    wild8_Xr5
                                                    (unpackAppendCString#
                                                       lvl33_r2Ur7 show_e'_s2LMQ)))
                                        } } in
                                  case ds6_d2K7C of {
                                    __DEFAULT -> jump fail_s2LMP void#;
                                    '0'# ->
                                      case ds5_d2K7B of {
                                        [] -> lvl16_r2UqP;
                                        : ipv_s2KWi ipv1_s2KWj -> jump fail_s2LMP void#
                                      }
                                  }
                                  }
                              };
                            Just dec_a2I1o ->
                              let {
                                dec'_s2LMV [Dmd=<L,1*U(U)>] :: Int
                                [LclId]
                                dec'_s2LMV
                                  = case dec_a2I1o of wild6_at54 { I# x1_at56 ->
                                    case <=# x1_at56 1# of {
                                      __DEFAULT -> wild6_at54;
                                      1# -> GHC.Float.$fRealFracFloat2
                                    }
                                    } } in
                              join {
                                fail_s2LMU [Dmd=<L,1*C1(U)>] :: Void# -> [Char]
                                [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                                fail_s2LMU _ [Occ=Dead, OS=OneShot]
                                  = let {
                                      ds5_s2LN1 [Dmd=<L,U(U(U),1*U)>] :: (Int, [Int])
                                      [LclId]
                                      ds5_s2LN1
                                        = case GHC.Float.$wroundTo
                                                 base_r2UqK
                                                 (case dec'_s2LMV of { I# x_i1AMi ->
                                                  GHC.Types.I# (+# x_i1AMi 1#)
                                                  })
                                                 ww1_s2RCc
                                          of
                                          { (# ww4_s2RE3, ww5_s2RE4 #) ->
                                          (ww4_s2RE3, ww5_s2RE4)
                                          } } in
                                    let {
                                      ds6_s2LMZ [Dmd=<L,U(1*U,1*U)>] :: (Char, [Char])
                                      [LclId]
                                      ds6_s2LMZ
                                        = case ds5_s2LN1 of { (ei_a2IQN, is'_a2IQP) ->
                                          case ei_a2IQN of { I# x_aA1E ->
                                          case ># x_aA1E 0# of {
                                            __DEFAULT ->
                                              case map @ Int @ Char intToDigit is'_a2IQP of {
                                                [] -> lvl18_r2UqR;
                                                : d_a2IR6 ds'_a2IR8 -> (d_a2IR6, ds'_a2IR8)
                                              };
                                            1# ->
                                              case is'_a2IQP of {
                                                [] -> case GHC.List.init2 of wild9_00 { };
                                                : x1_i2K8j xs_i2K8k ->
                                                  case map
                                                         @ Int
                                                         @ Char
                                                         intToDigit
                                                         (GHC.List.init1 @ Int x1_i2K8j xs_i2K8k)
                                                  of {
                                                    [] -> lvl18_r2UqR;
                                                    : d_a2IR6 ds'_a2IR8 -> (d_a2IR6, ds'_a2IR8)
                                                  }
                                              }
                                          }
                                          }
                                          } } in
                                    GHC.Types.:
                                      @ Char
                                      (case ds6_s2LMZ of { (d_a2IR6, ds'_a2IR8) -> d_a2IR6 })
                                      (GHC.Types.:
                                         @ Char
                                         lvl14_r2UqN
                                         (case ds6_s2LMZ of { (d_a2IR6, ds'_a2IR8) ->
                                          ++
                                            @ Char
                                            ds'_a2IR8
                                            (GHC.Types.:
                                               @ Char
                                               lvl19_r2UqS
                                               (case ww2_s2RCd of { I# x_i1AMw ->
                                                case ds5_s2LN1 of { (ei_a2IQN, is'_a2IQP) ->
                                                case ei_a2IQN of { I# y_i1AMm ->
                                                case GHC.Show.$wshowSignedInt
                                                       0#
                                                       (+# (-# x_i1AMw 1#) y_i1AMm)
                                                       (GHC.Types.[] @ Char)
                                                of
                                                { (# ww5_i1MP4, ww6_i1MP5 #) ->
                                                GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                                                }
                                                }
                                                }
                                                }))
                                          })) } in
                              case ww1_s2RCc of {
                                [] -> jump fail_s2LMU void#;
                                : ds4_d2K9O ds5_d2K9P ->
                                  case ds4_d2K9O of { I# ds6_d2K9Q ->
                                  case ds6_d2K9Q of {
                                    __DEFAULT -> jump fail_s2LMU void#;
                                    0# ->
                                      case ds5_d2K9P of {
                                        [] ->
                                          GHC.Types.:
                                            @ Char
                                            lvl20_r2UqT
                                            (GHC.Types.:
                                               @ Char
                                               lvl14_r2UqN
                                               (case dec'_s2LMV of { I# y_alNd ->
                                                case <# 0# y_alNd of {
                                                  __DEFAULT -> lvl34_r2Ur8;
                                                  1# -> $wxs1_r2Ura y_alNd
                                                }
                                                }));
                                        : ipv_s2KWP ipv1_s2KXh -> jump fail_s2LMU void#
                                      }
                                  }
                                  }
                              }
                          };
                        FFFixed ->
                          case w1_s2RCh of {
                            Nothing ->
                              case ww2_s2RCd of { I# x_at1e ->
                              case <=# x_at1e 0# of {
                                __DEFAULT ->
                                  $wf_r2UqX
                                    x_at1e
                                    (GHC.Types.[] @ Char)
                                    (map @ Int @ Char intToDigit ww1_s2RCc);
                                1# ->
                                  unpackAppendCString#
                                    lvl36_r2Urb
                                    (let {
                                       n_s2NLq [Dmd=<S,U>] :: Int#
                                       [LclId]
                                       n_s2NLq = negateInt# x_at1e } in
                                     case <# 0# n_s2NLq of {
                                       __DEFAULT -> map @ Int @ Char intToDigit ww1_s2RCc;
                                       1# ->
                                         let {
                                           n1_i2KC1 :: [Char]
                                           [LclId]
                                           n1_i2KC1 = map @ Int @ Char intToDigit ww1_s2RCc } in
                                         let {
                                           lvl38_s2SQ5 :: [Char]
                                           [LclId, Unf=OtherCon []]
                                           lvl38_s2SQ5
                                             = GHC.Types.: @ Char lvl20_r2UqT n1_i2KC1 } in
                                         letrec {
                                           $wxs4_s2RC1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                                             :: Int# -> [Char]
                                           [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                           $wxs4_s2RC1
                                             = \ (ww3_s2RBZ :: Int#) ->
                                                 case ww3_s2RBZ of ds4_i2KC9 {
                                                   __DEFAULT ->
                                                     GHC.Types.:
                                                       @ Char
                                                       lvl20_r2UqT
                                                       ($wxs4_s2RC1 (-# ds4_i2KC9 1#));
                                                   1# -> lvl38_s2SQ5
                                                 }; } in
                                         $wxs4_s2RC1 n_s2NLq
                                     })
                              }
                              };
                            Just dec_a2I1F ->
                              case ww2_s2RCd of wild6_alMW { I# x_alMY ->
                              case >=# x_alMY 0# of {
                                __DEFAULT ->
                                  let {
                                    ds4_s2LNa [Dmd=<L,U(1*U,1*U)>] :: (Char, [Char])
                                    [LclId]
                                    ds4_s2LNa
                                      = let {
                                          n_s2NLz [Dmd=<S,U>] :: Int#
                                          [LclId]
                                          n_s2NLz = negateInt# x_alMY } in
                                        case <# 0# n_s2NLz of {
                                          __DEFAULT ->
                                            case GHC.Float.$wroundTo
                                                   base_r2UqK
                                                   (case dec_a2I1F of wild7_at54 { I# x1_at56 ->
                                                    case <=# x1_at56 0# of {
                                                      __DEFAULT -> wild7_at54;
                                                      1# -> minExpt
                                                    }
                                                    })
                                                   ww1_s2RCc
                                            of
                                            { (# ww4_s2RE3, ww5_s2RE4 #) ->
                                            $j_r2Urc ww4_s2RE3 ww5_s2RE4
                                            };
                                          1# ->
                                            let {
                                              lvl38_s2SQ8 :: [Int]
                                              [LclId, Unf=OtherCon []]
                                              lvl38_s2SQ8 = GHC.Types.: @ Int minExpt ww1_s2RCc } in
                                            letrec {
                                              $wxs4_s2RC7 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                                                :: Int# -> [Int]
                                              [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                              $wxs4_s2RC7
                                                = \ (ww3_s2RC5 :: Int#) ->
                                                    case ww3_s2RC5 of ds5_i2KC9 {
                                                      __DEFAULT ->
                                                        GHC.Types.:
                                                          @ Int
                                                          minExpt
                                                          ($wxs4_s2RC7 (-# ds5_i2KC9 1#));
                                                      1# -> lvl38_s2SQ8
                                                    }; } in
                                            case GHC.Float.$wroundTo
                                                   base_r2UqK
                                                   (case dec_a2I1F of wild7_at54 { I# x1_at56 ->
                                                    case <=# x1_at56 0# of {
                                                      __DEFAULT -> wild7_at54;
                                                      1# -> minExpt
                                                    }
                                                    })
                                                   ($wxs4_s2RC7 n_s2NLz)
                                            of
                                            { (# ww4_s2RE3, ww5_s2RE4 #) ->
                                            $j_r2Urc ww4_s2RE3 ww5_s2RE4
                                            }
                                        } } in
                                  GHC.Types.:
                                    @ Char
                                    (case ds4_s2LNa of { (d_a2IUk, ds'_a2IUm) -> d_a2IUk })
                                    (case ds4_s2LNa of { (d_a2IUk, ds'_a2IUm) ->
                                     case ds'_a2IUm of wild7_i2KaD {
                                       [] ->
                                         case w2_s2RCi of {
                                           False -> GHC.Types.[] @ Char;
                                           True -> lvl37_r2Urd
                                         };
                                       : ds6_i2Mqv ds7_i2Mqw ->
                                         GHC.Types.: @ Char lvl14_r2UqN wild7_i2KaD
                                     }
                                     });
                                1# ->
                                  case GHC.Float.$wroundTo
                                         base_r2UqK
                                         (case dec_a2I1F of { I# x1_at56 ->
                                          case <=# x1_at56 0# of {
                                            __DEFAULT -> GHC.Types.I# (+# x1_at56 x_alMY);
                                            1# -> wild6_alMW
                                          }
                                          })
                                         ww1_s2RCc
                                  of
                                  { (# ww4_s2RE3, ww5_s2RE4 #) ->
                                  case ww4_s2RE3 of { I# y_i1AMm ->
                                  let {
                                    x1_i2KaL [Dmd=<S,U>] :: Int#
                                    [LclId]
                                    x1_i2KaL = +# x_alMY y_i1AMm } in
                                  case <=# x1_i2KaL 0# of {
                                    __DEFAULT ->
                                      case GHC.List.$wsplitAt'
                                             @ Char
                                             (GHC.Types.I# x1_i2KaL)
                                             (map @ Int @ Char intToDigit ww5_s2RE4)
                                      of
                                      { (# ww7_i2KYm, ww8_i2KYn #) ->
                                      case ww7_i2KYm of wild8_Xh6 {
                                        [] ->
                                          ++
                                            @ Char
                                            lvl23_r2UqW
                                            (case ww8_i2KYn of wild9_i2KaD {
                                               [] ->
                                                 case w2_s2RCi of {
                                                   False -> GHC.Types.[] @ Char;
                                                   True -> lvl37_r2Urd
                                                 };
                                               : ds4_i2Mqv ds5_i2Mqw ->
                                                 GHC.Types.: @ Char lvl14_r2UqN wild9_i2KaD
                                             });
                                        : ipv_s2KXk ipv1_s2KXl ->
                                          ++
                                            @ Char
                                            wild8_Xh6
                                            (case ww8_i2KYn of wild9_i2KaD {
                                               [] ->
                                                 case w2_s2RCi of {
                                                   False -> GHC.Types.[] @ Char;
                                                   True -> lvl37_r2Urd
                                                 };
                                               : ds4_i2Mqv ds5_i2Mqw ->
                                                 GHC.Types.: @ Char lvl14_r2UqN wild9_i2KaD
                                             })
                                      }
                                      };
                                    1# ->
                                      ++
                                        @ Char
                                        lvl23_r2UqW
                                        (case map @ Int @ Char intToDigit ww5_s2RE4 of wild8_i2KaD {
                                           [] ->
                                             case w2_s2RCi of {
                                               False -> GHC.Types.[] @ Char;
                                               True -> lvl37_r2Urd
                                             };
                                           : ds4_i2Mqv ds5_i2Mqw ->
                                             GHC.Types.: @ Char lvl14_r2UqN wild8_i2KaD
                                         })
                                  }
                                  }
                                  }
                              }
                              }
                          };
                        FFGeneric ->
                          case ww2_s2RCd of wild5_alN7 { I# x_alN9 ->
                          case <# x_alN9 0# of {
                            __DEFAULT ->
                              case ># x_alN9 7# of {
                                __DEFAULT -> $wdoFmt_s2RCf GHC.Float.FFFixed ww1_s2RCc wild5_alN7;
                                1# -> $wdoFmt_s2RCf GHC.Float.FFExponent ww1_s2RCc wild5_alN7
                              };
                            1# -> $wdoFmt_s2RCf GHC.Float.FFExponent ww1_s2RCc wild5_alN7
                          }
                          }
                      }; } in
              join {
                $j1_s2MqZ [Dmd=<L,1*U>] :: [Char]
                [LclId[JoinId(0)], Unf=OtherCon []]
                $j1_s2MqZ
                  = GHC.Types.:
                      @ Char
                      GHC.Float.$fShowDouble3
                      (case GHC.Float.$w$sfloatToDigits1
                              GHC.Float.expts4 (negateFloat# ww_s2RCm)
                       of
                       { (# ww2_s2RE6, ww3_s2RE7 #) ->
                       $wdoFmt_s2RCf w_s2RCg ww2_s2RE6 ww3_s2RE7
                       }) } in
              case ltFloat# ww_s2RCm 0.0# of {
                __DEFAULT ->
                  case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kvk
                         ww_s2RCm realWorld#
                  of
                  { (# ds4_d2Kvj, ds5_d2Kvi #) ->
                  case ds5_d2Kvi of {
                    __DEFAULT -> jump $j1_s2MqZ;
                    0# ->
                      case GHC.Float.$w$sfloatToDigits1 GHC.Float.expts4 ww_s2RCm of
                      { (# ww2_s2RE6, ww3_s2RE7 #) ->
                      $wdoFmt_s2RCf w_s2RCg ww2_s2RE6 ww3_s2RE7
                      }
                  }
                  };
                1# -> jump $j1_s2MqZ
              }
          }
          }
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
GHC.Float.$fShowFloat_$sformatRealFloatAlt [InlPrag=NOUSERINLINE[0]]
  :: FFFormat -> Maybe Int -> Bool -> Float -> String
[GblId,
 Arity=4,
 Str=<L,1*U><L,U><L,U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2RCg [Occ=Once] :: FFFormat)
                 (w1_s2RCh [Occ=Once] :: Maybe Int)
                 (w2_s2RCi [Occ=Once] :: Bool)
                 (w3_s2RCj [Occ=Once!] :: Float) ->
                 case w3_s2RCj of { F# ww1_s2RCm [Occ=Once] ->
                 GHC.Float.$w$sformatRealFloatAlt1
                   w_s2RCg w1_s2RCh w2_s2RCi ww1_s2RCm
                 }}]
GHC.Float.$fShowFloat_$sformatRealFloatAlt
  = \ (w_s2RCg :: FFFormat)
      (w1_s2RCh :: Maybe Int)
      (w2_s2RCi :: Bool)
      (w3_s2RCj :: Float) ->
      case w3_s2RCj of { F# ww1_s2RCm ->
      GHC.Float.$w$sformatRealFloatAlt1
        w_s2RCg w1_s2RCh w2_s2RCi ww1_s2RCm
      }

Rec {
-- RHS size: {terms: 12, types: 3, coercions: 0, joins: 0/0}
$wxs2_r2Ure :: Int# -> [Char]
[GblId, Arity=1, Str=<S,1*U>m2, Unf=OtherCon []]
$wxs2_r2Ure
  = \ (ww_s2RCC :: Int#) ->
      case ww_s2RCC of ds1_i2KC9 {
        __DEFAULT ->
          GHC.Types.: @ Char lvl20_r2UqT ($wxs2_r2Ure (-# ds1_i2KC9 1#));
        1# -> lvl35_r2Ur9
      }
end Rec }

-- RHS size: {terms: 555, types: 407, coercions: 0, joins: 3/17}
GHC.Float.$w$sformatRealFloatAlt [InlPrag=NOUSERINLINE[0]]
  :: FFFormat -> Maybe Int -> Bool -> Double# -> [Char]
[GblId, Arity=4, Str=<L,1*U><L,U><L,U><S,U>, Unf=OtherCon []]
GHC.Float.$w$sformatRealFloatAlt
  = \ (w_s2RCZ :: FFFormat)
      (w1_s2RD0 :: Maybe Int)
      (w2_s2RD1 :: Bool)
      (ww_s2RD5 :: Double#) ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2Kv6
             ww_s2RD5 realWorld#
      of
      { (# ds_d2Kv5, ds1_d2Kv4 #) ->
      case ds1_d2Kv4 of {
        __DEFAULT -> lvl31_r2Ur5;
        0# ->
          case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuZ
                 ww_s2RD5 realWorld#
          of
          { (# ds2_d2KuY, ds3_d2KuX #) ->
          case ds3_d2KuX of {
            __DEFAULT ->
              case <## ww_s2RD5 0.0## of {
                __DEFAULT -> lvl27_r2Ur1;
                1# -> lvl29_r2Ur3
              };
            0# ->
              letrec {
                $wdoFmt_s2RCY [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                  :: FFFormat -> [Int] -> Int -> [Char]
                [LclId, Arity=3, Str=<S,1*U><L,U><L,1*U(U)>, Unf=OtherCon []]
                $wdoFmt_s2RCY
                  = \ (w3_s2RCR :: FFFormat)
                      (ww1_s2RCV :: [Int])
                      (ww2_s2RCW :: Int) ->
                      case w3_s2RCR of {
                        FFExponent ->
                          case w1_s2RD0 of {
                            Nothing ->
                              case map @ Int @ Char intToDigit ww1_s2RCV of {
                                [] -> lvl13_r2UqM;
                                : ds4_d2K7A ds5_d2K7B ->
                                  case ds4_d2K7A of wild7_X5E { C# ds6_d2K7C ->
                                  join {
                                    fail_s2LM3 [Dmd=<L,1*C1(U)>] :: Void# -> [Char]
                                    [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                                    fail_s2LM3 _ [Occ=Dead, OS=OneShot]
                                      = let {
                                          show_e'_s2LM4 :: String
                                          [LclId]
                                          show_e'_s2LM4
                                            = case ww2_s2RCW of { I# x_i1AMw ->
                                              case GHC.Show.$wshowSignedInt
                                                     0# (-# x_i1AMw 1#) (GHC.Types.[] @ Char)
                                              of
                                              { (# ww5_i1MP4, ww6_i1MP5 #) ->
                                              GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                                              }
                                              } } in
                                        case ds5_d2K7B of wild8_XrJ {
                                          [] ->
                                            GHC.Types.:
                                              @ Char
                                              wild7_X5E
                                              (unpackAppendCString# lvl32_r2Ur6 show_e'_s2LM4);
                                          : ipv_s2KWc ipv1_s2KWd ->
                                            GHC.Types.:
                                              @ Char
                                              wild7_X5E
                                              (GHC.Types.:
                                                 @ Char
                                                 lvl14_r2UqN
                                                 (++
                                                    @ Char
                                                    wild8_XrJ
                                                    (unpackAppendCString#
                                                       lvl33_r2Ur7 show_e'_s2LM4)))
                                        } } in
                                  case ds6_d2K7C of {
                                    __DEFAULT -> jump fail_s2LM3 void#;
                                    '0'# ->
                                      case ds5_d2K7B of {
                                        [] -> lvl16_r2UqP;
                                        : ipv_s2KWi ipv1_s2KWj -> jump fail_s2LM3 void#
                                      }
                                  }
                                  }
                              };
                            Just dec_a2I1o ->
                              let {
                                dec'_s2LM9 [Dmd=<L,1*U(U)>] :: Int
                                [LclId]
                                dec'_s2LM9
                                  = case dec_a2I1o of wild6_at54 { I# x1_at56 ->
                                    case <=# x1_at56 1# of {
                                      __DEFAULT -> wild6_at54;
                                      1# -> GHC.Float.$fRealFracFloat2
                                    }
                                    } } in
                              join {
                                fail_s2LM8 [Dmd=<L,1*C1(U)>] :: Void# -> [Char]
                                [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                                fail_s2LM8 _ [Occ=Dead, OS=OneShot]
                                  = let {
                                      ds5_s2LMf [Dmd=<L,U(U(U),1*U)>] :: (Int, [Int])
                                      [LclId]
                                      ds5_s2LMf
                                        = case GHC.Float.$wroundTo
                                                 base_r2UqK
                                                 (case dec'_s2LM9 of { I# x_i1AMi ->
                                                  GHC.Types.I# (+# x_i1AMi 1#)
                                                  })
                                                 ww1_s2RCV
                                          of
                                          { (# ww4_s2RE3, ww5_s2RE4 #) ->
                                          (ww4_s2RE3, ww5_s2RE4)
                                          } } in
                                    let {
                                      ds6_s2LMd [Dmd=<L,U(1*U,1*U)>] :: (Char, [Char])
                                      [LclId]
                                      ds6_s2LMd
                                        = case ds5_s2LMf of { (ei_a2IQN, is'_a2IQP) ->
                                          case ei_a2IQN of { I# x_aA1E ->
                                          case ># x_aA1E 0# of {
                                            __DEFAULT ->
                                              case map @ Int @ Char intToDigit is'_a2IQP of {
                                                [] -> lvl18_r2UqR;
                                                : d_a2IR6 ds'_a2IR8 -> (d_a2IR6, ds'_a2IR8)
                                              };
                                            1# ->
                                              case is'_a2IQP of {
                                                [] -> case GHC.List.init2 of wild9_00 { };
                                                : x1_i2K8j xs_i2K8k ->
                                                  case map
                                                         @ Int
                                                         @ Char
                                                         intToDigit
                                                         (GHC.List.init1 @ Int x1_i2K8j xs_i2K8k)
                                                  of {
                                                    [] -> lvl18_r2UqR;
                                                    : d_a2IR6 ds'_a2IR8 -> (d_a2IR6, ds'_a2IR8)
                                                  }
                                              }
                                          }
                                          }
                                          } } in
                                    GHC.Types.:
                                      @ Char
                                      (case ds6_s2LMd of { (d_a2IR6, ds'_a2IR8) -> d_a2IR6 })
                                      (GHC.Types.:
                                         @ Char
                                         lvl14_r2UqN
                                         (case ds6_s2LMd of { (d_a2IR6, ds'_a2IR8) ->
                                          ++
                                            @ Char
                                            ds'_a2IR8
                                            (GHC.Types.:
                                               @ Char
                                               lvl19_r2UqS
                                               (case ww2_s2RCW of { I# x_i1AMw ->
                                                case ds5_s2LMf of { (ei_a2IQN, is'_a2IQP) ->
                                                case ei_a2IQN of { I# y_i1AMm ->
                                                case GHC.Show.$wshowSignedInt
                                                       0#
                                                       (+# (-# x_i1AMw 1#) y_i1AMm)
                                                       (GHC.Types.[] @ Char)
                                                of
                                                { (# ww5_i1MP4, ww6_i1MP5 #) ->
                                                GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                                                }
                                                }
                                                }
                                                }))
                                          })) } in
                              case ww1_s2RCV of {
                                [] -> jump fail_s2LM8 void#;
                                : ds4_d2K9O ds5_d2K9P ->
                                  case ds4_d2K9O of { I# ds6_d2K9Q ->
                                  case ds6_d2K9Q of {
                                    __DEFAULT -> jump fail_s2LM8 void#;
                                    0# ->
                                      case ds5_d2K9P of {
                                        [] ->
                                          GHC.Types.:
                                            @ Char
                                            lvl20_r2UqT
                                            (GHC.Types.:
                                               @ Char
                                               lvl14_r2UqN
                                               (case dec'_s2LM9 of { I# y_alNd ->
                                                case <# 0# y_alNd of {
                                                  __DEFAULT -> lvl34_r2Ur8;
                                                  1# -> $wxs2_r2Ure y_alNd
                                                }
                                                }));
                                        : ipv_s2KWP ipv1_s2KXh -> jump fail_s2LM8 void#
                                      }
                                  }
                                  }
                              }
                          };
                        FFFixed ->
                          case w1_s2RD0 of {
                            Nothing ->
                              case ww2_s2RCW of { I# x_at1e ->
                              case <=# x_at1e 0# of {
                                __DEFAULT ->
                                  $wf_r2UqX
                                    x_at1e
                                    (GHC.Types.[] @ Char)
                                    (map @ Int @ Char intToDigit ww1_s2RCV);
                                1# ->
                                  unpackAppendCString#
                                    lvl36_r2Urb
                                    (let {
                                       n_s2NN5 [Dmd=<S,U>] :: Int#
                                       [LclId]
                                       n_s2NN5 = negateInt# x_at1e } in
                                     case <# 0# n_s2NN5 of {
                                       __DEFAULT -> map @ Int @ Char intToDigit ww1_s2RCV;
                                       1# ->
                                         let {
                                           n1_i2KC1 :: [Char]
                                           [LclId]
                                           n1_i2KC1 = map @ Int @ Char intToDigit ww1_s2RCV } in
                                         let {
                                           lvl38_s2SQp :: [Char]
                                           [LclId, Unf=OtherCon []]
                                           lvl38_s2SQp
                                             = GHC.Types.: @ Char lvl20_r2UqT n1_i2KC1 } in
                                         letrec {
                                           $wxs4_s2RCK [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                                             :: Int# -> [Char]
                                           [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                           $wxs4_s2RCK
                                             = \ (ww3_s2RCI :: Int#) ->
                                                 case ww3_s2RCI of ds4_i2KC9 {
                                                   __DEFAULT ->
                                                     GHC.Types.:
                                                       @ Char
                                                       lvl20_r2UqT
                                                       ($wxs4_s2RCK (-# ds4_i2KC9 1#));
                                                   1# -> lvl38_s2SQp
                                                 }; } in
                                         $wxs4_s2RCK n_s2NN5
                                     })
                              }
                              };
                            Just dec_a2I1F ->
                              case ww2_s2RCW of wild6_alMW { I# x_alMY ->
                              case >=# x_alMY 0# of {
                                __DEFAULT ->
                                  let {
                                    ds4_s2LMo [Dmd=<L,U(1*U,1*U)>] :: (Char, [Char])
                                    [LclId]
                                    ds4_s2LMo
                                      = let {
                                          n_s2NNe [Dmd=<S,U>] :: Int#
                                          [LclId]
                                          n_s2NNe = negateInt# x_alMY } in
                                        case <# 0# n_s2NNe of {
                                          __DEFAULT ->
                                            case GHC.Float.$wroundTo
                                                   base_r2UqK
                                                   (case dec_a2I1F of wild7_at54 { I# x1_at56 ->
                                                    case <=# x1_at56 0# of {
                                                      __DEFAULT -> wild7_at54;
                                                      1# -> minExpt
                                                    }
                                                    })
                                                   ww1_s2RCV
                                            of
                                            { (# ww4_s2RE3, ww5_s2RE4 #) ->
                                            $j_r2Urc ww4_s2RE3 ww5_s2RE4
                                            };
                                          1# ->
                                            let {
                                              lvl38_s2SQs :: [Int]
                                              [LclId, Unf=OtherCon []]
                                              lvl38_s2SQs = GHC.Types.: @ Int minExpt ww1_s2RCV } in
                                            letrec {
                                              $wxs4_s2RCQ [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                                                :: Int# -> [Int]
                                              [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                              $wxs4_s2RCQ
                                                = \ (ww3_s2RCO :: Int#) ->
                                                    case ww3_s2RCO of ds5_i2KC9 {
                                                      __DEFAULT ->
                                                        GHC.Types.:
                                                          @ Int
                                                          minExpt
                                                          ($wxs4_s2RCQ (-# ds5_i2KC9 1#));
                                                      1# -> lvl38_s2SQs
                                                    }; } in
                                            case GHC.Float.$wroundTo
                                                   base_r2UqK
                                                   (case dec_a2I1F of wild7_at54 { I# x1_at56 ->
                                                    case <=# x1_at56 0# of {
                                                      __DEFAULT -> wild7_at54;
                                                      1# -> minExpt
                                                    }
                                                    })
                                                   ($wxs4_s2RCQ n_s2NNe)
                                            of
                                            { (# ww4_s2RE3, ww5_s2RE4 #) ->
                                            $j_r2Urc ww4_s2RE3 ww5_s2RE4
                                            }
                                        } } in
                                  GHC.Types.:
                                    @ Char
                                    (case ds4_s2LMo of { (d_a2IUk, ds'_a2IUm) -> d_a2IUk })
                                    (case ds4_s2LMo of { (d_a2IUk, ds'_a2IUm) ->
                                     case ds'_a2IUm of wild7_i2KaD {
                                       [] ->
                                         case w2_s2RD1 of {
                                           False -> GHC.Types.[] @ Char;
                                           True -> lvl37_r2Urd
                                         };
                                       : ds6_i2Mqv ds7_i2Mqw ->
                                         GHC.Types.: @ Char lvl14_r2UqN wild7_i2KaD
                                     }
                                     });
                                1# ->
                                  case GHC.Float.$wroundTo
                                         base_r2UqK
                                         (case dec_a2I1F of { I# x1_at56 ->
                                          case <=# x1_at56 0# of {
                                            __DEFAULT -> GHC.Types.I# (+# x1_at56 x_alMY);
                                            1# -> wild6_alMW
                                          }
                                          })
                                         ww1_s2RCV
                                  of
                                  { (# ww4_s2RE3, ww5_s2RE4 #) ->
                                  case ww4_s2RE3 of { I# y_i1AMm ->
                                  let {
                                    x1_i2KaL [Dmd=<S,U>] :: Int#
                                    [LclId]
                                    x1_i2KaL = +# x_alMY y_i1AMm } in
                                  case <=# x1_i2KaL 0# of {
                                    __DEFAULT ->
                                      case GHC.List.$wsplitAt'
                                             @ Char
                                             (GHC.Types.I# x1_i2KaL)
                                             (map @ Int @ Char intToDigit ww5_s2RE4)
                                      of
                                      { (# ww7_i2KYm, ww8_i2KYn #) ->
                                      case ww7_i2KYm of wild8_Xh6 {
                                        [] ->
                                          ++
                                            @ Char
                                            lvl23_r2UqW
                                            (case ww8_i2KYn of wild9_i2KaD {
                                               [] ->
                                                 case w2_s2RD1 of {
                                                   False -> GHC.Types.[] @ Char;
                                                   True -> lvl37_r2Urd
                                                 };
                                               : ds4_i2Mqv ds5_i2Mqw ->
                                                 GHC.Types.: @ Char lvl14_r2UqN wild9_i2KaD
                                             });
                                        : ipv_s2KXk ipv1_s2KXl ->
                                          ++
                                            @ Char
                                            wild8_Xh6
                                            (case ww8_i2KYn of wild9_i2KaD {
                                               [] ->
                                                 case w2_s2RD1 of {
                                                   False -> GHC.Types.[] @ Char;
                                                   True -> lvl37_r2Urd
                                                 };
                                               : ds4_i2Mqv ds5_i2Mqw ->
                                                 GHC.Types.: @ Char lvl14_r2UqN wild9_i2KaD
                                             })
                                      }
                                      };
                                    1# ->
                                      ++
                                        @ Char
                                        lvl23_r2UqW
                                        (case map @ Int @ Char intToDigit ww5_s2RE4 of wild8_i2KaD {
                                           [] ->
                                             case w2_s2RD1 of {
                                               False -> GHC.Types.[] @ Char;
                                               True -> lvl37_r2Urd
                                             };
                                           : ds4_i2Mqv ds5_i2Mqw ->
                                             GHC.Types.: @ Char lvl14_r2UqN wild8_i2KaD
                                         })
                                  }
                                  }
                                  }
                              }
                              }
                          };
                        FFGeneric ->
                          case ww2_s2RCW of wild5_alN7 { I# x_alN9 ->
                          case <# x_alN9 0# of {
                            __DEFAULT ->
                              case ># x_alN9 7# of {
                                __DEFAULT -> $wdoFmt_s2RCY GHC.Float.FFFixed ww1_s2RCV wild5_alN7;
                                1# -> $wdoFmt_s2RCY GHC.Float.FFExponent ww1_s2RCV wild5_alN7
                              };
                            1# -> $wdoFmt_s2RCY GHC.Float.FFExponent ww1_s2RCV wild5_alN7
                          }
                          }
                      }; } in
              join {
                $j1_s2Msn [Dmd=<L,1*U>] :: [Char]
                [LclId[JoinId(0)], Unf=OtherCon []]
                $j1_s2Msn
                  = GHC.Types.:
                      @ Char
                      GHC.Float.$fShowDouble3
                      (case GHC.Float.$w$sfloatToDigits
                              GHC.Float.expts4 (negateDouble# ww_s2RD5)
                       of
                       { (# ww2_s2RE9, ww3_s2REa #) ->
                       $wdoFmt_s2RCY w_s2RCZ ww2_s2RE9 ww3_s2REa
                       }) } in
              case <## ww_s2RD5 0.0## of {
                __DEFAULT ->
                  case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2KuL
                         ww_s2RD5 realWorld#
                  of
                  { (# ds4_d2KuK, ds5_d2KuJ #) ->
                  case ds5_d2KuJ of {
                    __DEFAULT -> jump $j1_s2Msn;
                    0# ->
                      case GHC.Float.$w$sfloatToDigits GHC.Float.expts4 ww_s2RD5 of
                      { (# ww2_s2RE9, ww3_s2REa #) ->
                      $wdoFmt_s2RCY w_s2RCZ ww2_s2RE9 ww3_s2REa
                      }
                  }
                  };
                1# -> jump $j1_s2Msn
              }
          }
          }
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
GHC.Float.$fShowDouble_$sformatRealFloatAlt [InlPrag=NOUSERINLINE[0]]
  :: FFFormat -> Maybe Int -> Bool -> Double -> String
[GblId,
 Arity=4,
 Str=<L,1*U><L,U><L,U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2RCZ [Occ=Once] :: FFFormat)
                 (w1_s2RD0 [Occ=Once] :: Maybe Int)
                 (w2_s2RD1 [Occ=Once] :: Bool)
                 (w3_s2RD2 [Occ=Once!] :: Double) ->
                 case w3_s2RD2 of { D# ww1_s2RD5 [Occ=Once] ->
                 GHC.Float.$w$sformatRealFloatAlt
                   w_s2RCZ w1_s2RD0 w2_s2RD1 ww1_s2RD5
                 }}]
GHC.Float.$fShowDouble_$sformatRealFloatAlt
  = \ (w_s2RCZ :: FFFormat)
      (w1_s2RD0 :: Maybe Int)
      (w2_s2RD1 :: Bool)
      (w3_s2RD2 :: Double) ->
      case w3_s2RD2 of { D# ww1_s2RD5 ->
      GHC.Float.$w$sformatRealFloatAlt
        w_s2RCZ w1_s2RD0 w2_s2RD1 ww1_s2RD5
      }

Rec {
-- RHS size: {terms: 12, types: 3, coercions: 0, joins: 0/0}
$wxs3_r2Urf :: Int# -> [Char]
[GblId, Arity=1, Str=<S,1*U>m2, Unf=OtherCon []]
$wxs3_r2Urf
  = \ (ww_s2RDl :: Int#) ->
      case ww_s2RDl of ds1_i2KC9 {
        __DEFAULT ->
          GHC.Types.: @ Char lvl20_r2UqT ($wxs3_r2Urf (-# ds1_i2KC9 1#));
        1# -> lvl35_r2Ur9
      }
end Rec }

-- RHS size: {terms: 568, types: 399, coercions: 0, joins: 3/20}
formatRealFloatAlt
  :: forall a.
     RealFloat a =>
     FFFormat -> Maybe Int -> Bool -> a -> String
[GblId,
 Arity=5,
 Str=<S(LLLLLLLLLLC(S)LLLLL),U(U(U(U(A,A,A,1*C1(U),A,A,C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,1*C1(U),1*C1(U),A,1*C1(U),A,A)><L,1*U><L,U><L,U><L,U>,
 Unf=OtherCon []]
formatRealFloatAlt
  = \ (@ a_a2IOQ)
      ($dRealFloat_a2IOS :: RealFloat a_a2IOQ)
      (eta_B4 :: FFFormat)
      (eta1_B3 :: Maybe Int)
      (eta2_B2 :: Bool)
      (eta3_B1 :: a_a2IOQ) ->
      case isNaN @ a_a2IOQ $dRealFloat_a2IOS eta3_B1 of {
        False ->
          let {
            $dRealFrac_s2LLd [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A)>]
              :: RealFrac a_a2IOQ
            [LclId]
            $dRealFrac_s2LLd
              = GHC.Float.$p1RealFloat @ a_a2IOQ $dRealFloat_a2IOS } in
          let {
            $dReal_s2LLc [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
              :: Real a_a2IOQ
            [LclId]
            $dReal_s2LLc = GHC.Real.$p1RealFrac @ a_a2IOQ $dRealFrac_s2LLd } in
          let {
            $dNum_s2LLb [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>] :: Num a_a2IOQ
            [LclId]
            $dNum_s2LLb = GHC.Real.$p1Real @ a_a2IOQ $dReal_s2LLc } in
          case isInfinite @ a_a2IOQ $dRealFloat_a2IOS eta3_B1 of {
            False ->
              letrec {
                $wdoFmt_s2RDH [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                  :: FFFormat -> [Int] -> Int -> [Char]
                [LclId, Arity=3, Str=<S,1*U><L,U><L,1*U(U)>, Unf=OtherCon []]
                $wdoFmt_s2RDH
                  = \ (w_s2RDA :: FFFormat) (ww_s2RDE :: [Int]) (ww1_s2RDF :: Int) ->
                      case w_s2RDA of {
                        FFExponent ->
                          case eta1_B3 of {
                            Nothing ->
                              case map @ Int @ Char intToDigit ww_s2RDE of {
                                [] -> lvl13_r2UqM;
                                : ds_d2K7A ds1_d2K7B ->
                                  case ds_d2K7A of wild5_X5E { C# ds2_d2K7C ->
                                  join {
                                    fail_s2LLh [Dmd=<L,1*C1(U)>] :: Void# -> [Char]
                                    [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                                    fail_s2LLh _ [Occ=Dead, OS=OneShot]
                                      = let {
                                          show_e'_s2LLi :: String
                                          [LclId]
                                          show_e'_s2LLi
                                            = case ww1_s2RDF of { I# x_i1AMw ->
                                              case GHC.Show.$wshowSignedInt
                                                     0# (-# x_i1AMw 1#) (GHC.Types.[] @ Char)
                                              of
                                              { (# ww5_i1MP4, ww6_i1MP5 #) ->
                                              GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                                              }
                                              } } in
                                        case ds1_d2K7B of wild6_Xsh {
                                          [] ->
                                            GHC.Types.:
                                              @ Char
                                              wild5_X5E
                                              (unpackAppendCString# lvl32_r2Ur6 show_e'_s2LLi);
                                          : ipv_s2KWc ipv1_s2KWd ->
                                            GHC.Types.:
                                              @ Char
                                              wild5_X5E
                                              (GHC.Types.:
                                                 @ Char
                                                 lvl14_r2UqN
                                                 (++
                                                    @ Char
                                                    wild6_Xsh
                                                    (unpackAppendCString#
                                                       lvl33_r2Ur7 show_e'_s2LLi)))
                                        } } in
                                  case ds2_d2K7C of {
                                    __DEFAULT -> jump fail_s2LLh void#;
                                    '0'# ->
                                      case ds1_d2K7B of {
                                        [] -> lvl16_r2UqP;
                                        : ipv_s2KWi ipv1_s2KWj -> jump fail_s2LLh void#
                                      }
                                  }
                                  }
                              };
                            Just dec_a2I1o ->
                              let {
                                dec'_s2LLn [Dmd=<L,1*U(U)>] :: Int
                                [LclId]
                                dec'_s2LLn
                                  = case dec_a2I1o of wild4_at54 { I# x1_at56 ->
                                    case <=# x1_at56 1# of {
                                      __DEFAULT -> wild4_at54;
                                      1# -> GHC.Float.$fRealFracFloat2
                                    }
                                    } } in
                              join {
                                fail_s2LLm [Dmd=<L,1*C1(U)>] :: Void# -> [Char]
                                [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                                fail_s2LLm _ [Occ=Dead, OS=OneShot]
                                  = let {
                                      ds1_s2LLt [Dmd=<L,U(U(U),1*U)>] :: (Int, [Int])
                                      [LclId]
                                      ds1_s2LLt
                                        = case GHC.Float.$wroundTo
                                                 base_r2UqK
                                                 (case dec'_s2LLn of { I# x_i1AMi ->
                                                  GHC.Types.I# (+# x_i1AMi 1#)
                                                  })
                                                 ww_s2RDE
                                          of
                                          { (# ww3_s2RE3, ww4_s2RE4 #) ->
                                          (ww3_s2RE3, ww4_s2RE4)
                                          } } in
                                    let {
                                      ds2_s2LLr [Dmd=<L,U(1*U,1*U)>] :: (Char, [Char])
                                      [LclId]
                                      ds2_s2LLr
                                        = case ds1_s2LLt of { (ei_a2IQN, is'_a2IQP) ->
                                          case ei_a2IQN of { I# x_aA1E ->
                                          case ># x_aA1E 0# of {
                                            __DEFAULT ->
                                              case map @ Int @ Char intToDigit is'_a2IQP of {
                                                [] -> lvl18_r2UqR;
                                                : d_a2IR6 ds'_a2IR8 -> (d_a2IR6, ds'_a2IR8)
                                              };
                                            1# ->
                                              case is'_a2IQP of {
                                                [] -> case GHC.List.init2 of wild7_00 { };
                                                : x1_i2K8j xs_i2K8k ->
                                                  case map
                                                         @ Int
                                                         @ Char
                                                         intToDigit
                                                         (GHC.List.init1 @ Int x1_i2K8j xs_i2K8k)
                                                  of {
                                                    [] -> lvl18_r2UqR;
                                                    : d_a2IR6 ds'_a2IR8 -> (d_a2IR6, ds'_a2IR8)
                                                  }
                                              }
                                          }
                                          }
                                          } } in
                                    GHC.Types.:
                                      @ Char
                                      (case ds2_s2LLr of { (d_a2IR6, ds'_a2IR8) -> d_a2IR6 })
                                      (GHC.Types.:
                                         @ Char
                                         lvl14_r2UqN
                                         (case ds2_s2LLr of { (d_a2IR6, ds'_a2IR8) ->
                                          ++
                                            @ Char
                                            ds'_a2IR8
                                            (GHC.Types.:
                                               @ Char
                                               lvl19_r2UqS
                                               (case ww1_s2RDF of { I# x_i1AMw ->
                                                case ds1_s2LLt of { (ei_a2IQN, is'_a2IQP) ->
                                                case ei_a2IQN of { I# y_i1AMm ->
                                                case GHC.Show.$wshowSignedInt
                                                       0#
                                                       (+# (-# x_i1AMw 1#) y_i1AMm)
                                                       (GHC.Types.[] @ Char)
                                                of
                                                { (# ww5_i1MP4, ww6_i1MP5 #) ->
                                                GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                                                }
                                                }
                                                }
                                                }))
                                          })) } in
                              case ww_s2RDE of {
                                [] -> jump fail_s2LLm void#;
                                : ds_d2K9O ds1_d2K9P ->
                                  case ds_d2K9O of { I# ds2_d2K9Q ->
                                  case ds2_d2K9Q of {
                                    __DEFAULT -> jump fail_s2LLm void#;
                                    0# ->
                                      case ds1_d2K9P of {
                                        [] ->
                                          GHC.Types.:
                                            @ Char
                                            lvl20_r2UqT
                                            (GHC.Types.:
                                               @ Char
                                               lvl14_r2UqN
                                               (case dec'_s2LLn of { I# y_alNd ->
                                                case <# 0# y_alNd of {
                                                  __DEFAULT -> lvl34_r2Ur8;
                                                  1# -> $wxs3_r2Urf y_alNd
                                                }
                                                }));
                                        : ipv_s2KWP ipv1_s2KXh -> jump fail_s2LLm void#
                                      }
                                  }
                                  }
                              }
                          };
                        FFFixed ->
                          case eta1_B3 of {
                            Nothing ->
                              case ww1_s2RDF of { I# x_at1e ->
                              case <=# x_at1e 0# of {
                                __DEFAULT ->
                                  $wf_r2UqX
                                    x_at1e
                                    (GHC.Types.[] @ Char)
                                    (map @ Int @ Char intToDigit ww_s2RDE);
                                1# ->
                                  unpackAppendCString#
                                    lvl36_r2Urb
                                    (let {
                                       n_s2NOK [Dmd=<S,U>] :: Int#
                                       [LclId]
                                       n_s2NOK = negateInt# x_at1e } in
                                     case <# 0# n_s2NOK of {
                                       __DEFAULT -> map @ Int @ Char intToDigit ww_s2RDE;
                                       1# ->
                                         let {
                                           n1_i2KC1 :: [Char]
                                           [LclId]
                                           n1_i2KC1 = map @ Int @ Char intToDigit ww_s2RDE } in
                                         let {
                                           lvl38_s2SQJ :: [Char]
                                           [LclId, Unf=OtherCon []]
                                           lvl38_s2SQJ
                                             = GHC.Types.: @ Char lvl20_r2UqT n1_i2KC1 } in
                                         letrec {
                                           $wxs4_s2RDt [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                                             :: Int# -> [Char]
                                           [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                           $wxs4_s2RDt
                                             = \ (ww2_s2RDr :: Int#) ->
                                                 case ww2_s2RDr of ds1_i2KC9 {
                                                   __DEFAULT ->
                                                     GHC.Types.:
                                                       @ Char
                                                       lvl20_r2UqT
                                                       ($wxs4_s2RDt (-# ds1_i2KC9 1#));
                                                   1# -> lvl38_s2SQJ
                                                 }; } in
                                         $wxs4_s2RDt n_s2NOK
                                     })
                              }
                              };
                            Just dec_a2I1F ->
                              case ww1_s2RDF of wild4_alMW { I# x_alMY ->
                              case >=# x_alMY 0# of {
                                __DEFAULT ->
                                  let {
                                    ds_s2LLC [Dmd=<L,U(1*U,1*U)>] :: (Char, [Char])
                                    [LclId]
                                    ds_s2LLC
                                      = let {
                                          n_s2NOT [Dmd=<S,U>] :: Int#
                                          [LclId]
                                          n_s2NOT = negateInt# x_alMY } in
                                        case <# 0# n_s2NOT of {
                                          __DEFAULT ->
                                            case GHC.Float.$wroundTo
                                                   base_r2UqK
                                                   (case dec_a2I1F of wild5_at54 { I# x1_at56 ->
                                                    case <=# x1_at56 0# of {
                                                      __DEFAULT -> wild5_at54;
                                                      1# -> minExpt
                                                    }
                                                    })
                                                   ww_s2RDE
                                            of
                                            { (# ww3_s2RE3, ww4_s2RE4 #) ->
                                            $j_r2Urc ww3_s2RE3 ww4_s2RE4
                                            };
                                          1# ->
                                            let {
                                              lvl38_s2SQM :: [Int]
                                              [LclId, Unf=OtherCon []]
                                              lvl38_s2SQM = GHC.Types.: @ Int minExpt ww_s2RDE } in
                                            letrec {
                                              $wxs4_s2RDz [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                                                :: Int# -> [Int]
                                              [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                              $wxs4_s2RDz
                                                = \ (ww2_s2RDx :: Int#) ->
                                                    case ww2_s2RDx of ds1_i2KC9 {
                                                      __DEFAULT ->
                                                        GHC.Types.:
                                                          @ Int
                                                          minExpt
                                                          ($wxs4_s2RDz (-# ds1_i2KC9 1#));
                                                      1# -> lvl38_s2SQM
                                                    }; } in
                                            case GHC.Float.$wroundTo
                                                   base_r2UqK
                                                   (case dec_a2I1F of wild5_at54 { I# x1_at56 ->
                                                    case <=# x1_at56 0# of {
                                                      __DEFAULT -> wild5_at54;
                                                      1# -> minExpt
                                                    }
                                                    })
                                                   ($wxs4_s2RDz n_s2NOT)
                                            of
                                            { (# ww3_s2RE3, ww4_s2RE4 #) ->
                                            $j_r2Urc ww3_s2RE3 ww4_s2RE4
                                            }
                                        } } in
                                  GHC.Types.:
                                    @ Char
                                    (case ds_s2LLC of { (d_a2IUk, ds'_a2IUm) -> d_a2IUk })
                                    (case ds_s2LLC of { (d_a2IUk, ds'_a2IUm) ->
                                     case ds'_a2IUm of wild5_i2KaD {
                                       [] ->
                                         case eta2_B2 of {
                                           False -> GHC.Types.[] @ Char;
                                           True -> lvl37_r2Urd
                                         };
                                       : ds2_i2Mqv ds3_i2Mqw ->
                                         GHC.Types.: @ Char lvl14_r2UqN wild5_i2KaD
                                     }
                                     });
                                1# ->
                                  case GHC.Float.$wroundTo
                                         base_r2UqK
                                         (case dec_a2I1F of { I# x1_at56 ->
                                          case <=# x1_at56 0# of {
                                            __DEFAULT -> GHC.Types.I# (+# x1_at56 x_alMY);
                                            1# -> wild4_alMW
                                          }
                                          })
                                         ww_s2RDE
                                  of
                                  { (# ww3_s2RE3, ww4_s2RE4 #) ->
                                  case ww3_s2RE3 of { I# y_i1AMm ->
                                  let {
                                    x1_i2KaL [Dmd=<S,U>] :: Int#
                                    [LclId]
                                    x1_i2KaL = +# x_alMY y_i1AMm } in
                                  case <=# x1_i2KaL 0# of {
                                    __DEFAULT ->
                                      case GHC.List.$wsplitAt'
                                             @ Char
                                             (GHC.Types.I# x1_i2KaL)
                                             (map @ Int @ Char intToDigit ww4_s2RE4)
                                      of
                                      { (# ww6_i2KYm, ww7_i2KYn #) ->
                                      case ww6_i2KYm of wild6_Xh6 {
                                        [] ->
                                          ++
                                            @ Char
                                            lvl23_r2UqW
                                            (case ww7_i2KYn of wild7_i2KaD {
                                               [] ->
                                                 case eta2_B2 of {
                                                   False -> GHC.Types.[] @ Char;
                                                   True -> lvl37_r2Urd
                                                 };
                                               : ds1_i2Mqv ds2_i2Mqw ->
                                                 GHC.Types.: @ Char lvl14_r2UqN wild7_i2KaD
                                             });
                                        : ipv_s2KXk ipv1_s2KXl ->
                                          ++
                                            @ Char
                                            wild6_Xh6
                                            (case ww7_i2KYn of wild7_i2KaD {
                                               [] ->
                                                 case eta2_B2 of {
                                                   False -> GHC.Types.[] @ Char;
                                                   True -> lvl37_r2Urd
                                                 };
                                               : ds1_i2Mqv ds2_i2Mqw ->
                                                 GHC.Types.: @ Char lvl14_r2UqN wild7_i2KaD
                                             })
                                      }
                                      };
                                    1# ->
                                      ++
                                        @ Char
                                        lvl23_r2UqW
                                        (case map @ Int @ Char intToDigit ww4_s2RE4 of wild6_i2KaD {
                                           [] ->
                                             case eta2_B2 of {
                                               False -> GHC.Types.[] @ Char;
                                               True -> lvl37_r2Urd
                                             };
                                           : ds1_i2Mqv ds2_i2Mqw ->
                                             GHC.Types.: @ Char lvl14_r2UqN wild6_i2KaD
                                         })
                                  }
                                  }
                                  }
                              }
                              }
                          };
                        FFGeneric ->
                          case ww1_s2RDF of wild3_alN7 { I# x_alN9 ->
                          case <# x_alN9 0# of {
                            __DEFAULT ->
                              case ># x_alN9 7# of {
                                __DEFAULT -> $wdoFmt_s2RDH GHC.Float.FFFixed ww_s2RDE wild3_alN7;
                                1# -> $wdoFmt_s2RDH GHC.Float.FFExponent ww_s2RDE wild3_alN7
                              };
                            1# -> $wdoFmt_s2RDH GHC.Float.FFExponent ww_s2RDE wild3_alN7
                          }
                          }
                      }; } in
              join {
                $j1_s2MtI [Dmd=<L,1*U>] :: [Char]
                [LclId[JoinId(0)], Unf=OtherCon []]
                $j1_s2MtI
                  = GHC.Types.:
                      @ Char
                      GHC.Float.$fShowDouble3
                      (case GHC.Float.$wfloatToDigits
                              @ a_a2IOQ
                              $dRealFloat_a2IOS
                              GHC.Float.expts4
                              (negate @ a_a2IOQ $dNum_s2LLb eta3_B1)
                       of
                       { (# ww1_s2REc, ww2_s2REd #) ->
                       $wdoFmt_s2RDH eta_B4 ww1_s2REc ww2_s2REd
                       }) } in
              case < @ a_a2IOQ
                     (GHC.Real.$p2Real @ a_a2IOQ $dReal_s2LLc)
                     eta3_B1
                     (fromInteger @ a_a2IOQ $dNum_s2LLb GHC.Float.rationalToDouble5)
              of {
                False ->
                  case isNegativeZero @ a_a2IOQ $dRealFloat_a2IOS eta3_B1 of {
                    False ->
                      case GHC.Float.$wfloatToDigits
                             @ a_a2IOQ $dRealFloat_a2IOS GHC.Float.expts4 eta3_B1
                      of
                      { (# ww1_s2REc, ww2_s2REd #) ->
                      $wdoFmt_s2RDH eta_B4 ww1_s2REc ww2_s2REd
                      };
                    True -> jump $j1_s2MtI
                  };
                True -> jump $j1_s2MtI
              };
            True ->
              case < @ a_a2IOQ
                     (GHC.Real.$p2Real @ a_a2IOQ $dReal_s2LLc)
                     eta3_B1
                     (fromInteger @ a_a2IOQ $dNum_s2LLb GHC.Float.rationalToDouble5)
              of {
                False -> lvl27_r2Ur1;
                True -> lvl29_r2Ur3
              }
          };
        True -> lvl31_r2Ur5
      }

-- RHS size: {terms: 11, types: 9, coercions: 0, joins: 0/0}
formatRealFloat
  :: forall a. RealFloat a => FFFormat -> Maybe Int -> a -> String
[GblId,
 Arity=4,
 Str=<S(LLLLLLLLLLC(S)LLLLL),U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,1*U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2IV8)
                 ($dRealFloat_a2IVa [Occ=Once] :: RealFloat a_a2IV8)
                 (fmt_a2I17 [Occ=Once] :: FFFormat)
                 (decs_a2I18 [Occ=Once] :: Maybe Int)
                 (x_a2I19 [Occ=Once] :: a_a2IV8) ->
                 formatRealFloatAlt
                   @ a_a2IV8
                   $dRealFloat_a2IVa
                   fmt_a2I17
                   decs_a2I18
                   GHC.Types.False
                   x_a2I19}]
formatRealFloat
  = \ (@ a_a2IV8)
      ($dRealFloat_a2IVa :: RealFloat a_a2IV8)
      (fmt_a2I17 :: FFFormat)
      (decs_a2I18 :: Maybe Int)
      (x_a2I19 :: a_a2IV8) ->
      formatRealFloatAlt
        @ a_a2IV8
        $dRealFloat_a2IVa
        fmt_a2I17
        decs_a2I18
        GHC.Types.False
        x_a2I19

-- RHS size: {terms: 10, types: 8, coercions: 0, joins: 0/0}
showFloat :: forall a. RealFloat a => a -> ShowS
[GblId,
 Arity=2,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a2IVe)
                 ($dRealFloat_a2IVg [Occ=Once] :: RealFloat a_a2IVe)
                 (x_a2I16 [Occ=Once] :: a_a2IVe) ->
                 ++
                   @ Char
                   (formatRealFloatAlt
                      @ a_a2IVe
                      $dRealFloat_a2IVg
                      GHC.Float.FFGeneric
                      (GHC.Base.Nothing @ Int)
                      GHC.Types.False
                      x_a2I16)}]
showFloat
  = \ (@ a_a2IVe)
      ($dRealFloat_a2IVg :: RealFloat a_a2IVe)
      (x_a2I16 :: a_a2IVe) ->
      ++
        @ Char
        (formatRealFloatAlt
           @ a_a2IVe
           $dRealFloat_a2IVg
           GHC.Float.FFGeneric
           (GHC.Base.Nothing @ Int)
           GHC.Types.False
           x_a2I16)

-- RHS size: {terms: 10, types: 5, coercions: 0, joins: 0/0}
GHC.Float.$fShowDouble2 :: Double -> [Char] -> [Char]
[GblId,
 Arity=1,
 Str=<L,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2I16 [Occ=Once] :: Double) ->
                 ++
                   @ Char
                   (GHC.Float.$fShowDouble_$sformatRealFloatAlt
                      GHC.Float.FFGeneric
                      (GHC.Base.Nothing @ Int)
                      GHC.Types.False
                      x_a2I16)}]
GHC.Float.$fShowDouble2
  = \ (x_a2I16 :: Double) ->
      ++
        @ Char
        (case x_a2I16 of { D# ww1_s2RD5 ->
         GHC.Float.$w$sformatRealFloatAlt
           GHC.Float.FFGeneric
           (GHC.Base.Nothing @ Int)
           GHC.Types.False
           ww1_s2RD5
         })

-- RHS size: {terms: 9, types: 4, coercions: 0, joins: 0/0}
GHC.Float.$fShowDouble_$cshowsPrec :: Int -> Double -> ShowS
[GblId,
 Arity=2,
 Str=<L,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HYa [Occ=Once] :: Int)
                 (eta_B1 [Occ=Once] :: Double) ->
                 GHC.Float.$fShowDouble_$sshowSignedFloat
                   GHC.Float.$fShowDouble2 x_a2HYa eta_B1}]
GHC.Float.$fShowDouble_$cshowsPrec
  = \ (x_a2HYa :: Int) (eta_B1 :: Double) ->
      case eta_B1 of { D# ww1_s2RyZ ->
      GHC.Float.$w$sshowSignedFloat
        GHC.Float.$fShowDouble2 x_a2HYa ww1_s2RyZ
      }

-- RHS size: {terms: 9, types: 4, coercions: 0, joins: 0/0}
GHC.Float.$fShowDouble_$cshow :: Double -> String
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i1Jj2 [Occ=Once] :: Double) ->
                 GHC.Float.$fShowDouble_$sshowSignedFloat
                   GHC.Float.$fShowDouble2 minExpt x_i1Jj2 (GHC.Types.[] @ Char)}]
GHC.Float.$fShowDouble_$cshow
  = \ (x_i1Jj2 :: Double) ->
      case x_i1Jj2 of { D# ww1_s2RyZ ->
      GHC.Float.$w$sshowSignedFloat
        GHC.Float.$fShowDouble2 minExpt ww1_s2RyZ (GHC.Types.[] @ Char)
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Float.$fShowDouble1 :: Double -> ShowS
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (eta_B1 [Occ=Once] :: Double) ->
                 GHC.Float.$fShowDouble_$sshowSignedFloat
                   GHC.Float.$fShowDouble2 minExpt eta_B1}]
GHC.Float.$fShowDouble1
  = \ (eta_B1 :: Double) ->
      case eta_B1 of { D# ww1_s2RyZ ->
      GHC.Float.$w$sshowSignedFloat
        GHC.Float.$fShowDouble2 minExpt ww1_s2RyZ
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fShowDouble_$cshowList :: [Double] -> ShowS
[GblId,
 Arity=2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
GHC.Float.$fShowDouble_$cshowList
  = showList__ @ Double GHC.Float.$fShowDouble1

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fShowDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Show Double
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Double
                       GHC.Float.$fShowDouble_$cshowsPrec
                       GHC.Float.$fShowDouble_$cshow
                       GHC.Float.$fShowDouble_$cshowList]
GHC.Float.$fShowDouble
  = GHC.Show.C:Show
      @ Double
      GHC.Float.$fShowDouble_$cshowsPrec
      GHC.Float.$fShowDouble_$cshow
      GHC.Float.$fShowDouble_$cshowList

-- RHS size: {terms: 10, types: 5, coercions: 0, joins: 0/0}
GHC.Float.$fShowFloat2 :: Float -> [Char] -> [Char]
[GblId,
 Arity=1,
 Str=<L,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2I16 [Occ=Once] :: Float) ->
                 ++
                   @ Char
                   (GHC.Float.$fShowFloat_$sformatRealFloatAlt
                      GHC.Float.FFGeneric
                      (GHC.Base.Nothing @ Int)
                      GHC.Types.False
                      x_a2I16)}]
GHC.Float.$fShowFloat2
  = \ (x_a2I16 :: Float) ->
      ++
        @ Char
        (case x_a2I16 of { F# ww1_s2RCm ->
         GHC.Float.$w$sformatRealFloatAlt1
           GHC.Float.FFGeneric
           (GHC.Base.Nothing @ Int)
           GHC.Types.False
           ww1_s2RCm
         })

-- RHS size: {terms: 9, types: 4, coercions: 0, joins: 0/0}
GHC.Float.$fShowFloat_$cshowsPrec :: Int -> Float -> ShowS
[GblId,
 Arity=2,
 Str=<L,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2HZt [Occ=Once] :: Int) (eta_B1 [Occ=Once] :: Float) ->
                 GHC.Float.$fShowFloat_$sshowSignedFloat
                   GHC.Float.$fShowFloat2 x_a2HZt eta_B1}]
GHC.Float.$fShowFloat_$cshowsPrec
  = \ (x_a2HZt :: Int) (eta_B1 :: Float) ->
      case eta_B1 of { F# ww1_s2RyR ->
      GHC.Float.$w$sshowSignedFloat1
        GHC.Float.$fShowFloat2 x_a2HZt ww1_s2RyR
      }

-- RHS size: {terms: 9, types: 4, coercions: 0, joins: 0/0}
GHC.Float.$fShowFloat_$cshow :: Float -> String
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i1Jj2 [Occ=Once] :: Float) ->
                 GHC.Float.$fShowFloat_$sshowSignedFloat
                   GHC.Float.$fShowFloat2 minExpt x_i1Jj2 (GHC.Types.[] @ Char)}]
GHC.Float.$fShowFloat_$cshow
  = \ (x_i1Jj2 :: Float) ->
      case x_i1Jj2 of { F# ww1_s2RyR ->
      GHC.Float.$w$sshowSignedFloat1
        GHC.Float.$fShowFloat2 minExpt ww1_s2RyR (GHC.Types.[] @ Char)
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Float.$fShowFloat1 :: Float -> ShowS
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (eta_B1 [Occ=Once] :: Float) ->
                 GHC.Float.$fShowFloat_$sshowSignedFloat
                   GHC.Float.$fShowFloat2 minExpt eta_B1}]
GHC.Float.$fShowFloat1
  = \ (eta_B1 :: Float) ->
      case eta_B1 of { F# ww1_s2RyR ->
      GHC.Float.$w$sshowSignedFloat1
        GHC.Float.$fShowFloat2 minExpt ww1_s2RyR
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fShowFloat_$cshowList :: [Float] -> ShowS
[GblId,
 Arity=2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
GHC.Float.$fShowFloat_$cshowList
  = showList__ @ Float GHC.Float.$fShowFloat1

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Float.$fShowFloat [InlPrag=NOUSERINLINE CONLIKE] :: Show Float
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Float
                       GHC.Float.$fShowFloat_$cshowsPrec
                       GHC.Float.$fShowFloat_$cshow
                       GHC.Float.$fShowFloat_$cshowList]
GHC.Float.$fShowFloat
  = GHC.Show.C:Show
      @ Float
      GHC.Float.$fShowFloat_$cshowsPrec
      GHC.Float.$fShowFloat_$cshow
      GHC.Float.$fShowFloat_$cshowList


------ Local rules for imported ids --------
"SPEC showSignedFloat @ Float"
    forall ($dRealFloat_s2LSV :: RealFloat Float).
      showSignedFloat @ Float $dRealFloat_s2LSV
      = GHC.Float.$fShowFloat_$sshowSignedFloat
"SPEC showSignedFloat @ Double"
    forall ($dRealFloat_s2LSJ :: RealFloat Double).
      showSignedFloat @ Double $dRealFloat_s2LSJ
      = GHC.Float.$fShowDouble_$sshowSignedFloat
"SPEC fromRat''"
    forall ($dRealFloat_X2IFw :: RealFloat Double).
      fromRat'' @ Double $dRealFloat_X2IFw
      = GHC.Float.fromRat''_$sfromRat''1
"SPEC fromRat''"
    forall ($dRealFloat_X2IFL :: RealFloat Float).
      fromRat'' @ Float $dRealFloat_X2IFL
      = GHC.Float.fromRat''_$sfromRat''
"fromRat/Double"
    forall ($dRealFloat_a2JrF :: RealFloat Double).
      fromRat @ Double $dRealFloat_a2JrF
      = GHC.Float.$fFractionalDouble_$cfromRational
"fromRat/Float"
    forall ($dRealFloat_a2Jrn :: RealFloat Float).
      fromRat @ Float $dRealFloat_a2Jrn
      = GHC.Float.$fFractionalFloat_$cfromRational
"SPEC formatRealFloatAlt @ Float"
    forall ($dRealFloat_s2LMA :: RealFloat Float).
      formatRealFloatAlt @ Float $dRealFloat_s2LMA
      = GHC.Float.$fShowFloat_$sformatRealFloatAlt
"SPEC formatRealFloatAlt @ Double"
    forall ($dRealFloat_s2LLO :: RealFloat Double).
      formatRealFloatAlt @ Double $dRealFloat_s2LLO
      = GHC.Float.$fShowDouble_$sformatRealFloatAlt
"SPEC/GHC.Float numericEnumFromThen @ Double" [0]
    forall (w_s2LUE :: Fractional Double).
      numericEnumFromThen @ Double w_s2LUE
      = GHC.Float.$fEnumDouble_$snumericEnumFromThen
"SPEC/GHC.Float numericEnumFromThen @ Float" [0]
    forall (w_s2LUC :: Fractional Float).
      numericEnumFromThen @ Float w_s2LUC
      = GHC.Float.$fEnumFloat_$snumericEnumFromThen
"SPEC/GHC.Float numericEnumFrom @ Double" [0]
    forall (w_s2LUI :: Fractional Double).
      numericEnumFrom @ Double w_s2LUI
      = GHC.Float.$fEnumDouble_$snumericEnumFrom
"SPEC/GHC.Float numericEnumFrom @ Float" [0]
    forall (w_s2LUG :: Fractional Float).
      numericEnumFrom @ Float w_s2LUG
      = GHC.Float.$fEnumFloat_$snumericEnumFrom
"SPEC/GHC.Float even @ Int"
    forall ($dIntegral_s2LUK :: Integral Int).
      even @ Int $dIntegral_s2LUK
      = GHC.Float.$seven
"fromIntegral/Int->Float"
    forall ($dIntegral_a2Jpj :: Integral Int)
           ($dNum_a2Jpk :: Num Float).
      fromIntegral @ Int @ Float $dIntegral_a2Jpj $dNum_a2Jpk
      = int2Float
"fromIntegral/Int->Double"
    forall ($dIntegral_a2Jpu :: Integral Int)
           ($dNum_a2Jpv :: Num Double).
      fromIntegral @ Int @ Double $dIntegral_a2Jpu $dNum_a2Jpv
      = int2Double
"fromIntegral/Word->Float"
    forall ($dIntegral_a2JpF :: Integral Word)
           ($dNum_a2JpG :: Num Float).
      fromIntegral @ Word @ Float $dIntegral_a2JpF $dNum_a2JpG
      = word2Float
"fromIntegral/Word->Double"
    forall ($dIntegral_a2JpQ :: Integral Word)
           ($dNum_a2JpR :: Num Double).
      fromIntegral @ Word @ Double $dIntegral_a2JpQ $dNum_a2JpR
      = word2Double
"realToFrac/Float->Float"
    forall ($dReal_a2Jq4 :: Real Float)
           ($dFractional_a2Jq5 :: Fractional Float).
      realToFrac @ Float @ Float $dReal_a2Jq4 $dFractional_a2Jq5
      = id @ Float
"realToFrac/Float->Double"
    forall ($dReal_a2Jqn :: Real Float)
           ($dFractional_a2Jqo :: Fractional Double).
      realToFrac @ Float @ Double $dReal_a2Jqn $dFractional_a2Jqo
      = float2Double
"realToFrac/Double->Float"
    forall ($dReal_a2Jqy :: Real Double)
           ($dFractional_a2Jqz :: Fractional Float).
      realToFrac @ Double @ Float $dReal_a2Jqy $dFractional_a2Jqz
      = double2Float
"realToFrac/Double->Double"
    forall ($dReal_a2JqJ :: Real Double)
           ($dFractional_a2JqK :: Fractional Double).
      realToFrac @ Double @ Double $dReal_a2JqJ $dFractional_a2JqK
      = id @ Double
"realToFrac/Int->Double"
    forall ($dReal_a2Jr2 :: Real Int)
           ($dFractional_a2Jr3 :: Fractional Double).
      realToFrac @ Int @ Double $dReal_a2Jr2 $dFractional_a2Jr3
      = int2Double
"realToFrac/Int->Float"
    forall ($dReal_a2Jrd :: Real Int)
           ($dFractional_a2Jre :: Fractional Float).
      realToFrac @ Int @ Float $dReal_a2Jrd $dFractional_a2Jre
      = int2Float
"properFraction/Double->Integer"
    forall ($dRealFrac_a2JrX :: RealFrac Double)
           ($dIntegral_a2JrZ :: Integral Integer).
      properFraction @ Double $dRealFrac_a2JrX @ Integer $dIntegral_a2JrZ
      = properFractionDoubleInteger
"truncate/Double->Integer"
    forall ($dRealFrac_a2Js9 :: RealFrac Double)
           ($dIntegral_a2Jsb :: Integral Integer).
      truncate @ Double $dRealFrac_a2Js9 @ Integer $dIntegral_a2Jsb
      = truncateDoubleInteger
"floor/Double->Integer"
    forall ($dRealFrac_a2Jsl :: RealFrac Double)
           ($dIntegral_a2Jsn :: Integral Integer).
      floor @ Double $dRealFrac_a2Jsl @ Integer $dIntegral_a2Jsn
      = floorDoubleInteger
"ceiling/Double->Integer"
    forall ($dRealFrac_a2Jsx :: RealFrac Double)
           ($dIntegral_a2Jsz :: Integral Integer).
      ceiling @ Double $dRealFrac_a2Jsx @ Integer $dIntegral_a2Jsz
      = ceilingDoubleInteger
"round/Double->Integer"
    forall ($dRealFrac_a2JsJ :: RealFrac Double)
           ($dIntegral_a2JsL :: Integral Integer).
      round @ Double $dRealFrac_a2JsJ @ Integer $dIntegral_a2JsL
      = roundDoubleInteger
"properFraction/Double->Int"
    forall ($dRealFrac_a2JsV :: RealFrac Double)
           ($dIntegral_a2JsX :: Integral Int).
      properFraction @ Double $dRealFrac_a2JsV @ Int $dIntegral_a2JsX
      = properFractionDoubleInt
"truncate/Double->Int"
    forall ($dRealFrac_a2Jt7 :: RealFrac Double)
           ($dIntegral_a2Jt9 :: Integral Int).
      truncate @ Double $dRealFrac_a2Jt7 @ Int $dIntegral_a2Jt9
      = double2Int
"floor/Double->Int"
    forall ($dRealFrac_a2Jtj :: RealFrac Double)
           ($dIntegral_a2Jtl :: Integral Int).
      floor @ Double $dRealFrac_a2Jtj @ Int $dIntegral_a2Jtl
      = floorDoubleInt
"ceiling/Double->Int"
    forall ($dRealFrac_a2Jtv :: RealFrac Double)
           ($dIntegral_a2Jtx :: Integral Int).
      ceiling @ Double $dRealFrac_a2Jtv @ Int $dIntegral_a2Jtx
      = ceilingDoubleInt
"round/Double->Int"
    forall ($dRealFrac_a2JtH :: RealFrac Double)
           ($dIntegral_a2JtJ :: Integral Int).
      round @ Double $dRealFrac_a2JtH @ Int $dIntegral_a2JtJ
      = roundDoubleInt
"properFraction/Float->Integer"
    forall ($dRealFrac_a2JtT :: RealFrac Float)
           ($dIntegral_a2JtV :: Integral Integer).
      properFraction @ Float $dRealFrac_a2JtT @ Integer $dIntegral_a2JtV
      = properFractionFloatInteger
"truncate/Float->Integer"
    forall ($dRealFrac_a2Ju5 :: RealFrac Float)
           ($dIntegral_a2Ju7 :: Integral Integer).
      truncate @ Float $dRealFrac_a2Ju5 @ Integer $dIntegral_a2Ju7
      = truncateFloatInteger
"floor/Float->Integer"
    forall ($dRealFrac_a2Juh :: RealFrac Float)
           ($dIntegral_a2Juj :: Integral Integer).
      floor @ Float $dRealFrac_a2Juh @ Integer $dIntegral_a2Juj
      = floorFloatInteger
"ceiling/Float->Integer"
    forall ($dRealFrac_a2Jut :: RealFrac Float)
           ($dIntegral_a2Juv :: Integral Integer).
      ceiling @ Float $dRealFrac_a2Jut @ Integer $dIntegral_a2Juv
      = ceilingFloatInteger
"round/Float->Integer"
    forall ($dRealFrac_a2JuF :: RealFrac Float)
           ($dIntegral_a2JuH :: Integral Integer).
      round @ Float $dRealFrac_a2JuF @ Integer $dIntegral_a2JuH
      = roundFloatInteger
"properFraction/Float->Int"
    forall ($dRealFrac_a2JuR :: RealFrac Float)
           ($dIntegral_a2JuT :: Integral Int).
      properFraction @ Float $dRealFrac_a2JuR @ Int $dIntegral_a2JuT
      = properFractionFloatInt
"truncate/Float->Int"
    forall ($dRealFrac_a2Jv3 :: RealFrac Float)
           ($dIntegral_a2Jv5 :: Integral Int).
      truncate @ Float $dRealFrac_a2Jv3 @ Int $dIntegral_a2Jv5
      = float2Int
"floor/Float->Int"
    forall ($dRealFrac_a2Jvf :: RealFrac Float)
           ($dIntegral_a2Jvh :: Integral Int).
      floor @ Float $dRealFrac_a2Jvf @ Int $dIntegral_a2Jvh
      = floorFloatInt
"ceiling/Float->Int"
    forall ($dRealFrac_a2Jvr :: RealFrac Float)
           ($dIntegral_a2Jvt :: Integral Int).
      ceiling @ Float $dRealFrac_a2Jvr @ Int $dIntegral_a2Jvt
      = ceilingFloatInt
"round/Float->Int"
    forall ($dRealFrac_a2JvD :: RealFrac Float)
           ($dIntegral_a2JvF :: Integral Int).
      round @ Float $dRealFrac_a2JvD @ Int $dIntegral_a2JvF
      = roundFloatInt

