
==================== Output Cmm ====================
2018-03-16 15:55:00.686123812 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:00.68719937 UTC

[section ""data" . GHC.MVar.$fEqMVar_$c==_closure" {
     GHC.MVar.$fEqMVar_$c==_closure:
         const GHC.MVar.$fEqMVar_$c==_info;
 },
 GHC.MVar.$fEqMVar_$c==_entry() //  [R2, R3]
         { info_tbl: [(cmWz,
                       label: GHC.MVar.$fEqMVar_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmWz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmWD; else goto cmWE;
       cmWD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.$fEqMVar_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmWE: // global
           I64[Sp - 16] = block_cmWw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umWN; else goto cmWx;
       umWN: // global
           call _cmWw(R1) args: 0, res: 0, upd: 0;
       cmWx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmWw() //  [R1]
         { info_tbl: [(cmWw,
                       label: block_cmWw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmWw: // global
           I64[Sp] = block_cmWC_info;
           _smV7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _smV7::P64;
           if (R1 & 7 != 0) goto umWM; else goto cmWG;
       umWM: // global
           call _cmWC(R1) args: 0, res: 0, upd: 0;
       cmWG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmWC() //  [R1]
         { info_tbl: [(cmWC,
                       label: block_cmWC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmWC: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.688834866 UTC

[section ""data" . GHC.MVar.$fEqMVar_$c/=_closure" {
     GHC.MVar.$fEqMVar_$c/=_closure:
         const GHC.MVar.$fEqMVar_$c/=_info;
 },
 GHC.MVar.$fEqMVar_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cmWV,
                       label: GHC.MVar.$fEqMVar_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmWV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmWZ; else goto cmX0;
       cmWZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.$fEqMVar_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmX0: // global
           I64[Sp - 16] = block_cmWS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umXn; else goto cmWT;
       umXn: // global
           call _cmWS(R1) args: 0, res: 0, upd: 0;
       cmWT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmWS() //  [R1]
         { info_tbl: [(cmWS,
                       label: block_cmWS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmWS: // global
           I64[Sp] = block_cmWY_info;
           _smVe::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _smVe::P64;
           if (R1 & 7 != 0) goto umXm; else goto cmX2;
       umXm: // global
           call _cmWY(R1) args: 0, res: 0, upd: 0;
       cmX2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmWY() //  [R1]
         { info_tbl: [(cmWY,
                       label: block_cmWY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmWY: // global
           if (P64[Sp + 8] == P64[R1 + 7]) goto cmXi; else goto cmXc;
       cmXi: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cmXc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.690106063 UTC

[section ""data" . GHC.MVar.$fEqMVar_closure" {
     GHC.MVar.$fEqMVar_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.MVar.$fEqMVar_$c==_closure+2;
         const GHC.MVar.$fEqMVar_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.690971256 UTC

[section ""data" . GHC.MVar.newEmptyMVar1_closure" {
     GHC.MVar.newEmptyMVar1_closure:
         const GHC.MVar.newEmptyMVar1_info;
 },
 GHC.MVar.newEmptyMVar1_entry() //  []
         { info_tbl: [(cmXv,
                       label: GHC.MVar.newEmptyMVar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmXv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmXw; else goto cmXx;
       cmXw: // global
           R1 = GHC.MVar.newEmptyMVar1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cmXx: // global
           I64[Sp - 8] = block_cmXs_info;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cmXs() //  [R1]
         { info_tbl: [(cmXs,
                       label: block_cmXs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmXs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmXA; else goto cmXz;
       cmXA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmXz: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.691973637 UTC

[section ""data" . GHC.MVar.newEmptyMVar_closure" {
     GHC.MVar.newEmptyMVar_closure:
         const GHC.MVar.newEmptyMVar_info;
 },
 GHC.MVar.newEmptyMVar_entry() //  []
         { info_tbl: [(cmXF,
                       label: GHC.MVar.newEmptyMVar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmXF: // global
           call GHC.MVar.newEmptyMVar1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.692867601 UTC

[section ""data" . GHC.MVar.takeMVar1_closure" {
     GHC.MVar.takeMVar1_closure:
         const GHC.MVar.takeMVar1_info;
 },
 GHC.MVar.takeMVar1_entry() //  [R2]
         { info_tbl: [(cmXP,
                       label: GHC.MVar.takeMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmXP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmXQ; else goto cmXR;
       cmXQ: // global
           R2 = R2;
           R1 = GHC.MVar.takeMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmXR: // global
           I64[Sp - 8] = block_cmXM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umXV; else goto cmXN;
       umXV: // global
           call _cmXM(R1) args: 0, res: 0, upd: 0;
       cmXN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmXM() //  [R1]
         { info_tbl: [(cmXM,
                       label: block_cmXM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmXM: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.693953221 UTC

[section ""data" . GHC.MVar.takeMVar_closure" {
     GHC.MVar.takeMVar_closure:
         const GHC.MVar.takeMVar_info;
 },
 GHC.MVar.takeMVar_entry() //  [R2]
         { info_tbl: [(cmY0,
                       label: GHC.MVar.takeMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmY0: // global
           R2 = R2;
           call GHC.MVar.takeMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.694814105 UTC

[section ""data" . GHC.MVar.readMVar1_closure" {
     GHC.MVar.readMVar1_closure:
         const GHC.MVar.readMVar1_info;
 },
 GHC.MVar.readMVar1_entry() //  [R2]
         { info_tbl: [(cmYa,
                       label: GHC.MVar.readMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmYa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmYb; else goto cmYc;
       cmYb: // global
           R2 = R2;
           R1 = GHC.MVar.readMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmYc: // global
           I64[Sp - 8] = block_cmY7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umYg; else goto cmY8;
       umYg: // global
           call _cmY7(R1) args: 0, res: 0, upd: 0;
       cmY8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmY7() //  [R1]
         { info_tbl: [(cmY7,
                       label: block_cmY7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmY7: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readMVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.695862135 UTC

[section ""data" . GHC.MVar.readMVar_closure" {
     GHC.MVar.readMVar_closure:
         const GHC.MVar.readMVar_info;
 },
 GHC.MVar.readMVar_entry() //  [R2]
         { info_tbl: [(cmYl,
                       label: GHC.MVar.readMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmYl: // global
           R2 = R2;
           call GHC.MVar.readMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.696796804 UTC

[section ""data" . GHC.MVar.putMVar1_closure" {
     GHC.MVar.putMVar1_closure:
         const GHC.MVar.putMVar1_info;
 },
 GHC.MVar.putMVar1_entry() //  [R2, R3]
         { info_tbl: [(cmYv,
                       label: GHC.MVar.putMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmYv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmYz; else goto cmYA;
       cmYz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.putMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmYA: // global
           I64[Sp - 16] = block_cmYs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umYE; else goto cmYt;
       umYE: // global
           call _cmYs(R1) args: 0, res: 0, upd: 0;
       cmYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmYs() //  [R1]
         { info_tbl: [(cmYs,
                       label: block_cmYs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmYs: // global
           _smVw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cmYy_info;
           R2 = _smVw::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmYy() //  []
         { info_tbl: [(cmYy,
                       label: block_cmYy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmYy: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.698084642 UTC

[section ""data" . GHC.MVar.putMVar_closure" {
     GHC.MVar.putMVar_closure:
         const GHC.MVar.putMVar_info;
 },
 GHC.MVar.putMVar_entry() //  [R2, R3]
         { info_tbl: [(cmYJ,
                       label: GHC.MVar.putMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmYJ: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.putMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.699076805 UTC

[section ""data" . GHC.MVar.newMVar1_closure" {
     GHC.MVar.newMVar1_closure:
         const GHC.MVar.newMVar1_info;
 },
 GHC.MVar.newMVar1_entry() //  [R2]
         { info_tbl: [(cmYV,
                       label: GHC.MVar.newMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmYV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmYW; else goto cmYX;
       cmYW: // global
           R2 = R2;
           R1 = GHC.MVar.newMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmYX: // global
           I64[Sp - 16] = block_cmYQ_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cmYQ() //  [R1]
         { info_tbl: [(cmYQ,
                       label: block_cmYQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmYQ: // global
           I64[Sp] = block_cmYS_info;
           R2 = P64[Sp + 8];
           _smVF::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _smVF::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmYS() //  []
         { info_tbl: [(cmYS,
                       label: block_cmYS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmYS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmZ1; else goto cmZ0;
       cmZ1: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cmZ0: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.700293167 UTC

[section ""data" . GHC.MVar.newMVar_closure" {
     GHC.MVar.newMVar_closure:
         const GHC.MVar.newMVar_info;
 },
 GHC.MVar.newMVar_entry() //  [R2]
         { info_tbl: [(cmZ6,
                       label: GHC.MVar.newMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmZ6: // global
           R2 = R2;
           call GHC.MVar.newMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.701454041 UTC

[section ""data" . GHC.MVar.tryTakeMVar1_closure" {
     GHC.MVar.tryTakeMVar1_closure:
         const GHC.MVar.tryTakeMVar1_info;
 },
 GHC.MVar.tryTakeMVar1_entry() //  [R2]
         { info_tbl: [(cmZg,
                       label: GHC.MVar.tryTakeMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmZg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cmZh; else goto cmZi;
       cmZh: // global
           R2 = R2;
           R1 = GHC.MVar.tryTakeMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmZi: // global
           I64[Sp - 8] = block_cmZd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umZA; else goto cmZe;
       umZA: // global
           call _cmZd(R1) args: 0, res: 0, upd: 0;
       cmZe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmZd() //  [R1]
         { info_tbl: [(cmZd,
                       label: block_cmZd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmZd: // global
           I64[Sp] = block_cmZl_info;
           R1 = P64[R1 + 7];
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmZl() //  [R1, R2]
         { info_tbl: [(cmZl,
                       label: block_cmZl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmZl: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cmZn() args: 0, res: 0, upd: 0;
     }
 },
 _cmZn() //  []
         { info_tbl: [(cmZn,
                       label: block_cmZn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmZn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmZs; else goto cmZr;
       cmZs: // global
           HpAlloc = 16;
           I64[Sp] = block_cmZn_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cmZr: // global
           if (I64[Sp + 16] == 0) goto cmZy; else goto cmZx;
       cmZy: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cmZx: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.702891551 UTC

[section ""data" . GHC.MVar.tryTakeMVar_closure" {
     GHC.MVar.tryTakeMVar_closure:
         const GHC.MVar.tryTakeMVar_info;
 },
 GHC.MVar.tryTakeMVar_entry() //  [R2]
         { info_tbl: [(cmZG,
                       label: GHC.MVar.tryTakeMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmZG: // global
           R2 = R2;
           call GHC.MVar.tryTakeMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.703944276 UTC

[section ""data" . GHC.MVar.tryPutMVar1_closure" {
     GHC.MVar.tryPutMVar1_closure:
         const GHC.MVar.tryPutMVar1_info;
 },
 GHC.MVar.tryPutMVar1_entry() //  [R2, R3]
         { info_tbl: [(cmZQ,
                       label: GHC.MVar.tryPutMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmZQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmZR; else goto cmZS;
       cmZR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.tryPutMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmZS: // global
           I64[Sp - 16] = block_cmZN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto un03; else goto cmZO;
       un03: // global
           call _cmZN(R1) args: 0, res: 0, upd: 0;
       cmZO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmZN() //  [R1]
         { info_tbl: [(cmZN,
                       label: block_cmZN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmZN: // global
           _smVT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cmZV_info;
           R2 = _smVT::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmZV() //  [R1]
         { info_tbl: [(cmZV,
                       label: block_cmZV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmZV: // global
           if (R1 == 0) goto cn02; else goto cn01;
       cn02: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cn01: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.705235033 UTC

[section ""data" . GHC.MVar.tryPutMVar_closure" {
     GHC.MVar.tryPutMVar_closure:
         const GHC.MVar.tryPutMVar_info;
 },
 GHC.MVar.tryPutMVar_entry() //  [R2, R3]
         { info_tbl: [(cn08,
                       label: GHC.MVar.tryPutMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn08: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.tryPutMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.706407153 UTC

[section ""data" . GHC.MVar.tryReadMVar1_closure" {
     GHC.MVar.tryReadMVar1_closure:
         const GHC.MVar.tryReadMVar1_info;
 },
 GHC.MVar.tryReadMVar1_entry() //  [R2]
         { info_tbl: [(cn0i,
                       label: GHC.MVar.tryReadMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn0i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cn0j; else goto cn0k;
       cn0j: // global
           R2 = R2;
           R1 = GHC.MVar.tryReadMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cn0k: // global
           I64[Sp - 8] = block_cn0f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto un0C; else goto cn0g;
       un0C: // global
           call _cn0f(R1) args: 0, res: 0, upd: 0;
       cn0g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn0f() //  [R1]
         { info_tbl: [(cn0f,
                       label: block_cn0f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn0f: // global
           I64[Sp] = block_cn0n_info;
           R1 = P64[R1 + 7];
           call stg_tryReadMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn0n() //  [R1, R2]
         { info_tbl: [(cn0n,
                       label: block_cn0n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn0n: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cn0p() args: 0, res: 0, upd: 0;
     }
 },
 _cn0p() //  []
         { info_tbl: [(cn0p,
                       label: block_cn0p_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn0p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cn0u; else goto cn0t;
       cn0u: // global
           HpAlloc = 16;
           I64[Sp] = block_cn0p_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cn0t: // global
           if (I64[Sp + 16] == 0) goto cn0A; else goto cn0z;
       cn0A: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cn0z: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.707853648 UTC

[section ""data" . GHC.MVar.tryReadMVar_closure" {
     GHC.MVar.tryReadMVar_closure:
         const GHC.MVar.tryReadMVar_info;
 },
 GHC.MVar.tryReadMVar_entry() //  [R2]
         { info_tbl: [(cn0I,
                       label: GHC.MVar.tryReadMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn0I: // global
           R2 = R2;
           call GHC.MVar.tryReadMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.709371057 UTC

[section ""data" . GHC.MVar.isEmptyMVar1_closure" {
     GHC.MVar.isEmptyMVar1_closure:
         const GHC.MVar.isEmptyMVar1_info;
 },
 sat_smWj_entry() //  [R1]
         { info_tbl: [(cn14,
                       label: sat_smWj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn14: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cn15; else goto cn16;
       cn15: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cn16: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto cn13; else goto cn12;
       cn13: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cn12: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.MVar.isEmptyMVar1_entry() //  [R2]
         { info_tbl: [(cn17,
                       label: GHC.MVar.isEmptyMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn17: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cn18; else goto cn19;
       cn18: // global
           R2 = R2;
           R1 = GHC.MVar.isEmptyMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cn19: // global
           I64[Sp - 8] = block_cn0P_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto un1e; else goto cn0Q;
       un1e: // global
           call _cn0P(R1) args: 0, res: 0, upd: 0;
       cn0Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn0P() //  [R1]
         { info_tbl: [(cn0P,
                       label: block_cn0P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn0P: // global
           I64[Sp] = block_cn0U_info;
           R1 = P64[R1 + 7];
           call stg_isEmptyMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn0U() //  [R1]
         { info_tbl: [(cn0U,
                       label: block_cn0U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn0U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cn1d; else goto cn1c;
       cn1d: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cn1c: // global
           I64[Hp - 16] = sat_smWj_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.711143331 UTC

[section ""data" . GHC.MVar.isEmptyMVar_closure" {
     GHC.MVar.isEmptyMVar_closure:
         const GHC.MVar.isEmptyMVar_info;
 },
 GHC.MVar.isEmptyMVar_entry() //  [R2]
         { info_tbl: [(cn1j,
                       label: GHC.MVar.isEmptyMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn1j: // global
           R2 = R2;
           call GHC.MVar.isEmptyMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.712485365 UTC

[section ""data" . GHC.MVar.addMVarFinalizer1_closure" {
     GHC.MVar.addMVarFinalizer1_closure:
         const GHC.MVar.addMVarFinalizer1_info;
 },
 GHC.MVar.addMVarFinalizer1_entry() //  [R2, R3]
         { info_tbl: [(cn1t,
                       label: GHC.MVar.addMVarFinalizer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn1t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cn1x; else goto cn1y;
       cn1x: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.addMVarFinalizer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cn1y: // global
           I64[Sp - 16] = block_cn1q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto un1C; else goto cn1r;
       un1C: // global
           call _cn1q(R1) args: 0, res: 0, upd: 0;
       cn1r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn1q() //  [R1]
         { info_tbl: [(cn1q,
                       label: block_cn1q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn1q: // global
           _smWl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cn1w_info;
           R3 = _smWl::P64;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn1w() //  []
         { info_tbl: [(cn1w,
                       label: block_cn1w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn1w: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.714488409 UTC

[section ""data" . GHC.MVar.addMVarFinalizer_closure" {
     GHC.MVar.addMVarFinalizer_closure:
         const GHC.MVar.addMVarFinalizer_info;
 },
 GHC.MVar.addMVarFinalizer_entry() //  [R2, R3]
         { info_tbl: [(cn1H,
                       label: GHC.MVar.addMVarFinalizer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn1H: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.addMVarFinalizer1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.715538636 UTC

[section ""cstring" . GHC.MVar.$trModule4_bytes" {
     GHC.MVar.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.717384424 UTC

[section ""data" . GHC.MVar.$trModule3_closure" {
     GHC.MVar.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.717942655 UTC

[section ""cstring" . GHC.MVar.$trModule2_bytes" {
     GHC.MVar.$trModule2_bytes:
         I8[] [71,72,67,46,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.718473198 UTC

[section ""data" . GHC.MVar.$trModule1_closure" {
     GHC.MVar.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.719042903 UTC

[section ""data" . GHC.MVar.$trModule_closure" {
     GHC.MVar.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.MVar.$trModule3_closure+1;
         const GHC.MVar.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.719609953 UTC

[section ""data" . $krep_rmUX_closure" {
     $krep_rmUX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRealWorld_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.720240855 UTC

[section ""data" . $krep1_rmUY_closure" {
     $krep1_rmUY_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.720768302 UTC

[section ""data" . $krep2_rmUZ_closure" {
     $krep2_rmUZ_closure:
         const :_con_info;
         const $krep1_rmUY_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.721384226 UTC

[section ""data" . $krep3_rmV0_closure" {
     $krep3_rmV0_closure:
         const :_con_info;
         const $krep_rmUX_closure+1;
         const $krep2_rmUZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.721967592 UTC

[section ""data" . $krep4_rmV1_closure" {
     $krep4_rmV1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcMVar#_closure;
         const $krep3_rmV0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.722527892 UTC

[section ""cstring" . GHC.MVar.$tcMVar2_bytes" {
     GHC.MVar.$tcMVar2_bytes:
         I8[] [77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.723053711 UTC

[section ""data" . GHC.MVar.$tcMVar1_closure" {
     GHC.MVar.$tcMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$tcMVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.723627885 UTC

[section ""data" . GHC.MVar.$tcMVar_closure" {
     GHC.MVar.$tcMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.MVar.$trModule_closure+1;
         const GHC.MVar.$tcMVar1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 4036113818353836845;
         const 5005913288165264115;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.724251633 UTC

[section ""data" . $krep5_rmV2_closure" {
     $krep5_rmV2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure+1;
         const $krep2_rmUZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.724810653 UTC

[section ""data" . GHC.MVar.$tc'MVar1_closure" {
     GHC.MVar.$tc'MVar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rmV1_closure+1;
         const $krep5_rmV2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.725568266 UTC

[section ""cstring" . GHC.MVar.$tc'MVar3_bytes" {
     GHC.MVar.$tc'MVar3_bytes:
         I8[] [39,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.726121247 UTC

[section ""data" . GHC.MVar.$tc'MVar2_closure" {
     GHC.MVar.$tc'MVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$tc'MVar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.726728927 UTC

[section ""data" . GHC.MVar.$tc'MVar_closure" {
     GHC.MVar.$tc'MVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.MVar.$trModule_closure+1;
         const GHC.MVar.$tc'MVar2_closure+1;
         const GHC.MVar.$tc'MVar1_closure+4;
         const 1422225975627779673;
         const 4396512866399833428;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.727635536 UTC

[section ""data" . GHC.MVar.MVar_closure" {
     GHC.MVar.MVar_closure:
         const GHC.MVar.MVar_info;
 },
 GHC.MVar.MVar_entry() //  [R2]
         { info_tbl: [(cn1P,
                       label: GHC.MVar.MVar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn1P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cn1T; else goto cn1S;
       cn1T: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.MVar.MVar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cn1S: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.728494295 UTC

[GHC.MVar.MVar_con_entry() //  [R1]
         { info_tbl: [(cn1U,
                       label: GHC.MVar.MVar_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,77,86,97,114,46,77,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn1U: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.729160937 UTC

[section ""relreadonly" . Sn1V_srt" { Sn1V_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.729754911 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:00.730624842 UTC

[section ""data" . GHC.MVar.$fEqMVar_$c==_closure" {
     GHC.MVar.$fEqMVar_$c==_closure:
         const GHC.MVar.$fEqMVar_$c==_info;
 },
 GHC.MVar.$fEqMVar_$c==_entry() //  [R2, R3]
         { info_tbl: [(cn23,
                       label: GHC.MVar.$fEqMVar_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn23: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cn27; else goto cn28;
       cn27: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.$fEqMVar_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cn28: // global
           I64[Sp - 16] = block_cn20_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto un2h; else goto cn21;
       un2h: // global
           call _cn20(R1) args: 0, res: 0, upd: 0;
       cn21: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn20() //  [R1]
         { info_tbl: [(cn20,
                       label: block_cn20_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn20: // global
           I64[Sp] = block_cn26_info;
           _smV7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _smV7::P64;
           if (R1 & 7 != 0) goto un2g; else goto cn2a;
       un2g: // global
           call _cn26(R1) args: 0, res: 0, upd: 0;
       cn2a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn26() //  [R1]
         { info_tbl: [(cn26,
                       label: block_cn26_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn26: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.73219411 UTC

[section ""data" . GHC.MVar.$fEqMVar_$c/=_closure" {
     GHC.MVar.$fEqMVar_$c/=_closure:
         const GHC.MVar.$fEqMVar_$c/=_info;
 },
 GHC.MVar.$fEqMVar_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cn2p,
                       label: GHC.MVar.$fEqMVar_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn2p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cn2t; else goto cn2u;
       cn2t: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.$fEqMVar_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cn2u: // global
           I64[Sp - 16] = block_cn2m_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto un2R; else goto cn2n;
       un2R: // global
           call _cn2m(R1) args: 0, res: 0, upd: 0;
       cn2n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn2m() //  [R1]
         { info_tbl: [(cn2m,
                       label: block_cn2m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn2m: // global
           I64[Sp] = block_cn2s_info;
           _smVe::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _smVe::P64;
           if (R1 & 7 != 0) goto un2Q; else goto cn2w;
       un2Q: // global
           call _cn2s(R1) args: 0, res: 0, upd: 0;
       cn2w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn2s() //  [R1]
         { info_tbl: [(cn2s,
                       label: block_cn2s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn2s: // global
           if (P64[Sp + 8] == P64[R1 + 7]) goto cn2M; else goto cn2G;
       cn2M: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cn2G: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.733893927 UTC

[section ""data" . GHC.MVar.$fEqMVar_closure" {
     GHC.MVar.$fEqMVar_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.MVar.$fEqMVar_$c==_closure+2;
         const GHC.MVar.$fEqMVar_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.734666271 UTC

[section ""data" . GHC.MVar.newEmptyMVar1_closure" {
     GHC.MVar.newEmptyMVar1_closure:
         const GHC.MVar.newEmptyMVar1_info;
 },
 GHC.MVar.newEmptyMVar1_entry() //  []
         { info_tbl: [(cn2Z,
                       label: GHC.MVar.newEmptyMVar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn2Z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cn30; else goto cn31;
       cn30: // global
           R1 = GHC.MVar.newEmptyMVar1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cn31: // global
           I64[Sp - 8] = block_cn2W_info;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cn2W() //  [R1]
         { info_tbl: [(cn2W,
                       label: block_cn2W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn2W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cn34; else goto cn33;
       cn34: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cn33: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.735711984 UTC

[section ""data" . GHC.MVar.newEmptyMVar_closure" {
     GHC.MVar.newEmptyMVar_closure:
         const GHC.MVar.newEmptyMVar_info;
 },
 GHC.MVar.newEmptyMVar_entry() //  []
         { info_tbl: [(cn39,
                       label: GHC.MVar.newEmptyMVar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn39: // global
           call GHC.MVar.newEmptyMVar1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.736556783 UTC

[section ""data" . GHC.MVar.takeMVar1_closure" {
     GHC.MVar.takeMVar1_closure:
         const GHC.MVar.takeMVar1_info;
 },
 GHC.MVar.takeMVar1_entry() //  [R2]
         { info_tbl: [(cn3j,
                       label: GHC.MVar.takeMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn3j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cn3k; else goto cn3l;
       cn3k: // global
           R2 = R2;
           R1 = GHC.MVar.takeMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cn3l: // global
           I64[Sp - 8] = block_cn3g_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto un3p; else goto cn3h;
       un3p: // global
           call _cn3g(R1) args: 0, res: 0, upd: 0;
       cn3h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn3g() //  [R1]
         { info_tbl: [(cn3g,
                       label: block_cn3g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn3g: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.737702042 UTC

[section ""data" . GHC.MVar.takeMVar_closure" {
     GHC.MVar.takeMVar_closure:
         const GHC.MVar.takeMVar_info;
 },
 GHC.MVar.takeMVar_entry() //  [R2]
         { info_tbl: [(cn3u,
                       label: GHC.MVar.takeMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn3u: // global
           R2 = R2;
           call GHC.MVar.takeMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.738560857 UTC

[section ""data" . GHC.MVar.readMVar1_closure" {
     GHC.MVar.readMVar1_closure:
         const GHC.MVar.readMVar1_info;
 },
 GHC.MVar.readMVar1_entry() //  [R2]
         { info_tbl: [(cn3E,
                       label: GHC.MVar.readMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn3E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cn3F; else goto cn3G;
       cn3F: // global
           R2 = R2;
           R1 = GHC.MVar.readMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cn3G: // global
           I64[Sp - 8] = block_cn3B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto un3K; else goto cn3C;
       un3K: // global
           call _cn3B(R1) args: 0, res: 0, upd: 0;
       cn3C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn3B() //  [R1]
         { info_tbl: [(cn3B,
                       label: block_cn3B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn3B: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readMVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.739590225 UTC

[section ""data" . GHC.MVar.readMVar_closure" {
     GHC.MVar.readMVar_closure:
         const GHC.MVar.readMVar_info;
 },
 GHC.MVar.readMVar_entry() //  [R2]
         { info_tbl: [(cn3P,
                       label: GHC.MVar.readMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn3P: // global
           R2 = R2;
           call GHC.MVar.readMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.740468978 UTC

[section ""data" . GHC.MVar.putMVar1_closure" {
     GHC.MVar.putMVar1_closure:
         const GHC.MVar.putMVar1_info;
 },
 GHC.MVar.putMVar1_entry() //  [R2, R3]
         { info_tbl: [(cn3Z,
                       label: GHC.MVar.putMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn3Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cn43; else goto cn44;
       cn43: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.putMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cn44: // global
           I64[Sp - 16] = block_cn3W_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto un48; else goto cn3X;
       un48: // global
           call _cn3W(R1) args: 0, res: 0, upd: 0;
       cn3X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn3W() //  [R1]
         { info_tbl: [(cn3W,
                       label: block_cn3W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn3W: // global
           _smVw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cn42_info;
           R2 = _smVw::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn42() //  []
         { info_tbl: [(cn42,
                       label: block_cn42_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn42: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.741729684 UTC

[section ""data" . GHC.MVar.putMVar_closure" {
     GHC.MVar.putMVar_closure:
         const GHC.MVar.putMVar_info;
 },
 GHC.MVar.putMVar_entry() //  [R2, R3]
         { info_tbl: [(cn4d,
                       label: GHC.MVar.putMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn4d: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.putMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.742721511 UTC

[section ""data" . GHC.MVar.newMVar1_closure" {
     GHC.MVar.newMVar1_closure:
         const GHC.MVar.newMVar1_info;
 },
 GHC.MVar.newMVar1_entry() //  [R2]
         { info_tbl: [(cn4p,
                       label: GHC.MVar.newMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn4p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cn4q; else goto cn4r;
       cn4q: // global
           R2 = R2;
           R1 = GHC.MVar.newMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cn4r: // global
           I64[Sp - 16] = block_cn4k_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cn4k() //  [R1]
         { info_tbl: [(cn4k,
                       label: block_cn4k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn4k: // global
           I64[Sp] = block_cn4m_info;
           R2 = P64[Sp + 8];
           _smVF::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _smVF::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn4m() //  []
         { info_tbl: [(cn4m,
                       label: block_cn4m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn4m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cn4v; else goto cn4u;
       cn4v: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cn4u: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.743939211 UTC

[section ""data" . GHC.MVar.newMVar_closure" {
     GHC.MVar.newMVar_closure:
         const GHC.MVar.newMVar_info;
 },
 GHC.MVar.newMVar_entry() //  [R2]
         { info_tbl: [(cn4A,
                       label: GHC.MVar.newMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn4A: // global
           R2 = R2;
           call GHC.MVar.newMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.745058924 UTC

[section ""data" . GHC.MVar.tryTakeMVar1_closure" {
     GHC.MVar.tryTakeMVar1_closure:
         const GHC.MVar.tryTakeMVar1_info;
 },
 GHC.MVar.tryTakeMVar1_entry() //  [R2]
         { info_tbl: [(cn4K,
                       label: GHC.MVar.tryTakeMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn4K: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cn4L; else goto cn4M;
       cn4L: // global
           R2 = R2;
           R1 = GHC.MVar.tryTakeMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cn4M: // global
           I64[Sp - 8] = block_cn4H_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto un54; else goto cn4I;
       un54: // global
           call _cn4H(R1) args: 0, res: 0, upd: 0;
       cn4I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn4H() //  [R1]
         { info_tbl: [(cn4H,
                       label: block_cn4H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn4H: // global
           I64[Sp] = block_cn4P_info;
           R1 = P64[R1 + 7];
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn4P() //  [R1, R2]
         { info_tbl: [(cn4P,
                       label: block_cn4P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn4P: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cn4R() args: 0, res: 0, upd: 0;
     }
 },
 _cn4R() //  []
         { info_tbl: [(cn4R,
                       label: block_cn4R_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn4R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cn4W; else goto cn4V;
       cn4W: // global
           HpAlloc = 16;
           I64[Sp] = block_cn4R_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cn4V: // global
           if (I64[Sp + 16] == 0) goto cn52; else goto cn51;
       cn52: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cn51: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.746673045 UTC

[section ""data" . GHC.MVar.tryTakeMVar_closure" {
     GHC.MVar.tryTakeMVar_closure:
         const GHC.MVar.tryTakeMVar_info;
 },
 GHC.MVar.tryTakeMVar_entry() //  [R2]
         { info_tbl: [(cn5a,
                       label: GHC.MVar.tryTakeMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn5a: // global
           R2 = R2;
           call GHC.MVar.tryTakeMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.747654686 UTC

[section ""data" . GHC.MVar.tryPutMVar1_closure" {
     GHC.MVar.tryPutMVar1_closure:
         const GHC.MVar.tryPutMVar1_info;
 },
 GHC.MVar.tryPutMVar1_entry() //  [R2, R3]
         { info_tbl: [(cn5k,
                       label: GHC.MVar.tryPutMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn5k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cn5l; else goto cn5m;
       cn5l: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.tryPutMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cn5m: // global
           I64[Sp - 16] = block_cn5h_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto un5x; else goto cn5i;
       un5x: // global
           call _cn5h(R1) args: 0, res: 0, upd: 0;
       cn5i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn5h() //  [R1]
         { info_tbl: [(cn5h,
                       label: block_cn5h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn5h: // global
           _smVT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cn5p_info;
           R2 = _smVT::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn5p() //  [R1]
         { info_tbl: [(cn5p,
                       label: block_cn5p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn5p: // global
           if (R1 == 0) goto cn5w; else goto cn5v;
       cn5w: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cn5v: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.748934323 UTC

[section ""data" . GHC.MVar.tryPutMVar_closure" {
     GHC.MVar.tryPutMVar_closure:
         const GHC.MVar.tryPutMVar_info;
 },
 GHC.MVar.tryPutMVar_entry() //  [R2, R3]
         { info_tbl: [(cn5C,
                       label: GHC.MVar.tryPutMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn5C: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.tryPutMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.750135444 UTC

[section ""data" . GHC.MVar.tryReadMVar1_closure" {
     GHC.MVar.tryReadMVar1_closure:
         const GHC.MVar.tryReadMVar1_info;
 },
 GHC.MVar.tryReadMVar1_entry() //  [R2]
         { info_tbl: [(cn5M,
                       label: GHC.MVar.tryReadMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn5M: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cn5N; else goto cn5O;
       cn5N: // global
           R2 = R2;
           R1 = GHC.MVar.tryReadMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cn5O: // global
           I64[Sp - 8] = block_cn5J_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto un66; else goto cn5K;
       un66: // global
           call _cn5J(R1) args: 0, res: 0, upd: 0;
       cn5K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn5J() //  [R1]
         { info_tbl: [(cn5J,
                       label: block_cn5J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn5J: // global
           I64[Sp] = block_cn5R_info;
           R1 = P64[R1 + 7];
           call stg_tryReadMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn5R() //  [R1, R2]
         { info_tbl: [(cn5R,
                       label: block_cn5R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn5R: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cn5T() args: 0, res: 0, upd: 0;
     }
 },
 _cn5T() //  []
         { info_tbl: [(cn5T,
                       label: block_cn5T_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn5T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cn5Y; else goto cn5X;
       cn5Y: // global
           HpAlloc = 16;
           I64[Sp] = block_cn5T_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cn5X: // global
           if (I64[Sp + 16] == 0) goto cn64; else goto cn63;
       cn64: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cn63: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.751560846 UTC

[section ""data" . GHC.MVar.tryReadMVar_closure" {
     GHC.MVar.tryReadMVar_closure:
         const GHC.MVar.tryReadMVar_info;
 },
 GHC.MVar.tryReadMVar_entry() //  [R2]
         { info_tbl: [(cn6c,
                       label: GHC.MVar.tryReadMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn6c: // global
           R2 = R2;
           call GHC.MVar.tryReadMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.752660704 UTC

[section ""data" . GHC.MVar.isEmptyMVar1_closure" {
     GHC.MVar.isEmptyMVar1_closure:
         const GHC.MVar.isEmptyMVar1_info;
 },
 sat_smWj_entry() //  [R1]
         { info_tbl: [(cn6y,
                       label: sat_smWj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn6y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cn6z; else goto cn6A;
       cn6z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cn6A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto cn6x; else goto cn6w;
       cn6x: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cn6w: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.MVar.isEmptyMVar1_entry() //  [R2]
         { info_tbl: [(cn6B,
                       label: GHC.MVar.isEmptyMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn6B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cn6C; else goto cn6D;
       cn6C: // global
           R2 = R2;
           R1 = GHC.MVar.isEmptyMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cn6D: // global
           I64[Sp - 8] = block_cn6j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto un6I; else goto cn6k;
       un6I: // global
           call _cn6j(R1) args: 0, res: 0, upd: 0;
       cn6k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn6j() //  [R1]
         { info_tbl: [(cn6j,
                       label: block_cn6j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn6j: // global
           I64[Sp] = block_cn6o_info;
           R1 = P64[R1 + 7];
           call stg_isEmptyMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn6o() //  [R1]
         { info_tbl: [(cn6o,
                       label: block_cn6o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn6o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cn6H; else goto cn6G;
       cn6H: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cn6G: // global
           I64[Hp - 16] = sat_smWj_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.754269415 UTC

[section ""data" . GHC.MVar.isEmptyMVar_closure" {
     GHC.MVar.isEmptyMVar_closure:
         const GHC.MVar.isEmptyMVar_info;
 },
 GHC.MVar.isEmptyMVar_entry() //  [R2]
         { info_tbl: [(cn6N,
                       label: GHC.MVar.isEmptyMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn6N: // global
           R2 = R2;
           call GHC.MVar.isEmptyMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.756371677 UTC

[section ""data" . GHC.MVar.addMVarFinalizer1_closure" {
     GHC.MVar.addMVarFinalizer1_closure:
         const GHC.MVar.addMVarFinalizer1_info;
 },
 GHC.MVar.addMVarFinalizer1_entry() //  [R2, R3]
         { info_tbl: [(cn6X,
                       label: GHC.MVar.addMVarFinalizer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn6X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cn71; else goto cn72;
       cn71: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.addMVarFinalizer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cn72: // global
           I64[Sp - 16] = block_cn6U_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto un76; else goto cn6V;
       un76: // global
           call _cn6U(R1) args: 0, res: 0, upd: 0;
       cn6V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn6U() //  [R1]
         { info_tbl: [(cn6U,
                       label: block_cn6U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn6U: // global
           _smWl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cn70_info;
           R3 = _smWl::P64;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn70() //  []
         { info_tbl: [(cn70,
                       label: block_cn70_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn70: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.757633659 UTC

[section ""data" . GHC.MVar.addMVarFinalizer_closure" {
     GHC.MVar.addMVarFinalizer_closure:
         const GHC.MVar.addMVarFinalizer_info;
 },
 GHC.MVar.addMVarFinalizer_entry() //  [R2, R3]
         { info_tbl: [(cn7b,
                       label: GHC.MVar.addMVarFinalizer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn7b: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.addMVarFinalizer1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.758314229 UTC

[section ""cstring" . GHC.MVar.$trModule4_bytes" {
     GHC.MVar.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.758836448 UTC

[section ""data" . GHC.MVar.$trModule3_closure" {
     GHC.MVar.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.759350423 UTC

[section ""cstring" . GHC.MVar.$trModule2_bytes" {
     GHC.MVar.$trModule2_bytes:
         I8[] [71,72,67,46,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.759847436 UTC

[section ""data" . GHC.MVar.$trModule1_closure" {
     GHC.MVar.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.760366519 UTC

[section ""data" . GHC.MVar.$trModule_closure" {
     GHC.MVar.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.MVar.$trModule3_closure+1;
         const GHC.MVar.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.760922982 UTC

[section ""data" . $krep_rmUX_closure" {
     $krep_rmUX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRealWorld_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.761540795 UTC

[section ""data" . $krep1_rmUY_closure" {
     $krep1_rmUY_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.762090056 UTC

[section ""data" . $krep2_rmUZ_closure" {
     $krep2_rmUZ_closure:
         const :_con_info;
         const $krep1_rmUY_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.76262515 UTC

[section ""data" . $krep3_rmV0_closure" {
     $krep3_rmV0_closure:
         const :_con_info;
         const $krep_rmUX_closure+1;
         const $krep2_rmUZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.763184233 UTC

[section ""data" . $krep4_rmV1_closure" {
     $krep4_rmV1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcMVar#_closure;
         const $krep3_rmV0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.76373051 UTC

[section ""cstring" . GHC.MVar.$tcMVar2_bytes" {
     GHC.MVar.$tcMVar2_bytes:
         I8[] [77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.764276577 UTC

[section ""data" . GHC.MVar.$tcMVar1_closure" {
     GHC.MVar.$tcMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$tcMVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.764834387 UTC

[section ""data" . GHC.MVar.$tcMVar_closure" {
     GHC.MVar.$tcMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.MVar.$trModule_closure+1;
         const GHC.MVar.$tcMVar1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 4036113818353836845;
         const 5005913288165264115;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.765468469 UTC

[section ""data" . $krep5_rmV2_closure" {
     $krep5_rmV2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure+1;
         const $krep2_rmUZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.766014875 UTC

[section ""data" . GHC.MVar.$tc'MVar1_closure" {
     GHC.MVar.$tc'MVar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rmV1_closure+1;
         const $krep5_rmV2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.766555262 UTC

[section ""cstring" . GHC.MVar.$tc'MVar3_bytes" {
     GHC.MVar.$tc'MVar3_bytes:
         I8[] [39,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.767089897 UTC

[section ""data" . GHC.MVar.$tc'MVar2_closure" {
     GHC.MVar.$tc'MVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$tc'MVar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.767647485 UTC

[section ""data" . GHC.MVar.$tc'MVar_closure" {
     GHC.MVar.$tc'MVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.MVar.$trModule_closure+1;
         const GHC.MVar.$tc'MVar2_closure+1;
         const GHC.MVar.$tc'MVar1_closure+4;
         const 1422225975627779673;
         const 4396512866399833428;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.768516769 UTC

[section ""data" . GHC.MVar.MVar_closure" {
     GHC.MVar.MVar_closure:
         const GHC.MVar.MVar_info;
 },
 GHC.MVar.MVar_entry() //  [R2]
         { info_tbl: [(cn7j,
                       label: GHC.MVar.MVar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn7j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cn7n; else goto cn7m;
       cn7n: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.MVar.MVar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cn7m: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.769533384 UTC

[GHC.MVar.MVar_con_entry() //  [R1]
         { info_tbl: [(cn7o,
                       label: GHC.MVar.MVar_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,77,86,97,114,46,77,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn7o: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.770159602 UTC

[section ""relreadonly" . Sn1V_srt" { Sn1V_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.770967829 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:00.7727697 UTC

[section ""data" . GHC.MVar.$fEqMVar_$c==_closure" {
     GHC.MVar.$fEqMVar_$c==_closure:
         const GHC.MVar.$fEqMVar_$c==_info;
 },
 GHC.MVar.$fEqMVar_$c==_entry() //  [R2, R3]
         { info_tbl: [(cn7x,
                       label: GHC.MVar.$fEqMVar_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn7x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cn7B; else goto cn7C;
       cn7B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.$fEqMVar_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cn7C: // global
           I64[Sp - 16] = block_cn7u_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto un7L; else goto cn7v;
       un7L: // global
           call _cn7u(R1) args: 0, res: 0, upd: 0;
       cn7v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn7u() //  [R1]
         { info_tbl: [(cn7u,
                       label: block_cn7u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn7u: // global
           I64[Sp] = block_cn7A_info;
           _smV7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _smV7::P64;
           if (R1 & 7 != 0) goto un7K; else goto cn7E;
       un7K: // global
           call _cn7A(R1) args: 0, res: 0, upd: 0;
       cn7E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn7A() //  [R1]
         { info_tbl: [(cn7A,
                       label: block_cn7A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn7A: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.78494493 UTC

[section ""data" . GHC.MVar.$fEqMVar_$c/=_closure" {
     GHC.MVar.$fEqMVar_$c/=_closure:
         const GHC.MVar.$fEqMVar_$c/=_info;
 },
 GHC.MVar.$fEqMVar_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cn8a,
                       label: GHC.MVar.$fEqMVar_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn8a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cn8e; else goto cn8f;
       cn8e: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.$fEqMVar_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cn8f: // global
           I64[Sp - 16] = block_cn87_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto un8C; else goto cn88;
       un8C: // global
           call _cn87(R1) args: 0, res: 0, upd: 0;
       cn88: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn87() //  [R1]
         { info_tbl: [(cn87,
                       label: block_cn87_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn87: // global
           I64[Sp] = block_cn8d_info;
           _smVe::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _smVe::P64;
           if (R1 & 7 != 0) goto un8B; else goto cn8h;
       un8B: // global
           call _cn8d(R1) args: 0, res: 0, upd: 0;
       cn8h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn8d() //  [R1]
         { info_tbl: [(cn8d,
                       label: block_cn8d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn8d: // global
           if (P64[Sp + 8] == P64[R1 + 7]) goto cn8x; else goto cn8r;
       cn8x: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cn8r: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.797127912 UTC

[section ""data" . GHC.MVar.$fEqMVar_closure" {
     GHC.MVar.$fEqMVar_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.MVar.$fEqMVar_$c==_closure+2;
         const GHC.MVar.$fEqMVar_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.80017599 UTC

[section ""data" . GHC.MVar.newEmptyMVar1_closure" {
     GHC.MVar.newEmptyMVar1_closure:
         const GHC.MVar.newEmptyMVar1_info;
 },
 GHC.MVar.newEmptyMVar1_entry() //  []
         { info_tbl: [(cn91,
                       label: GHC.MVar.newEmptyMVar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn91: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cn92; else goto cn93;
       cn92: // global
           R1 = GHC.MVar.newEmptyMVar1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cn93: // global
           I64[Sp - 8] = block_cn8Y_info;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cn8Y() //  [R1]
         { info_tbl: [(cn8Y,
                       label: block_cn8Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn8Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cn96; else goto cn95;
       cn96: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cn95: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.809025271 UTC

[section ""data" . GHC.MVar.newEmptyMVar_closure" {
     GHC.MVar.newEmptyMVar_closure:
         const GHC.MVar.newEmptyMVar_info;
 },
 GHC.MVar.newEmptyMVar_entry() //  []
         { info_tbl: [(cn9k,
                       label: GHC.MVar.newEmptyMVar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn9k: // global
           call GHC.MVar.newEmptyMVar1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.813905157 UTC

[section ""data" . GHC.MVar.takeMVar1_closure" {
     GHC.MVar.takeMVar1_closure:
         const GHC.MVar.takeMVar1_info;
 },
 GHC.MVar.takeMVar1_entry() //  [R2]
         { info_tbl: [(cn9y,
                       label: GHC.MVar.takeMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn9y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cn9z; else goto cn9A;
       cn9z: // global
           R2 = R2;
           R1 = GHC.MVar.takeMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cn9A: // global
           I64[Sp - 8] = block_cn9v_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto un9E; else goto cn9w;
       un9E: // global
           call _cn9v(R1) args: 0, res: 0, upd: 0;
       cn9w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cn9v() //  [R1]
         { info_tbl: [(cn9v,
                       label: block_cn9v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn9v: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.819606736 UTC

[section ""data" . GHC.MVar.takeMVar_closure" {
     GHC.MVar.takeMVar_closure:
         const GHC.MVar.takeMVar_info;
 },
 GHC.MVar.takeMVar_entry() //  [R2]
         { info_tbl: [(cn9S,
                       label: GHC.MVar.takeMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cn9S: // global
           R2 = R2;
           call GHC.MVar.takeMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.822913278 UTC

[section ""data" . GHC.MVar.readMVar1_closure" {
     GHC.MVar.readMVar1_closure:
         const GHC.MVar.readMVar1_info;
 },
 GHC.MVar.readMVar1_entry() //  [R2]
         { info_tbl: [(cna6,
                       label: GHC.MVar.readMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cna6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cna7; else goto cna8;
       cna7: // global
           R2 = R2;
           R1 = GHC.MVar.readMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cna8: // global
           I64[Sp - 8] = block_cna3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unac; else goto cna4;
       unac: // global
           call _cna3(R1) args: 0, res: 0, upd: 0;
       cna4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cna3() //  [R1]
         { info_tbl: [(cna3,
                       label: block_cna3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cna3: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readMVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.831000092 UTC

[section ""data" . GHC.MVar.readMVar_closure" {
     GHC.MVar.readMVar_closure:
         const GHC.MVar.readMVar_info;
 },
 GHC.MVar.readMVar_entry() //  [R2]
         { info_tbl: [(cnaq,
                       label: GHC.MVar.readMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnaq: // global
           R2 = R2;
           call GHC.MVar.readMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.834659237 UTC

[section ""data" . GHC.MVar.putMVar1_closure" {
     GHC.MVar.putMVar1_closure:
         const GHC.MVar.putMVar1_info;
 },
 GHC.MVar.putMVar1_entry() //  [R2, R3]
         { info_tbl: [(cnaE,
                       label: GHC.MVar.putMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnaE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnaI; else goto cnaJ;
       cnaI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.putMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cnaJ: // global
           I64[Sp - 16] = block_cnaB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto unaN; else goto cnaC;
       unaN: // global
           call _cnaB(R1) args: 0, res: 0, upd: 0;
       cnaC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnaB() //  [R1]
         { info_tbl: [(cnaB,
                       label: block_cnaB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnaB: // global
           _smVw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cnaH_info;
           R2 = _smVw::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnaH() //  []
         { info_tbl: [(cnaH,
                       label: block_cnaH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnaH: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.842362869 UTC

[section ""data" . GHC.MVar.putMVar_closure" {
     GHC.MVar.putMVar_closure:
         const GHC.MVar.putMVar_info;
 },
 GHC.MVar.putMVar_entry() //  [R2, R3]
         { info_tbl: [(cnb5,
                       label: GHC.MVar.putMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnb5: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.putMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.845885496 UTC

[section ""data" . GHC.MVar.newMVar1_closure" {
     GHC.MVar.newMVar1_closure:
         const GHC.MVar.newMVar1_info;
 },
 GHC.MVar.newMVar1_entry() //  [R2]
         { info_tbl: [(cnbl,
                       label: GHC.MVar.newMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnbl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnbm; else goto cnbn;
       cnbm: // global
           R2 = R2;
           R1 = GHC.MVar.newMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnbn: // global
           I64[Sp - 16] = block_cnbg_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cnbg() //  [R1]
         { info_tbl: [(cnbg,
                       label: block_cnbg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnbg: // global
           I64[Sp] = block_cnbi_info;
           R2 = P64[Sp + 8];
           _smVF::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _smVF::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnbi() //  []
         { info_tbl: [(cnbi,
                       label: block_cnbi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnbi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnbr; else goto cnbq;
       cnbr: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cnbq: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.852589609 UTC

[section ""data" . GHC.MVar.newMVar_closure" {
     GHC.MVar.newMVar_closure:
         const GHC.MVar.newMVar_info;
 },
 GHC.MVar.newMVar_entry() //  [R2]
         { info_tbl: [(cnbJ,
                       label: GHC.MVar.newMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnbJ: // global
           R2 = R2;
           call GHC.MVar.newMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.856091516 UTC

[section ""data" . GHC.MVar.tryTakeMVar1_closure" {
     GHC.MVar.tryTakeMVar1_closure:
         const GHC.MVar.tryTakeMVar1_info;
 },
 GHC.MVar.tryTakeMVar1_entry() //  [R2]
         { info_tbl: [(cnbX,
                       label: GHC.MVar.tryTakeMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnbX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cnbY; else goto cnbZ;
       cnbY: // global
           R2 = R2;
           R1 = GHC.MVar.tryTakeMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnbZ: // global
           I64[Sp - 8] = block_cnbU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unch; else goto cnbV;
       unch: // global
           call _cnbU(R1) args: 0, res: 0, upd: 0;
       cnbV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnbU() //  [R1]
         { info_tbl: [(cnbU,
                       label: block_cnbU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnbU: // global
           I64[Sp] = block_cnc2_info;
           R1 = P64[R1 + 7];
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnc2() //  [R1, R2]
         { info_tbl: [(cnc2,
                       label: block_cnc2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnc2: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cnc4() args: 0, res: 0, upd: 0;
     }
 },
 _cnc4() //  []
         { info_tbl: [(cnc4,
                       label: block_cnc4_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnc4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnc9; else goto cnc8;
       cnc9: // global
           HpAlloc = 16;
           I64[Sp] = block_cnc4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cnc8: // global
           if (I64[Sp + 16] == 0) goto cncf; else goto cnce;
       cncf: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cnce: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.865131469 UTC

[section ""data" . GHC.MVar.tryTakeMVar_closure" {
     GHC.MVar.tryTakeMVar_closure:
         const GHC.MVar.tryTakeMVar_info;
 },
 GHC.MVar.tryTakeMVar_entry() //  [R2]
         { info_tbl: [(cncF,
                       label: GHC.MVar.tryTakeMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cncF: // global
           R2 = R2;
           call GHC.MVar.tryTakeMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.868619631 UTC

[section ""data" . GHC.MVar.tryPutMVar1_closure" {
     GHC.MVar.tryPutMVar1_closure:
         const GHC.MVar.tryPutMVar1_info;
 },
 GHC.MVar.tryPutMVar1_entry() //  [R2, R3]
         { info_tbl: [(cncT,
                       label: GHC.MVar.tryPutMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cncT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cncU; else goto cncV;
       cncU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.tryPutMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cncV: // global
           I64[Sp - 16] = block_cncQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto und6; else goto cncR;
       und6: // global
           call _cncQ(R1) args: 0, res: 0, upd: 0;
       cncR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cncQ() //  [R1]
         { info_tbl: [(cncQ,
                       label: block_cncQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cncQ: // global
           _smVT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cncY_info;
           R2 = _smVT::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cncY() //  [R1]
         { info_tbl: [(cncY,
                       label: block_cncY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cncY: // global
           if (R1 == 0) goto cnd5; else goto cnd4;
       cnd5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cnd4: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.876677256 UTC

[section ""data" . GHC.MVar.tryPutMVar_closure" {
     GHC.MVar.tryPutMVar_closure:
         const GHC.MVar.tryPutMVar_info;
 },
 GHC.MVar.tryPutMVar_entry() //  [R2, R3]
         { info_tbl: [(cndp,
                       label: GHC.MVar.tryPutMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cndp: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.tryPutMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.880229739 UTC

[section ""data" . GHC.MVar.tryReadMVar1_closure" {
     GHC.MVar.tryReadMVar1_closure:
         const GHC.MVar.tryReadMVar1_info;
 },
 GHC.MVar.tryReadMVar1_entry() //  [R2]
         { info_tbl: [(cndD,
                       label: GHC.MVar.tryReadMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cndD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cndE; else goto cndF;
       cndE: // global
           R2 = R2;
           R1 = GHC.MVar.tryReadMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cndF: // global
           I64[Sp - 8] = block_cndA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto undX; else goto cndB;
       undX: // global
           call _cndA(R1) args: 0, res: 0, upd: 0;
       cndB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cndA() //  [R1]
         { info_tbl: [(cndA,
                       label: block_cndA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cndA: // global
           I64[Sp] = block_cndI_info;
           R1 = P64[R1 + 7];
           call stg_tryReadMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cndI() //  [R1, R2]
         { info_tbl: [(cndI,
                       label: block_cndI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cndI: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cndK() args: 0, res: 0, upd: 0;
     }
 },
 _cndK() //  []
         { info_tbl: [(cndK,
                       label: block_cndK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cndK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cndP; else goto cndO;
       cndP: // global
           HpAlloc = 16;
           I64[Sp] = block_cndK_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cndO: // global
           if (I64[Sp + 16] == 0) goto cndV; else goto cndU;
       cndV: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cndU: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.889037542 UTC

[section ""data" . GHC.MVar.tryReadMVar_closure" {
     GHC.MVar.tryReadMVar_closure:
         const GHC.MVar.tryReadMVar_info;
 },
 GHC.MVar.tryReadMVar_entry() //  [R2]
         { info_tbl: [(cnel,
                       label: GHC.MVar.tryReadMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnel: // global
           R2 = R2;
           call GHC.MVar.tryReadMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.892902994 UTC

[section ""data" . GHC.MVar.isEmptyMVar1_closure" {
     GHC.MVar.isEmptyMVar1_closure:
         const GHC.MVar.isEmptyMVar1_info;
 },
 sat_smWj_entry() //  [R1]
         { info_tbl: [(cneL,
                       label: sat_smWj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cneL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cneM; else goto cneN;
       cneM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cneN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto cneK; else goto cneJ;
       cneK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cneJ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.MVar.isEmptyMVar1_entry() //  [R2]
         { info_tbl: [(cneO,
                       label: GHC.MVar.isEmptyMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cneO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cneP; else goto cneQ;
       cneP: // global
           R2 = R2;
           R1 = GHC.MVar.isEmptyMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cneQ: // global
           I64[Sp - 8] = block_cnew_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uneV; else goto cnex;
       uneV: // global
           call _cnew(R1) args: 0, res: 0, upd: 0;
       cnex: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnew() //  [R1]
         { info_tbl: [(cnew,
                       label: block_cnew_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnew: // global
           I64[Sp] = block_cneB_info;
           R1 = P64[R1 + 7];
           call stg_isEmptyMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cneB() //  [R1]
         { info_tbl: [(cneB,
                       label: block_cneB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cneB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cneU; else goto cneT;
       cneU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cneT: // global
           I64[Hp - 16] = sat_smWj_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.902212345 UTC

[section ""data" . GHC.MVar.isEmptyMVar_closure" {
     GHC.MVar.isEmptyMVar_closure:
         const GHC.MVar.isEmptyMVar_info;
 },
 GHC.MVar.isEmptyMVar_entry() //  [R2]
         { info_tbl: [(cnfj,
                       label: GHC.MVar.isEmptyMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnfj: // global
           R2 = R2;
           call GHC.MVar.isEmptyMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.906230896 UTC

[section ""data" . GHC.MVar.addMVarFinalizer1_closure" {
     GHC.MVar.addMVarFinalizer1_closure:
         const GHC.MVar.addMVarFinalizer1_info;
 },
 GHC.MVar.addMVarFinalizer1_entry() //  [R2, R3]
         { info_tbl: [(cnfx,
                       label: GHC.MVar.addMVarFinalizer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnfx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnfB; else goto cnfC;
       cnfB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.addMVarFinalizer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cnfC: // global
           I64[Sp - 16] = block_cnfu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto unfG; else goto cnfv;
       unfG: // global
           call _cnfu(R1) args: 0, res: 0, upd: 0;
       cnfv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnfu() //  [R1]
         { info_tbl: [(cnfu,
                       label: block_cnfu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnfu: // global
           _smWl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cnfA_info;
           R3 = _smWl::P64;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnfA() //  []
         { info_tbl: [(cnfA,
                       label: block_cnfA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnfA: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.913216108 UTC

[section ""data" . GHC.MVar.addMVarFinalizer_closure" {
     GHC.MVar.addMVarFinalizer_closure:
         const GHC.MVar.addMVarFinalizer_info;
 },
 GHC.MVar.addMVarFinalizer_entry() //  [R2, R3]
         { info_tbl: [(cnfY,
                       label: GHC.MVar.addMVarFinalizer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnfY: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.addMVarFinalizer1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.916392658 UTC

[section ""cstring" . GHC.MVar.$trModule4_bytes" {
     GHC.MVar.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.918097162 UTC

[section ""data" . GHC.MVar.$trModule3_closure" {
     GHC.MVar.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.919654382 UTC

[section ""cstring" . GHC.MVar.$trModule2_bytes" {
     GHC.MVar.$trModule2_bytes:
         I8[] [71,72,67,46,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.921312524 UTC

[section ""data" . GHC.MVar.$trModule1_closure" {
     GHC.MVar.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.922881224 UTC

[section ""data" . GHC.MVar.$trModule_closure" {
     GHC.MVar.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.MVar.$trModule3_closure+1;
         const GHC.MVar.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.92446359 UTC

[section ""data" . $krep_rmUX_closure" {
     $krep_rmUX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRealWorld_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.926377435 UTC

[section ""data" . $krep1_rmUY_closure" {
     $krep1_rmUY_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.927940147 UTC

[section ""data" . $krep2_rmUZ_closure" {
     $krep2_rmUZ_closure:
         const :_con_info;
         const $krep1_rmUY_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.92962929 UTC

[section ""data" . $krep3_rmV0_closure" {
     $krep3_rmV0_closure:
         const :_con_info;
         const $krep_rmUX_closure+1;
         const $krep2_rmUZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.931670418 UTC

[section ""data" . $krep4_rmV1_closure" {
     $krep4_rmV1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcMVar#_closure;
         const $krep3_rmV0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.933436587 UTC

[section ""cstring" . GHC.MVar.$tcMVar2_bytes" {
     GHC.MVar.$tcMVar2_bytes:
         I8[] [77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.934940617 UTC

[section ""data" . GHC.MVar.$tcMVar1_closure" {
     GHC.MVar.$tcMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$tcMVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.936600247 UTC

[section ""data" . GHC.MVar.$tcMVar_closure" {
     GHC.MVar.$tcMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.MVar.$trModule_closure+1;
         const GHC.MVar.$tcMVar1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 4036113818353836845;
         const 5005913288165264115;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.938404112 UTC

[section ""data" . $krep5_rmV2_closure" {
     $krep5_rmV2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure+1;
         const $krep2_rmUZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.94004782 UTC

[section ""data" . GHC.MVar.$tc'MVar1_closure" {
     GHC.MVar.$tc'MVar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rmV1_closure+1;
         const $krep5_rmV2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.941684754 UTC

[section ""cstring" . GHC.MVar.$tc'MVar3_bytes" {
     GHC.MVar.$tc'MVar3_bytes:
         I8[] [39,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.943276698 UTC

[section ""data" . GHC.MVar.$tc'MVar2_closure" {
     GHC.MVar.$tc'MVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$tc'MVar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.944897238 UTC

[section ""data" . GHC.MVar.$tc'MVar_closure" {
     GHC.MVar.$tc'MVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.MVar.$trModule_closure+1;
         const GHC.MVar.$tc'MVar2_closure+1;
         const GHC.MVar.$tc'MVar1_closure+4;
         const 1422225975627779673;
         const 4396512866399833428;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.946909782 UTC

[section ""data" . GHC.MVar.MVar_closure" {
     GHC.MVar.MVar_closure:
         const GHC.MVar.MVar_info;
 },
 GHC.MVar.MVar_entry() //  [R2]
         { info_tbl: [(cngs,
                       label: GHC.MVar.MVar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cngs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cngw; else goto cngv;
       cngw: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.MVar.MVar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cngv: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.951138131 UTC

[GHC.MVar.MVar_con_entry() //  [R1]
         { info_tbl: [(cngC,
                       label: GHC.MVar.MVar_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,77,86,97,114,46,77,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cngC: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.954121723 UTC

[section ""relreadonly" . Sn1V_srt" { Sn1V_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.190175611 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:01.192053548 UTC

[section ""data" . GHC.MVar.$fEqMVar_$c==_closure" {
     GHC.MVar.$fEqMVar_$c==_closure:
         const GHC.MVar.$fEqMVar_$c==_info;
 },
 GHC.MVar.$fEqMVar_$c==_entry() //  [R2, R3]
         { info_tbl: [(cnie,
                       label: GHC.MVar.$fEqMVar_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnie: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnii; else goto cnij;
       cnii: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.$fEqMVar_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cnij: // global
           I64[Sp - 16] = block_cnib_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto unis; else goto cnic;
       unis: // global
           call _cnib(R1) args: 0, res: 0, upd: 0;
       cnic: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnib() //  [R1]
         { info_tbl: [(cnib,
                       label: block_cnib_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnib: // global
           I64[Sp] = block_cnih_info;
           _sngM::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sngM::P64;
           if (R1 & 7 != 0) goto unir; else goto cnil;
       unir: // global
           call _cnih(R1) args: 0, res: 0, upd: 0;
       cnil: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnih() //  [R1]
         { info_tbl: [(cnih,
                       label: block_cnih_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnih: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.199929721 UTC

[section ""data" . GHC.MVar.$fEqMVar_$c/=_closure" {
     GHC.MVar.$fEqMVar_$c/=_closure:
         const GHC.MVar.$fEqMVar_$c/=_info;
 },
 GHC.MVar.$fEqMVar_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cniU,
                       label: GHC.MVar.$fEqMVar_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cniU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cniY; else goto cniZ;
       cniY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.$fEqMVar_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cniZ: // global
           I64[Sp - 16] = block_cniR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto unjm; else goto cniS;
       unjm: // global
           call _cniR(R1) args: 0, res: 0, upd: 0;
       cniS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cniR() //  [R1]
         { info_tbl: [(cniR,
                       label: block_cniR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cniR: // global
           I64[Sp] = block_cniX_info;
           _sngT::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sngT::P64;
           if (R1 & 7 != 0) goto unjl; else goto cnj1;
       unjl: // global
           call _cniX(R1) args: 0, res: 0, upd: 0;
       cnj1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cniX() //  [R1]
         { info_tbl: [(cniX,
                       label: block_cniX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cniX: // global
           if (P64[Sp + 8] == P64[R1 + 7]) goto cnjh; else goto cnjb;
       cnjh: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cnjb: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.206996628 UTC

[section ""data" . GHC.MVar.$fEqMVar_closure" {
     GHC.MVar.$fEqMVar_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.MVar.$fEqMVar_$c==_closure+2;
         const GHC.MVar.$fEqMVar_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.209041973 UTC

[section ""data" . GHC.MVar.newEmptyMVar1_closure" {
     GHC.MVar.newEmptyMVar1_closure:
         const GHC.MVar.newEmptyMVar1_info;
 },
 GHC.MVar.newEmptyMVar1_entry() //  []
         { info_tbl: [(cnjP,
                       label: GHC.MVar.newEmptyMVar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnjP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cnjQ; else goto cnjR;
       cnjQ: // global
           R1 = GHC.MVar.newEmptyMVar1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cnjR: // global
           I64[Sp - 8] = block_cnjM_info;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cnjM() //  [R1]
         { info_tbl: [(cnjM,
                       label: block_cnjM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnjM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnjU; else goto cnjT;
       cnjU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cnjT: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.214352829 UTC

[section ""data" . GHC.MVar.newEmptyMVar_closure" {
     GHC.MVar.newEmptyMVar_closure:
         const GHC.MVar.newEmptyMVar_info;
 },
 GHC.MVar.newEmptyMVar_entry() //  []
         { info_tbl: [(cnka,
                       label: GHC.MVar.newEmptyMVar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnka: // global
           call GHC.MVar.newEmptyMVar1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.217646155 UTC

[section ""data" . GHC.MVar.takeMVar1_closure" {
     GHC.MVar.takeMVar1_closure:
         const GHC.MVar.takeMVar1_info;
 },
 GHC.MVar.takeMVar1_entry() //  [R2]
         { info_tbl: [(cnko,
                       label: GHC.MVar.takeMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnko: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cnkp; else goto cnkq;
       cnkp: // global
           R2 = R2;
           R1 = GHC.MVar.takeMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnkq: // global
           I64[Sp - 8] = block_cnkl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unku; else goto cnkm;
       unku: // global
           call _cnkl(R1) args: 0, res: 0, upd: 0;
       cnkm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnkl() //  [R1]
         { info_tbl: [(cnkl,
                       label: block_cnkl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnkl: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.22346014 UTC

[section ""data" . GHC.MVar.takeMVar_closure" {
     GHC.MVar.takeMVar_closure:
         const GHC.MVar.takeMVar_info;
 },
 GHC.MVar.takeMVar_entry() //  [R2]
         { info_tbl: [(cnkJ,
                       label: GHC.MVar.takeMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnkJ: // global
           R2 = R2;
           call GHC.MVar.takeMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.226654827 UTC

[section ""data" . GHC.MVar.readMVar1_closure" {
     GHC.MVar.readMVar1_closure:
         const GHC.MVar.readMVar1_info;
 },
 GHC.MVar.readMVar1_entry() //  [R2]
         { info_tbl: [(cnkX,
                       label: GHC.MVar.readMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnkX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cnkY; else goto cnkZ;
       cnkY: // global
           R2 = R2;
           R1 = GHC.MVar.readMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnkZ: // global
           I64[Sp - 8] = block_cnkU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unl3; else goto cnkV;
       unl3: // global
           call _cnkU(R1) args: 0, res: 0, upd: 0;
       cnkV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnkU() //  [R1]
         { info_tbl: [(cnkU,
                       label: block_cnkU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnkU: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readMVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.232476611 UTC

[section ""data" . GHC.MVar.readMVar_closure" {
     GHC.MVar.readMVar_closure:
         const GHC.MVar.readMVar_info;
 },
 GHC.MVar.readMVar_entry() //  [R2]
         { info_tbl: [(cnli,
                       label: GHC.MVar.readMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnli: // global
           R2 = R2;
           call GHC.MVar.readMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.235815396 UTC

[section ""data" . GHC.MVar.putMVar1_closure" {
     GHC.MVar.putMVar1_closure:
         const GHC.MVar.putMVar1_info;
 },
 GHC.MVar.putMVar1_entry() //  [R2, R3]
         { info_tbl: [(cnlw,
                       label: GHC.MVar.putMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnlw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnlA; else goto cnlB;
       cnlA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.putMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cnlB: // global
           I64[Sp - 16] = block_cnlt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto unlF; else goto cnlu;
       unlF: // global
           call _cnlt(R1) args: 0, res: 0, upd: 0;
       cnlu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnlt() //  [R1]
         { info_tbl: [(cnlt,
                       label: block_cnlt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnlt: // global
           _snhb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cnlz_info;
           R2 = _snhb::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnlz() //  []
         { info_tbl: [(cnlz,
                       label: block_cnlz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnlz: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.242698793 UTC

[section ""data" . GHC.MVar.putMVar_closure" {
     GHC.MVar.putMVar_closure:
         const GHC.MVar.putMVar_info;
 },
 GHC.MVar.putMVar_entry() //  [R2, R3]
         { info_tbl: [(cnm0,
                       label: GHC.MVar.putMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnm0: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.putMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.246082456 UTC

[section ""data" . GHC.MVar.newMVar1_closure" {
     GHC.MVar.newMVar1_closure:
         const GHC.MVar.newMVar1_info;
 },
 GHC.MVar.newMVar1_entry() //  [R2]
         { info_tbl: [(cnmg,
                       label: GHC.MVar.newMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnmg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnmh; else goto cnmi;
       cnmh: // global
           R2 = R2;
           R1 = GHC.MVar.newMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnmi: // global
           I64[Sp - 16] = block_cnmb_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cnmb() //  [R1]
         { info_tbl: [(cnmb,
                       label: block_cnmb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnmb: // global
           I64[Sp] = block_cnmd_info;
           R2 = P64[Sp + 8];
           _snhk::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _snhk::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnmd() //  []
         { info_tbl: [(cnmd,
                       label: block_cnmd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnmd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnmm; else goto cnml;
       cnmm: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cnml: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.252715309 UTC

[section ""data" . GHC.MVar.newMVar_closure" {
     GHC.MVar.newMVar_closure:
         const GHC.MVar.newMVar_info;
 },
 GHC.MVar.newMVar_entry() //  [R2]
         { info_tbl: [(cnmH,
                       label: GHC.MVar.newMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnmH: // global
           R2 = R2;
           call GHC.MVar.newMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.256775689 UTC

[section ""data" . GHC.MVar.tryTakeMVar1_closure" {
     GHC.MVar.tryTakeMVar1_closure:
         const GHC.MVar.tryTakeMVar1_info;
 },
 GHC.MVar.tryTakeMVar1_entry() //  [R2]
         { info_tbl: [(cnmV,
                       label: GHC.MVar.tryTakeMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnmV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cnmW; else goto cnmX;
       cnmW: // global
           R2 = R2;
           R1 = GHC.MVar.tryTakeMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnmX: // global
           I64[Sp - 8] = block_cnmS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unnf; else goto cnmT;
       unnf: // global
           call _cnmS(R1) args: 0, res: 0, upd: 0;
       cnmT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnmS() //  [R1]
         { info_tbl: [(cnmS,
                       label: block_cnmS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnmS: // global
           I64[Sp] = block_cnn0_info;
           R1 = P64[R1 + 7];
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnn0() //  [R1, R2]
         { info_tbl: [(cnn0,
                       label: block_cnn0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnn0: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cnn2() args: 0, res: 0, upd: 0;
     }
 },
 _cnn2() //  []
         { info_tbl: [(cnn2,
                       label: block_cnn2_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnn2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnn7; else goto cnn6;
       cnn7: // global
           HpAlloc = 16;
           I64[Sp] = block_cnn2_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cnn6: // global
           if (I64[Sp + 16] == 0) goto cnnd; else goto cnnc;
       cnnd: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cnnc: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.266203344 UTC

[section ""data" . GHC.MVar.tryTakeMVar_closure" {
     GHC.MVar.tryTakeMVar_closure:
         const GHC.MVar.tryTakeMVar_info;
 },
 GHC.MVar.tryTakeMVar_entry() //  [R2]
         { info_tbl: [(cnnI,
                       label: GHC.MVar.tryTakeMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnnI: // global
           R2 = R2;
           call GHC.MVar.tryTakeMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.269757175 UTC

[section ""data" . GHC.MVar.tryPutMVar1_closure" {
     GHC.MVar.tryPutMVar1_closure:
         const GHC.MVar.tryPutMVar1_info;
 },
 GHC.MVar.tryPutMVar1_entry() //  [R2, R3]
         { info_tbl: [(cnnW,
                       label: GHC.MVar.tryPutMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnnW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnnX; else goto cnnY;
       cnnX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.tryPutMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cnnY: // global
           I64[Sp - 16] = block_cnnT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uno9; else goto cnnU;
       uno9: // global
           call _cnnT(R1) args: 0, res: 0, upd: 0;
       cnnU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnnT() //  [R1]
         { info_tbl: [(cnnT,
                       label: block_cnnT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnnT: // global
           _snhy::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cno1_info;
           R2 = _snhy::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cno1() //  [R1]
         { info_tbl: [(cno1,
                       label: block_cno1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cno1: // global
           if (R1 == 0) goto cno8; else goto cno7;
       cno8: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cno7: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.27664487 UTC

[section ""data" . GHC.MVar.tryPutMVar_closure" {
     GHC.MVar.tryPutMVar_closure:
         const GHC.MVar.tryPutMVar_info;
 },
 GHC.MVar.tryPutMVar_entry() //  [R2, R3]
         { info_tbl: [(cnow,
                       label: GHC.MVar.tryPutMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnow: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.tryPutMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.280808882 UTC

[section ""data" . GHC.MVar.tryReadMVar1_closure" {
     GHC.MVar.tryReadMVar1_closure:
         const GHC.MVar.tryReadMVar1_info;
 },
 GHC.MVar.tryReadMVar1_entry() //  [R2]
         { info_tbl: [(cnoK,
                       label: GHC.MVar.tryReadMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnoK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cnoL; else goto cnoM;
       cnoL: // global
           R2 = R2;
           R1 = GHC.MVar.tryReadMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnoM: // global
           I64[Sp - 8] = block_cnoH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unp4; else goto cnoI;
       unp4: // global
           call _cnoH(R1) args: 0, res: 0, upd: 0;
       cnoI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnoH() //  [R1]
         { info_tbl: [(cnoH,
                       label: block_cnoH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnoH: // global
           I64[Sp] = block_cnoP_info;
           R1 = P64[R1 + 7];
           call stg_tryReadMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnoP() //  [R1, R2]
         { info_tbl: [(cnoP,
                       label: block_cnoP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnoP: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cnoR() args: 0, res: 0, upd: 0;
     }
 },
 _cnoR() //  []
         { info_tbl: [(cnoR,
                       label: block_cnoR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnoR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnoW; else goto cnoV;
       cnoW: // global
           HpAlloc = 16;
           I64[Sp] = block_cnoR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cnoV: // global
           if (I64[Sp + 16] == 0) goto cnp2; else goto cnp1;
       cnp2: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cnp1: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.290175007 UTC

[section ""data" . GHC.MVar.tryReadMVar_closure" {
     GHC.MVar.tryReadMVar_closure:
         const GHC.MVar.tryReadMVar_info;
 },
 GHC.MVar.tryReadMVar_entry() //  [R2]
         { info_tbl: [(cnpx,
                       label: GHC.MVar.tryReadMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnpx: // global
           R2 = R2;
           call GHC.MVar.tryReadMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.293691272 UTC

[section ""data" . GHC.MVar.isEmptyMVar1_closure" {
     GHC.MVar.isEmptyMVar1_closure:
         const GHC.MVar.isEmptyMVar1_info;
 },
 sat_snhY_entry() //  [R1]
         { info_tbl: [(cnpX,
                       label: sat_snhY_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnpX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnpY; else goto cnpZ;
       cnpY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cnpZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto cnpW; else goto cnpV;
       cnpW: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cnpV: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.MVar.isEmptyMVar1_entry() //  [R2]
         { info_tbl: [(cnq0,
                       label: GHC.MVar.isEmptyMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnq0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cnq1; else goto cnq2;
       cnq1: // global
           R2 = R2;
           R1 = GHC.MVar.isEmptyMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnq2: // global
           I64[Sp - 8] = block_cnpI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unq7; else goto cnpJ;
       unq7: // global
           call _cnpI(R1) args: 0, res: 0, upd: 0;
       cnpJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnpI() //  [R1]
         { info_tbl: [(cnpI,
                       label: block_cnpI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnpI: // global
           I64[Sp] = block_cnpN_info;
           R1 = P64[R1 + 7];
           call stg_isEmptyMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnpN() //  [R1]
         { info_tbl: [(cnpN,
                       label: block_cnpN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnpN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cnq6; else goto cnq5;
       cnq6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cnq5: // global
           I64[Hp - 16] = sat_snhY_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.303171124 UTC

[section ""data" . GHC.MVar.isEmptyMVar_closure" {
     GHC.MVar.isEmptyMVar_closure:
         const GHC.MVar.isEmptyMVar_info;
 },
 GHC.MVar.isEmptyMVar_entry() //  [R2]
         { info_tbl: [(cnqB,
                       label: GHC.MVar.isEmptyMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnqB: // global
           R2 = R2;
           call GHC.MVar.isEmptyMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.306648395 UTC

[section ""data" . GHC.MVar.addMVarFinalizer1_closure" {
     GHC.MVar.addMVarFinalizer1_closure:
         const GHC.MVar.addMVarFinalizer1_info;
 },
 GHC.MVar.addMVarFinalizer1_entry() //  [R2, R3]
         { info_tbl: [(cnqP,
                       label: GHC.MVar.addMVarFinalizer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnqP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnqT; else goto cnqU;
       cnqT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.addMVarFinalizer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cnqU: // global
           I64[Sp - 16] = block_cnqM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto unqY; else goto cnqN;
       unqY: // global
           call _cnqM(R1) args: 0, res: 0, upd: 0;
       cnqN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnqM() //  [R1]
         { info_tbl: [(cnqM,
                       label: block_cnqM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnqM: // global
           _sni0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cnqS_info;
           R3 = _sni0::P64;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cnqS() //  []
         { info_tbl: [(cnqS,
                       label: block_cnqS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnqS: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.313544154 UTC

[section ""data" . GHC.MVar.addMVarFinalizer_closure" {
     GHC.MVar.addMVarFinalizer_closure:
         const GHC.MVar.addMVarFinalizer_info;
 },
 GHC.MVar.addMVarFinalizer_entry() //  [R2, R3]
         { info_tbl: [(cnrk,
                       label: GHC.MVar.addMVarFinalizer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnrk: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.addMVarFinalizer1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.316715317 UTC

[section ""cstring" . GHC.MVar.$trModule4_bytes" {
     GHC.MVar.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.318341418 UTC

[section ""data" . GHC.MVar.$trModule3_closure" {
     GHC.MVar.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.319960499 UTC

[section ""cstring" . GHC.MVar.$trModule2_bytes" {
     GHC.MVar.$trModule2_bytes:
         I8[] [71,72,67,46,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.322079175 UTC

[section ""data" . GHC.MVar.$trModule1_closure" {
     GHC.MVar.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.323670847 UTC

[section ""data" . GHC.MVar.$trModule_closure" {
     GHC.MVar.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.MVar.$trModule3_closure+1;
         const GHC.MVar.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.32540299 UTC

[section ""data" . $krep_rmUX_closure" {
     $krep_rmUX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRealWorld_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.327063153 UTC

[section ""data" . $krep1_rmUY_closure" {
     $krep1_rmUY_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.328704164 UTC

[section ""data" . $krep2_rmUZ_closure" {
     $krep2_rmUZ_closure:
         const :_con_info;
         const $krep1_rmUY_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.330361048 UTC

[section ""data" . $krep3_rmV0_closure" {
     $krep3_rmV0_closure:
         const :_con_info;
         const $krep_rmUX_closure+1;
         const $krep2_rmUZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.331925603 UTC

[section ""data" . $krep4_rmV1_closure" {
     $krep4_rmV1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcMVar#_closure;
         const $krep3_rmV0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.33396757 UTC

[section ""cstring" . GHC.MVar.$tcMVar2_bytes" {
     GHC.MVar.$tcMVar2_bytes:
         I8[] [77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.335474745 UTC

[section ""data" . GHC.MVar.$tcMVar1_closure" {
     GHC.MVar.$tcMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$tcMVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.337068545 UTC

[section ""data" . GHC.MVar.$tcMVar_closure" {
     GHC.MVar.$tcMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.MVar.$trModule_closure+1;
         const GHC.MVar.$tcMVar1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 4036113818353836845;
         const 5005913288165264115;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.33885128 UTC

[section ""data" . $krep5_rmV2_closure" {
     $krep5_rmV2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure+1;
         const $krep2_rmUZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.340509366 UTC

[section ""data" . GHC.MVar.$tc'MVar1_closure" {
     GHC.MVar.$tc'MVar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rmV1_closure+1;
         const $krep5_rmV2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.342890885 UTC

[section ""cstring" . GHC.MVar.$tc'MVar3_bytes" {
     GHC.MVar.$tc'MVar3_bytes:
         I8[] [39,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.344499873 UTC

[section ""data" . GHC.MVar.$tc'MVar2_closure" {
     GHC.MVar.$tc'MVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$tc'MVar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.346642692 UTC

[section ""data" . GHC.MVar.$tc'MVar_closure" {
     GHC.MVar.$tc'MVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.MVar.$trModule_closure+1;
         const GHC.MVar.$tc'MVar2_closure+1;
         const GHC.MVar.$tc'MVar1_closure+4;
         const 1422225975627779673;
         const 4396512866399833428;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.348653552 UTC

[section ""data" . GHC.MVar.MVar_closure" {
     GHC.MVar.MVar_closure:
         const GHC.MVar.MVar_info;
 },
 GHC.MVar.MVar_entry() //  [R2]
         { info_tbl: [(cnrO,
                       label: GHC.MVar.MVar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnrO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnrS; else goto cnrR;
       cnrS: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.MVar.MVar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnrR: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.352331191 UTC

[GHC.MVar.MVar_con_entry() //  [R1]
         { info_tbl: [(cnrZ,
                       label: GHC.MVar.MVar_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,77,86,97,114,46,77,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cnrZ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:01.355949894 UTC

[section ""relreadonly" . Sns6_srt" { Sns6_srt:
 }]

