
==================== Output Cmm ====================
2018-03-16 15:56:02.309130235 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:56:02.310758526 UTC

[section ""data" . GHC.Real.$p1Fractional_closure" {
     GHC.Real.$p1Fractional_closure:
         const GHC.Real.$p1Fractional_info;
 },
 GHC.Real.$p1Fractional_entry() //  [R2]
         { info_tbl: [(c1jEB,
                       label: GHC.Real.$p1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jEB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jEC; else goto c1jED;
       c1jEC: // global
           R2 = R2;
           R1 = GHC.Real.$p1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jED: // global
           I64[Sp - 8] = block_c1jEy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jEH; else goto c1jEz;
       u1jEH: // global
           call _c1jEy(R1) args: 0, res: 0, upd: 0;
       c1jEz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jEy() //  [R1]
         { info_tbl: [(c1jEy,
                       label: block_c1jEy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jEy: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.31194721 UTC

[section ""data" . GHC.Real./_closure" {
     GHC.Real./_closure:
         const GHC.Real./_info;
 },
 GHC.Real./_entry() //  [R2]
         { info_tbl: [(c1jEP,
                       label: GHC.Real./_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jEP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jEQ; else goto c1jER;
       c1jEQ: // global
           R2 = R2;
           R1 = GHC.Real./_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jER: // global
           I64[Sp - 8] = block_c1jEM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jEV; else goto c1jEN;
       u1jEV: // global
           call _c1jEM(R1) args: 0, res: 0, upd: 0;
       c1jEN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jEM() //  [R1]
         { info_tbl: [(c1jEM,
                       label: block_c1jEM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jEM: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.313086023 UTC

[section ""data" . GHC.Real.recip_closure" {
     GHC.Real.recip_closure:
         const GHC.Real.recip_info;
 },
 GHC.Real.recip_entry() //  [R2]
         { info_tbl: [(c1jF3,
                       label: GHC.Real.recip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jF3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jF4; else goto c1jF5;
       c1jF4: // global
           R2 = R2;
           R1 = GHC.Real.recip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jF5: // global
           I64[Sp - 8] = block_c1jF0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jF9; else goto c1jF1;
       u1jF9: // global
           call _c1jF0(R1) args: 0, res: 0, upd: 0;
       c1jF1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jF0() //  [R1]
         { info_tbl: [(c1jF0,
                       label: block_c1jF0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jF0: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.31438128 UTC

[section ""data" . GHC.Real.fromRational_closure" {
     GHC.Real.fromRational_closure:
         const GHC.Real.fromRational_info;
 },
 GHC.Real.fromRational_entry() //  [R2]
         { info_tbl: [(c1jFh,
                       label: GHC.Real.fromRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jFh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jFi; else goto c1jFj;
       c1jFi: // global
           R2 = R2;
           R1 = GHC.Real.fromRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jFj: // global
           I64[Sp - 8] = block_c1jFe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jFn; else goto c1jFf;
       u1jFn: // global
           call _c1jFe(R1) args: 0, res: 0, upd: 0;
       c1jFf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jFe() //  [R1]
         { info_tbl: [(c1jFe,
                       label: block_c1jFe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jFe: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.315479803 UTC

[section ""data" . GHC.Real.$p1Integral_closure" {
     GHC.Real.$p1Integral_closure:
         const GHC.Real.$p1Integral_info;
 },
 GHC.Real.$p1Integral_entry() //  [R2]
         { info_tbl: [(c1jFv,
                       label: GHC.Real.$p1Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jFv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jFw; else goto c1jFx;
       c1jFw: // global
           R2 = R2;
           R1 = GHC.Real.$p1Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jFx: // global
           I64[Sp - 8] = block_c1jFs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jFB; else goto c1jFt;
       u1jFB: // global
           call _c1jFs(R1) args: 0, res: 0, upd: 0;
       c1jFt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jFs() //  [R1]
         { info_tbl: [(c1jFs,
                       label: block_c1jFs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jFs: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.316663066 UTC

[section ""data" . GHC.Real.$p2Integral_closure" {
     GHC.Real.$p2Integral_closure:
         const GHC.Real.$p2Integral_info;
 },
 GHC.Real.$p2Integral_entry() //  [R2]
         { info_tbl: [(c1jFJ,
                       label: GHC.Real.$p2Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jFJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jFK; else goto c1jFL;
       c1jFK: // global
           R2 = R2;
           R1 = GHC.Real.$p2Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jFL: // global
           I64[Sp - 8] = block_c1jFG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jFP; else goto c1jFH;
       u1jFP: // global
           call _c1jFG(R1) args: 0, res: 0, upd: 0;
       c1jFH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jFG() //  [R1]
         { info_tbl: [(c1jFG,
                       label: block_c1jFG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jFG: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.317949363 UTC

[section ""data" . GHC.Real.quot_closure" {
     GHC.Real.quot_closure:
         const GHC.Real.quot_info;
 },
 GHC.Real.quot_entry() //  [R2]
         { info_tbl: [(c1jFX,
                       label: GHC.Real.quot_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jFX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jFY; else goto c1jFZ;
       c1jFY: // global
           R2 = R2;
           R1 = GHC.Real.quot_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jFZ: // global
           I64[Sp - 8] = block_c1jFU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jG3; else goto c1jFV;
       u1jG3: // global
           call _c1jFU(R1) args: 0, res: 0, upd: 0;
       c1jFV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jFU() //  [R1]
         { info_tbl: [(c1jFU,
                       label: block_c1jFU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jFU: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.319122243 UTC

[section ""data" . GHC.Real.rem_closure" {
     GHC.Real.rem_closure:
         const GHC.Real.rem_info;
 },
 GHC.Real.rem_entry() //  [R2]
         { info_tbl: [(c1jGb,
                       label: GHC.Real.rem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jGb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jGc; else goto c1jGd;
       c1jGc: // global
           R2 = R2;
           R1 = GHC.Real.rem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jGd: // global
           I64[Sp - 8] = block_c1jG8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jGh; else goto c1jG9;
       u1jGh: // global
           call _c1jG8(R1) args: 0, res: 0, upd: 0;
       c1jG9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jG8() //  [R1]
         { info_tbl: [(c1jG8,
                       label: block_c1jG8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jG8: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.320248604 UTC

[section ""data" . GHC.Real.div_closure" {
     GHC.Real.div_closure:
         const GHC.Real.div_info;
 },
 GHC.Real.div_entry() //  [R2]
         { info_tbl: [(c1jGp,
                       label: GHC.Real.div_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jGp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jGq; else goto c1jGr;
       c1jGq: // global
           R2 = R2;
           R1 = GHC.Real.div_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jGr: // global
           I64[Sp - 8] = block_c1jGm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jGv; else goto c1jGn;
       u1jGv: // global
           call _c1jGm(R1) args: 0, res: 0, upd: 0;
       c1jGn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jGm() //  [R1]
         { info_tbl: [(c1jGm,
                       label: block_c1jGm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jGm: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.321465443 UTC

[section ""data" . GHC.Real.mod_closure" {
     GHC.Real.mod_closure:
         const GHC.Real.mod_info;
 },
 GHC.Real.mod_entry() //  [R2]
         { info_tbl: [(c1jGD,
                       label: GHC.Real.mod_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jGD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jGE; else goto c1jGF;
       c1jGE: // global
           R2 = R2;
           R1 = GHC.Real.mod_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jGF: // global
           I64[Sp - 8] = block_c1jGA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jGJ; else goto c1jGB;
       u1jGJ: // global
           call _c1jGA(R1) args: 0, res: 0, upd: 0;
       c1jGB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jGA() //  [R1]
         { info_tbl: [(c1jGA,
                       label: block_c1jGA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jGA: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.322641283 UTC

[section ""data" . GHC.Real.quotRem_closure" {
     GHC.Real.quotRem_closure:
         const GHC.Real.quotRem_info;
 },
 GHC.Real.quotRem_entry() //  [R2]
         { info_tbl: [(c1jGR,
                       label: GHC.Real.quotRem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jGR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jGS; else goto c1jGT;
       c1jGS: // global
           R2 = R2;
           R1 = GHC.Real.quotRem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jGT: // global
           I64[Sp - 8] = block_c1jGO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jGX; else goto c1jGP;
       u1jGX: // global
           call _c1jGO(R1) args: 0, res: 0, upd: 0;
       c1jGP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jGO() //  [R1]
         { info_tbl: [(c1jGO,
                       label: block_c1jGO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jGO: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.323770774 UTC

[section ""data" . GHC.Real.divMod_closure" {
     GHC.Real.divMod_closure:
         const GHC.Real.divMod_info;
 },
 GHC.Real.divMod_entry() //  [R2]
         { info_tbl: [(c1jH5,
                       label: GHC.Real.divMod_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jH5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jH6; else goto c1jH7;
       c1jH6: // global
           R2 = R2;
           R1 = GHC.Real.divMod_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jH7: // global
           I64[Sp - 8] = block_c1jH2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jHb; else goto c1jH3;
       u1jHb: // global
           call _c1jH2(R1) args: 0, res: 0, upd: 0;
       c1jH3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jH2() //  [R1]
         { info_tbl: [(c1jH2,
                       label: block_c1jH2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jH2: // global
           R1 = P64[R1 + 63];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.324923414 UTC

[section ""data" . GHC.Real.toInteger_closure" {
     GHC.Real.toInteger_closure:
         const GHC.Real.toInteger_info;
 },
 GHC.Real.toInteger_entry() //  [R2]
         { info_tbl: [(c1jHj,
                       label: GHC.Real.toInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jHj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jHk; else goto c1jHl;
       c1jHk: // global
           R2 = R2;
           R1 = GHC.Real.toInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jHl: // global
           I64[Sp - 8] = block_c1jHg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jHp; else goto c1jHh;
       u1jHp: // global
           call _c1jHg(R1) args: 0, res: 0, upd: 0;
       c1jHh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jHg() //  [R1]
         { info_tbl: [(c1jHg,
                       label: block_c1jHg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jHg: // global
           R1 = P64[R1 + 71];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.326217145 UTC

[section ""data" . GHC.Real.$p1Real_closure" {
     GHC.Real.$p1Real_closure:
         const GHC.Real.$p1Real_info;
 },
 GHC.Real.$p1Real_entry() //  [R2]
         { info_tbl: [(c1jHx,
                       label: GHC.Real.$p1Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jHx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jHy; else goto c1jHz;
       c1jHy: // global
           R2 = R2;
           R1 = GHC.Real.$p1Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jHz: // global
           I64[Sp - 8] = block_c1jHu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jHD; else goto c1jHv;
       u1jHD: // global
           call _c1jHu(R1) args: 0, res: 0, upd: 0;
       c1jHv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jHu() //  [R1]
         { info_tbl: [(c1jHu,
                       label: block_c1jHu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jHu: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.327380571 UTC

[section ""data" . GHC.Real.$p2Real_closure" {
     GHC.Real.$p2Real_closure:
         const GHC.Real.$p2Real_info;
 },
 GHC.Real.$p2Real_entry() //  [R2]
         { info_tbl: [(c1jHL,
                       label: GHC.Real.$p2Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jHL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jHM; else goto c1jHN;
       c1jHM: // global
           R2 = R2;
           R1 = GHC.Real.$p2Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jHN: // global
           I64[Sp - 8] = block_c1jHI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jHR; else goto c1jHJ;
       u1jHR: // global
           call _c1jHI(R1) args: 0, res: 0, upd: 0;
       c1jHJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jHI() //  [R1]
         { info_tbl: [(c1jHI,
                       label: block_c1jHI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jHI: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.328568049 UTC

[section ""data" . GHC.Real.toRational_closure" {
     GHC.Real.toRational_closure:
         const GHC.Real.toRational_info;
 },
 GHC.Real.toRational_entry() //  [R2]
         { info_tbl: [(c1jHZ,
                       label: GHC.Real.toRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jHZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jI0; else goto c1jI1;
       c1jI0: // global
           R2 = R2;
           R1 = GHC.Real.toRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jI1: // global
           I64[Sp - 8] = block_c1jHW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jI5; else goto c1jHX;
       u1jI5: // global
           call _c1jHW(R1) args: 0, res: 0, upd: 0;
       c1jHX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jHW() //  [R1]
         { info_tbl: [(c1jHW,
                       label: block_c1jHW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jHW: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.329878482 UTC

[section ""data" . GHC.Real.$p1RealFrac_closure" {
     GHC.Real.$p1RealFrac_closure:
         const GHC.Real.$p1RealFrac_info;
 },
 GHC.Real.$p1RealFrac_entry() //  [R2]
         { info_tbl: [(c1jId,
                       label: GHC.Real.$p1RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jId: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jIe; else goto c1jIf;
       c1jIe: // global
           R2 = R2;
           R1 = GHC.Real.$p1RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jIf: // global
           I64[Sp - 8] = block_c1jIa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jIj; else goto c1jIb;
       u1jIj: // global
           call _c1jIa(R1) args: 0, res: 0, upd: 0;
       c1jIb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jIa() //  [R1]
         { info_tbl: [(c1jIa,
                       label: block_c1jIa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jIa: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.343462144 UTC

[section ""data" . GHC.Real.$p2RealFrac_closure" {
     GHC.Real.$p2RealFrac_closure:
         const GHC.Real.$p2RealFrac_info;
 },
 GHC.Real.$p2RealFrac_entry() //  [R2]
         { info_tbl: [(c1jIr,
                       label: GHC.Real.$p2RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jIr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jIs; else goto c1jIt;
       c1jIs: // global
           R2 = R2;
           R1 = GHC.Real.$p2RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jIt: // global
           I64[Sp - 8] = block_c1jIo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jIx; else goto c1jIp;
       u1jIx: // global
           call _c1jIo(R1) args: 0, res: 0, upd: 0;
       c1jIp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jIo() //  [R1]
         { info_tbl: [(c1jIo,
                       label: block_c1jIo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jIo: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.344649675 UTC

[section ""data" . GHC.Real.properFraction_closure" {
     GHC.Real.properFraction_closure:
         const GHC.Real.properFraction_info;
 },
 GHC.Real.properFraction_entry() //  [R2]
         { info_tbl: [(c1jIF,
                       label: GHC.Real.properFraction_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jIF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jIG; else goto c1jIH;
       c1jIG: // global
           R2 = R2;
           R1 = GHC.Real.properFraction_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jIH: // global
           I64[Sp - 8] = block_c1jIC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jIL; else goto c1jID;
       u1jIL: // global
           call _c1jIC(R1) args: 0, res: 0, upd: 0;
       c1jID: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jIC() //  [R1]
         { info_tbl: [(c1jIC,
                       label: block_c1jIC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jIC: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.345900759 UTC

[section ""data" . GHC.Real.truncate_closure" {
     GHC.Real.truncate_closure:
         const GHC.Real.truncate_info;
 },
 GHC.Real.truncate_entry() //  [R2]
         { info_tbl: [(c1jIT,
                       label: GHC.Real.truncate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jIT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jIU; else goto c1jIV;
       c1jIU: // global
           R2 = R2;
           R1 = GHC.Real.truncate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jIV: // global
           I64[Sp - 8] = block_c1jIQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jIZ; else goto c1jIR;
       u1jIZ: // global
           call _c1jIQ(R1) args: 0, res: 0, upd: 0;
       c1jIR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jIQ() //  [R1]
         { info_tbl: [(c1jIQ,
                       label: block_c1jIQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jIQ: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.347050417 UTC

[section ""data" . GHC.Real.round_closure" {
     GHC.Real.round_closure:
         const GHC.Real.round_info;
 },
 GHC.Real.round_entry() //  [R2]
         { info_tbl: [(c1jJ7,
                       label: GHC.Real.round_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jJ7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jJ8; else goto c1jJ9;
       c1jJ8: // global
           R2 = R2;
           R1 = GHC.Real.round_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jJ9: // global
           I64[Sp - 8] = block_c1jJ4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jJd; else goto c1jJ5;
       u1jJd: // global
           call _c1jJ4(R1) args: 0, res: 0, upd: 0;
       c1jJ5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jJ4() //  [R1]
         { info_tbl: [(c1jJ4,
                       label: block_c1jJ4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jJ4: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.348188645 UTC

[section ""data" . GHC.Real.ceiling_closure" {
     GHC.Real.ceiling_closure:
         const GHC.Real.ceiling_info;
 },
 GHC.Real.ceiling_entry() //  [R2]
         { info_tbl: [(c1jJl,
                       label: GHC.Real.ceiling_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jJl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jJm; else goto c1jJn;
       c1jJm: // global
           R2 = R2;
           R1 = GHC.Real.ceiling_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jJn: // global
           I64[Sp - 8] = block_c1jJi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jJr; else goto c1jJj;
       u1jJr: // global
           call _c1jJi(R1) args: 0, res: 0, upd: 0;
       c1jJj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jJi() //  [R1]
         { info_tbl: [(c1jJi,
                       label: block_c1jJi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jJi: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.349443693 UTC

[section ""data" . GHC.Real.floor_closure" {
     GHC.Real.floor_closure:
         const GHC.Real.floor_info;
 },
 GHC.Real.floor_entry() //  [R2]
         { info_tbl: [(c1jJz,
                       label: GHC.Real.floor_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jJz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jJA; else goto c1jJB;
       c1jJA: // global
           R2 = R2;
           R1 = GHC.Real.floor_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jJB: // global
           I64[Sp - 8] = block_c1jJw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jJF; else goto c1jJx;
       u1jJF: // global
           call _c1jJw(R1) args: 0, res: 0, upd: 0;
       c1jJx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jJw() //  [R1]
         { info_tbl: [(c1jJw,
                       label: block_c1jJw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jJw: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.350717841 UTC

[section ""data" . GHC.Real.$W:%_closure" {
     GHC.Real.$W:%_closure:
         const GHC.Real.$W:%_info;
 },
 GHC.Real.$W:%_entry() //  [R2, R3]
         { info_tbl: [(c1jJP,
                       label: GHC.Real.$W:%_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jJP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1jJQ; else goto c1jJR;
       c1jJQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$W:%_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jJR: // global
           I64[Sp - 16] = block_c1jJK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jJK() //  [R1]
         { info_tbl: [(c1jJK,
                       label: block_c1jJK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jJK: // global
           I64[Sp] = block_c1jJM_info;
           _s1j7b::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1j7b::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jJM() //  [R1]
         { info_tbl: [(c1jJM,
                       label: block_c1jJM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jJM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1jJV; else goto c1jJU;
       c1jJV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1jJU: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.352319351 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$c<_closure" {
     GHC.Real.$fOrdRatio_$s$c<_closure:
         const GHC.Real.$fOrdRatio_$s$c<_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$c<_entry() //  [R2, R3]
         { info_tbl: [(c1jK3,
                       label: GHC.Real.$fOrdRatio_$s$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jK3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1jKk; else goto c1jKl;
       c1jKk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jKl: // global
           I64[Sp - 16] = block_c1jK0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1jKv; else goto c1jK1;
       u1jKv: // global
           call _c1jK0(R1) args: 0, res: 0, upd: 0;
       c1jK1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jK0() //  [R1]
         { info_tbl: [(c1jK0,
                       label: block_c1jK0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jK0: // global
           I64[Sp - 8] = block_c1jK6_info;
           _s1j7g::P64 = P64[R1 + 7];
           _s1j7h::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j7h::P64;
           P64[Sp + 8] = _s1j7g::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jKu; else goto c1jK7;
       u1jKu: // global
           call _c1jK6(R1) args: 0, res: 0, upd: 0;
       c1jK7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jK6() //  [R1]
         { info_tbl: [(c1jK6,
                       label: block_c1jK6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jK6: // global
           I64[Sp] = block_c1jKb_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp + 8] = P64[R1 + 15];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jKb() //  [R1]
         { info_tbl: [(c1jKb,
                       label: block_c1jKb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jKb: // global
           _s1j7k::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1jKf_info;
           R3 = _s1j7k::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jKf() //  [R1]
         { info_tbl: [(c1jKf,
                       label: block_c1jKf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jKf: // global
           _s1j7m::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1jKj_info;
           R3 = _s1j7m::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jKj() //  [R1]
         { info_tbl: [(c1jKj,
                       label: block_c1jKj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jKj: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.354812986 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c<=_closure" {
     GHC.Real.$fEnumRatio_$s$c<=_closure:
         const GHC.Real.$fEnumRatio_$s$c<=_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c<=_entry() //  [R2, R3]
         { info_tbl: [(c1jKE,
                       label: GHC.Real.$fEnumRatio_$s$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jKE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1jKV; else goto c1jKW;
       c1jKV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jKW: // global
           I64[Sp - 16] = block_c1jKB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1jL6; else goto c1jKC;
       u1jL6: // global
           call _c1jKB(R1) args: 0, res: 0, upd: 0;
       c1jKC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jKB() //  [R1]
         { info_tbl: [(c1jKB,
                       label: block_c1jKB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jKB: // global
           I64[Sp - 8] = block_c1jKH_info;
           _s1j7r::P64 = P64[R1 + 7];
           _s1j7s::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j7s::P64;
           P64[Sp + 8] = _s1j7r::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jL5; else goto c1jKI;
       u1jL5: // global
           call _c1jKH(R1) args: 0, res: 0, upd: 0;
       c1jKI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jKH() //  [R1]
         { info_tbl: [(c1jKH,
                       label: block_c1jKH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jKH: // global
           I64[Sp] = block_c1jKM_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp + 8] = P64[R1 + 15];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jKM() //  [R1]
         { info_tbl: [(c1jKM,
                       label: block_c1jKM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jKM: // global
           _s1j7v::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1jKQ_info;
           R3 = _s1j7v::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jKQ() //  [R1]
         { info_tbl: [(c1jKQ,
                       label: block_c1jKQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jKQ: // global
           _s1j7x::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1jKU_info;
           R3 = _s1j7x::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jKU() //  [R1]
         { info_tbl: [(c1jKU,
                       label: block_c1jKU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jKU: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.357009143 UTC

[section ""data" . GHC.Real.$w$s$ccompare_closure" {
     GHC.Real.$w$s$ccompare_closure:
         const GHC.Real.$w$s$ccompare_info;
         const 0;
 },
 GHC.Real.$w$s$ccompare_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1jLd,
                       label: GHC.Real.$w$s$ccompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jLd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1jLe; else goto c1jLf;
       c1jLe: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$ccompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jLf: // global
           I64[Sp - 40] = block_c1jLb_info;
           _s1j7A::P64 = R3;
           R3 = R4;
           _s1j7z::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s1j7z::P64;
           P64[Sp - 24] = _s1j7A::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jLb() //  [R1]
         { info_tbl: [(c1jLb,
                       label: block_c1jLb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jLb: // global
           if (R1 == 1) goto c1jLQ; else goto u1jM1;
       c1jLQ: // global
           I64[Sp] = block_c1jLP_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       u1jM1: // global
           Sp = Sp + 8;
           call _s1j7E() args: 0, res: 0, upd: 0;
     }
 },
 _c1jLP() //  [R1]
         { info_tbl: [(c1jLP,
                       label: block_c1jLP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jLP: // global
           if (R1 == 1) goto c1jM0; else goto u1jM2;
       c1jM0: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1jM2: // global
           Sp = Sp + 8;
           call _s1j7E() args: 0, res: 0, upd: 0;
     }
 },
 _s1j7E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1j7E: // global
           I64[Sp - 8] = block_c1jLo_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jLo() //  [R1]
         { info_tbl: [(c1jLo,
                       label: block_c1jLo_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jLo: // global
           I64[Sp + 24] = block_c1jLs_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jLs() //  [R1]
         { info_tbl: [(c1jLs,
                       label: block_c1jLs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jLs: // global
           _s1j7G::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1jLy_info;
           R3 = _s1j7G::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jLy() //  [R1]
         { info_tbl: [(c1jLy,
                       label: block_c1jLy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jLy: // global
           if (R1 == 1) goto c1jLJ; else goto c1jLF;
       c1jLJ: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1jLF: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.359440304 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$ccompare_closure" {
     GHC.Real.$fEnumRatio_$s$ccompare_closure:
         const GHC.Real.$fEnumRatio_$s$ccompare_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c1jMc,
                       label: GHC.Real.$fEnumRatio_$s$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jMc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1jMg; else goto c1jMh;
       c1jMg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jMh: // global
           I64[Sp - 16] = block_c1jM9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1jMp; else goto c1jMa;
       u1jMp: // global
           call _c1jM9(R1) args: 0, res: 0, upd: 0;
       c1jMa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jM9() //  [R1]
         { info_tbl: [(c1jM9,
                       label: block_c1jM9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jM9: // global
           I64[Sp - 8] = block_c1jMf_info;
           _s1j7N::P64 = P64[R1 + 7];
           _s1j7O::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j7O::P64;
           P64[Sp + 8] = _s1j7N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jMo; else goto c1jMj;
       u1jMo: // global
           call _c1jMf(R1) args: 0, res: 0, upd: 0;
       c1jMj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jMf() //  [R1]
         { info_tbl: [(c1jMf,
                       label: block_c1jMf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jMf: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.361619562 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c>=_closure" {
     GHC.Real.$fEnumRatio_$s$c>=_closure:
         const GHC.Real.$fEnumRatio_$s$c>=_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c>=_entry() //  [R2, R3]
         { info_tbl: [(c1jMx,
                       label: GHC.Real.$fEnumRatio_$s$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jMx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1jMB; else goto c1jMC;
       c1jMB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jMC: // global
           I64[Sp - 16] = block_c1jMu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1jMW; else goto c1jMv;
       u1jMW: // global
           call _c1jMu(R1) args: 0, res: 0, upd: 0;
       c1jMv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jMu() //  [R1]
         { info_tbl: [(c1jMu,
                       label: block_c1jMu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jMu: // global
           I64[Sp - 8] = block_c1jMA_info;
           _s1j7V::P64 = P64[R1 + 7];
           _s1j7W::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j7W::P64;
           P64[Sp + 8] = _s1j7V::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jMV; else goto c1jME;
       u1jMV: // global
           call _c1jMA(R1) args: 0, res: 0, upd: 0;
       c1jME: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jMA() //  [R1]
         { info_tbl: [(c1jMA,
                       label: block_c1jMA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jMA: // global
           _s1j7V::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1jMI_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1j7V::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jMI() //  [R1]
         { info_tbl: [(c1jMI,
                       label: block_c1jMI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jMI: // global
           if (R1 & 7 == 1) goto c1jMT; else goto c1jMP;
       c1jMT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1jMP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.363480377 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$c>_closure" {
     GHC.Real.$fOrdRatio_$s$c>_closure:
         const GHC.Real.$fOrdRatio_$s$c>_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$c>_entry() //  [R2, R3]
         { info_tbl: [(c1jN4,
                       label: GHC.Real.$fOrdRatio_$s$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jN4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1jN8; else goto c1jN9;
       c1jN8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jN9: // global
           I64[Sp - 16] = block_c1jN1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1jNt; else goto c1jN2;
       u1jNt: // global
           call _c1jN1(R1) args: 0, res: 0, upd: 0;
       c1jN2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jN1() //  [R1]
         { info_tbl: [(c1jN1,
                       label: block_c1jN1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jN1: // global
           I64[Sp - 8] = block_c1jN7_info;
           _s1j84::P64 = P64[R1 + 7];
           _s1j85::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j85::P64;
           P64[Sp + 8] = _s1j84::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jNs; else goto c1jNb;
       u1jNs: // global
           call _c1jN7(R1) args: 0, res: 0, upd: 0;
       c1jNb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jN7() //  [R1]
         { info_tbl: [(c1jN7,
                       label: block_c1jN7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jN7: // global
           _s1j84::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1jNf_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1j84::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jNf() //  [R1]
         { info_tbl: [(c1jNf,
                       label: block_c1jNf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jNf: // global
           if (R1 & 7 == 3) goto c1jNq; else goto c1jNm;
       c1jNq: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1jNm: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.365591009 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$cmin_closure" {
     GHC.Real.$fOrdRatio_$s$cmin_closure:
         const GHC.Real.$fOrdRatio_$s$cmin_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$cmin_entry() //  [R2, R3]
         { info_tbl: [(c1jNB,
                       label: GHC.Real.$fOrdRatio_$s$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jNB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1jNO; else goto c1jNP;
       c1jNO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jNP: // global
           I64[Sp - 16] = block_c1jNy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1jO9; else goto c1jNz;
       u1jO9: // global
           call _c1jNy(R1) args: 0, res: 0, upd: 0;
       c1jNz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jNy() //  [R1]
         { info_tbl: [(c1jNy,
                       label: block_c1jNy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jNy: // global
           I64[Sp - 16] = block_c1jNE_info;
           _s1j8c::P64 = R1;
           _s1j8d::P64 = P64[R1 + 7];
           _s1j8e::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s1j8e::P64;
           P64[Sp] = _s1j8d::P64;
           P64[Sp + 8] = _s1j8c::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1jO8; else goto c1jNF;
       u1jO8: // global
           call _c1jNE(R1) args: 0, res: 0, upd: 0;
       c1jNF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jNE() //  [R1]
         { info_tbl: [(c1jNE,
                       label: block_c1jNE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jNE: // global
           I64[Sp - 8] = block_c1jNJ_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jNJ() //  [R1]
         { info_tbl: [(c1jNJ,
                       label: block_c1jNJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jNJ: // global
           _s1j8h::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1jNN_info;
           R3 = _s1j8h::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jNN() //  [R1]
         { info_tbl: [(c1jNN,
                       label: block_c1jNN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jNN: // global
           I64[Sp] = block_c1jNW_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jNW() //  [R1]
         { info_tbl: [(c1jNW,
                       label: block_c1jNW_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jNW: // global
           if (R1 == 1) goto c1jO7; else goto c1jO3;
       c1jO7: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1jO3: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.367831754 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$cmax_closure" {
     GHC.Real.$fOrdRatio_$s$cmax_closure:
         const GHC.Real.$fOrdRatio_$s$cmax_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$cmax_entry() //  [R2, R3]
         { info_tbl: [(c1jOh,
                       label: GHC.Real.$fOrdRatio_$s$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jOh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1jOu; else goto c1jOv;
       c1jOu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jOv: // global
           I64[Sp - 16] = block_c1jOe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1jOP; else goto c1jOf;
       u1jOP: // global
           call _c1jOe(R1) args: 0, res: 0, upd: 0;
       c1jOf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jOe() //  [R1]
         { info_tbl: [(c1jOe,
                       label: block_c1jOe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jOe: // global
           I64[Sp - 16] = block_c1jOk_info;
           _s1j8n::P64 = R1;
           _s1j8o::P64 = P64[R1 + 7];
           _s1j8p::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s1j8p::P64;
           P64[Sp] = _s1j8o::P64;
           P64[Sp + 8] = _s1j8n::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1jOO; else goto c1jOl;
       u1jOO: // global
           call _c1jOk(R1) args: 0, res: 0, upd: 0;
       c1jOl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jOk() //  [R1]
         { info_tbl: [(c1jOk,
                       label: block_c1jOk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jOk: // global
           I64[Sp - 8] = block_c1jOp_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jOp() //  [R1]
         { info_tbl: [(c1jOp,
                       label: block_c1jOp_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jOp: // global
           _s1j8s::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1jOt_info;
           R3 = _s1j8s::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jOt() //  [R1]
         { info_tbl: [(c1jOt,
                       label: block_c1jOt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jOt: // global
           I64[Sp] = block_c1jOC_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jOC() //  [R1]
         { info_tbl: [(c1jOC,
                       label: block_c1jOC_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jOC: // global
           if (R1 == 1) goto c1jON; else goto c1jOJ;
       c1jON: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1jOJ: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.370490163 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cnegate_closure" {
     GHC.Real.$fFractionalRatio_$s$cnegate_closure:
         const GHC.Real.$fFractionalRatio_$s$cnegate_info;
 },
 GHC.Real.$fFractionalRatio_$s$cnegate_entry() //  [R2]
         { info_tbl: [(c1jOX,
                       label: GHC.Real.$fFractionalRatio_$s$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jOX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1jP5; else goto c1jP6;
       c1jP5: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jP6: // global
           I64[Sp - 8] = block_c1jOU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jPb; else goto c1jOV;
       u1jPb: // global
           call _c1jOU(R1) args: 0, res: 0, upd: 0;
       c1jOV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jOU() //  [R1]
         { info_tbl: [(c1jOU,
                       label: block_c1jOU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jOU: // global
           I64[Sp - 8] = block_c1jP0_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jP0() //  [R1]
         { info_tbl: [(c1jP0,
                       label: block_c1jP0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jP0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1jPa; else goto c1jP9;
       c1jPa: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1jP9: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.371992714 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cabs_closure" {
     GHC.Real.$fFractionalRatio_$s$cabs_closure:
         const GHC.Real.$fFractionalRatio_$s$cabs_info;
 },
 GHC.Real.$fFractionalRatio_$s$cabs_entry() //  [R2]
         { info_tbl: [(c1jPj,
                       label: GHC.Real.$fFractionalRatio_$s$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jPj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1jPr; else goto c1jPs;
       c1jPr: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jPs: // global
           I64[Sp - 8] = block_c1jPg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jPx; else goto c1jPh;
       u1jPx: // global
           call _c1jPg(R1) args: 0, res: 0, upd: 0;
       c1jPh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jPg() //  [R1]
         { info_tbl: [(c1jPg,
                       label: block_c1jPg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jPg: // global
           I64[Sp - 8] = block_c1jPm_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jPm() //  [R1]
         { info_tbl: [(c1jPm,
                       label: block_c1jPm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jPm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1jPw; else goto c1jPv;
       c1jPw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1jPv: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.373277694 UTC

[section ""data" . sat_s1j8G_closure" {
     sat_s1j8G_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.373892295 UTC

[section ""data" . sat_s1j8H_closure" {
     sat_s1j8H_closure:
         const :_con_info;
         const sat_s1j8G_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.37466806 UTC

[section ""data" . GHC.Real.$fEnumRatio1_closure" {
     GHC.Real.$fEnumRatio1_closure:
         const GHC.Real.$fEnumRatio1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fEnumRatio1_entry() //  [R1]
         { info_tbl: [(c1jPE,
                       label: GHC.Real.$fEnumRatio1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jPE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1jPF; else goto c1jPG;
       c1jPF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jPG: // global
           (_c1jPB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1jPB::I64 == 0) goto c1jPD; else goto c1jPC;
       c1jPD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1jPC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1jPB::I64;
           R3 = sat_s1j8H_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.376981736 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$csignum_closure" {
     GHC.Real.$fFractionalRatio_$s$csignum_closure:
         const GHC.Real.$fFractionalRatio_$s$csignum_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$csignum_entry() //  [R2]
         { info_tbl: [(c1jPO,
                       label: GHC.Real.$fFractionalRatio_$s$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jPO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jPW; else goto c1jPX;
       c1jPW: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jPX: // global
           I64[Sp - 8] = block_c1jPL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jQ2; else goto c1jPM;
       u1jQ2: // global
           call _c1jPL(R1) args: 0, res: 0, upd: 0;
       c1jPM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jPL() //  [R1]
         { info_tbl: [(c1jPL,
                       label: block_c1jPL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jPL: // global
           I64[Sp] = block_c1jPR_info;
           R2 = P64[R1 + 7];
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jPR() //  [R1]
         { info_tbl: [(c1jPR,
                       label: block_c1jPR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jPR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1jQ1; else goto c1jQ0;
       c1jQ1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1jQ0: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Real.$fEnumRatio1_closure;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.378476644 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cfromInteger_closure" {
     GHC.Real.$fFractionalRatio_$s$cfromInteger_closure:
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$cfromInteger_entry() //  [R2]
         { info_tbl: [(c1jQa,
                       label: GHC.Real.$fFractionalRatio_$s$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jQa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jQe; else goto c1jQf;
       c1jQe: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jQf: // global
           I64[Sp - 8] = block_c1jQ7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jQj; else goto c1jQ8;
       u1jQj: // global
           call _c1jQ7(R1) args: 0, res: 0, upd: 0;
       c1jQ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jQ7() //  [R1]
         { info_tbl: [(c1jQ7,
                       label: block_c1jQ7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jQ7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1jQi; else goto c1jQh;
       c1jQi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1jQh: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Real.$fEnumRatio1_closure;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.379543231 UTC

[section ""data" . GHC.Real.$fRealInteger_closure" {
     GHC.Real.$fRealInteger_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Num.$fNumInteger_closure;
         const GHC.Integer.Type.$fOrdInteger_closure;
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.380348476 UTC

[section ""data" . GHC.Real.$fIntegralInt_$ctoInteger_closure" {
     GHC.Real.$fIntegralInt_$ctoInteger_closure:
         const GHC.Real.$fIntegralInt_$ctoInteger_info;
 },
 GHC.Real.$fIntegralInt_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c1jQr,
                       label: GHC.Real.$fIntegralInt_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jQr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jQs; else goto c1jQt;
       c1jQs: // global
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jQt: // global
           I64[Sp - 8] = block_c1jQo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jQx; else goto c1jQp;
       u1jQx: // global
           call _c1jQo(R1) args: 0, res: 0, upd: 0;
       c1jQp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jQo() //  [R1]
         { info_tbl: [(c1jQo,
                       label: block_c1jQo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jQo: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.381624045 UTC

[section ""data" . GHC.Real.$fEnumRatio_$ctoRational_closure" {
     GHC.Real.$fEnumRatio_$ctoRational_closure:
         const GHC.Real.$fEnumRatio_$ctoRational_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$ctoRational_entry() //  [R2]
         { info_tbl: [(c1jQF,
                       label: GHC.Real.$fEnumRatio_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jQF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jQN; else goto c1jQO;
       c1jQN: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jQO: // global
           I64[Sp - 8] = block_c1jQC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jQT; else goto c1jQD;
       u1jQT: // global
           call _c1jQC(R1) args: 0, res: 0, upd: 0;
       c1jQD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jQC() //  [R1]
         { info_tbl: [(c1jQC,
                       label: block_c1jQC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jQC: // global
           I64[Sp] = block_c1jQI_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jQI() //  [R1]
         { info_tbl: [(c1jQI,
                       label: block_c1jQI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jQI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1jQS; else goto c1jQR;
       c1jQS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1jQR: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Real.$fEnumRatio1_closure;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.382812266 UTC

[section ""data" . GHC.Real.$fRealInt_closure" {
     GHC.Real.$fRealInt_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Num.$fNumInt_closure;
         const GHC.Classes.$fOrdInt_closure;
         const GHC.Real.$fEnumRatio_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.383560789 UTC

[section ""data" . GHC.Real.$fIntegralWord_$ctoInteger_closure" {
     GHC.Real.$fIntegralWord_$ctoInteger_closure:
         const GHC.Real.$fIntegralWord_$ctoInteger_info;
 },
 GHC.Real.$fIntegralWord_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c1jR1,
                       label: GHC.Real.$fIntegralWord_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jR1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1jR2; else goto c1jR3;
       c1jR2: // global
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jR3: // global
           I64[Sp - 8] = block_c1jQY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jR7; else goto c1jQZ;
       u1jR7: // global
           call _c1jQY(R1) args: 0, res: 0, upd: 0;
       c1jQZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jQY() //  [R1]
         { info_tbl: [(c1jQY,
                       label: block_c1jQY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jQY: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.384607265 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$ctoInteger_closure" {
     GHC.Real.$fIntegralInteger_$ctoInteger_closure:
         const GHC.Real.$fIntegralInteger_$ctoInteger_info;
 },
 GHC.Real.$fIntegralInteger_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c1jRc,
                       label: GHC.Real.$fIntegralInteger_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jRc: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.385876635 UTC

[section ""data" . GHC.Real.$fEqRatio_$s$c==_closure" {
     GHC.Real.$fEqRatio_$s$c==_closure:
         const GHC.Real.$fEqRatio_$s$c==_info;
 },
 GHC.Real.$fEqRatio_$s$c==_entry() //  [R2, R3]
         { info_tbl: [(c1jRm,
                       label: GHC.Real.$fEqRatio_$s$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jRm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1jRq; else goto c1jRr;
       c1jRq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_$s$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jRr: // global
           I64[Sp - 16] = block_c1jRj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1jRP; else goto c1jRk;
       u1jRP: // global
           call _c1jRj(R1) args: 0, res: 0, upd: 0;
       c1jRk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jRj() //  [R1]
         { info_tbl: [(c1jRj,
                       label: block_c1jRj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jRj: // global
           I64[Sp - 8] = block_c1jRp_info;
           _s1j93::P64 = P64[R1 + 7];
           _s1j94::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j94::P64;
           P64[Sp + 8] = _s1j93::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jRO; else goto c1jRt;
       u1jRO: // global
           call _c1jRp(R1) args: 0, res: 0, upd: 0;
       c1jRt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jRp() //  [R1]
         { info_tbl: [(c1jRp,
                       label: block_c1jRp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jRp: // global
           I64[Sp] = block_c1jRx_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 15];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jRx() //  [R1]
         { info_tbl: [(c1jRx,
                       label: block_c1jRx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jRx: // global
           if (R1 == 1) goto c1jRJ; else goto c1jRE;
       c1jRJ: // global
           _s1j97::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1jRH_info;
           R3 = _s1j97::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       c1jRE: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1jRH() //  [R1]
         { info_tbl: [(c1jRH,
                       label: block_c1jRH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jRH: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.38789493 UTC

[section ""data" . GHC.Real.$fEqRatio_$c==_closure" {
     GHC.Real.$fEqRatio_$c==_closure:
         const GHC.Real.$fEqRatio_$c==_info;
 },
 GHC.Real.$fEqRatio_$c==_entry() //  [R2, R3, R4]
         { info_tbl: [(c1jRX,
                       label: GHC.Real.$fEqRatio_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jRX: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1jS1; else goto c1jS2;
       c1jS1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jS2: // global
           I64[Sp - 24] = block_c1jRU_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1jSm; else goto c1jRV;
       u1jSm: // global
           call _c1jRU(R1) args: 0, res: 0, upd: 0;
       c1jRV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jRU() //  [R1]
         { info_tbl: [(c1jRU,
                       label: block_c1jRU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jRU: // global
           I64[Sp - 8] = block_c1jS0_info;
           _s1j9e::P64 = P64[R1 + 7];
           _s1j9f::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1j9f::P64;
           P64[Sp + 16] = _s1j9e::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jSl; else goto c1jS4;
       u1jSl: // global
           call _c1jS0(R1) args: 0, res: 0, upd: 0;
       c1jS4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jS0() //  [R1]
         { info_tbl: [(c1jS0,
                       label: block_c1jS0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jS0: // global
           I64[Sp] = block_c1jS8_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1jS8() //  [R1]
         { info_tbl: [(c1jS8,
                       label: block_c1jS8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jS8: // global
           if (R1 & 7 == 1) goto c1jSf; else goto c1jSj;
       c1jSf: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1jSj: // global
           R2 = P64[Sp + 16];
           _s1j9f::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1j9f::P64;
           Sp = Sp + 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.390058195 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$c/=_closure" {
     GHC.Real.$fOrdRatio_$s$c/=_closure:
         const GHC.Real.$fOrdRatio_$s$c/=_info;
 },
 GHC.Real.$fOrdRatio_$s$c/=_entry() //  [R2, R3]
         { info_tbl: [(c1jSu,
                       label: GHC.Real.$fOrdRatio_$s$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jSu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1jSy; else goto c1jSz;
       c1jSy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jSz: // global
           I64[Sp - 16] = block_c1jSr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1jT5; else goto c1jSs;
       u1jT5: // global
           call _c1jSr(R1) args: 0, res: 0, upd: 0;
       c1jSs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jSr() //  [R1]
         { info_tbl: [(c1jSr,
                       label: block_c1jSr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jSr: // global
           I64[Sp - 8] = block_c1jSx_info;
           _s1j9n::P64 = P64[R1 + 7];
           _s1j9o::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j9o::P64;
           P64[Sp + 8] = _s1j9n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jT4; else goto c1jSB;
       u1jT4: // global
           call _c1jSx(R1) args: 0, res: 0, upd: 0;
       c1jSB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jSx() //  [R1]
         { info_tbl: [(c1jSx,
                       label: block_c1jSx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jSx: // global
           I64[Sp] = block_c1jSF_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 15];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jSF() //  [R1]
         { info_tbl: [(c1jSF,
                       label: block_c1jSF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jSF: // global
           if (R1 == 1) goto c1jSR; else goto u1jT2;
       c1jSR: // global
           _s1j9r::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1jSP_info;
           R3 = _s1j9r::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       u1jT2: // global
           Sp = Sp + 24;
           call _c1jSX() args: 0, res: 0, upd: 0;
     }
 },
 _c1jSP() //  [R1]
         { info_tbl: [(c1jSP,
                       label: block_c1jSP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jSP: // global
           if (R1 == 1) goto c1jT1; else goto u1jT3;
       c1jT1: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1jT3: // global
           Sp = Sp + 8;
           call _c1jSX() args: 0, res: 0, upd: 0;
     }
 },
 _c1jSX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jSX: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.392323279 UTC

[section ""data" . GHC.Real.$fEqRatio_$c/=_closure" {
     GHC.Real.$fEqRatio_$c/=_closure:
         const GHC.Real.$fEqRatio_$c/=_info;
 },
 GHC.Real.$fEqRatio_$c/=_entry() //  [R2, R3, R4]
         { info_tbl: [(c1jTf,
                       label: GHC.Real.$fEqRatio_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jTf: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1jTj; else goto c1jTk;
       c1jTj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jTk: // global
           I64[Sp - 24] = block_c1jTc_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1jTS; else goto c1jTd;
       u1jTS: // global
           call _c1jTc(R1) args: 0, res: 0, upd: 0;
       c1jTd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jTc() //  [R1]
         { info_tbl: [(c1jTc,
                       label: block_c1jTc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jTc: // global
           I64[Sp - 8] = block_c1jTi_info;
           _s1j9y::P64 = P64[R1 + 7];
           _s1j9z::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1j9z::P64;
           P64[Sp + 16] = _s1j9y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1jTR; else goto c1jTm;
       u1jTR: // global
           call _c1jTi(R1) args: 0, res: 0, upd: 0;
       c1jTm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1jTi() //  [R1]
         { info_tbl: [(c1jTi,
                       label: block_c1jTi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jTi: // global
           I64[Sp] = block_c1jTq_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1jTq() //  [R1]
         { info_tbl: [(c1jTq,
                       label: block_c1jTq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jTq: // global
           if (R1 & 7 == 1) goto u1jTP; else goto c1jTC;
       u1jTP: // global
           Sp = Sp + 32;
           call _c1jTI() args: 0, res: 0, upd: 0;
       c1jTC: // global
           _s1j9C::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1jTA_info;
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = _s1j9C::P64;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1jTA() //  [R1]
         { info_tbl: [(c1jTA,
                       label: block_c1jTA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jTA: // global
           if (R1 & 7 == 1) goto u1jTQ; else goto c1jTM;
       u1jTQ: // global
           Sp = Sp + 8;
           call _c1jTI() args: 0, res: 0, upd: 0;
       c1jTM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1jTI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jTI: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.394199369 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$fEqRatio_closure" {
     GHC.Real.$fOrdRatio_$s$fEqRatio_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Real.$fEqRatio_$s$c==_closure+2;
         const GHC.Real.$fOrdRatio_$s$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.395198244 UTC

[section ""data" . GHC.Real.$fEqRatio_closure" {
     GHC.Real.$fEqRatio_closure:
         const GHC.Real.$fEqRatio_info;
 },
 sat_s1j9H_entry() //  [R1, R2, R3]
         { info_tbl: [(c1jU4,
                       label: sat_s1j9H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jU4: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fEqRatio_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1j9G_entry() //  [R1, R2, R3]
         { info_tbl: [(c1jUc,
                       label: sat_s1j9G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jUc: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fEqRatio_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEqRatio_entry() //  [R2]
         { info_tbl: [(c1jUg,
                       label: GHC.Real.$fEqRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jUg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1jUk; else goto c1jUj;
       c1jUk: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jUj: // global
           I64[Hp - 48] = sat_s1j9H_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s1j9G_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.396420689 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$fOrdRatio_closure" {
     GHC.Real.$fOrdRatio_$s$fOrdRatio_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Real.$fOrdRatio_$s$fEqRatio_closure+1;
         const GHC.Real.$fEnumRatio_$s$ccompare_closure+2;
         const GHC.Real.$fOrdRatio_$s$c<_closure+2;
         const GHC.Real.$fEnumRatio_$s$c<=_closure+2;
         const GHC.Real.$fOrdRatio_$s$c>_closure+2;
         const GHC.Real.$fEnumRatio_$s$c>=_closure+2;
         const GHC.Real.$fOrdRatio_$s$cmax_closure+2;
         const GHC.Real.$fOrdRatio_$s$cmin_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.397589385 UTC

[section ""data" . GHC.Real.$fOrdRatio_$cp1Ord_closure" {
     GHC.Real.$fOrdRatio_$cp1Ord_closure:
         const GHC.Real.$fOrdRatio_$cp1Ord_info;
 },
 sat_s1j9L_entry() //  [R1]
         { info_tbl: [(c1jUv,
                       label: sat_s1j9L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jUv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1jUz; else goto c1jUA;
       c1jUz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jUA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1jUt_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1jUt() //  [R1]
         { info_tbl: [(c1jUt,
                       label: block_c1jUt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jUt: // global
           I64[Sp] = block_c1jUy_info;
           R2 = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1jUy() //  [R1]
         { info_tbl: [(c1jUy,
                       label: block_c1jUy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jUy: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fOrdRatio_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c1jUG,
                       label: GHC.Real.$fOrdRatio_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jUG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1jUK; else goto c1jUJ;
       c1jUK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1jUJ: // global
           I64[Hp - 16] = sat_s1j9L_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Real.$fEqRatio_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.399001509 UTC

[section ""data" . GHC.Real.even1_closure" {
     GHC.Real.even1_closure:
         const GHC.Real.even1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.even1_entry() //  [R1]
         { info_tbl: [(c1jUR,
                       label: GHC.Real.even1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jUR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1jUS; else goto c1jUT;
       c1jUS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jUT: // global
           (_c1jUO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1jUO::I64 == 0) goto c1jUQ; else goto c1jUP;
       c1jUQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1jUP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1jUO::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.400997044 UTC

[section ""data" . GHC.Real.$dmfloor_closure" {
     GHC.Real.$dmfloor_closure:
         const GHC.Real.$dmfloor_info;
         const 0;
 },
 ds_s1j9P_entry() //  [R1]
         { info_tbl: [(c1jV2,
                       label: ds_s1j9P_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jV2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1jV3; else goto c1jV4;
       c1jV3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jV4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.properFraction_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1j9X_entry() //  [R1]
         { info_tbl: [(c1jVf,
                       label: sat_s1j9X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jVf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1jVg; else goto c1jVh;
       c1jVg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jVh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1jVd_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1jVd() //  [R1]
         { info_tbl: [(c1jVd,
                       label: block_c1jVd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jVd: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1ja8_entry() //  [R1]
         { info_tbl: [(c1jVH,
                       label: sat_s1ja8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jVH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1jVI; else goto c1jVJ;
       c1jVI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jVJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(c1jVK,
                       label: GHC.Real.$dmfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jVK: // global
           _s1j9O::P64 = R4;
           _s1j9N::P64 = R3;
           _s1j9M::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1jVL; else goto c1jVM;
       c1jVM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1jVO; else goto c1jVN;
       c1jVO: // global
           HpAlloc = 40;
           goto c1jVL;
       c1jVL: // global
           R4 = _s1j9O::P64;
           R3 = _s1j9N::P64;
           R2 = _s1j9M::P64;
           R1 = GHC.Real.$dmfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jVN: // global
           I64[Hp - 32] = ds_s1j9P_info;
           P64[Hp - 16] = _s1j9M::P64;
           P64[Hp - 8] = _s1j9N::P64;
           P64[Hp] = _s1j9O::P64;
           I64[Sp - 24] = block_c1jV5_info;
           R2 = _s1j9M::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s1j9N::P64;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jV5() //  [R1]
         { info_tbl: [(c1jV5,
                       label: block_c1jV5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jV5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1jVR; else goto c1jVQ;
       c1jVR: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1jVQ: // global
           I64[Hp - 40] = sat_s1j9X_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = block_c1jVm_info;
           R2 = R1;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jVm() //  [R1]
         { info_tbl: [(c1jVm,
                       label: block_c1jVm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jVm: // global
           _c1jV9::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1jVq_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _c1jV9::P64;
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1jVq() //  [R1]
         { info_tbl: [(c1jVq,
                       label: block_c1jVq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jVq: // global
           if (R1 & 7 == 1) goto c1jVX; else goto c1jW4;
       c1jVX: // global
           I64[Sp + 16] = block_c1jVU_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u1jWb; else goto c1jVY;
       u1jWb: // global
           call _c1jVU(R1) args: 0, res: 0, upd: 0;
       c1jVY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1jW4: // global
           I64[Sp] = block_c1jVv_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jVU() //  [R1]
         { info_tbl: [(c1jVU,
                       label: block_c1jVU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jVU: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1jVv() //  [R1]
         { info_tbl: [(c1jVv,
                       label: block_c1jVv_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jVv: // global
           I64[Sp] = block_c1jVz_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jVz() //  [R1]
         { info_tbl: [(c1jVz,
                       label: block_c1jVz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jVz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1jW8; else goto c1jW7;
       c1jW8: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1jW7: // global
           I64[Hp - 40] = sat_s1ja8_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = Hp - 40;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.405750031 UTC

[section ""data" . GHC.Real.$dmceiling_closure" {
     GHC.Real.$dmceiling_closure:
         const GHC.Real.$dmceiling_info;
         const 0;
 },
 ds_s1jac_entry() //  [R1]
         { info_tbl: [(c1jWk,
                       label: ds_s1jac_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jWk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1jWl; else goto c1jWm;
       c1jWl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jWm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.properFraction_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jak_entry() //  [R1]
         { info_tbl: [(c1jWx,
                       label: sat_s1jak_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jWx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1jWy; else goto c1jWz;
       c1jWy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jWz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1jWv_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1jWv() //  [R1]
         { info_tbl: [(c1jWv,
                       label: block_c1jWv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jWv: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jav_entry() //  [R1]
         { info_tbl: [(c1jWZ,
                       label: sat_s1jav_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jWZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1jX0; else goto c1jX1;
       c1jX0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jX1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(c1jX2,
                       label: GHC.Real.$dmceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jX2: // global
           _s1jab::P64 = R4;
           _s1jaa::P64 = R3;
           _s1ja9::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1jX3; else goto c1jX4;
       c1jX4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1jX6; else goto c1jX5;
       c1jX6: // global
           HpAlloc = 40;
           goto c1jX3;
       c1jX3: // global
           R4 = _s1jab::P64;
           R3 = _s1jaa::P64;
           R2 = _s1ja9::P64;
           R1 = GHC.Real.$dmceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jX5: // global
           I64[Hp - 32] = ds_s1jac_info;
           P64[Hp - 16] = _s1ja9::P64;
           P64[Hp - 8] = _s1jaa::P64;
           P64[Hp] = _s1jab::P64;
           I64[Sp - 24] = block_c1jWn_info;
           R2 = _s1ja9::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s1jaa::P64;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jWn() //  [R1]
         { info_tbl: [(c1jWn,
                       label: block_c1jWn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jWn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1jX9; else goto c1jX8;
       c1jX9: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1jX8: // global
           I64[Hp - 40] = sat_s1jak_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = block_c1jWE_info;
           R2 = R1;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jWE() //  [R1]
         { info_tbl: [(c1jWE,
                       label: block_c1jWE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jWE: // global
           _c1jWr::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1jWI_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _c1jWr::P64;
           Sp = Sp - 8;
           call GHC.Classes.>_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1jWI() //  [R1]
         { info_tbl: [(c1jWI,
                       label: block_c1jWI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jWI: // global
           if (R1 & 7 == 1) goto c1jXf; else goto c1jXm;
       c1jXf: // global
           I64[Sp + 16] = block_c1jXc_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u1jXt; else goto c1jXg;
       u1jXt: // global
           call _c1jXc(R1) args: 0, res: 0, upd: 0;
       c1jXg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1jXm: // global
           I64[Sp] = block_c1jWN_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jXc() //  [R1]
         { info_tbl: [(c1jXc,
                       label: block_c1jXc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jXc: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1jWN() //  [R1]
         { info_tbl: [(c1jWN,
                       label: block_c1jWN_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jWN: // global
           I64[Sp] = block_c1jWR_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jWR() //  [R1]
         { info_tbl: [(c1jWR,
                       label: block_c1jWR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jWR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1jXq; else goto c1jXp;
       c1jXq: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1jXp: // global
           I64[Hp - 40] = sat_s1jav_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = Hp - 40;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.409088739 UTC

[section ""data" . GHC.Real.$dmtruncate_closure" {
     GHC.Real.$dmtruncate_closure:
         const GHC.Real.$dmtruncate_info;
 },
 GHC.Real.$dmtruncate_entry() //  [R2, R3, R4]
         { info_tbl: [(c1jXA,
                       label: GHC.Real.$dmtruncate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jXA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1jXB; else goto c1jXC;
       c1jXB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmtruncate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jXC: // global
           I64[Sp - 8] = block_c1jXy_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.properFraction_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1jXy() //  [R1]
         { info_tbl: [(c1jXy,
                       label: block_c1jXy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jXy: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.411886097 UTC

[section ""data" . GHC.Real.$dmrecip_closure" {
     GHC.Real.$dmrecip_closure:
         const GHC.Real.$dmrecip_info;
         const 0;
 },
 sat_s1jaF_entry() //  [R1]
         { info_tbl: [(c1jXQ,
                       label: sat_s1jaF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jXQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1jXR; else goto c1jXS;
       c1jXR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jXS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1jXO_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1jXO() //  [R1]
         { info_tbl: [(c1jXO,
                       label: block_c1jXO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jXO: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmrecip_entry() //  [R2, R3]
         { info_tbl: [(c1jXW,
                       label: GHC.Real.$dmrecip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jXW: // global
           _s1jaD::P64 = R3;
           _s1jaC::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1jXX; else goto c1jXY;
       c1jXY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1jY0; else goto c1jXZ;
       c1jY0: // global
           HpAlloc = 24;
           goto c1jXX;
       c1jXX: // global
           R3 = _s1jaD::P64;
           R2 = _s1jaC::P64;
           R1 = GHC.Real.$dmrecip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jXZ: // global
           I64[Hp - 16] = sat_s1jaF_info;
           P64[Hp] = _s1jaC::P64;
           R2 = _s1jaC::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s1jaD::P64;
           Sp = Sp - 24;
           call GHC.Real./_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.413720692 UTC

[section ""data" . GHC.Real.$dm/_closure" {
     GHC.Real.$dm/_closure:
         const GHC.Real.$dm/_info;
 },
 sat_s1jaK_entry() //  [R1]
         { info_tbl: [(c1jY9,
                       label: sat_s1jaK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jY9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1jYa; else goto c1jYb;
       c1jYa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jYb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.recip_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dm/_entry() //  [R2, R3, R4]
         { info_tbl: [(c1jYe,
                       label: GHC.Real.$dm/_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jYe: // global
           _s1jaI::P64 = R4;
           _s1jaH::P64 = R3;
           _s1jaG::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1jYf; else goto c1jYg;
       c1jYg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1jYi; else goto c1jYh;
       c1jYi: // global
           HpAlloc = 32;
           goto c1jYf;
       c1jYf: // global
           R4 = _s1jaI::P64;
           R3 = _s1jaH::P64;
           R2 = _s1jaG::P64;
           R1 = GHC.Real.$dm/_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jYh: // global
           I64[Hp - 24] = sat_s1jaK_info;
           P64[Hp - 8] = _s1jaG::P64;
           P64[Hp] = _s1jaI::P64;
           I64[Sp - 24] = block_c1jYc_info;
           R2 = _s1jaG::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s1jaH::P64;
           Sp = Sp - 24;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jYc() //  [R1]
         { info_tbl: [(c1jYc,
                       label: block_c1jYc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jYc: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _c1jY5::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _c1jY5::P64;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.416915898 UTC

[section ""data" . GHC.Real.$dmdivMod_closure" {
     GHC.Real.$dmdivMod_closure:
         const GHC.Real.$dmdivMod_info;
         const 0;
 },
 $dNum_s1jaP_entry() //  [R1]
         { info_tbl: [(c1jYy,
                       label: $dNum_s1jaP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jYy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1jYz; else goto c1jYA;
       c1jYz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jYA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_s1jaQ_entry() //  [R1]
         { info_tbl: [(c1jYH,
                       label: ds_s1jaQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jYH: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1jYL; else goto c1jYM;
       c1jYL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jYM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1jYF_info;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_pp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1jYF() //  [R1]
         { info_tbl: [(c1jYF,
                       label: block_c1jYF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jYF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1jYP; else goto c1jYO;
       c1jYP: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1jYO: // global
           _s1jaS::P64 = P64[R1 + 7];
           _s1jaT::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = _s1jaS::P64;
           P64[Hp] = _s1jaT::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jb2_entry() //  [R1]
         { info_tbl: [(c1jYZ,
                       label: sat_s1jb2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jYZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1jZ0; else goto c1jZ1;
       c1jZ0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jZ1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jb3_entry() //  [R1]
         { info_tbl: [(c1jZ2,
                       label: sat_s1jb3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jZ2: // global
           _s1jb3::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1jZ3; else goto c1jZ4;
       c1jZ4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1jZ6; else goto c1jZ5;
       c1jZ6: // global
           HpAlloc = 32;
           goto c1jZ3;
       c1jZ3: // global
           R1 = _s1jb3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jZ5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jb3::P64;
           _s1jaN::P64 = P64[_s1jb3::P64 + 16];
           _s1jaP::P64 = P64[_s1jb3::P64 + 24];
           I64[Hp - 24] = sat_s1jb2_info;
           P64[Hp - 8] = _s1jaN::P64;
           P64[Hp] = _s1jaP::P64;
           R2 = _s1jaP::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jb1_entry() //  [R1]
         { info_tbl: [(c1jZb,
                       label: sat_s1jb1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jZb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1jZc; else goto c1jZd;
       c1jZc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jZd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jbg_entry() //  [R1]
         { info_tbl: [(c1jZv,
                       label: sat_s1jbg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jZv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1jZw; else goto c1jZx;
       c1jZw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jZx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jbe_entry() //  [R1]
         { info_tbl: [(c1jZG,
                       label: sat_s1jbe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jZG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1jZH; else goto c1jZI;
       c1jZH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jZI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jbf_entry() //  [R1]
         { info_tbl: [(c1jZK,
                       label: sat_s1jbf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jZK: // global
           _s1jbf::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1jZL; else goto c1jZM;
       c1jZM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1jZO; else goto c1jZN;
       c1jZO: // global
           HpAlloc = 48;
           goto c1jZL;
       c1jZL: // global
           R1 = _s1jbf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1jZN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jbf::P64;
           _s1jaP::P64 = P64[_s1jbf::P64 + 16];
           _s1jaQ::P64 = P64[_s1jbf::P64 + 24];
           I64[Hp - 40] = sat_s1jbe_info;
           P64[Hp - 24] = _s1jaP::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1jaQ::P64;
           R2 = _s1jaP::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmdivMod_entry() //  [R2, R3, R4]
         { info_tbl: [(c1jZP,
                       label: GHC.Real.$dmdivMod_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jZP: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1jZQ; else goto c1jZR;
       c1jZQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmdivMod_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1jZR: // global
           I64[Sp - 32] = block_c1jYq_info;
           _s1jaL::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1jaL::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jYq() //  [R1]
         { info_tbl: [(c1jYq,
                       label: block_c1jYq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jYq: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c1jZU; else goto c1jZT;
       c1jZU: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1jZT: // global
           I64[Hp - 144] = $dNum_s1jaP_info;
           P64[Hp - 128] = R1;
           I64[Hp - 120] = ds_s1jaQ_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = P64[Sp + 16];
           _s1jaN::P64 = P64[Sp + 24];
           P64[Hp - 88] = _s1jaN::P64;
           I64[Hp - 80] = stg_sel_2_upd_info;
           _c1jYB::P64 = Hp - 120;
           P64[Hp - 64] = _c1jYB::P64;
           I64[Hp - 56] = sat_s1jb3_info;
           P64[Hp - 40] = _s1jaN::P64;
           _c1jYu::P64 = Hp - 144;
           P64[Hp - 32] = _c1jYu::P64;
           I64[Hp - 24] = sat_s1jb1_info;
           P64[Hp - 8] = _c1jYu::P64;
           _c1jYQ::P64 = Hp - 80;
           P64[Hp] = _c1jYQ::P64;
           I64[Sp - 24] = block_c1jZe_info;
           R2 = R1;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 24;
           P64[Sp] = _c1jYQ::P64;
           P64[Sp + 8] = _c1jYB::P64;
           P64[Sp + 16] = _c1jYu::P64;
           Sp = Sp - 24;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jZe() //  [R1]
         { info_tbl: [(c1jZe,
                       label: block_c1jZe_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jZe: // global
           I64[Sp] = block_c1jZi_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1jZi() //  [R1]
         { info_tbl: [(c1jZi,
                       label: block_c1jZi_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jZi: // global
           _c1jZ7::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1jZm_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _c1jZ7::P64;
           Sp = Sp - 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1jZm() //  [R1]
         { info_tbl: [(c1jZm,
                       label: block_c1jZm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jZm: // global
           _c1jYB::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1k01; else goto c1k08;
       c1k01: // global
           I64[Sp + 32] = block_c1jZY_info;
           R1 = _c1jYB::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u1k0d; else goto c1k02;
       u1k0d: // global
           call _c1jZY(R1) args: 0, res: 0, upd: 0;
       c1k02: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1k08: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1k0b; else goto c1k0a;
       c1k0b: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1k0a: // global
           I64[Hp - 88] = sat_s1jbg_info;
           P64[Hp - 72] = P64[Sp + 32];
           _c1jYu::P64 = P64[Sp + 24];
           P64[Hp - 64] = _c1jYu::P64;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = sat_s1jbf_info;
           P64[Hp - 32] = _c1jYu::P64;
           P64[Hp - 24] = _c1jYB::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1jZY() //  [R1]
         { info_tbl: [(c1jZY,
                       label: block_c1jZY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1jZY: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.422042663 UTC

[section ""data" . GHC.Real.$dmmod_closure" {
     GHC.Real.$dmmod_closure:
         const GHC.Real.$dmmod_info;
 },
 GHC.Real.$dmmod_entry() //  [R2, R3, R4]
         { info_tbl: [(c1k0k,
                       label: GHC.Real.$dmmod_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k0k: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1k0l; else goto c1k0m;
       c1k0l: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmmod_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k0m: // global
           I64[Sp - 8] = block_c1k0i_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.divMod_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1k0i() //  [R1]
         { info_tbl: [(c1k0i,
                       label: block_c1k0i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k0i: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.423265299 UTC

[section ""data" . GHC.Real.$dmdiv_closure" {
     GHC.Real.$dmdiv_closure:
         const GHC.Real.$dmdiv_info;
 },
 GHC.Real.$dmdiv_entry() //  [R2, R3, R4]
         { info_tbl: [(c1k0w,
                       label: GHC.Real.$dmdiv_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k0w: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1k0x; else goto c1k0y;
       c1k0x: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmdiv_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k0y: // global
           I64[Sp - 8] = block_c1k0u_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.divMod_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1k0u() //  [R1]
         { info_tbl: [(c1k0u,
                       label: block_c1k0u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k0u: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.424381364 UTC

[section ""data" . GHC.Real.$dmrem_closure" {
     GHC.Real.$dmrem_closure:
         const GHC.Real.$dmrem_info;
 },
 GHC.Real.$dmrem_entry() //  [R2, R3, R4]
         { info_tbl: [(c1k0I,
                       label: GHC.Real.$dmrem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k0I: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1k0J; else goto c1k0K;
       c1k0J: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmrem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k0K: // global
           I64[Sp - 8] = block_c1k0G_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1k0G() //  [R1]
         { info_tbl: [(c1k0G,
                       label: block_c1k0G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k0G: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.425664275 UTC

[section ""data" . GHC.Real.$dmquot_closure" {
     GHC.Real.$dmquot_closure:
         const GHC.Real.$dmquot_info;
 },
 GHC.Real.$dmquot_entry() //  [R2, R3, R4]
         { info_tbl: [(c1k0U,
                       label: GHC.Real.$dmquot_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k0U: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1k0V; else goto c1k0W;
       c1k0V: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmquot_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k0W: // global
           I64[Sp - 8] = block_c1k0S_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1k0S() //  [R1]
         { info_tbl: [(c1k0S,
                       label: block_c1k0S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k0S: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.42678407 UTC

[section ""data" . GHC.Real.divZeroError_closure" {
     GHC.Real.divZeroError_closure:
         const GHC.Real.divZeroError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.divZeroError_entry() //  [R1]
         { info_tbl: [(c1k16,
                       label: GHC.Real.divZeroError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k16: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1k17; else goto c1k18;
       c1k17: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1k18: // global
           (_c1k13::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1k13::I64 == 0) goto c1k15; else goto c1k14;
       c1k15: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1k14: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1k13::I64;
           R1 = GHC.Exception.divZeroException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.427693388 UTC

[section ""data" . GHC.Real.$fIntegralInt1_closure" {
     GHC.Real.$fIntegralInt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.428749504 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cmod_closure" {
     GHC.Real.$fIntegralInt_$cmod_closure:
         const GHC.Real.$fIntegralInt_$cmod_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c1k1g,
                       label: GHC.Real.$fIntegralInt_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k1g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1k1h; else goto c1k1i;
       c1k1h: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k1i: // global
           I64[Sp - 16] = block_c1k1d_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1k1I; else goto c1k1e;
       u1k1I: // global
           call _c1k1d(R1) args: 0, res: 0, upd: 0;
       c1k1e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1k1d() //  [R1]
         { info_tbl: [(c1k1d,
                       label: block_c1k1d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k1d: // global
           _s1jbJ::I64 = I64[R1 + 7];
           if (_s1jbJ::I64 != (-1)) goto u1k1G; else goto c1k1E;
       u1k1G: // global
           if (_s1jbJ::I64 != 0) goto c1k1z; else goto c1k1F;
       c1k1z: // global
           I64[Sp] = block_c1k1o_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jbJ::I64;
           if (R1 & 7 != 0) goto u1k1H; else goto c1k1p;
       u1k1H: // global
           call _c1k1o(R1) args: 0, res: 0, upd: 0;
       c1k1p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1k1F: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1k1E: // global
           R1 = GHC.Real.$fIntegralInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1k1o() //  [R1]
         { info_tbl: [(c1k1o,
                       label: block_c1k1o_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k1o: // global
           _s1jbJ::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1k1t_info;
           R3 = _s1jbJ::I64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1k1t() //  [R1]
         { info_tbl: [(c1k1t,
                       label: block_c1k1t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k1t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1k1D; else goto c1k1C;
       c1k1D: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1k1C: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.430884432 UTC

[section ""data" . GHC.Real.$fIntegralInt_$crem_closure" {
     GHC.Real.$fIntegralInt_$crem_closure:
         const GHC.Real.$fIntegralInt_$crem_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$crem_entry() //  [R2, R3]
         { info_tbl: [(c1k1Q,
                       label: GHC.Real.$fIntegralInt_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k1Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1k1R; else goto c1k1S;
       c1k1R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k1S: // global
           I64[Sp - 16] = block_c1k1N_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1k2g; else goto c1k1O;
       u1k2g: // global
           call _c1k1N(R1) args: 0, res: 0, upd: 0;
       c1k1O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1k1N() //  [R1]
         { info_tbl: [(c1k1N,
                       label: block_c1k1N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k1N: // global
           _s1jbS::I64 = I64[R1 + 7];
           if (_s1jbS::I64 != (-1)) goto u1k2e; else goto c1k2c;
       u1k2e: // global
           if (_s1jbS::I64 != 0) goto c1k28; else goto c1k2d;
       c1k28: // global
           I64[Sp] = block_c1k1Y_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jbS::I64;
           if (R1 & 7 != 0) goto u1k2f; else goto c1k1Z;
       u1k2f: // global
           call _c1k1Y(R1) args: 0, res: 0, upd: 0;
       c1k1Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1k2d: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1k2c: // global
           R1 = GHC.Real.$fIntegralInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1k1Y() //  [R1]
         { info_tbl: [(c1k1Y,
                       label: block_c1k1Y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k1Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1k2b; else goto c1k2a;
       c1k2b: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1k2a: // global
           _s1jbV::I64 = %MO_S_Rem_W64(I64[R1 + 7], I64[Sp + 8]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1jbV::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.432567878 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cquot_closure" {
     GHC.Real.$fIntegralInteger_$cquot_closure:
         const GHC.Real.$fIntegralInteger_$cquot_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c1k2q,
                       label: GHC.Real.$fIntegralInteger_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k2q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1k2r; else goto c1k2s;
       c1k2r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k2s: // global
           I64[Sp - 24] = block_c1k2l_info;
           _s1jbX::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jbW::P64 = R2;
           R2 = _s1jbX::P64;
           P64[Sp - 16] = _s1jbW::P64;
           P64[Sp - 8] = _s1jbX::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1k2l() //  [R1]
         { info_tbl: [(c1k2l,
                       label: block_c1k2l_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k2l: // global
           if (R1 == 1) goto c1k2p; else goto c1k2o;
       c1k2p: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1k2o: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.434441343 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$crem_closure" {
     GHC.Real.$fIntegralInteger_$crem_closure:
         const GHC.Real.$fIntegralInteger_$crem_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$crem_entry() //  [R2, R3]
         { info_tbl: [(c1k2I,
                       label: GHC.Real.$fIntegralInteger_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k2I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1k2J; else goto c1k2K;
       c1k2J: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k2K: // global
           I64[Sp - 24] = block_c1k2D_info;
           _s1jc0::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jbZ::P64 = R2;
           R2 = _s1jc0::P64;
           P64[Sp - 16] = _s1jbZ::P64;
           P64[Sp - 8] = _s1jc0::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1k2D() //  [R1]
         { info_tbl: [(c1k2D,
                       label: block_c1k2D_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k2D: // global
           if (R1 == 1) goto c1k2H; else goto c1k2G;
       c1k2H: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1k2G: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.435772924 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cdiv_closure" {
     GHC.Real.$fIntegralInteger_$cdiv_closure:
         const GHC.Real.$fIntegralInteger_$cdiv_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c1k30,
                       label: GHC.Real.$fIntegralInteger_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k30: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1k31; else goto c1k32;
       c1k31: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k32: // global
           I64[Sp - 24] = block_c1k2V_info;
           _s1jc3::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jc2::P64 = R2;
           R2 = _s1jc3::P64;
           P64[Sp - 16] = _s1jc2::P64;
           P64[Sp - 8] = _s1jc3::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1k2V() //  [R1]
         { info_tbl: [(c1k2V,
                       label: block_c1k2V_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k2V: // global
           if (R1 == 1) goto c1k2Z; else goto c1k2Y;
       c1k2Z: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1k2Y: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.437123616 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cmod_closure" {
     GHC.Real.$fIntegralInteger_$cmod_closure:
         const GHC.Real.$fIntegralInteger_$cmod_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c1k3i,
                       label: GHC.Real.$fIntegralInteger_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k3i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1k3j; else goto c1k3k;
       c1k3j: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k3k: // global
           I64[Sp - 24] = block_c1k3d_info;
           _s1jc6::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jc5::P64 = R2;
           R2 = _s1jc6::P64;
           P64[Sp - 16] = _s1jc5::P64;
           P64[Sp - 8] = _s1jc6::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1k3d() //  [R1]
         { info_tbl: [(c1k3d,
                       label: block_c1k3d_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k3d: // global
           if (R1 == 1) goto c1k3h; else goto c1k3g;
       c1k3h: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1k3g: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.438695456 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cquotRem_closure" {
     GHC.Real.$fIntegralInteger_$cquotRem_closure:
         const GHC.Real.$fIntegralInteger_$cquotRem_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c1k3A,
                       label: GHC.Real.$fIntegralInteger_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k3A: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1k3B; else goto c1k3C;
       c1k3B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k3C: // global
           I64[Sp - 24] = block_c1k3v_info;
           _s1jc9::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jc8::P64 = R2;
           R2 = _s1jc9::P64;
           P64[Sp - 16] = _s1jc8::P64;
           P64[Sp - 8] = _s1jc9::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1k3v() //  [R1]
         { info_tbl: [(c1k3v,
                       label: block_c1k3v_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k3v: // global
           if (R1 == 1) goto c1k3z; else goto c1k3y;
       c1k3z: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1k3y: // global
           _s1jc9::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1k3F_info;
           R3 = _s1jc9::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1k3F() //  [R1, R2]
         { info_tbl: [(c1k3F,
                       label: block_c1k3F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k3F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1k3L; else goto c1k3K;
       c1k3L: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1k3K: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.440368448 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cdivMod_closure" {
     GHC.Real.$fIntegralInteger_$cdivMod_closure:
         const GHC.Real.$fIntegralInteger_$cdivMod_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c1k3Y,
                       label: GHC.Real.$fIntegralInteger_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k3Y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1k3Z; else goto c1k40;
       c1k3Z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k40: // global
           I64[Sp - 24] = block_c1k3T_info;
           _s1jcf::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jce::P64 = R2;
           R2 = _s1jcf::P64;
           P64[Sp - 16] = _s1jce::P64;
           P64[Sp - 8] = _s1jcf::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1k3T() //  [R1]
         { info_tbl: [(c1k3T,
                       label: block_c1k3T_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k3T: // global
           if (R1 == 1) goto c1k3X; else goto c1k3W;
       c1k3X: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1k3W: // global
           _s1jcf::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1k43_info;
           R3 = _s1jcf::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1k43() //  [R1, R2]
         { info_tbl: [(c1k43,
                       label: block_c1k43_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k43: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1k49; else goto c1k48;
       c1k49: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1k48: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.4418848 UTC

[section ""data" . GHC.Real.$fIntegralInteger_closure" {
     GHC.Real.$fIntegralInteger_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Real.$fRealInteger_closure+1;
         const GHC.Enum.$fEnumInteger_closure;
         const GHC.Real.$fIntegralInteger_$cquot_closure+2;
         const GHC.Real.$fIntegralInteger_$crem_closure+2;
         const GHC.Real.$fIntegralInteger_$cdiv_closure+2;
         const GHC.Real.$fIntegralInteger_$cmod_closure+2;
         const GHC.Real.$fIntegralInteger_$cquotRem_closure+2;
         const GHC.Real.$fIntegralInteger_$cdivMod_closure+2;
         const GHC.Real.$fIntegralInteger_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.442893855 UTC

[section ""data" . GHC.Real.$fIntegralWord_$cquot_closure" {
     GHC.Real.$fIntegralWord_$cquot_closure:
         const GHC.Real.$fIntegralWord_$cquot_info;
         const 0;
 },
 GHC.Real.$fIntegralWord_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c1k4k,
                       label: GHC.Real.$fIntegralWord_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k4k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1k4o; else goto c1k4p;
       c1k4o: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k4p: // global
           I64[Sp - 16] = block_c1k4h_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1k4I; else goto c1k4i;
       u1k4I: // global
           call _c1k4h(R1) args: 0, res: 0, upd: 0;
       c1k4i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1k4h() //  [R1]
         { info_tbl: [(c1k4h,
                       label: block_c1k4h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k4h: // global
           I64[Sp] = block_c1k4n_info;
           _s1jcn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jcn::I64;
           if (R1 & 7 != 0) goto u1k4H; else goto c1k4r;
       u1k4H: // global
           call _c1k4n(R1) args: 0, res: 0, upd: 0;
       c1k4r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1k4n() //  [R1]
         { info_tbl: [(c1k4n,
                       label: block_c1k4n_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k4n: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1k4x; else goto c1k4w;
       c1k4x: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1k4w: // global
           _s1jcq::I64 = I64[R1 + 7];
           if (_s1jcq::I64 != 0) goto c1k4F; else goto c1k4G;
       c1k4F: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] / _s1jcq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1k4G: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.444739007 UTC

[section ""data" . GHC.Real.$fIntegralWord_$crem_closure" {
     GHC.Real.$fIntegralWord_$crem_closure:
         const GHC.Real.$fIntegralWord_$crem_info;
         const 0;
 },
 GHC.Real.$fIntegralWord_$crem_entry() //  [R2, R3]
         { info_tbl: [(c1k4Q,
                       label: GHC.Real.$fIntegralWord_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k4Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1k4U; else goto c1k4V;
       c1k4U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k4V: // global
           I64[Sp - 16] = block_c1k4N_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1k5e; else goto c1k4O;
       u1k5e: // global
           call _c1k4N(R1) args: 0, res: 0, upd: 0;
       c1k4O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1k4N() //  [R1]
         { info_tbl: [(c1k4N,
                       label: block_c1k4N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k4N: // global
           I64[Sp] = block_c1k4T_info;
           _s1jcv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jcv::I64;
           if (R1 & 7 != 0) goto u1k5d; else goto c1k4X;
       u1k5d: // global
           call _c1k4T(R1) args: 0, res: 0, upd: 0;
       c1k4X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1k4T() //  [R1]
         { info_tbl: [(c1k4T,
                       label: block_c1k4T_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k4T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1k53; else goto c1k52;
       c1k53: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1k52: // global
           _s1jcy::I64 = I64[R1 + 7];
           if (_s1jcy::I64 != 0) goto c1k5b; else goto c1k5c;
       c1k5b: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] % _s1jcy::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1k5c: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.4480421 UTC

[section ""data" . GHC.Real.$fIntegralWord_$cquotRem_closure" {
     GHC.Real.$fIntegralWord_$cquotRem_closure:
         const GHC.Real.$fIntegralWord_$cquotRem_info;
         const 0;
 },
 GHC.Real.$fIntegralWord_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c1k5m,
                       label: GHC.Real.$fIntegralWord_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k5m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1k5q; else goto c1k5r;
       c1k5q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k5r: // global
           I64[Sp - 16] = block_c1k5j_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1k5J; else goto c1k5k;
       u1k5J: // global
           call _c1k5j(R1) args: 0, res: 0, upd: 0;
       c1k5k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1k5j() //  [R1]
         { info_tbl: [(c1k5j,
                       label: block_c1k5j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k5j: // global
           I64[Sp] = block_c1k5p_info;
           _s1jcD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jcD::I64;
           if (R1 & 7 != 0) goto u1k5I; else goto c1k5t;
       u1k5I: // global
           call _c1k5p(R1) args: 0, res: 0, upd: 0;
       c1k5t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1k5p() //  [R1]
         { info_tbl: [(c1k5p,
                       label: block_c1k5p_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k5p: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1k5z; else goto c1k5y;
       c1k5z: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1k5y: // global
           _s1jcG::I64 = I64[R1 + 7];
           if (_s1jcG::I64 != 0) goto c1k5G; else goto c1k5H;
       c1k5G: // global
           (_s1jcI::I64, _s1jcJ::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s1jcG::I64);
           I64[Hp - 48] = GHC.Types.W#_con_info;
           I64[Hp - 40] = _s1jcJ::I64;
           I64[Hp - 32] = GHC.Types.W#_con_info;
           I64[Hp - 24] = _s1jcI::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1k5H: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.450400405 UTC

[section ""data" . GHC.Real.$fIntegralWord_$cdivMod_closure" {
     GHC.Real.$fIntegralWord_$cdivMod_closure:
         const GHC.Real.$fIntegralWord_$cdivMod_info;
         const 0;
 },
 sat_s1jcW_entry() //  [R1]
         { info_tbl: [(c1k66,
                       label: sat_s1jcW_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k66: // global
           _s1jcW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1k69; else goto c1k6a;
       c1k6a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1k6c; else goto c1k6b;
       c1k6c: // global
           HpAlloc = 16;
           goto c1k69;
       c1k69: // global
           R1 = _s1jcW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1k6b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jcW::P64;
           _s1jcV::I64 = I64[_s1jcW::P64 + 16] % I64[_s1jcW::P64 + 24];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1jcV::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jcU_entry() //  [R1]
         { info_tbl: [(c1k6j,
                       label: sat_s1jcU_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k6j: // global
           _s1jcU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1k6m; else goto c1k6n;
       c1k6n: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1k6p; else goto c1k6o;
       c1k6p: // global
           HpAlloc = 16;
           goto c1k6m;
       c1k6m: // global
           R1 = _s1jcU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1k6o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jcU::P64;
           _s1jcT::I64 = I64[_s1jcU::P64 + 16] / I64[_s1jcU::P64 + 24];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1jcT::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fIntegralWord_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c1k6q,
                       label: GHC.Real.$fIntegralWord_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k6q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1k6r; else goto c1k6s;
       c1k6r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k6s: // global
           I64[Sp - 16] = block_c1k5O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1k6C; else goto c1k5P;
       u1k6C: // global
           call _c1k5O(R1) args: 0, res: 0, upd: 0;
       c1k5P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1k5O() //  [R1]
         { info_tbl: [(c1k5O,
                       label: block_c1k5O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k5O: // global
           I64[Sp] = block_c1k5T_info;
           _s1jcP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jcP::I64;
           if (R1 & 7 != 0) goto u1k6B; else goto c1k5U;
       u1k6B: // global
           call _c1k5T(R1) args: 0, res: 0, upd: 0;
       c1k5U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1k5T() //  [R1]
         { info_tbl: [(c1k5T,
                       label: block_c1k5T_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k5T: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1k6w; else goto c1k6v;
       c1k6w: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1k6v: // global
           _s1jcS::I64 = I64[R1 + 7];
           if (_s1jcS::I64 != 0) goto c1k6z; else goto c1k6A;
       c1k6z: // global
           I64[Hp - 80] = sat_s1jcW_info;
           _s1jcP::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s1jcP::I64;
           I64[Hp - 56] = _s1jcS::I64;
           I64[Hp - 48] = sat_s1jcU_info;
           I64[Hp - 32] = _s1jcP::I64;
           I64[Hp - 24] = _s1jcS::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1k6A: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.452637775 UTC

[section ""data" . GHC.Real.ratioZeroDenominatorError_closure" {
     GHC.Real.ratioZeroDenominatorError_closure:
         const GHC.Real.ratioZeroDenominatorError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.ratioZeroDenominatorError_entry() //  [R1]
         { info_tbl: [(c1k6J,
                       label: GHC.Real.ratioZeroDenominatorError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k6J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1k6K; else goto c1k6L;
       c1k6K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1k6L: // global
           (_c1k6G::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1k6G::I64 == 0) goto c1k6I; else goto c1k6H;
       c1k6I: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1k6H: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1k6G::I64;
           R1 = GHC.Exception.ratioZeroDenomException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.45427112 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$crecip_closure" {
     GHC.Real.$fFractionalRatio_$s$crecip_closure:
         const GHC.Real.$fFractionalRatio_$s$crecip_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$crecip_entry() //  [R2]
         { info_tbl: [(c1k6T,
                       label: GHC.Real.$fFractionalRatio_$s$crecip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k6T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1k6U; else goto c1k6V;
       c1k6U: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$crecip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1k6V: // global
           I64[Sp - 8] = block_c1k6Q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1k7B; else goto c1k6R;
       u1k7B: // global
           call _c1k6Q(R1) args: 0, res: 0, upd: 0;
       c1k6R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1k6Q() //  [R1]
         { info_tbl: [(c1k6Q,
                       label: block_c1k6Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k6Q: // global
           I64[Sp - 16] = block_c1k6Y_info;
           R3 = GHC.Real.even1_closure;
           _s1jcZ::P64 = P64[R1 + 7];
           R2 = _s1jcZ::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _s1jcZ::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1k6Y() //  [R1]
         { info_tbl: [(c1k6Y,
                       label: block_c1k6Y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k6Y: // global
           if (R1 == 1) goto c1k7A; else goto c1k76;
       c1k7A: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1k76: // global
           I64[Sp] = block_c1k73_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1k73() //  [R1]
         { info_tbl: [(c1k73,
                       label: block_c1k73_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k73: // global
           _s1jd0::P64 = P64[Sp + 8];
           if (R1 == 1) goto c1k7s; else goto c1k7c;
       c1k7s: // global
           I64[Sp + 8] = block_c1k7i_info;
           R2 = _s1jd0::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       c1k7c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1k7f; else goto c1k7e;
       c1k7f: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1k7e: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = _s1jd0::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1k7i() //  [R1]
         { info_tbl: [(c1k7i,
                       label: block_c1k7i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k7i: // global
           I64[Sp] = block_c1k7m_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1k7m() //  [R1]
         { info_tbl: [(c1k7m,
                       label: block_c1k7m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k7m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1k7w; else goto c1k7v;
       c1k7w: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1k7v: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.456280411 UTC

[section ""data" . GHC.Real.overflowError_closure" {
     GHC.Real.overflowError_closure:
         const GHC.Real.overflowError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.overflowError_entry() //  [R1]
         { info_tbl: [(c1k7I,
                       label: GHC.Real.overflowError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k7I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1k7J; else goto c1k7K;
       c1k7J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1k7K: // global
           (_c1k7F::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1k7F::I64 == 0) goto c1k7H; else goto c1k7G;
       c1k7H: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1k7G: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1k7F::I64;
           R1 = GHC.Exception.overflowException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.457177942 UTC

[section ""data" . lvl_r1j38_closure" {
     lvl_r1j38_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Real.$fIntegralInt1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.459283578 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cdivMod_closure" {
     GHC.Real.$fIntegralInt_$cdivMod_closure:
         const GHC.Real.$fIntegralInt_$cdivMod_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c1k7S,
                       label: GHC.Real.$fIntegralInt_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k7S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1k7W; else goto c1k7X;
       c1k7W: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1k7X: // global
           I64[Sp - 16] = block_c1k7P_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kak; else goto c1k7Q;
       u1kak: // global
           call _c1k7P(R1) args: 0, res: 0, upd: 0;
       c1k7Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1k7P() //  [R1]
         { info_tbl: [(c1k7P,
                       label: block_c1k7P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k7P: // global
           I64[Sp] = block_c1k7V_info;
           _s1jd9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jd9::I64;
           if (R1 & 7 != 0) goto u1kaj; else goto c1k7Z;
       u1kaj: // global
           call _c1k7V(R1) args: 0, res: 0, upd: 0;
       c1k7Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1k7V() //  [R1]
         { info_tbl: [(c1k7V,
                       label: block_c1k7V_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1k7V: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1k85; else goto c1k84;
       c1k85: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1k84: // global
           _s1jd9::I64 = I64[Sp + 8];
           _s1jdc::I64 = I64[R1 + 7];
           if (_s1jdc::I64 != (-1)) goto u1kai; else goto c1kag;
       u1kai: // global
           if (_s1jdc::I64 != 0) goto c1k9K; else goto c1kah;
       c1k9K: // global
           if (%MO_S_Le_W64(_s1jd9::I64, 0)) goto c1k8L; else goto c1k9I;
       c1k8L: // global
           if (%MO_S_Ge_W64(_s1jd9::I64, 0)) goto c1k8i; else goto c1k8J;
       c1k8i: // global
           (_s1jdg::I64, _s1jdh::I64) = call MO_S_QuotRem W64(_s1jd9::I64, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdh::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdg::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1k8J: // global
           if (%MO_S_Le_W64(_s1jdc::I64, 0)) goto c1k8r; else goto c1k8I;
       c1k8r: // global
           (_s1jdm::I64, _s1jdn::I64) = call MO_S_QuotRem W64(_s1jd9::I64, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdn::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdm::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1k8I: // global
           (_s1jds::I64, _s1jdt::I64) = call MO_S_QuotRem W64(_s1jd9::I64 + 1, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdt::I64 + _s1jdc::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jds::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1k9I: // global
           if (%MO_S_Ge_W64(_s1jdc::I64, 0)) goto c1k9q; else goto c1k9H;
       c1k9q: // global
           if (%MO_S_Ge_W64(_s1jd9::I64, 0)) goto c1k8X; else goto c1k9o;
       c1k8X: // global
           (_s1jdC::I64, _s1jdD::I64) = call MO_S_QuotRem W64(_s1jd9::I64, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdD::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdC::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1k9o: // global
           if (%MO_S_Le_W64(_s1jdc::I64, 0)) goto c1k96; else goto c1k9n;
       c1k96: // global
           (_s1jdI::I64, _s1jdJ::I64) = call MO_S_QuotRem W64(_s1jd9::I64, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdJ::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdI::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1k9n: // global
           (_s1jdO::I64, _s1jdP::I64) = call MO_S_QuotRem W64(_s1jd9::I64 + 1, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdP::I64 + _s1jdc::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdO::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1k9H: // global
           (_s1jdX::I64, _s1jdY::I64) = call MO_S_QuotRem W64(_s1jd9::I64 - 1, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdY::I64 + _s1jdc::I64 + 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdX::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kah: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1kag: // global
           if (_s1jd9::I64 == (-9223372036854775808)) goto c1kaf; else goto c1kae;
       c1kaf: // global
           Hp = Hp - 56;
           R1 = lvl_r1j38_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kae: // global
           if (%MO_S_Le_W64(_s1jd9::I64, 0)) goto c1k9V; else goto c1kac;
       c1k9V: // global
           (_s1je7::I64, _s1je8::I64) = call MO_S_QuotRem W64(_s1jd9::I64, (-1));
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1je8::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1je7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kac: // global
           (_s1jed::I64, _s1jee::I64) = call MO_S_QuotRem W64(_s1jd9::I64 - 1, (-1));
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jee::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jed::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.463098044 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cquotRem_closure" {
     GHC.Real.$fIntegralInt_$cquotRem_closure:
         const GHC.Real.$fIntegralInt_$cquotRem_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c1kas,
                       label: GHC.Real.$fIntegralInt_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kas: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kaw; else goto c1kax;
       c1kaw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kax: // global
           I64[Sp - 16] = block_c1kap_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kb0; else goto c1kaq;
       u1kb0: // global
           call _c1kap(R1) args: 0, res: 0, upd: 0;
       c1kaq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kap() //  [R1]
         { info_tbl: [(c1kap,
                       label: block_c1kap_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kap: // global
           I64[Sp] = block_c1kav_info;
           _s1jeo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jeo::I64;
           if (R1 & 7 != 0) goto u1kaZ; else goto c1kaz;
       u1kaZ: // global
           call _c1kav(R1) args: 0, res: 0, upd: 0;
       c1kaz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kav() //  [R1]
         { info_tbl: [(c1kav,
                       label: block_c1kav_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kav: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1kaF; else goto c1kaE;
       c1kaF: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kaE: // global
           _s1jeo::I64 = I64[Sp + 8];
           _s1jer::I64 = I64[R1 + 7];
           if (_s1jer::I64 != (-1)) goto u1kaY; else goto c1kaW;
       u1kaY: // global
           if (_s1jer::I64 != 0) goto c1kaM; else goto c1kaX;
       c1kaM: // global
           (_s1jet::I64, _s1jeu::I64) = call MO_S_QuotRem W64(_s1jeo::I64, _s1jer::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jeu::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jet::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kaX: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1kaW: // global
           if (_s1jeo::I64 == (-9223372036854775808)) goto c1kaV; else goto c1kaU;
       c1kaV: // global
           Hp = Hp - 56;
           R1 = lvl_r1j38_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kaU: // global
           (_s1jez::I64, _s1jeA::I64) = call MO_S_QuotRem W64(_s1jeo::I64, (-1));
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jeA::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jez::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.465122863 UTC

[section ""data" . GHC.Real.$w$cdiv_closure" {
     GHC.Real.$w$cdiv_closure:
         const GHC.Real.$w$cdiv_info;
         const 0;
 },
 GHC.Real.$w$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c1kba,
                       label: GHC.Real.$w$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kba: // global
           if (R3 == (-1)) goto c1kb8; else goto u1kbj;
       c1kb8: // global
           if (R2 == (-9223372036854775808)) goto c1kbi; else goto c1kbh;
       c1kbi: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1kbh: // global
           R3 = (-1);
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
       u1kbj: // global
           if (R3 == 0) goto c1kb9; else goto c1kb7;
       c1kb9: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1kb7: // global
           R3 = R3;
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.466477279 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cdiv_closure" {
     GHC.Real.$fIntegralInt_$cdiv_closure:
         const GHC.Real.$fIntegralInt_$cdiv_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c1kbr,
                       label: GHC.Real.$fIntegralInt_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kbr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kbE; else goto c1kbF;
       c1kbE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kbF: // global
           I64[Sp - 16] = block_c1kbo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kbM; else goto c1kbp;
       u1kbM: // global
           call _c1kbo(R1) args: 0, res: 0, upd: 0;
       c1kbp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kbo() //  [R1]
         { info_tbl: [(c1kbo,
                       label: block_c1kbo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kbo: // global
           I64[Sp] = block_c1kbu_info;
           _s1jeN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jeN::I64;
           if (R1 & 7 != 0) goto u1kbL; else goto c1kbv;
       u1kbL: // global
           call _c1kbu(R1) args: 0, res: 0, upd: 0;
       c1kbv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kbu() //  [R1]
         { info_tbl: [(c1kbu,
                       label: block_c1kbu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kbu: // global
           _s1jeN::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1kbz_info;
           R3 = I64[R1 + 7];
           R2 = _s1jeN::I64;
           Sp = Sp + 8;
           call GHC.Real.$w$cdiv_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kbz() //  [R1]
         { info_tbl: [(c1kbz,
                       label: block_c1kbz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kbz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1kbK; else goto c1kbJ;
       c1kbK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1kbJ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.468418009 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cquot_closure" {
     GHC.Real.$fIntegralInt_$cquot_closure:
         const GHC.Real.$fIntegralInt_$cquot_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c1kbU,
                       label: GHC.Real.$fIntegralInt_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kbU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kbY; else goto c1kbZ;
       c1kbY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kbZ: // global
           I64[Sp - 16] = block_c1kbR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kcu; else goto c1kbS;
       u1kcu: // global
           call _c1kbR(R1) args: 0, res: 0, upd: 0;
       c1kbS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kbR() //  [R1]
         { info_tbl: [(c1kbR,
                       label: block_c1kbR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kbR: // global
           I64[Sp] = block_c1kbX_info;
           _s1jeU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jeU::I64;
           if (R1 & 7 != 0) goto u1kct; else goto c1kc1;
       u1kct: // global
           call _c1kbX(R1) args: 0, res: 0, upd: 0;
       c1kc1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kbX() //  [R1]
         { info_tbl: [(c1kbX,
                       label: block_c1kbX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kbX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1kc7; else goto c1kc6;
       c1kc7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kc6: // global
           _s1jeU::I64 = I64[Sp + 8];
           _s1jeX::I64 = I64[R1 + 7];
           if (_s1jeX::I64 != (-1)) goto u1kcs; else goto c1kcq;
       u1kcs: // global
           if (_s1jeX::I64 != 0) goto c1kcf; else goto c1kcr;
       c1kcf: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s1jeU::I64, _s1jeX::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kcr: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1kcq: // global
           if (_s1jeU::I64 == (-9223372036854775808)) goto c1kcp; else goto c1kco;
       c1kcp: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1kco: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s1jeU::I64, (-1));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.470106378 UTC

[section ""data" . GHC.Real.$fIntegralInt_closure" {
     GHC.Real.$fIntegralInt_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Real.$fRealInt_closure+1;
         const GHC.Enum.$fEnumInt_closure;
         const GHC.Real.$fIntegralInt_$cquot_closure+2;
         const GHC.Real.$fIntegralInt_$crem_closure+2;
         const GHC.Real.$fIntegralInt_$cdiv_closure+2;
         const GHC.Real.$fIntegralInt_$cmod_closure+2;
         const GHC.Real.$fIntegralInt_$cquotRem_closure+2;
         const GHC.Real.$fIntegralInt_$cdivMod_closure+2;
         const GHC.Real.$fIntegralInt_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.470759713 UTC

[section ""data" . lvl1_r1j39_closure" {
     lvl1_r1j39_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.471976633 UTC

[section ""data" . lvl2_r1j3a_closure" {
     lvl2_r1j3a_closure:
         const lvl2_r1j3a_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r1j3a_entry() //  [R1]
         { info_tbl: [(c1kcQ,
                       label: lvl2_r1j3a_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kcQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kcR; else goto c1kcS;
       c1kcR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kcS: // global
           (_c1kcN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1kcN::I64 == 0) goto c1kcP; else goto c1kcO;
       c1kcP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1kcO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1kcN::I64;
           R3 = 0;
           R2 = lvl1_r1j39_closure+1;
           Sp = Sp - 16;
           call GHC.Real.$wgcd'_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""data" . GHC.Real.$wgcd'_closure" {
     GHC.Real.$wgcd'_closure:
         const GHC.Real.$wgcd'_info;
         const 0;
 },
 GHC.Real.$wgcd'_entry() //  [R2, R3]
         { info_tbl: [(c1kcX,
                       label: GHC.Real.$wgcd'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kcX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kcY; else goto u1kd4;
       c1kcY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wgcd'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1kd4: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1kcx() args: 0, res: 0, upd: 0;
     }
 },
 _c1kcx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kcx: // global
           _s1jf5::I64 = I64[Sp + 8];
           if (_s1jf5::I64 != (-1)) goto u1kd3; else goto c1kcV;
       u1kd3: // global
           _s1jf3::P64 = P64[Sp];
           if (_s1jf5::I64 != 0) goto c1kcU; else goto c1kcW;
       c1kcU: // global
           I64[Sp] = block_c1kcC_info;
           R1 = _s1jf3::P64;
           I64[Sp + 8] = _s1jf5::I64;
           if (R1 & 7 != 0) goto u1kd6; else goto c1kcD;
       u1kd6: // global
           call _c1kcC(R1) args: 0, res: 0, upd: 0;
       c1kcD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1kcW: // global
           R1 = _s1jf3::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1kcV: // global
           R1 = lvl2_r1j3a_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1kcC() //  [R1]
         { info_tbl: [(c1kcC,
                       label: block_c1kcC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kcC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1kd2; else goto c1kd1;
       c1kd2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kd1: // global
           _s1jf5::I64 = I64[Sp + 8];
           _s1jf8::I64 = %MO_S_Rem_W64(I64[R1 + 7], _s1jf5::I64);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1jf5::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s1jf8::I64;
           call _c1kcx() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.47416097 UTC

[section ""data" . GHC.Real.$fEnumRatio_gcd'_closure" {
     GHC.Real.$fEnumRatio_gcd'_closure:
         const GHC.Real.$fEnumRatio_gcd'_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_gcd'_entry() //  [R2, R3]
         { info_tbl: [(c1kdi,
                       label: GHC.Real.$fEnumRatio_gcd'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kdi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1kdj; else goto u1kdw;
       c1kdj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_gcd'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1kdw: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1kda() args: 0, res: 0, upd: 0;
     }
 },
 _c1kda() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kda: // global
           I64[Sp - 8] = block_c1kdd_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kdd() //  [R1]
         { info_tbl: [(c1kdd,
                       label: block_c1kdd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kdd: // global
           _s1jfa::P64 = P64[Sp + 8];
           if (R1 == 1) goto c1kdh; else goto c1kdg;
       c1kdh: // global
           R1 = _s1jfa::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1kdg: // global
           I64[Sp + 8] = block_c1kdn_info;
           R3 = P64[Sp + 16];
           R2 = _s1jfa::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kdn() //  [R1]
         { info_tbl: [(c1kdn,
                       label: block_c1kdn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kdn: // global
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call _c1kda() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.476792282 UTC

[section ""data" . GHC.Real.gcd_closure" {
     GHC.Real.gcd_closure:
         const GHC.Real.gcd_info;
         const 0;
 },
 lvl8_s1jfi_entry() //  [R1]
         { info_tbl: [(c1kec,
                       label: lvl8_s1jfi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kec: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ked; else goto c1kee;
       c1ked: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kee: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1kea_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kea() //  [R1]
         { info_tbl: [(c1kea,
                       label: block_c1kea_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kea: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dNum_s1jfm_entry() //  [R1]
         { info_tbl: [(c1kek,
                       label: $dNum_s1jfm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kek: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kel; else goto c1kem;
       c1kel: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kem: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jft_entry() //  [R1]
         { info_tbl: [(c1kep,
                       label: sat_s1jft_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kep: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1keq; else goto c1ker;
       c1keq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ker: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jfs_entry() //  [R1]
         { info_tbl: [(c1keu,
                       label: sat_s1jfs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1keu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kev; else goto c1kew;
       c1kev: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kew: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jfr_entry() //  [R1]
         { info_tbl: [(c1keA,
                       label: sat_s1jfr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1keA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1keB; else goto c1keC;
       c1keB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1keC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.rem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.gcd_entry() //  [R2, R3, R4]
         { info_tbl: [(c1keD,
                       label: GHC.Real.gcd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1keD: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1keE; else goto c1keF;
       c1keE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.gcd_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1keF: // global
           I64[Sp - 32] = block_c1kdE_info;
           _s1jfe::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1jfe::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kdE() //  [R1]
         { info_tbl: [(c1kdE,
                       label: block_c1kdE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kdE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1keI; else goto c1keH;
       c1keI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1keH: // global
           I64[Hp - 16] = lvl8_s1jfi_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c1kdK_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kdK() //  [R1]
         { info_tbl: [(c1kdK,
                       label: block_c1kdK_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kdK: // global
           I64[Sp] = block_c1kdO_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kdO() //  [R1]
         { info_tbl: [(c1kdO,
                       label: block_c1kdO_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kdO: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1keM; else goto c1keL;
       c1keM: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1keL: // global
           I64[Hp - 80] = $dNum_s1jfm_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s1jft_info;
           P64[Hp - 40] = P64[Sp + 40];
           _c1kdS::P64 = Hp - 80;
           P64[Hp - 32] = _c1kdS::P64;
           I64[Hp - 24] = sat_s1jfs_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _c1kdS::P64;
           P64[Sp + 8] = Hp - 56;
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _c1ke1() args: 0, res: 0, upd: 0;
     }
 },
 _c1ke1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ke1: // global
           I64[Sp - 8] = block_c1ke3_info;
           R2 = P64[Sp + 32];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp];
           P64[Sp - 16] = P64[Sp + 8];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1ke3() //  [R1]
         { info_tbl: [(c1ke3,
                       label: block_c1ke3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ke3: // global
           _s1jfo::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c1keP; else goto c1keW;
       c1keP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1keS; else goto c1keR;
       c1keS: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1keR: // global
           I64[Hp - 32] = sat_s1jfr_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _s1jfo::P64;
           _s1jfp::P64 = P64[Sp + 8];
           P64[Hp] = _s1jfp::P64;
           _s1jfo::P64 = _s1jfp::P64;
           P64[Sp + 32] = _s1jfo::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _c1ke1() args: 0, res: 0, upd: 0;
       c1keW: // global
           R1 = _s1jfo::P64;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.482078165 UTC

[section ""data" . GHC.Real.$w$sreduce_closure" {
     GHC.Real.$w$sreduce_closure:
         const GHC.Real.$w$sreduce_info;
         const 0;
 },
 section ""relreadonly" . u1kfU_srtd" {
     u1kfU_srtd:
         const S1jKw_srt+160;
         const 33;
         const 5905711105;
 },
 GHC.Real.$w$sreduce_entry() //  [R2, R3]
         { info_tbl: [(c1kfb,
                       label: GHC.Real.$w$sreduce_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kfb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kfc; else goto c1kfd;
       c1kfc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$sreduce_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kfd: // global
           I64[Sp - 24] = block_c1kf6_info;
           _s1jfv::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jfu::P64 = R2;
           R2 = _s1jfv::P64;
           P64[Sp - 16] = _s1jfu::P64;
           P64[Sp - 8] = _s1jfv::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kf6() //  [R1]
         { info_tbl: [(c1kf6,
                       label: block_c1kf6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kf6: // global
           if (R1 == 1) goto c1kfa; else goto c1kf9;
       c1kfa: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1kf9: // global
           I64[Sp] = block_c1kfg_info;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kfg() //  [R1]
         { info_tbl: [(c1kfg,
                       label: block_c1kfg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kfg: // global
           I64[Sp - 8] = block_c1kfk_info;
           R2 = P64[Sp + 8];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kfk() //  [R1]
         { info_tbl: [(c1kfk,
                       label: block_c1kfk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kfk: // global
           _s1jfz::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1kfo_info;
           R3 = _s1jfz::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$fEnumRatio_gcd'_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kfo() //  [R1]
         { info_tbl: [(c1kfo,
                       label: block_c1kfo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kfo: // global
           I64[Sp - 8] = block_c1kfv_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kfv() //  [R1]
         { info_tbl: [(c1kfv,
                       label: block_c1kfv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kfv: // global
           if (R1 == 1) goto c1kfQ; else goto c1kfH;
       c1kfQ: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1kfH: // global
           I64[Sp] = block_c1kfA_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kfA() //  [R1]
         { info_tbl: [(c1kfA,
                       label: block_c1kfA_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kfA: // global
           I64[Sp + 16] = block_c1kfE_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kfE() //  [R1]
         { info_tbl: [(c1kfE,
                       label: block_c1kfE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kfE: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.48434714 UTC

[section ""data" . GHC.Real.reduce_$sreduce_closure" {
     GHC.Real.reduce_$sreduce_closure:
         const GHC.Real.reduce_$sreduce_info;
         const 0;
 },
 GHC.Real.reduce_$sreduce_entry() //  [R2, R3]
         { info_tbl: [(c1kg2,
                       label: GHC.Real.reduce_$sreduce_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kg2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1kg3; else goto c1kg4;
       c1kg3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.reduce_$sreduce_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kg4: // global
           I64[Sp - 8] = block_c1kfZ_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kfZ() //  [R1, R2]
         { info_tbl: [(c1kfZ,
                       label: block_c1kfZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kfZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kg7; else goto c1kg6;
       c1kg7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kg6: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.486074271 UTC

[section ""data" . GHC.Real.$fRealWord_$ctoRational_closure" {
     GHC.Real.$fRealWord_$ctoRational_closure:
         const GHC.Real.$fRealWord_$ctoRational_info;
         const 0;
 },
 section ""relreadonly" . u1kgC_srtd" {
     u1kgC_srtd:
         const S1jKw_srt;
         const 56;
         const 40532396646335489;
 },
 GHC.Real.$fRealWord_$ctoRational_entry() //  [R2]
         { info_tbl: [(c1kgf,
                       label: GHC.Real.$fRealWord_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kgf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1kgt; else goto c1kgu;
       c1kgt: // global
           R2 = R2;
           R1 = GHC.Real.$fRealWord_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kgu: // global
           I64[Sp - 8] = block_c1kgc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kgB; else goto c1kgd;
       u1kgB: // global
           call _c1kgc(R1) args: 0, res: 0, upd: 0;
       c1kgd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kgD_srtd" {
     u1kgD_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627371521;
 },
 _c1kgc() //  [R1]
         { info_tbl: [(c1kgc,
                       label: block_c1kgc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kgc: // global
           I64[Sp] = block_c1kgi_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kgE_srtd" {
     u1kgE_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627371521;
 },
 _c1kgi() //  [R1]
         { info_tbl: [(c1kgi,
                       label: block_c1kgi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kgi: // global
           I64[Sp] = block_c1kgm_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kgF_srtd" {
     u1kgF_srtd:
         const S1jKw_srt+80;
         const 43;
         const 4398046511105;
 },
 _c1kgm() //  [R1]
         { info_tbl: [(c1kgm,
                       label: block_c1kgm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kgm: // global
           I64[Sp] = block_c1kgq_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kgq() //  [R1, R2]
         { info_tbl: [(c1kgq,
                       label: block_c1kgq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kgq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kgA; else goto c1kgz;
       c1kgA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kgz: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.488087844 UTC

[section ""data" . GHC.Real.$fRealWord_closure" {
     GHC.Real.$fRealWord_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Num.$fNumWord_closure;
         const GHC.Classes.$fOrdWord_closure;
         const GHC.Real.$fRealWord_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.488645181 UTC

[section ""data" . GHC.Real.$fIntegralWord_closure" {
     GHC.Real.$fIntegralWord_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Real.$fRealWord_closure+1;
         const GHC.Enum.$fEnumWord_closure;
         const GHC.Real.$fIntegralWord_$cquot_closure+2;
         const GHC.Real.$fIntegralWord_$crem_closure+2;
         const GHC.Real.$fIntegralWord_$cquot_closure+2;
         const GHC.Real.$fIntegralWord_$crem_closure+2;
         const GHC.Real.$fIntegralWord_$cquotRem_closure+2;
         const GHC.Real.$fIntegralWord_$cdivMod_closure+2;
         const GHC.Real.$fIntegralWord_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.489791435 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$c*_closure" {
     GHC.Real.$fFractionalRatio_$s$c*_closure:
         const GHC.Real.$fFractionalRatio_$s$c*_info;
         const 0;
 },
 section ""relreadonly" . u1khh_srtd" {
     u1khh_srtd:
         const S1jKw_srt;
         const 57;
         const 76561193665298433;
 },
 GHC.Real.$fFractionalRatio_$s$c*_entry() //  [R2, R3]
         { info_tbl: [(c1kgN,
                       label: GHC.Real.$fFractionalRatio_$s$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kgN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1kh6; else goto c1kh7;
       c1kh6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kh7: // global
           I64[Sp - 16] = block_c1kgK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1khg; else goto c1kgL;
       u1khg: // global
           call _c1kgK(R1) args: 0, res: 0, upd: 0;
       c1kgL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1khi_srtd" {
     u1khi_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1kgK() //  [R1]
         { info_tbl: [(c1kgK,
                       label: block_c1kgK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kgK: // global
           I64[Sp - 8] = block_c1kgQ_info;
           _s1jfV::P64 = P64[R1 + 7];
           _s1jfW::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jfW::P64;
           P64[Sp + 8] = _s1jfV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1khf; else goto c1kgR;
       u1khf: // global
           call _c1kgQ(R1) args: 0, res: 0, upd: 0;
       c1kgR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1khj_srtd" {
     u1khj_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1kgQ() //  [R1]
         { info_tbl: [(c1kgQ,
                       label: block_c1kgQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kgQ: // global
           I64[Sp] = block_c1kgV_info;
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1khk_srtd" {
     u1khk_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1kgV() //  [R1]
         { info_tbl: [(c1kgV,
                       label: block_c1kgV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kgV: // global
           _s1jfY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1kgZ_info;
           R3 = _s1jfY::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kgZ() //  [R1]
         { info_tbl: [(c1kgZ,
                       label: block_c1kgZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kgZ: // global
           _s1jg1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1kh3_info;
           R3 = _s1jg1::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kh3() //  [R1, R2]
         { info_tbl: [(c1kh3,
                       label: block_c1kh3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kh3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1khe; else goto c1khd;
       c1khe: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1khd: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.49201224 UTC

[section ""data" . GHC.Real.$w$s$c-_closure" {
     GHC.Real.$w$s$c-_closure:
         const GHC.Real.$w$s$c-_info;
         const 0;
 },
 section ""relreadonly" . u1khM_srtd" {
     u1khM_srtd:
         const S1jKw_srt;
         const 59;
         const 436849163854938113;
 },
 GHC.Real.$w$s$c-_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1khr,
                       label: GHC.Real.$w$s$c-_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1khr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1khD; else goto c1khE;
       c1khD: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$c-_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1khE: // global
           I64[Sp - 40] = block_c1khp_info;
           _s1jg6::P64 = R3;
           R3 = R5;
           _s1jg5::P64 = R2;
           R2 = _s1jg6::P64;
           P64[Sp - 32] = _s1jg5::P64;
           P64[Sp - 24] = _s1jg6::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1khN_srtd" {
     u1khN_srtd:
         const S1jKw_srt;
         const 58;
         const 148618787703226369;
 },
 _c1khp() //  [R1]
         { info_tbl: [(c1khp,
                       label: block_c1khp_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1khp: // global
           I64[Sp] = block_c1khu_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1khO_srtd" {
     u1khO_srtd:
         const S1jKw_srt;
         const 58;
         const 148618787703226369;
 },
 _c1khu() //  [R1]
         { info_tbl: [(c1khu,
                       label: block_c1khu_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1khu: // global
           I64[Sp + 16] = block_c1khy_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1khy() //  [R1]
         { info_tbl: [(c1khy,
                       label: block_c1khy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1khy: // global
           I64[Sp] = block_c1khC_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1khC() //  [R1]
         { info_tbl: [(c1khC,
                       label: block_c1khC_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1khC: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.493995614 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c-_closure" {
     GHC.Real.$fEnumRatio_$s$c-_closure:
         const GHC.Real.$fEnumRatio_$s$c-_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c-_entry() //  [R2, R3]
         { info_tbl: [(c1khW,
                       label: GHC.Real.$fEnumRatio_$s$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1khW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1ki7; else goto c1ki8;
       c1ki7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ki8: // global
           I64[Sp - 16] = block_c1khT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kif; else goto c1khU;
       u1kif: // global
           call _c1khT(R1) args: 0, res: 0, upd: 0;
       c1khU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1khT() //  [R1]
         { info_tbl: [(c1khT,
                       label: block_c1khT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1khT: // global
           I64[Sp - 8] = block_c1khZ_info;
           _s1jgg::P64 = P64[R1 + 7];
           _s1jgh::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jgh::P64;
           P64[Sp + 8] = _s1jgg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kie; else goto c1ki0;
       u1kie: // global
           call _c1khZ(R1) args: 0, res: 0, upd: 0;
       c1ki0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1khZ() //  [R1]
         { info_tbl: [(c1khZ,
                       label: block_c1khZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1khZ: // global
           _s1jgg::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1ki4_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1jgg::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ki4() //  [R1, R2]
         { info_tbl: [(c1ki4,
                       label: block_c1ki4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ki4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kid; else goto c1kic;
       c1kid: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kic: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.495811711 UTC

[section ""data" . GHC.Real.$w$s$c+_closure" {
     GHC.Real.$w$s$c+_closure:
         const GHC.Real.$w$s$c+_info;
         const 0;
 },
 section ""relreadonly" . u1kiH_srtd" {
     u1kiH_srtd:
         const S1jKw_srt;
         const 62;
         const 3463268113447911425;
 },
 GHC.Real.$w$s$c+_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1kim,
                       label: GHC.Real.$w$s$c+_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kim: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kiy; else goto c1kiz;
       c1kiy: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$c+_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kiz: // global
           I64[Sp - 40] = block_c1kik_info;
           _s1jgp::P64 = R3;
           R3 = R5;
           _s1jgo::P64 = R2;
           R2 = _s1jgp::P64;
           P64[Sp - 32] = _s1jgo::P64;
           P64[Sp - 24] = _s1jgp::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kiI_srtd" {
     u1kiI_srtd:
         const S1jKw_srt;
         const 61;
         const 1157425104234217473;
 },
 _c1kik() //  [R1]
         { info_tbl: [(c1kik,
                       label: block_c1kik_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kik: // global
           I64[Sp] = block_c1kip_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kiJ_srtd" {
     u1kiJ_srtd:
         const S1jKw_srt;
         const 61;
         const 1157425104234217473;
 },
 _c1kip() //  [R1]
         { info_tbl: [(c1kip,
                       label: block_c1kip_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kip: // global
           I64[Sp + 16] = block_c1kit_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kit() //  [R1]
         { info_tbl: [(c1kit,
                       label: block_c1kit_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kit: // global
           I64[Sp] = block_c1kix_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kix() //  [R1]
         { info_tbl: [(c1kix,
                       label: block_c1kix_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kix: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.497840571 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c+_closure" {
     GHC.Real.$fEnumRatio_$s$c+_closure:
         const GHC.Real.$fEnumRatio_$s$c+_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c+_entry() //  [R2, R3]
         { info_tbl: [(c1kiR,
                       label: GHC.Real.$fEnumRatio_$s$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kiR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1kj2; else goto c1kj3;
       c1kj2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kj3: // global
           I64[Sp - 16] = block_c1kiO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kja; else goto c1kiP;
       u1kja: // global
           call _c1kiO(R1) args: 0, res: 0, upd: 0;
       c1kiP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kiO() //  [R1]
         { info_tbl: [(c1kiO,
                       label: block_c1kiO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kiO: // global
           I64[Sp - 8] = block_c1kiU_info;
           _s1jgz::P64 = P64[R1 + 7];
           _s1jgA::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jgA::P64;
           P64[Sp + 8] = _s1jgz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kj9; else goto c1kiV;
       u1kj9: // global
           call _c1kiU(R1) args: 0, res: 0, upd: 0;
       c1kiV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kiU() //  [R1]
         { info_tbl: [(c1kiU,
                       label: block_c1kiU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kiU: // global
           _s1jgz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1kiZ_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1jgz::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kiZ() //  [R1, R2]
         { info_tbl: [(c1kiZ,
                       label: block_c1kiZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kiZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kj8; else goto c1kj7;
       c1kj8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kj7: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.499372564 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$fNumRatio_closure" {
     GHC.Real.$fFractionalRatio_$s$fNumRatio_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Real.$fEnumRatio_$s$c+_closure+2;
         const GHC.Real.$fEnumRatio_$s$c-_closure+2;
         const GHC.Real.$fFractionalRatio_$s$c*_closure+2;
         const GHC.Real.$fFractionalRatio_$s$cnegate_closure+1;
         const GHC.Real.$fFractionalRatio_$s$cabs_closure+1;
         const GHC.Real.$fFractionalRatio_$s$csignum_closure+1;
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.500203818 UTC

[section ""data" . GHC.Real.$w$s$cfromRational_closure" {
     GHC.Real.$w$s$cfromRational_closure:
         const GHC.Real.$w$s$cfromRational_info;
         const 0;
 },
 section ""relreadonly" . u1kjx_srtd" {
     u1kjx_srtd:
         const S1jKw_srt;
         const 64;
         const 9227875636482146305;
 },
 GHC.Real.$w$s$cfromRational_entry() //  [R2, R3]
         { info_tbl: [(c1kjh,
                       label: GHC.Real.$w$s$cfromRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kjh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1kjp; else goto c1kjq;
       c1kjp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cfromRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kjq: // global
           I64[Sp - 24] = block_c1kjf_info;
           _s1jgH::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _s1jgH::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kjy_srtd" {
     u1kjy_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1kjf() //  [R1]
         { info_tbl: [(c1kjf,
                       label: block_c1kjf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kjf: // global
           I64[Sp] = block_c1kjk_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kjz_srtd" {
     u1kjz_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1kjk() //  [R1]
         { info_tbl: [(c1kjk,
                       label: block_c1kjk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kjk: // global
           _s1jgH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1kjo_info;
           R3 = R1;
           R2 = _s1jgH::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kjo() //  [R1]
         { info_tbl: [(c1kjo,
                       label: block_c1kjo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kjo: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.502158548 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cfromRational_closure" {
     GHC.Real.$fFractionalRatio_$s$cfromRational_closure:
         const GHC.Real.$fFractionalRatio_$s$cfromRational_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$cfromRational_entry() //  [R2]
         { info_tbl: [(c1kjH,
                       label: GHC.Real.$fFractionalRatio_$s$cfromRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kjH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1kjN; else goto c1kjO;
       c1kjN: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cfromRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kjO: // global
           I64[Sp - 8] = block_c1kjE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kjT; else goto c1kjF;
       u1kjT: // global
           call _c1kjE(R1) args: 0, res: 0, upd: 0;
       c1kjF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kjE() //  [R1]
         { info_tbl: [(c1kjE,
                       label: block_c1kjE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kjE: // global
           I64[Sp] = block_c1kjK_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$cfromRational_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kjK() //  [R1, R2]
         { info_tbl: [(c1kjK,
                       label: block_c1kjK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kjK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kjS; else goto c1kjR;
       c1kjS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kjR: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.503682981 UTC

[section ""data" . GHC.Real.$w$s$c/_closure" {
     GHC.Real.$w$s$c/_closure:
         const GHC.Real.$w$s$c/_info;
         const 0;
 },
 section ""relreadonly" . u1kkq_srtd" {
     u1kkq_srtd:
         const S1jKw_srt;
         const 66;
         const 4503599627370497;
         const 2;
 },
 GHC.Real.$w$s$c/_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1kk0,
                       label: GHC.Real.$w$s$c/_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kk0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kkg; else goto c1kkh;
       c1kkg: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$c/_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kkh: // global
           I64[Sp - 24] = block_c1kjY_info;
           _s1jgU::P64 = R3;
           R3 = R4;
           _s1jgT::P64 = R2;
           R2 = _s1jgU::P64;
           P64[Sp - 16] = _s1jgT::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kkr_srtd" {
     u1kkr_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1kjY() //  [R1]
         { info_tbl: [(c1kjY,
                       label: block_c1kjY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kjY: // global
           I64[Sp - 8] = block_c1kk3_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kks_srtd" {
     u1kks_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1kk3() //  [R1]
         { info_tbl: [(c1kk3,
                       label: block_c1kk3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kk3: // global
           I64[Sp] = block_c1kk7_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kkt_srtd" {
     u1kkt_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1kk7() //  [R1]
         { info_tbl: [(c1kk7,
                       label: block_c1kk7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kk7: // global
           I64[Sp] = block_c1kkb_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kku_srtd" {
     u1kku_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1kkb() //  [R1]
         { info_tbl: [(c1kkb,
                       label: block_c1kkb_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kkb: // global
           I64[Sp] = block_c1kkf_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kkf() //  [R1]
         { info_tbl: [(c1kkf,
                       label: block_c1kkf_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kkf: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.50590556 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$c/_closure" {
     GHC.Real.$fFractionalRatio_$s$c/_closure:
         const GHC.Real.$fFractionalRatio_$s$c/_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$c/_entry() //  [R2, R3]
         { info_tbl: [(c1kkC,
                       label: GHC.Real.$fFractionalRatio_$s$c/_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kkC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1kkN; else goto c1kkO;
       c1kkN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$c/_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kkO: // global
           I64[Sp - 16] = block_c1kkz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kkV; else goto c1kkA;
       u1kkV: // global
           call _c1kkz(R1) args: 0, res: 0, upd: 0;
       c1kkA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kkz() //  [R1]
         { info_tbl: [(c1kkz,
                       label: block_c1kkz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kkz: // global
           I64[Sp - 8] = block_c1kkF_info;
           _s1jh5::P64 = P64[R1 + 7];
           _s1jh6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jh6::P64;
           P64[Sp + 8] = _s1jh5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kkU; else goto c1kkG;
       u1kkU: // global
           call _c1kkF(R1) args: 0, res: 0, upd: 0;
       c1kkG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kkF() //  [R1]
         { info_tbl: [(c1kkF,
                       label: block_c1kkF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kkF: // global
           _s1jh5::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1kkK_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1jh5::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kkK() //  [R1, R2]
         { info_tbl: [(c1kkK,
                       label: block_c1kkK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kkK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kkT; else goto c1kkS;
       c1kkT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kkS: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.507407154 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$fFractionalRatio_closure" {
     GHC.Real.$fFractionalRatio_$s$fFractionalRatio_closure:
         const GHC.Real.C:Fractional_con_info;
         const GHC.Real.$fFractionalRatio_$s$fNumRatio_closure+1;
         const GHC.Real.$fFractionalRatio_$s$c/_closure+2;
         const GHC.Real.$fFractionalRatio_$s$crecip_closure+1;
         const GHC.Real.$fFractionalRatio_$s$cfromRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.507998044 UTC

[section ""data" . GHC.Real.ratioPrec_closure" {
     GHC.Real.ratioPrec_closure:
         const GHC.Types.I#_con_info;
         const 7;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.508547043 UTC

[section ""data" . GHC.Real.infinity_closure" {
     GHC.Real.infinity_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.even1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.509081252 UTC

[section ""data" . GHC.Real.notANumber_closure" {
     GHC.Real.notANumber_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.even1_closure;
         const GHC.Real.even1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.510027921 UTC

[section ""data" . GHC.Real.numerator_closure" {
     GHC.Real.numerator_closure:
         const GHC.Real.numerator_info;
 },
 GHC.Real.numerator_entry() //  [R2]
         { info_tbl: [(c1kl3,
                       label: GHC.Real.numerator_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kl3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1kl4; else goto c1kl5;
       c1kl4: // global
           R2 = R2;
           R1 = GHC.Real.numerator_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kl5: // global
           I64[Sp - 8] = block_c1kl0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kl9; else goto c1kl1;
       u1kl9: // global
           call _c1kl0(R1) args: 0, res: 0, upd: 0;
       c1kl1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kl0() //  [R1]
         { info_tbl: [(c1kl0,
                       label: block_c1kl0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kl0: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.511190022 UTC

[section ""data" . GHC.Real.denominator_closure" {
     GHC.Real.denominator_closure:
         const GHC.Real.denominator_info;
 },
 GHC.Real.denominator_entry() //  [R2]
         { info_tbl: [(c1klh,
                       label: GHC.Real.denominator_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1klh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1kli; else goto c1klj;
       c1kli: // global
           R2 = R2;
           R1 = GHC.Real.denominator_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1klj: // global
           I64[Sp - 8] = block_c1kle_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kln; else goto c1klf;
       u1kln: // global
           call _c1kle(R1) args: 0, res: 0, upd: 0;
       c1klf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kle() //  [R1]
         { info_tbl: [(c1kle,
                       label: block_c1kle_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kle: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.512685092 UTC

[section ""data" . GHC.Real.$w$snumericEnumFrom_closure" {
     GHC.Real.$w$snumericEnumFrom_closure:
         const GHC.Real.$w$snumericEnumFrom_info;
         const 0;
 },
 section ""relreadonly" . u1klO_srtd" {
     u1klO_srtd:
         const S1jKw_srt+80;
         const 58;
         const 146366987889541121;
 },
 sat_s1jhu_entry() //  [R1]
         { info_tbl: [(c1klB,
                       label: sat_s1jhu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1klB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1klC; else goto c1klD;
       c1klC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1klD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1klw_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1klw() //  [R1, R2]
         { info_tbl: [(c1klw,
                       label: block_c1klw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1klw: // global
           I64[Sp] = block_c1kly_info;
           R3 = R2;
           R2 = R1;
           call GHC.Real.$w$snumericEnumFrom_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kly() //  [R1, R2]
         { info_tbl: [(c1kly,
                       label: block_c1kly_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kly: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1klH; else goto c1klG;
       c1klH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1klG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1klP_srtd" {
     u1klP_srtd:
         const S1jKw_srt+80;
         const 58;
         const 146366987889541121;
 },
 GHC.Real.$w$snumericEnumFrom_entry() //  [R2, R3]
         { info_tbl: [(c1klJ,
                       label: GHC.Real.$w$snumericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1klJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1klN; else goto c1klM;
       c1klN: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1klM: // global
           I64[Hp - 48] = sat_s1jhu_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.5147397 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFrom_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFrom_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFrom_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFrom_entry() //  [R2]
         { info_tbl: [(c1klX,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1klX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1km3; else goto c1km4;
       c1km3: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1km4: // global
           I64[Sp - 8] = block_c1klU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1km9; else goto c1klV;
       u1km9: // global
           call _c1klU(R1) args: 0, res: 0, upd: 0;
       c1klV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1klU() //  [R1]
         { info_tbl: [(c1klU,
                       label: block_c1klU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1klU: // global
           I64[Sp] = block_c1km0_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$snumericEnumFrom_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1km0() //  [R1, R2]
         { info_tbl: [(c1km0,
                       label: block_c1km0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1km0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1km8; else goto c1km7;
       c1km8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1km7: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.518067681 UTC

[section ""data" . GHC.Real.$wnumericEnumFrom_closure" {
     GHC.Real.$wnumericEnumFrom_closure:
         const GHC.Real.$wnumericEnumFrom_info;
         const 0;
 },
 sat_s1jhG_entry() //  [R1]
         { info_tbl: [(c1kms,
                       label: sat_s1jhG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kms: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kmt; else goto c1kmu;
       c1kmt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kmu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jhL_entry() //  [R1]
         { info_tbl: [(c1kmv,
                       label: sat_s1jhL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kmv: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1kmB; else goto c1kmC;
       c1kmB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kmC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c1kmk_info;
           _s1jhC::P64 = P64[R1 + 16];
           R2 = _s1jhC::P64;
           P64[Sp - 32] = _s1jhC::P64;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kmk() //  [R1]
         { info_tbl: [(c1kmk,
                       label: block_c1kmk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kmk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kmF; else goto c1kmE;
       c1kmF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1kmE: // global
           I64[Hp - 16] = sat_s1jhG_info;
           P64[Hp] = R1;
           I64[Sp] = block_c1kmw_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call GHC.Num.+_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1kmw() //  [R1]
         { info_tbl: [(c1kmw,
                       label: block_c1kmw_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kmw: // global
           I64[Sp + 16] = block_c1kmy_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kmy() //  [R1, R2]
         { info_tbl: [(c1kmy,
                       label: block_c1kmy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kmy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kmJ; else goto c1kmI;
       c1kmJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1kmI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$wnumericEnumFrom_entry() //  [R2, R3]
         { info_tbl: [(c1kmK,
                       label: GHC.Real.$wnumericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kmK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kmL; else goto c1kmM;
       c1kmL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wnumericEnumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kmM: // global
           I64[Sp - 16] = block_c1kme_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kme() //  [R1]
         { info_tbl: [(c1kme,
                       label: block_c1kme_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kme: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1kmP; else goto c1kmO;
       c1kmP: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kmO: // global
           I64[Hp - 24] = sat_s1jhL_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = Hp - 24;
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.520516039 UTC

[section ""data" . GHC.Real.numericEnumFrom_closure" {
     GHC.Real.numericEnumFrom_closure:
         const GHC.Real.numericEnumFrom_info;
         const 0;
 },
 GHC.Real.numericEnumFrom_entry() //  [R2, R3]
         { info_tbl: [(c1kmX,
                       label: GHC.Real.numericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kmX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1kmY; else goto c1kmZ;
       c1kmY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kmZ: // global
           I64[Sp - 8] = block_c1kmU_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kmU() //  [R1, R2]
         { info_tbl: [(c1kmU,
                       label: block_c1kmU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kmU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kn2; else goto c1kn1;
       c1kn2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kn1: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.521615028 UTC

[section ""data" . sat_s1jhR_closure" {
     sat_s1jhR_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.522167761 UTC

[section ""data" . sat_s1jhS_closure" {
     sat_s1jhS_closure:
         const :_con_info;
         const sat_s1jhR_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.52298644 UTC

[section ""data" . GHC.Real.even2_closure" {
     GHC.Real.even2_closure:
         const GHC.Real.even2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.even2_entry() //  [R1]
         { info_tbl: [(c1kn9,
                       label: GHC.Real.even2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kn9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kna; else goto c1knb;
       c1kna: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1knb: // global
           (_c1kn6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1kn6::I64 == 0) goto c1kn8; else goto c1kn7;
       c1kn8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1kn7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1kn6::I64;
           R3 = sat_s1jhS_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.524165846 UTC

[section ""data" . GHC.Real.$fEnumRatio2_closure" {
     GHC.Real.$fEnumRatio2_closure:
         const GHC.Real.$fEnumRatio2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fEnumRatio2_entry() //  [R1]
         { info_tbl: [(c1knl,
                       label: GHC.Real.$fEnumRatio2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1knl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1knm; else goto c1knn;
       c1knm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1knn: // global
           (_c1knf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1knf::I64 == 0) goto c1knh; else goto c1kng;
       c1knh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1kng: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1knf::I64;
           I64[Sp - 24] = block_c1kni_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even2_closure;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 24;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kni() //  [R1, R2]
         { info_tbl: [(c1kni,
                       label: block_c1kni_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kni: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1knq; else goto c1knp;
       c1knq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1knp: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.526353252 UTC

[section ""data" . GHC.Real.$w$snumericEnumFromTo_closure" {
     GHC.Real.$w$snumericEnumFromTo_closure:
         const GHC.Real.$w$snumericEnumFromTo_info;
         const 0;
 },
 ds_s1ji2_entry() //  [R1]
         { info_tbl: [(c1knF,
                       label: ds_s1ji2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1knF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1knQ; else goto c1knR;
       c1knQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1knR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1knC_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1knY; else goto c1knD;
       u1knY: // global
           call _c1knC(R1) args: 0, res: 0, upd: 0;
       c1knD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1knC() //  [R1]
         { info_tbl: [(c1knC,
                       label: block_c1knC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1knC: // global
           I64[Sp - 16] = block_c1knI_info;
           _s1ji4::P64 = P64[R1 + 7];
           _s1ji5::P64 = P64[R1 + 15];
           R1 = GHC.Real.$fEnumRatio2_closure;
           P64[Sp - 8] = _s1ji5::P64;
           P64[Sp] = _s1ji4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1knX; else goto c1knJ;
       u1knX: // global
           call _c1knI(R1) args: 0, res: 0, upd: 0;
       c1knJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1knI() //  [R1]
         { info_tbl: [(c1knI,
                       label: block_c1knI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1knI: // global
           _s1ji4::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1knN_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1ji4::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1knN() //  [R1, R2]
         { info_tbl: [(c1knN,
                       label: block_c1knN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1knN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1knW; else goto c1knV;
       c1knW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1knV: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jid_entry() //  [R1, R2]
         { info_tbl: [(c1ko4,
                       label: sat_s1jid_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ko4: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call GHC.Real.$fEnumRatio_$s$c<=_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$w$snumericEnumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ko7,
                       label: GHC.Real.$w$snumericEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ko7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ko8; else goto c1ko9;
       c1ko8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ko9: // global
           I64[Sp - 16] = block_c1knv_info;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Real.$w$snumericEnumFrom_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1knv() //  [R1, R2]
         { info_tbl: [(c1knv,
                       label: block_c1knv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1knv: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1koc; else goto c1kob;
       c1koc: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kob: // global
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = R1;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = ds_s1ji2_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_s1jid_info;
           P64[Hp] = Hp - 32;
           R3 = Hp - 54;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.528774342 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFromTo_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c1kok,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kok: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kol; else goto c1kom;
       c1kol: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kom: // global
           I64[Sp - 16] = block_c1koh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1koq; else goto c1koi;
       u1koq: // global
           call _c1koh(R1) args: 0, res: 0, upd: 0;
       c1koi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1koh() //  [R1]
         { info_tbl: [(c1koh,
                       label: block_c1koh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1koh: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Real.$w$snumericEnumFromTo_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.530982808 UTC

[section ""data" . GHC.Real.numericEnumFromTo_closure" {
     GHC.Real.numericEnumFromTo_closure:
         const GHC.Real.numericEnumFromTo_info;
         const 0;
 },
 $dNum_s1jir_entry() //  [R1]
         { info_tbl: [(c1koB,
                       label: $dNum_s1jir_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1koB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1koC; else goto c1koD;
       c1koC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1koD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jiu_entry() //  [R1]
         { info_tbl: [(c1koR,
                       label: sat_s1jiu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1koR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1koS; else goto c1koT;
       c1koS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1koT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jit_entry() //  [R1]
         { info_tbl: [(c1koY,
                       label: sat_s1jit_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1koY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1koZ; else goto c1kp0;
       c1koZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kp0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jiv_entry() //  [R1]
         { info_tbl: [(c1kp1,
                       label: sat_s1jiv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kp1: // global
           _s1jiv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1kp2; else goto c1kp3;
       c1kp3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1kp5; else goto c1kp4;
       c1kp5: // global
           HpAlloc = 48;
           goto c1kp2;
       c1kp2: // global
           R1 = _s1jiv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kp4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jiv::P64;
           _s1jil::P64 = P64[_s1jiv::P64 + 16];
           _s1jir::P64 = P64[_s1jiv::P64 + 24];
           I64[Hp - 40] = sat_s1jiu_info;
           P64[Hp - 24] = _s1jir::P64;
           I64[Hp - 16] = sat_s1jit_info;
           P64[Hp] = _s1jir::P64;
           R2 = _s1jil::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           Sp = Sp - 40;
           call GHC.Real./_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds_s1jis_entry() //  [R1]
         { info_tbl: [(c1kp6,
                       label: ds_s1jis_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kp6: // global
           _s1jis::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1kp7; else goto c1kp8;
       c1kp8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1kpa; else goto c1kp9;
       c1kpa: // global
           HpAlloc = 32;
           goto c1kp7;
       c1kp7: // global
           R1 = _s1jis::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kp9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jis::P64;
           _s1jil::P64 = P64[_s1jis::P64 + 16];
           _s1jin::P64 = P64[_s1jis::P64 + 24];
           _s1jir::P64 = P64[_s1jis::P64 + 32];
           I64[Hp - 24] = sat_s1jiv_info;
           P64[Hp - 8] = _s1jil::P64;
           P64[Hp] = _s1jir::P64;
           R2 = _s1jir::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1jin::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jix_entry() //  [R1, R2]
         { info_tbl: [(c1kpg,
                       label: sat_s1jix_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kpg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1kph; else goto c1kpi;
       c1kph: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kpi: // global
           _s1jiw::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jiw::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Real.numericEnumFromTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1kpj,
                       label: GHC.Real.numericEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kpj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kpk; else goto c1kpl;
       c1kpk: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFromTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kpl: // global
           I64[Sp - 32] = block_c1kov_info;
           _s1jil::P64 = R3;
           R3 = R4;
           _s1jik::P64 = R2;
           R2 = _s1jil::P64;
           P64[Sp - 24] = _s1jik::P64;
           P64[Sp - 16] = _s1jil::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kov() //  [R1, R2]
         { info_tbl: [(c1kov,
                       label: block_c1kov_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kov: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1kpo; else goto c1kpn;
       c1kpo: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kpn: // global
           I64[Hp - 104] = $dNum_s1jir_info;
           _s1jil::P64 = P64[Sp + 16];
           P64[Hp - 88] = _s1jil::P64;
           I64[Hp - 80] = :_con_info;
           P64[Hp - 72] = R1;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = ds_s1jis_info;
           P64[Hp - 40] = _s1jil::P64;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = sat_s1jix_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 56;
           R3 = Hp - 78;
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.534566464 UTC

[section ""data" . GHC.Real.$w$snumericEnumFromThen_closure" {
     GHC.Real.$w$snumericEnumFromThen_closure:
         const GHC.Real.$w$snumericEnumFromThen_info;
         const 0;
 },
 sat_s1jiN_entry() //  [R1]
         { info_tbl: [(c1kpE,
                       label: sat_s1jiN_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kpE: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1kpF; else goto c1kpG;
       c1kpF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kpG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_c1kpx_info;
           _s1jiC::P64 = P64[R1 + 40];
           R5 = _s1jiC::P64;
           _s1jiB::P64 = P64[R1 + 32];
           R4 = _s1jiB::P64;
           R3 = _s1jiC::P64;
           R2 = _s1jiB::P64;
           P64[Sp - 48] = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = _s1jiB::P64;
           P64[Sp - 24] = _s1jiC::P64;
           Sp = Sp - 56;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kpx() //  [R1, R2]
         { info_tbl: [(c1kpx,
                       label: block_c1kpx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kpx: // global
           _s1jiA::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1kpz_info;
           R5 = _s1jiA::P64;
           R4 = P64[Sp + 8];
           R3 = R2;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kpz() //  [R1, R2]
         { info_tbl: [(c1kpz,
                       label: block_c1kpz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kpz: // global
           _s1jiC::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1kpB_info;
           R5 = R2;
           R4 = R1;
           R3 = _s1jiC::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$snumericEnumFromThen_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kpB() //  [R1, R2]
         { info_tbl: [(c1kpB,
                       label: block_c1kpB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kpB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kpL; else goto c1kpK;
       c1kpL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1kpK: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$snumericEnumFromThen_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1kpN,
                       label: GHC.Real.$w$snumericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kpN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1kpR; else goto c1kpQ;
       c1kpR: // global
           HpAlloc = 72;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFromThen_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kpQ: // global
           I64[Hp - 64] = sat_s1jiN_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.536855168 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFromThen_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c1kpZ,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kpZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1kqa; else goto c1kqb;
       c1kqa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kqb: // global
           I64[Sp - 16] = block_c1kpW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kqi; else goto c1kpX;
       u1kqi: // global
           call _c1kpW(R1) args: 0, res: 0, upd: 0;
       c1kpX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kpW() //  [R1]
         { info_tbl: [(c1kpW,
                       label: block_c1kpW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kpW: // global
           I64[Sp - 8] = block_c1kq2_info;
           _s1jiR::P64 = P64[R1 + 7];
           _s1jiS::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jiS::P64;
           P64[Sp + 8] = _s1jiR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kqh; else goto c1kq3;
       u1kqh: // global
           call _c1kq2(R1) args: 0, res: 0, upd: 0;
       c1kq3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kq2() //  [R1]
         { info_tbl: [(c1kq2,
                       label: block_c1kq2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kq2: // global
           _s1jiR::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1kq7_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1jiR::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$snumericEnumFromThen_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kq7() //  [R1, R2]
         { info_tbl: [(c1kq7,
                       label: block_c1kq7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kq7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kqg; else goto c1kqf;
       c1kqg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kqf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.539316933 UTC

[section ""data" . GHC.Real.$wnumericEnumFromThen_closure" {
     GHC.Real.$wnumericEnumFromThen_closure:
         const GHC.Real.$wnumericEnumFromThen_info;
 },
 sat_s1jj5_entry() //  [R1]
         { info_tbl: [(c1kqD,
                       label: sat_s1jj5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kqD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kqE; else goto c1kqF;
       c1kqE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kqF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jj3::P64 = P64[R1 + 16];
           P64[Sp - 32] = _s1jj3::P64;
           P64[Sp - 24] = _s1jj3::P64;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jja_entry() //  [R1]
         { info_tbl: [(c1kqG,
                       label: sat_s1jja_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kqG: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1kqM; else goto c1kqN;
       c1kqM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kqN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_c1kqv_info;
           _s1jiZ::P64 = P64[R1 + 16];
           R2 = _s1jiZ::P64;
           P64[Sp - 40] = _s1jiZ::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kqv() //  [R1]
         { info_tbl: [(c1kqv,
                       label: block_c1kqv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kqv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1kqQ; else goto c1kqP;
       c1kqQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1kqP: // global
           I64[Hp - 24] = sat_s1jj5_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           I64[Sp] = block_c1kqH_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1kqH() //  [R1]
         { info_tbl: [(c1kqH,
                       label: block_c1kqH_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kqH: // global
           _s1jj3::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1kqJ_info;
           R4 = R1;
           R3 = _s1jj3::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kqJ() //  [R1, R2]
         { info_tbl: [(c1kqJ,
                       label: block_c1kqJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kqJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kqU; else goto c1kqT;
       c1kqU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1kqT: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$wnumericEnumFromThen_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kqV,
                       label: GHC.Real.$wnumericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kqV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1kqW; else goto c1kqX;
       c1kqW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wnumericEnumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kqX: // global
           I64[Sp - 24] = block_c1kqn_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kqn() //  [R1]
         { info_tbl: [(c1kqn,
                       label: block_c1kqn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kqn: // global
           I64[Sp] = block_c1kqp_info;
           _s1jj2::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s1jj2::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kqp() //  [R1]
         { info_tbl: [(c1kqp,
                       label: block_c1kqp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kqp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1kr1; else goto c1kr0;
       c1kr1: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kr0: // global
           I64[Hp - 32] = sat_s1jja_info;
           P64[Hp - 16] = P64[Sp + 8];
           _s1jj2::P64 = P64[Sp + 16];
           P64[Hp - 8] = _s1jj2::P64;
           P64[Hp] = R1;
           R2 = Hp - 32;
           R1 = _s1jj2::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.542494366 UTC

[section ""data" . GHC.Real.numericEnumFromThen_closure" {
     GHC.Real.numericEnumFromThen_closure:
         const GHC.Real.numericEnumFromThen_info;
 },
 GHC.Real.numericEnumFromThen_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kr9,
                       label: GHC.Real.numericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kr9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1kra; else goto c1krb;
       c1kra: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1krb: // global
           I64[Sp - 8] = block_c1kr6_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kr6() //  [R1, R2]
         { info_tbl: [(c1kr6,
                       label: block_c1kr6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kr6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kre; else goto c1krd;
       c1kre: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1krd: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.545530649 UTC

[section ""data" . GHC.Real.$w$snumericEnumFromThenTo_closure" {
     GHC.Real.$w$snumericEnumFromThenTo_closure:
         const GHC.Real.$w$snumericEnumFromThenTo_info;
         const 0;
 },
 ds_s1jjq_entry() //  [R1]
         { info_tbl: [(c1krB,
                       label: ds_s1jjq_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1krB: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1krL; else goto c1krM;
       c1krL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1krM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_c1kry_info;
           _s1jjh::P64 = P64[R1 + 16];
           _s1jji::P64 = P64[R1 + 24];
           _s1jjj::P64 = P64[R1 + 32];
           _s1jjk::P64 = P64[R1 + 40];
           R1 = P64[R1 + 48];
           P64[Sp - 48] = _s1jjh::P64;
           P64[Sp - 40] = _s1jji::P64;
           P64[Sp - 32] = _s1jjj::P64;
           P64[Sp - 24] = _s1jjk::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u1krT; else goto c1krz;
       u1krT: // global
           call _c1kry(R1) args: 0, res: 0, upd: 0;
       c1krz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1kry() //  [R1]
         { info_tbl: [(c1kry,
                       label: block_c1kry_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kry: // global
           _s1jji::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1krE_info;
           R5 = _s1jji::P64;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 15];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1krE() //  [R1, R2]
         { info_tbl: [(c1krE,
                       label: block_c1krE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1krE: // global
           I64[Sp] = block_c1krG_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even2_closure;
           R3 = R2;
           R2 = R1;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1krG() //  [R1, R2]
         { info_tbl: [(c1krG,
                       label: block_c1krG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1krG: // global
           _s1jjs::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1krI_info;
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = _s1jjs::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1krI() //  [R1, R2]
         { info_tbl: [(c1krI,
                       label: block_c1krI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1krI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1krS; else goto c1krR;
       c1krS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1krR: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jjE_entry() //  [R1, R2]
         { info_tbl: [(c1krZ,
                       label: sat_s1jjE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1krZ: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call GHC.Real.$fEnumRatio_$s$c<=_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_s1jjF_entry() //  [R1]
         { info_tbl: [(c1ksb,
                       label: ds_s1jjF_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ksb: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1ksl; else goto c1ksm;
       c1ksl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ksm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_c1ks8_info;
           _s1jjh::P64 = P64[R1 + 16];
           _s1jji::P64 = P64[R1 + 24];
           _s1jjj::P64 = P64[R1 + 32];
           _s1jjk::P64 = P64[R1 + 40];
           R1 = P64[R1 + 48];
           P64[Sp - 48] = _s1jjh::P64;
           P64[Sp - 40] = _s1jji::P64;
           P64[Sp - 32] = _s1jjj::P64;
           P64[Sp - 24] = _s1jjk::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u1kst; else goto c1ks9;
       u1kst: // global
           call _c1ks8(R1) args: 0, res: 0, upd: 0;
       c1ks9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1ks8() //  [R1]
         { info_tbl: [(c1ks8,
                       label: block_c1ks8_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ks8: // global
           _s1jji::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1kse_info;
           R5 = _s1jji::P64;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 15];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kse() //  [R1, R2]
         { info_tbl: [(c1kse,
                       label: block_c1kse_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kse: // global
           I64[Sp] = block_c1ksg_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even2_closure;
           R3 = R2;
           R2 = R1;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1ksg() //  [R1, R2]
         { info_tbl: [(c1ksg,
                       label: block_c1ksg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ksg: // global
           _s1jjH::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1ksi_info;
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = _s1jjH::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1ksi() //  [R1, R2]
         { info_tbl: [(c1ksi,
                       label: block_c1ksi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ksi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kss; else goto c1ksr;
       c1kss: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1ksr: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jjT_entry() //  [R1, R2]
         { info_tbl: [(c1ksz,
                       label: sat_s1jjT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ksz: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call GHC.Real.$fEnumRatio_$s$c>=_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1ksV_srtd" {
     u1ksV_srtd:
         const S1jKw_srt+24;
         const 79;
         const 4935945191598063617;
         const 16708;
 },
 sat_s1jjU_entry() //  [R1]
         { info_tbl: [(c1ksG,
                       label: sat_s1jjU_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ksG: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1ksH; else goto c1ksI;
       c1ksH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ksI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c1krq_info;
           _s1jji::P64 = P64[R1 + 24];
           R5 = _s1jji::P64;
           _s1jjh::P64 = P64[R1 + 16];
           R4 = _s1jjh::P64;
           _s1jjk::P64 = P64[R1 + 40];
           R3 = _s1jjk::P64;
           _s1jjj::P64 = P64[R1 + 32];
           R2 = _s1jjj::P64;
           P64[Sp - 56] = _s1jjh::P64;
           P64[Sp - 48] = _s1jji::P64;
           P64[Sp - 40] = _s1jjj::P64;
           P64[Sp - 32] = _s1jjk::P64;
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 64;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1krq() //  [R1]
         { info_tbl: [(c1krq,
                       label: block_c1krq_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1krq: // global
           _s1jjh::P64 = P64[Sp + 8];
           _s1jji::P64 = P64[Sp + 16];
           _s1jjj::P64 = P64[Sp + 24];
           _s1jjk::P64 = P64[Sp + 32];
           _s1jjl::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c1ksE; else goto c1ksD;
       c1ksE: // global
           Hp = Hp + 72;
           _s1jjp::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1ksO; else goto c1ksN;
       c1ksN: // global
           I64[Hp - 64] = ds_s1jjF_info;
           P64[Hp - 48] = _s1jjh::P64;
           P64[Hp - 40] = _s1jji::P64;
           P64[Hp - 32] = _s1jjj::P64;
           P64[Hp - 24] = _s1jjk::P64;
           P64[Hp - 16] = _s1jjl::P64;
           I64[Hp - 8] = sat_s1jjT_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c1ksD: // global
           Hp = Hp + 72;
           _s1jjp::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1ksO; else goto c1ksK;
       c1ksO: // global
           HpAlloc = 72;
           R1 = _s1jjp::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1ksK: // global
           I64[Hp - 64] = ds_s1jjq_info;
           P64[Hp - 48] = _s1jjh::P64;
           P64[Hp - 40] = _s1jji::P64;
           P64[Hp - 32] = _s1jjj::P64;
           P64[Hp - 24] = _s1jjk::P64;
           P64[Hp - 16] = _s1jjl::P64;
           I64[Hp - 8] = sat_s1jjE_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1ksW_srtd" {
     u1ksW_srtd:
         const S1jKw_srt+24;
         const 80;
         const 4935945191598063617;
         const 53572;
 },
 GHC.Real.$w$snumericEnumFromThenTo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1ksP,
                       label: GHC.Real.$w$snumericEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ksP: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1ksQ; else goto c1ksR;
       c1ksQ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFromThenTo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ksR: // global
           I64[Sp - 48] = block_c1krj_info;
           _s1jjk::P64 = R5;
           R5 = R5;
           _s1jjj::P64 = R4;
           R4 = R4;
           _s1jji::P64 = R3;
           R3 = R3;
           _s1jjh::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = _s1jjh::P64;
           P64[Sp - 32] = _s1jji::P64;
           P64[Sp - 24] = _s1jjj::P64;
           P64[Sp - 16] = _s1jjk::P64;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$w$snumericEnumFromThen_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ksX_srtd" {
     u1ksX_srtd:
         const S1jKw_srt+24;
         const 79;
         const 4935945191598063617;
         const 16708;
 },
 _c1krj() //  [R1, R2]
         { info_tbl: [(c1krj,
                       label: block_c1krj_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1krj: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1ksU; else goto c1ksT;
       c1ksU: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1ksT: // global
           I64[Hp - 72] = :_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s1jjU_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R3 = Hp - 70;
           R2 = Hp - 48;
           Sp = Sp + 48;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.55273456 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c1kt5,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kt5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kt9; else goto c1kta;
       c1kt9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kta: // global
           I64[Sp - 24] = block_c1kt2_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1kti; else goto c1kt3;
       u1kti: // global
           call _c1kt2(R1) args: 0, res: 0, upd: 0;
       c1kt3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kt2() //  [R1]
         { info_tbl: [(c1kt2,
                       label: block_c1kt2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kt2: // global
           I64[Sp - 8] = block_c1kt8_info;
           _s1jk0::P64 = P64[R1 + 7];
           _s1jk1::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jk1::P64;
           P64[Sp + 8] = _s1jk0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kth; else goto c1ktc;
       u1kth: // global
           call _c1kt8(R1) args: 0, res: 0, upd: 0;
       c1ktc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kt8() //  [R1]
         { info_tbl: [(c1kt8,
                       label: block_c1kt8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kt8: // global
           R6 = P64[Sp + 24];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$snumericEnumFromThenTo_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.555971434 UTC

[section ""data" . GHC.Real.numericEnumFromThenTo_closure" {
     GHC.Real.numericEnumFromThenTo_closure:
         const GHC.Real.numericEnumFromThenTo_info;
         const 0;
 },
 $dNum_s1jkd_entry() //  [R1]
         { info_tbl: [(c1kty,
                       label: $dNum_s1jkd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kty: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ktz; else goto c1ktA;
       c1ktz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ktA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jkg_entry() //  [R1]
         { info_tbl: [(c1ktJ,
                       label: sat_s1jkg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ktJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ktK; else goto c1ktL;
       c1ktK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ktL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jkf_entry() //  [R1]
         { info_tbl: [(c1ktQ,
                       label: sat_s1jkf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ktQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ktR; else goto c1ktS;
       c1ktR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ktS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 mid_s1jke_entry() //  [R1]
         { info_tbl: [(c1ktT,
                       label: mid_s1jke_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ktT: // global
           _s1jke::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1ktU; else goto c1ktV;
       c1ktV: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1ktX; else goto c1ktW;
       c1ktX: // global
           HpAlloc = 64;
           goto c1ktU;
       c1ktU: // global
           R1 = _s1jke::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ktW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jke::P64;
           _s1jk6::P64 = P64[_s1jke::P64 + 16];
           _s1jk7::P64 = P64[_s1jke::P64 + 24];
           _s1jk8::P64 = P64[_s1jke::P64 + 32];
           _s1jkd::P64 = P64[_s1jke::P64 + 40];
           I64[Hp - 56] = sat_s1jkg_info;
           P64[Hp - 40] = _s1jkd::P64;
           I64[Hp - 32] = sat_s1jkf_info;
           P64[Hp - 16] = _s1jk7::P64;
           P64[Hp - 8] = _s1jk8::P64;
           P64[Hp] = _s1jkd::P64;
           R2 = _s1jk6::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Real./_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds_s1jki_entry() //  [R1]
         { info_tbl: [(c1ku6,
                       label: ds_s1jki_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ku6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ku7; else goto c1ku8;
       c1ku7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ku8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jkk_entry() //  [R1, R2]
         { info_tbl: [(c1kue,
                       label: sat_s1jkk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kue: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1kuf; else goto c1kug;
       c1kuf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kug: // global
           _s1jkj::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jkj::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 ds_s1jkl_entry() //  [R1]
         { info_tbl: [(c1kun,
                       label: ds_s1jkl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kun: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kuo; else goto c1kup;
       c1kuo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kup: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jkn_entry() //  [R1, R2]
         { info_tbl: [(c1kuv,
                       label: sat_s1jkn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kuv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1kuw; else goto c1kux;
       c1kuw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kux: // global
           _s1jkm::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jkm::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s1jko_entry() //  [R1]
         { info_tbl: [(c1kuC,
                       label: sat_s1jko_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kuC: // global
           _s1jko::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto c1kuD; else goto c1kuE;
       c1kuE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1kuG; else goto c1kuF;
       c1kuG: // global
           HpAlloc = 72;
           goto c1kuD;
       c1kuD: // global
           R1 = _s1jko::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kuF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jko::P64;
           _s1jk5::P64 = P64[_s1jko::P64 + 16];
           _s1jk6::P64 = P64[_s1jko::P64 + 24];
           _s1jk7::P64 = P64[_s1jko::P64 + 32];
           _s1jk8::P64 = P64[_s1jko::P64 + 40];
           _s1jk9::P64 = P64[_s1jko::P64 + 48];
           I64[Hp - 64] = $dNum_s1jkd_info;
           P64[Hp - 48] = _s1jk6::P64;
           I64[Hp - 40] = mid_s1jke_info;
           P64[Hp - 24] = _s1jk6::P64;
           P64[Hp - 16] = _s1jk7::P64;
           P64[Hp - 8] = _s1jk8::P64;
           _c1ktu::P64 = Hp - 64;
           P64[Hp] = _c1ktu::P64;
           I64[Sp - 56] = block_c1ktY_info;
           R2 = _s1jk5::P64;
           I64[Sp - 80] = stg_ap_pp_info;
           P64[Sp - 72] = _s1jk8::P64;
           P64[Sp - 64] = _s1jk7::P64;
           P64[Sp - 48] = _c1ktu::P64;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = _s1jk5::P64;
           P64[Sp - 24] = _s1jk9::P64;
           Sp = Sp - 80;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1ktY() //  [R1]
         { info_tbl: [(c1ktY,
                       label: block_c1ktY_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ktY: // global
           _c1ktu::P64 = P64[Sp + 8];
           _c1ktB::P64 = P64[Sp + 16];
           _s1jk5::P64 = P64[Sp + 24];
           _s1jk9::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c1kuz; else goto c1kuA;
       c1kuz: // global
           Hp = Hp + 64;
           _s1jkh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1kuM; else goto c1kuI;
       c1kuI: // global
           I64[Hp - 56] = ds_s1jki_info;
           P64[Hp - 40] = _s1jk9::P64;
           P64[Hp - 32] = _c1ktu::P64;
           P64[Hp - 24] = _c1ktB::P64;
           I64[Hp - 16] = sat_s1jkk_info;
           P64[Hp - 8] = _s1jk5::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c1kuA: // global
           Hp = Hp + 64;
           _s1jkh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1kuM; else goto c1kuL;
       c1kuM: // global
           HpAlloc = 64;
           R1 = _s1jkh::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1kuL: // global
           I64[Hp - 56] = ds_s1jkl_info;
           P64[Hp - 40] = _s1jk9::P64;
           P64[Hp - 32] = _c1ktu::P64;
           P64[Hp - 24] = _c1ktB::P64;
           I64[Hp - 16] = sat_s1jkn_info;
           P64[Hp - 8] = _s1jk5::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.numericEnumFromThenTo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1kuN,
                       label: GHC.Real.numericEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kuN: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1kuO; else goto c1kuP;
       c1kuO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFromThenTo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kuP: // global
           I64[Sp - 48] = block_c1ktn_info;
           _s1jk7::P64 = R4;
           R4 = R5;
           _s1jk6::P64 = R3;
           R3 = _s1jk7::P64;
           _s1jk5::P64 = R2;
           R2 = _s1jk6::P64;
           P64[Sp - 40] = _s1jk5::P64;
           P64[Sp - 32] = _s1jk6::P64;
           P64[Sp - 24] = _s1jk7::P64;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ktn() //  [R1, R2]
         { info_tbl: [(c1ktn,
                       label: block_c1ktn_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ktn: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1kuS; else goto c1kuR;
       c1kuS: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kuR: // global
           I64[Hp - 72] = :_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s1jko_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R3 = Hp - 70;
           R2 = Hp - 48;
           Sp = Sp + 48;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.560869701 UTC

[section ""data" . GHC.Real.fromIntegral_closure" {
     GHC.Real.fromIntegral_closure:
         const GHC.Real.fromIntegral_info;
 },
 sat_s1jkt_entry() //  [R1]
         { info_tbl: [(c1kv1,
                       label: sat_s1jkt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kv1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kv2; else goto c1kv3;
       c1kv2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kv3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.fromIntegral_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kv4,
                       label: GHC.Real.fromIntegral_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kv4: // global
           _s1jks::P64 = R4;
           _s1jkr::P64 = R3;
           _s1jkq::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c1kv5; else goto c1kv6;
       c1kv6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1kv8; else goto c1kv7;
       c1kv8: // global
           HpAlloc = 32;
           goto c1kv5;
       c1kv5: // global
           R4 = _s1jks::P64;
           R3 = _s1jkr::P64;
           R2 = _s1jkq::P64;
           R1 = GHC.Real.fromIntegral_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kv7: // global
           I64[Hp - 24] = sat_s1jkt_info;
           P64[Hp - 8] = _s1jkq::P64;
           P64[Hp] = _s1jks::P64;
           R2 = _s1jkr::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.562418218 UTC

[section ""data" . GHC.Real.realToFrac_closure" {
     GHC.Real.realToFrac_closure:
         const GHC.Real.realToFrac_info;
 },
 sat_s1jkx_entry() //  [R1]
         { info_tbl: [(c1kvh,
                       label: sat_s1jkx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kvh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kvi; else goto c1kvj;
       c1kvi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kvj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.realToFrac_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kvk,
                       label: GHC.Real.realToFrac_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kvk: // global
           _s1jkw::P64 = R4;
           _s1jkv::P64 = R3;
           _s1jku::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c1kvl; else goto c1kvm;
       c1kvm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1kvo; else goto c1kvn;
       c1kvo: // global
           HpAlloc = 32;
           goto c1kvl;
       c1kvl: // global
           R4 = _s1jkw::P64;
           R3 = _s1jkv::P64;
           R2 = _s1jku::P64;
           R1 = GHC.Real.realToFrac_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kvn: // global
           I64[Hp - 24] = sat_s1jkx_info;
           P64[Hp - 8] = _s1jku::P64;
           P64[Hp] = _s1jkw::P64;
           R2 = _s1jkv::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Real.fromRational_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.563545539 UTC

[section ""data" . GHC.Real.showSigned1_closure" {
     GHC.Real.showSigned1_closure:
         const GHC.Types.C#_con_info;
         const 45;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.565800056 UTC

[section ""data" . GHC.Real.showSigned_closure" {
     GHC.Real.showSigned_closure:
         const GHC.Real.showSigned_info;
         const 0;
 },
 $dNum_s1jkC_entry() //  [R1]
         { info_tbl: [(c1kvx,
                       label: $dNum_s1jkC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kvx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kvy; else goto c1kvz;
       c1kvy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kvz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jkE_entry() //  [R1]
         { info_tbl: [(c1kvE,
                       label: sat_s1jkE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kvE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kvF; else goto c1kvG;
       c1kvF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kvG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jkJ_entry() //  [R1]
         { info_tbl: [(c1kw3,
                       label: sat_s1jkJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kw3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kw4; else goto c1kw5;
       c1kw4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kw5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 g1_s1jkI_entry() //  [R1]
         { info_tbl: [(c1kw6,
                       label: g1_s1jkI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kw6: // global
           _s1jkI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1kw7; else goto c1kw8;
       c1kw8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1kwa; else goto c1kw9;
       c1kwa: // global
           HpAlloc = 32;
           goto c1kw7;
       c1kw7: // global
           R1 = _s1jkI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kw9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jkI::P64;
           _s1jkz::P64 = P64[_s1jkI::P64 + 16];
           _s1jkB::P64 = P64[_s1jkI::P64 + 24];
           _s1jkC::P64 = P64[_s1jkI::P64 + 32];
           I64[Hp - 24] = sat_s1jkJ_info;
           P64[Hp - 8] = _s1jkB::P64;
           P64[Hp] = _s1jkC::P64;
           R2 = Hp - 24;
           R1 = _s1jkz::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jkN_entry() //  [R1, R2]
         { info_tbl: [(c1kwl,
                       label: sat_s1jkN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kwl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1kwp; else goto c1kwo;
       c1kwp: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kwo: // global
           _s1jkI::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _s1jkI::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Real.showSigned1_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jkQ_entry() //  [R1]
         { info_tbl: [(c1kwB,
                       label: sat_s1jkQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kwB: // global
           _s1jkQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1kwC; else goto c1kwD;
       c1kwD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kwF; else goto c1kwE;
       c1kwF: // global
           HpAlloc = 24;
           goto c1kwC;
       c1kwC: // global
           R1 = _s1jkQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kwE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jkQ::P64;
           _s1jkI::P64 = P64[_s1jkQ::P64 + 16];
           _s1jkO::P64 = P64[_s1jkQ::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s1jkO::P64;
           R2 = Hp - 14;
           R1 = _s1jkI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jkS_entry() //  [R1, R2]
         { info_tbl: [(c1kwI,
                       label: sat_s1jkS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kwI: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1kwM; else goto c1kwL;
       c1kwM: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kwL: // global
           _s1jkI::P64 = P64[R1 + 7];
           I64[Hp - 72] = sat_s1jkQ_info;
           P64[Hp - 56] = _s1jkI::P64;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = GHC.Real.showSigned1_closure+1;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.showSigned_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1kwN,
                       label: GHC.Real.showSigned_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kwN: // global
           _s1jkB::P64 = R5;
           _s1jkA::P64 = R4;
           _s1jkz::P64 = R3;
           _s1jky::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto c1kwO; else goto c1kwP;
       c1kwP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1kwR; else goto c1kwQ;
       c1kwR: // global
           HpAlloc = 48;
           goto c1kwO;
       c1kwO: // global
           R5 = _s1jkB::P64;
           R4 = _s1jkA::P64;
           R3 = _s1jkz::P64;
           R2 = _s1jky::P64;
           R1 = GHC.Real.showSigned_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kwQ: // global
           I64[Hp - 40] = $dNum_s1jkC_info;
           P64[Hp - 24] = _s1jky::P64;
           I64[Hp - 16] = sat_s1jkE_info;
           _c1kvt::P64 = Hp - 40;
           P64[Hp] = _c1kvt::P64;
           I64[Sp - 48] = block_c1kvH_info;
           R2 = _s1jky::P64;
           P64[Sp - 40] = _c1kvt::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _s1jkz::P64;
           P64[Sp - 16] = _s1jkA::P64;
           P64[Sp - 8] = _s1jkB::P64;
           Sp = Sp - 48;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kvH() //  [R1]
         { info_tbl: [(c1kvH,
                       label: block_c1kvH_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kvH: // global
           I64[Sp] = block_c1kvL_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1kvL() //  [R1]
         { info_tbl: [(c1kvL,
                       label: block_c1kvL_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kvL: // global
           if (R1 & 7 == 1) goto c1kwW; else goto c1kwY;
       c1kwW: // global
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 24];
           Sp = Sp + 48;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       c1kwY: // global
           I64[Sp] = block_c1kvQ_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1kx6; else goto c1kvR;
       u1kx6: // global
           call _c1kvQ(R1) args: 0, res: 0, upd: 0;
       c1kvR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kvQ() //  [R1]
         { info_tbl: [(c1kvQ,
                       label: block_c1kvQ_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kvQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1kx1; else goto c1kx0;
       c1kx1: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kx0: // global
           _s1jkH::I64 = I64[R1 + 7];
           I64[Hp - 48] = g1_s1jkI_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = P64[Sp + 8];
           _c1kvV::P64 = Hp - 48;
           if (%MO_S_Le_W64(_s1jkH::I64, 6)) goto c1kx3; else goto c1kx4;
       c1kx3: // global
           I64[Hp - 8] = sat_s1jkN_info;
           P64[Hp] = _c1kvV::P64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kx4: // global
           I64[Hp - 8] = sat_s1jkS_info;
           P64[Hp] = _c1kvV::P64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.570577194 UTC

[section ""data" . GHC.Real.even_closure" {
     GHC.Real.even_closure:
         const GHC.Real.even_info;
         const 0;
 },
 $dNum_s1jkW_entry() //  [R1]
         { info_tbl: [(c1kxj,
                       label: $dNum_s1jkW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kxj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kxk; else goto c1kxl;
       c1kxk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kxl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jl1_entry() //  [R1]
         { info_tbl: [(c1kxq,
                       label: sat_s1jl1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kxq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kxr; else goto c1kxs;
       c1kxr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kxs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jkZ_entry() //  [R1]
         { info_tbl: [(c1kxB,
                       label: sat_s1jkZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kxB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kxC; else goto c1kxD;
       c1kxC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kxD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jl0_entry() //  [R1]
         { info_tbl: [(c1kxE,
                       label: sat_s1jl0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kxE: // global
           _s1jl0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1kxF; else goto c1kxG;
       c1kxG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kxI; else goto c1kxH;
       c1kxI: // global
           HpAlloc = 24;
           goto c1kxF;
       c1kxF: // global
           R1 = _s1jl0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kxH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jl0::P64;
           _s1jkT::P64 = P64[_s1jl0::P64 + 16];
           _s1jkU::P64 = P64[_s1jl0::P64 + 24];
           _s1jkW::P64 = P64[_s1jl0::P64 + 32];
           I64[Hp - 16] = sat_s1jkZ_info;
           P64[Hp] = _s1jkW::P64;
           R2 = _s1jkT::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1jkU::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Real.rem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.even_entry() //  [R2, R3]
         { info_tbl: [(c1kxJ,
                       label: GHC.Real.even_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kxJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1kxP; else goto c1kxQ;
       c1kxP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.even_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kxQ: // global
           I64[Sp - 24] = block_c1kxb_info;
           _s1jkT::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1jkT::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kxb() //  [R1]
         { info_tbl: [(c1kxb,
                       label: block_c1kxb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kxb: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1kxT; else goto c1kxS;
       c1kxT: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kxS: // global
           I64[Hp - 80] = $dNum_s1jkW_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_s1jl1_info;
           _c1kxf::P64 = Hp - 80;
           P64[Hp - 40] = _c1kxf::P64;
           I64[Hp - 32] = sat_s1jl0_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _c1kxf::P64;
           I64[Sp] = block_c1kxK_info;
           R2 = R1;
           P64[Sp + 8] = Hp - 32;
           P64[Sp + 16] = Hp - 56;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kxK() //  [R1]
         { info_tbl: [(c1kxK,
                       label: block_c1kxK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kxK: // global
           I64[Sp] = block_c1kxO_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kxO() //  [R1]
         { info_tbl: [(c1kxO,
                       label: block_c1kxO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kxO: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.573416644 UTC

[section ""data" . GHC.Real.odd_closure" {
     GHC.Real.odd_closure:
         const GHC.Real.odd_info;
         const 0;
 },
 GHC.Real.odd_entry() //  [R2, R3]
         { info_tbl: [(c1ky9,
                       label: GHC.Real.odd_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ky9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1kya; else goto c1kyb;
       c1kya: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.odd_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kyb: // global
           I64[Sp - 8] = block_c1ky3_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ky3() //  [R1]
         { info_tbl: [(c1ky3,
                       label: block_c1ky3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ky3: // global
           if (R1 & 7 == 1) goto c1ky6; else goto c1ky7;
       c1ky6: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1ky7: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.574420841 UTC

[section ""data" . lvl3_r1j3b_closure" {
     lvl3_r1j3b_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.even2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.574976904 UTC

[section ""cstring" . lvl4_r1j3c_bytes" {
     lvl4_r1j3c_bytes:
         I8[] [114,111,117,110,100,32,100,101,102,97,117,108,116,32,100,101,102,110,58,32,66,97,100,32,118,97,108,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.575784343 UTC

[section ""data" . GHC.Real.$fRealFracRatio1_closure" {
     GHC.Real.$fRealFracRatio1_closure:
         const GHC.Real.$fRealFracRatio1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fRealFracRatio1_entry() //  [R1]
         { info_tbl: [(c1kyq,
                       label: GHC.Real.$fRealFracRatio1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kyq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1kyr; else goto c1kys;
       c1kyr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kys: // global
           (_c1kyl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1kyl::I64 == 0) goto c1kyn; else goto c1kym;
       c1kyn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1kym: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1kyl::I64;
           I64[Sp - 24] = block_c1kyo_info;
           R2 = lvl4_r1j3c_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kyo() //  [R1]
         { info_tbl: [(c1kyo,
                       label: block_c1kyo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kyo: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.580084933 UTC

[section ""data" . GHC.Real.$dmround_closure" {
     GHC.Real.$dmround_closure:
         const GHC.Real.$dmround_info;
         const 0;
 },
 ds_s1jl9_entry() //  [R1]
         { info_tbl: [(c1kyE,
                       label: ds_s1jl9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kyE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kyF; else goto c1kyG;
       c1kyF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kyG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.properFraction_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $dNum_s1jld_entry() //  [R1]
         { info_tbl: [(c1kyX,
                       label: $dNum_s1jld_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kyX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kyY; else goto c1kyZ;
       c1kyY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kyZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jll_entry() //  [R1]
         { info_tbl: [(c1kzf,
                       label: sat_s1jll_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kzf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kzg; else goto c1kzh;
       c1kzg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kzh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1kzd_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p2RealFrac_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kzd() //  [R1]
         { info_tbl: [(c1kzd,
                       label: block_c1kzd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kzd: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = lvl3_r1j3b_closure+1;
           Sp = Sp - 8;
           call GHC.Real.fromRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlj_entry() //  [R1]
         { info_tbl: [(c1kzp,
                       label: sat_s1jlj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kzp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kzq; else goto c1kzr;
       c1kzq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kzr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlm_entry() //  [R1]
         { info_tbl: [(c1kzs,
                       label: sat_s1jlm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kzs: // global
           _s1jlm::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1kzt; else goto c1kzu;
       c1kzu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1kzw; else goto c1kzv;
       c1kzw: // global
           HpAlloc = 56;
           goto c1kzt;
       c1kzt: // global
           R1 = _s1jlm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kzv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jlm::P64;
           _s1jl6::P64 = P64[_s1jlm::P64 + 16];
           _s1jld::P64 = P64[_s1jlm::P64 + 24];
           _s1jle::P64 = P64[_s1jlm::P64 + 32];
           I64[Hp - 48] = sat_s1jll_info;
           P64[Hp - 32] = _s1jl6::P64;
           I64[Hp - 24] = sat_s1jlj_info;
           P64[Hp - 8] = _s1jld::P64;
           P64[Hp] = _s1jle::P64;
           R2 = _s1jld::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds1_s1jli_entry() //  [R1]
         { info_tbl: [(c1kzx,
                       label: ds1_s1jli_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kzx: // global
           _s1jli::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1kzy; else goto c1kzz;
       c1kzz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1kzB; else goto c1kzA;
       c1kzB: // global
           HpAlloc = 40;
           goto c1kzy;
       c1kzy: // global
           R1 = _s1jli::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kzA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jli::P64;
           _s1jl6::P64 = P64[_s1jli::P64 + 16];
           _s1jld::P64 = P64[_s1jli::P64 + 24];
           _s1jle::P64 = P64[_s1jli::P64 + 32];
           I64[Hp - 32] = sat_s1jlm_info;
           P64[Hp - 16] = _s1jl6::P64;
           P64[Hp - 8] = _s1jld::P64;
           P64[Hp] = _s1jle::P64;
           R2 = _s1jld::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlr_entry() //  [R1]
         { info_tbl: [(c1kzL,
                       label: sat_s1jlr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kzL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kzM; else goto c1kzN;
       c1kzM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kzN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jls_entry() //  [R1]
         { info_tbl: [(c1kzO,
                       label: sat_s1jls_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kzO: // global
           _s1jls::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1kzP; else goto c1kzQ;
       c1kzQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kzS; else goto c1kzR;
       c1kzS: // global
           HpAlloc = 24;
           goto c1kzP;
       c1kzP: // global
           R1 = _s1jls::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kzR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jls::P64;
           _s1jld::P64 = P64[_s1jls::P64 + 16];
           I64[Hp - 16] = sat_s1jlr_info;
           P64[Hp] = _s1jld::P64;
           R2 = _s1jld::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlB_entry() //  [R1]
         { info_tbl: [(c1kA1,
                       label: sat_s1jlB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kA1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kA2; else goto c1kA3;
       c1kA2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kA3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlx_entry() //  [R1]
         { info_tbl: [(c1kAl,
                       label: sat_s1jlx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kAl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kAm; else goto c1kAn;
       c1kAm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kAn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlz_entry() //  [R1]
         { info_tbl: [(c1kAw,
                       label: sat_s1jlz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kAw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kAx; else goto c1kAy;
       c1kAx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kAy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlA_entry() //  [R1]
         { info_tbl: [(c1kAF,
                       label: sat_s1jlA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kAF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kAG; else goto c1kAH;
       c1kAG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kAH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlD_entry() //  [R1]
         { info_tbl: [(c1kAQ,
                       label: sat_s1jlD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kAQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kAR; else goto c1kAS;
       c1kAR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kAS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmround_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kAT,
                       label: GHC.Real.$dmround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kAT: // global
           _s1jl8::P64 = R4;
           _s1jl7::P64 = R3;
           _s1jl6::P64 = R2;
           if ((Sp + -88) < SpLim) (likely: False) goto c1kAU; else goto c1kAV;
       c1kAV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1kAX; else goto c1kAW;
       c1kAX: // global
           HpAlloc = 40;
           goto c1kAU;
       c1kAU: // global
           R4 = _s1jl8::P64;
           R3 = _s1jl7::P64;
           R2 = _s1jl6::P64;
           R1 = GHC.Real.$dmround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kAW: // global
           I64[Hp - 32] = ds_s1jl9_info;
           P64[Hp - 16] = _s1jl6::P64;
           P64[Hp - 8] = _s1jl7::P64;
           P64[Hp] = _s1jl8::P64;
           I64[Sp - 32] = block_c1kyH_info;
           R2 = _s1jl6::P64;
           P64[Sp - 24] = Hp - 32;
           P64[Sp - 16] = _s1jl6::P64;
           P64[Sp - 8] = _s1jl7::P64;
           Sp = Sp - 32;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kyH() //  [R1]
         { info_tbl: [(c1kyH,
                       label: block_c1kyH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kyH: // global
           I64[Sp - 8] = block_c1kyL_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kyL() //  [R1]
         { info_tbl: [(c1kyL,
                       label: block_c1kyL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kyL: // global
           I64[Sp - 8] = block_c1kyP_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kyP() //  [R1]
         { info_tbl: [(c1kyP,
                       label: block_c1kyP_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kyP: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c1kB2; else goto c1kB1;
       c1kB2: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kB1: // global
           I64[Hp - 128] = $dNum_s1jld_info;
           P64[Hp - 112] = P64[Sp + 16];
           I64[Hp - 104] = stg_sel_1_upd_info;
           _c1kyA::P64 = P64[Sp + 24];
           P64[Hp - 88] = _c1kyA::P64;
           I64[Hp - 80] = ds1_s1jli_info;
           P64[Hp - 64] = P64[Sp + 32];
           _c1kyT::P64 = Hp - 128;
           P64[Hp - 56] = _c1kyT::P64;
           _c1kz0::P64 = Hp - 104;
           P64[Hp - 48] = _c1kz0::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1kyA::P64;
           I64[Hp - 16] = sat_s1jls_info;
           P64[Hp] = _c1kyT::P64;
           I64[Sp - 16] = block_c1kzT_info;
           R2 = R1;
           I64[Sp - 40] = stg_ap_pp_info;
           _c1kz1::P64 = Hp - 80;
           P64[Sp - 32] = _c1kz1::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 40;
           P64[Sp + 16] = _c1kz1::P64;
           P64[Sp + 24] = _c1kz0::P64;
           P64[Sp + 32] = _c1kyT::P64;
           Sp = Sp - 40;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1kzT() //  [R1]
         { info_tbl: [(c1kzT,
                       label: block_c1kzT_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kzT: // global
           if (R1 & 7 == 1) goto c1kB4; else goto u1kC0;
       c1kB4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kB7; else goto c1kB6;
       c1kB7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kB6: // global
           I64[Hp - 16] = sat_s1jlB_info;
           P64[Hp] = P64[Sp + 48];
           I64[Sp] = block_c1kAI_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       u1kC0: // global
           Sp = Sp + 16;
           call _c1kBU() args: 0, res: 0, upd: 0;
     }
 },
 _c1kAI() //  [R1]
         { info_tbl: [(c1kAI,
                       label: block_c1kAI_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kAI: // global
           if (R1 & 7 == 1) goto c1kBo; else goto c1kBG;
       c1kBo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kBr; else goto c1kBq;
       c1kBr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kBq: // global
           I64[Hp - 16] = sat_s1jlD_info;
           P64[Hp] = P64[Sp + 48];
           _s1jlc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1kBm_info;
           R2 = _s1jlc::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c1kBG: // global
           I64[Sp + 8] = block_c1kBE_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 56];
           Sp = Sp + 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kBm() //  [R1]
         { info_tbl: [(c1kBm,
                       label: block_c1kBm_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kBm: // global
           if (R1 & 7 == 1) goto c1kBx; else goto u1kC3;
       c1kBx: // global
           R1 = GHC.Real.$fRealFracRatio1_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       u1kC3: // global
           Sp = Sp + 8;
           call _s1jlu() args: 0, res: 0, upd: 0;
     }
 },
 _c1kBE() //  [R1]
         { info_tbl: [(c1kBE,
                       label: block_c1kBE_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kBE: // global
           if (R1 & 7 == 1) goto u1kC1; else goto u1kC2;
       u1kC1: // global
           Sp = Sp + 8;
           call _s1jlu() args: 0, res: 0, upd: 0;
       u1kC2: // global
           Sp = Sp + 8;
           call _c1kBU() args: 0, res: 0, upd: 0;
     }
 },
 _s1jlu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jlu: // global
           I64[Sp - 8] = block_c1kA9_info;
           R2 = P64[Sp + 40];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kA9() //  [R1]
         { info_tbl: [(c1kA9,
                       label: block_c1kA9_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kA9: // global
           I64[Sp] = block_c1kAd_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kAd() //  [R1]
         { info_tbl: [(c1kAd,
                       label: block_c1kAd_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kAd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kBc; else goto c1kBb;
       c1kBc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kBb: // global
           I64[Hp - 16] = sat_s1jlx_info;
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_c1kAo_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 48] = R1;
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1kAo() //  [R1]
         { info_tbl: [(c1kAo,
                       label: block_c1kAo_info
                       rep:StackRep [False, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kAo: // global
           _c1kzC::P64 = P64[Sp + 8];
           _s1jlw::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto c1kBe; else goto c1kBi;
       c1kBe: // global
           Hp = Hp + 24;
           _s1jly::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1kBl; else goto c1kBg;
       c1kBg: // global
           I64[Hp - 16] = sat_s1jlz_info;
           P64[Hp] = _s1jlw::P64;
           R2 = _s1jlw::P64;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = _c1kzC::P64;
           P64[Sp + 48] = Hp - 16;
           Sp = Sp + 32;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
       c1kBi: // global
           Hp = Hp + 24;
           _s1jly::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1kBl; else goto c1kBk;
       c1kBl: // global
           HpAlloc = 24;
           R1 = _s1jly::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kBk: // global
           I64[Hp - 16] = sat_s1jlA_info;
           P64[Hp] = _s1jlw::P64;
           R2 = _s1jlw::P64;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = _c1kzC::P64;
           P64[Sp + 48] = Hp - 16;
           Sp = Sp + 32;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _c1kBU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kBU: // global
           R1 = P64[Sp];
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.591043683 UTC

[section ""data" . GHC.Real.integralEnumFrom_closure" {
     GHC.Real.integralEnumFrom_closure:
         const GHC.Real.integralEnumFrom_info;
         const 0;
 },
 f_s1jlJ_entry() //  [R1]
         { info_tbl: [(c1kCg,
                       label: f_s1jlJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kCg: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jlK_entry() //  [R1]
         { info_tbl: [(c1kCn,
                       label: f1_s1jlK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kCn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kCo; else goto c1kCp;
       c1kCo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kCp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jlM_entry() //  [R1]
         { info_tbl: [(c1kCu,
                       label: sat_s1jlM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kCu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kCv; else goto c1kCw;
       c1kCv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kCw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jlS_entry() //  [R1]
         { info_tbl: [(c1kCQ,
                       label: sat_s1jlS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kCQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kCR; else goto c1kCS;
       c1kCR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kCS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1kCO_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kCO() //  [R1]
         { info_tbl: [(c1kCO,
                       label: block_c1kCO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kCO: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jlN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jlQ_entry() //  [R1]
         { info_tbl: [(c1kD0,
                       label: sat_s1jlQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kD0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kD1; else goto c1kD2;
       c1kD1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kD2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jlN_entry() //  [R1, R2]
         { info_tbl: [(c1kD6,
                       label: go_s1jlN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kD6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kD7; else goto c1kD8;
       c1kD7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kD8: // global
           I64[Sp - 32] = block_c1kCG_info;
           R3 = P64[R1 + 15];
           _s1jlO::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jlO::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kCG() //  [R1]
         { info_tbl: [(c1kCG,
                       label: block_c1kCG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kCG: // global
           if (R1 == 1) goto c1kD5; else goto c1kD4;
       c1kD5: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kD4: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1kDc; else goto c1kDb;
       c1kDc: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1kDb: // global
           I64[Hp - 80] = sat_s1jlS_info;
           P64[Hp - 64] = P64[Sp + 16];
           _s1jlO::P64 = P64[Sp + 24];
           P64[Hp - 56] = _s1jlO::P64;
           I64[Hp - 48] = sat_s1jlQ_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s1jlO::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1kDt_srtd" {
     u1kDt_srtd:
         const S1jKw_srt+480;
         const 34;
         const 8589935105;
 },
 GHC.Real.integralEnumFrom_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kDg,
                       label: GHC.Real.integralEnumFrom_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kDg: // global
           _s1jlI::P64 = R4;
           _s1jlH::P64 = R3;
           _s1jlG::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1kDi; else goto c1kDj;
       c1kDj: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1kDl; else goto c1kDk;
       c1kDl: // global
           HpAlloc = 72;
           goto c1kDi;
       c1kDi: // global
           R4 = _s1jlI::P64;
           R3 = _s1jlH::P64;
           R2 = _s1jlG::P64;
           R1 = GHC.Real.integralEnumFrom_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kDk: // global
           I64[Hp - 64] = f_s1jlJ_info;
           P64[Hp - 48] = _s1jlG::P64;
           I64[Hp - 40] = f1_s1jlK_info;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = sat_s1jlM_info;
           P64[Hp] = _s1jlH::P64;
           I64[Sp - 32] = block_c1kCx_info;
           R2 = _s1jlG::P64;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = _s1jlG::P64;
           P64[Sp - 8] = _s1jlI::P64;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kCx() //  [R1]
         { info_tbl: [(c1kCx,
                       label: block_c1kCx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kCx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kDo; else goto c1kDn;
       c1kDo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kDn: // global
           I64[Hp - 16] = go_s1jlN_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           _s1jlG::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1kDh_info;
           R2 = _s1jlG::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 15;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kDh() //  [R1]
         { info_tbl: [(c1kDh,
                       label: block_c1kDh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kDh: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jlN_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.599485801 UTC

[section ""data" . GHC.Real.integralEnumFromThen_closure" {
     GHC.Real.integralEnumFromThen_closure:
         const GHC.Real.integralEnumFromThen_info;
         const 0;
 },
 f_s1jm2_entry() //  [R1]
         { info_tbl: [(c1kDS,
                       label: f_s1jm2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kDS: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jm3_entry() //  [R1]
         { info_tbl: [(c1kDZ,
                       label: f1_s1jm3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kDZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kE0; else goto c1kE1;
       c1kE0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kE1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jm6_entry() //  [R1]
         { info_tbl: [(c1kEa,
                       label: sat_s1jm6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kEa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kEb; else goto c1kEc;
       c1kEb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kEc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmc_entry() //  [R1]
         { info_tbl: [(c1kEw,
                       label: sat_s1jmc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kEw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kEx; else goto c1kEy;
       c1kEx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kEy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1kEu_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kEu() //  [R1]
         { info_tbl: [(c1kEu,
                       label: block_c1kEu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kEu: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jm7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jma_entry() //  [R1]
         { info_tbl: [(c1kEG,
                       label: sat_s1jma_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kEG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kEH; else goto c1kEI;
       c1kEH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kEI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jm7_entry() //  [R1, R2]
         { info_tbl: [(c1kEM,
                       label: go_s1jm7_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kEM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kEN; else goto c1kEO;
       c1kEN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kEO: // global
           I64[Sp - 40] = block_c1kEm_info;
           R3 = P64[R1 + 23];
           _s1jm8::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jm8::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kEm() //  [R1]
         { info_tbl: [(c1kEm,
                       label: block_c1kEm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kEm: // global
           if (R1 == 1) goto c1kEL; else goto c1kEK;
       c1kEL: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kEK: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1kES; else goto c1kER;
       c1kES: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1kER: // global
           I64[Hp - 88] = sat_s1jmc_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jm8::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jm8::P64;
           I64[Hp - 48] = sat_s1jma_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jm8::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jme_entry() //  [R1]
         { info_tbl: [(c1kF2,
                       label: sat_s1jme_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kF2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kF3; else goto c1kF4;
       c1kF3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kF4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmk_entry() //  [R1]
         { info_tbl: [(c1kFo,
                       label: sat_s1jmk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kFo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kFp; else goto c1kFq;
       c1kFp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kFq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1kFm_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kFm() //  [R1]
         { info_tbl: [(c1kFm,
                       label: block_c1kFm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kFm: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmf_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmi_entry() //  [R1]
         { info_tbl: [(c1kFy,
                       label: sat_s1jmi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kFy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kFz; else goto c1kFA;
       c1kFz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kFA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jmf_entry() //  [R1, R2]
         { info_tbl: [(c1kFE,
                       label: go_s1jmf_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kFE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kFF; else goto c1kFG;
       c1kFF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kFG: // global
           I64[Sp - 40] = block_c1kFe_info;
           R3 = P64[R1 + 23];
           _s1jmg::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jmg::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kFe() //  [R1]
         { info_tbl: [(c1kFe,
                       label: block_c1kFe_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kFe: // global
           if (R1 == 1) goto c1kFD; else goto c1kFC;
       c1kFD: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kFC: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1kFK; else goto c1kFJ;
       c1kFK: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1kFJ: // global
           I64[Hp - 88] = sat_s1jmk_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jmg::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jmg::P64;
           I64[Hp - 48] = sat_s1jmi_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jmg::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 f_s1jmm_entry() //  [R1]
         { info_tbl: [(c1kFY,
                       label: f_s1jmm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kFY: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jmn_entry() //  [R1]
         { info_tbl: [(c1kG5,
                       label: f1_s1jmn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kG5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kG6; else goto c1kG7;
       c1kG6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kG7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmq_entry() //  [R1]
         { info_tbl: [(c1kGg,
                       label: sat_s1jmq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kGg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kGh; else goto c1kGi;
       c1kGh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kGi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmw_entry() //  [R1]
         { info_tbl: [(c1kGC,
                       label: sat_s1jmw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kGC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kGD; else goto c1kGE;
       c1kGD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kGE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1kGA_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kGA() //  [R1]
         { info_tbl: [(c1kGA,
                       label: block_c1kGA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kGA: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmr_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmu_entry() //  [R1]
         { info_tbl: [(c1kGM,
                       label: sat_s1jmu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kGM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kGN; else goto c1kGO;
       c1kGN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kGO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jmr_entry() //  [R1, R2]
         { info_tbl: [(c1kGS,
                       label: go_s1jmr_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kGS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kGT; else goto c1kGU;
       c1kGT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kGU: // global
           I64[Sp - 40] = block_c1kGs_info;
           R3 = P64[R1 + 23];
           _s1jms::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jms::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kGs() //  [R1]
         { info_tbl: [(c1kGs,
                       label: block_c1kGs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kGs: // global
           if (R1 == 1) goto c1kGR; else goto c1kGQ;
       c1kGR: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kGQ: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1kGY; else goto c1kGX;
       c1kGY: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1kGX: // global
           I64[Hp - 88] = sat_s1jmw_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jms::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jms::P64;
           I64[Hp - 48] = sat_s1jmu_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jms::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jmy_entry() //  [R1]
         { info_tbl: [(c1kH8,
                       label: sat_s1jmy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kH8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kH9; else goto c1kHa;
       c1kH9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kHa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmE_entry() //  [R1]
         { info_tbl: [(c1kHu,
                       label: sat_s1jmE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kHu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kHv; else goto c1kHw;
       c1kHv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kHw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1kHs_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kHs() //  [R1]
         { info_tbl: [(c1kHs,
                       label: block_c1kHs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kHs: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmC_entry() //  [R1]
         { info_tbl: [(c1kHE,
                       label: sat_s1jmC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kHE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kHF; else goto c1kHG;
       c1kHF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kHG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jmz_entry() //  [R1, R2]
         { info_tbl: [(c1kHK,
                       label: go_s1jmz_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kHK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kHL; else goto c1kHM;
       c1kHL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kHM: // global
           I64[Sp - 40] = block_c1kHk_info;
           R3 = P64[R1 + 23];
           _s1jmA::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jmA::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kHk() //  [R1]
         { info_tbl: [(c1kHk,
                       label: block_c1kHk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kHk: // global
           if (R1 == 1) goto c1kHJ; else goto c1kHI;
       c1kHJ: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kHI: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1kHQ; else goto c1kHP;
       c1kHQ: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1kHP: // global
           I64[Hp - 88] = sat_s1jmE_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jmA::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jmA::P64;
           I64[Hp - 48] = sat_s1jmC_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jmA::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1kIE_srtd" {
     u1kIE_srtd:
         const S1jKw_srt+456;
         const 39;
         const 412585295873;
 },
 GHC.Real.integralEnumFromThen_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1kHU,
                       label: GHC.Real.integralEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kHU: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1kHV; else goto c1kHW;
       c1kHV: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.integralEnumFromThen_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kHW: // global
           I64[Sp - 32] = block_c1kDy_info;
           _s1jlU::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s1jlU::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kIF_srtd" {
     u1kIF_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1kDy() //  [R1]
         { info_tbl: [(c1kDy,
                       label: block_c1kDy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kDy: // global
           I64[Sp] = block_c1kDC_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kIG_srtd" {
     u1kIG_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1kDC() //  [R1]
         { info_tbl: [(c1kDC,
                       label: block_c1kDC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kDC: // global
           I64[Sp - 8] = block_c1kDG_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kIH_srtd" {
     u1kIH_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1kDG() //  [R1]
         { info_tbl: [(c1kDG,
                       label: block_c1kDG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kDG: // global
           _s1jlY::P64 = P64[Sp + 32];
           _s1jlZ::P64 = P64[Sp + 8];
           if (R1 == 1) goto c1kIl; else goto c1kI1;
       c1kIl: // global
           I64[Sp] = block_c1kFQ_info;
           R3 = _s1jlZ::P64;
           R2 = _s1jlY::P64;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       c1kI1: // global
           I64[Sp] = block_c1kDK_info;
           R3 = _s1jlZ::P64;
           R2 = _s1jlY::P64;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kFQ() //  [R1]
         { info_tbl: [(c1kFQ,
                       label: block_c1kFQ_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kFQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1kIo; else goto c1kIn;
       c1kIo: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kIn: // global
           I64[Hp - 40] = f_s1jmm_info;
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = f1_s1jmn_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_c1kG8_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp] = R1;
           P64[Sp + 32] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kG8() //  [R1]
         { info_tbl: [(c1kG8,
                       label: block_c1kG8_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kG8: // global
           _s1jlU::P64 = P64[Sp + 24];
           _s1jlV::P64 = P64[Sp + 32];
           if (R1 == 1) goto c1kIx; else goto c1kIq;
       c1kIx: // global
           Hp = Hp + 24;
           _s1jmo::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1kIA; else goto c1kIz;
       c1kIz: // global
           I64[Hp - 16] = sat_s1jmy_info;
           P64[Hp] = _s1jlV::P64;
           I64[Sp] = block_c1kHb_info;
           R2 = _s1jlU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c1kIq: // global
           Hp = Hp + 24;
           _s1jmo::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1kIA; else goto c1kIs;
       c1kIA: // global
           HpAlloc = 24;
           R1 = _s1jmo::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1kIs: // global
           I64[Hp - 16] = sat_s1jmq_info;
           P64[Hp] = _s1jlV::P64;
           I64[Sp] = block_c1kGj_info;
           R2 = _s1jlU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kHb() //  [R1]
         { info_tbl: [(c1kHb,
                       label: block_c1kHb_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kHb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1kID; else goto c1kIC;
       c1kID: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kIC: // global
           I64[Hp - 24] = go_s1jmz_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jmz_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1kGj() //  [R1]
         { info_tbl: [(c1kGj,
                       label: block_c1kGj_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kGj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1kIw; else goto c1kIv;
       c1kIw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kIv: // global
           I64[Hp - 24] = go_s1jmr_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jmr_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1kDK() //  [R1]
         { info_tbl: [(c1kDK,
                       label: block_c1kDK_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kDK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1kI4; else goto c1kI3;
       c1kI4: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kI3: // global
           I64[Hp - 40] = f_s1jm2_info;
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = f1_s1jm3_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_c1kE2_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp] = R1;
           P64[Sp + 32] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kE2() //  [R1]
         { info_tbl: [(c1kE2,
                       label: block_c1kE2_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kE2: // global
           _s1jlU::P64 = P64[Sp + 24];
           _s1jlV::P64 = P64[Sp + 32];
           if (R1 == 1) goto c1kId; else goto c1kI6;
       c1kId: // global
           Hp = Hp + 24;
           _s1jm4::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1kIg; else goto c1kIf;
       c1kIf: // global
           I64[Hp - 16] = sat_s1jme_info;
           P64[Hp] = _s1jlV::P64;
           I64[Sp] = block_c1kF5_info;
           R2 = _s1jlU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c1kI6: // global
           Hp = Hp + 24;
           _s1jm4::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1kIg; else goto c1kI8;
       c1kIg: // global
           HpAlloc = 24;
           R1 = _s1jm4::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1kI8: // global
           I64[Hp - 16] = sat_s1jm6_info;
           P64[Hp] = _s1jlV::P64;
           I64[Sp] = block_c1kEd_info;
           R2 = _s1jlU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kF5() //  [R1]
         { info_tbl: [(c1kF5,
                       label: block_c1kF5_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kF5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1kIj; else goto c1kIi;
       c1kIj: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kIi: // global
           I64[Hp - 24] = go_s1jmf_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jmf_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1kEd() //  [R1]
         { info_tbl: [(c1kEd,
                       label: block_c1kEd_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kEd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1kIc; else goto c1kIb;
       c1kIc: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kIb: // global
           I64[Hp - 24] = go_s1jm7_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jm7_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.611883695 UTC

[section ""data" . GHC.Real.integralEnumFromTo_closure" {
     GHC.Real.integralEnumFromTo_closure:
         const GHC.Real.integralEnumFromTo_info;
         const 0;
 },
 f_s1jmI_entry() //  [R1]
         { info_tbl: [(c1kIQ,
                       label: f_s1jmI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kIQ: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jmJ_entry() //  [R1]
         { info_tbl: [(c1kIX,
                       label: f1_s1jmJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kIX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kIY; else goto c1kIZ;
       c1kIY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kIZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmQ_entry() //  [R1]
         { info_tbl: [(c1kJj,
                       label: sat_s1jmQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kJj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kJk; else goto c1kJl;
       c1kJk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kJl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1kJh_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kJh() //  [R1]
         { info_tbl: [(c1kJh,
                       label: block_c1kJh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kJh: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmL_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmO_entry() //  [R1]
         { info_tbl: [(c1kJt,
                       label: sat_s1jmO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kJt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kJu; else goto c1kJv;
       c1kJu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kJv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jmL_entry() //  [R1, R2]
         { info_tbl: [(c1kJz,
                       label: go_s1jmL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kJz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kJA; else goto c1kJB;
       c1kJA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kJB: // global
           I64[Sp - 32] = block_c1kJ9_info;
           R3 = P64[R1 + 15];
           _s1jmM::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jmM::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kJ9() //  [R1]
         { info_tbl: [(c1kJ9,
                       label: block_c1kJ9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kJ9: // global
           if (R1 == 1) goto c1kJy; else goto c1kJx;
       c1kJy: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kJx: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1kJF; else goto c1kJE;
       c1kJF: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1kJE: // global
           I64[Hp - 80] = sat_s1jmQ_info;
           P64[Hp - 64] = P64[Sp + 16];
           _s1jmM::P64 = P64[Sp + 24];
           P64[Hp - 56] = _s1jmM::P64;
           I64[Hp - 48] = sat_s1jmO_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s1jmM::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.integralEnumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kJJ,
                       label: GHC.Real.integralEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kJJ: // global
           _s1jmH::P64 = R4;
           _s1jmG::P64 = R3;
           _s1jmF::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1kJL; else goto c1kJM;
       c1kJM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1kJO; else goto c1kJN;
       c1kJO: // global
           HpAlloc = 48;
           goto c1kJL;
       c1kJL: // global
           R4 = _s1jmH::P64;
           R3 = _s1jmG::P64;
           R2 = _s1jmF::P64;
           R1 = GHC.Real.integralEnumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kJN: // global
           I64[Hp - 40] = f_s1jmI_info;
           P64[Hp - 24] = _s1jmF::P64;
           I64[Hp - 16] = f1_s1jmJ_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 32] = block_c1kJ0_info;
           R2 = _s1jmF::P64;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = _s1jmH::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _s1jmF::P64;
           P64[Sp - 8] = _s1jmG::P64;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kJ0() //  [R1]
         { info_tbl: [(c1kJ0,
                       label: block_c1kJ0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kJ0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kJR; else goto c1kJQ;
       c1kJR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kJQ: // global
           I64[Hp - 16] = go_s1jmL_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           _s1jmF::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1kJK_info;
           R2 = _s1jmF::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 15;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kJK() //  [R1]
         { info_tbl: [(c1kJK,
                       label: block_c1kJK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kJK: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmL_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.617352675 UTC

[section ""data" . GHC.Real.integralEnumFromThenTo_closure" {
     GHC.Real.integralEnumFromThenTo_closure:
         const GHC.Real.integralEnumFromThenTo_info;
         const 0;
 },
 f_s1jmZ_entry() //  [R1]
         { info_tbl: [(c1kKg,
                       label: f_s1jmZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kKg: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jn0_entry() //  [R1]
         { info_tbl: [(c1kKn,
                       label: f1_s1jn0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kKn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kKo; else goto c1kKp;
       c1kKo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kKp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jn8_entry() //  [R1]
         { info_tbl: [(c1kKN,
                       label: sat_s1jn8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kKN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kKO; else goto c1kKP;
       c1kKO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kKP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1kKL_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kKL() //  [R1]
         { info_tbl: [(c1kKL,
                       label: block_c1kKL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kKL: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jn3_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jn6_entry() //  [R1]
         { info_tbl: [(c1kKX,
                       label: sat_s1jn6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kKX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kKY; else goto c1kKZ;
       c1kKY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kKZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jn3_entry() //  [R1, R2]
         { info_tbl: [(c1kL3,
                       label: go_s1jn3_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kL3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kL4; else goto c1kL5;
       c1kL4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kL5: // global
           I64[Sp - 40] = block_c1kKD_info;
           R3 = P64[R1 + 23];
           _s1jn4::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jn4::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kKD() //  [R1]
         { info_tbl: [(c1kKD,
                       label: block_c1kKD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kKD: // global
           if (R1 == 1) goto c1kL2; else goto c1kL1;
       c1kL2: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kL1: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1kL9; else goto c1kL8;
       c1kL9: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1kL8: // global
           I64[Hp - 88] = sat_s1jn8_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jn4::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jn4::P64;
           I64[Hp - 48] = sat_s1jn6_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jn4::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jnf_entry() //  [R1]
         { info_tbl: [(c1kLy,
                       label: sat_s1jnf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kLy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kLz; else goto c1kLA;
       c1kLz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kLA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1kLw_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kLw() //  [R1]
         { info_tbl: [(c1kLw,
                       label: block_c1kLw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kLw: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jna_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jnd_entry() //  [R1]
         { info_tbl: [(c1kLI,
                       label: sat_s1jnd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kLI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kLJ; else goto c1kLK;
       c1kLJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kLK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jna_entry() //  [R1, R2]
         { info_tbl: [(c1kLO,
                       label: go_s1jna_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kLO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kLP; else goto c1kLQ;
       c1kLP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kLQ: // global
           I64[Sp - 40] = block_c1kLo_info;
           R3 = P64[R1 + 23];
           _s1jnb::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jnb::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kLo() //  [R1]
         { info_tbl: [(c1kLo,
                       label: block_c1kLo_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kLo: // global
           if (R1 == 1) goto c1kLN; else goto c1kLM;
       c1kLN: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kLM: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1kLU; else goto c1kLT;
       c1kLU: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1kLT: // global
           I64[Hp - 88] = sat_s1jnf_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jnb::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jnb::P64;
           I64[Hp - 48] = sat_s1jnd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jnb::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1kMh_srtd" {
     u1kMh_srtd:
         const S1jKw_srt+456;
         const 41;
         const 1237219016705;
 },
 GHC.Real.integralEnumFromThenTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1kLY,
                       label: GHC.Real.integralEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kLY: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1kLZ; else goto c1kM0;
       c1kLZ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.integralEnumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kM0: // global
           I64[Sp - 32] = block_c1kK0_info;
           _s1jmS::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = R3;
           P64[Sp - 24] = _s1jmS::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kMi_srtd" {
     u1kMi_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1kK0() //  [R1]
         { info_tbl: [(c1kK0,
                       label: block_c1kK0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kK0: // global
           I64[Sp] = block_c1kK4_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kMj_srtd" {
     u1kMj_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1kK4() //  [R1]
         { info_tbl: [(c1kK4,
                       label: block_c1kK4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kK4: // global
           I64[Sp] = block_c1kK8_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kK8() //  [R1]
         { info_tbl: [(c1kK8,
                       label: block_c1kK8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kK8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1kM5; else goto c1kM4;
       c1kM5: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kM4: // global
           I64[Hp - 40] = f_s1jmZ_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = f1_s1jn0_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 16] = block_c1kKq_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kKq() //  [R1]
         { info_tbl: [(c1kKq,
                       label: block_c1kKq_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kKq: // global
           _s1jmS::P64 = P64[Sp + 24];
           _s1jmV::P64 = P64[Sp + 40];
           if (R1 == 1) goto c1kMd; else goto c1kM8;
       c1kMd: // global
           I64[Sp] = block_c1kLf_info;
           R2 = _s1jmS::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s1jmV::P64;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c1kM8: // global
           I64[Sp] = block_c1kKu_info;
           R2 = _s1jmS::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s1jmV::P64;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kLf() //  [R1]
         { info_tbl: [(c1kLf,
                       label: block_c1kLf_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kLf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1kMg; else goto c1kMf;
       c1kMg: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kMf: // global
           I64[Hp - 24] = go_s1jna_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = P64[Sp + 32];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jna_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1kKu() //  [R1]
         { info_tbl: [(c1kKu,
                       label: block_c1kKu_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kKu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1kMb; else goto c1kMa;
       c1kMb: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kMa: // global
           I64[Hp - 24] = go_s1jn3_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = P64[Sp + 32];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jn3_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.624464284 UTC

[section ""cstring" . GHC.Real.$trModule4_bytes" {
     GHC.Real.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.625071352 UTC

[section ""data" . GHC.Real.$trModule3_closure" {
     GHC.Real.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.625635099 UTC

[section ""cstring" . GHC.Real.$trModule2_bytes" {
     GHC.Real.$trModule2_bytes:
         I8[] [71,72,67,46,82,101,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.626183731 UTC

[section ""data" . GHC.Real.$trModule1_closure" {
     GHC.Real.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.626740884 UTC

[section ""data" . GHC.Real.$trModule_closure" {
     GHC.Real.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Real.$trModule3_closure+1;
         const GHC.Real.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.627310128 UTC

[section ""data" . $krep_r1j3d_closure" {
     $krep_r1j3d_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.62788428 UTC

[section ""data" . $krep1_r1j3e_closure" {
     $krep1_r1j3e_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.628451429 UTC

[section ""data" . GHC.Real.$tcFractional1_closure" {
     GHC.Real.$tcFractional1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep1_r1j3e_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.629046823 UTC

[section ""data" . $krep2_r1j3f_closure" {
     $krep2_r1j3f_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.629681523 UTC

[section ""data" . $krep3_r1j3g_closure" {
     $krep3_r1j3g_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep2_r1j3f_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.630250239 UTC

[section ""data" . $krep4_r1j3h_closure" {
     $krep4_r1j3h_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep3_r1j3g_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.630833789 UTC

[section ""data" . $krep5_r1j3i_closure" {
     $krep5_r1j3i_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep_r1j3d_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.6313948 UTC

[section ""data" . $krep6_r1j3j_closure" {
     $krep6_r1j3j_closure:
         const :_con_info;
         const $krep2_r1j3f_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.631923317 UTC

[section ""data" . $krep7_r1j3k_closure" {
     $krep7_r1j3k_closure:
         const :_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.632509581 UTC

[section ""data" . $krep8_r1j3l_closure" {
     $krep8_r1j3l_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep7_r1j3k_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.633125315 UTC

[section ""data" . $krep9_r1j3m_closure" {
     $krep9_r1j3m_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep8_r1j3l_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.633732391 UTC

[section ""data" . $krep10_r1j3n_closure" {
     $krep10_r1j3n_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep9_r1j3m_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.634329784 UTC

[section ""data" . $krep11_r1j3o_closure" {
     $krep11_r1j3o_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Num.$tcNum_closure;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.634906977 UTC

[section ""data" . $krep12_r1j3p_closure" {
     $krep12_r1j3p_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Enum.$tcEnum_closure;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.635524408 UTC

[section ""data" . $krep13_r1j3q_closure" {
     $krep13_r1j3q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Classes.$tcOrd_closure;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.636082562 UTC

[section ""cstring" . GHC.Real.$tcRatio2_bytes" {
     GHC.Real.$tcRatio2_bytes:
         I8[] [82,97,116,105,111]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.63663781 UTC

[section ""data" . GHC.Real.$tcRatio1_closure" {
     GHC.Real.$tcRatio1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcRatio2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.637179017 UTC

[section ""data" . GHC.Real.$tcRatio_closure" {
     GHC.Real.$tcRatio_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcRatio1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 17658523810845794968;
         const 1271393732863050253;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.637863357 UTC

[section ""data" . $krep14_r1j3r_closure" {
     $krep14_r1j3r_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcRatio_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.638446884 UTC

[section ""data" . $krep15_r1j3s_closure" {
     $krep15_r1j3s_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep14_r1j3r_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.639062795 UTC

[section ""data" . GHC.Real.$tc':%1_closure" {
     GHC.Real.$tc':%1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep15_r1j3s_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.63964803 UTC

[section ""cstring" . GHC.Real.$tc':%3_bytes" {
     GHC.Real.$tc':%3_bytes:
         I8[] [39,58,37]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.640183955 UTC

[section ""data" . GHC.Real.$tc':%2_closure" {
     GHC.Real.$tc':%2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc':%3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.640759423 UTC

[section ""data" . GHC.Real.$tc':%_closure" {
     GHC.Real.$tc':%_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc':%2_closure+1;
         const GHC.Real.$tc':%1_closure+4;
         const 11952989868638128372;
         const 6861245286732044789;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.64150721 UTC

[section ""data" . $krep16_r1j3t_closure" {
     $krep16_r1j3t_closure:
         const :_con_info;
         const $krep_r1j3d_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.64203966 UTC

[section ""data" . $krep17_r1j3u_closure" {
     $krep17_r1j3u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcRatio_closure+1;
         const $krep16_r1j3t_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.642553018 UTC

[section ""data" . $krep18_r1j3v_closure" {
     $krep18_r1j3v_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep17_r1j3u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.643121939 UTC

[section ""data" . $krep19_r1j3w_closure" {
     $krep19_r1j3w_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep17_r1j3u_closure+1;
         const $krep2_r1j3f_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.643692236 UTC

[section ""cstring" . GHC.Real.$tcReal2_bytes" {
     GHC.Real.$tcReal2_bytes:
         I8[] [82,101,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.644239038 UTC

[section ""data" . GHC.Real.$tcReal1_closure" {
     GHC.Real.$tcReal1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcReal2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.644834558 UTC

[section ""data" . GHC.Real.$tcReal_closure" {
     GHC.Real.$tcReal_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcReal1_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 1826502536394630182;
         const 14487785779892251413;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.645469308 UTC

[section ""data" . $krep20_r1j3x_closure" {
     $krep20_r1j3x_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcReal_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.646068085 UTC

[section ""data" . $krep21_r1j3y_closure" {
     $krep21_r1j3y_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep18_r1j3v_closure+4;
         const $krep20_r1j3x_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.646653092 UTC

[section ""data" . $krep22_r1j3z_closure" {
     $krep22_r1j3z_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_r1j3q_closure+1;
         const $krep21_r1j3y_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.64726643 UTC

[section ""data" . GHC.Real.$tc'C:Real1_closure" {
     GHC.Real.$tc'C:Real1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1j3o_closure+1;
         const $krep22_r1j3z_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.647819179 UTC

[section ""cstring" . GHC.Real.$tc'C:Real3_bytes" {
     GHC.Real.$tc'C:Real3_bytes:
         I8[] [39,67,58,82,101,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.648407382 UTC

[section ""data" . GHC.Real.$tc'C:Real2_closure" {
     GHC.Real.$tc'C:Real2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc'C:Real3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.649979661 UTC

[section ""data" . GHC.Real.$tc'C:Real_closure" {
     GHC.Real.$tc'C:Real_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc'C:Real2_closure+1;
         const GHC.Real.$tc'C:Real1_closure+4;
         const 5938283050841830427;
         const 8926187074226767634;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.650601779 UTC

[section ""cstring" . GHC.Real.$tcIntegral2_bytes" {
     GHC.Real.$tcIntegral2_bytes:
         I8[] [73,110,116,101,103,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.651140236 UTC

[section ""data" . GHC.Real.$tcIntegral1_closure" {
     GHC.Real.$tcIntegral1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcIntegral2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.651715437 UTC

[section ""data" . GHC.Real.$tcIntegral_closure" {
     GHC.Real.$tcIntegral_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcIntegral1_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 16601157811546713973;
         const 3304955164956033666;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.65231641 UTC

[section ""data" . $krep23_r1j3A_closure" {
     $krep23_r1j3A_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcIntegral_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.65286152 UTC

[section ""data" . $krep24_r1j3B_closure" {
     $krep24_r1j3B_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r1j3i_closure+4;
         const $krep23_r1j3A_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.653656776 UTC

[section ""data" . $krep25_r1j3C_closure" {
     $krep25_r1j3C_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_r1j3n_closure+4;
         const $krep24_r1j3B_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.654210731 UTC

[section ""data" . $krep26_r1j3D_closure" {
     $krep26_r1j3D_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_r1j3n_closure+4;
         const $krep25_r1j3C_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.654787707 UTC

[section ""data" . $krep27_r1j3E_closure" {
     $krep27_r1j3E_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep26_r1j3D_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.655352503 UTC

[section ""data" . $krep28_r1j3F_closure" {
     $krep28_r1j3F_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep27_r1j3E_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.655890285 UTC

[section ""data" . $krep29_r1j3G_closure" {
     $krep29_r1j3G_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep28_r1j3F_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.656477587 UTC

[section ""data" . $krep30_r1j3H_closure" {
     $krep30_r1j3H_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep29_r1j3G_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.657032841 UTC

[section ""data" . $krep31_r1j3I_closure" {
     $krep31_r1j3I_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_r1j3p_closure+1;
         const $krep30_r1j3H_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.657633193 UTC

[section ""data" . GHC.Real.$tc'C:Integral1_closure" {
     GHC.Real.$tc'C:Integral1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep20_r1j3x_closure+1;
         const $krep31_r1j3I_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.658191419 UTC

[section ""cstring" . GHC.Real.$tc'C:Integral3_bytes" {
     GHC.Real.$tc'C:Integral3_bytes:
         I8[] [39,67,58,73,110,116,101,103,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.658729102 UTC

[section ""data" . GHC.Real.$tc'C:Integral2_closure" {
     GHC.Real.$tc'C:Integral2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc'C:Integral3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.659269507 UTC

[section ""data" . GHC.Real.$tc'C:Integral_closure" {
     GHC.Real.$tc'C:Integral_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc'C:Integral2_closure+1;
         const GHC.Real.$tc'C:Integral1_closure+4;
         const 12141017740256829283;
         const 17564033539811245778;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.659870164 UTC

[section ""cstring" . GHC.Real.$tcFractional3_bytes" {
     GHC.Real.$tcFractional3_bytes:
         I8[] [70,114,97,99,116,105,111,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.660403944 UTC

[section ""data" . GHC.Real.$tcFractional2_closure" {
     GHC.Real.$tcFractional2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcFractional3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.660910847 UTC

[section ""data" . GHC.Real.$tcFractional_closure" {
     GHC.Real.$tcFractional_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcFractional2_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 14968870971062750857;
         const 13774835939651899219;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.661584178 UTC

[section ""data" . $krep32_r1j3J_closure" {
     $krep32_r1j3J_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcFractional_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.662145708 UTC

[section ""data" . $krep33_r1j3K_closure" {
     $krep33_r1j3K_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep19_r1j3w_closure+4;
         const $krep32_r1j3J_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.662700828 UTC

[section ""data" . $krep34_r1j3L_closure" {
     $krep34_r1j3L_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r1j3g_closure+4;
         const $krep33_r1j3K_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.663251032 UTC

[section ""data" . $krep35_r1j3M_closure" {
     $krep35_r1j3M_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep34_r1j3L_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.663781541 UTC

[section ""data" . GHC.Real.$tc'C:Fractional1_closure" {
     GHC.Real.$tc'C:Fractional1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1j3o_closure+1;
         const $krep35_r1j3M_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.664364171 UTC

[section ""cstring" . GHC.Real.$tc'C:Fractional3_bytes" {
     GHC.Real.$tc'C:Fractional3_bytes:
         I8[] [39,67,58,70,114,97,99,116,105,111,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.664883325 UTC

[section ""data" . GHC.Real.$tc'C:Fractional2_closure" {
     GHC.Real.$tc'C:Fractional2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc'C:Fractional3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.665468085 UTC

[section ""data" . GHC.Real.$tc'C:Fractional_closure" {
     GHC.Real.$tc'C:Fractional_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc'C:Fractional2_closure+1;
         const GHC.Real.$tc'C:Fractional1_closure+4;
         const 15706435530565718930;
         const 11021884564355505453;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.666070615 UTC

[section ""cstring" . GHC.Real.$tcRealFrac2_bytes" {
     GHC.Real.$tcRealFrac2_bytes:
         I8[] [82,101,97,108,70,114,97,99]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.666576761 UTC

[section ""data" . GHC.Real.$tcRealFrac1_closure" {
     GHC.Real.$tcRealFrac1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcRealFrac2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.667088351 UTC

[section ""data" . GHC.Real.$tcRealFrac_closure" {
     GHC.Real.$tcRealFrac_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcRealFrac1_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 2318913099678420819;
         const 6373121509494083706;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.668599577 UTC

[section ""data" . GHC.Real.$w$c<_closure" {
     GHC.Real.$w$c<_closure:
         const GHC.Real.$w$c<_info;
 },
 $dNum_s1jnm_entry() //  [R1]
         { info_tbl: [(c1kMw,
                       label: $dNum_s1jnm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kMw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kMx; else goto c1kMy;
       c1kMx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kMy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jnp_entry() //  [R1]
         { info_tbl: [(c1kMD,
                       label: sat_s1jnp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kMD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kME; else goto c1kMF;
       c1kME: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kMF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jno_entry() //  [R1]
         { info_tbl: [(c1kMK,
                       label: sat_s1jno_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kMK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kML; else goto c1kMM;
       c1kML: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kMM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1kMN,
                       label: GHC.Real.$w$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kMN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kMP; else goto c1kMQ;
       c1kMP: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kMQ: // global
           I64[Sp - 40] = block_c1kMo_info;
           R2 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kMo() //  [R1]
         { info_tbl: [(c1kMo,
                       label: block_c1kMo_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kMo: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c1kMT; else goto c1kMS;
       c1kMT: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kMS: // global
           I64[Hp - 96] = $dNum_s1jnm_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s1jnp_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           _c1kMs::P64 = Hp - 96;
           P64[Hp - 40] = _c1kMs::P64;
           I64[Hp - 32] = sat_s1jno_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _c1kMs::P64;
           I64[Sp + 16] = block_c1kMO_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kMO() //  [R1]
         { info_tbl: [(c1kMO,
                       label: block_c1kMO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kMO: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.<_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.67106011 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c<_closure" {
     GHC.Real.$fOrdRatio_$c<_closure:
         const GHC.Real.$fOrdRatio_$c<_info;
 },
 GHC.Real.$fOrdRatio_$c<_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kN5,
                       label: GHC.Real.$fOrdRatio_$c<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kN5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kN9; else goto c1kNa;
       c1kN9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kNa: // global
           I64[Sp - 24] = block_c1kN2_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1kNi; else goto c1kN3;
       u1kNi: // global
           call _c1kN2(R1) args: 0, res: 0, upd: 0;
       c1kN3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kN2() //  [R1]
         { info_tbl: [(c1kN2,
                       label: block_c1kN2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kN2: // global
           I64[Sp - 8] = block_c1kN8_info;
           _s1jnu::P64 = P64[R1 + 7];
           _s1jnv::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jnv::P64;
           P64[Sp + 16] = _s1jnu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kNh; else goto c1kNc;
       u1kNh: // global
           call _c1kN8(R1) args: 0, res: 0, upd: 0;
       c1kNc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kN8() //  [R1]
         { info_tbl: [(c1kN8,
                       label: block_c1kN8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kN8: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.673076176 UTC

[section ""data" . GHC.Real.$w$c<=_closure" {
     GHC.Real.$w$c<=_closure:
         const GHC.Real.$w$c<=_info;
 },
 $dNum_s1jnF_entry() //  [R1]
         { info_tbl: [(c1kNv,
                       label: $dNum_s1jnF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kNv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kNw; else goto c1kNx;
       c1kNw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kNx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jnI_entry() //  [R1]
         { info_tbl: [(c1kNC,
                       label: sat_s1jnI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kNC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kND; else goto c1kNE;
       c1kND: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kNE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jnH_entry() //  [R1]
         { info_tbl: [(c1kNJ,
                       label: sat_s1jnH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kNJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kNK; else goto c1kNL;
       c1kNK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kNL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1kNM,
                       label: GHC.Real.$w$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kNM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kNO; else goto c1kNP;
       c1kNO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kNP: // global
           I64[Sp - 40] = block_c1kNn_info;
           R2 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kNn() //  [R1]
         { info_tbl: [(c1kNn,
                       label: block_c1kNn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kNn: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c1kNS; else goto c1kNR;
       c1kNS: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kNR: // global
           I64[Hp - 96] = $dNum_s1jnF_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s1jnI_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           _c1kNr::P64 = Hp - 96;
           P64[Hp - 40] = _c1kNr::P64;
           I64[Hp - 32] = sat_s1jnH_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _c1kNr::P64;
           I64[Sp + 16] = block_c1kNN_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kNN() //  [R1]
         { info_tbl: [(c1kNN,
                       label: block_c1kNN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kNN: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.<=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.675465101 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c<=_closure" {
     GHC.Real.$fOrdRatio_$c<=_closure:
         const GHC.Real.$fOrdRatio_$c<=_info;
 },
 GHC.Real.$fOrdRatio_$c<=_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kO4,
                       label: GHC.Real.$fOrdRatio_$c<=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kO4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kO8; else goto c1kO9;
       c1kO8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kO9: // global
           I64[Sp - 24] = block_c1kO1_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1kOh; else goto c1kO2;
       u1kOh: // global
           call _c1kO1(R1) args: 0, res: 0, upd: 0;
       c1kO2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kO1() //  [R1]
         { info_tbl: [(c1kO1,
                       label: block_c1kO1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kO1: // global
           I64[Sp - 8] = block_c1kO7_info;
           _s1jnN::P64 = P64[R1 + 7];
           _s1jnO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jnO::P64;
           P64[Sp + 16] = _s1jnN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kOg; else goto c1kOb;
       u1kOg: // global
           call _c1kO7(R1) args: 0, res: 0, upd: 0;
       c1kOb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kO7() //  [R1]
         { info_tbl: [(c1kO7,
                       label: block_c1kO7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kO7: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.677236177 UTC

[section ""data" . GHC.Real.$fOrdRatio_$cmax_closure" {
     GHC.Real.$fOrdRatio_$cmax_closure:
         const GHC.Real.$fOrdRatio_$cmax_info;
 },
 GHC.Real.$fOrdRatio_$cmax_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kOp,
                       label: GHC.Real.$fOrdRatio_$cmax_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kOp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kOt; else goto c1kOu;
       c1kOt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kOu: // global
           I64[Sp - 24] = block_c1kOm_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1kOO; else goto c1kOn;
       u1kOO: // global
           call _c1kOm(R1) args: 0, res: 0, upd: 0;
       c1kOn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kOm() //  [R1]
         { info_tbl: [(c1kOm,
                       label: block_c1kOm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kOm: // global
           I64[Sp - 16] = block_c1kOs_info;
           _s1jnV::P64 = R1;
           _s1jnW::P64 = P64[R1 + 7];
           _s1jnX::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s1jnX::P64;
           P64[Sp] = _s1jnW::P64;
           P64[Sp + 16] = _s1jnV::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kON; else goto c1kOw;
       u1kON: // global
           call _c1kOs(R1) args: 0, res: 0, upd: 0;
       c1kOw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kOs() //  [R1]
         { info_tbl: [(c1kOs,
                       label: block_c1kOs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kOs: // global
           _s1jnW::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1kOA_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jnW::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kOA() //  [R1]
         { info_tbl: [(c1kOA,
                       label: block_c1kOA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kOA: // global
           if (R1 & 7 == 1) goto c1kOH; else goto c1kOL;
       c1kOH: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1kOL: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.680690715 UTC

[section ""data" . GHC.Real.$fOrdRatio_$cmin_closure" {
     GHC.Real.$fOrdRatio_$cmin_closure:
         const GHC.Real.$fOrdRatio_$cmin_info;
 },
 GHC.Real.$fOrdRatio_$cmin_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kOW,
                       label: GHC.Real.$fOrdRatio_$cmin_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kOW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kP0; else goto c1kP1;
       c1kP0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kP1: // global
           I64[Sp - 24] = block_c1kOT_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1kPl; else goto c1kOU;
       u1kPl: // global
           call _c1kOT(R1) args: 0, res: 0, upd: 0;
       c1kOU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kOT() //  [R1]
         { info_tbl: [(c1kOT,
                       label: block_c1kOT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kOT: // global
           I64[Sp - 16] = block_c1kOZ_info;
           _s1jo5::P64 = R1;
           _s1jo6::P64 = P64[R1 + 7];
           _s1jo7::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s1jo7::P64;
           P64[Sp] = _s1jo6::P64;
           P64[Sp + 16] = _s1jo5::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kPk; else goto c1kP3;
       u1kPk: // global
           call _c1kOZ(R1) args: 0, res: 0, upd: 0;
       c1kP3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kOZ() //  [R1]
         { info_tbl: [(c1kOZ,
                       label: block_c1kOZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kOZ: // global
           _s1jo6::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1kP7_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jo6::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kP7() //  [R1]
         { info_tbl: [(c1kP7,
                       label: block_c1kP7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kP7: // global
           if (R1 & 7 == 1) goto c1kPe; else goto c1kPi;
       c1kPe: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1kPi: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.683053503 UTC

[section ""data" . GHC.Real.$w$ccompare_closure" {
     GHC.Real.$w$ccompare_closure:
         const GHC.Real.$w$ccompare_info;
 },
 GHC.Real.$w$ccompare_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1kPs,
                       label: GHC.Real.$w$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kPs: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c1kPA; else goto c1kPB;
       c1kPA: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kPB: // global
           I64[Sp - 48] = block_c1kPq_info;
           _s1joc::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = _s1joc::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kPq() //  [R1]
         { info_tbl: [(c1kPq,
                       label: block_c1kPq_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kPq: // global
           I64[Sp] = block_c1kPv_info;
           R2 = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kPv() //  [R1]
         { info_tbl: [(c1kPv,
                       label: block_c1kPv_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kPv: // global
           I64[Sp] = block_c1kPz_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kPz() //  [R1]
         { info_tbl: [(c1kPz,
                       label: block_c1kPz_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kPz: // global
           I64[Sp - 8] = block_c1kPH_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1kPH() //  [R1]
         { info_tbl: [(c1kPH,
                       label: block_c1kPH_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kPH: // global
           _s1joe::P64 = P64[Sp + 32];
           _s1jog::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto c1kPP; else goto c1kQ4;
       c1kPP: // global
           I64[Sp + 48] = block_c1kPM_info;
           R6 = _s1jog::P64;
           R5 = P64[Sp + 40];
           R4 = _s1joe::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 48;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
       c1kQ4: // global
           _s1joj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1kQ2_info;
           R2 = _s1joj::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s1joe::P64;
           P64[Sp] = _s1jog::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1kPM() //  [R1]
         { info_tbl: [(c1kPM,
                       label: block_c1kPM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kPM: // global
           if (R1 & 7 == 1) goto u1kQw; else goto u1kQx;
       u1kQw: // global
           Sp = Sp + 8;
           call _c1kQh() args: 0, res: 0, upd: 0;
       u1kQx: // global
           Sp = Sp + 8;
           call _c1kQl() args: 0, res: 0, upd: 0;
     }
 },
 _c1kQ2() //  [R1]
         { info_tbl: [(c1kQ2,
                       label: block_c1kQ2_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kQ2: // global
           if (R1 & 7 == 1) goto c1kQb; else goto c1kQp;
       c1kQb: // global
           _s1jog::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_c1kQ8_info;
           R6 = _s1jog::P64;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
       c1kQp: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1kQ8() //  [R1]
         { info_tbl: [(c1kQ8,
                       label: block_c1kQ8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kQ8: // global
           if (R1 & 7 == 1) goto u1kQu; else goto u1kQv;
       u1kQu: // global
           Sp = Sp + 8;
           call _c1kQh() args: 0, res: 0, upd: 0;
       u1kQv: // global
           Sp = Sp + 8;
           call _c1kQl() args: 0, res: 0, upd: 0;
     }
 },
 _c1kQh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kQh: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1kQl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kQl: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.686116485 UTC

[section ""data" . GHC.Real.$fOrdRatio_$ccompare_closure" {
     GHC.Real.$fOrdRatio_$ccompare_closure:
         const GHC.Real.$fOrdRatio_$ccompare_info;
 },
 GHC.Real.$fOrdRatio_$ccompare_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kQJ,
                       label: GHC.Real.$fOrdRatio_$ccompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kQJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kQN; else goto c1kQO;
       c1kQN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kQO: // global
           I64[Sp - 24] = block_c1kQG_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1kQW; else goto c1kQH;
       u1kQW: // global
           call _c1kQG(R1) args: 0, res: 0, upd: 0;
       c1kQH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kQG() //  [R1]
         { info_tbl: [(c1kQG,
                       label: block_c1kQG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kQG: // global
           I64[Sp - 8] = block_c1kQM_info;
           _s1jos::P64 = P64[R1 + 7];
           _s1jot::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jot::P64;
           P64[Sp + 16] = _s1jos::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kQV; else goto c1kQQ;
       u1kQV: // global
           call _c1kQM(R1) args: 0, res: 0, upd: 0;
       c1kQQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kQM() //  [R1]
         { info_tbl: [(c1kQM,
                       label: block_c1kQM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kQM: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.687821137 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c>_closure" {
     GHC.Real.$fOrdRatio_$c>_closure:
         const GHC.Real.$fOrdRatio_$c>_info;
 },
 GHC.Real.$fOrdRatio_$c>_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kR4,
                       label: GHC.Real.$fOrdRatio_$c>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kR4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kR8; else goto c1kR9;
       c1kR8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kR9: // global
           I64[Sp - 24] = block_c1kR1_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1kRt; else goto c1kR2;
       u1kRt: // global
           call _c1kR1(R1) args: 0, res: 0, upd: 0;
       c1kR2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kR1() //  [R1]
         { info_tbl: [(c1kR1,
                       label: block_c1kR1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kR1: // global
           I64[Sp - 8] = block_c1kR7_info;
           _s1joB::P64 = P64[R1 + 7];
           _s1joC::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1joC::P64;
           P64[Sp + 16] = _s1joB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kRs; else goto c1kRb;
       u1kRs: // global
           call _c1kR7(R1) args: 0, res: 0, upd: 0;
       c1kRb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kR7() //  [R1]
         { info_tbl: [(c1kR7,
                       label: block_c1kR7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kR7: // global
           _s1joB::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1kRf_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1joB::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kRf() //  [R1]
         { info_tbl: [(c1kRf,
                       label: block_c1kRf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kRf: // global
           if (R1 & 7 == 3) goto c1kRq; else goto c1kRm;
       c1kRq: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kRm: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.689720474 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c>=_closure" {
     GHC.Real.$fOrdRatio_$c>=_closure:
         const GHC.Real.$fOrdRatio_$c>=_info;
 },
 GHC.Real.$fOrdRatio_$c>=_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kRB,
                       label: GHC.Real.$fOrdRatio_$c>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kRB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kRF; else goto c1kRG;
       c1kRF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kRG: // global
           I64[Sp - 24] = block_c1kRy_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1kS0; else goto c1kRz;
       u1kS0: // global
           call _c1kRy(R1) args: 0, res: 0, upd: 0;
       c1kRz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kRy() //  [R1]
         { info_tbl: [(c1kRy,
                       label: block_c1kRy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kRy: // global
           I64[Sp - 8] = block_c1kRE_info;
           _s1joL::P64 = P64[R1 + 7];
           _s1joM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1joM::P64;
           P64[Sp + 16] = _s1joL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1kRZ; else goto c1kRI;
       u1kRZ: // global
           call _c1kRE(R1) args: 0, res: 0, upd: 0;
       c1kRI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kRE() //  [R1]
         { info_tbl: [(c1kRE,
                       label: block_c1kRE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kRE: // global
           _s1joL::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1kRM_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1joL::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kRM() //  [R1]
         { info_tbl: [(c1kRM,
                       label: block_c1kRM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kRM: // global
           if (R1 & 7 == 1) goto c1kRX; else goto c1kRT;
       c1kRX: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1kRT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.692229915 UTC

[section ""data" . GHC.Real.$fOrdRatio_closure" {
     GHC.Real.$fOrdRatio_closure:
         const GHC.Real.$fOrdRatio_info;
 },
 sat_s1joZ_entry() //  [R1, R2, R3]
         { info_tbl: [(c1kSa,
                       label: sat_s1joZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kSa: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joY_entry() //  [R1, R2, R3]
         { info_tbl: [(c1kSi,
                       label: sat_s1joY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kSi: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joX_entry() //  [R1, R2, R3]
         { info_tbl: [(c1kSq,
                       label: sat_s1joX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kSq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joW_entry() //  [R1, R2, R3]
         { info_tbl: [(c1kSy,
                       label: sat_s1joW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kSy: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c>_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joV_entry() //  [R1, R2, R3]
         { info_tbl: [(c1kSG,
                       label: sat_s1joV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kSG: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joU_entry() //  [R1, R2, R3]
         { info_tbl: [(c1kSO,
                       label: sat_s1joU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kSO: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joT_entry() //  [R1, R2, R3]
         { info_tbl: [(c1kSW,
                       label: sat_s1joT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kSW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joS_entry() //  [R1]
         { info_tbl: [(c1kT3,
                       label: sat_s1joS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kT3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kT4; else goto c1kT5;
       c1kT4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kT5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fOrdRatio_entry() //  [R2]
         { info_tbl: [(c1kT7,
                       label: GHC.Real.$fOrdRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kT7: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c1kTb; else goto c1kTa;
       c1kTb: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1kTa: // global
           I64[Hp - 200] = sat_s1joZ_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s1joY_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s1joX_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1joW_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s1joV_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s1joU_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s1joT_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s1joS_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.695030818 UTC

[section ""data" . GHC.Real.$fNumRatio_$cnegate_closure" {
     GHC.Real.$fNumRatio_$cnegate_closure:
         const GHC.Real.$fNumRatio_$cnegate_info;
 },
 GHC.Real.$fNumRatio_$cnegate_entry() //  [R2, R3]
         { info_tbl: [(c1kTj,
                       label: GHC.Real.$fNumRatio_$cnegate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kTj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kTx; else goto c1kTy;
       c1kTx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$cnegate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kTy: // global
           I64[Sp - 16] = block_c1kTg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kTF; else goto c1kTh;
       u1kTF: // global
           call _c1kTg(R1) args: 0, res: 0, upd: 0;
       c1kTh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kTg() //  [R1]
         { info_tbl: [(c1kTg,
                       label: block_c1kTg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kTg: // global
           I64[Sp - 8] = block_c1kTm_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kTm() //  [R1]
         { info_tbl: [(c1kTm,
                       label: block_c1kTm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kTm: // global
           I64[Sp] = block_c1kTq_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kTq() //  [R1]
         { info_tbl: [(c1kTq,
                       label: block_c1kTq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kTq: // global
           I64[Sp] = block_c1kTu_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kTu() //  [R1]
         { info_tbl: [(c1kTu,
                       label: block_c1kTu_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kTu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kTE; else goto c1kTD;
       c1kTE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kTD: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.696905952 UTC

[section ""data" . GHC.Real.$fNumRatio_$cabs_closure" {
     GHC.Real.$fNumRatio_$cabs_closure:
         const GHC.Real.$fNumRatio_$cabs_info;
 },
 GHC.Real.$fNumRatio_$cabs_entry() //  [R2, R3]
         { info_tbl: [(c1kTN,
                       label: GHC.Real.$fNumRatio_$cabs_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kTN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kU1; else goto c1kU2;
       c1kU1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$cabs_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kU2: // global
           I64[Sp - 16] = block_c1kTK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kU9; else goto c1kTL;
       u1kU9: // global
           call _c1kTK(R1) args: 0, res: 0, upd: 0;
       c1kTL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kTK() //  [R1]
         { info_tbl: [(c1kTK,
                       label: block_c1kTK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kTK: // global
           I64[Sp - 8] = block_c1kTQ_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kTQ() //  [R1]
         { info_tbl: [(c1kTQ,
                       label: block_c1kTQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kTQ: // global
           I64[Sp] = block_c1kTU_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kTU() //  [R1]
         { info_tbl: [(c1kTU,
                       label: block_c1kTU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kTU: // global
           I64[Sp] = block_c1kTY_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kTY() //  [R1]
         { info_tbl: [(c1kTY,
                       label: block_c1kTY_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kTY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kU8; else goto c1kU7;
       c1kU8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kU7: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.698671674 UTC

[section ""data" . GHC.Real.$w$csignum_closure" {
     GHC.Real.$w$csignum_closure:
         const GHC.Real.$w$csignum_info;
         const 0;
 },
 GHC.Real.$w$csignum_entry() //  [R2, R3]
         { info_tbl: [(c1kUg,
                       label: GHC.Real.$w$csignum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kUg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kUq; else goto c1kUr;
       c1kUq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$csignum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kUr: // global
           I64[Sp - 16] = block_c1kUe_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kUe() //  [R1]
         { info_tbl: [(c1kUe,
                       label: block_c1kUe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kUe: // global
           I64[Sp] = block_c1kUj_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kUj() //  [R1]
         { info_tbl: [(c1kUj,
                       label: block_c1kUj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kUj: // global
           I64[Sp] = block_c1kUn_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kUn() //  [R1]
         { info_tbl: [(c1kUn,
                       label: block_c1kUn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kUn: // global
           I64[Sp] = block_c1kUp_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Real.$fEnumRatio1_closure;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kUp() //  [R1]
         { info_tbl: [(c1kUp,
                       label: block_c1kUp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kUp: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.700336925 UTC

[section ""data" . GHC.Real.$fNumRatio_$csignum_closure" {
     GHC.Real.$fNumRatio_$csignum_closure:
         const GHC.Real.$fNumRatio_$csignum_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$csignum_entry() //  [R2, R3]
         { info_tbl: [(c1kUE,
                       label: GHC.Real.$fNumRatio_$csignum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kUE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kUK; else goto c1kUL;
       c1kUK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$csignum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kUL: // global
           I64[Sp - 16] = block_c1kUB_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kUQ; else goto c1kUC;
       u1kUQ: // global
           call _c1kUB(R1) args: 0, res: 0, upd: 0;
       c1kUC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kUB() //  [R1]
         { info_tbl: [(c1kUB,
                       label: block_c1kUB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kUB: // global
           _s1jpm::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1kUH_info;
           R3 = P64[R1 + 7];
           R2 = _s1jpm::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$csignum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kUH() //  [R1, R2]
         { info_tbl: [(c1kUH,
                       label: block_c1kUH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kUH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kUP; else goto c1kUO;
       c1kUP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kUO: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.701927558 UTC

[section ""data" . GHC.Real.$w$cfromInteger_closure" {
     GHC.Real.$w$cfromInteger_closure:
         const GHC.Real.$w$cfromInteger_info;
         const 0;
 },
 GHC.Real.$w$cfromInteger_entry() //  [R2, R3]
         { info_tbl: [(c1kUX,
                       label: GHC.Real.$w$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kUX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kV7; else goto c1kV8;
       c1kV7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cfromInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kV8: // global
           I64[Sp - 16] = block_c1kUV_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kUV() //  [R1]
         { info_tbl: [(c1kUV,
                       label: block_c1kUV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kUV: // global
           I64[Sp] = block_c1kV0_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kV0() //  [R1]
         { info_tbl: [(c1kV0,
                       label: block_c1kV0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kV0: // global
           I64[Sp] = block_c1kV4_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kV4() //  [R1]
         { info_tbl: [(c1kV4,
                       label: block_c1kV4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kV4: // global
           I64[Sp] = block_c1kV6_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Real.$fEnumRatio1_closure;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kV6() //  [R1]
         { info_tbl: [(c1kV6,
                       label: block_c1kV6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kV6: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.703514734 UTC

[section ""data" . GHC.Real.$fNumRatio_$cfromInteger_closure" {
     GHC.Real.$fNumRatio_$cfromInteger_closure:
         const GHC.Real.$fNumRatio_$cfromInteger_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$cfromInteger_entry() //  [R2, R3]
         { info_tbl: [(c1kVl,
                       label: GHC.Real.$fNumRatio_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kVl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1kVm; else goto c1kVn;
       c1kVm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$cfromInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kVn: // global
           I64[Sp - 8] = block_c1kVi_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kVi() //  [R1, R2]
         { info_tbl: [(c1kVi,
                       label: block_c1kVi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kVi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kVq; else goto c1kVp;
       c1kVq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kVp: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.704646622 UTC

[section ""data" . GHC.Real.$fRealRatio_$s$ctoRational_closure" {
     GHC.Real.$fRealRatio_$s$ctoRational_closure:
         const GHC.Real.$fRealRatio_$s$ctoRational_info;
 },
 GHC.Real.$fRealRatio_$s$ctoRational_entry() //  [R2]
         { info_tbl: [(c1kVv,
                       label: GHC.Real.$fRealRatio_$s$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kVv: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.706360028 UTC

[section ""data" . GHC.Real.$fRealRatio_$ctoRational_closure" {
     GHC.Real.$fRealRatio_$ctoRational_closure:
         const GHC.Real.$fRealRatio_$ctoRational_info;
 },
 GHC.Real.$fRealRatio_$ctoRational_entry() //  [R2, R3]
         { info_tbl: [(c1kVF,
                       label: GHC.Real.$fRealRatio_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kVF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kVR; else goto c1kVS;
       c1kVR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealRatio_$ctoRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kVS: // global
           I64[Sp - 16] = block_c1kVC_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kVY; else goto c1kVD;
       u1kVY: // global
           call _c1kVC(R1) args: 0, res: 0, upd: 0;
       c1kVD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kVC() //  [R1]
         { info_tbl: [(c1kVC,
                       label: block_c1kVC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kVC: // global
           I64[Sp - 8] = block_c1kVI_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kVI() //  [R1]
         { info_tbl: [(c1kVI,
                       label: block_c1kVI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kVI: // global
           _s1jpK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1kVM_info;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = _s1jpK::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 8;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kVM() //  [R1]
         { info_tbl: [(c1kVM,
                       label: block_c1kVM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kVM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kVX; else goto c1kVW;
       c1kVX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kVW: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.708891779 UTC

[section ""data" . GHC.Real.$w$crecip_closure" {
     GHC.Real.$w$crecip_closure:
         const GHC.Real.$w$crecip_info;
         const 0;
 },
 $dNum_s1jpR_entry() //  [R1]
         { info_tbl: [(c1kWb,
                       label: $dNum_s1jpR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kWb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kWc; else goto c1kWd;
       c1kWc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kWd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jpU_entry() //  [R1]
         { info_tbl: [(c1kWm,
                       label: sat_s1jpU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kWm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kWn; else goto c1kWo;
       c1kWn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kWo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jpW_entry() //  [R1]
         { info_tbl: [(c1kWB,
                       label: sat_s1jpW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kWB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kWC; else goto c1kWD;
       c1kWC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kWD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1kXg_srtd" {
     u1kXg_srtd:
         const S1jKw_srt+296;
         const 66;
         const 281474976710657;
         const 2;
 },
 GHC.Real.$w$crecip_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kWE,
                       label: GHC.Real.$w$crecip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kWE: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1kWF; else goto c1kWG;
       c1kWF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$crecip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kWG: // global
           I64[Sp - 24] = block_c1kW3_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kXh_srtd" {
     u1kXh_srtd:
         const S1jKw_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1kW3() //  [R1]
         { info_tbl: [(c1kW3,
                       label: block_c1kW3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kW3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kWJ; else goto c1kWI;
       c1kWJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kWI: // global
           I64[Hp - 16] = $dNum_s1jpR_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1kWe_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kXi_srtd" {
     u1kXi_srtd:
         const S1jKw_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1kWe() //  [R1]
         { info_tbl: [(c1kWe,
                       label: block_c1kWe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kWe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kWM; else goto c1kWL;
       c1kWM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kWL: // global
           I64[Hp - 16] = sat_s1jpU_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = block_c1kWp_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kXj_srtd" {
     u1kXj_srtd:
         const S1jKw_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1kWp() //  [R1]
         { info_tbl: [(c1kWp,
                       label: block_c1kWp_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kWp: // global
           I64[Sp] = block_c1kWt_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1kXk_srtd" {
     u1kXk_srtd:
         const S1jKw_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1kWt() //  [R1]
         { info_tbl: [(c1kWt,
                       label: block_c1kWt_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kWt: // global
           if (R1 & 7 == 1) goto c1kWQ; else goto c1kXd;
       c1kWQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kWT; else goto c1kWS;
       c1kWT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1kWS: // global
           I64[Hp - 16] = sat_s1jpW_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 16] = block_c1kWO_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 32];
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
       c1kXd: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1kWO() //  [R1]
         { info_tbl: [(c1kWO,
                       label: block_c1kWO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kWO: // global
           _s1jpP::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c1kWZ; else goto c1kX6;
       c1kWZ: // global
           R2 = P64[Sp + 16];
           R1 = _s1jpP::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c1kX6: // global
           I64[Sp] = block_c1kX2_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s1jpP::P64;
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kX2() //  [R1]
         { info_tbl: [(c1kX2,
                       label: block_c1kX2_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kX2: // global
           _s1jpO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1kX4_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = _s1jpO::P64;
           P64[Sp + 24] = R1;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1kX4() //  [R1]
         { info_tbl: [(c1kX4,
                       label: block_c1kX4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kX4: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.71402092 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$crecip_closure" {
     GHC.Real.$fFractionalRatio_$crecip_closure:
         const GHC.Real.$fFractionalRatio_$crecip_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$crecip_entry() //  [R2, R3]
         { info_tbl: [(c1kXs,
                       label: GHC.Real.$fFractionalRatio_$crecip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kXs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kXy; else goto c1kXz;
       c1kXy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$crecip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kXz: // global
           I64[Sp - 16] = block_c1kXp_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kXE; else goto c1kXq;
       u1kXE: // global
           call _c1kXp(R1) args: 0, res: 0, upd: 0;
       c1kXq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kXp() //  [R1]
         { info_tbl: [(c1kXp,
                       label: block_c1kXp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kXp: // global
           _s1jq1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1kXv_info;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = _s1jq1::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$crecip_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kXv() //  [R1, R2]
         { info_tbl: [(c1kXv,
                       label: block_c1kXv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kXv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kXD; else goto c1kXC;
       c1kXD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kXC: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.716393406 UTC

[section ""data" . GHC.Real.$w$s$cproperFraction_closure" {
     GHC.Real.$w$s$cproperFraction_closure:
         const GHC.Real.$w$s$cproperFraction_info;
         const 0;
 },
 section ""relreadonly" . u1kYU_srtd" {
     u1kYU_srtd:
         const S1jKw_srt+424;
         const 33;
         const 4294967297;
 },
 ds_s1jqc_entry() //  [R1]
         { info_tbl: [(c1kXS,
                       label: ds_s1jqc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kXS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kXT; else goto c1kXU;
       c1kXT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kXU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c1kXN_info;
           R3 = GHC.Real.even1_closure;
           _s1jqb::P64 = P64[R1 + 24];
           R2 = _s1jqb::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s1jqb::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kXN() //  [R1]
         { info_tbl: [(c1kXN,
                       label: block_c1kXN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kXN: // global
           if (R1 == 1) goto c1kXR; else goto c1kXQ;
       c1kXR: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c1kXQ: // global
           _s1jqb::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1kXX_info;
           R3 = _s1jqb::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kXX() //  [R1, R2]
         { info_tbl: [(c1kXX,
                       label: block_c1kXX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kXX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kY3; else goto c1kY2;
       c1kY3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1kY2: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jqs_entry() //  [R1]
         { info_tbl: [(c1kYe,
                       label: sat_s1jqs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kYe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kYn; else goto c1kYo;
       c1kYn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kYo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1kYb_info;
           _s1jqb::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s1jqb::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1kYu; else goto c1kYc;
       u1kYu: // global
           call _c1kYb(R1) args: 0, res: 0, upd: 0;
       c1kYc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1kYb() //  [R1]
         { info_tbl: [(c1kYb,
                       label: block_c1kYb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kYb: // global
           I64[Sp] = block_c1kYh_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto u1kYt; else goto c1kYi;
       u1kYt: // global
           call _c1kYh(R1) args: 0, res: 0, upd: 0;
       c1kYi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1kYh() //  [R1]
         { info_tbl: [(c1kYh,
                       label: block_c1kYh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kYh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kYs; else goto c1kYr;
       c1kYs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1kYr: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jqn_entry() //  [R1]
         { info_tbl: [(c1kYC,
                       label: sat_s1jqn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kYC: // global
           _s1jqn::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1kYG; else goto c1kYH;
       c1kYH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kYJ; else goto c1kYI;
       c1kYJ: // global
           HpAlloc = 24;
           goto c1kYG;
       c1kYG: // global
           R1 = _s1jqn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kYI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jqn::P64;
           _s1jq9::P64 = P64[_s1jqn::P64 + 16];
           _s1jqc::P64 = P64[_s1jqn::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1jqc::P64;
           I64[Sp - 32] = block_c1kYA_info;
           R2 = _s1jq9::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kYA() //  [R1]
         { info_tbl: [(c1kYA,
                       label: block_c1kYA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kYA: // global
           I64[Sp] = block_c1kYF_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kYF() //  [R1]
         { info_tbl: [(c1kYF,
                       label: block_c1kYF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kYF: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$s$cproperFraction_entry() //  [R2, R3, R4]
         { info_tbl: [(c1kYP,
                       label: GHC.Real.$w$s$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kYP: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1kYT; else goto c1kYS;
       c1kYT: // global
           HpAlloc = 96;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kYS: // global
           I64[Hp - 88] = ds_s1jqc_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_s1jqs_info;
           P64[Hp - 40] = R4;
           _c1kXJ::P64 = Hp - 88;
           P64[Hp - 32] = _c1kXJ::P64;
           I64[Hp - 24] = sat_s1jqn_info;
           P64[Hp - 8] = R2;
           P64[Hp] = _c1kXJ::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.719684197 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$cproperFraction_closure" {
     GHC.Real.$fEnumRatio_$s$cproperFraction_closure:
         const GHC.Real.$fEnumRatio_$s$cproperFraction_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$cproperFraction_entry() //  [R2, R3]
         { info_tbl: [(c1kZ2,
                       label: GHC.Real.$fEnumRatio_$s$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kZ2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1kZ8; else goto c1kZ9;
       c1kZ8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$cproperFraction_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1kZ9: // global
           I64[Sp - 16] = block_c1kYZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1kZe; else goto c1kZ0;
       u1kZe: // global
           call _c1kYZ(R1) args: 0, res: 0, upd: 0;
       c1kZ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1kYZ() //  [R1]
         { info_tbl: [(c1kYZ,
                       label: block_c1kYZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kYZ: // global
           _s1jqt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1kZ5_info;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = _s1jqt::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1kZ5() //  [R1, R2]
         { info_tbl: [(c1kZ5,
                       label: block_c1kZ5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kZ5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kZd; else goto c1kZc;
       c1kZd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1kZc: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.722060606 UTC

[section ""data" . GHC.Real.$w$cproperFraction_closure" {
     GHC.Real.$w$cproperFraction_closure:
         const GHC.Real.$w$cproperFraction_info;
 },
 ds_s1jqF_entry() //  [R1]
         { info_tbl: [(c1kZn,
                       label: ds_s1jqF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kZn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1kZo; else goto c1kZp;
       c1kZo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kZp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.quotRem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jqS_entry() //  [R1]
         { info_tbl: [(c1kZx,
                       label: sat_s1jqS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kZx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1kZD; else goto c1kZE;
       c1kZD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kZE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1kZu_info;
           _s1jqE::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s1jqE::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1kZJ; else goto c1kZv;
       u1kZJ: // global
           call _c1kZu(R1) args: 0, res: 0, upd: 0;
       c1kZv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1kZu() //  [R1]
         { info_tbl: [(c1kZu,
                       label: block_c1kZu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kZu: // global
           I64[Sp] = block_c1kZA_info;
           R1 = P64[R1 + 15];
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1kZA() //  [R1]
         { info_tbl: [(c1kZA,
                       label: block_c1kZA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kZA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kZI; else goto c1kZH;
       c1kZI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1kZH: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jqM_entry() //  [R1]
         { info_tbl: [(c1kZT,
                       label: sat_s1jqM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kZT: // global
           _s1jqM::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1kZU; else goto c1kZV;
       c1kZV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1kZX; else goto c1kZW;
       c1kZX: // global
           HpAlloc = 24;
           goto c1kZU;
       c1kZU: // global
           R1 = _s1jqM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1kZW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jqM::P64;
           _s1jqB::P64 = P64[_s1jqM::P64 + 16];
           _s1jqF::P64 = P64[_s1jqM::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1jqF::P64;
           R2 = _s1jqB::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jqN_entry() //  [R1]
         { info_tbl: [(c1l00,
                       label: sat_s1jqN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l00: // global
           _s1jqN::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1l04; else goto c1l05;
       c1l05: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1l07; else goto c1l06;
       c1l07: // global
           HpAlloc = 32;
           goto c1l04;
       c1l04: // global
           R1 = _s1jqN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l06: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jqN::P64;
           _s1jqB::P64 = P64[_s1jqN::P64 + 16];
           _s1jqC::P64 = P64[_s1jqN::P64 + 24];
           _s1jqF::P64 = P64[_s1jqN::P64 + 32];
           I64[Hp - 24] = sat_s1jqM_info;
           P64[Hp - 8] = _s1jqB::P64;
           P64[Hp] = _s1jqF::P64;
           I64[Sp - 32] = block_c1kZY_info;
           R2 = _s1jqC::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1kZY() //  [R1]
         { info_tbl: [(c1kZY,
                       label: block_c1kZY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1kZY: // global
           I64[Sp] = block_c1l03_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1l03() //  [R1]
         { info_tbl: [(c1l03,
                       label: block_c1l03_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l03: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$cproperFraction_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1l0d,
                       label: GHC.Real.$w$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l0d: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1l0h; else goto c1l0g;
       c1l0h: // global
           HpAlloc = 112;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cproperFraction_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l0g: // global
           I64[Hp - 104] = ds_s1jqF_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R5;
           I64[Hp - 64] = sat_s1jqS_info;
           P64[Hp - 48] = R5;
           _c1kZj::P64 = Hp - 104;
           P64[Hp - 40] = _c1kZj::P64;
           I64[Hp - 32] = sat_s1jqN_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = _c1kZj::P64;
           R2 = Hp - 64;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.725192078 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cproperFraction_closure" {
     GHC.Real.$fEnumRatio_$cproperFraction_closure:
         const GHC.Real.$fEnumRatio_$cproperFraction_info;
 },
 GHC.Real.$fEnumRatio_$cproperFraction_entry() //  [R2, R3, R4]
         { info_tbl: [(c1l0p,
                       label: GHC.Real.$fEnumRatio_$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l0p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1l0v; else goto c1l0w;
       c1l0v: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l0w: // global
           I64[Sp - 24] = block_c1l0m_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1l0B; else goto c1l0n;
       u1l0B: // global
           call _c1l0m(R1) args: 0, res: 0, upd: 0;
       c1l0n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1l0m() //  [R1]
         { info_tbl: [(c1l0m,
                       label: block_c1l0m_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l0m: // global
           _s1jqU::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1l0s_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _s1jqU::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1l0s() //  [R1, R2]
         { info_tbl: [(c1l0s,
                       label: block_c1l0s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l0s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1l0A; else goto c1l0z;
       c1l0A: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1l0z: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.727473764 UTC

[section ""data" . GHC.Real.$wreduce_closure" {
     GHC.Real.$wreduce_closure:
         const GHC.Real.$wreduce_info;
         const 0;
 },
 sat_s1jr9_entry() //  [R1]
         { info_tbl: [(c1l0Q,
                       label: sat_s1jr9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l0Q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1l0R; else goto c1l0S;
       c1l0R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l0S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1l0O_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1l0O() //  [R1]
         { info_tbl: [(c1l0O,
                       label: block_c1l0O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l0O: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 d_s1jrb_entry() //  [R1]
         { info_tbl: [(c1l1c,
                       label: d_s1jrb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l1c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1l1d; else goto c1l1e;
       c1l1d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l1e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.gcd_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1l1D_srtd" {
     u1l1D_srtd:
         const S1jKw_srt+296;
         const 72;
         const 281474976710657;
         const 192;
 },
 GHC.Real.$wreduce_entry() //  [R2, R3, R4]
         { info_tbl: [(c1l1f,
                       label: GHC.Real.$wreduce_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l1f: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1l1g; else goto c1l1h;
       c1l1g: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wreduce_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l1h: // global
           I64[Sp - 32] = block_c1l0G_info;
           _s1jr2::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1jr2::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1l1E_srtd" {
     u1l1E_srtd:
         const S1jKw_srt+296;
         const 71;
         const 281474976710657;
         const 64;
 },
 _c1l0G() //  [R1]
         { info_tbl: [(c1l0G,
                       label: block_c1l0G_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l0G: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1l1k; else goto c1l1j;
       c1l1k: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1l1j: // global
           I64[Hp - 16] = sat_s1jr9_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1l0W_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1l1F_srtd" {
     u1l1F_srtd:
         const S1jKw_srt+296;
         const 71;
         const 1;
         const 64;
 },
 _c1l0W() //  [R1]
         { info_tbl: [(c1l0W,
                       label: block_c1l0W_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l0W: // global
           I64[Sp] = block_c1l10_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1l1G_srtd" {
     u1l1G_srtd:
         const S1jKw_srt+296;
         const 71;
         const 1;
         const 64;
 },
 _c1l10() //  [R1]
         { info_tbl: [(c1l10,
                       label: block_c1l10_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l10: // global
           _c1l0K::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1l14_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = _c1l0K::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1l1H_srtd" {
     u1l1H_srtd:
         const S1jKw_srt+296;
         const 71;
         const 1;
         const 64;
 },
 _c1l14() //  [R1]
         { info_tbl: [(c1l14,
                       label: block_c1l14_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l14: // global
           if (R1 & 7 == 1) goto c1l1r; else goto c1l1B;
       c1l1r: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1l1u; else goto c1l1t;
       c1l1u: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1l1t: // global
           I64[Hp - 32] = d_s1jrb_info;
           _s1jr2::P64 = P64[Sp + 8];
           P64[Hp - 16] = _s1jr2::P64;
           _s1jr3::P64 = P64[Sp + 16];
           P64[Hp - 8] = _s1jr3::P64;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_c1l1n_info;
           R2 = _s1jr2::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jr3::P64;
           _c1l18::P64 = Hp - 32;
           P64[Sp - 8] = _c1l18::P64;
           P64[Sp + 16] = _c1l18::P64;
           Sp = Sp - 24;
           call GHC.Real.quot_entry(R2) args: 32, res: 8, upd: 8;
       c1l1B: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1l1n() //  [R1]
         { info_tbl: [(c1l1n,
                       label: block_c1l1n_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l1n: // global
           _c1l18::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1l1p_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 24];
           P64[Sp + 8] = _c1l18::P64;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call GHC.Real.quot_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1l1p() //  [R1]
         { info_tbl: [(c1l1p,
                       label: block_c1l1p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l1p: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.730683669 UTC

[section ""data" . GHC.Real.reduce_closure" {
     GHC.Real.reduce_closure:
         const GHC.Real.reduce_info;
         const 0;
 },
 GHC.Real.reduce_entry() //  [R2, R3, R4]
         { info_tbl: [(c1l1P,
                       label: GHC.Real.reduce_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l1P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1l1Q; else goto c1l1R;
       c1l1Q: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.reduce_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l1R: // global
           I64[Sp - 8] = block_c1l1M_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1l1M() //  [R1, R2]
         { info_tbl: [(c1l1M,
                       label: block_c1l1M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l1M: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1l1U; else goto c1l1T;
       c1l1U: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1l1T: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.732046709 UTC

[section ""data" . GHC.Real.%_$s%_closure" {
     GHC.Real.%_$s%_closure:
         const GHC.Real.%_$s%_info;
         const 0;
 },
 GHC.Real.%_$s%_entry() //  [R2, R3]
         { info_tbl: [(c1l22,
                       label: GHC.Real.%_$s%_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l22: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1l23; else goto c1l24;
       c1l23: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.%_$s%_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l24: // global
           I64[Sp - 8] = block_c1l1Z_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$s$cfromRational_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1l1Z() //  [R1, R2]
         { info_tbl: [(c1l1Z,
                       label: block_c1l1Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l1Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1l27; else goto c1l26;
       c1l27: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1l26: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.73399379 UTC

[section ""data" . GHC.Real.$w%_closure" {
     GHC.Real.$w%_closure:
         const GHC.Real.$w%_info;
         const 0;
 },
 $dReal_s1jrt_entry() //  [R1]
         { info_tbl: [(c1l2g,
                       label: $dReal_s1jrt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l2g: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jru_entry() //  [R1]
         { info_tbl: [(c1l2n,
                       label: $dNum_s1jru_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l2n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1l2o; else goto c1l2p;
       c1l2o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l2p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jrx_entry() //  [R1]
         { info_tbl: [(c1l2u,
                       label: sat_s1jrx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l2u: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1l2v; else goto c1l2w;
       c1l2v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l2w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jrv_entry() //  [R1]
         { info_tbl: [(c1l2F,
                       label: sat_s1jrv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l2F: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1l2G; else goto c1l2H;
       c1l2G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l2H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jrw_entry() //  [R1]
         { info_tbl: [(c1l2I,
                       label: sat_s1jrw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l2I: // global
           _s1jrw::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1l2J; else goto c1l2K;
       c1l2K: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1l2M; else goto c1l2L;
       c1l2M: // global
           HpAlloc = 32;
           goto c1l2J;
       c1l2J: // global
           R1 = _s1jrw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l2L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jrw::P64;
           _s1jrr::P64 = P64[_s1jrw::P64 + 16];
           _s1jrs::P64 = P64[_s1jrw::P64 + 24];
           _s1jru::P64 = P64[_s1jrw::P64 + 32];
           I64[Hp - 24] = sat_s1jrv_info;
           P64[Hp - 8] = _s1jrs::P64;
           P64[Hp] = _s1jru::P64;
           R2 = _s1jru::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1jrr::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w%_entry() //  [R2, R3, R4]
         { info_tbl: [(c1l2N,
                       label: GHC.Real.$w%_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l2N: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c1l2R; else goto c1l2Q;
       c1l2R: // global
           HpAlloc = 120;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w%_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l2Q: // global
           I64[Hp - 112] = $dReal_s1jrt_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = $dNum_s1jru_info;
           P64[Hp - 72] = Hp - 112;
           I64[Hp - 64] = sat_s1jrx_info;
           P64[Hp - 48] = R4;
           _c1l2j::P64 = Hp - 88;
           P64[Hp - 40] = _c1l2j::P64;
           I64[Hp - 32] = sat_s1jrw_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = _c1l2j::P64;
           R4 = Hp - 64;
           R3 = Hp - 32;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.736331083 UTC

[section ""data" . GHC.Real.%_closure" {
     GHC.Real.%_closure:
         const GHC.Real.%_info;
         const 0;
 },
 GHC.Real.%_entry() //  [R2, R3, R4]
         { info_tbl: [(c1l2Z,
                       label: GHC.Real.%_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l2Z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1l30; else goto c1l31;
       c1l30: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.%_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l31: // global
           I64[Sp - 8] = block_c1l2W_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w%_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1l2W() //  [R1, R2]
         { info_tbl: [(c1l2W,
                       label: block_c1l2W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l2W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1l34; else goto c1l33;
       c1l34: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1l33: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.738219276 UTC

[section ""data" . GHC.Real.$w$c/_closure" {
     GHC.Real.$w$c/_closure:
         const GHC.Real.$w$c/_info;
         const 0;
 },
 $dReal_s1jrJ_entry() //  [R1]
         { info_tbl: [(c1l3d,
                       label: $dReal_s1jrJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l3d: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jrK_entry() //  [R1]
         { info_tbl: [(c1l3k,
                       label: $dNum_s1jrK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l3k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1l3l; else goto c1l3m;
       c1l3l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l3m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jrM_entry() //  [R1]
         { info_tbl: [(c1l3r,
                       label: sat_s1jrM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l3r: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1l3s; else goto c1l3t;
       c1l3s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l3t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jrL_entry() //  [R1]
         { info_tbl: [(c1l3y,
                       label: sat_s1jrL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l3y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1l3z; else goto c1l3A;
       c1l3z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l3A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c/_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1l3B,
                       label: GHC.Real.$w$c/_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l3B: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto c1l3F; else goto c1l3E;
       c1l3F: // global
           HpAlloc = 128;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c/_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l3E: // global
           I64[Hp - 120] = $dReal_s1jrJ_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = $dNum_s1jrK_info;
           P64[Hp - 80] = Hp - 120;
           I64[Hp - 72] = sat_s1jrM_info;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           _c1l3g::P64 = Hp - 96;
           P64[Hp - 40] = _c1l3g::P64;
           I64[Hp - 32] = sat_s1jrL_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R6;
           P64[Hp] = _c1l3g::P64;
           R4 = Hp - 72;
           R3 = Hp - 32;
           R2 = R2;
           call GHC.Real.$w%_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.740502237 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$c/_closure" {
     GHC.Real.$fFractionalRatio_$c/_closure:
         const GHC.Real.$fFractionalRatio_$c/_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$c/_entry() //  [R2, R3, R4]
         { info_tbl: [(c1l3N,
                       label: GHC.Real.$fFractionalRatio_$c/_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l3N: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1l3Y; else goto c1l3Z;
       c1l3Y: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$c/_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l3Z: // global
           I64[Sp - 24] = block_c1l3K_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1l46; else goto c1l3L;
       u1l46: // global
           call _c1l3K(R1) args: 0, res: 0, upd: 0;
       c1l3L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1l3K() //  [R1]
         { info_tbl: [(c1l3K,
                       label: block_c1l3K_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l3K: // global
           I64[Sp - 8] = block_c1l3Q_info;
           _s1jrR::P64 = P64[R1 + 7];
           _s1jrS::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jrS::P64;
           P64[Sp + 16] = _s1jrR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1l45; else goto c1l3R;
       u1l45: // global
           call _c1l3Q(R1) args: 0, res: 0, upd: 0;
       c1l3R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1l3Q() //  [R1]
         { info_tbl: [(c1l3Q,
                       label: block_c1l3Q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l3Q: // global
           _s1jrR::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1l3V_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jrR::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c/_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1l3V() //  [R1, R2]
         { info_tbl: [(c1l3V,
                       label: block_c1l3V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l3V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1l44; else goto c1l43;
       c1l44: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1l43: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.742832203 UTC

[section ""data" . GHC.Real.$w$cfromRational_closure" {
     GHC.Real.$w$cfromRational_closure:
         const GHC.Real.$w$cfromRational_info;
         const 0;
 },
 $dReal_s1js2_entry() //  [R1]
         { info_tbl: [(c1l4f,
                       label: $dReal_s1js2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l4f: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1js3_entry() //  [R1]
         { info_tbl: [(c1l4m,
                       label: $dNum_s1js3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l4m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1l4n; else goto c1l4o;
       c1l4n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l4o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1js5_entry() //  [R1]
         { info_tbl: [(c1l4t,
                       label: sat_s1js5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l4t: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1l4u; else goto c1l4v;
       c1l4u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l4v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1js4_entry() //  [R1]
         { info_tbl: [(c1l4A,
                       label: sat_s1js4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l4A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1l4B; else goto c1l4C;
       c1l4B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l4C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$cfromRational_entry() //  [R2, R3, R4]
         { info_tbl: [(c1l4D,
                       label: GHC.Real.$w$cfromRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l4D: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1l4H; else goto c1l4G;
       c1l4H: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cfromRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l4G: // global
           I64[Hp - 104] = $dReal_s1js2_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_s1js3_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = sat_s1js5_info;
           P64[Hp - 40] = R4;
           _c1l4i::P64 = Hp - 80;
           P64[Hp - 32] = _c1l4i::P64;
           I64[Hp - 24] = sat_s1js4_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _c1l4i::P64;
           R4 = Hp - 56;
           R3 = Hp - 24;
           R2 = R2;
           call GHC.Real.$w%_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.74489862 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$cfromRational_closure" {
     GHC.Real.$fFractionalRatio_$cfromRational_closure:
         const GHC.Real.$fFractionalRatio_$cfromRational_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$cfromRational_entry() //  [R2, R3]
         { info_tbl: [(c1l4P,
                       label: GHC.Real.$fFractionalRatio_$cfromRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l4P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1l4V; else goto c1l4W;
       c1l4V: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$cfromRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l4W: // global
           I64[Sp - 16] = block_c1l4M_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1l51; else goto c1l4N;
       u1l51: // global
           call _c1l4M(R1) args: 0, res: 0, upd: 0;
       c1l4N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1l4M() //  [R1]
         { info_tbl: [(c1l4M,
                       label: block_c1l4M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l4M: // global
           _s1js6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1l4S_info;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = _s1js6::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$cfromRational_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1l4S() //  [R1, R2]
         { info_tbl: [(c1l4S,
                       label: block_c1l4S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l4S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1l50; else goto c1l4Z;
       c1l50: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1l4Z: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.747478981 UTC

[section ""data" . GHC.Real.$w$c+_closure" {
     GHC.Real.$w$c+_closure:
         const GHC.Real.$w$c+_info;
         const 0;
 },
 $dReal_s1jsj_entry() //  [R1]
         { info_tbl: [(c1l5a,
                       label: $dReal_s1jsj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l5a: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jsk_entry() //  [R1]
         { info_tbl: [(c1l5h,
                       label: $dNum_s1jsk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l5h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1l5i; else goto c1l5j;
       c1l5i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l5j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jso_entry() //  [R1]
         { info_tbl: [(c1l5o,
                       label: sat_s1jso_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l5o: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1l5p; else goto c1l5q;
       c1l5p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l5q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsm_entry() //  [R1]
         { info_tbl: [(c1l5z,
                       label: sat_s1jsm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l5z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1l5A; else goto c1l5B;
       c1l5A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l5B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsl_entry() //  [R1]
         { info_tbl: [(c1l5G,
                       label: sat_s1jsl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l5G: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1l5H; else goto c1l5I;
       c1l5H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l5I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsn_entry() //  [R1]
         { info_tbl: [(c1l5J,
                       label: sat_s1jsn_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l5J: // global
           _s1jsn::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1l5K; else goto c1l5L;
       c1l5L: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1l5N; else goto c1l5M;
       c1l5N: // global
           HpAlloc = 80;
           goto c1l5K;
       c1l5K: // global
           R1 = _s1jsn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l5M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jsn::P64;
           _s1jsf::P64 = P64[_s1jsn::P64 + 16];
           _s1jsg::P64 = P64[_s1jsn::P64 + 24];
           _s1jsh::P64 = P64[_s1jsn::P64 + 32];
           _s1jsi::P64 = P64[_s1jsn::P64 + 40];
           _s1jsk::P64 = P64[_s1jsn::P64 + 48];
           I64[Hp - 72] = sat_s1jsm_info;
           P64[Hp - 56] = _s1jsg::P64;
           P64[Hp - 48] = _s1jsh::P64;
           P64[Hp - 40] = _s1jsk::P64;
           I64[Hp - 32] = sat_s1jsl_info;
           P64[Hp - 16] = _s1jsf::P64;
           P64[Hp - 8] = _s1jsi::P64;
           P64[Hp] = _s1jsk::P64;
           R2 = _s1jsk::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c+_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1l5O,
                       label: GHC.Real.$w$c+_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l5O: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1l5S; else goto c1l5R;
       c1l5S: // global
           HpAlloc = 144;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c+_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l5R: // global
           I64[Hp - 136] = $dReal_s1jsj_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = $dNum_s1jsk_info;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = sat_s1jso_info;
           P64[Hp - 72] = R4;
           P64[Hp - 64] = R6;
           _c1l5d::P64 = Hp - 112;
           P64[Hp - 56] = _c1l5d::P64;
           I64[Hp - 48] = sat_s1jsn_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _c1l5d::P64;
           R4 = Hp - 88;
           R3 = Hp - 48;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.751980184 UTC

[section ""data" . GHC.Real.$fNumRatio_$c+_closure" {
     GHC.Real.$fNumRatio_$c+_closure:
         const GHC.Real.$fNumRatio_$c+_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$c+_entry() //  [R2, R3, R4]
         { info_tbl: [(c1l60,
                       label: GHC.Real.$fNumRatio_$c+_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l60: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1l6b; else goto c1l6c;
       c1l6b: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$c+_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l6c: // global
           I64[Sp - 24] = block_c1l5X_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1l6j; else goto c1l5Y;
       u1l6j: // global
           call _c1l5X(R1) args: 0, res: 0, upd: 0;
       c1l5Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1l5X() //  [R1]
         { info_tbl: [(c1l5X,
                       label: block_c1l5X_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l5X: // global
           I64[Sp - 8] = block_c1l63_info;
           _s1jst::P64 = P64[R1 + 7];
           _s1jsu::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jsu::P64;
           P64[Sp + 16] = _s1jst::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1l6i; else goto c1l64;
       u1l6i: // global
           call _c1l63(R1) args: 0, res: 0, upd: 0;
       c1l64: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1l63() //  [R1]
         { info_tbl: [(c1l63,
                       label: block_c1l63_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l63: // global
           _s1jst::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1l68_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jst::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c+_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1l68() //  [R1, R2]
         { info_tbl: [(c1l68,
                       label: block_c1l68_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l68: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1l6h; else goto c1l6g;
       c1l6h: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1l6g: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.754594726 UTC

[section ""data" . GHC.Real.$w$c-_closure" {
     GHC.Real.$w$c-_closure:
         const GHC.Real.$w$c-_info;
         const 0;
 },
 $dReal_s1jsG_entry() //  [R1]
         { info_tbl: [(c1l6s,
                       label: $dReal_s1jsG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l6s: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jsH_entry() //  [R1]
         { info_tbl: [(c1l6z,
                       label: $dNum_s1jsH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l6z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1l6A; else goto c1l6B;
       c1l6A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l6B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jsL_entry() //  [R1]
         { info_tbl: [(c1l6G,
                       label: sat_s1jsL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l6G: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1l6H; else goto c1l6I;
       c1l6H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l6I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsJ_entry() //  [R1]
         { info_tbl: [(c1l6R,
                       label: sat_s1jsJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l6R: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1l6S; else goto c1l6T;
       c1l6S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l6T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsI_entry() //  [R1]
         { info_tbl: [(c1l6Y,
                       label: sat_s1jsI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l6Y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1l6Z; else goto c1l70;
       c1l6Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l70: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsK_entry() //  [R1]
         { info_tbl: [(c1l71,
                       label: sat_s1jsK_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l71: // global
           _s1jsK::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1l72; else goto c1l73;
       c1l73: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1l75; else goto c1l74;
       c1l75: // global
           HpAlloc = 80;
           goto c1l72;
       c1l72: // global
           R1 = _s1jsK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l74: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jsK::P64;
           _s1jsC::P64 = P64[_s1jsK::P64 + 16];
           _s1jsD::P64 = P64[_s1jsK::P64 + 24];
           _s1jsE::P64 = P64[_s1jsK::P64 + 32];
           _s1jsF::P64 = P64[_s1jsK::P64 + 40];
           _s1jsH::P64 = P64[_s1jsK::P64 + 48];
           I64[Hp - 72] = sat_s1jsJ_info;
           P64[Hp - 56] = _s1jsD::P64;
           P64[Hp - 48] = _s1jsE::P64;
           P64[Hp - 40] = _s1jsH::P64;
           I64[Hp - 32] = sat_s1jsI_info;
           P64[Hp - 16] = _s1jsC::P64;
           P64[Hp - 8] = _s1jsF::P64;
           P64[Hp] = _s1jsH::P64;
           R2 = _s1jsH::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c-_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1l76,
                       label: GHC.Real.$w$c-_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l76: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1l7a; else goto c1l79;
       c1l7a: // global
           HpAlloc = 144;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c-_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l79: // global
           I64[Hp - 136] = $dReal_s1jsG_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = $dNum_s1jsH_info;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = sat_s1jsL_info;
           P64[Hp - 72] = R4;
           P64[Hp - 64] = R6;
           _c1l6v::P64 = Hp - 112;
           P64[Hp - 56] = _c1l6v::P64;
           I64[Hp - 48] = sat_s1jsK_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _c1l6v::P64;
           R4 = Hp - 88;
           R3 = Hp - 48;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.757675859 UTC

[section ""data" . GHC.Real.$fNumRatio_$c-_closure" {
     GHC.Real.$fNumRatio_$c-_closure:
         const GHC.Real.$fNumRatio_$c-_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$c-_entry() //  [R2, R3, R4]
         { info_tbl: [(c1l7i,
                       label: GHC.Real.$fNumRatio_$c-_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l7i: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1l7t; else goto c1l7u;
       c1l7t: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$c-_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l7u: // global
           I64[Sp - 24] = block_c1l7f_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1l7B; else goto c1l7g;
       u1l7B: // global
           call _c1l7f(R1) args: 0, res: 0, upd: 0;
       c1l7g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1l7f() //  [R1]
         { info_tbl: [(c1l7f,
                       label: block_c1l7f_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l7f: // global
           I64[Sp - 8] = block_c1l7l_info;
           _s1jsQ::P64 = P64[R1 + 7];
           _s1jsR::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jsR::P64;
           P64[Sp + 16] = _s1jsQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1l7A; else goto c1l7m;
       u1l7A: // global
           call _c1l7l(R1) args: 0, res: 0, upd: 0;
       c1l7m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1l7l() //  [R1]
         { info_tbl: [(c1l7l,
                       label: block_c1l7l_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l7l: // global
           _s1jsQ::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1l7q_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jsQ::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c-_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1l7q() //  [R1, R2]
         { info_tbl: [(c1l7q,
                       label: block_c1l7q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l7q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1l7z; else goto c1l7y;
       c1l7z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1l7y: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.75996879 UTC

[section ""data" . GHC.Real.$w$c*_closure" {
     GHC.Real.$w$c*_closure:
         const GHC.Real.$w$c*_info;
         const 0;
 },
 $dReal_s1jt3_entry() //  [R1]
         { info_tbl: [(c1l7K,
                       label: $dReal_s1jt3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l7K: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jt4_entry() //  [R1]
         { info_tbl: [(c1l7R,
                       label: $dNum_s1jt4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l7R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1l7S; else goto c1l7T;
       c1l7S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l7T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jt6_entry() //  [R1]
         { info_tbl: [(c1l7Y,
                       label: sat_s1jt6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l7Y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1l7Z; else goto c1l80;
       c1l7Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l80: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jt5_entry() //  [R1]
         { info_tbl: [(c1l85,
                       label: sat_s1jt5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l85: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1l86; else goto c1l87;
       c1l86: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1l87: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c*_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1l88,
                       label: GHC.Real.$w$c*_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l88: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto c1l8c; else goto c1l8b;
       c1l8c: // global
           HpAlloc = 128;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c*_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l8b: // global
           I64[Hp - 120] = $dReal_s1jt3_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = $dNum_s1jt4_info;
           P64[Hp - 80] = Hp - 120;
           I64[Hp - 72] = sat_s1jt6_info;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R6;
           _c1l7N::P64 = Hp - 96;
           P64[Hp - 40] = _c1l7N::P64;
           I64[Hp - 32] = sat_s1jt5_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R5;
           P64[Hp] = _c1l7N::P64;
           R4 = Hp - 72;
           R3 = Hp - 32;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.762286045 UTC

[section ""data" . GHC.Real.$fNumRatio_$c*_closure" {
     GHC.Real.$fNumRatio_$c*_closure:
         const GHC.Real.$fNumRatio_$c*_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$c*_entry() //  [R2, R3, R4]
         { info_tbl: [(c1l8k,
                       label: GHC.Real.$fNumRatio_$c*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l8k: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1l8v; else goto c1l8w;
       c1l8v: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$c*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1l8w: // global
           I64[Sp - 24] = block_c1l8h_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1l8D; else goto c1l8i;
       u1l8D: // global
           call _c1l8h(R1) args: 0, res: 0, upd: 0;
       c1l8i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1l8h() //  [R1]
         { info_tbl: [(c1l8h,
                       label: block_c1l8h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l8h: // global
           I64[Sp - 8] = block_c1l8n_info;
           _s1jtb::P64 = P64[R1 + 7];
           _s1jtc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jtc::P64;
           P64[Sp + 16] = _s1jtb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1l8C; else goto c1l8o;
       u1l8C: // global
           call _c1l8n(R1) args: 0, res: 0, upd: 0;
       c1l8o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1l8n() //  [R1]
         { info_tbl: [(c1l8n,
                       label: block_c1l8n_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l8n: // global
           _s1jtb::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1l8s_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jtb::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c*_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1l8s() //  [R1, R2]
         { info_tbl: [(c1l8s,
                       label: block_c1l8s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l8s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1l8B; else goto c1l8A;
       c1l8B: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1l8A: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.764748754 UTC

[section ""data" . GHC.Real.$fNumRatio_closure" {
     GHC.Real.$fNumRatio_closure:
         const GHC.Real.$fNumRatio_info;
         const 0;
 },
 sat_s1jtq_entry() //  [R1, R2]
         { info_tbl: [(c1l8N,
                       label: sat_s1jtq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l8N: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$cfromInteger_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtp_entry() //  [R1, R2]
         { info_tbl: [(c1l8V,
                       label: sat_s1jtp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l8V: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$csignum_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jto_entry() //  [R1, R2]
         { info_tbl: [(c1l93,
                       label: sat_s1jto_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l93: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$cabs_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtn_entry() //  [R1, R2]
         { info_tbl: [(c1l9b,
                       label: sat_s1jtn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l9b: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$cnegate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtm_entry() //  [R1, R2, R3]
         { info_tbl: [(c1l9j,
                       label: sat_s1jtm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l9j: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fNumRatio_$c*_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtl_entry() //  [R1, R2, R3]
         { info_tbl: [(c1l9r,
                       label: sat_s1jtl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l9r: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fNumRatio_$c-_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtk_entry() //  [R1, R2, R3]
         { info_tbl: [(c1l9z,
                       label: sat_s1jtk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l9z: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fNumRatio_$c+_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fNumRatio_entry() //  [R2]
         { info_tbl: [(c1l9D,
                       label: GHC.Real.$fNumRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l9D: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c1l9H; else goto c1l9G;
       c1l9H: // global
           HpAlloc = 176;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1l9G: // global
           I64[Hp - 168] = sat_s1jtq_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1jtp_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s1jto_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s1jtn_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s1jtm_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s1jtl_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1jtk_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 70;
           P64[Hp - 40] = Hp - 86;
           P64[Hp - 32] = Hp - 102;
           P64[Hp - 24] = Hp - 119;
           P64[Hp - 16] = Hp - 135;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 167;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.766902478 UTC

[section ""data" . GHC.Real.$fEnumRatio3_closure" {
     GHC.Real.$fEnumRatio3_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.767817555 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$csucc_closure" {
     GHC.Real.$fEnumRatio_$s$csucc_closure:
         const GHC.Real.$fEnumRatio_$s$csucc_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$csucc_entry() //  [R2]
         { info_tbl: [(c1l9P,
                       label: GHC.Real.$fEnumRatio_$s$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l9P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1l9V; else goto c1l9W;
       c1l9V: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1l9W: // global
           I64[Sp - 8] = block_c1l9M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1la1; else goto c1l9N;
       u1la1: // global
           call _c1l9M(R1) args: 0, res: 0, upd: 0;
       c1l9N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1l9M() //  [R1]
         { info_tbl: [(c1l9M,
                       label: block_c1l9M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l9M: // global
           I64[Sp] = block_c1l9S_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1l9S() //  [R1, R2]
         { info_tbl: [(c1l9S,
                       label: block_c1l9S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1l9S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1la0; else goto c1l9Z;
       c1la0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1l9Z: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.7695479 UTC

[section ""data" . GHC.Real.$fEnumRatio_$csucc_closure" {
     GHC.Real.$fEnumRatio_$csucc_closure:
         const GHC.Real.$fEnumRatio_$csucc_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$csucc_entry() //  [R2, R3]
         { info_tbl: [(c1la9,
                       label: GHC.Real.$fEnumRatio_$csucc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1la9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lah; else goto c1lai;
       c1lah: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$csucc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lai: // global
           I64[Sp - 16] = block_c1la6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lao; else goto c1la7;
       u1lao: // global
           call _c1la6(R1) args: 0, res: 0, upd: 0;
       c1la7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1la6() //  [R1]
         { info_tbl: [(c1la6,
                       label: block_c1la6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1la6: // global
           I64[Sp - 16] = block_c1lac_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lac() //  [R1, R2]
         { info_tbl: [(c1lac,
                       label: block_c1lac_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lac: // global
           _s1jty::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1lae_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = _s1jty::P64;
           Sp = Sp + 24;
           call GHC.Real.$w$c+_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lae() //  [R1, R2]
         { info_tbl: [(c1lae,
                       label: block_c1lae_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lae: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lan; else goto c1lam;
       c1lan: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1lam: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.771325067 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$cpred_closure" {
     GHC.Real.$fEnumRatio_$s$cpred_closure:
         const GHC.Real.$fEnumRatio_$s$cpred_info;
         const 0;
 },
 section ""relreadonly" . u1laJ_srtd" {
     u1laJ_srtd:
         const S1jKw_srt+464;
         const 72;
         const 1;
         const 144;
 },
 GHC.Real.$fEnumRatio_$s$cpred_entry() //  [R2]
         { info_tbl: [(c1law,
                       label: GHC.Real.$fEnumRatio_$s$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1law: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1laC; else goto c1laD;
       c1laC: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1laD: // global
           I64[Sp - 8] = block_c1lat_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1laI; else goto c1lau;
       u1laI: // global
           call _c1lat(R1) args: 0, res: 0, upd: 0;
       c1lau: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1laK_srtd" {
     u1laK_srtd:
         const S1jKw_srt+464;
         const 69;
         const 1;
         const 16;
 },
 _c1lat() //  [R1]
         { info_tbl: [(c1lat,
                       label: block_c1lat_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lat: // global
           I64[Sp] = block_c1laz_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1laz() //  [R1, R2]
         { info_tbl: [(c1laz,
                       label: block_c1laz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1laz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1laH; else goto c1laG;
       c1laH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1laG: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.773071907 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cpred_closure" {
     GHC.Real.$fEnumRatio_$cpred_closure:
         const GHC.Real.$fEnumRatio_$cpred_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$cpred_entry() //  [R2, R3]
         { info_tbl: [(c1laS,
                       label: GHC.Real.$fEnumRatio_$cpred_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1laS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lb0; else goto c1lb1;
       c1lb0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cpred_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lb1: // global
           I64[Sp - 16] = block_c1laP_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lb7; else goto c1laQ;
       u1lb7: // global
           call _c1laP(R1) args: 0, res: 0, upd: 0;
       c1laQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1laP() //  [R1]
         { info_tbl: [(c1laP,
                       label: block_c1laP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1laP: // global
           I64[Sp - 16] = block_c1laV_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1laV() //  [R1, R2]
         { info_tbl: [(c1laV,
                       label: block_c1laV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1laV: // global
           _s1jtQ::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1laX_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = _s1jtQ::P64;
           Sp = Sp + 24;
           call GHC.Real.$w$c-_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1laX() //  [R1, R2]
         { info_tbl: [(c1laX,
                       label: block_c1laX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1laX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lb6; else goto c1lb5;
       c1lb6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1lb5: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.775274584 UTC

[section ""data" . GHC.Real.$fFractionalRatio_closure" {
     GHC.Real.$fFractionalRatio_closure:
         const GHC.Real.$fFractionalRatio_info;
         const 0;
 },
 sat_s1ju5_entry() //  [R1, R2]
         { info_tbl: [(c1lbh,
                       label: sat_s1ju5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lbh: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fFractionalRatio_$cfromRational_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ju4_entry() //  [R1, R2]
         { info_tbl: [(c1lbp,
                       label: sat_s1ju4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lbp: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fFractionalRatio_$crecip_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ju3_entry() //  [R1, R2, R3]
         { info_tbl: [(c1lbx,
                       label: sat_s1ju3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lbx: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fFractionalRatio_$c/_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ju2_entry() //  [R1]
         { info_tbl: [(c1lbE,
                       label: sat_s1ju2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lbE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lbF; else goto c1lbG;
       c1lbF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lbG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fNumRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fFractionalRatio_entry() //  [R2]
         { info_tbl: [(c1lbI,
                       label: GHC.Real.$fFractionalRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lbI: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1lbM; else goto c1lbL;
       c1lbM: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1lbL: // global
           I64[Hp - 104] = sat_s1ju5_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s1ju4_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1ju3_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1ju2_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.777467503 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFrom_closure" {
     GHC.Real.$fEnumRatio_$cenumFrom_closure:
         const GHC.Real.$fEnumRatio_$cenumFrom_info;
         const 0;
 },
 w_s1ju7_entry() //  [R1]
         { info_tbl: [(c1lbV,
                       label: w_s1ju7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lbV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lbW; else goto c1lbX;
       c1lbW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lbX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1juc_entry() //  [R1, R2]
         { info_tbl: [(c1lc6,
                       label: sat_s1juc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lc6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1lc7; else goto c1lc8;
       c1lc7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1lc8: // global
           I64[Sp - 8] = block_c1lc3_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lc3() //  [R1, R2]
         { info_tbl: [(c1lc3,
                       label: block_c1lc3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lc3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lcb; else goto c1lca;
       c1lcb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1lca: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEnumRatio_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c1lcc,
                       label: GHC.Real.$fEnumRatio_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lcc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1lcg; else goto c1lcf;
       c1lcg: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1lcf: // global
           I64[Hp - 32] = w_s1ju7_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s1juc_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.779580853 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFromThen_closure" {
     GHC.Real.$fEnumRatio_$cenumFromThen_closure:
         const GHC.Real.$fEnumRatio_$cenumFromThen_info;
         const 0;
 },
 w_s1jue_entry() //  [R1]
         { info_tbl: [(c1lcp,
                       label: w_s1jue_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lcp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lcq; else goto c1lcr;
       c1lcq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lcr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1juk_entry() //  [R1, R2, R3]
         { info_tbl: [(c1lcA,
                       label: sat_s1juk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lcA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1lcB; else goto c1lcC;
       c1lcB: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lcC: // global
           I64[Sp - 8] = block_c1lcx_info;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lcx() //  [R1, R2]
         { info_tbl: [(c1lcx,
                       label: block_c1lcx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lcx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lcF; else goto c1lcE;
       c1lcF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1lcE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEnumRatio_$cenumFromThen_entry() //  [R2]
         { info_tbl: [(c1lcG,
                       label: GHC.Real.$fEnumRatio_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lcG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1lcK; else goto c1lcJ;
       c1lcK: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFromThen_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1lcJ: // global
           I64[Hp - 32] = w_s1jue_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s1juk_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.781622534 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFromTo_closure" {
     GHC.Real.$fEnumRatio_$cenumFromTo_closure:
         const GHC.Real.$fEnumRatio_$cenumFromTo_info;
         const 0;
 },
 sat_s1jun_entry() //  [R1]
         { info_tbl: [(c1lcT,
                       label: sat_s1jun_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lcT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lcU; else goto c1lcV;
       c1lcU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lcV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jum_entry() //  [R1]
         { info_tbl: [(c1ld0,
                       label: sat_s1jum_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ld0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ld1; else goto c1ld2;
       c1ld1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ld2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1ld8_srtd" {
     u1ld8_srtd:
         const S1jKw_srt+624;
         const 58;
         const 153122387330596865;
 },
 GHC.Real.$fEnumRatio_$cenumFromTo_entry() //  [R2]
         { info_tbl: [(c1ld3,
                       label: GHC.Real.$fEnumRatio_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ld3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1ld7; else goto c1ld6;
       c1ld7: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFromTo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1ld6: // global
           I64[Hp - 40] = sat_s1jun_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s1jum_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.Real.numericEnumFromTo_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.784800332 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFromThenTo_closure" {
     GHC.Real.$fEnumRatio_$cenumFromThenTo_closure:
         const GHC.Real.$fEnumRatio_$cenumFromThenTo_info;
         const 0;
 },
 sat_s1juq_entry() //  [R1]
         { info_tbl: [(c1ldh,
                       label: sat_s1juq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ldh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ldi; else goto c1ldj;
       c1ldi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ldj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jup_entry() //  [R1]
         { info_tbl: [(c1ldo,
                       label: sat_s1jup_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ldo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ldp; else goto c1ldq;
       c1ldp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ldq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1ldw_srtd" {
     u1ldw_srtd:
         const S1jKw_srt+672;
         const 53;
         const 4644337115725825;
 },
 GHC.Real.$fEnumRatio_$cenumFromThenTo_entry() //  [R2]
         { info_tbl: [(c1ldr,
                       label: GHC.Real.$fEnumRatio_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ldr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1ldv; else goto c1ldu;
       c1ldv: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1ldu: // global
           I64[Hp - 40] = sat_s1juq_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s1jup_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.Real.numericEnumFromThenTo_closure+5;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.78619264 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$fRealRatio_closure" {
     GHC.Real.$fRealFracRatio_$s$fRealRatio_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Real.$fFractionalRatio_$s$fNumRatio_closure+1;
         const GHC.Real.$fOrdRatio_$s$fOrdRatio_closure+1;
         const GHC.Real.$fRealRatio_$s$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.787246499 UTC

[section ""data" . GHC.Real.$fRealRatio_closure" {
     GHC.Real.$fRealRatio_closure:
         const GHC.Real.$fRealRatio_info;
         const 0;
 },
 sat_s1juu_entry() //  [R1, R2]
         { info_tbl: [(c1ldG,
                       label: sat_s1juu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ldG: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fRealRatio_$ctoRational_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jut_entry() //  [R1]
         { info_tbl: [(c1ldN,
                       label: sat_s1jut_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ldN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ldO; else goto c1ldP;
       c1ldO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ldP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jus_entry() //  [R1]
         { info_tbl: [(c1ldU,
                       label: sat_s1jus_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ldU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ldV; else goto c1ldW;
       c1ldV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ldW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fNumRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fRealRatio_entry() //  [R2]
         { info_tbl: [(c1ldY,
                       label: GHC.Real.$fRealRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ldY: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1le2; else goto c1le1;
       c1le2: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = GHC.Real.$fRealRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1le1: // global
           I64[Hp - 88] = sat_s1juu_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1jut_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s1jus_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 87;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.789472748 UTC

[section ""data" . GHC.Real.$w$s$cceiling_closure" {
     GHC.Real.$w$s$cceiling_closure:
         const GHC.Real.$w$s$cceiling_info;
         const 0;
 },
 sat_s1juH_entry() //  [R1]
         { info_tbl: [(c1lev,
                       label: sat_s1juH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lev: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lew; else goto c1lex;
       c1lew: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lex: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1leP_srtd" {
     u1leP_srtd:
         const S1jKw_srt+24;
         const 136;
         const 1;
         const 576461027181592576;
         const 128;
 },
 GHC.Real.$w$s$cceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ley,
                       label: GHC.Real.$w$s$cceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ley: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lez; else goto c1leA;
       c1lez: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1leA: // global
           I64[Sp - 16] = block_c1le7_info;
           R4 = R4;
           R3 = R3;
           _s1juv::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s1juv::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1leQ_srtd" {
     u1leQ_srtd:
         const S1jKw_srt+24;
         const 124;
         const 1;
         const 576460752303685632;
 },
 _c1le7() //  [R1, R2]
         { info_tbl: [(c1le7,
                       label: block_c1le7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1le7: // global
           I64[Sp - 8] = block_c1le9_info;
           _s1juz::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1juz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1leO; else goto c1lea;
       u1leO: // global
           call _c1le9(R1) args: 0, res: 0, upd: 0;
       c1lea: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1leR_srtd" {
     u1leR_srtd:
         const S1jKw_srt+24;
         const 124;
         const 1;
         const 576460752303685632;
 },
 _c1le9() //  [R1]
         { info_tbl: [(c1le9,
                       label: block_c1le9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1le9: // global
           I64[Sp] = block_c1lee_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even1_closure;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lee() //  [R1]
         { info_tbl: [(c1lee,
                       label: block_c1lee_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lee: // global
           if (R1 & 7 == 3) goto c1leI; else goto c1leG;
       c1leI: // global
           I64[Sp] = block_c1lej_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
       c1leG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1lej() //  [R1]
         { info_tbl: [(c1lej,
                       label: block_c1lej_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lej: // global
           I64[Sp] = block_c1len_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1len() //  [R1]
         { info_tbl: [(c1len,
                       label: block_c1len_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1len: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1leM; else goto c1leL;
       c1leM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1leL: // global
           I64[Hp - 16] = sat_s1juH_info;
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.791811936 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$cceiling_closure" {
     GHC.Real.$fRealFracRatio_$s$cceiling_closure:
         const GHC.Real.$fRealFracRatio_$s$cceiling_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$s$cceiling_entry() //  [R2, R3]
         { info_tbl: [(c1leZ,
                       label: GHC.Real.$fRealFracRatio_$s$cceiling_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1leZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lf0; else goto c1lf1;
       c1lf0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$cceiling_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lf1: // global
           I64[Sp - 16] = block_c1leW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lf5; else goto c1leX;
       u1lf5: // global
           call _c1leW(R1) args: 0, res: 0, upd: 0;
       c1leX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1leW() //  [R1]
         { info_tbl: [(c1leW,
                       label: block_c1leW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1leW: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cceiling_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.793648687 UTC

[section ""data" . GHC.Real.$w$cceiling_closure" {
     GHC.Real.$w$cceiling_closure:
         const GHC.Real.$w$cceiling_info;
         const 0;
 },
 sat_s1jv3_entry() //  [R1]
         { info_tbl: [(c1lfA,
                       label: sat_s1jv3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lfA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lfB; else goto c1lfC;
       c1lfB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lfC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1lfV_srtd" {
     u1lfV_srtd:
         const S1jKw_srt+680;
         const 56;
         const 36030996042252289;
 },
 GHC.Real.$w$cceiling_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1lfD,
                       label: GHC.Real.$w$cceiling_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lfD: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1lfE; else goto c1lfF;
       c1lfE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cceiling_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lfF: // global
           I64[Sp - 24] = block_c1lfa_info;
           R5 = R5;
           R4 = R4;
           _s1juO::P64 = R3;
           R3 = R3;
           _s1juN::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1juN::P64;
           P64[Sp - 8] = _s1juO::P64;
           Sp = Sp - 24;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lfW_srtd" {
     u1lfW_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1lfa() //  [R1, R2]
         { info_tbl: [(c1lfa,
                       label: block_c1lfa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lfa: // global
           I64[Sp - 8] = block_c1lfc_info;
           _s1juS::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1juS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1lfU; else goto c1lfd;
       u1lfU: // global
           call _c1lfc(R1) args: 0, res: 0, upd: 0;
       c1lfd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lfX_srtd" {
     u1lfX_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1lfc() //  [R1]
         { info_tbl: [(c1lfc,
                       label: block_c1lfc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lfc: // global
           I64[Sp - 16] = block_c1lfh_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lfh() //  [R1, R2]
         { info_tbl: [(c1lfh,
                       label: block_c1lfh_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lfh: // global
           _s1juV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1lfj_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = _s1juV::P64;
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lfj() //  [R1]
         { info_tbl: [(c1lfj,
                       label: block_c1lfj_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lfj: // global
           if (R1 & 7 == 3) goto c1lfO; else goto c1lfM;
       c1lfO: // global
           I64[Sp] = block_c1lfo_info;
           R2 = P64[Sp + 24];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
       c1lfM: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1lfo() //  [R1]
         { info_tbl: [(c1lfo,
                       label: block_c1lfo_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lfo: // global
           I64[Sp] = block_c1lfs_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lfs() //  [R1]
         { info_tbl: [(c1lfs,
                       label: block_c1lfs_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lfs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lfS; else goto c1lfR;
       c1lfS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lfR: // global
           I64[Hp - 16] = sat_s1jv3_info;
           P64[Hp] = R1;
           R2 = R1;
           _s1juS::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1juS::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.796320592 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$cceiling_closure" {
     GHC.Real.$fRealFracRatio_$cceiling_closure:
         const GHC.Real.$fRealFracRatio_$cceiling_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$cceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lg5,
                       label: GHC.Real.$fRealFracRatio_$cceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lg5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lg6; else goto c1lg7;
       c1lg6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$cceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lg7: // global
           I64[Sp - 24] = block_c1lg2_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1lgb; else goto c1lg3;
       u1lgb: // global
           call _c1lg2(R1) args: 0, res: 0, upd: 0;
       c1lg3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lg2() //  [R1]
         { info_tbl: [(c1lg2,
                       label: block_c1lg2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lg2: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cceiling_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.79843159 UTC

[section ""data" . GHC.Real.$w$s$cfloor_closure" {
     GHC.Real.$w$s$cfloor_closure:
         const GHC.Real.$w$s$cfloor_info;
         const 0;
 },
 sat_s1jvo_entry() //  [R1]
         { info_tbl: [(c1lgM,
                       label: sat_s1jvo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lgM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lgN; else goto c1lgO;
       c1lgN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lgO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1lh7_srtd" {
     u1lh7_srtd:
         const S1jKw_srt;
         const 143;
         const 1;
         const 4611688217452740608;
         const 16384;
 },
 GHC.Real.$w$s$cfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lgP,
                       label: GHC.Real.$w$s$cfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lgP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lgQ; else goto c1lgR;
       c1lgQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lgR: // global
           I64[Sp - 16] = block_c1lgg_info;
           R4 = R4;
           R3 = R3;
           _s1jva::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s1jva::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lh8_srtd" {
     u1lh8_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1lgg() //  [R1, R2]
         { info_tbl: [(c1lgg,
                       label: block_c1lgg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lgg: // global
           I64[Sp - 8] = block_c1lgi_info;
           _s1jve::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1jve::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1lh6; else goto c1lgj;
       u1lh6: // global
           call _c1lgi(R1) args: 0, res: 0, upd: 0;
       c1lgj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lh9_srtd" {
     u1lh9_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1lgi() //  [R1]
         { info_tbl: [(c1lgi,
                       label: block_c1lgi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lgi: // global
           I64[Sp - 8] = block_c1lgn_info;
           R3 = P64[R1 + 15];
           R2 = GHC.Real.even1_closure;
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lha_srtd" {
     u1lha_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018427387904;
 },
 _c1lgn() //  [R1]
         { info_tbl: [(c1lgn,
                       label: block_c1lgn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lgn: // global
           I64[Sp] = block_c1lgr_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lgr() //  [R1]
         { info_tbl: [(c1lgr,
                       label: block_c1lgr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lgr: // global
           _s1jvk::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lgv_info;
           R3 = _s1jvk::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lgv() //  [R1]
         { info_tbl: [(c1lgv,
                       label: block_c1lgv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lgv: // global
           if (R1 == 1) goto c1lh1; else goto c1lgZ;
       c1lh1: // global
           I64[Sp] = block_c1lgA_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
       c1lgZ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1lgA() //  [R1]
         { info_tbl: [(c1lgA,
                       label: block_c1lgA_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lgA: // global
           I64[Sp] = block_c1lgE_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lgE() //  [R1]
         { info_tbl: [(c1lgE,
                       label: block_c1lgE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lgE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lh5; else goto c1lh4;
       c1lh5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lh4: // global
           I64[Hp - 16] = sat_s1jvo_info;
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.80128643 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$cfloor_closure" {
     GHC.Real.$fRealFracRatio_$s$cfloor_closure:
         const GHC.Real.$fRealFracRatio_$s$cfloor_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$s$cfloor_entry() //  [R2, R3]
         { info_tbl: [(c1lhi,
                       label: GHC.Real.$fRealFracRatio_$s$cfloor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lhi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lhj; else goto c1lhk;
       c1lhj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$cfloor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lhk: // global
           I64[Sp - 16] = block_c1lhf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lho; else goto c1lhg;
       u1lho: // global
           call _c1lhf(R1) args: 0, res: 0, upd: 0;
       c1lhg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lhf() //  [R1]
         { info_tbl: [(c1lhf,
                       label: block_c1lhf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lhf: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.803047569 UTC

[section ""data" . GHC.Real.$w$cfloor_closure" {
     GHC.Real.$w$cfloor_closure:
         const GHC.Real.$w$cfloor_info;
         const 0;
 },
 sat_s1jvK_entry() //  [R1]
         { info_tbl: [(c1lhT,
                       label: sat_s1jvK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lhT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lhU; else goto c1lhV;
       c1lhU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lhV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1lie_srtd" {
     u1lie_srtd:
         const S1jKw_srt+680;
         const 60;
         const 576462951326711809;
 },
 GHC.Real.$w$cfloor_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1lhW,
                       label: GHC.Real.$w$cfloor_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lhW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1lhX; else goto c1lhY;
       c1lhX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cfloor_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lhY: // global
           I64[Sp - 24] = block_c1lht_info;
           R5 = R5;
           R4 = R4;
           _s1jvv::P64 = R3;
           R3 = R3;
           _s1jvu::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1jvu::P64;
           P64[Sp - 8] = _s1jvv::P64;
           Sp = Sp - 24;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lif_srtd" {
     u1lif_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1lht() //  [R1, R2]
         { info_tbl: [(c1lht,
                       label: block_c1lht_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lht: // global
           I64[Sp - 8] = block_c1lhv_info;
           _s1jvz::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1jvz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1lid; else goto c1lhw;
       u1lid: // global
           call _c1lhv(R1) args: 0, res: 0, upd: 0;
       c1lhw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lig_srtd" {
     u1lig_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1lhv() //  [R1]
         { info_tbl: [(c1lhv,
                       label: block_c1lhv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lhv: // global
           I64[Sp - 16] = block_c1lhA_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lhA() //  [R1, R2]
         { info_tbl: [(c1lhA,
                       label: block_c1lhA_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lhA: // global
           _s1jvC::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1lhC_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = _s1jvC::P64;
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Real.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lhC() //  [R1]
         { info_tbl: [(c1lhC,
                       label: block_c1lhC_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lhC: // global
           if (R1 & 7 == 1) goto c1li5; else goto c1li7;
       c1li5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1li7: // global
           I64[Sp] = block_c1lhH_info;
           R2 = P64[Sp + 24];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lhH() //  [R1]
         { info_tbl: [(c1lhH,
                       label: block_c1lhH_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lhH: // global
           I64[Sp] = block_c1lhL_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lhL() //  [R1]
         { info_tbl: [(c1lhL,
                       label: block_c1lhL_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lhL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lib; else goto c1lia;
       c1lib: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lia: // global
           I64[Hp - 16] = sat_s1jvK_info;
           P64[Hp] = R1;
           R2 = R1;
           _s1jvz::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1jvz::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.80580906 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$cfloor_closure" {
     GHC.Real.$fRealFracRatio_$cfloor_closure:
         const GHC.Real.$fRealFracRatio_$cfloor_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$cfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lio,
                       label: GHC.Real.$fRealFracRatio_$cfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lio: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lip; else goto c1liq;
       c1lip: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$cfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1liq: // global
           I64[Sp - 24] = block_c1lil_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1liu; else goto c1lim;
       u1liu: // global
           call _c1lil(R1) args: 0, res: 0, upd: 0;
       c1lim: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lil() //  [R1]
         { info_tbl: [(c1lil,
                       label: block_c1lil_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lil: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cfloor_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.806904889 UTC

[section ""data" . sat_s1jvR_closure" {
     sat_s1jvR_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.807469172 UTC

[section ""data" . sat_s1jvS_closure" {
     sat_s1jvS_closure:
         const :_con_info;
         const sat_s1jvR_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.808210448 UTC

[section ""data" . GHC.Real.$fRealFracRatio2_closure" {
     GHC.Real.$fRealFracRatio2_closure:
         const GHC.Real.$fRealFracRatio2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fRealFracRatio2_entry() //  [R1]
         { info_tbl: [(c1liB,
                       label: GHC.Real.$fRealFracRatio2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1liB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1liC; else goto c1liD;
       c1liC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1liD: // global
           (_c1liy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1liy::I64 == 0) goto c1liA; else goto c1liz;
       c1liA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1liz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1liy::I64;
           R3 = sat_s1jvS_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.810649641 UTC

[section ""data" . GHC.Real.$w$s$cround_closure" {
     GHC.Real.$w$s$cround_closure:
         const GHC.Real.$w$s$cround_info;
         const 0;
 },
 sat_s1jwe_entry() //  [R1]
         { info_tbl: [(c1ljw,
                       label: sat_s1jwe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ljw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ljx; else goto c1ljy;
       c1ljx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ljy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jwf_entry() //  [R1]
         { info_tbl: [(c1ljF,
                       label: sat_s1jwf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ljF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ljG; else goto c1ljH;
       c1ljG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ljH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1lkS_srtd" {
     u1lkS_srtd:
         const S1jKw_srt;
         const 149;
         const 288230376151711745;
         const 4611688217729565184;
         const 1572864;
 },
 GHC.Real.$w$s$cround_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ljI,
                       label: GHC.Real.$w$s$cround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ljI: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1ljJ; else goto c1ljK;
       c1ljJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ljK: // global
           I64[Sp - 16] = block_c1liI_info;
           R4 = R4;
           R3 = R3;
           _s1jvT::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s1jvT::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lkT_srtd" {
     u1lkT_srtd:
         const S1jKw_srt;
         const 149;
         const 288230376151711745;
         const 4611686018706309632;
         const 1048576;
 },
 _c1liI() //  [R1, R2]
         { info_tbl: [(c1liI,
                       label: block_c1liI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1liI: // global
           I64[Sp - 8] = block_c1liK_info;
           _s1jvX::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1jvX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1lkN; else goto c1liL;
       u1lkN: // global
           call _c1liK(R1) args: 0, res: 0, upd: 0;
       c1liL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lkU_srtd" {
     u1lkU_srtd:
         const S1jKw_srt;
         const 149;
         const 288230376151711745;
         const 4611686018706309632;
         const 1048576;
 },
 _c1liK() //  [R1]
         { info_tbl: [(c1liK,
                       label: block_c1liK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1liK: // global
           I64[Sp - 16] = block_c1liP_info;
           _s1jw0::P64 = P64[R1 + 7];
           R2 = _s1jw0::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _s1jw0::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lkV_srtd" {
     u1lkV_srtd:
         const S1jKw_srt;
         const 149;
         const 288230376151711745;
         const 4611686018706309632;
         const 1048576;
 },
 _c1liP() //  [R1]
         { info_tbl: [(c1liP,
                       label: block_c1liP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1liP: // global
           I64[Sp] = block_c1liT_info;
           R5 = GHC.Real.even2_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[Sp + 8];
           R2 = R1;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lkW_srtd" {
     u1lkW_srtd:
         const S1jKw_srt;
         const 149;
         const 1;
         const 4611686018706309120;
         const 1048576;
 },
 _c1liT() //  [R1]
         { info_tbl: [(c1liT,
                       label: block_c1liT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1liT: // global
           I64[Sp] = block_c1liV_info;
           R2 = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lkX_srtd" {
     u1lkX_srtd:
         const S1jKw_srt;
         const 149;
         const 1;
         const 4611686018706309120;
         const 1048576;
 },
 _c1liV() //  [R1]
         { info_tbl: [(c1liV,
                       label: block_c1liV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1liV: // global
           I64[Sp - 8] = block_c1liZ_info;
           R3 = GHC.Real.$fRealFracRatio2_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lkY_srtd" {
     u1lkY_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018706309120;
 },
 _c1liZ() //  [R1]
         { info_tbl: [(c1liZ,
                       label: block_c1liZ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1liZ: // global
           if (R1 == 1) goto u1lkJ; else goto c1lk7;
       u1lkJ: // global
           Sp = Sp + 32;
           call _c1lkH() args: 0, res: 0, upd: 0;
       c1lk7: // global
           I64[Sp] = block_c1ljQ_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lkZ_srtd" {
     u1lkZ_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018706309120;
 },
 _c1ljQ() //  [R1]
         { info_tbl: [(c1ljQ,
                       label: block_c1ljQ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ljQ: // global
           if (R1 == 1) goto c1lkt; else goto c1lke;
       c1lkt: // global
           I64[Sp + 8] = block_c1lkr_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
       c1lke: // global
           _s1jw6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lkb_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _s1jw6::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ll0_srtd" {
     u1ll0_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1lkr() //  [R1]
         { info_tbl: [(c1lkr,
                       label: block_c1lkr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lkr: // global
           if (R1 & 7 == 1) goto u1lkL; else goto u1lkM;
       u1lkL: // global
           Sp = Sp + 8;
           call _s1jw8() args: 0, res: 0, upd: 0;
       u1lkM: // global
           Sp = Sp + 24;
           call _c1lkH() args: 0, res: 0, upd: 0;
     }
 },
 _c1lkH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lkH: // global
           R1 = P64[Sp];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1ll1_srtd" {
     u1ll1_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018697920512;
 },
 _c1lkb() //  [R1]
         { info_tbl: [(c1lkb,
                       label: block_c1lkb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lkb: // global
           if (R1 == 1) goto u1lkK; else goto c1lkk;
       u1lkK: // global
           Sp = Sp + 8;
           call _s1jw8() args: 0, res: 0, upd: 0;
       c1lkk: // global
           R1 = GHC.Real.$fRealFracRatio1_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s1jw8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jw8: // global
           I64[Sp - 8] = block_c1lj8_info;
           R2 = P64[Sp + 24];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ll2_srtd" {
     u1ll2_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1lj8() //  [R1]
         { info_tbl: [(c1lj8,
                       label: block_c1lj8_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lj8: // global
           I64[Sp] = block_c1ljc_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ll3_srtd" {
     u1ll3_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1ljc() //  [R1]
         { info_tbl: [(c1ljc,
                       label: block_c1ljc_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ljc: // global
           _s1jw1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1ljg_info;
           R3 = _s1jw1::P64;
           R2 = GHC.Real.even1_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ll4_srtd" {
     u1ll4_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018427387904;
 },
 _c1ljg() //  [R1]
         { info_tbl: [(c1ljg,
                       label: block_c1ljg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ljg: // global
           I64[Sp] = block_c1ljk_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ljk() //  [R1]
         { info_tbl: [(c1ljk,
                       label: block_c1ljk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ljk: // global
           _s1jwc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1ljo_info;
           R3 = _s1jwc::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ljo() //  [R1]
         { info_tbl: [(c1ljo,
                       label: block_c1ljo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ljo: // global
           _s1jwa::P64 = P64[Sp + 16];
           if (R1 == 1) goto c1lk2; else goto c1ljY;
       c1lk2: // global
           Hp = Hp + 24;
           _s1jwd::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1lk5; else goto c1lk4;
       c1lk4: // global
           I64[Hp - 16] = sat_s1jwf_info;
           P64[Hp] = _s1jwa::P64;
           R2 = _s1jwa::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
       c1ljY: // global
           Hp = Hp + 24;
           _s1jwd::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1lk5; else goto c1lk0;
       c1lk5: // global
           HpAlloc = 24;
           R1 = _s1jwd::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1lk0: // global
           I64[Hp - 16] = sat_s1jwe_info;
           P64[Hp] = _s1jwa::P64;
           R2 = _s1jwa::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.815977188 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$cround_closure" {
     GHC.Real.$fRealFracRatio_$s$cround_closure:
         const GHC.Real.$fRealFracRatio_$s$cround_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$s$cround_entry() //  [R2, R3]
         { info_tbl: [(c1llc,
                       label: GHC.Real.$fRealFracRatio_$s$cround_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1llc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lld; else goto c1lle;
       c1lld: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$cround_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lle: // global
           I64[Sp - 16] = block_c1ll9_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lli; else goto c1lla;
       u1lli: // global
           call _c1ll9(R1) args: 0, res: 0, upd: 0;
       c1lla: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ll9() //  [R1]
         { info_tbl: [(c1ll9,
                       label: block_c1ll9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ll9: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cround_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.821123181 UTC

[section ""data" . GHC.Real.$w$cround_closure" {
     GHC.Real.$w$cround_closure:
         const GHC.Real.$w$cround_info;
         const 0;
 },
 sat_s1jx1_entry() //  [R1]
         { info_tbl: [(c1lmA,
                       label: sat_s1jx1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lmA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lmB; else goto c1lmC;
       c1lmB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lmC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jx2_entry() //  [R1]
         { info_tbl: [(c1lmJ,
                       label: sat_s1jx2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lmJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lmK; else goto c1lmL;
       c1lmK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lmL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1lp6_srtd" {
     u1lp6_srtd:
         const S1jKw_srt+584;
         const 78;
         const 9156733004435457;
         const 8192;
 },
 GHC.Real.$w$cround_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1lmM,
                       label: GHC.Real.$w$cround_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lmM: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c1lmN; else goto c1lmO;
       c1lmN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cround_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lmO: // global
           I64[Sp - 24] = block_c1lln_info;
           R5 = R5;
           R4 = R4;
           _s1jwp::P64 = R3;
           R3 = R3;
           _s1jwo::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1jwo::P64;
           P64[Sp - 8] = _s1jwp::P64;
           Sp = Sp - 24;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lp7_srtd" {
     u1lp7_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1lln() //  [R1, R2]
         { info_tbl: [(c1lln,
                       label: block_c1lln_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lln: // global
           I64[Sp - 8] = block_c1llp_info;
           _s1jwt::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1jwt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1loV; else goto c1llq;
       u1loV: // global
           call _c1llp(R1) args: 0, res: 0, upd: 0;
       c1llq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lp8_srtd" {
     u1lp8_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1llp() //  [R1]
         { info_tbl: [(c1llp,
                       label: block_c1llp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1llp: // global
           I64[Sp - 16] = block_c1llu_info;
           R2 = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lp9_srtd" {
     u1lp9_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1llu() //  [R1]
         { info_tbl: [(c1llu,
                       label: block_c1llu_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1llu: // global
           I64[Sp] = block_c1lly_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpa_srtd" {
     u1lpa_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1lly() //  [R1]
         { info_tbl: [(c1lly,
                       label: block_c1lly_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lly: // global
           I64[Sp] = block_c1llC_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpb_srtd" {
     u1lpb_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1llC() //  [R1]
         { info_tbl: [(c1llC,
                       label: block_c1llC_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1llC: // global
           I64[Sp - 8] = block_c1llE_info;
           R4 = GHC.Real.even2_closure;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 32];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$w$cfromRational_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpc_srtd" {
     u1lpc_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2233383035013;
 },
 _c1llE() //  [R1, R2]
         { info_tbl: [(c1llE,
                       label: block_c1llE_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1llE: // global
           _s1jwA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1llG_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 16];
           R3 = _s1jwA::P64;
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call GHC.Real.$w$c-_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpd_srtd" {
     u1lpd_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023296645;
 },
 _c1llG() //  [R1]
         { info_tbl: [(c1llG,
                       label: block_c1llG_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1llG: // global
           I64[Sp] = block_c1llI_info;
           R3 = R1;
           R2 = P64[Sp + 32];
           call GHC.Real.$w$csignum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpe_srtd" {
     u1lpe_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1llI() //  [R1, R2]
         { info_tbl: [(c1llI,
                       label: block_c1llI_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1llI: // global
           I64[Sp - 16] = block_c1llK_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           _s1jwJ::P64 = R2;
           R2 = P64[Sp + 32];
           P64[Sp - 8] = _s1jwJ::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpf_srtd" {
     u1lpf_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1llK() //  [R1, R2]
         { info_tbl: [(c1llK,
                       label: block_c1llK_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1llK: // global
           I64[Sp - 16] = block_c1llM_info;
           _s1jwM::P64 = R2;
           R2 = P64[Sp + 48];
           P64[Sp - 8] = _s1jwM::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpg_srtd" {
     u1lpg_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1llM() //  [R1]
         { info_tbl: [(c1llM,
                       label: block_c1llM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1llM: // global
           I64[Sp] = block_c1llQ_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lph_srtd" {
     u1lph_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1llQ() //  [R1]
         { info_tbl: [(c1llQ,
                       label: block_c1llQ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1llQ: // global
           I64[Sp] = block_c1llU_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpi_srtd" {
     u1lpi_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1llU() //  [R1]
         { info_tbl: [(c1llU,
                       label: block_c1llU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1llU: // global
           I64[Sp - 8] = block_c1llW_info;
           R2 = P64[Sp + 64];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpj_srtd" {
     u1lpj_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1llW() //  [R1]
         { info_tbl: [(c1llW,
                       label: block_c1llW_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1llW: // global
           I64[Sp] = block_c1lm0_info;
           R2 = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpk_srtd" {
     u1lpk_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1lm0() //  [R1]
         { info_tbl: [(c1lm0,
                       label: block_c1lm0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lm0: // global
           I64[Sp] = block_c1lm4_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpl_srtd" {
     u1lpl_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1lm4() //  [R1]
         { info_tbl: [(c1lm4,
                       label: block_c1lm4_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lm4: // global
           I64[Sp] = block_c1ln3_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpm_srtd" {
     u1lpm_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1ln3() //  [R1]
         { info_tbl: [(c1ln3,
                       label: block_c1ln3_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ln3: // global
           if (R1 & 7 == 1) goto u1loL; else goto c1los;
       u1loL: // global
           Sp = Sp + 8;
           call _s1jwT() args: 0, res: 0, upd: 0;
       c1los: // global
           I64[Sp] = block_c1loq_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpn_srtd" {
     u1lpn_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1loq() //  [R1]
         { info_tbl: [(c1loq,
                       label: block_c1loq_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1loq: // global
           if (R1 & 7 == 1) goto u1loM; else goto u1loN;
       u1loM: // global
           Sp = Sp + 8;
           call _s1jwT() args: 0, res: 0, upd: 0;
       u1loN: // global
           Sp = Sp + 64;
           call _c1loC() args: 0, res: 0, upd: 0;
     }
 },
 _s1jwT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jwT: // global
           I64[Sp - 8] = block_c1lmd_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 64];
           Sp = Sp - 8;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpo_srtd" {
     u1lpo_srtd:
         const S1jKw_srt+696;
         const 40;
         const 549755813921;
 },
 _c1lmd() //  [R1, R2]
         { info_tbl: [(c1lmd,
                       label: block_c1lmd_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lmd: // global
           I64[Sp - 16] = block_c1ln7_info;
           _s1jwW::P64 = R2;
           R2 = P64[Sp + 8];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[Sp + 40];
           P64[Sp - 24] = R1;
           P64[Sp - 8] = _s1jwW::P64;
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpp_srtd" {
     u1lpp_srtd:
         const S1jKw_srt+696;
         const 40;
         const 549755813921;
 },
 _c1ln7() //  [R1]
         { info_tbl: [(c1ln7,
                       label: block_c1ln7_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ln7: // global
           if (R1 & 7 == 1) goto u1loO; else goto c1lnW;
       u1loO: // global
           Sp = Sp + 8;
           call _s1jx3() args: 0, res: 0, upd: 0;
       c1lnW: // global
           I64[Sp] = block_c1lnU_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 48];
           P64[Sp - 8] = P64[Sp + 8];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpq_srtd" {
     u1lpq_srtd:
         const S1jKw_srt+696;
         const 40;
         const 549755813921;
 },
 _c1lnU() //  [R1]
         { info_tbl: [(c1lnU,
                       label: block_c1lnU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lnU: // global
           if (R1 & 7 == 1) goto u1loP; else goto c1lo7;
       u1loP: // global
           Sp = Sp + 8;
           call _s1jx3() args: 0, res: 0, upd: 0;
       c1lo7: // global
           I64[Sp] = block_c1lo5_info;
           R3 = P64[Sp + 80];
           R2 = P64[Sp + 96];
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _s1jx3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jx3: // global
           I64[Sp - 8] = block_c1lnp_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 48];
           P64[Sp - 16] = P64[Sp + 32];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lpr_srtd" {
     u1lpr_srtd:
         const S1jKw_srt+736;
         const 35;
         const 17179869185;
 },
 _c1lnp() //  [R1]
         { info_tbl: [(c1lnp,
                       label: block_c1lnp_info
                       rep:StackRep [False, False, False, False, True, False, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lnp: // global
           if (R1 & 7 == 1) goto u1loS; else goto c1lnB;
       u1loS: // global
           Sp = Sp + 104;
           call _c1lnH() args: 0, res: 0, upd: 0;
       c1lnB: // global
           I64[Sp] = block_c1lnz_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 48];
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lps_srtd" {
     u1lps_srtd:
         const S1jKw_srt+736;
         const 35;
         const 17179869185;
 },
 _c1lnz() //  [R1]
         { info_tbl: [(c1lnz,
                       label: block_c1lnz_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lnz: // global
           if (R1 & 7 == 1) goto u1loT; else goto u1loU;
       u1loT: // global
           Sp = Sp + 104;
           call _c1lnH() args: 0, res: 0, upd: 0;
       u1loU: // global
           Sp = Sp + 8;
           call _s1jwX() args: 0, res: 0, upd: 0;
     }
 },
 _c1lnH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lnH: // global
           R1 = GHC.Real.$fRealFracRatio1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1lo5() //  [R1]
         { info_tbl: [(c1lo5,
                       label: block_c1lo5_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lo5: // global
           if (R1 & 7 == 1) goto u1loQ; else goto u1loR;
       u1loQ: // global
           Sp = Sp + 8;
           call _s1jwX() args: 0, res: 0, upd: 0;
       u1loR: // global
           Sp = Sp + 80;
           call _c1loC() args: 0, res: 0, upd: 0;
     }
 },
 _s1jwX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jwX: // global
           I64[Sp - 8] = block_c1lmk_info;
           R2 = P64[Sp + 88];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lmk() //  [R1]
         { info_tbl: [(c1lmk,
                       label: block_c1lmk_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lmk: // global
           I64[Sp] = block_c1lmo_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lmo() //  [R1]
         { info_tbl: [(c1lmo,
                       label: block_c1lmo_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lmo: // global
           _s1jww::P64 = P64[Sp + 72];
           I64[Sp + 72] = block_c1lms_info;
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 64];
           R3 = _s1jww::P64;
           R2 = P64[Sp + 88];
           P64[Sp + 96] = R1;
           Sp = Sp + 72;
           call GHC.Real.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lms() //  [R1]
         { info_tbl: [(c1lms,
                       label: block_c1lms_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lms: // global
           _s1jwt::P64 = P64[Sp + 8];
           _s1jwZ::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c1lne; else goto c1lni;
       c1lne: // global
           Hp = Hp + 24;
           _s1jx0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1lnl; else goto c1lng;
       c1lng: // global
           I64[Hp - 16] = sat_s1jx1_info;
           P64[Hp] = _s1jwZ::P64;
           R2 = _s1jwZ::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1jwt::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
       c1lni: // global
           Hp = Hp + 24;
           _s1jx0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1lnl; else goto c1lnk;
       c1lnl: // global
           HpAlloc = 24;
           R1 = _s1jx0::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lnk: // global
           I64[Hp - 16] = sat_s1jx2_info;
           P64[Hp] = _s1jwZ::P64;
           R2 = _s1jwZ::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1jwt::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _c1loC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1loC: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.829892839 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$cround_closure" {
     GHC.Real.$fRealFracRatio_$cround_closure:
         const GHC.Real.$fRealFracRatio_$cround_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$cround_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lpA,
                       label: GHC.Real.$fRealFracRatio_$cround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lpA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lpB; else goto c1lpC;
       c1lpB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$cround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lpC: // global
           I64[Sp - 24] = block_c1lpx_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1lpG; else goto c1lpy;
       u1lpG: // global
           call _c1lpx(R1) args: 0, res: 0, upd: 0;
       c1lpy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lpx() //  [R1]
         { info_tbl: [(c1lpx,
                       label: block_c1lpx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lpx: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cround_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.831661661 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$ctruncate_closure" {
     GHC.Real.$fRealFracRatio_$s$ctruncate_closure:
         const GHC.Real.$fRealFracRatio_$s$ctruncate_info;
         const 0;
 },
 sat_s1jxt_entry() //  [R1]
         { info_tbl: [(c1lpZ,
                       label: sat_s1jxt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lpZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1lq0; else goto c1lq1;
       c1lq0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lq1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c1lpU_info;
           R3 = GHC.Real.even1_closure;
           _s1jxl::P64 = P64[R1 + 24];
           R2 = _s1jxl::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s1jxl::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1lpU() //  [R1]
         { info_tbl: [(c1lpU,
                       label: block_c1lpU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lpU: // global
           if (R1 == 1) goto c1lpY; else goto c1lpX;
       c1lpY: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c1lpX: // global
           _s1jxl::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1lq4_info;
           R3 = _s1jxl::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1lq4() //  [R1]
         { info_tbl: [(c1lq4,
                       label: block_c1lq4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lq4: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fRealFracRatio_$s$ctruncate_entry() //  [R2, R3]
         { info_tbl: [(c1lqb,
                       label: GHC.Real.$fRealFracRatio_$s$ctruncate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lqb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lqh; else goto c1lqi;
       c1lqh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$ctruncate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lqi: // global
           I64[Sp - 16] = block_c1lpL_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lqr; else goto c1lpM;
       u1lqr: // global
           call _c1lpL(R1) args: 0, res: 0, upd: 0;
       c1lpM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lpL() //  [R1]
         { info_tbl: [(c1lpL,
                       label: block_c1lpL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lpL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lql; else goto c1lqk;
       c1lql: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lqk: // global
           _s1jxk::P64 = P64[R1 + 7];
           _s1jxl::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s1jxt_info;
           P64[Hp - 8] = _s1jxk::P64;
           P64[Hp] = _s1jxl::P64;
           I64[Sp] = block_c1lqc_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lqc() //  [R1]
         { info_tbl: [(c1lqc,
                       label: block_c1lqc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lqc: // global
           I64[Sp] = block_c1lqg_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lqg() //  [R1]
         { info_tbl: [(c1lqg,
                       label: block_c1lqg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lqg: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.834019137 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$ctruncate_closure" {
     GHC.Real.$fRealFracRatio_$ctruncate_closure:
         const GHC.Real.$fRealFracRatio_$ctruncate_info;
 },
 GHC.Real.$fRealFracRatio_$ctruncate_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lqz,
                       label: GHC.Real.$fRealFracRatio_$ctruncate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lqz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lqD; else goto c1lqE;
       c1lqD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$ctruncate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lqE: // global
           I64[Sp - 24] = block_c1lqw_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1lqI; else goto c1lqx;
       u1lqI: // global
           call _c1lqw(R1) args: 0, res: 0, upd: 0;
       c1lqx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lqw() //  [R1]
         { info_tbl: [(c1lqw,
                       label: block_c1lqw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lqw: // global
           _s1jxv::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1lqC_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _s1jxv::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lqC() //  [R1]
         { info_tbl: [(c1lqC,
                       label: block_c1lqC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lqC: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.835163348 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$fRealFracRatio_closure" {
     GHC.Real.$fRealFracRatio_$s$fRealFracRatio_closure:
         const GHC.Real.C:RealFrac_con_info;
         const GHC.Real.$fRealFracRatio_$s$fRealRatio_closure+1;
         const GHC.Real.$fFractionalRatio_$s$fFractionalRatio_closure+1;
         const GHC.Real.$fEnumRatio_$s$cproperFraction_closure+2;
         const GHC.Real.$fRealFracRatio_$s$ctruncate_closure+2;
         const GHC.Real.$fRealFracRatio_$s$cround_closure+2;
         const GHC.Real.$fRealFracRatio_$s$cceiling_closure+2;
         const GHC.Real.$fRealFracRatio_$s$cfloor_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.836678 UTC

[section ""data" . GHC.Real.$fRealFracRatio_closure" {
     GHC.Real.$fRealFracRatio_closure:
         const GHC.Real.$fRealFracRatio_info;
         const 0;
 },
 sat_s1jxK_entry() //  [R1, R2, R3]
         { info_tbl: [(c1lqS,
                       label: sat_s1jxK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lqS: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$cfloor_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxJ_entry() //  [R1, R2, R3]
         { info_tbl: [(c1lr0,
                       label: sat_s1jxJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lr0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$cceiling_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxI_entry() //  [R1, R2, R3]
         { info_tbl: [(c1lr8,
                       label: sat_s1jxI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lr8: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$cround_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxH_entry() //  [R1, R2, R3]
         { info_tbl: [(c1lrg,
                       label: sat_s1jxH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lrg: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$ctruncate_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxG_entry() //  [R1, R2, R3]
         { info_tbl: [(c1lro,
                       label: sat_s1jxG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lro: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fEnumRatio_$cproperFraction_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxF_entry() //  [R1]
         { info_tbl: [(c1lrv,
                       label: sat_s1jxF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lrv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lrw; else goto c1lrx;
       c1lrw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lrx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jxE_entry() //  [R1]
         { info_tbl: [(c1lrC,
                       label: sat_s1jxE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lrC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lrD; else goto c1lrE;
       c1lrD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lrE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fRealRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fRealFracRatio_entry() //  [R2]
         { info_tbl: [(c1lrG,
                       label: GHC.Real.$fRealFracRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lrG: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c1lrK; else goto c1lrJ;
       c1lrK: // global
           HpAlloc = 192;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1lrJ: // global
           I64[Hp - 184] = sat_s1jxK_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s1jxJ_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1jxI_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s1jxH_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s1jxG_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s1jxF_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s1jxE_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 118;
           P64[Hp - 24] = Hp - 134;
           P64[Hp - 16] = Hp - 150;
           P64[Hp - 8] = Hp - 166;
           P64[Hp] = Hp - 182;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.839599931 UTC

[section ""data" . g_r1j3N_closure" {
     g_r1j3N_closure:
         const g_r1j3N_info;
         const 0;
 },
 section ""relreadonly" . u1lsO_srtd" {
     u1lsO_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 g_r1j3N_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lrR,
                       label: g_r1j3N_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lrR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lrS; else goto u1lsI;
       c1lrS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = g_r1j3N_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u1lsI: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c1lrM() args: 0, res: 0, upd: 0;
     }
 },
 _c1lrM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lrM: // global
           I64[Sp - 8] = block_c1lrP_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lsP_srtd" {
     u1lsP_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1lrP() //  [R1]
         { info_tbl: [(c1lrP,
                       label: block_c1lrP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lrP: // global
           I64[Sp] = block_c1lrW_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lsQ_srtd" {
     u1lsQ_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1lrW() //  [R1]
         { info_tbl: [(c1lrW,
                       label: block_c1lrW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lrW: // global
           _s1jxM::P64 = P64[Sp + 16];
           if (R1 == 1) goto c1lsC; else goto c1ls4;
       c1lsC: // global
           I64[Sp] = block_c1lsw_info;
           R3 = GHC.Real.even2_closure;
           R2 = _s1jxM::P64;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       c1ls4: // global
           I64[Sp] = block_c1ls1_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _s1jxM::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lsR_srtd" {
     u1lsR_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1lsw() //  [R1]
         { info_tbl: [(c1lsw,
                       label: block_c1lsw_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lsw: // global
           _s1jxL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lsA_info;
           R3 = _s1jxL::P64;
           R2 = _s1jxL::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lsS_srtd" {
     u1lsS_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1lsA() //  [R1]
         { info_tbl: [(c1lsA,
                       label: block_c1lsA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lsA: // global
           P64[Sp] = R1;
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           call _c1lrM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1lsT_srtd" {
     u1lsT_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1ls1() //  [R1]
         { info_tbl: [(c1ls1,
                       label: block_c1ls1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ls1: // global
           _s1jxL::P64 = P64[Sp + 8];
           _s1jxN::P64 = P64[Sp + 24];
           if (R1 == 1) goto c1lst; else goto c1lsj;
       c1lst: // global
           R3 = _s1jxN::P64;
           R2 = _s1jxL::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
       c1lsj: // global
           I64[Sp] = block_c1ls8_info;
           R3 = _s1jxN::P64;
           R2 = _s1jxL::P64;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lsU_srtd" {
     u1lsU_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1ls8() //  [R1]
         { info_tbl: [(c1ls8,
                       label: block_c1ls8_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ls8: // global
           I64[Sp] = block_c1lsc_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 16];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lsV_srtd" {
     u1lsV_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1lsc() //  [R1]
         { info_tbl: [(c1lsc,
                       label: block_c1lsc_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lsc: // global
           _s1jxL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lsg_info;
           R3 = _s1jxL::P64;
           R2 = _s1jxL::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lsW_srtd" {
     u1lsW_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1lsg() //  [R1]
         { info_tbl: [(c1lsg,
                       label: block_c1lsg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lsg: // global
           P64[Sp] = R1;
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           call _c1lrM() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.843083902 UTC

[section ""data" . GHC.Real.^_f_closure" {
     GHC.Real.^_f_closure:
         const GHC.Real.^_f_info;
         const 0;
 },
 section ""relreadonly" . u1ltT_srtd" {
     u1ltT_srtd:
         const S1jKw_srt;
         const 158;
         const 1;
         const 4611686018427388416;
         const 838860800;
 },
 GHC.Real.^_f_entry() //  [R2, R3]
         { info_tbl: [(c1lt3,
                       label: GHC.Real.^_f_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lt3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lt4; else goto u1ltP;
       c1lt4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_f_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1ltP: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1lsY() args: 0, res: 0, upd: 0;
     }
 },
 _c1lsY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lsY: // global
           I64[Sp - 8] = block_c1lt1_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ltU_srtd" {
     u1ltU_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1lt1() //  [R1]
         { info_tbl: [(c1lt1,
                       label: block_c1lt1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lt1: // global
           I64[Sp] = block_c1lt8_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ltV_srtd" {
     u1ltV_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1lt8() //  [R1]
         { info_tbl: [(c1lt8,
                       label: block_c1lt8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lt8: // global
           _s1jxX::P64 = P64[Sp + 16];
           if (R1 == 1) goto c1ltJ; else goto c1ltg;
       c1ltJ: // global
           I64[Sp] = block_c1ltD_info;
           R3 = GHC.Real.even2_closure;
           R2 = _s1jxX::P64;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       c1ltg: // global
           I64[Sp] = block_c1ltd_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _s1jxX::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ltW_srtd" {
     u1ltW_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1ltD() //  [R1]
         { info_tbl: [(c1ltD,
                       label: block_c1ltD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ltD: // global
           _s1jxW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1ltH_info;
           R3 = _s1jxW::P64;
           R2 = _s1jxW::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ltX_srtd" {
     u1ltX_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1ltH() //  [R1]
         { info_tbl: [(c1ltH,
                       label: block_c1ltH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ltH: // global
           P64[Sp] = R1;
           P64[Sp + 8] = P64[Sp + 8];
           call _c1lsY() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1ltY_srtd" {
     u1ltY_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 512;
         const 268435456;
 },
 _c1ltd() //  [R1]
         { info_tbl: [(c1ltd,
                       label: block_c1ltd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ltd: // global
           if (R1 == 1) goto c1ltA; else goto c1ltr;
       c1ltA: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1ltr: // global
           I64[Sp] = block_c1ltk_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ltZ_srtd" {
     u1ltZ_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 0;
         const 268435456;
 },
 _c1ltk() //  [R1]
         { info_tbl: [(c1ltk,
                       label: block_c1ltk_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ltk: // global
           I64[Sp] = block_c1lto_info;
           _s1jxW::P64 = P64[Sp + 8];
           R3 = _s1jxW::P64;
           R2 = _s1jxW::P64;
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lto() //  [R1]
         { info_tbl: [(c1lto,
                       label: block_c1lto_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lto: // global
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = R1;
           Sp = Sp + 24;
           call g_r1j3N_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.845568036 UTC

[section ""cstring" . lvl5_r1j3O_bytes" {
     lvl5_r1j3O_bytes:
         I8[] [78,101,103,97,116,105,118,101,32,101,120,112,111,110,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.846409172 UTC

[section ""data" . GHC.Real.^1_closure" {
     GHC.Real.^1_closure:
         const GHC.Real.^1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.^1_entry() //  [R1]
         { info_tbl: [(c1lu8,
                       label: GHC.Real.^1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lu8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lu9; else goto c1lua;
       c1lu9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lua: // global
           (_c1lu3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1lu3::I64 == 0) goto c1lu5; else goto c1lu4;
       c1lu5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1lu4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1lu3::I64;
           I64[Sp - 24] = block_c1lu6_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1lu6() //  [R1]
         { info_tbl: [(c1lu6,
                       label: block_c1lu6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lu6: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.847782073 UTC

[section ""data" . GHC.Real.^_$s^_closure" {
     GHC.Real.^_$s^_closure:
         const GHC.Real.^_$s^_info;
         const 0;
 },
 section ""relreadonly" . u1luH_srtd" {
     u1luH_srtd:
         const S1jKw_srt+1008;
         const 35;
         const 28051505153;
 },
 GHC.Real.^_$s^_entry() //  [R2, R3]
         { info_tbl: [(c1lun,
                       label: GHC.Real.^_$s^_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lun: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1luo; else goto c1lup;
       c1luo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_$s^_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lup: // global
           I64[Sp - 24] = block_c1lui_info;
           _s1jy7::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jy6::P64 = R2;
           R2 = _s1jy7::P64;
           P64[Sp - 16] = _s1jy6::P64;
           P64[Sp - 8] = _s1jy7::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1luI_srtd" {
     u1luI_srtd:
         const S1jKw_srt+1008;
         const 35;
         const 19461570561;
 },
 _c1lui() //  [R1]
         { info_tbl: [(c1lui,
                       label: block_c1lui_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lui: // global
           if (R1 == 1) goto c1lum; else goto c1lul;
       c1lum: // global
           R1 = GHC.Real.^1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1lul: // global
           I64[Sp] = block_c1lus_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lus() //  [R1]
         { info_tbl: [(c1lus,
                       label: block_c1lus_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lus: // global
           if (R1 == 1) goto c1luD; else goto c1luz;
       c1luD: // global
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1luz: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.^_f_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.849509966 UTC

[section ""data" . GHC.Real.$w$s$cfromEnum_closure" {
     GHC.Real.$w$s$cfromEnum_closure:
         const GHC.Real.$w$s$cfromEnum_info;
         const 0;
 },
 GHC.Real.$w$s$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c1luS,
                       label: GHC.Real.$w$s$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1luS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1luT; else goto c1luU;
       c1luT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1luU: // global
           I64[Sp - 24] = block_c1luN_info;
           _s1jyb::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jya::P64 = R2;
           R2 = _s1jyb::P64;
           P64[Sp - 16] = _s1jya::P64;
           P64[Sp - 8] = _s1jyb::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1luN() //  [R1]
         { info_tbl: [(c1luN,
                       label: block_c1luN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1luN: // global
           if (R1 == 1) goto c1luR; else goto c1luQ;
       c1luR: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1luQ: // global
           _s1jyb::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1luX_info;
           R3 = _s1jyb::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1luX() //  [R1]
         { info_tbl: [(c1luX,
                       label: block_c1luX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1luX: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.852636207 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$cfromEnum_closure" {
     GHC.Real.$fEnumRatio_$s$cfromEnum_closure:
         const GHC.Real.$fEnumRatio_$s$cfromEnum_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$cfromEnum_entry() //  [R2]
         { info_tbl: [(c1lvb,
                       label: GHC.Real.$fEnumRatio_$s$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lvb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1lvj; else goto c1lvk;
       c1lvj: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1lvk: // global
           I64[Sp - 8] = block_c1lv8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1lvp; else goto c1lv9;
       u1lvp: // global
           call _c1lv8(R1) args: 0, res: 0, upd: 0;
       c1lv9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lv8() //  [R1]
         { info_tbl: [(c1lv8,
                       label: block_c1lv8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lv8: // global
           I64[Sp] = block_c1lve_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$cfromEnum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lve() //  [R1]
         { info_tbl: [(c1lve,
                       label: block_c1lve_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lve: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1lvo; else goto c1lvn;
       c1lvo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1lvn: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.854518354 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cfromEnum_closure" {
     GHC.Real.$fEnumRatio_$cfromEnum_closure:
         const GHC.Real.$fEnumRatio_$cfromEnum_info;
 },
 sat_s1jyu_entry() //  [R1]
         { info_tbl: [(c1lvF,
                       label: sat_s1jyu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lvF: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1lvG; else goto c1lvH;
       c1lvG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lvH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1lvD_info;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_pp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1lvD() //  [R1]
         { info_tbl: [(c1lvD,
                       label: block_c1lvD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lvD: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fEnumRatio_$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c1lvL,
                       label: GHC.Real.$fEnumRatio_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lvL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lvV; else goto c1lvW;
       c1lvV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lvW: // global
           I64[Sp - 16] = block_c1lvu_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lw4; else goto c1lvv;
       u1lw4: // global
           call _c1lvu(R1) args: 0, res: 0, upd: 0;
       c1lvv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lvu() //  [R1]
         { info_tbl: [(c1lvu,
                       label: block_c1lvu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lvu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1lvZ; else goto c1lvY;
       c1lvZ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lvY: // global
           _s1jyp::P64 = P64[R1 + 7];
           _s1jyq::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s1jyu_info;
           _s1jym::P64 = P64[Sp + 8];
           P64[Hp - 16] = _s1jym::P64;
           P64[Hp - 8] = _s1jyp::P64;
           P64[Hp] = _s1jyq::P64;
           I64[Sp + 8] = block_c1lvM_info;
           R2 = _s1jym::P64;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Hp - 32;
           Sp = Sp - 8;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1lvM() //  [R1]
         { info_tbl: [(c1lvM,
                       label: block_c1lvM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lvM: // global
           I64[Sp] = block_c1lvQ_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lvQ() //  [R1]
         { info_tbl: [(c1lvQ,
                       label: block_c1lvQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lvQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1lw3; else goto c1lw2;
       c1lw3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1lw2: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.856324515 UTC

[section ""data" . GHC.Real.ratioPrec1_closure" {
     GHC.Real.ratioPrec1_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.856858464 UTC

[section ""cstring" . GHC.Real.$fShowRatio2_bytes" {
     GHC.Real.$fShowRatio2_bytes:
         I8[] [32,37,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.858919947 UTC

[section ""data" . GHC.Real.$w$s$cshowsPrec_closure" {
     GHC.Real.$w$s$cshowsPrec_closure:
         const GHC.Real.$w$s$cshowsPrec_info;
         const 0;
 },
 GHC.Real.$w$s$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lw6: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Real.$w$s$cshowsPrec_entry(R5,
                                               R4,
                                               R3,
                                               R2,
                                               R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jyF_entry() //  [R1]
         { info_tbl: [(c1lwo,
                       label: sat_s1jyF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lwo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lwp; else goto c1lwq;
       c1lwp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lwq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1lwl_info;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1lwl() //  [R1, R2]
         { info_tbl: [(c1lwl,
                       label: block_c1lwl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lwl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lwt; else goto c1lws;
       c1lwt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1lws: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jyG_entry() //  [R1]
         { info_tbl: [(c1lwu,
                       label: sat_s1jyG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lwu: // global
           _s1jyG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1lwv; else goto c1lww;
       c1lww: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lwy; else goto c1lwx;
       c1lwy: // global
           HpAlloc = 32;
           goto c1lwv;
       c1lwv: // global
           R1 = _s1jyG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lwx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jyG::P64;
           _s1jyz::P64 = P64[_s1jyG::P64 + 16];
           _s1jyA::P64 = P64[_s1jyG::P64 + 24];
           I64[Hp - 24] = sat_s1jyF_info;
           P64[Hp - 8] = _s1jyz::P64;
           P64[Hp] = _s1jyA::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jyL_entry() //  [R1]
         { info_tbl: [(c1lwQ,
                       label: sat_s1jyL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lwQ: // global
           _s1jyL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1lwR; else goto c1lwS;
       c1lwS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lwU; else goto c1lwT;
       c1lwU: // global
           HpAlloc = 24;
           goto c1lwR;
       c1lwR: // global
           R1 = _s1jyL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lwT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jyL::P64;
           _s1jyz::P64 = P64[_s1jyL::P64 + 16];
           _s1jyA::P64 = P64[_s1jyL::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s1jyA::P64;
           I64[Sp - 24] = block_c1lwN_info;
           R4 = Hp - 14;
           R3 = _s1jyz::P64;
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1lwN() //  [R1, R2]
         { info_tbl: [(c1lwN,
                       label: block_c1lwN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lwN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lwX; else goto c1lwW;
       c1lwX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1lwW: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jyM_entry() //  [R1]
         { info_tbl: [(c1lwY,
                       label: sat_s1jyM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lwY: // global
           _s1jyM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1lwZ; else goto c1lx0;
       c1lx0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lx2; else goto c1lx1;
       c1lx2: // global
           HpAlloc = 32;
           goto c1lwZ;
       c1lwZ: // global
           R1 = _s1jyM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lx1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jyM::P64;
           _s1jyz::P64 = P64[_s1jyM::P64 + 16];
           _s1jyA::P64 = P64[_s1jyM::P64 + 24];
           I64[Hp - 24] = sat_s1jyL_info;
           P64[Hp - 8] = _s1jyz::P64;
           P64[Hp] = _s1jyA::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jyQ_entry() //  [R1]
         { info_tbl: [(c1lx6,
                       label: sat_s1jyQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lx6: // global
           _s1jyQ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1lx7; else goto c1lx8;
       c1lx8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lxa; else goto c1lx9;
       c1lxa: // global
           HpAlloc = 32;
           goto c1lx7;
       c1lx7: // global
           R1 = _s1jyQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lx9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jyQ::P64;
           _s1jyy::P64 = P64[_s1jyQ::P64 + 16];
           _s1jyz::P64 = P64[_s1jyQ::P64 + 24];
           _s1jyA::P64 = P64[_s1jyQ::P64 + 32];
           I64[Hp - 24] = sat_s1jyM_info;
           P64[Hp - 8] = _s1jyz::P64;
           P64[Hp] = _s1jyA::P64;
           I64[Sp - 24] = block_c1lx3_info;
           R4 = Hp - 24;
           R3 = _s1jyy::P64;
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1lx3() //  [R1, R2]
         { info_tbl: [(c1lx3,
                       label: block_c1lx3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lx3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lxd; else goto c1lxc;
       c1lxd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1lxc: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$s$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1lxh,
                       label: GHC.Real.$w$s$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lxh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1lxl; else goto c1lxk;
       c1lxl: // global
           HpAlloc = 40;
           R1 = GHC.Real.$w$s$cshowsPrec_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c1lxk: // global
           if (%MO_S_Le_W64(R2, 7)) goto c1lxf; else goto c1lxg;
       c1lxf: // global
           I64[Hp - 32] = sat_s1jyG_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           _c1lwd::P64 = Hp - 32;
           Hp = Hp - 8;
           R4 = _c1lwd::P64;
           R3 = R3;
           R2 = 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
       c1lxg: // global
           I64[Hp - 32] = sat_s1jyQ_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 32;
           R1 = GHC.Show.$fShow(,)4_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.86319291 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$cshowsPrec_closure" {
     GHC.Real.$fShowRatio_$s$cshowsPrec_closure:
         const GHC.Real.$fShowRatio_$s$cshowsPrec_info;
         const 0;
 },
 GHC.Real.$fShowRatio_$s$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lxt,
                       label: GHC.Real.$fShowRatio_$s$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lxt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lxE; else goto c1lxF;
       c1lxE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$s$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lxF: // global
           I64[Sp - 24] = block_c1lxq_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1lxM; else goto c1lxr;
       u1lxM: // global
           call _c1lxq(R1) args: 0, res: 0, upd: 0;
       c1lxr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lxq() //  [R1]
         { info_tbl: [(c1lxq,
                       label: block_c1lxq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lxq: // global
           I64[Sp] = block_c1lxw_info;
           _s1jyV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jyV::I64;
           if (R1 & 7 != 0) goto u1lxL; else goto c1lxx;
       u1lxL: // global
           call _c1lxw(R1) args: 0, res: 0, upd: 0;
       c1lxx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lxw() //  [R1]
         { info_tbl: [(c1lxw,
                       label: block_c1lxw_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lxw: // global
           _s1jyT::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1lxB_info;
           R5 = _s1jyT::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cshowsPrec_entry(R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lxB() //  [R1, R2]
         { info_tbl: [(c1lxB,
                       label: block_c1lxB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lxB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lxK; else goto c1lxJ;
       c1lxK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1lxJ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.86633107 UTC

[section ""data" . GHC.Real.$w$cshowsPrec_closure" {
     GHC.Real.$w$cshowsPrec_closure:
         const GHC.Real.$w$cshowsPrec_info;
 },
 GHC.Real.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lxO: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Real.$w$cshowsPrec_entry(R5,
                                             R4,
                                             R3,
                                             R2,
                                             R1) args: 8, res: 0, upd: 8;
     }
 },
 f_s1jz6_entry() //  [R1]
         { info_tbl: [(c1lxW,
                       label: f_s1jz6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lxW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1lxX; else goto c1lxY;
       c1lxX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lxY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 g1_s1jz7_entry() //  [R1]
         { info_tbl: [(c1ly3,
                       label: g1_s1jz7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ly3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ly4; else goto c1ly5;
       c1ly4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ly5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jzb_entry() //  [R1]
         { info_tbl: [(c1lyj,
                       label: sat_s1jzb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lyj: // global
           _s1jzb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1lyk; else goto c1lyl;
       c1lyl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lyn; else goto c1lym;
       c1lyn: // global
           HpAlloc = 32;
           goto c1lyk;
       c1lyk: // global
           R1 = _s1jzb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lym: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzb::P64;
           _s1jz7::P64 = P64[_s1jzb::P64 + 16];
           _s1jz9::P64 = P64[_s1jzb::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s1jz7::P64;
           P64[Hp] = _s1jz9::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzc_entry() //  [R1, R2]
         { info_tbl: [(c1lyo,
                       label: sat_s1jzc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lyo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lys; else goto c1lyr;
       c1lys: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1lyr: // global
           _s1jz6::P64 = P64[R1 + 7];
           _s1jz7::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s1jzb_info;
           P64[Hp - 8] = _s1jz7::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _s1jz6::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jzf_entry() //  [R1]
         { info_tbl: [(c1lyM,
                       label: sat_s1jzf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lyM: // global
           _s1jzf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1lyN; else goto c1lyO;
       c1lyO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lyQ; else goto c1lyP;
       c1lyQ: // global
           HpAlloc = 24;
           goto c1lyN;
       c1lyN: // global
           R1 = _s1jzf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lyP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzf::P64;
           _s1jz7::P64 = P64[_s1jzf::P64 + 16];
           _s1jzd::P64 = P64[_s1jzf::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s1jzd::P64;
           R2 = Hp - 14;
           R1 = _s1jz7::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzg_entry() //  [R1]
         { info_tbl: [(c1lyR,
                       label: sat_s1jzg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lyR: // global
           _s1jzg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1lyS; else goto c1lyT;
       c1lyT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lyV; else goto c1lyU;
       c1lyV: // global
           HpAlloc = 32;
           goto c1lyS;
       c1lyS: // global
           R1 = _s1jzg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lyU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzg::P64;
           _s1jz7::P64 = P64[_s1jzg::P64 + 16];
           _s1jzd::P64 = P64[_s1jzg::P64 + 24];
           I64[Hp - 24] = sat_s1jzf_info;
           P64[Hp - 8] = _s1jz7::P64;
           P64[Hp] = _s1jzd::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzh_entry() //  [R1]
         { info_tbl: [(c1lyW,
                       label: sat_s1jzh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lyW: // global
           _s1jzh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1lyX; else goto c1lyY;
       c1lyY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lz0; else goto c1lyZ;
       c1lz0: // global
           HpAlloc = 32;
           goto c1lyX;
       c1lyX: // global
           R1 = _s1jzh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lyZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzh::P64;
           _s1jz6::P64 = P64[_s1jzh::P64 + 16];
           _s1jz7::P64 = P64[_s1jzh::P64 + 24];
           _s1jzd::P64 = P64[_s1jzh::P64 + 32];
           I64[Hp - 24] = sat_s1jzg_info;
           P64[Hp - 8] = _s1jz7::P64;
           P64[Hp] = _s1jzd::P64;
           R2 = Hp - 24;
           R1 = _s1jz6::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzi_entry() //  [R1, R2]
         { info_tbl: [(c1lz2,
                       label: sat_s1jzi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lz2: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1lz6; else goto c1lz5;
       c1lz6: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1lz5: // global
           _s1jz6::P64 = P64[R1 + 7];
           _s1jz7::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s1jzh_info;
           P64[Hp - 40] = _s1jz6::P64;
           P64[Hp - 32] = _s1jz7::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$w$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1lza,
                       label: GHC.Real.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lza: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1lze; else goto c1lzd;
       c1lze: // global
           HpAlloc = 88;
           R1 = GHC.Real.$w$cshowsPrec_closure;
           P64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c1lzd: // global
           I64[Hp - 80] = f_s1jz6_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = g1_s1jz7_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R5;
           _c1lxS::P64 = Hp - 80;
           _c1lxZ::P64 = Hp - 48;
           if (%MO_S_Le_W64(R3, 7)) goto c1lz8; else goto c1lz9;
       c1lz8: // global
           I64[Hp - 16] = sat_s1jzc_info;
           P64[Hp - 8] = _c1lxS::P64;
           P64[Hp] = _c1lxZ::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1lz9: // global
           I64[Hp - 16] = sat_s1jzi_info;
           P64[Hp - 8] = _c1lxS::P64;
           P64[Hp] = _c1lxZ::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.870385021 UTC

[section ""data" . GHC.Real.$fShowRatio_$cshowsPrec_closure" {
     GHC.Real.$fShowRatio_$cshowsPrec_closure:
         const GHC.Real.$fShowRatio_$cshowsPrec_info;
 },
 GHC.Real.$fShowRatio_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lzm,
                       label: GHC.Real.$fShowRatio_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lzm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lzq; else goto c1lzr;
       c1lzq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lzr: // global
           I64[Sp - 24] = block_c1lzj_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1lzz; else goto c1lzk;
       u1lzz: // global
           call _c1lzj(R1) args: 0, res: 0, upd: 0;
       c1lzk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lzj() //  [R1]
         { info_tbl: [(c1lzj,
                       label: block_c1lzj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lzj: // global
           I64[Sp] = block_c1lzp_info;
           _s1jzn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s1jzn::I64;
           if (R1 & 7 != 0) goto u1lzy; else goto c1lzt;
       u1lzy: // global
           call _c1lzp(R1) args: 0, res: 0, upd: 0;
       c1lzt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lzp() //  [R1]
         { info_tbl: [(c1lzp,
                       label: block_c1lzp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lzp: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cshowsPrec_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.871957629 UTC

[section ""data" . GHC.Real.$fShowRatio1_closure" {
     GHC.Real.$fShowRatio1_closure:
         const GHC.Real.$fShowRatio1_info;
         const 0;
 },
 GHC.Real.$fShowRatio1_entry() //  [R2, R3]
         { info_tbl: [(c1lzH,
                       label: GHC.Real.$fShowRatio1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lzH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lzN; else goto c1lzO;
       c1lzN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lzO: // global
           I64[Sp - 16] = block_c1lzE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lzT; else goto c1lzF;
       u1lzT: // global
           call _c1lzE(R1) args: 0, res: 0, upd: 0;
       c1lzF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lzE() //  [R1]
         { info_tbl: [(c1lzE,
                       label: block_c1lzE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lzE: // global
           _s1jzs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lzK_info;
           R5 = _s1jzs::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cshowsPrec_entry(R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lzK() //  [R1, R2]
         { info_tbl: [(c1lzK,
                       label: block_c1lzK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lzK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lzS; else goto c1lzR;
       c1lzS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1lzR: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.873460642 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$cshowList_closure" {
     GHC.Real.$fShowRatio_$s$cshowList_closure:
         const GHC.Real.$fShowRatio_$s$cshowList_info;
         const 0;
 },
 GHC.Real.$fShowRatio_$s$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c1lzY,
                       label: GHC.Real.$fShowRatio_$s$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lzY: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Real.$fShowRatio1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.874618104 UTC

[section ""data" . GHC.Real.$fShowRatio_$cshowList_closure" {
     GHC.Real.$fShowRatio_$cshowList_closure:
         const GHC.Real.$fShowRatio_$cshowList_info;
 },
 sat_s1jzI_entry() //  [R1, R2]
         { info_tbl: [(c1lAd,
                       label: sat_s1jzI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lAd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lAe; else goto c1lAf;
       c1lAe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1lAf: // global
           I64[Sp - 16] = block_c1lAa_info;
           _s1jzB::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s1jzB::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lAj; else goto c1lAb;
       u1lAj: // global
           call _c1lAa(R1) args: 0, res: 0, upd: 0;
       c1lAb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lAa() //  [R1]
         { info_tbl: [(c1lAa,
                       label: block_c1lAa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lAa: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = 0;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cshowsPrec_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fShowRatio_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lAk,
                       label: GHC.Real.$fShowRatio_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lAk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1lAo; else goto c1lAn;
       c1lAo: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lAn: // global
           I64[Hp - 8] = sat_s1jzI_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.876467787 UTC

[section ""data" . GHC.Real.$w$s$cshow_closure" {
     GHC.Real.$w$s$cshow_closure:
         const GHC.Real.$w$s$cshow_info;
         const 0;
 },
 sat_s1jzO_entry() //  [R1]
         { info_tbl: [(c1lAE,
                       label: sat_s1jzO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lAE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lAF; else goto c1lAG;
       c1lAF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lAG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1lAB_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[R1 + 16];
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1lAB() //  [R1, R2]
         { info_tbl: [(c1lAB,
                       label: block_c1lAB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lAB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lAJ; else goto c1lAI;
       c1lAJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1lAI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzP_entry() //  [R1]
         { info_tbl: [(c1lAK,
                       label: sat_s1jzP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lAK: // global
           _s1jzP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1lAL; else goto c1lAM;
       c1lAM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lAO; else goto c1lAN;
       c1lAO: // global
           HpAlloc = 24;
           goto c1lAL;
       c1lAL: // global
           R1 = _s1jzP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lAN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzP::P64;
           _s1jzK::P64 = P64[_s1jzP::P64 + 16];
           I64[Hp - 16] = sat_s1jzO_info;
           P64[Hp] = _s1jzK::P64;
           R3 = Hp - 16;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$s$cshow_entry() //  [R2, R3]
         { info_tbl: [(c1lAP,
                       label: GHC.Real.$w$s$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lAP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lAT; else goto c1lAS;
       c1lAT: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lAS: // global
           I64[Hp - 16] = sat_s1jzP_info;
           P64[Hp] = R3;
           R4 = Hp - 16;
           R3 = R2;
           R2 = 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.878511659 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$cshow_closure" {
     GHC.Real.$fShowRatio_$s$cshow_closure:
         const GHC.Real.$fShowRatio_$s$cshow_info;
         const 0;
 },
 GHC.Real.$fShowRatio_$s$cshow_entry() //  [R2]
         { info_tbl: [(c1lB1,
                       label: GHC.Real.$fShowRatio_$s$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lB1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1lB7; else goto c1lB8;
       c1lB7: // global
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$s$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1lB8: // global
           I64[Sp - 8] = block_c1lAY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1lBd; else goto c1lAZ;
       u1lBd: // global
           call _c1lAY(R1) args: 0, res: 0, upd: 0;
       c1lAZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lAY() //  [R1]
         { info_tbl: [(c1lAY,
                       label: block_c1lAY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lAY: // global
           I64[Sp] = block_c1lB4_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$cshow_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lB4() //  [R1, R2]
         { info_tbl: [(c1lB4,
                       label: block_c1lB4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lB4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lBc; else goto c1lBb;
       c1lBc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1lBb: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.88020526 UTC

[section ""data" . GHC.Real.$w$cshow_closure" {
     GHC.Real.$w$cshow_closure:
         const GHC.Real.$w$cshow_info;
 },
 sat_s1jA0_entry() //  [R1]
         { info_tbl: [(c1lBq,
                       label: sat_s1jA0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lBq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1lBr; else goto c1lBs;
       c1lBr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lBs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s1jA1_entry() //  [R1]
         { info_tbl: [(c1lBt,
                       label: sat_s1jA1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lBt: // global
           _s1jA1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1lBu; else goto c1lBv;
       c1lBv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lBx; else goto c1lBw;
       c1lBx: // global
           HpAlloc = 32;
           goto c1lBu;
       c1lBu: // global
           R1 = _s1jA1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lBw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jA1::P64;
           _s1jzX::P64 = P64[_s1jA1::P64 + 16];
           _s1jzZ::P64 = P64[_s1jA1::P64 + 24];
           I64[Hp - 24] = sat_s1jA0_info;
           P64[Hp - 8] = _s1jzX::P64;
           P64[Hp] = _s1jzZ::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$cshow_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lBy,
                       label: GHC.Real.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lBy: // global
           _s1jzZ::P64 = R4;
           _s1jzY::P64 = R3;
           _s1jzX::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto c1lBz; else goto c1lBA;
       c1lBA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lBC; else goto c1lBB;
       c1lBC: // global
           HpAlloc = 32;
           goto c1lBz;
       c1lBz: // global
           R4 = _s1jzZ::P64;
           R3 = _s1jzY::P64;
           R2 = _s1jzX::P64;
           R1 = GHC.Real.$w$cshow_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lBB: // global
           I64[Hp - 24] = sat_s1jA1_info;
           P64[Hp - 8] = _s1jzX::P64;
           P64[Hp] = _s1jzZ::P64;
           R2 = _s1jzX::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 16] = _s1jzY::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.882089068 UTC

[section ""data" . GHC.Real.$fShowRatio_$cshow_closure" {
     GHC.Real.$fShowRatio_$cshow_closure:
         const GHC.Real.$fShowRatio_$cshow_info;
 },
 GHC.Real.$fShowRatio_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c1lBK,
                       label: GHC.Real.$fShowRatio_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lBK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lBL; else goto c1lBM;
       c1lBL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lBM: // global
           I64[Sp - 16] = block_c1lBH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lBQ; else goto c1lBI;
       u1lBQ: // global
           call _c1lBH(R1) args: 0, res: 0, upd: 0;
       c1lBI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lBH() //  [R1]
         { info_tbl: [(c1lBH,
                       label: block_c1lBH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lBH: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cshow_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.883102823 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$fShowRatio_closure" {
     GHC.Real.$fShowRatio_$s$fShowRatio_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Real.$fShowRatio_$s$cshowsPrec_closure+3;
         const GHC.Real.$fShowRatio_$s$cshow_closure+1;
         const GHC.Real.$fShowRatio_$s$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.884245645 UTC

[section ""data" . GHC.Real.$fShowRatio_closure" {
     GHC.Real.$fShowRatio_closure:
         const GHC.Real.$fShowRatio_info;
 },
 sat_s1jAa_entry() //  [R1, R2, R3]
         { info_tbl: [(c1lC0,
                       label: sat_s1jAa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lC0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fShowRatio_$cshowList_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jA9_entry() //  [R1, R2]
         { info_tbl: [(c1lC8,
                       label: sat_s1jA9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lC8: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fShowRatio_$cshow_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jA8_entry() //  [R1, R2, R3]
         { info_tbl: [(c1lCg,
                       label: sat_s1jA8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lCg: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fShowRatio_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fShowRatio_entry() //  [R2]
         { info_tbl: [(c1lCk,
                       label: GHC.Real.$fShowRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lCk: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1lCo; else goto c1lCn;
       c1lCo: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1lCn: // global
           I64[Hp - 72] = sat_s1jAa_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1jA9_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s1jA8_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.887604374 UTC

[section ""data" . GHC.Real.$w$slcm_closure" {
     GHC.Real.$w$slcm_closure:
         const GHC.Real.$w$slcm_info;
         const 0;
 },
 section ""relreadonly" . u1lD4_srtd" {
     u1lD4_srtd:
         const S1jKw_srt+856;
         const 64;
         const 13835093239654252545;
 },
 GHC.Real.$w$slcm_entry() //  [R2, R3]
         { info_tbl: [(c1lCx,
                       label: GHC.Real.$w$slcm_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lCx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lCy; else goto c1lCz;
       c1lCy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$slcm_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lCz: // global
           if (R3 == 0) goto c1lCw; else goto c1lCv;
       c1lCw: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1lCv: // global
           I64[Sp - 16] = block_c1lCB_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lD3; else goto c1lCC;
       u1lD3: // global
           call _c1lCB(R1) args: 0, res: 0, upd: 0;
       c1lCC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lD5_srtd" {
     u1lD5_srtd:
         const S1jKw_srt+856;
         const 63;
         const 4611721202799476737;
 },
 _c1lCB() //  [R1]
         { info_tbl: [(c1lCB,
                       label: block_c1lCB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lCB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1lCI; else goto c1lCH;
       c1lCI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lCH: // global
           _s1jAg::I64 = I64[R1 + 7];
           if (_s1jAg::I64 == 0) goto c1lD2; else goto c1lCO;
       c1lD2: // global
           Hp = Hp - 16;
           R1 = 0;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1lCO: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp - 8] = block_c1lCM_info;
           R4 = Hp - 7;
           R3 = R1;
           R2 = GHC.Real.$fIntegralWord_closure+1;
           I64[Sp] = _s1jAg::I64;
           Sp = Sp - 8;
           call GHC.Real.gcd_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lCM() //  [R1]
         { info_tbl: [(c1lCM,
                       label: block_c1lCM_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lCM: // global
           _s1jAk::I64 = I64[R1 + 7];
           if (_s1jAk::I64 != 0) goto c1lD0; else goto c1lD1;
       c1lD0: // global
           R1 = I64[Sp + 8] / _s1jAk::I64 * I64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1lD1: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.889589515 UTC

[section ""data" . GHC.Real.lcm_$slcm_closure" {
     GHC.Real.lcm_$slcm_closure:
         const GHC.Real.lcm_$slcm_info;
         const 0;
 },
 GHC.Real.lcm_$slcm_entry() //  [R2, R3]
         { info_tbl: [(c1lDd,
                       label: GHC.Real.lcm_$slcm_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lDd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lDl; else goto c1lDm;
       c1lDl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.lcm_$slcm_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lDm: // global
           I64[Sp - 16] = block_c1lDa_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lDr; else goto c1lDb;
       u1lDr: // global
           call _c1lDa(R1) args: 0, res: 0, upd: 0;
       c1lDb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lDa() //  [R1]
         { info_tbl: [(c1lDa,
                       label: block_c1lDa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lDa: // global
           _s1jAn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lDg_info;
           R3 = I64[R1 + 7];
           R2 = _s1jAn::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$slcm_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lDg() //  [R1]
         { info_tbl: [(c1lDg,
                       label: block_c1lDg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lDg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1lDq; else goto c1lDp;
       c1lDq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1lDp: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.892019367 UTC

[section ""data" . GHC.Real.$w$slcm1_closure" {
     GHC.Real.$w$slcm1_closure:
         const GHC.Real.$w$slcm1_info;
         const 0;
 },
 sat_s1jAC_entry() //  [R1]
         { info_tbl: [(c1lDT,
                       label: sat_s1jAC_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lDT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1lDX; else goto c1lDW;
       c1lDX: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lDW: // global
           _s1jAx::I64 = I64[R1 + 24];
           if (%MO_S_Lt_W64(_s1jAx::I64, 0)) goto c1lDR; else goto c1lDS;
       c1lDR: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_s1jAx::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1lDS: // global
           _s1jAv::P64 = P64[R1 + 16];
           Hp = Hp - 16;
           R1 = _s1jAv::P64 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1lFf_srtd" {
     u1lFf_srtd:
         const S1jKw_srt+344;
         const 130;
         const 17;
         const 35184372088832;
         const 2;
 },
 GHC.Real.$w$slcm1_entry() //  [R2, R3]
         { info_tbl: [(c1lE6,
                       label: GHC.Real.$w$slcm1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lE6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1lE7; else goto c1lE8;
       c1lE7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$slcm1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lE8: // global
           if (R3 == 0) goto u1lFe; else goto c1lE4;
       u1lFe: // global
           call _c1lE5() args: 0, res: 0, upd: 0;
       c1lE4: // global
           I64[Sp - 16] = block_c1lDy_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lFd; else goto c1lDz;
       u1lFd: // global
           call _c1lDy(R1) args: 0, res: 0, upd: 0;
       c1lDz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lFg_srtd" {
     u1lFg_srtd:
         const S1jKw_srt+344;
         const 110;
         const 17;
         const 35184372088832;
 },
 _c1lDy() //  [R1]
         { info_tbl: [(c1lDy,
                       label: block_c1lDy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lDy: // global
           _s1jAx::I64 = I64[R1 + 7];
           if (_s1jAx::I64 == 0) goto u1lF5; else goto c1lF0;
       u1lF5: // global
           Sp = Sp + 16;
           call _c1lE5() args: 0, res: 0, upd: 0;
       c1lF0: // global
           _s1jAu::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s1jAu::I64, 0)) goto c1lEX; else goto c1lEY;
       c1lEX: // global
           I64[Sp - 16] = _s1jAx::I64;
           I64[Sp - 8] = -_s1jAu::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           goto u1lFb;
       c1lEY: // global
           P64[Sp] = R1;
           I64[Sp - 16] = _s1jAx::I64;
           I64[Sp - 8] = _s1jAu::I64;
           Sp = Sp - 16;
           goto u1lFb;
       u1lFb: // global
           call _c1lDI() args: 0, res: 0, upd: 0;
     }
 },
 _c1lE5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lE5: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1lDI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lDI: // global
           Hp = Hp + 32;
           _s1jAz::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c1lEd; else goto c1lEc;
       c1lEd: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_c1lDH_info;
           R1 = _s1jAz::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1lEc: // global
           I64[Hp - 24] = sat_s1jAC_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp];
           I64[Sp - 8] = block_c1lEa_info;
           R3 = _s1jAz::I64;
           R2 = Hp - 24;
           Sp = Sp - 8;
           call GHC.Real.$wgcd'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lFh_srtd" {
     u1lFh_srtd:
         const S1jKw_srt+344;
         const 110;
         const 17;
         const 35184372088832;
 },
 _c1lDH() //  [R1]
         { info_tbl: [(c1lDH,
                       label: block_c1lDH_info
                       rep:StackRep [True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lDH: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c1lDI() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1lFi_srtd" {
     u1lFi_srtd:
         const S1jKw_srt+344;
         const 110;
         const 1;
         const 35184372088832;
 },
 _c1lEa() //  [R1]
         { info_tbl: [(c1lEa,
                       label: block_c1lEa_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lEa: // global
           _s1jAu::I64 = I64[Sp + 32];
           _s1jAx::I64 = I64[Sp + 8];
           _s1jAF::I64 = I64[R1 + 7];
           if (_s1jAF::I64 != (-1)) goto u1lF4; else goto c1lES;
       u1lF4: // global
           if (_s1jAF::I64 != 0) goto c1lEy; else goto c1lET;
       c1lEy: // global
           _s1jAH::I64 = %MO_S_Quot_W64(_s1jAx::I64,
                                        _s1jAF::I64) * _s1jAu::I64;
           if (%MO_S_Lt_W64(_s1jAH::I64, 0)) goto c1lEv; else goto c1lEw;
       c1lEv: // global
           R1 = -_s1jAH::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1lEw: // global
           R1 = _s1jAH::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1lET: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1lES: // global
           if (_s1jAx::I64 == (-9223372036854775808)) goto c1lER; else goto c1lEQ;
       c1lER: // global
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1lEQ: // global
           _s1jAK::I64 = %MO_S_Quot_W64(_s1jAx::I64, (-1)) * _s1jAu::I64;
           if (%MO_S_Lt_W64(_s1jAK::I64, 0)) goto c1lEN; else goto c1lEO;
       c1lEN: // global
           R1 = -_s1jAK::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1lEO: // global
           R1 = _s1jAK::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.895213718 UTC

[section ""data" . GHC.Real.lcm_$slcm1_closure" {
     GHC.Real.lcm_$slcm1_closure:
         const GHC.Real.lcm_$slcm1_info;
         const 0;
 },
 GHC.Real.lcm_$slcm1_entry() //  [R2, R3]
         { info_tbl: [(c1lFq,
                       label: GHC.Real.lcm_$slcm1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lFq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lFy; else goto c1lFz;
       c1lFy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.lcm_$slcm1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lFz: // global
           I64[Sp - 16] = block_c1lFn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lFE; else goto c1lFo;
       u1lFE: // global
           call _c1lFn(R1) args: 0, res: 0, upd: 0;
       c1lFo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lFn() //  [R1]
         { info_tbl: [(c1lFn,
                       label: block_c1lFn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lFn: // global
           _s1jAR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lFt_info;
           R3 = I64[R1 + 7];
           R2 = _s1jAR::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$slcm1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lFt() //  [R1]
         { info_tbl: [(c1lFt,
                       label: block_c1lFt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lFt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1lFD; else goto c1lFC;
       c1lFD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1lFC: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.898152487 UTC

[section ""data" . GHC.Real.lcm_closure" {
     GHC.Real.lcm_closure:
         const GHC.Real.lcm_info;
         const 0;
 },
 sat_s1jB3_entry() //  [R1]
         { info_tbl: [(c1lG3,
                       label: sat_s1jB3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lG3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lG4; else goto c1lG5;
       c1lG4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lG5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jB5_entry() //  [R1]
         { info_tbl: [(c1lGe,
                       label: sat_s1jB5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lGe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lGf; else goto c1lGg;
       c1lGf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lGg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jB7_entry() //  [R1]
         { info_tbl: [(c1lGx,
                       label: sat_s1jB7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lGx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lGy; else goto c1lGz;
       c1lGy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lGz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.gcd_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jB8_entry() //  [R1]
         { info_tbl: [(c1lGA,
                       label: sat_s1jB8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lGA: // global
           _s1jB8::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1lGB; else goto c1lGC;
       c1lGC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1lGE; else goto c1lGD;
       c1lGE: // global
           HpAlloc = 40;
           goto c1lGB;
       c1lGB: // global
           R1 = _s1jB8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lGD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jB8::P64;
           _s1jAW::P64 = P64[_s1jB8::P64 + 16];
           _s1jAX::P64 = P64[_s1jB8::P64 + 24];
           _s1jAY::P64 = P64[_s1jB8::P64 + 32];
           I64[Hp - 32] = sat_s1jB7_info;
           P64[Hp - 16] = _s1jAW::P64;
           P64[Hp - 8] = _s1jAX::P64;
           P64[Hp] = _s1jAY::P64;
           R2 = _s1jAW::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1jAX::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jB9_entry() //  [R1]
         { info_tbl: [(c1lGF,
                       label: sat_s1jB9_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lGF: // global
           _s1jB9::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1lGG; else goto c1lGH;
       c1lGH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1lGJ; else goto c1lGI;
       c1lGJ: // global
           HpAlloc = 40;
           goto c1lGG;
       c1lGG: // global
           R1 = _s1jB9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lGI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jB9::P64;
           _s1jAW::P64 = P64[_s1jB9::P64 + 16];
           _s1jAX::P64 = P64[_s1jB9::P64 + 24];
           _s1jAY::P64 = P64[_s1jB9::P64 + 32];
           _s1jB0::P64 = P64[_s1jB9::P64 + 40];
           I64[Hp - 32] = sat_s1jB8_info;
           P64[Hp - 16] = _s1jAW::P64;
           P64[Hp - 8] = _s1jAX::P64;
           P64[Hp] = _s1jAY::P64;
           R2 = _s1jB0::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _s1jAY::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.lcm_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lGK,
                       label: GHC.Real.lcm_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lGK: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1lGL; else goto c1lGM;
       c1lGL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.lcm_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lGM: // global
           I64[Sp - 32] = block_c1lFJ_info;
           _s1jAW::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1jAW::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lFJ() //  [R1]
         { info_tbl: [(c1lFJ,
                       label: block_c1lFJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lFJ: // global
           I64[Sp - 8] = block_c1lFN_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lFN() //  [R1]
         { info_tbl: [(c1lFN,
                       label: block_c1lFN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lFN: // global
           I64[Sp] = block_c1lFR_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lFR() //  [R1]
         { info_tbl: [(c1lFR,
                       label: block_c1lFR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lFR: // global
           I64[Sp] = block_c1lFV_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lFV() //  [R1]
         { info_tbl: [(c1lFV,
                       label: block_c1lFV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lFV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lGS; else goto c1lGR;
       c1lGS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lGR: // global
           I64[Hp - 16] = sat_s1jB3_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1lG6_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1lG6() //  [R1]
         { info_tbl: [(c1lG6,
                       label: block_c1lG6_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lG6: // global
           if (R1 & 7 == 1) goto c1lGU; else goto u1lHd;
       c1lGU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lGX; else goto c1lGW;
       c1lGX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lGW: // global
           I64[Hp - 16] = sat_s1jB5_info;
           P64[Hp] = P64[Sp + 16];
           _s1jB2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lGh_info;
           R2 = _s1jB2::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       u1lHd: // global
           Sp = Sp + 16;
           call _c1lHa() args: 0, res: 0, upd: 0;
     }
 },
 _c1lGh() //  [R1]
         { info_tbl: [(c1lGh,
                       label: block_c1lGh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lGh: // global
           if (R1 & 7 == 1) goto c1lGZ; else goto u1lHe;
       c1lGZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1lH2; else goto c1lH1;
       c1lH2: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lH1: // global
           I64[Hp - 40] = sat_s1jB9_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           _s1jB0::P64 = P64[Sp + 8];
           P64[Hp] = _s1jB0::P64;
           R2 = _s1jB0::P64;
           I64[Sp + 24] = stg_ap_p_info;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 8;
       u1lHe: // global
           Sp = Sp + 8;
           call _c1lHa() args: 0, res: 0, upd: 0;
     }
 },
 _c1lHa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lHa: // global
           R2 = P64[Sp];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = GHC.Real.even1_closure;
           Sp = Sp + 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.902748402 UTC

[section ""data" . GHC.Real.$w$ctoEnum_closure" {
     GHC.Real.$w$ctoEnum_closure:
         const GHC.Real.$w$ctoEnum_info;
         const 0;
 },
 sat_s1jBg_entry() //  [R1]
         { info_tbl: [(c1lHA,
                       label: sat_s1jBg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lHA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lHB; else goto c1lHC;
       c1lHB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lHC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1lHx_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1lHG; else goto c1lHy;
       u1lHG: // global
           call _c1lHx(R1) args: 0, res: 0, upd: 0;
       c1lHy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1lHx() //  [R1]
         { info_tbl: [(c1lHx,
                       label: block_c1lHx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lHx: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c1lHH,
                       label: GHC.Real.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lHH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lHL; else goto c1lHM;
       c1lHL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lHM: // global
           I64[Sp - 16] = block_c1lHl_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lHl() //  [R1]
         { info_tbl: [(c1lHl,
                       label: block_c1lHl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lHl: // global
           I64[Sp] = block_c1lHp_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lHp() //  [R1]
         { info_tbl: [(c1lHp,
                       label: block_c1lHp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lHp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lHQ; else goto c1lHP;
       c1lHQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lHP: // global
           I64[Hp - 16] = sat_s1jBg_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c1lHI_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1lHI() //  [R1]
         { info_tbl: [(c1lHI,
                       label: block_c1lHI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lHI: // global
           I64[Sp] = block_c1lHK_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Real.$fEnumRatio1_closure;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1lHK() //  [R1]
         { info_tbl: [(c1lHK,
                       label: block_c1lHK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lHK: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.904887871 UTC

[section ""data" . GHC.Real.$fEnumRatio_$ctoEnum_closure" {
     GHC.Real.$fEnumRatio_$ctoEnum_closure:
         const GHC.Real.$fEnumRatio_$ctoEnum_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c1lI1,
                       label: GHC.Real.$fEnumRatio_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lI1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1lI2; else goto c1lI3;
       c1lI2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lI3: // global
           I64[Sp - 8] = block_c1lHY_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$ctoEnum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lHY() //  [R1, R2]
         { info_tbl: [(c1lHY,
                       label: block_c1lHY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lHY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lI6; else goto c1lI5;
       c1lI6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1lI5: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.906082638 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$fEnumRatio_closure" {
     GHC.Real.$fEnumRatio_$s$fEnumRatio_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Real.$fEnumRatio_$s$csucc_closure+1;
         const GHC.Real.$fEnumRatio_$s$cpred_closure+1;
         const GHC.Real.$fEnumRatio_$ctoRational_closure+1;
         const GHC.Real.$fEnumRatio_$s$cfromEnum_closure+1;
         const GHC.Real.$fEnumRatio_$snumericEnumFrom_closure+1;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure+2;
         const GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure+2;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.90780516 UTC

[section ""data" . GHC.Real.$fEnumRatio_closure" {
     GHC.Real.$fEnumRatio_closure:
         const GHC.Real.$fEnumRatio_info;
         const 0;
 },
 sat_s1jBw_entry() //  [R1]
         { info_tbl: [(c1lIf,
                       label: sat_s1jBw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lIf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lIg; else goto c1lIh;
       c1lIg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lIh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jBv_entry() //  [R1]
         { info_tbl: [(c1lIm,
                       label: sat_s1jBv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lIm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lIn; else goto c1lIo;
       c1lIn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lIo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jBu_entry() //  [R1]
         { info_tbl: [(c1lIt,
                       label: sat_s1jBu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lIt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lIu; else goto c1lIv;
       c1lIu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lIv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jBt_entry() //  [R1]
         { info_tbl: [(c1lIA,
                       label: sat_s1jBt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lIA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lIB; else goto c1lIC;
       c1lIB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lIC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jBs_entry() //  [R1, R2]
         { info_tbl: [(c1lII,
                       label: sat_s1jBs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lII: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$cfromEnum_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jBr_entry() //  [R1, R2]
         { info_tbl: [(c1lIQ,
                       label: sat_s1jBr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lIQ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$ctoEnum_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jBq_entry() //  [R1, R2]
         { info_tbl: [(c1lIY,
                       label: sat_s1jBq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lIY: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$cpred_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jBp_entry() //  [R1, R2]
         { info_tbl: [(c1lJ6,
                       label: sat_s1jBp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lJ6: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$csucc_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEnumRatio_entry() //  [R2]
         { info_tbl: [(c1lJa,
                       label: GHC.Real.$fEnumRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lJa: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c1lJe; else goto c1lJd;
       c1lJe: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1lJd: // global
           I64[Hp - 224] = sat_s1jBw_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s1jBv_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s1jBu_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1jBt_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s1jBs_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s1jBr_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s1jBq_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s1jBp_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = Hp - 95;
           P64[Hp - 40] = Hp - 111;
           P64[Hp - 32] = Hp - 127;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.911045917 UTC

[section ""data" . $wg_r1j3P_closure" {
     $wg_r1j3P_closure:
         const $wg_r1j3P_info;
 },
 $wg_r1j3P_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lJo,
                       label: $wg_r1j3P_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lJo: // global
           _s1jBz::I64 = R4;
           _s1jBy::I64 = R3;
           _s1jBx::I64 = R2;
           goto c1lJg;
       c1lJg: // global
           if (_s1jBy::I64 - (_s1jBy::I64 + (_s1jBy::I64 >> 63)) & (-2) == 0) goto c1lJn; else goto c1lJm;
       c1lJn: // global
           _s1jBy::I64 = %MO_S_Shr_W64(_s1jBy::I64 + (_s1jBy::I64 >> 63), 1);
           _s1jBx::I64 = _s1jBx::I64 * _s1jBx::I64;
           goto c1lJg;
       c1lJm: // global
           if (_s1jBy::I64 == 1) goto c1lJC; else goto c1lJy;
       c1lJC: // global
           R1 = _s1jBx::I64 * _s1jBz::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1lJy: // global
           _s1jBz::I64 = _s1jBx::I64 * _s1jBz::I64;
           _s1jBy::I64 = %MO_S_Shr_W64(_s1jBy::I64 + (_s1jBy::I64 >> 63), 1);
           _s1jBx::I64 = _s1jBx::I64 * _s1jBx::I64;
           goto c1lJg;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.912312197 UTC

[section ""data" . GHC.Real.$wf1_closure" {
     GHC.Real.$wf1_closure:
         const GHC.Real.$wf1_info;
 },
 GHC.Real.$wf1_entry() //  [R2, R3]
         { info_tbl: [(c1lK2,
                       label: GHC.Real.$wf1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lK2: // global
           _s1jBI::I64 = R3;
           _s1jBH::I64 = R2;
           goto c1lJU;
       c1lJU: // global
           if (_s1jBI::I64 - (_s1jBI::I64 + (_s1jBI::I64 >> 63)) & (-2) == 0) goto c1lK1; else goto c1lK0;
       c1lK1: // global
           _s1jBI::I64 = %MO_S_Shr_W64(_s1jBI::I64 + (_s1jBI::I64 >> 63), 1);
           _s1jBH::I64 = _s1jBH::I64 * _s1jBH::I64;
           goto c1lJU;
       c1lK0: // global
           if (_s1jBI::I64 == 1) goto c1lKd; else goto c1lKc;
       c1lKd: // global
           R1 = _s1jBH::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1lKc: // global
           R4 = _s1jBH::I64;
           R3 = %MO_S_Shr_W64(_s1jBI::I64 + (_s1jBI::I64 >> 63), 1);
           R2 = _s1jBH::I64 * _s1jBH::I64;
           call $wg_r1j3P_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.9137371 UTC

[section ""data" . GHC.Real.^_f2_closure" {
     GHC.Real.^_f2_closure:
         const GHC.Real.^_f2_info;
 },
 GHC.Real.^_f2_entry() //  [R2, R3]
         { info_tbl: [(c1lKz,
                       label: GHC.Real.^_f2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lKz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lKM; else goto c1lKN;
       c1lKM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_f2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lKN: // global
           I64[Sp - 16] = block_c1lKw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lKU; else goto c1lKx;
       u1lKU: // global
           call _c1lKw(R1) args: 0, res: 0, upd: 0;
       c1lKx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lKw() //  [R1]
         { info_tbl: [(c1lKw,
                       label: block_c1lKw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lKw: // global
           I64[Sp] = block_c1lKC_info;
           _s1jBS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jBS::I64;
           if (R1 & 7 != 0) goto u1lKT; else goto c1lKD;
       u1lKT: // global
           call _c1lKC(R1) args: 0, res: 0, upd: 0;
       c1lKD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lKC() //  [R1]
         { info_tbl: [(c1lKC,
                       label: block_c1lKC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lKC: // global
           _s1jBS::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1lKH_info;
           R3 = I64[R1 + 7];
           R2 = _s1jBS::I64;
           Sp = Sp + 8;
           call GHC.Real.$wf1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lKH() //  [R1]
         { info_tbl: [(c1lKH,
                       label: block_c1lKH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lKH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1lKS; else goto c1lKR;
       c1lKS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1lKR: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.91514481 UTC

[section ""data" . GHC.Real.^3_closure" {
     GHC.Real.^3_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.915947515 UTC

[section ""data" . GHC.Real.^2_closure" {
     GHC.Real.^2_closure:
         const GHC.Real.^2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.^2_entry() //  [R1]
         { info_tbl: [(c1lL3,
                       label: GHC.Real.^2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lL3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lL4; else goto c1lL5;
       c1lL4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lL5: // global
           (_c1lKY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1lKY::I64 == 0) goto c1lL0; else goto c1lKZ;
       c1lL0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1lKZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1lKY::I64;
           I64[Sp - 24] = block_c1lL1_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1lL1() //  [R1]
         { info_tbl: [(c1lL1,
                       label: block_c1lL1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lL1: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.917590731 UTC

[section ""data" . GHC.Real.^_$s^2_closure" {
     GHC.Real.^_$s^2_closure:
         const GHC.Real.^_$s^2_info;
         const 0;
 },
 GHC.Real.^_$s^2_entry() //  [R2, R3]
         { info_tbl: [(c1lLg,
                       label: GHC.Real.^_$s^2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lLg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lLh; else goto c1lLi;
       c1lLh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_$s^2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lLi: // global
           I64[Sp - 16] = block_c1lLd_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lLM; else goto c1lLe;
       u1lLM: // global
           call _c1lLd(R1) args: 0, res: 0, upd: 0;
       c1lLe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lLd() //  [R1]
         { info_tbl: [(c1lLd,
                       label: block_c1lLd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lLd: // global
           _s1jC0::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1jC0::I64, 0)) goto c1lLJ; else goto c1lLK;
       c1lLJ: // global
           if (_s1jC0::I64 == 0) goto c1lLH; else goto c1lLC;
       c1lLH: // global
           R1 = GHC.Real.^3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1lLC: // global
           I64[Sp] = block_c1lLr_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jC0::I64;
           if (R1 & 7 != 0) goto u1lLL; else goto c1lLs;
       u1lLL: // global
           call _c1lLr(R1) args: 0, res: 0, upd: 0;
       c1lLs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1lLK: // global
           R1 = GHC.Real.^2_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1lLr() //  [R1]
         { info_tbl: [(c1lLr,
                       label: block_c1lLr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lLr: // global
           _s1jC2::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1lLw_info;
           R3 = _s1jC2::I64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Real.$wf1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lLw() //  [R1]
         { info_tbl: [(c1lLw,
                       label: block_c1lLw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lLw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1lLG; else goto c1lLF;
       c1lLG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1lLF: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.921382074 UTC

[section ""data" . $wg1_r1j3Q_closure" {
     $wg1_r1j3Q_closure:
         const $wg1_r1j3Q_info;
         const 0;
 },
 $wg1_r1j3Q_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lLW,
                       label: $wg1_r1j3Q_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lLW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lLX; else goto u1lMz;
       c1lLX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wg1_r1j3Q_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u1lMz: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c1lLO() args: 0, res: 0, upd: 0;
     }
 },
 _c1lLO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lLO: // global
           _s1jC6::P64 = P64[Sp];
           _s1jC7::I64 = I64[Sp + 8];
           if (_s1jC7::I64 - (_s1jC7::I64 + (_s1jC7::I64 >> 63)) & (-2) == 0) goto c1lLV; else goto c1lLU;
       c1lLV: // global
           I64[Sp] = block_c1lMt_info;
           R3 = _s1jC6::P64;
           R2 = _s1jC6::P64;
           I64[Sp + 8] = %MO_S_Shr_W64(_s1jC7::I64 + (_s1jC7::I64 >> 63), 1);
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       c1lLU: // global
           _s1jC8::P64 = P64[Sp + 16];
           if (_s1jC7::I64 == 1) goto c1lMl; else goto c1lMf;
       c1lMl: // global
           R3 = _s1jC8::P64;
           R2 = _s1jC6::P64;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
       c1lMf: // global
           I64[Sp - 8] = block_c1lM6_info;
           R3 = _s1jC8::P64;
           R2 = _s1jC6::P64;
           I64[Sp + 16] = _s1jC7::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lMt() //  [R1]
         { info_tbl: [(c1lMt,
                       label: block_c1lMt_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lMt: // global
           P64[Sp] = R1;
           I64[Sp + 8] = I64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           call _c1lLO() args: 0, res: 0, upd: 0;
     }
 },
 _c1lM6() //  [R1]
         { info_tbl: [(c1lM6,
                       label: block_c1lM6_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lM6: // global
           _s1jC6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lMd_info;
           R3 = _s1jC6::P64;
           R2 = _s1jC6::P64;
           P64[Sp + 16] = R1;
           _s1jCa::I64 = I64[Sp + 24];
           I64[Sp + 24] = %MO_S_Shr_W64(_s1jCa::I64 + (_s1jCa::I64 >> 63), 1);
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lMd() //  [R1]
         { info_tbl: [(c1lMd,
                       label: block_c1lMd_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lMd: // global
           P64[Sp] = R1;
           _s1jC8::P64 = P64[Sp + 8];
           I64[Sp + 8] = I64[Sp + 16];
           P64[Sp + 16] = _s1jC8::P64;
           call _c1lLO() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.923569455 UTC

[section ""data" . GHC.Real.$wf_closure" {
     GHC.Real.$wf_closure:
         const GHC.Real.$wf_info;
         const 0;
 },
 GHC.Real.$wf_entry() //  [R2, R3]
         { info_tbl: [(c1lMO,
                       label: GHC.Real.$wf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lMO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lMP; else goto u1lNm;
       c1lMP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wf_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1lNm: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1lMG() args: 0, res: 0, upd: 0;
     }
 },
 _c1lMG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lMG: // global
           _s1jCg::P64 = P64[Sp];
           _s1jCh::I64 = I64[Sp + 8];
           if (_s1jCh::I64 - (_s1jCh::I64 + (_s1jCh::I64 >> 63)) & (-2) == 0) goto c1lMN; else goto c1lMM;
       c1lMN: // global
           I64[Sp] = block_c1lNg_info;
           R3 = _s1jCg::P64;
           R2 = _s1jCg::P64;
           I64[Sp + 8] = %MO_S_Shr_W64(_s1jCh::I64 + (_s1jCh::I64 >> 63), 1);
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       c1lMM: // global
           if (_s1jCh::I64 == 1) goto c1lN8; else goto c1lN3;
       c1lN8: // global
           R1 = _s1jCg::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1lN3: // global
           I64[Sp - 8] = block_c1lN1_info;
           R3 = _s1jCg::P64;
           R2 = _s1jCg::P64;
           I64[Sp + 8] = %MO_S_Shr_W64(_s1jCh::I64 + (_s1jCh::I64 >> 63), 1);
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lNg() //  [R1]
         { info_tbl: [(c1lNg,
                       label: block_c1lNg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lNg: // global
           P64[Sp] = R1;
           I64[Sp + 8] = I64[Sp + 8];
           call _c1lMG() args: 0, res: 0, upd: 0;
     }
 },
 _c1lN1() //  [R1]
         { info_tbl: [(c1lN1,
                       label: block_c1lN1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lN1: // global
           R4 = P64[Sp + 8];
           R3 = I64[Sp + 16];
           R2 = R1;
           Sp = Sp + 24;
           call $wg1_r1j3Q_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.925289797 UTC

[section ""data" . GHC.Real.^_f1_closure" {
     GHC.Real.^_f1_closure:
         const GHC.Real.^_f1_info;
         const 0;
 },
 GHC.Real.^_f1_entry() //  [R2, R3]
         { info_tbl: [(c1lNx,
                       label: GHC.Real.^_f1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lNx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lNy; else goto c1lNz;
       c1lNy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_f1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lNz: // global
           I64[Sp - 16] = block_c1lNu_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lND; else goto c1lNv;
       u1lND: // global
           call _c1lNu(R1) args: 0, res: 0, upd: 0;
       c1lNv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lNu() //  [R1]
         { info_tbl: [(c1lNu,
                       label: block_c1lNu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lNu: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$wf_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.926611018 UTC

[section ""data" . GHC.Real.^_$s^1_closure" {
     GHC.Real.^_$s^1_closure:
         const GHC.Real.^_$s^1_info;
         const 0;
 },
 section ""relreadonly" . u1lO2_srtd" {
     u1lO2_srtd:
         const S1jKw_srt+1280;
         const 33;
         const 5368840193;
 },
 GHC.Real.^_$s^1_entry() //  [R2, R3]
         { info_tbl: [(c1lNL,
                       label: GHC.Real.^_$s^1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lNL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lNM; else goto c1lNN;
       c1lNM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_$s^1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lNN: // global
           I64[Sp - 16] = block_c1lNI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1lO1; else goto c1lNJ;
       u1lO1: // global
           call _c1lNI(R1) args: 0, res: 0, upd: 0;
       c1lNJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lNI() //  [R1]
         { info_tbl: [(c1lNI,
                       label: block_c1lNI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lNI: // global
           _s1jCv::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1jCv::I64, 0)) goto c1lNZ; else goto c1lO0;
       c1lNZ: // global
           if (_s1jCv::I64 == 0) goto c1lNX; else goto c1lNW;
       c1lNX: // global
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1lNW: // global
           R3 = _s1jCv::I64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$wf_entry(R3, R2) args: 8, res: 0, upd: 8;
       c1lO0: // global
           R1 = GHC.Real.^1_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.928022543 UTC

[section ""data" . lvl6_r1j3R_closure" {
     lvl6_r1j3R_closure:
         const lvl6_r1j3R_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r1j3R_entry() //  [R1]
         { info_tbl: [(c1lOb,
                       label: lvl6_r1j3R_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lOb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lOc; else goto c1lOd;
       c1lOc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lOd: // global
           (_c1lO6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1lO6::I64 == 0) goto c1lO8; else goto c1lO7;
       c1lO8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1lO7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1lO6::I64;
           I64[Sp - 24] = block_c1lO9_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1lO9() //  [R1]
         { info_tbl: [(c1lO9,
                       label: block_c1lO9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lO9: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.929292474 UTC

[section ""data" . lvl7_r1j3S_closure" {
     lvl7_r1j3S_closure:
         const lvl7_r1j3S_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r1j3S_entry() //  [R1]
         { info_tbl: [(c1lOp,
                       label: lvl7_r1j3S_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lOp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lOq; else goto c1lOr;
       c1lOq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lOr: // global
           (_c1lOk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1lOk::I64 == 0) goto c1lOm; else goto c1lOl;
       c1lOm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1lOl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1lOk::I64;
           I64[Sp - 24] = block_c1lOn_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1lOn() //  [R1]
         { info_tbl: [(c1lOn,
                       label: block_c1lOn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lOn: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.935509368 UTC

[section ""data" . GHC.Real.^_closure" {
     GHC.Real.^_closure:
         const GHC.Real.^_info;
         const 0;
 },
 $dNum1_s1jCF_entry() //  [R1]
         { info_tbl: [(c1lPY,
                       label: $dNum1_s1jCF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lPY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lPZ; else goto c1lQ0;
       c1lPZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lQ0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jCH_entry() //  [R1]
         { info_tbl: [(c1lQ3,
                       label: sat_s1jCH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lQ3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lQ4; else goto c1lQ5;
       c1lQ4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lQ5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jCK_entry() //  [R1]
         { info_tbl: [(c1lQ8,
                       label: sat_s1jCK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lQ8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lQ9; else goto c1lQa;
       c1lQ9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lQa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl8_s1jCM_entry() //  [R1]
         { info_tbl: [(c1lQd,
                       label: lvl8_s1jCM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lQd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lQe; else goto c1lQf;
       c1lQe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lQf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl9_s1jCR_entry() //  [R1]
         { info_tbl: [(c1lQi,
                       label: lvl9_s1jCR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lQi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lQj; else goto c1lQk;
       c1lQj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lQk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jD8_entry() //  [R1]
         { info_tbl: [(c1lQn,
                       label: sat_s1jD8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lQn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1lQo; else goto c1lQp;
       c1lQo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lQp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD7_entry() //  [R1]
         { info_tbl: [(c1lQs,
                       label: sat_s1jD7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lQs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1lQt; else goto c1lQu;
       c1lQt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lQu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jCO::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1jCO::P64;
           P64[Sp - 24] = _s1jCO::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD4_entry() //  [R1]
         { info_tbl: [(c1lQx,
                       label: sat_s1jD4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lQx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1lQy; else goto c1lQz;
       c1lQy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lQz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD3_entry() //  [R1]
         { info_tbl: [(c1lQC,
                       label: sat_s1jD3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lQC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1lQD; else goto c1lQE;
       c1lQD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lQE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD2_entry() //  [R1]
         { info_tbl: [(c1lQI,
                       label: sat_s1jD2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lQI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1lQJ; else goto c1lQK;
       c1lQJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lQK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jCX::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1jCX::P64;
           P64[Sp - 24] = _s1jCX::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD6_entry() //  [R1]
         { info_tbl: [(c1lQN,
                       label: sat_s1jD6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lQN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1lQO; else goto c1lQP;
       c1lQO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lQP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD5_entry() //  [R1]
         { info_tbl: [(c1lQT,
                       label: sat_s1jD5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lQT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1lQU; else goto c1lQV;
       c1lQU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lQV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jCX::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1jCX::P64;
           P64[Sp - 24] = _s1jCX::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jDe_entry() //  [R1]
         { info_tbl: [(c1lQY,
                       label: sat_s1jDe_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lQY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1lQZ; else goto c1lR0;
       c1lQZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lR0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jDd_entry() //  [R1]
         { info_tbl: [(c1lR4,
                       label: sat_s1jDd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lR4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1lR5; else goto c1lR6;
       c1lR5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lR6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jDa::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1jDa::P64;
           P64[Sp - 24] = _s1jDa::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1lUb_srtd" {
     u1lUb_srtd:
         const S1jKw_srt+696;
         const 111;
         const 1;
         const 131941462441984;
 },
 GHC.Real.^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1lR7,
                       label: GHC.Real.^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lR7: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c1lR8; else goto c1lR9;
       c1lR8: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lR9: // global
           I64[Sp - 40] = block_c1lOz_info;
           _s1jCA::P64 = R2;
           R2 = R3;
           P64[Sp - 32] = _s1jCA::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lUc_srtd" {
     u1lUc_srtd:
         const S1jKw_srt+696;
         const 111;
         const 1;
         const 96757090353152;
 },
 _c1lOz() //  [R1]
         { info_tbl: [(c1lOz,
                       label: block_c1lOz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lOz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lRc; else goto c1lRb;
       c1lRc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lRb: // global
           I64[Hp - 16] = $dNum1_s1jCF_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1lOF_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lUd_srtd" {
     u1lUd_srtd:
         const S1jKw_srt+696;
         const 111;
         const 1;
         const 96757090353152;
 },
 _c1lOF() //  [R1]
         { info_tbl: [(c1lOF,
                       label: block_c1lOF_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lOF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lRf; else goto c1lRe;
       c1lRf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lRe: // global
           I64[Hp - 16] = sat_s1jCH_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1lOL_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 40];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lUe_srtd" {
     u1lUe_srtd:
         const S1jKw_srt+696;
         const 111;
         const 1;
         const 96757090353152;
 },
 _c1lOL() //  [R1]
         { info_tbl: [(c1lOL,
                       label: block_c1lOL_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lOL: // global
           if (R1 & 7 == 1) goto c1lRh; else goto c1lSf;
       c1lRh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lRk; else goto c1lRj;
       c1lRk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lRj: // global
           I64[Hp - 16] = sat_s1jCK_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 8] = block_c1lOR_info;
           R2 = P64[Sp + 8];
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1lSf: // global
           R1 = lvl7_r1j3S_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1lUf_srtd" {
     u1lUf_srtd:
         const S1jKw_srt+696;
         const 109;
         const 1;
         const 17592253153280;
 },
 _c1lOR() //  [R1]
         { info_tbl: [(c1lOR,
                       label: block_c1lOR_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lOR: // global
           _c1lOP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lOV_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 56];
           P64[Sp] = _c1lOP::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lUg_srtd" {
     u1lUg_srtd:
         const S1jKw_srt+696;
         const 109;
         const 1;
         const 17592253153280;
 },
 _c1lOV() //  [R1]
         { info_tbl: [(c1lOV,
                       label: block_c1lOV_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lOV: // global
           if (R1 & 7 == 1) goto c1lRn; else goto c1lSb;
       c1lRn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lRq; else goto c1lRp;
       c1lRq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lRp: // global
           I64[Hp - 16] = lvl8_s1jCM_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp] = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = Hp - 16;
           call _c1lPM() args: 0, res: 0, upd: 0;
       c1lSb: // global
           R2 = P64[Sp + 24];
           I64[Sp + 40] = stg_ap_p_info;
           P64[Sp + 48] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 40;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 _c1lPM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lPM: // global
           I64[Sp - 8] = block_c1lPO_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lUh_srtd" {
     u1lUh_srtd:
         const S1jKw_srt+696;
         const 91;
         const 1;
         const 67108864;
 },
 _c1lPO() //  [R1]
         { info_tbl: [(c1lPO,
                       label: block_c1lPO_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lPO: // global
           _s1jDa::P64 = P64[Sp + 48];
           _s1jDb::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c1lS3; else goto c1lS4;
       c1lS3: // global
           I64[Sp + 8] = block_c1lP6_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = _s1jDb::P64;
           P64[Sp + 48] = _s1jDa::P64;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1lS4: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1lS7; else goto c1lS6;
       c1lS7: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lS6: // global
           I64[Hp - 64] = sat_s1jDe_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = _s1jDb::P64;
           I64[Hp - 24] = sat_s1jDd_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _s1jDa::P64;
           P64[Sp + 48] = Hp - 24;
           P64[Sp + 8] = Hp - 64;
           Sp = Sp + 8;
           call _c1lPM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1lUi_srtd" {
     u1lUi_srtd:
         const S1jKw_srt+696;
         const 91;
         const 1;
         const 67108864;
 },
 _c1lP6() //  [R1]
         { info_tbl: [(c1lP6,
                       label: block_c1lP6_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lP6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lRu; else goto c1lRt;
       c1lRu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lRt: // global
           I64[Hp - 16] = lvl9_s1jCR_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 8] = block_c1lPc_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 8];
           _c1lPa::P64 = Hp - 16;
           P64[Sp - 16] = _c1lPa::P64;
           P64[Sp] = R1;
           P64[Sp + 16] = _c1lPa::P64;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1lPc() //  [R1]
         { info_tbl: [(c1lPc,
                       label: block_c1lPc_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lPc: // global
           _s1jCO::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto c1lRw; else goto c1lRY;
       c1lRw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1lRz; else goto c1lRy;
       c1lRz: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lRy: // global
           I64[Hp - 64] = sat_s1jD8_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = sat_s1jD7_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _s1jCO::P64;
           P64[Sp] = _s1jCO::P64;
           P64[Sp + 16] = Hp - 64;
           P64[Sp + 48] = Hp - 24;
           call _c1lPp() args: 0, res: 0, upd: 0;
       c1lRY: // global
           R1 = _s1jCO::P64;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1lPp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lPp: // global
           I64[Sp - 8] = block_c1lPr_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 40];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lPr() //  [R1]
         { info_tbl: [(c1lPr,
                       label: block_c1lPr_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lPr: // global
           _s1jCY::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c1lRH; else goto c1lRR;
       c1lRH: // global
           I64[Sp] = block_c1lPv_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jCY::P64;
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c1lRR: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1lRU; else goto c1lRT;
       c1lRU: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lRT: // global
           I64[Hp - 64] = sat_s1jD6_info;
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = _s1jCY::P64;
           I64[Hp - 24] = sat_s1jD5_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 56];
           P64[Sp + 56] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c1lPp() args: 0, res: 0, upd: 0;
     }
 },
 _c1lPv() //  [R1]
         { info_tbl: [(c1lPv,
                       label: block_c1lPv_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lPv: // global
           _s1jCA::P64 = P64[Sp + 40];
           _s1jCX::P64 = P64[Sp + 56];
           _s1jCZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c1lRJ; else goto c1lRQ;
       c1lRJ: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1lRM; else goto c1lRL;
       c1lRM: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lRL: // global
           I64[Hp - 104] = sat_s1jD4_info;
           P64[Hp - 88] = _s1jCA::P64;
           P64[Hp - 80] = _s1jCX::P64;
           P64[Hp - 72] = _s1jCZ::P64;
           I64[Hp - 64] = sat_s1jD3_info;
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_s1jD2_info;
           P64[Hp - 8] = _s1jCA::P64;
           P64[Hp] = _s1jCX::P64;
           P64[Sp + 56] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = Hp - 104;
           Sp = Sp + 8;
           call _c1lPp() args: 0, res: 0, upd: 0;
       c1lRQ: // global
           R2 = _s1jCA::P64;
           I64[Sp + 48] = stg_ap_pp_info;
           P64[Sp + 56] = _s1jCX::P64;
           P64[Sp + 64] = _s1jCZ::P64;
           Sp = Sp + 48;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Real.^%^_closure" {
     GHC.Real.^%^_closure:
         const GHC.Real.^%^_info;
         const 0;
 },
 GHC.Real.^%^_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lSD,
                       label: GHC.Real.^%^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lSD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lSJ; else goto c1lSK;
       c1lSJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^%^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lSK: // global
           I64[Sp - 24] = block_c1lSA_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1lSP; else goto c1lSB;
       u1lSP: // global
           call _c1lSA(R1) args: 0, res: 0, upd: 0;
       c1lSB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lSA() //  [R1]
         { info_tbl: [(c1lSA,
                       label: block_c1lSA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lSA: // global
           _s1jDh::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1lSG_info;
           R5 = _s1jDh::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w^%^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lSG() //  [R1, R2]
         { info_tbl: [(c1lSG,
                       label: block_c1lSG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lSG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lSO; else goto c1lSN;
       c1lSO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1lSN: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Real.$w^%^_closure" {
     GHC.Real.$w^%^_closure:
         const GHC.Real.$w^%^_info;
         const 0;
 },
 $dNum_s1jDt_entry() //  [R1]
         { info_tbl: [(c1lT2,
                       label: $dNum_s1jDt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lT2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lT3; else goto c1lT4;
       c1lT3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lT4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jDv_entry() //  [R1]
         { info_tbl: [(c1lTd,
                       label: sat_s1jDv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lTd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lTe; else goto c1lTf;
       c1lTe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lTf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jDy_entry() //  [R1]
         { info_tbl: [(c1lTo,
                       label: sat_s1jDy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lTo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lTp; else goto c1lTq;
       c1lTp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lTq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w^%^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1lTr,
                       label: GHC.Real.$w^%^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lTr: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c1lTs; else goto c1lTt;
       c1lTs: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w^%^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lTt: // global
           I64[Sp - 40] = block_c1lSU_info;
           _s1jDo::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s1jDo::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lSU() //  [R1]
         { info_tbl: [(c1lSU,
                       label: block_c1lSU_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lSU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lTw; else goto c1lTv;
       c1lTw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lTv: // global
           I64[Hp - 16] = $dNum_s1jDt_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1lT5_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lT5() //  [R1]
         { info_tbl: [(c1lT5,
                       label: block_c1lT5_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lT5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lTz; else goto c1lTy;
       c1lTz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lTy: // global
           I64[Hp - 16] = sat_s1jDv_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1lTg_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 40];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1lTg() //  [R1]
         { info_tbl: [(c1lTg,
                       label: block_c1lTg_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lTg: // global
           if (R1 & 7 == 1) goto c1lTC; else goto c1lU8;
       c1lTC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lTF; else goto c1lTE;
       c1lTF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lTE: // global
           I64[Hp - 16] = sat_s1jDy_info;
           P64[Hp] = P64[Sp + 16];
           _s1jDu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lTA_info;
           R2 = _s1jDu::P64;
           P64[Sp + 16] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1lU8: // global
           R1 = lvl6_r1j3R_closure;
           Sp = Sp + 56;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1lTA() //  [R1]
         { info_tbl: [(c1lTA,
                       label: block_c1lTA_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lTA: // global
           _c1lTk::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lTJ_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = _c1lTk::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1lTJ() //  [R1]
         { info_tbl: [(c1lTJ,
                       label: block_c1lTJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lTJ: // global
           if (R1 & 7 == 1) goto c1lTV; else goto c1lU4;
       c1lTV: // global
           I64[Sp] = block_c1lTO_info;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = GHC.Num.$fNumInteger_closure;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
       c1lU4: // global
           R2 = GHC.Real.$fEnumRatio1_closure;
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1lTO() //  [R1]
         { info_tbl: [(c1lTO,
                       label: block_c1lTO_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lTO: // global
           _s1jDq::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1lTS_info;
           R5 = P64[Sp + 32];
           R4 = _s1jDq::P64;
           R3 = P64[Sp + 8];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lTS() //  [R1]
         { info_tbl: [(c1lTS,
                       label: block_c1lTS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lTS: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.950358746 UTC

[section ""data" . GHC.Real.$w^^%^^_closure" {
     GHC.Real.$w^^%^^_closure:
         const GHC.Real.$w^^%^^_info;
         const 0;
 },
 $dNum_s1jDI_entry() //  [R1]
         { info_tbl: [(c1lUv,
                       label: $dNum_s1jDI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lUv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lUw; else goto c1lUx;
       c1lUw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lUx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jDK_entry() //  [R1]
         { info_tbl: [(c1lUG,
                       label: sat_s1jDK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lUG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lUH; else goto c1lUI;
       c1lUH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lUI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jDN_entry() //  [R1]
         { info_tbl: [(c1lUR,
                       label: sat_s1jDN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lUR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lUS; else goto c1lUT;
       c1lUS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lUT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jDT_entry() //  [R1]
         { info_tbl: [(c1lVe,
                       label: sat_s1jDT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lVe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lVf; else goto c1lVg;
       c1lVf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lVg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jDS_entry() //  [R1]
         { info_tbl: [(c1lVl,
                       label: sat_s1jDS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lVl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lVm; else goto c1lVn;
       c1lVm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lVn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jDV_entry() //  [R1]
         { info_tbl: [(c1lVw,
                       label: sat_s1jDV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lVw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lVx; else goto c1lVy;
       c1lVx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lVy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jE2_entry() //  [R1]
         { info_tbl: [(c1lVF,
                       label: sat_s1jE2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lVF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lVG; else goto c1lVH;
       c1lVG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lVH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jE4_entry() //  [R1]
         { info_tbl: [(c1lVQ,
                       label: sat_s1jE4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lVQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lVR; else goto c1lVS;
       c1lVR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lVS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1lXD_srtd" {
     u1lXD_srtd:
         const S1jKw_srt+296;
         const 167;
         const 1;
         const 0;
         const 354871676928;
 },
 GHC.Real.$w^^%^^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1lVT,
                       label: GHC.Real.$w^^%^^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lVT: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c1lVU; else goto c1lVV;
       c1lVU: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w^^%^^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lVV: // global
           I64[Sp - 40] = block_c1lUn_info;
           _s1jDD::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s1jDD::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lXE_srtd" {
     u1lXE_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1lUn() //  [R1]
         { info_tbl: [(c1lUn,
                       label: block_c1lUn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lUn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lVY; else goto c1lVX;
       c1lVY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lVX: // global
           I64[Hp - 16] = $dNum_s1jDI_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1lUy_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lXF_srtd" {
     u1lXF_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1lUy() //  [R1]
         { info_tbl: [(c1lUy,
                       label: block_c1lUy_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lUy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lW1; else goto c1lW0;
       c1lW1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lW0: // global
           I64[Hp - 16] = sat_s1jDK_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1lUJ_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 40];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.>_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lXG_srtd" {
     u1lXG_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1lUJ() //  [R1]
         { info_tbl: [(c1lUJ,
                       label: block_c1lUJ_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lUJ: // global
           if (R1 & 7 == 1) goto c1lW3; else goto c1lXr;
       c1lW3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lW6; else goto c1lW5;
       c1lW6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lW5: // global
           I64[Hp - 16] = sat_s1jDN_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp] = block_c1lUU_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1lXr: // global
           I64[Sp + 16] = block_c1lXl_info;
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = GHC.Num.$fNumInteger_closure;
           Sp = Sp + 16;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lXH_srtd" {
     u1lXH_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1lUU() //  [R1]
         { info_tbl: [(c1lUU,
                       label: block_c1lUU_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lUU: // global
           _c1lUN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lUY_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 48];
           P64[Sp] = _c1lUN::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1lXI_srtd" {
     u1lXI_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1lUY() //  [R1]
         { info_tbl: [(c1lUY,
                       label: block_c1lUY_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lUY: // global
           if (R1 & 7 == 1) goto c1lWa; else goto c1lXi;
       c1lWa: // global
           I64[Sp] = block_c1lV2_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       c1lXi: // global
           R2 = GHC.Real.$fEnumRatio1_closure;
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1lXJ_srtd" {
     u1lXJ_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993765888;
 },
 _c1lV2() //  [R1]
         { info_tbl: [(c1lV2,
                       label: block_c1lV2_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lV2: // global
           if (R1 == 1) goto c1lX4; else goto c1lWd;
       c1lX4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lX7; else goto c1lX6;
       c1lX7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1lX6: // global
           I64[Hp - 24] = sat_s1jE2_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c1lVI_info;
           R5 = Hp - 24;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
       c1lWd: // global
           I64[Sp] = block_c1lV6_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lVI() //  [R1]
         { info_tbl: [(c1lVI,
                       label: block_c1lVI_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lVI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lXa; else goto c1lX9;
       c1lXa: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lX9: // global
           I64[Hp - 24] = sat_s1jE4_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 32] = block_c1lX3_info;
           R5 = Hp - 24;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 40] = R1;
           Sp = Sp + 32;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lX3() //  [R1]
         { info_tbl: [(c1lX3,
                       label: block_c1lX3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lX3: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1lXK_srtd" {
     u1lXK_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79456894976;
 },
 _c1lV6() //  [R1]
         { info_tbl: [(c1lV6,
                       label: block_c1lV6_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lV6: // global
           if (R1 == 1) goto c1lX2; else goto c1lWg;
       c1lX2: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1lWg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1lWj; else goto c1lWi;
       c1lWj: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1lWi: // global
           I64[Hp - 48] = sat_s1jDT_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = sat_s1jDS_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_c1lVo_info;
           R5 = Hp - 48;
           R4 = Hp - 16;
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lVo() //  [R1]
         { info_tbl: [(c1lVo,
                       label: block_c1lVo_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lVo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lWm; else goto c1lWl;
       c1lWm: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lWl: // global
           I64[Hp - 24] = sat_s1jDV_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c1lWe_info;
           R5 = Hp - 24;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lWe() //  [R1]
         { info_tbl: [(c1lWe,
                       label: block_c1lWe_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lWe: // global
           I64[Sp + 16] = block_c1lWq_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lWq() //  [R1]
         { info_tbl: [(c1lWq,
                       label: block_c1lWq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lWq: // global
           _s1jDU::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1lWC; else goto c1lWS;
       c1lWC: // global
           I64[Sp] = block_c1lWv_info;
           R2 = _s1jDU::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       c1lWS: // global
           I64[Sp] = block_c1lWL_info;
           R1 = _s1jDU::P64;
           if (R1 & 7 != 0) goto u1lXA; else goto c1lWM;
       u1lXA: // global
           call _c1lWL(R1) args: 0, res: 0, upd: 0;
       c1lWM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lWv() //  [R1]
         { info_tbl: [(c1lWv,
                       label: block_c1lWv_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lWv: // global
           _s1jDR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lWz_info;
           _s1jDX::P64 = R1;
           R1 = _s1jDR::P64;
           P64[Sp + 16] = _s1jDX::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1lXB; else goto c1lWE;
       u1lXB: // global
           call _c1lWz(R1) args: 0, res: 0, upd: 0;
       c1lWE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lWz() //  [R1]
         { info_tbl: [(c1lWz,
                       label: block_c1lWz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lWz: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1lWL() //  [R1]
         { info_tbl: [(c1lWL,
                       label: block_c1lWL_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lWL: // global
           _s1jDR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lWQ_info;
           _s1jDZ::P64 = R1;
           R1 = _s1jDR::P64;
           P64[Sp + 16] = _s1jDZ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1lXC; else goto c1lWU;
       u1lXC: // global
           call _c1lWQ(R1) args: 0, res: 0, upd: 0;
       c1lWU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lWQ() //  [R1]
         { info_tbl: [(c1lWQ,
                       label: block_c1lWQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lWQ: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1lXl() //  [R1]
         { info_tbl: [(c1lXl,
                       label: block_c1lXl_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lXl: // global
           _s1jDF::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1lXp_info;
           R5 = P64[Sp + 32];
           R4 = _s1jDF::P64;
           R3 = P64[Sp + 8];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lXp() //  [R1]
         { info_tbl: [(c1lXp,
                       label: block_c1lXp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lXp: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.960214842 UTC

[section ""data" . GHC.Real.^^%^^_closure" {
     GHC.Real.^^%^^_closure:
         const GHC.Real.^^%^^_info;
         const 0;
 },
 GHC.Real.^^%^^_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lXS,
                       label: GHC.Real.^^%^^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lXS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1lXY; else goto c1lXZ;
       c1lXY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^^%^^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lXZ: // global
           I64[Sp - 24] = block_c1lXP_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1lY4; else goto c1lXQ;
       u1lY4: // global
           call _c1lXP(R1) args: 0, res: 0, upd: 0;
       c1lXQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1lXP() //  [R1]
         { info_tbl: [(c1lXP,
                       label: block_c1lXP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lXP: // global
           _s1jEa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1lXV_info;
           R5 = _s1jEa::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w^^%^^_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lXV() //  [R1, R2]
         { info_tbl: [(c1lXV,
                       label: block_c1lXV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lXV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lY3; else goto c1lY2;
       c1lY3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1lY2: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.963243239 UTC

[section ""data" . GHC.Real.^^_closure" {
     GHC.Real.^^_closure:
         const GHC.Real.^^_info;
         const 0;
 },
 $dNum_s1jEm_entry() //  [R1]
         { info_tbl: [(c1lYh,
                       label: $dNum_s1jEm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lYh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lYi; else goto c1lYj;
       c1lYi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lYj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jEo_entry() //  [R1]
         { info_tbl: [(c1lYo,
                       label: sat_s1jEo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lYo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lYp; else goto c1lYq;
       c1lYp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lYq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jEr_entry() //  [R1]
         { info_tbl: [(c1lYH,
                       label: sat_s1jEr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lYH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1lYI; else goto c1lYJ;
       c1lYI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lYJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jEq_entry() //  [R1]
         { info_tbl: [(c1lYO,
                       label: sat_s1jEq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lYO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lYP; else goto c1lYQ;
       c1lYP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lYQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jEs_entry() //  [R1]
         { info_tbl: [(c1lYR,
                       label: sat_s1jEs_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lYR: // global
           _s1jEs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1lYS; else goto c1lYT;
       c1lYT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1lYV; else goto c1lYU;
       c1lYV: // global
           HpAlloc = 56;
           goto c1lYS;
       c1lYS: // global
           R1 = _s1jEs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lYU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jEs::P64;
           _s1jEh::P64 = P64[_s1jEs::P64 + 16];
           _s1jEi::P64 = P64[_s1jEs::P64 + 24];
           _s1jEj::P64 = P64[_s1jEs::P64 + 32];
           _s1jEk::P64 = P64[_s1jEs::P64 + 40];
           _s1jEm::P64 = P64[_s1jEs::P64 + 48];
           I64[Hp - 48] = sat_s1jEr_info;
           P64[Hp - 32] = _s1jEk::P64;
           P64[Hp - 24] = _s1jEm::P64;
           I64[Hp - 16] = sat_s1jEq_info;
           P64[Hp] = _s1jEh::P64;
           R5 = Hp - 48;
           R4 = _s1jEj::P64;
           R3 = _s1jEi::P64;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jEt_entry() //  [R1]
         { info_tbl: [(c1lZ2,
                       label: sat_s1jEt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lZ2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1lZ3; else goto c1lZ4;
       c1lZ3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1lZ4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.^^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1lZ5,
                       label: GHC.Real.^^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lZ5: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1lZ6; else goto c1lZ7;
       c1lZ6: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lZ7: // global
           I64[Sp - 40] = block_c1lY9_info;
           _s1jEh::P64 = R2;
           R2 = R3;
           P64[Sp - 32] = _s1jEh::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lY9() //  [R1]
         { info_tbl: [(c1lY9,
                       label: block_c1lY9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lY9: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1lZa; else goto c1lZ9;
       c1lZa: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lZ9: // global
           I64[Hp - 40] = $dNum_s1jEm_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_s1jEo_info;
           _c1lYd::P64 = Hp - 40;
           P64[Hp] = _c1lYd::P64;
           I64[Sp - 16] = block_c1lYr_info;
           R2 = R1;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = _c1lYd::P64;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1lYr() //  [R1]
         { info_tbl: [(c1lYr,
                       label: block_c1lYr_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lYr: // global
           _c1lYk::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1lYv_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 48];
           P64[Sp] = _c1lYk::P64;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1lYv() //  [R1]
         { info_tbl: [(c1lYv,
                       label: block_c1lYv_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lYv: // global
           _s1jEh::P64 = P64[Sp + 16];
           _s1jEi::P64 = P64[Sp + 24];
           _s1jEj::P64 = P64[Sp + 32];
           _s1jEk::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c1lZd; else goto c1lZh;
       c1lZd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1lZg; else goto c1lZf;
       c1lZg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lZf: // global
           I64[Hp - 48] = sat_s1jEs_info;
           P64[Hp - 32] = _s1jEh::P64;
           P64[Hp - 24] = _s1jEi::P64;
           P64[Hp - 16] = _s1jEj::P64;
           P64[Hp - 8] = _s1jEk::P64;
           P64[Hp] = P64[Sp + 8];
           R2 = _s1jEh::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 48;
           Sp = Sp + 32;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 8;
       c1lZh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1lZk; else goto c1lZj;
       c1lZk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1lZj: // global
           I64[Hp - 16] = sat_s1jEt_info;
           P64[Hp] = _s1jEh::P64;
           R5 = _s1jEk::P64;
           R4 = _s1jEj::P64;
           R3 = _s1jEi::P64;
           R2 = Hp - 16;
           Sp = Sp + 48;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.967062788 UTC

[section ""data" . GHC.Real.C:Fractional_closure" {
     GHC.Real.C:Fractional_closure:
         const GHC.Real.C:Fractional_info;
 },
 GHC.Real.C:Fractional_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1lZr,
                       label: GHC.Real.C:Fractional_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lZr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1lZv; else goto c1lZu;
       c1lZv: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.C:Fractional_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lZu: // global
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.968320337 UTC

[section ""data" . GHC.Real.C:Integral_closure" {
     GHC.Real.C:Integral_closure:
         const GHC.Real.C:Integral_info;
 },
 GHC.Real.C:Integral_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lZx: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Real.C:Integral_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 GHC.Real.C:Integral_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1lZC,
                       label: GHC.Real.C:Integral_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lZC: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1lZG; else goto c1lZF;
       c1lZG: // global
           HpAlloc = 80;
           R1 = GHC.Real.C:Integral_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       c1lZF: // global
           I64[Hp - 72] = GHC.Real.C:Integral_con_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = R6;
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 71;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.969732486 UTC

[section ""data" . GHC.Real.C:Real_closure" {
     GHC.Real.C:Real_closure:
         const GHC.Real.C:Real_info;
 },
 GHC.Real.C:Real_entry() //  [R2, R3, R4]
         { info_tbl: [(c1lZM,
                       label: GHC.Real.C:Real_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lZM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1lZQ; else goto c1lZP;
       c1lZQ: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.C:Real_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1lZP: // global
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.970938663 UTC

[section ""data" . GHC.Real.C:RealFrac_closure" {
     GHC.Real.C:RealFrac_closure:
         const GHC.Real.C:RealFrac_info;
 },
 GHC.Real.C:RealFrac_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lZS: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Real.C:RealFrac_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Real.C:RealFrac_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1lZX,
                       label: GHC.Real.C:RealFrac_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1lZX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1m01; else goto c1m00;
       c1m01: // global
           HpAlloc = 64;
           R1 = GHC.Real.C:RealFrac_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       c1m00: // global
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.972292723 UTC

[section ""data" . GHC.Real.:%_closure" {
     GHC.Real.:%_closure:
         const GHC.Real.:%_info;
 },
 GHC.Real.:%_entry() //  [R2, R3]
         { info_tbl: [(c1m07,
                       label: GHC.Real.:%_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m07: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1m0b; else goto c1m0a;
       c1m0b: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.:%_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1m0a: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.973178533 UTC

[GHC.Real.C:Fractional_con_entry() //  [R1]
         { info_tbl: [(c1m0c,
                       label: GHC.Real.C:Fractional_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,70,114,97,99,116,105,111,110,97,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m0c: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.973969085 UTC

[GHC.Real.C:Integral_con_entry() //  [R1]
         { info_tbl: [(c1m0d,
                       label: GHC.Real.C:Integral_con_info
                       rep:HeapRep 9 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,73,110,116,101,103,114,97,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m0d: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.974682495 UTC

[GHC.Real.C:Real_con_entry() //  [R1]
         { info_tbl: [(c1m0e,
                       label: GHC.Real.C:Real_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,82,101,97,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m0e: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.975342833 UTC

[GHC.Real.C:RealFrac_con_entry() //  [R1]
         { info_tbl: [(c1m0f,
                       label: GHC.Real.C:RealFrac_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,82,101,97,108,70,114,97,99]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m0f: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.976034422 UTC

[GHC.Real.:%_con_entry() //  [R1]
         { info_tbl: [(c1m0g,
                       label: GHC.Real.:%_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,58,37]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m0g: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.976728235 UTC

[section ""relreadonly" . S1jKw_srt" {
     S1jKw_srt:
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$fOrdRatio_$s$c<_closure;
         const GHC.Real.$fEnumRatio_$s$c<=_closure;
         const GHC.Real.$w$s$ccompare_closure;
         const GHC.Real.$fEnumRatio_$s$ccompare_closure;
         const GHC.Real.$fEnumRatio_$s$c>=_closure;
         const GHC.Real.$fOrdRatio_$s$c>_closure;
         const GHC.Real.$fOrdRatio_$s$cmin_closure;
         const GHC.Real.$fOrdRatio_$s$cmax_closure;
         const sat_s1j8H_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$fFractionalRatio_$s$csignum_closure;
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure;
         const GHC.Real.$fEnumRatio_$ctoRational_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.$dmfloor_closure;
         const GHC.Real.$dmceiling_closure;
         const GHC.Real.$dmrecip_closure;
         const GHC.Real.$dmdivMod_closure;
         const GHC.Exception.divZeroException_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.$fIntegralInt_$cmod_closure;
         const GHC.Real.$fIntegralInt_$crem_closure;
         const GHC.Real.$fIntegralInteger_$cquot_closure;
         const GHC.Real.$fIntegralInteger_$crem_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Real.$fIntegralInteger_$cdiv_closure;
         const GHC.Integer.Type.modInteger_closure;
         const GHC.Real.$fIntegralInteger_$cmod_closure;
         const GHC.Real.$fIntegralInteger_$cquotRem_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Real.$fIntegralInteger_$cdivMod_closure;
         const GHC.Real.$fIntegralWord_$cquot_closure;
         const GHC.Real.$fIntegralWord_$crem_closure;
         const GHC.Real.$fIntegralWord_$cquotRem_closure;
         const GHC.Real.$fIntegralWord_$cdivMod_closure;
         const GHC.Exception.ratioZeroDenomException_closure;
         const GHC.Real.ratioZeroDenominatorError_closure;
         const GHC.Real.$fFractionalRatio_$s$crecip_closure;
         const GHC.Exception.overflowException_closure;
         const GHC.Real.$fIntegralInt_$cdivMod_closure;
         const lvl_r1j38_closure;
         const GHC.Real.$fIntegralInt_$cquotRem_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Real.$fIntegralInt_$cdiv_closure;
         const GHC.Real.$w$cdiv_closure;
         const GHC.Real.$fIntegralInt_$cquot_closure;
         const GHC.Real.$wgcd'_closure;
         const lvl2_r1j3a_closure;
         const GHC.Real.$fEnumRatio_gcd'_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.gcd_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.reduce_$sreduce_closure;
         const GHC.Real.$fRealWord_$ctoRational_closure;
         const GHC.Real.$fFractionalRatio_$s$c*_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Real.$w$s$c-_closure;
         const GHC.Real.$fEnumRatio_$s$c-_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$fEnumRatio_$s$c+_closure;
         const GHC.Real.$w$s$cfromRational_closure;
         const GHC.Real.$fFractionalRatio_$s$cfromRational_closure;
         const GHC.Real.$w$s$c/_closure;
         const GHC.Real.$fFractionalRatio_$s$c/_closure;
         const GHC.Real.$w$snumericEnumFrom_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFrom_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$wnumericEnumFrom_closure;
         const GHC.Real.numericEnumFrom_closure;
         const sat_s1jhS_closure;
         const GHC.Real.even2_closure;
         const GHC.Real.$fEnumRatio2_closure;
         const GHC.Real.$fEnumRatio_$s$c<=_closure;
         const GHC.Real.$w$snumericEnumFromTo_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure;
         const GHC.Real.numericEnumFromTo_closure;
         const GHC.Real.$w$snumericEnumFromThen_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure;
         const GHC.Real.$fEnumRatio_$s$c>=_closure;
         const GHC.Real.$w$snumericEnumFromThenTo_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure;
         const GHC.Real.numericEnumFromThenTo_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.showSigned_closure;
         const GHC.Real.even_closure;
         const GHC.Real.odd_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const lvl3_r1j3b_closure;
         const GHC.Real.$dmround_closure;
         const GHC.Real.$fRealFracRatio1_closure;
         const GHC.Real.integralEnumFrom_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Real.integralEnumFromThen_closure;
         const GHC.Real.integralEnumFromTo_closure;
         const GHC.Real.integralEnumFromThenTo_closure;
         const GHC.Real.$w$csignum_closure;
         const GHC.Real.$fNumRatio_$csignum_closure;
         const GHC.Real.$w$cfromInteger_closure;
         const GHC.Real.$fNumRatio_$cfromInteger_closure;
         const GHC.Real.$w$crecip_closure;
         const GHC.Real.$fFractionalRatio_$crecip_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.$w$s$cproperFraction_closure;
         const GHC.Real.$fEnumRatio_$s$cproperFraction_closure;
         const GHC.Real.gcd_closure;
         const GHC.Real.$wreduce_closure;
         const GHC.Real.reduce_closure;
         const GHC.Real.%_$s%_closure;
         const GHC.Real.$w$s$cfromRational_closure;
         const GHC.Real.$w%_closure;
         const GHC.Real.%_closure;
         const GHC.Real.$w$c/_closure;
         const GHC.Real.$fFractionalRatio_$c/_closure;
         const GHC.Real.$w$cfromRational_closure;
         const GHC.Real.$fFractionalRatio_$cfromRational_closure;
         const GHC.Real.$w$c+_closure;
         const GHC.Real.$fNumRatio_$c+_closure;
         const GHC.Real.$w$c-_closure;
         const GHC.Real.$fNumRatio_$c-_closure;
         const GHC.Real.$w$c*_closure;
         const GHC.Real.$fNumRatio_$c*_closure;
         const GHC.Real.$fNumRatio_closure;
         const GHC.Real.$fEnumRatio_$s$csucc_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$fEnumRatio_$csucc_closure;
         const GHC.Real.$fEnumRatio_$s$cpred_closure;
         const GHC.Real.$fEnumRatio_$cpred_closure;
         const GHC.Real.$fFractionalRatio_closure;
         const GHC.Real.$wnumericEnumFrom_closure;
         const GHC.Real.$fEnumRatio_$cenumFrom_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThen_closure;
         const GHC.Real.$fEnumRatio_$cenumFromTo_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThenTo_closure;
         const GHC.Real.$fRealRatio_closure;
         const GHC.Real.$w$s$cceiling_closure;
         const GHC.Real.$fRealFracRatio_$s$cceiling_closure;
         const GHC.Real.$w$cceiling_closure;
         const GHC.Real.$fRealFracRatio_$cceiling_closure;
         const GHC.Real.$w$s$cfloor_closure;
         const GHC.Real.$fRealFracRatio_$s$cfloor_closure;
         const GHC.Real.$w$cfloor_closure;
         const GHC.Real.$fRealFracRatio_$cfloor_closure;
         const sat_s1jvS_closure;
         const GHC.Real.$w$s$cround_closure;
         const GHC.Real.$fRealFracRatio2_closure;
         const GHC.Real.$fRealFracRatio_$s$cround_closure;
         const GHC.Real.$w$cround_closure;
         const GHC.Real.$fRealFracRatio_$cround_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.$fRealFracRatio_$s$ctruncate_closure;
         const GHC.Real.$fRealFracRatio_closure;
         const g_r1j3N_closure;
         const GHC.Real.^_f_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Real.^_$s^_closure;
         const GHC.Real.^1_closure;
         const GHC.Real.$w$s$cfromEnum_closure;
         const GHC.Real.$fEnumRatio_$s$cfromEnum_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Real.$w$s$cshowsPrec_closure;
         const GHC.Real.$fShowRatio_$s$cshowsPrec_closure;
         const GHC.Real.$fShowRatio1_closure;
         const GHC.Real.$w$s$cshow_closure;
         const GHC.Real.$fShowRatio_$s$cshow_closure;
         const GHC.Real.$fIntegralWord_closure;
         const GHC.Real.$w$slcm_closure;
         const GHC.Real.lcm_$slcm_closure;
         const GHC.Real.$w$slcm1_closure;
         const GHC.Real.lcm_$slcm1_closure;
         const GHC.Real.gcd_closure;
         const GHC.Real.lcm_closure;
         const GHC.Real.$w$ctoEnum_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$fEnumRatio_$ctoEnum_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThenTo_closure;
         const GHC.Real.$fEnumRatio_$cenumFromTo_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThen_closure;
         const GHC.Real.$fEnumRatio_$cenumFrom_closure;
         const GHC.Real.$fEnumRatio_$cpred_closure;
         const GHC.Real.$fEnumRatio_$csucc_closure;
         const GHC.Real.$fEnumRatio_closure;
         const GHC.Real.^_$s^2_closure;
         const GHC.Real.^2_closure;
         const $wg1_r1j3Q_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$wf_closure;
         const GHC.Real.^_f1_closure;
         const GHC.Real.^_$s^1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.even2_closure;
         const GHC.Real.^_closure;
         const lvl7_r1j3S_closure;
         const GHC.Real.even_closure;
         const GHC.Real.^%^_closure;
         const GHC.Real.$w^%^_closure;
         const GHC.Num.$fNumInteger_closure;
         const lvl6_r1j3R_closure;
         const GHC.Real.$w^^%^^_closure;
         const GHC.Real.^^%^^_closure;
         const GHC.Real.^^_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.978518761 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:56:02.979341209 UTC

[section ""data" . GHC.Real.$p1Fractional_closure" {
     GHC.Real.$p1Fractional_closure:
         const GHC.Real.$p1Fractional_info;
 },
 GHC.Real.$p1Fractional_entry() //  [R2]
         { info_tbl: [(c1m0o,
                       label: GHC.Real.$p1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m0o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m0p; else goto c1m0q;
       c1m0p: // global
           R2 = R2;
           R1 = GHC.Real.$p1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m0q: // global
           I64[Sp - 8] = block_c1m0l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m0u; else goto c1m0m;
       u1m0u: // global
           call _c1m0l(R1) args: 0, res: 0, upd: 0;
       c1m0m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m0l() //  [R1]
         { info_tbl: [(c1m0l,
                       label: block_c1m0l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m0l: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.98057004 UTC

[section ""data" . GHC.Real./_closure" {
     GHC.Real./_closure:
         const GHC.Real./_info;
 },
 GHC.Real./_entry() //  [R2]
         { info_tbl: [(c1m0C,
                       label: GHC.Real./_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m0C: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m0D; else goto c1m0E;
       c1m0D: // global
           R2 = R2;
           R1 = GHC.Real./_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m0E: // global
           I64[Sp - 8] = block_c1m0z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m0I; else goto c1m0A;
       u1m0I: // global
           call _c1m0z(R1) args: 0, res: 0, upd: 0;
       c1m0A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m0z() //  [R1]
         { info_tbl: [(c1m0z,
                       label: block_c1m0z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m0z: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.981814377 UTC

[section ""data" . GHC.Real.recip_closure" {
     GHC.Real.recip_closure:
         const GHC.Real.recip_info;
 },
 GHC.Real.recip_entry() //  [R2]
         { info_tbl: [(c1m0Q,
                       label: GHC.Real.recip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m0Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m0R; else goto c1m0S;
       c1m0R: // global
           R2 = R2;
           R1 = GHC.Real.recip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m0S: // global
           I64[Sp - 8] = block_c1m0N_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m0W; else goto c1m0O;
       u1m0W: // global
           call _c1m0N(R1) args: 0, res: 0, upd: 0;
       c1m0O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m0N() //  [R1]
         { info_tbl: [(c1m0N,
                       label: block_c1m0N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m0N: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.982936138 UTC

[section ""data" . GHC.Real.fromRational_closure" {
     GHC.Real.fromRational_closure:
         const GHC.Real.fromRational_info;
 },
 GHC.Real.fromRational_entry() //  [R2]
         { info_tbl: [(c1m14,
                       label: GHC.Real.fromRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m14: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m15; else goto c1m16;
       c1m15: // global
           R2 = R2;
           R1 = GHC.Real.fromRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m16: // global
           I64[Sp - 8] = block_c1m11_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m1a; else goto c1m12;
       u1m1a: // global
           call _c1m11(R1) args: 0, res: 0, upd: 0;
       c1m12: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m11() //  [R1]
         { info_tbl: [(c1m11,
                       label: block_c1m11_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m11: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.984081389 UTC

[section ""data" . GHC.Real.$p1Integral_closure" {
     GHC.Real.$p1Integral_closure:
         const GHC.Real.$p1Integral_info;
 },
 GHC.Real.$p1Integral_entry() //  [R2]
         { info_tbl: [(c1m1i,
                       label: GHC.Real.$p1Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m1i: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m1j; else goto c1m1k;
       c1m1j: // global
           R2 = R2;
           R1 = GHC.Real.$p1Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m1k: // global
           I64[Sp - 8] = block_c1m1f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m1o; else goto c1m1g;
       u1m1o: // global
           call _c1m1f(R1) args: 0, res: 0, upd: 0;
       c1m1g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m1f() //  [R1]
         { info_tbl: [(c1m1f,
                       label: block_c1m1f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m1f: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.985229648 UTC

[section ""data" . GHC.Real.$p2Integral_closure" {
     GHC.Real.$p2Integral_closure:
         const GHC.Real.$p2Integral_info;
 },
 GHC.Real.$p2Integral_entry() //  [R2]
         { info_tbl: [(c1m1w,
                       label: GHC.Real.$p2Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m1w: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m1x; else goto c1m1y;
       c1m1x: // global
           R2 = R2;
           R1 = GHC.Real.$p2Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m1y: // global
           I64[Sp - 8] = block_c1m1t_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m1C; else goto c1m1u;
       u1m1C: // global
           call _c1m1t(R1) args: 0, res: 0, upd: 0;
       c1m1u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m1t() //  [R1]
         { info_tbl: [(c1m1t,
                       label: block_c1m1t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m1t: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.987746971 UTC

[section ""data" . GHC.Real.quot_closure" {
     GHC.Real.quot_closure:
         const GHC.Real.quot_info;
 },
 GHC.Real.quot_entry() //  [R2]
         { info_tbl: [(c1m1K,
                       label: GHC.Real.quot_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m1K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m1L; else goto c1m1M;
       c1m1L: // global
           R2 = R2;
           R1 = GHC.Real.quot_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m1M: // global
           I64[Sp - 8] = block_c1m1H_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m1Q; else goto c1m1I;
       u1m1Q: // global
           call _c1m1H(R1) args: 0, res: 0, upd: 0;
       c1m1I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m1H() //  [R1]
         { info_tbl: [(c1m1H,
                       label: block_c1m1H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m1H: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.988944057 UTC

[section ""data" . GHC.Real.rem_closure" {
     GHC.Real.rem_closure:
         const GHC.Real.rem_info;
 },
 GHC.Real.rem_entry() //  [R2]
         { info_tbl: [(c1m1Y,
                       label: GHC.Real.rem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m1Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m1Z; else goto c1m20;
       c1m1Z: // global
           R2 = R2;
           R1 = GHC.Real.rem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m20: // global
           I64[Sp - 8] = block_c1m1V_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m24; else goto c1m1W;
       u1m24: // global
           call _c1m1V(R1) args: 0, res: 0, upd: 0;
       c1m1W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m1V() //  [R1]
         { info_tbl: [(c1m1V,
                       label: block_c1m1V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m1V: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.990442259 UTC

[section ""data" . GHC.Real.div_closure" {
     GHC.Real.div_closure:
         const GHC.Real.div_info;
 },
 GHC.Real.div_entry() //  [R2]
         { info_tbl: [(c1m2c,
                       label: GHC.Real.div_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m2c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m2d; else goto c1m2e;
       c1m2d: // global
           R2 = R2;
           R1 = GHC.Real.div_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m2e: // global
           I64[Sp - 8] = block_c1m29_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m2i; else goto c1m2a;
       u1m2i: // global
           call _c1m29(R1) args: 0, res: 0, upd: 0;
       c1m2a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m29() //  [R1]
         { info_tbl: [(c1m29,
                       label: block_c1m29_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m29: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.991653151 UTC

[section ""data" . GHC.Real.mod_closure" {
     GHC.Real.mod_closure:
         const GHC.Real.mod_info;
 },
 GHC.Real.mod_entry() //  [R2]
         { info_tbl: [(c1m2q,
                       label: GHC.Real.mod_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m2q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m2r; else goto c1m2s;
       c1m2r: // global
           R2 = R2;
           R1 = GHC.Real.mod_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m2s: // global
           I64[Sp - 8] = block_c1m2n_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m2w; else goto c1m2o;
       u1m2w: // global
           call _c1m2n(R1) args: 0, res: 0, upd: 0;
       c1m2o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m2n() //  [R1]
         { info_tbl: [(c1m2n,
                       label: block_c1m2n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m2n: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.99275729 UTC

[section ""data" . GHC.Real.quotRem_closure" {
     GHC.Real.quotRem_closure:
         const GHC.Real.quotRem_info;
 },
 GHC.Real.quotRem_entry() //  [R2]
         { info_tbl: [(c1m2E,
                       label: GHC.Real.quotRem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m2E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m2F; else goto c1m2G;
       c1m2F: // global
           R2 = R2;
           R1 = GHC.Real.quotRem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m2G: // global
           I64[Sp - 8] = block_c1m2B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m2K; else goto c1m2C;
       u1m2K: // global
           call _c1m2B(R1) args: 0, res: 0, upd: 0;
       c1m2C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m2B() //  [R1]
         { info_tbl: [(c1m2B,
                       label: block_c1m2B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m2B: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.993906599 UTC

[section ""data" . GHC.Real.divMod_closure" {
     GHC.Real.divMod_closure:
         const GHC.Real.divMod_info;
 },
 GHC.Real.divMod_entry() //  [R2]
         { info_tbl: [(c1m2S,
                       label: GHC.Real.divMod_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m2S: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m2T; else goto c1m2U;
       c1m2T: // global
           R2 = R2;
           R1 = GHC.Real.divMod_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m2U: // global
           I64[Sp - 8] = block_c1m2P_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m2Y; else goto c1m2Q;
       u1m2Y: // global
           call _c1m2P(R1) args: 0, res: 0, upd: 0;
       c1m2Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m2P() //  [R1]
         { info_tbl: [(c1m2P,
                       label: block_c1m2P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m2P: // global
           R1 = P64[R1 + 63];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.995042602 UTC

[section ""data" . GHC.Real.toInteger_closure" {
     GHC.Real.toInteger_closure:
         const GHC.Real.toInteger_info;
 },
 GHC.Real.toInteger_entry() //  [R2]
         { info_tbl: [(c1m36,
                       label: GHC.Real.toInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m36: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m37; else goto c1m38;
       c1m37: // global
           R2 = R2;
           R1 = GHC.Real.toInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m38: // global
           I64[Sp - 8] = block_c1m33_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m3c; else goto c1m34;
       u1m3c: // global
           call _c1m33(R1) args: 0, res: 0, upd: 0;
       c1m34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m33() //  [R1]
         { info_tbl: [(c1m33,
                       label: block_c1m33_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m33: // global
           R1 = P64[R1 + 71];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.996145203 UTC

[section ""data" . GHC.Real.$p1Real_closure" {
     GHC.Real.$p1Real_closure:
         const GHC.Real.$p1Real_info;
 },
 GHC.Real.$p1Real_entry() //  [R2]
         { info_tbl: [(c1m3k,
                       label: GHC.Real.$p1Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m3k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m3l; else goto c1m3m;
       c1m3l: // global
           R2 = R2;
           R1 = GHC.Real.$p1Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m3m: // global
           I64[Sp - 8] = block_c1m3h_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m3q; else goto c1m3i;
       u1m3q: // global
           call _c1m3h(R1) args: 0, res: 0, upd: 0;
       c1m3i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m3h() //  [R1]
         { info_tbl: [(c1m3h,
                       label: block_c1m3h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m3h: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.997341405 UTC

[section ""data" . GHC.Real.$p2Real_closure" {
     GHC.Real.$p2Real_closure:
         const GHC.Real.$p2Real_info;
 },
 GHC.Real.$p2Real_entry() //  [R2]
         { info_tbl: [(c1m3y,
                       label: GHC.Real.$p2Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m3y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m3z; else goto c1m3A;
       c1m3z: // global
           R2 = R2;
           R1 = GHC.Real.$p2Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m3A: // global
           I64[Sp - 8] = block_c1m3v_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m3E; else goto c1m3w;
       u1m3E: // global
           call _c1m3v(R1) args: 0, res: 0, upd: 0;
       c1m3w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m3v() //  [R1]
         { info_tbl: [(c1m3v,
                       label: block_c1m3v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m3v: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.998448554 UTC

[section ""data" . GHC.Real.toRational_closure" {
     GHC.Real.toRational_closure:
         const GHC.Real.toRational_info;
 },
 GHC.Real.toRational_entry() //  [R2]
         { info_tbl: [(c1m3M,
                       label: GHC.Real.toRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m3M: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m3N; else goto c1m3O;
       c1m3N: // global
           R2 = R2;
           R1 = GHC.Real.toRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m3O: // global
           I64[Sp - 8] = block_c1m3J_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m3S; else goto c1m3K;
       u1m3S: // global
           call _c1m3J(R1) args: 0, res: 0, upd: 0;
       c1m3K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m3J() //  [R1]
         { info_tbl: [(c1m3J,
                       label: block_c1m3J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m3J: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:02.999579192 UTC

[section ""data" . GHC.Real.$p1RealFrac_closure" {
     GHC.Real.$p1RealFrac_closure:
         const GHC.Real.$p1RealFrac_info;
 },
 GHC.Real.$p1RealFrac_entry() //  [R2]
         { info_tbl: [(c1m40,
                       label: GHC.Real.$p1RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m40: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m41; else goto c1m42;
       c1m41: // global
           R2 = R2;
           R1 = GHC.Real.$p1RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m42: // global
           I64[Sp - 8] = block_c1m3X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m46; else goto c1m3Y;
       u1m46: // global
           call _c1m3X(R1) args: 0, res: 0, upd: 0;
       c1m3Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m3X() //  [R1]
         { info_tbl: [(c1m3X,
                       label: block_c1m3X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m3X: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.000653841 UTC

[section ""data" . GHC.Real.$p2RealFrac_closure" {
     GHC.Real.$p2RealFrac_closure:
         const GHC.Real.$p2RealFrac_info;
 },
 GHC.Real.$p2RealFrac_entry() //  [R2]
         { info_tbl: [(c1m4e,
                       label: GHC.Real.$p2RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m4e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m4f; else goto c1m4g;
       c1m4f: // global
           R2 = R2;
           R1 = GHC.Real.$p2RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m4g: // global
           I64[Sp - 8] = block_c1m4b_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m4k; else goto c1m4c;
       u1m4k: // global
           call _c1m4b(R1) args: 0, res: 0, upd: 0;
       c1m4c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m4b() //  [R1]
         { info_tbl: [(c1m4b,
                       label: block_c1m4b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m4b: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.001920138 UTC

[section ""data" . GHC.Real.properFraction_closure" {
     GHC.Real.properFraction_closure:
         const GHC.Real.properFraction_info;
 },
 GHC.Real.properFraction_entry() //  [R2]
         { info_tbl: [(c1m4s,
                       label: GHC.Real.properFraction_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m4s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m4t; else goto c1m4u;
       c1m4t: // global
           R2 = R2;
           R1 = GHC.Real.properFraction_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m4u: // global
           I64[Sp - 8] = block_c1m4p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m4y; else goto c1m4q;
       u1m4y: // global
           call _c1m4p(R1) args: 0, res: 0, upd: 0;
       c1m4q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m4p() //  [R1]
         { info_tbl: [(c1m4p,
                       label: block_c1m4p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m4p: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.003253369 UTC

[section ""data" . GHC.Real.truncate_closure" {
     GHC.Real.truncate_closure:
         const GHC.Real.truncate_info;
 },
 GHC.Real.truncate_entry() //  [R2]
         { info_tbl: [(c1m4G,
                       label: GHC.Real.truncate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m4G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m4H; else goto c1m4I;
       c1m4H: // global
           R2 = R2;
           R1 = GHC.Real.truncate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m4I: // global
           I64[Sp - 8] = block_c1m4D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m4M; else goto c1m4E;
       u1m4M: // global
           call _c1m4D(R1) args: 0, res: 0, upd: 0;
       c1m4E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m4D() //  [R1]
         { info_tbl: [(c1m4D,
                       label: block_c1m4D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m4D: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.004364548 UTC

[section ""data" . GHC.Real.round_closure" {
     GHC.Real.round_closure:
         const GHC.Real.round_info;
 },
 GHC.Real.round_entry() //  [R2]
         { info_tbl: [(c1m4U,
                       label: GHC.Real.round_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m4U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m4V; else goto c1m4W;
       c1m4V: // global
           R2 = R2;
           R1 = GHC.Real.round_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m4W: // global
           I64[Sp - 8] = block_c1m4R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m50; else goto c1m4S;
       u1m50: // global
           call _c1m4R(R1) args: 0, res: 0, upd: 0;
       c1m4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m4R() //  [R1]
         { info_tbl: [(c1m4R,
                       label: block_c1m4R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m4R: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.00555093 UTC

[section ""data" . GHC.Real.ceiling_closure" {
     GHC.Real.ceiling_closure:
         const GHC.Real.ceiling_info;
 },
 GHC.Real.ceiling_entry() //  [R2]
         { info_tbl: [(c1m58,
                       label: GHC.Real.ceiling_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m58: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m59; else goto c1m5a;
       c1m59: // global
           R2 = R2;
           R1 = GHC.Real.ceiling_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m5a: // global
           I64[Sp - 8] = block_c1m55_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m5e; else goto c1m56;
       u1m5e: // global
           call _c1m55(R1) args: 0, res: 0, upd: 0;
       c1m56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m55() //  [R1]
         { info_tbl: [(c1m55,
                       label: block_c1m55_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m55: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.006607329 UTC

[section ""data" . GHC.Real.floor_closure" {
     GHC.Real.floor_closure:
         const GHC.Real.floor_info;
 },
 GHC.Real.floor_entry() //  [R2]
         { info_tbl: [(c1m5m,
                       label: GHC.Real.floor_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m5m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1m5n; else goto c1m5o;
       c1m5n: // global
           R2 = R2;
           R1 = GHC.Real.floor_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1m5o: // global
           I64[Sp - 8] = block_c1m5j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m5s; else goto c1m5k;
       u1m5s: // global
           call _c1m5j(R1) args: 0, res: 0, upd: 0;
       c1m5k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m5j() //  [R1]
         { info_tbl: [(c1m5j,
                       label: block_c1m5j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m5j: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.007800947 UTC

[section ""data" . GHC.Real.$W:%_closure" {
     GHC.Real.$W:%_closure:
         const GHC.Real.$W:%_info;
 },
 GHC.Real.$W:%_entry() //  [R2, R3]
         { info_tbl: [(c1m5C,
                       label: GHC.Real.$W:%_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m5C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1m5D; else goto c1m5E;
       c1m5D: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$W:%_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1m5E: // global
           I64[Sp - 16] = block_c1m5x_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m5x() //  [R1]
         { info_tbl: [(c1m5x,
                       label: block_c1m5x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m5x: // global
           I64[Sp] = block_c1m5z_info;
           _s1j7b::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1j7b::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m5z() //  [R1]
         { info_tbl: [(c1m5z,
                       label: block_c1m5z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m5z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1m5I; else goto c1m5H;
       c1m5I: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1m5H: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.009454372 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$c<_closure" {
     GHC.Real.$fOrdRatio_$s$c<_closure:
         const GHC.Real.$fOrdRatio_$s$c<_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$c<_entry() //  [R2, R3]
         { info_tbl: [(c1m5Q,
                       label: GHC.Real.$fOrdRatio_$s$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m5Q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1m67; else goto c1m68;
       c1m67: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1m68: // global
           I64[Sp - 16] = block_c1m5N_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1m6i; else goto c1m5O;
       u1m6i: // global
           call _c1m5N(R1) args: 0, res: 0, upd: 0;
       c1m5O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m5N() //  [R1]
         { info_tbl: [(c1m5N,
                       label: block_c1m5N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m5N: // global
           I64[Sp - 8] = block_c1m5T_info;
           _s1j7g::P64 = P64[R1 + 7];
           _s1j7h::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j7h::P64;
           P64[Sp + 8] = _s1j7g::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m6h; else goto c1m5U;
       u1m6h: // global
           call _c1m5T(R1) args: 0, res: 0, upd: 0;
       c1m5U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m5T() //  [R1]
         { info_tbl: [(c1m5T,
                       label: block_c1m5T_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m5T: // global
           I64[Sp] = block_c1m5Y_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp + 8] = P64[R1 + 15];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m5Y() //  [R1]
         { info_tbl: [(c1m5Y,
                       label: block_c1m5Y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m5Y: // global
           _s1j7k::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1m62_info;
           R3 = _s1j7k::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m62() //  [R1]
         { info_tbl: [(c1m62,
                       label: block_c1m62_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m62: // global
           _s1j7m::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1m66_info;
           R3 = _s1j7m::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m66() //  [R1]
         { info_tbl: [(c1m66,
                       label: block_c1m66_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m66: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.011619809 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c<=_closure" {
     GHC.Real.$fEnumRatio_$s$c<=_closure:
         const GHC.Real.$fEnumRatio_$s$c<=_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c<=_entry() //  [R2, R3]
         { info_tbl: [(c1m6q,
                       label: GHC.Real.$fEnumRatio_$s$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m6q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1m6H; else goto c1m6I;
       c1m6H: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1m6I: // global
           I64[Sp - 16] = block_c1m6n_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1m6S; else goto c1m6o;
       u1m6S: // global
           call _c1m6n(R1) args: 0, res: 0, upd: 0;
       c1m6o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m6n() //  [R1]
         { info_tbl: [(c1m6n,
                       label: block_c1m6n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m6n: // global
           I64[Sp - 8] = block_c1m6t_info;
           _s1j7r::P64 = P64[R1 + 7];
           _s1j7s::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j7s::P64;
           P64[Sp + 8] = _s1j7r::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m6R; else goto c1m6u;
       u1m6R: // global
           call _c1m6t(R1) args: 0, res: 0, upd: 0;
       c1m6u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m6t() //  [R1]
         { info_tbl: [(c1m6t,
                       label: block_c1m6t_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m6t: // global
           I64[Sp] = block_c1m6y_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp + 8] = P64[R1 + 15];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m6y() //  [R1]
         { info_tbl: [(c1m6y,
                       label: block_c1m6y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m6y: // global
           _s1j7v::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1m6C_info;
           R3 = _s1j7v::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m6C() //  [R1]
         { info_tbl: [(c1m6C,
                       label: block_c1m6C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m6C: // global
           _s1j7x::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1m6G_info;
           R3 = _s1j7x::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m6G() //  [R1]
         { info_tbl: [(c1m6G,
                       label: block_c1m6G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m6G: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.013937582 UTC

[section ""data" . GHC.Real.$w$s$ccompare_closure" {
     GHC.Real.$w$s$ccompare_closure:
         const GHC.Real.$w$s$ccompare_info;
         const 0;
 },
 GHC.Real.$w$s$ccompare_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1m6Z,
                       label: GHC.Real.$w$s$ccompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m6Z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1m70; else goto c1m71;
       c1m70: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$ccompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1m71: // global
           I64[Sp - 40] = block_c1m6X_info;
           _s1j7A::P64 = R3;
           R3 = R4;
           _s1j7z::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s1j7z::P64;
           P64[Sp - 24] = _s1j7A::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m6X() //  [R1]
         { info_tbl: [(c1m6X,
                       label: block_c1m6X_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m6X: // global
           if (R1 == 1) goto c1m7C; else goto u1m7N;
       c1m7C: // global
           I64[Sp] = block_c1m7B_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       u1m7N: // global
           Sp = Sp + 8;
           call _s1j7E() args: 0, res: 0, upd: 0;
     }
 },
 _c1m7B() //  [R1]
         { info_tbl: [(c1m7B,
                       label: block_c1m7B_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m7B: // global
           if (R1 == 1) goto c1m7M; else goto u1m7O;
       c1m7M: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1m7O: // global
           Sp = Sp + 8;
           call _s1j7E() args: 0, res: 0, upd: 0;
     }
 },
 _s1j7E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1j7E: // global
           I64[Sp - 8] = block_c1m7a_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m7a() //  [R1]
         { info_tbl: [(c1m7a,
                       label: block_c1m7a_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m7a: // global
           I64[Sp + 24] = block_c1m7e_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m7e() //  [R1]
         { info_tbl: [(c1m7e,
                       label: block_c1m7e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m7e: // global
           _s1j7G::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1m7k_info;
           R3 = _s1j7G::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m7k() //  [R1]
         { info_tbl: [(c1m7k,
                       label: block_c1m7k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m7k: // global
           if (R1 == 1) goto c1m7v; else goto c1m7r;
       c1m7v: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1m7r: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.016114025 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$ccompare_closure" {
     GHC.Real.$fEnumRatio_$s$ccompare_closure:
         const GHC.Real.$fEnumRatio_$s$ccompare_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c1m7Y,
                       label: GHC.Real.$fEnumRatio_$s$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m7Y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1m82; else goto c1m83;
       c1m82: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1m83: // global
           I64[Sp - 16] = block_c1m7V_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1m8b; else goto c1m7W;
       u1m8b: // global
           call _c1m7V(R1) args: 0, res: 0, upd: 0;
       c1m7W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m7V() //  [R1]
         { info_tbl: [(c1m7V,
                       label: block_c1m7V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m7V: // global
           I64[Sp - 8] = block_c1m81_info;
           _s1j7N::P64 = P64[R1 + 7];
           _s1j7O::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j7O::P64;
           P64[Sp + 8] = _s1j7N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m8a; else goto c1m85;
       u1m8a: // global
           call _c1m81(R1) args: 0, res: 0, upd: 0;
       c1m85: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m81() //  [R1]
         { info_tbl: [(c1m81,
                       label: block_c1m81_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m81: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.018465879 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c>=_closure" {
     GHC.Real.$fEnumRatio_$s$c>=_closure:
         const GHC.Real.$fEnumRatio_$s$c>=_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c>=_entry() //  [R2, R3]
         { info_tbl: [(c1m8j,
                       label: GHC.Real.$fEnumRatio_$s$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m8j: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1m8n; else goto c1m8o;
       c1m8n: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1m8o: // global
           I64[Sp - 16] = block_c1m8g_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1m8I; else goto c1m8h;
       u1m8I: // global
           call _c1m8g(R1) args: 0, res: 0, upd: 0;
       c1m8h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m8g() //  [R1]
         { info_tbl: [(c1m8g,
                       label: block_c1m8g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m8g: // global
           I64[Sp - 8] = block_c1m8m_info;
           _s1j7V::P64 = P64[R1 + 7];
           _s1j7W::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j7W::P64;
           P64[Sp + 8] = _s1j7V::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m8H; else goto c1m8q;
       u1m8H: // global
           call _c1m8m(R1) args: 0, res: 0, upd: 0;
       c1m8q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m8m() //  [R1]
         { info_tbl: [(c1m8m,
                       label: block_c1m8m_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m8m: // global
           _s1j7V::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1m8u_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1j7V::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m8u() //  [R1]
         { info_tbl: [(c1m8u,
                       label: block_c1m8u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m8u: // global
           if (R1 & 7 == 1) goto c1m8F; else goto c1m8B;
       c1m8F: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1m8B: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.020337848 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$c>_closure" {
     GHC.Real.$fOrdRatio_$s$c>_closure:
         const GHC.Real.$fOrdRatio_$s$c>_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$c>_entry() //  [R2, R3]
         { info_tbl: [(c1m8Q,
                       label: GHC.Real.$fOrdRatio_$s$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m8Q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1m8U; else goto c1m8V;
       c1m8U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1m8V: // global
           I64[Sp - 16] = block_c1m8N_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1m9f; else goto c1m8O;
       u1m9f: // global
           call _c1m8N(R1) args: 0, res: 0, upd: 0;
       c1m8O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m8N() //  [R1]
         { info_tbl: [(c1m8N,
                       label: block_c1m8N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m8N: // global
           I64[Sp - 8] = block_c1m8T_info;
           _s1j84::P64 = P64[R1 + 7];
           _s1j85::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j85::P64;
           P64[Sp + 8] = _s1j84::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1m9e; else goto c1m8X;
       u1m9e: // global
           call _c1m8T(R1) args: 0, res: 0, upd: 0;
       c1m8X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m8T() //  [R1]
         { info_tbl: [(c1m8T,
                       label: block_c1m8T_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m8T: // global
           _s1j84::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1m91_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1j84::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m91() //  [R1]
         { info_tbl: [(c1m91,
                       label: block_c1m91_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m91: // global
           if (R1 & 7 == 3) goto c1m9c; else goto c1m98;
       c1m9c: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1m98: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.023618774 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$cmin_closure" {
     GHC.Real.$fOrdRatio_$s$cmin_closure:
         const GHC.Real.$fOrdRatio_$s$cmin_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$cmin_entry() //  [R2, R3]
         { info_tbl: [(c1m9n,
                       label: GHC.Real.$fOrdRatio_$s$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m9n: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1m9A; else goto c1m9B;
       c1m9A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1m9B: // global
           I64[Sp - 16] = block_c1m9k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1m9V; else goto c1m9l;
       u1m9V: // global
           call _c1m9k(R1) args: 0, res: 0, upd: 0;
       c1m9l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m9k() //  [R1]
         { info_tbl: [(c1m9k,
                       label: block_c1m9k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m9k: // global
           I64[Sp - 16] = block_c1m9q_info;
           _s1j8c::P64 = R1;
           _s1j8d::P64 = P64[R1 + 7];
           _s1j8e::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s1j8e::P64;
           P64[Sp] = _s1j8d::P64;
           P64[Sp + 8] = _s1j8c::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1m9U; else goto c1m9r;
       u1m9U: // global
           call _c1m9q(R1) args: 0, res: 0, upd: 0;
       c1m9r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1m9q() //  [R1]
         { info_tbl: [(c1m9q,
                       label: block_c1m9q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m9q: // global
           I64[Sp - 8] = block_c1m9v_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m9v() //  [R1]
         { info_tbl: [(c1m9v,
                       label: block_c1m9v_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m9v: // global
           _s1j8h::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1m9z_info;
           R3 = _s1j8h::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m9z() //  [R1]
         { info_tbl: [(c1m9z,
                       label: block_c1m9z_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m9z: // global
           I64[Sp] = block_c1m9I_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1m9I() //  [R1]
         { info_tbl: [(c1m9I,
                       label: block_c1m9I_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1m9I: // global
           if (R1 == 1) goto c1m9T; else goto c1m9P;
       c1m9T: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1m9P: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.025862494 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$cmax_closure" {
     GHC.Real.$fOrdRatio_$s$cmax_closure:
         const GHC.Real.$fOrdRatio_$s$cmax_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$cmax_entry() //  [R2, R3]
         { info_tbl: [(c1ma3,
                       label: GHC.Real.$fOrdRatio_$s$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ma3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1mag; else goto c1mah;
       c1mag: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mah: // global
           I64[Sp - 16] = block_c1ma0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1maB; else goto c1ma1;
       u1maB: // global
           call _c1ma0(R1) args: 0, res: 0, upd: 0;
       c1ma1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ma0() //  [R1]
         { info_tbl: [(c1ma0,
                       label: block_c1ma0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ma0: // global
           I64[Sp - 16] = block_c1ma6_info;
           _s1j8n::P64 = R1;
           _s1j8o::P64 = P64[R1 + 7];
           _s1j8p::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s1j8p::P64;
           P64[Sp] = _s1j8o::P64;
           P64[Sp + 8] = _s1j8n::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1maA; else goto c1ma7;
       u1maA: // global
           call _c1ma6(R1) args: 0, res: 0, upd: 0;
       c1ma7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ma6() //  [R1]
         { info_tbl: [(c1ma6,
                       label: block_c1ma6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ma6: // global
           I64[Sp - 8] = block_c1mab_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mab() //  [R1]
         { info_tbl: [(c1mab,
                       label: block_c1mab_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mab: // global
           _s1j8s::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1maf_info;
           R3 = _s1j8s::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1maf() //  [R1]
         { info_tbl: [(c1maf,
                       label: block_c1maf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1maf: // global
           I64[Sp] = block_c1mao_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mao() //  [R1]
         { info_tbl: [(c1mao,
                       label: block_c1mao_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mao: // global
           if (R1 == 1) goto c1maz; else goto c1mav;
       c1maz: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1mav: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.02793392 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cnegate_closure" {
     GHC.Real.$fFractionalRatio_$s$cnegate_closure:
         const GHC.Real.$fFractionalRatio_$s$cnegate_info;
 },
 GHC.Real.$fFractionalRatio_$s$cnegate_entry() //  [R2]
         { info_tbl: [(c1maJ,
                       label: GHC.Real.$fFractionalRatio_$s$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1maJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1maR; else goto c1maS;
       c1maR: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1maS: // global
           I64[Sp - 8] = block_c1maG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1maX; else goto c1maH;
       u1maX: // global
           call _c1maG(R1) args: 0, res: 0, upd: 0;
       c1maH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1maG() //  [R1]
         { info_tbl: [(c1maG,
                       label: block_c1maG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1maG: // global
           I64[Sp - 8] = block_c1maM_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1maM() //  [R1]
         { info_tbl: [(c1maM,
                       label: block_c1maM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1maM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1maW; else goto c1maV;
       c1maW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1maV: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.0295031 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cabs_closure" {
     GHC.Real.$fFractionalRatio_$s$cabs_closure:
         const GHC.Real.$fFractionalRatio_$s$cabs_info;
 },
 GHC.Real.$fFractionalRatio_$s$cabs_entry() //  [R2]
         { info_tbl: [(c1mb5,
                       label: GHC.Real.$fFractionalRatio_$s$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mb5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mbd; else goto c1mbe;
       c1mbd: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mbe: // global
           I64[Sp - 8] = block_c1mb2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mbj; else goto c1mb3;
       u1mbj: // global
           call _c1mb2(R1) args: 0, res: 0, upd: 0;
       c1mb3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mb2() //  [R1]
         { info_tbl: [(c1mb2,
                       label: block_c1mb2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mb2: // global
           I64[Sp - 8] = block_c1mb8_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mb8() //  [R1]
         { info_tbl: [(c1mb8,
                       label: block_c1mb8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mb8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mbi; else goto c1mbh;
       c1mbi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mbh: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.030655407 UTC

[section ""data" . sat_s1j8G_closure" {
     sat_s1j8G_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.031315217 UTC

[section ""data" . sat_s1j8H_closure" {
     sat_s1j8H_closure:
         const :_con_info;
         const sat_s1j8G_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.032063318 UTC

[section ""data" . GHC.Real.$fEnumRatio1_closure" {
     GHC.Real.$fEnumRatio1_closure:
         const GHC.Real.$fEnumRatio1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fEnumRatio1_entry() //  [R1]
         { info_tbl: [(c1mbq,
                       label: GHC.Real.$fEnumRatio1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mbq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mbr; else goto c1mbs;
       c1mbr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mbs: // global
           (_c1mbn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1mbn::I64 == 0) goto c1mbp; else goto c1mbo;
       c1mbp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1mbo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1mbn::I64;
           R3 = sat_s1j8H_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.033370928 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$csignum_closure" {
     GHC.Real.$fFractionalRatio_$s$csignum_closure:
         const GHC.Real.$fFractionalRatio_$s$csignum_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$csignum_entry() //  [R2]
         { info_tbl: [(c1mbA,
                       label: GHC.Real.$fFractionalRatio_$s$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mbA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mbI; else goto c1mbJ;
       c1mbI: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mbJ: // global
           I64[Sp - 8] = block_c1mbx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mbO; else goto c1mby;
       u1mbO: // global
           call _c1mbx(R1) args: 0, res: 0, upd: 0;
       c1mby: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mbx() //  [R1]
         { info_tbl: [(c1mbx,
                       label: block_c1mbx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mbx: // global
           I64[Sp] = block_c1mbD_info;
           R2 = P64[R1 + 7];
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mbD() //  [R1]
         { info_tbl: [(c1mbD,
                       label: block_c1mbD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mbD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mbN; else goto c1mbM;
       c1mbN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mbM: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Real.$fEnumRatio1_closure;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.034780992 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cfromInteger_closure" {
     GHC.Real.$fFractionalRatio_$s$cfromInteger_closure:
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$cfromInteger_entry() //  [R2]
         { info_tbl: [(c1mbW,
                       label: GHC.Real.$fFractionalRatio_$s$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mbW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mc0; else goto c1mc1;
       c1mc0: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mc1: // global
           I64[Sp - 8] = block_c1mbT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mc5; else goto c1mbU;
       u1mc5: // global
           call _c1mbT(R1) args: 0, res: 0, upd: 0;
       c1mbU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mbT() //  [R1]
         { info_tbl: [(c1mbT,
                       label: block_c1mbT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mbT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mc4; else goto c1mc3;
       c1mc4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mc3: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Real.$fEnumRatio1_closure;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.035836262 UTC

[section ""data" . GHC.Real.$fRealInteger_closure" {
     GHC.Real.$fRealInteger_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Num.$fNumInteger_closure;
         const GHC.Integer.Type.$fOrdInteger_closure;
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.036594865 UTC

[section ""data" . GHC.Real.$fIntegralInt_$ctoInteger_closure" {
     GHC.Real.$fIntegralInt_$ctoInteger_closure:
         const GHC.Real.$fIntegralInt_$ctoInteger_info;
 },
 GHC.Real.$fIntegralInt_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c1mcd,
                       label: GHC.Real.$fIntegralInt_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mcd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mce; else goto c1mcf;
       c1mce: // global
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mcf: // global
           I64[Sp - 8] = block_c1mca_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mcj; else goto c1mcb;
       u1mcj: // global
           call _c1mca(R1) args: 0, res: 0, upd: 0;
       c1mcb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mca() //  [R1]
         { info_tbl: [(c1mca,
                       label: block_c1mca_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mca: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.037844415 UTC

[section ""data" . GHC.Real.$fEnumRatio_$ctoRational_closure" {
     GHC.Real.$fEnumRatio_$ctoRational_closure:
         const GHC.Real.$fEnumRatio_$ctoRational_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$ctoRational_entry() //  [R2]
         { info_tbl: [(c1mcr,
                       label: GHC.Real.$fEnumRatio_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mcr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mcz; else goto c1mcA;
       c1mcz: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mcA: // global
           I64[Sp - 8] = block_c1mco_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mcF; else goto c1mcp;
       u1mcF: // global
           call _c1mco(R1) args: 0, res: 0, upd: 0;
       c1mcp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mco() //  [R1]
         { info_tbl: [(c1mco,
                       label: block_c1mco_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mco: // global
           I64[Sp] = block_c1mcu_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mcu() //  [R1]
         { info_tbl: [(c1mcu,
                       label: block_c1mcu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mcu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mcE; else goto c1mcD;
       c1mcE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mcD: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Real.$fEnumRatio1_closure;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.039032269 UTC

[section ""data" . GHC.Real.$fRealInt_closure" {
     GHC.Real.$fRealInt_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Num.$fNumInt_closure;
         const GHC.Classes.$fOrdInt_closure;
         const GHC.Real.$fEnumRatio_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.039886804 UTC

[section ""data" . GHC.Real.$fIntegralWord_$ctoInteger_closure" {
     GHC.Real.$fIntegralWord_$ctoInteger_closure:
         const GHC.Real.$fIntegralWord_$ctoInteger_info;
 },
 GHC.Real.$fIntegralWord_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c1mcN,
                       label: GHC.Real.$fIntegralWord_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mcN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mcO; else goto c1mcP;
       c1mcO: // global
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mcP: // global
           I64[Sp - 8] = block_c1mcK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mcT; else goto c1mcL;
       u1mcT: // global
           call _c1mcK(R1) args: 0, res: 0, upd: 0;
       c1mcL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mcK() //  [R1]
         { info_tbl: [(c1mcK,
                       label: block_c1mcK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mcK: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.040996311 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$ctoInteger_closure" {
     GHC.Real.$fIntegralInteger_$ctoInteger_closure:
         const GHC.Real.$fIntegralInteger_$ctoInteger_info;
 },
 GHC.Real.$fIntegralInteger_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c1mcY,
                       label: GHC.Real.$fIntegralInteger_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mcY: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.042242807 UTC

[section ""data" . GHC.Real.$fEqRatio_$s$c==_closure" {
     GHC.Real.$fEqRatio_$s$c==_closure:
         const GHC.Real.$fEqRatio_$s$c==_info;
 },
 GHC.Real.$fEqRatio_$s$c==_entry() //  [R2, R3]
         { info_tbl: [(c1md8,
                       label: GHC.Real.$fEqRatio_$s$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1md8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mdc; else goto c1mdd;
       c1mdc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_$s$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mdd: // global
           I64[Sp - 16] = block_c1md5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mdB; else goto c1md6;
       u1mdB: // global
           call _c1md5(R1) args: 0, res: 0, upd: 0;
       c1md6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1md5() //  [R1]
         { info_tbl: [(c1md5,
                       label: block_c1md5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1md5: // global
           I64[Sp - 8] = block_c1mdb_info;
           _s1j93::P64 = P64[R1 + 7];
           _s1j94::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j94::P64;
           P64[Sp + 8] = _s1j93::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mdA; else goto c1mdf;
       u1mdA: // global
           call _c1mdb(R1) args: 0, res: 0, upd: 0;
       c1mdf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mdb() //  [R1]
         { info_tbl: [(c1mdb,
                       label: block_c1mdb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mdb: // global
           I64[Sp] = block_c1mdj_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 15];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mdj() //  [R1]
         { info_tbl: [(c1mdj,
                       label: block_c1mdj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mdj: // global
           if (R1 == 1) goto c1mdv; else goto c1mdq;
       c1mdv: // global
           _s1j97::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mdt_info;
           R3 = _s1j97::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       c1mdq: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1mdt() //  [R1]
         { info_tbl: [(c1mdt,
                       label: block_c1mdt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mdt: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.04427256 UTC

[section ""data" . GHC.Real.$fEqRatio_$c==_closure" {
     GHC.Real.$fEqRatio_$c==_closure:
         const GHC.Real.$fEqRatio_$c==_info;
 },
 GHC.Real.$fEqRatio_$c==_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mdJ,
                       label: GHC.Real.$fEqRatio_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mdJ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1mdN; else goto c1mdO;
       c1mdN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mdO: // global
           I64[Sp - 24] = block_c1mdG_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1me8; else goto c1mdH;
       u1me8: // global
           call _c1mdG(R1) args: 0, res: 0, upd: 0;
       c1mdH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mdG() //  [R1]
         { info_tbl: [(c1mdG,
                       label: block_c1mdG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mdG: // global
           I64[Sp - 8] = block_c1mdM_info;
           _s1j9e::P64 = P64[R1 + 7];
           _s1j9f::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1j9f::P64;
           P64[Sp + 16] = _s1j9e::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1me7; else goto c1mdQ;
       u1me7: // global
           call _c1mdM(R1) args: 0, res: 0, upd: 0;
       c1mdQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mdM() //  [R1]
         { info_tbl: [(c1mdM,
                       label: block_c1mdM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mdM: // global
           I64[Sp] = block_c1mdU_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1mdU() //  [R1]
         { info_tbl: [(c1mdU,
                       label: block_c1mdU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mdU: // global
           if (R1 & 7 == 1) goto c1me1; else goto c1me5;
       c1me1: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1me5: // global
           R2 = P64[Sp + 16];
           _s1j9f::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1j9f::P64;
           Sp = Sp + 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.046338829 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$c/=_closure" {
     GHC.Real.$fOrdRatio_$s$c/=_closure:
         const GHC.Real.$fOrdRatio_$s$c/=_info;
 },
 GHC.Real.$fOrdRatio_$s$c/=_entry() //  [R2, R3]
         { info_tbl: [(c1meg,
                       label: GHC.Real.$fOrdRatio_$s$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1meg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mek; else goto c1mel;
       c1mek: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mel: // global
           I64[Sp - 16] = block_c1med_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1meR; else goto c1mee;
       u1meR: // global
           call _c1med(R1) args: 0, res: 0, upd: 0;
       c1mee: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1med() //  [R1]
         { info_tbl: [(c1med,
                       label: block_c1med_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1med: // global
           I64[Sp - 8] = block_c1mej_info;
           _s1j9n::P64 = P64[R1 + 7];
           _s1j9o::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j9o::P64;
           P64[Sp + 8] = _s1j9n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1meQ; else goto c1men;
       u1meQ: // global
           call _c1mej(R1) args: 0, res: 0, upd: 0;
       c1men: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mej() //  [R1]
         { info_tbl: [(c1mej,
                       label: block_c1mej_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mej: // global
           I64[Sp] = block_c1mer_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 15];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mer() //  [R1]
         { info_tbl: [(c1mer,
                       label: block_c1mer_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mer: // global
           if (R1 == 1) goto c1meD; else goto u1meO;
       c1meD: // global
           _s1j9r::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1meB_info;
           R3 = _s1j9r::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       u1meO: // global
           Sp = Sp + 24;
           call _c1meJ() args: 0, res: 0, upd: 0;
     }
 },
 _c1meB() //  [R1]
         { info_tbl: [(c1meB,
                       label: block_c1meB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1meB: // global
           if (R1 == 1) goto c1meN; else goto u1meP;
       c1meN: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1meP: // global
           Sp = Sp + 8;
           call _c1meJ() args: 0, res: 0, upd: 0;
     }
 },
 _c1meJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1meJ: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.048635182 UTC

[section ""data" . GHC.Real.$fEqRatio_$c/=_closure" {
     GHC.Real.$fEqRatio_$c/=_closure:
         const GHC.Real.$fEqRatio_$c/=_info;
 },
 GHC.Real.$fEqRatio_$c/=_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mf1,
                       label: GHC.Real.$fEqRatio_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mf1: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1mf5; else goto c1mf6;
       c1mf5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mf6: // global
           I64[Sp - 24] = block_c1meY_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1mfE; else goto c1meZ;
       u1mfE: // global
           call _c1meY(R1) args: 0, res: 0, upd: 0;
       c1meZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1meY() //  [R1]
         { info_tbl: [(c1meY,
                       label: block_c1meY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1meY: // global
           I64[Sp - 8] = block_c1mf4_info;
           _s1j9y::P64 = P64[R1 + 7];
           _s1j9z::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1j9z::P64;
           P64[Sp + 16] = _s1j9y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mfD; else goto c1mf8;
       u1mfD: // global
           call _c1mf4(R1) args: 0, res: 0, upd: 0;
       c1mf8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mf4() //  [R1]
         { info_tbl: [(c1mf4,
                       label: block_c1mf4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mf4: // global
           I64[Sp] = block_c1mfc_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1mfc() //  [R1]
         { info_tbl: [(c1mfc,
                       label: block_c1mfc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mfc: // global
           if (R1 & 7 == 1) goto u1mfB; else goto c1mfo;
       u1mfB: // global
           Sp = Sp + 32;
           call _c1mfu() args: 0, res: 0, upd: 0;
       c1mfo: // global
           _s1j9C::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1mfm_info;
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = _s1j9C::P64;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1mfm() //  [R1]
         { info_tbl: [(c1mfm,
                       label: block_c1mfm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mfm: // global
           if (R1 & 7 == 1) goto u1mfC; else goto c1mfy;
       u1mfC: // global
           Sp = Sp + 8;
           call _c1mfu() args: 0, res: 0, upd: 0;
       c1mfy: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1mfu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mfu: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.050432685 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$fEqRatio_closure" {
     GHC.Real.$fOrdRatio_$s$fEqRatio_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Real.$fEqRatio_$s$c==_closure+2;
         const GHC.Real.$fOrdRatio_$s$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.05152601 UTC

[section ""data" . GHC.Real.$fEqRatio_closure" {
     GHC.Real.$fEqRatio_closure:
         const GHC.Real.$fEqRatio_info;
 },
 sat_s1j9H_entry() //  [R1, R2, R3]
         { info_tbl: [(c1mfQ,
                       label: sat_s1j9H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mfQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fEqRatio_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1j9G_entry() //  [R1, R2, R3]
         { info_tbl: [(c1mfY,
                       label: sat_s1j9G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mfY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fEqRatio_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEqRatio_entry() //  [R2]
         { info_tbl: [(c1mg2,
                       label: GHC.Real.$fEqRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mg2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1mg6; else goto c1mg5;
       c1mg6: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mg5: // global
           I64[Hp - 48] = sat_s1j9H_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s1j9G_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.054041004 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$fOrdRatio_closure" {
     GHC.Real.$fOrdRatio_$s$fOrdRatio_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Real.$fOrdRatio_$s$fEqRatio_closure+1;
         const GHC.Real.$fEnumRatio_$s$ccompare_closure+2;
         const GHC.Real.$fOrdRatio_$s$c<_closure+2;
         const GHC.Real.$fEnumRatio_$s$c<=_closure+2;
         const GHC.Real.$fOrdRatio_$s$c>_closure+2;
         const GHC.Real.$fEnumRatio_$s$c>=_closure+2;
         const GHC.Real.$fOrdRatio_$s$cmax_closure+2;
         const GHC.Real.$fOrdRatio_$s$cmin_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.055057418 UTC

[section ""data" . GHC.Real.$fOrdRatio_$cp1Ord_closure" {
     GHC.Real.$fOrdRatio_$cp1Ord_closure:
         const GHC.Real.$fOrdRatio_$cp1Ord_info;
 },
 sat_s1j9L_entry() //  [R1]
         { info_tbl: [(c1mgh,
                       label: sat_s1j9L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mgh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mgl; else goto c1mgm;
       c1mgl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mgm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1mgf_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mgf() //  [R1]
         { info_tbl: [(c1mgf,
                       label: block_c1mgf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mgf: // global
           I64[Sp] = block_c1mgk_info;
           R2 = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mgk() //  [R1]
         { info_tbl: [(c1mgk,
                       label: block_c1mgk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mgk: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fOrdRatio_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c1mgs,
                       label: GHC.Real.$fOrdRatio_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mgs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mgw; else goto c1mgv;
       c1mgw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mgv: // global
           I64[Hp - 16] = sat_s1j9L_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Real.$fEqRatio_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.056421009 UTC

[section ""data" . GHC.Real.even1_closure" {
     GHC.Real.even1_closure:
         const GHC.Real.even1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.even1_entry() //  [R1]
         { info_tbl: [(c1mgD,
                       label: GHC.Real.even1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mgD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mgE; else goto c1mgF;
       c1mgE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mgF: // global
           (_c1mgA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1mgA::I64 == 0) goto c1mgC; else goto c1mgB;
       c1mgC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1mgB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1mgA::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.058521914 UTC

[section ""data" . GHC.Real.$dmfloor_closure" {
     GHC.Real.$dmfloor_closure:
         const GHC.Real.$dmfloor_info;
         const 0;
 },
 ds_s1j9P_entry() //  [R1]
         { info_tbl: [(c1mgO,
                       label: ds_s1j9P_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mgO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1mgP; else goto c1mgQ;
       c1mgP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mgQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.properFraction_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1j9X_entry() //  [R1]
         { info_tbl: [(c1mh1,
                       label: sat_s1j9X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mh1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mh2; else goto c1mh3;
       c1mh2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mh3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1mgZ_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mgZ() //  [R1]
         { info_tbl: [(c1mgZ,
                       label: block_c1mgZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mgZ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1ja8_entry() //  [R1]
         { info_tbl: [(c1mht,
                       label: sat_s1ja8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mht: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mhu; else goto c1mhv;
       c1mhu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mhv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mhw,
                       label: GHC.Real.$dmfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mhw: // global
           _s1j9O::P64 = R4;
           _s1j9N::P64 = R3;
           _s1j9M::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1mhx; else goto c1mhy;
       c1mhy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1mhA; else goto c1mhz;
       c1mhA: // global
           HpAlloc = 40;
           goto c1mhx;
       c1mhx: // global
           R4 = _s1j9O::P64;
           R3 = _s1j9N::P64;
           R2 = _s1j9M::P64;
           R1 = GHC.Real.$dmfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mhz: // global
           I64[Hp - 32] = ds_s1j9P_info;
           P64[Hp - 16] = _s1j9M::P64;
           P64[Hp - 8] = _s1j9N::P64;
           P64[Hp] = _s1j9O::P64;
           I64[Sp - 24] = block_c1mgR_info;
           R2 = _s1j9M::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s1j9N::P64;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mgR() //  [R1]
         { info_tbl: [(c1mgR,
                       label: block_c1mgR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mgR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1mhD; else goto c1mhC;
       c1mhD: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mhC: // global
           I64[Hp - 40] = sat_s1j9X_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = block_c1mh8_info;
           R2 = R1;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mh8() //  [R1]
         { info_tbl: [(c1mh8,
                       label: block_c1mh8_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mh8: // global
           _c1mgV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mhc_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _c1mgV::P64;
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1mhc() //  [R1]
         { info_tbl: [(c1mhc,
                       label: block_c1mhc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mhc: // global
           if (R1 & 7 == 1) goto c1mhJ; else goto c1mhQ;
       c1mhJ: // global
           I64[Sp + 16] = block_c1mhG_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u1mhX; else goto c1mhK;
       u1mhX: // global
           call _c1mhG(R1) args: 0, res: 0, upd: 0;
       c1mhK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1mhQ: // global
           I64[Sp] = block_c1mhh_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mhG() //  [R1]
         { info_tbl: [(c1mhG,
                       label: block_c1mhG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mhG: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1mhh() //  [R1]
         { info_tbl: [(c1mhh,
                       label: block_c1mhh_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mhh: // global
           I64[Sp] = block_c1mhl_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mhl() //  [R1]
         { info_tbl: [(c1mhl,
                       label: block_c1mhl_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mhl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1mhU; else goto c1mhT;
       c1mhU: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mhT: // global
           I64[Hp - 40] = sat_s1ja8_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = Hp - 40;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.062734689 UTC

[section ""data" . GHC.Real.$dmceiling_closure" {
     GHC.Real.$dmceiling_closure:
         const GHC.Real.$dmceiling_info;
         const 0;
 },
 ds_s1jac_entry() //  [R1]
         { info_tbl: [(c1mi6,
                       label: ds_s1jac_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mi6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1mi7; else goto c1mi8;
       c1mi7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mi8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.properFraction_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jak_entry() //  [R1]
         { info_tbl: [(c1mij,
                       label: sat_s1jak_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mij: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mik; else goto c1mil;
       c1mik: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mil: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1mih_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mih() //  [R1]
         { info_tbl: [(c1mih,
                       label: block_c1mih_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mih: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jav_entry() //  [R1]
         { info_tbl: [(c1miL,
                       label: sat_s1jav_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1miL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1miM; else goto c1miN;
       c1miM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1miN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(c1miO,
                       label: GHC.Real.$dmceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1miO: // global
           _s1jab::P64 = R4;
           _s1jaa::P64 = R3;
           _s1ja9::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1miP; else goto c1miQ;
       c1miQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1miS; else goto c1miR;
       c1miS: // global
           HpAlloc = 40;
           goto c1miP;
       c1miP: // global
           R4 = _s1jab::P64;
           R3 = _s1jaa::P64;
           R2 = _s1ja9::P64;
           R1 = GHC.Real.$dmceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1miR: // global
           I64[Hp - 32] = ds_s1jac_info;
           P64[Hp - 16] = _s1ja9::P64;
           P64[Hp - 8] = _s1jaa::P64;
           P64[Hp] = _s1jab::P64;
           I64[Sp - 24] = block_c1mi9_info;
           R2 = _s1ja9::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s1jaa::P64;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mi9() //  [R1]
         { info_tbl: [(c1mi9,
                       label: block_c1mi9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mi9: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1miV; else goto c1miU;
       c1miV: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1miU: // global
           I64[Hp - 40] = sat_s1jak_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = block_c1miq_info;
           R2 = R1;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1miq() //  [R1]
         { info_tbl: [(c1miq,
                       label: block_c1miq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1miq: // global
           _c1mid::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1miu_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _c1mid::P64;
           Sp = Sp - 8;
           call GHC.Classes.>_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1miu() //  [R1]
         { info_tbl: [(c1miu,
                       label: block_c1miu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1miu: // global
           if (R1 & 7 == 1) goto c1mj1; else goto c1mj8;
       c1mj1: // global
           I64[Sp + 16] = block_c1miY_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u1mjf; else goto c1mj2;
       u1mjf: // global
           call _c1miY(R1) args: 0, res: 0, upd: 0;
       c1mj2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1mj8: // global
           I64[Sp] = block_c1miz_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1miY() //  [R1]
         { info_tbl: [(c1miY,
                       label: block_c1miY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1miY: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1miz() //  [R1]
         { info_tbl: [(c1miz,
                       label: block_c1miz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1miz: // global
           I64[Sp] = block_c1miD_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1miD() //  [R1]
         { info_tbl: [(c1miD,
                       label: block_c1miD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1miD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1mjc; else goto c1mjb;
       c1mjc: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mjb: // global
           I64[Hp - 40] = sat_s1jav_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = Hp - 40;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.065967654 UTC

[section ""data" . GHC.Real.$dmtruncate_closure" {
     GHC.Real.$dmtruncate_closure:
         const GHC.Real.$dmtruncate_info;
 },
 GHC.Real.$dmtruncate_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mjm,
                       label: GHC.Real.$dmtruncate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mjm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mjn; else goto c1mjo;
       c1mjn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmtruncate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mjo: // global
           I64[Sp - 8] = block_c1mjk_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.properFraction_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1mjk() //  [R1]
         { info_tbl: [(c1mjk,
                       label: block_c1mjk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mjk: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.067291105 UTC

[section ""data" . GHC.Real.$dmrecip_closure" {
     GHC.Real.$dmrecip_closure:
         const GHC.Real.$dmrecip_info;
         const 0;
 },
 sat_s1jaF_entry() //  [R1]
         { info_tbl: [(c1mjC,
                       label: sat_s1jaF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mjC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mjD; else goto c1mjE;
       c1mjD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mjE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1mjA_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mjA() //  [R1]
         { info_tbl: [(c1mjA,
                       label: block_c1mjA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mjA: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmrecip_entry() //  [R2, R3]
         { info_tbl: [(c1mjI,
                       label: GHC.Real.$dmrecip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mjI: // global
           _s1jaD::P64 = R3;
           _s1jaC::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1mjJ; else goto c1mjK;
       c1mjK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mjM; else goto c1mjL;
       c1mjM: // global
           HpAlloc = 24;
           goto c1mjJ;
       c1mjJ: // global
           R3 = _s1jaD::P64;
           R2 = _s1jaC::P64;
           R1 = GHC.Real.$dmrecip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mjL: // global
           I64[Hp - 16] = sat_s1jaF_info;
           P64[Hp] = _s1jaC::P64;
           R2 = _s1jaC::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s1jaD::P64;
           Sp = Sp - 24;
           call GHC.Real./_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.068912407 UTC

[section ""data" . GHC.Real.$dm/_closure" {
     GHC.Real.$dm/_closure:
         const GHC.Real.$dm/_info;
 },
 sat_s1jaK_entry() //  [R1]
         { info_tbl: [(c1mjV,
                       label: sat_s1jaK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mjV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mjW; else goto c1mjX;
       c1mjW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mjX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.recip_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dm/_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mk0,
                       label: GHC.Real.$dm/_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mk0: // global
           _s1jaI::P64 = R4;
           _s1jaH::P64 = R3;
           _s1jaG::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1mk1; else goto c1mk2;
       c1mk2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1mk4; else goto c1mk3;
       c1mk4: // global
           HpAlloc = 32;
           goto c1mk1;
       c1mk1: // global
           R4 = _s1jaI::P64;
           R3 = _s1jaH::P64;
           R2 = _s1jaG::P64;
           R1 = GHC.Real.$dm/_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mk3: // global
           I64[Hp - 24] = sat_s1jaK_info;
           P64[Hp - 8] = _s1jaG::P64;
           P64[Hp] = _s1jaI::P64;
           I64[Sp - 24] = block_c1mjY_info;
           R2 = _s1jaG::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s1jaH::P64;
           Sp = Sp - 24;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mjY() //  [R1]
         { info_tbl: [(c1mjY,
                       label: block_c1mjY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mjY: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _c1mjR::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _c1mjR::P64;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.072480593 UTC

[section ""data" . GHC.Real.$dmdivMod_closure" {
     GHC.Real.$dmdivMod_closure:
         const GHC.Real.$dmdivMod_info;
         const 0;
 },
 $dNum_s1jaP_entry() //  [R1]
         { info_tbl: [(c1mkk,
                       label: $dNum_s1jaP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mkk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mkl; else goto c1mkm;
       c1mkl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mkm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_s1jaQ_entry() //  [R1]
         { info_tbl: [(c1mkt,
                       label: ds_s1jaQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mkt: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1mkx; else goto c1mky;
       c1mkx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mky: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1mkr_info;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_pp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1mkr() //  [R1]
         { info_tbl: [(c1mkr,
                       label: block_c1mkr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mkr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1mkB; else goto c1mkA;
       c1mkB: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1mkA: // global
           _s1jaS::P64 = P64[R1 + 7];
           _s1jaT::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = _s1jaS::P64;
           P64[Hp] = _s1jaT::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jb2_entry() //  [R1]
         { info_tbl: [(c1mkL,
                       label: sat_s1jb2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mkL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mkM; else goto c1mkN;
       c1mkM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mkN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jb3_entry() //  [R1]
         { info_tbl: [(c1mkO,
                       label: sat_s1jb3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mkO: // global
           _s1jb3::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1mkP; else goto c1mkQ;
       c1mkQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1mkS; else goto c1mkR;
       c1mkS: // global
           HpAlloc = 32;
           goto c1mkP;
       c1mkP: // global
           R1 = _s1jb3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mkR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jb3::P64;
           _s1jaN::P64 = P64[_s1jb3::P64 + 16];
           _s1jaP::P64 = P64[_s1jb3::P64 + 24];
           I64[Hp - 24] = sat_s1jb2_info;
           P64[Hp - 8] = _s1jaN::P64;
           P64[Hp] = _s1jaP::P64;
           R2 = _s1jaP::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jb1_entry() //  [R1]
         { info_tbl: [(c1mkX,
                       label: sat_s1jb1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mkX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mkY; else goto c1mkZ;
       c1mkY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mkZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jbg_entry() //  [R1]
         { info_tbl: [(c1mlh,
                       label: sat_s1jbg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mlh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1mli; else goto c1mlj;
       c1mli: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mlj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jbe_entry() //  [R1]
         { info_tbl: [(c1mls,
                       label: sat_s1jbe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mls: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mlt; else goto c1mlu;
       c1mlt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mlu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jbf_entry() //  [R1]
         { info_tbl: [(c1mlw,
                       label: sat_s1jbf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mlw: // global
           _s1jbf::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1mlx; else goto c1mly;
       c1mly: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1mlA; else goto c1mlz;
       c1mlA: // global
           HpAlloc = 48;
           goto c1mlx;
       c1mlx: // global
           R1 = _s1jbf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mlz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jbf::P64;
           _s1jaP::P64 = P64[_s1jbf::P64 + 16];
           _s1jaQ::P64 = P64[_s1jbf::P64 + 24];
           I64[Hp - 40] = sat_s1jbe_info;
           P64[Hp - 24] = _s1jaP::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1jaQ::P64;
           R2 = _s1jaP::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmdivMod_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mlB,
                       label: GHC.Real.$dmdivMod_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mlB: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1mlC; else goto c1mlD;
       c1mlC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmdivMod_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mlD: // global
           I64[Sp - 32] = block_c1mkc_info;
           _s1jaL::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1jaL::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mkc() //  [R1]
         { info_tbl: [(c1mkc,
                       label: block_c1mkc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mkc: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c1mlG; else goto c1mlF;
       c1mlG: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mlF: // global
           I64[Hp - 144] = $dNum_s1jaP_info;
           P64[Hp - 128] = R1;
           I64[Hp - 120] = ds_s1jaQ_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = P64[Sp + 16];
           _s1jaN::P64 = P64[Sp + 24];
           P64[Hp - 88] = _s1jaN::P64;
           I64[Hp - 80] = stg_sel_2_upd_info;
           _c1mkn::P64 = Hp - 120;
           P64[Hp - 64] = _c1mkn::P64;
           I64[Hp - 56] = sat_s1jb3_info;
           P64[Hp - 40] = _s1jaN::P64;
           _c1mkg::P64 = Hp - 144;
           P64[Hp - 32] = _c1mkg::P64;
           I64[Hp - 24] = sat_s1jb1_info;
           P64[Hp - 8] = _c1mkg::P64;
           _c1mkC::P64 = Hp - 80;
           P64[Hp] = _c1mkC::P64;
           I64[Sp - 24] = block_c1ml0_info;
           R2 = R1;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 24;
           P64[Sp] = _c1mkC::P64;
           P64[Sp + 8] = _c1mkn::P64;
           P64[Sp + 16] = _c1mkg::P64;
           Sp = Sp - 24;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ml0() //  [R1]
         { info_tbl: [(c1ml0,
                       label: block_c1ml0_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ml0: // global
           I64[Sp] = block_c1ml4_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ml4() //  [R1]
         { info_tbl: [(c1ml4,
                       label: block_c1ml4_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ml4: // global
           _c1mkT::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1ml8_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _c1mkT::P64;
           Sp = Sp - 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1ml8() //  [R1]
         { info_tbl: [(c1ml8,
                       label: block_c1ml8_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ml8: // global
           _c1mkn::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1mlN; else goto c1mlU;
       c1mlN: // global
           I64[Sp + 32] = block_c1mlK_info;
           R1 = _c1mkn::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u1mlZ; else goto c1mlO;
       u1mlZ: // global
           call _c1mlK(R1) args: 0, res: 0, upd: 0;
       c1mlO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1mlU: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1mlX; else goto c1mlW;
       c1mlX: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mlW: // global
           I64[Hp - 88] = sat_s1jbg_info;
           P64[Hp - 72] = P64[Sp + 32];
           _c1mkg::P64 = P64[Sp + 24];
           P64[Hp - 64] = _c1mkg::P64;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = sat_s1jbf_info;
           P64[Hp - 32] = _c1mkg::P64;
           P64[Hp - 24] = _c1mkn::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1mlK() //  [R1]
         { info_tbl: [(c1mlK,
                       label: block_c1mlK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mlK: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.077351504 UTC

[section ""data" . GHC.Real.$dmmod_closure" {
     GHC.Real.$dmmod_closure:
         const GHC.Real.$dmmod_info;
 },
 GHC.Real.$dmmod_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mm6,
                       label: GHC.Real.$dmmod_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mm6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mm7; else goto c1mm8;
       c1mm7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmmod_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mm8: // global
           I64[Sp - 8] = block_c1mm4_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.divMod_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1mm4() //  [R1]
         { info_tbl: [(c1mm4,
                       label: block_c1mm4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mm4: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.078470931 UTC

[section ""data" . GHC.Real.$dmdiv_closure" {
     GHC.Real.$dmdiv_closure:
         const GHC.Real.$dmdiv_info;
 },
 GHC.Real.$dmdiv_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mmi,
                       label: GHC.Real.$dmdiv_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mmi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mmj; else goto c1mmk;
       c1mmj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmdiv_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mmk: // global
           I64[Sp - 8] = block_c1mmg_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.divMod_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1mmg() //  [R1]
         { info_tbl: [(c1mmg,
                       label: block_c1mmg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mmg: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.079593193 UTC

[section ""data" . GHC.Real.$dmrem_closure" {
     GHC.Real.$dmrem_closure:
         const GHC.Real.$dmrem_info;
 },
 GHC.Real.$dmrem_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mmu,
                       label: GHC.Real.$dmrem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mmu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mmv; else goto c1mmw;
       c1mmv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmrem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mmw: // global
           I64[Sp - 8] = block_c1mms_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1mms() //  [R1]
         { info_tbl: [(c1mms,
                       label: block_c1mms_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mms: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.080737081 UTC

[section ""data" . GHC.Real.$dmquot_closure" {
     GHC.Real.$dmquot_closure:
         const GHC.Real.$dmquot_info;
 },
 GHC.Real.$dmquot_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mmG,
                       label: GHC.Real.$dmquot_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mmG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mmH; else goto c1mmI;
       c1mmH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmquot_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mmI: // global
           I64[Sp - 8] = block_c1mmE_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1mmE() //  [R1]
         { info_tbl: [(c1mmE,
                       label: block_c1mmE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mmE: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.082009259 UTC

[section ""data" . GHC.Real.divZeroError_closure" {
     GHC.Real.divZeroError_closure:
         const GHC.Real.divZeroError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.divZeroError_entry() //  [R1]
         { info_tbl: [(c1mmS,
                       label: GHC.Real.divZeroError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mmS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mmT; else goto c1mmU;
       c1mmT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mmU: // global
           (_c1mmP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1mmP::I64 == 0) goto c1mmR; else goto c1mmQ;
       c1mmR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1mmQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1mmP::I64;
           R1 = GHC.Exception.divZeroException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.082919072 UTC

[section ""data" . GHC.Real.$fIntegralInt1_closure" {
     GHC.Real.$fIntegralInt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.083968149 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cmod_closure" {
     GHC.Real.$fIntegralInt_$cmod_closure:
         const GHC.Real.$fIntegralInt_$cmod_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c1mn2,
                       label: GHC.Real.$fIntegralInt_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mn2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mn3; else goto c1mn4;
       c1mn3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mn4: // global
           I64[Sp - 16] = block_c1mmZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mnu; else goto c1mn0;
       u1mnu: // global
           call _c1mmZ(R1) args: 0, res: 0, upd: 0;
       c1mn0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mmZ() //  [R1]
         { info_tbl: [(c1mmZ,
                       label: block_c1mmZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mmZ: // global
           _s1jbJ::I64 = I64[R1 + 7];
           if (_s1jbJ::I64 != (-1)) goto u1mns; else goto c1mnq;
       u1mns: // global
           if (_s1jbJ::I64 != 0) goto c1mnl; else goto c1mnr;
       c1mnl: // global
           I64[Sp] = block_c1mna_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jbJ::I64;
           if (R1 & 7 != 0) goto u1mnt; else goto c1mnb;
       u1mnt: // global
           call _c1mna(R1) args: 0, res: 0, upd: 0;
       c1mnb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1mnr: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1mnq: // global
           R1 = GHC.Real.$fIntegralInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1mna() //  [R1]
         { info_tbl: [(c1mna,
                       label: block_c1mna_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mna: // global
           _s1jbJ::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1mnf_info;
           R3 = _s1jbJ::I64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mnf() //  [R1]
         { info_tbl: [(c1mnf,
                       label: block_c1mnf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mnf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1mnp; else goto c1mno;
       c1mnp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1mno: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.087372196 UTC

[section ""data" . GHC.Real.$fIntegralInt_$crem_closure" {
     GHC.Real.$fIntegralInt_$crem_closure:
         const GHC.Real.$fIntegralInt_$crem_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$crem_entry() //  [R2, R3]
         { info_tbl: [(c1mnC,
                       label: GHC.Real.$fIntegralInt_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mnC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mnD; else goto c1mnE;
       c1mnD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mnE: // global
           I64[Sp - 16] = block_c1mnz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mo2; else goto c1mnA;
       u1mo2: // global
           call _c1mnz(R1) args: 0, res: 0, upd: 0;
       c1mnA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mnz() //  [R1]
         { info_tbl: [(c1mnz,
                       label: block_c1mnz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mnz: // global
           _s1jbS::I64 = I64[R1 + 7];
           if (_s1jbS::I64 != (-1)) goto u1mo0; else goto c1mnY;
       u1mo0: // global
           if (_s1jbS::I64 != 0) goto c1mnU; else goto c1mnZ;
       c1mnU: // global
           I64[Sp] = block_c1mnK_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jbS::I64;
           if (R1 & 7 != 0) goto u1mo1; else goto c1mnL;
       u1mo1: // global
           call _c1mnK(R1) args: 0, res: 0, upd: 0;
       c1mnL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1mnZ: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1mnY: // global
           R1 = GHC.Real.$fIntegralInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1mnK() //  [R1]
         { info_tbl: [(c1mnK,
                       label: block_c1mnK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mnK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1mnX; else goto c1mnW;
       c1mnX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mnW: // global
           _s1jbV::I64 = %MO_S_Rem_W64(I64[R1 + 7], I64[Sp + 8]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1jbV::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.089031668 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cquot_closure" {
     GHC.Real.$fIntegralInteger_$cquot_closure:
         const GHC.Real.$fIntegralInteger_$cquot_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c1moc,
                       label: GHC.Real.$fIntegralInteger_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1moc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mod; else goto c1moe;
       c1mod: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1moe: // global
           I64[Sp - 24] = block_c1mo7_info;
           _s1jbX::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jbW::P64 = R2;
           R2 = _s1jbX::P64;
           P64[Sp - 16] = _s1jbW::P64;
           P64[Sp - 8] = _s1jbX::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mo7() //  [R1]
         { info_tbl: [(c1mo7,
                       label: block_c1mo7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mo7: // global
           if (R1 == 1) goto c1mob; else goto c1moa;
       c1mob: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1moa: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.090367627 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$crem_closure" {
     GHC.Real.$fIntegralInteger_$crem_closure:
         const GHC.Real.$fIntegralInteger_$crem_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$crem_entry() //  [R2, R3]
         { info_tbl: [(c1mou,
                       label: GHC.Real.$fIntegralInteger_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mou: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mov; else goto c1mow;
       c1mov: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mow: // global
           I64[Sp - 24] = block_c1mop_info;
           _s1jc0::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jbZ::P64 = R2;
           R2 = _s1jc0::P64;
           P64[Sp - 16] = _s1jbZ::P64;
           P64[Sp - 8] = _s1jc0::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mop() //  [R1]
         { info_tbl: [(c1mop,
                       label: block_c1mop_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mop: // global
           if (R1 == 1) goto c1mot; else goto c1mos;
       c1mot: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1mos: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.091782272 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cdiv_closure" {
     GHC.Real.$fIntegralInteger_$cdiv_closure:
         const GHC.Real.$fIntegralInteger_$cdiv_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c1moM,
                       label: GHC.Real.$fIntegralInteger_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1moM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1moN; else goto c1moO;
       c1moN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1moO: // global
           I64[Sp - 24] = block_c1moH_info;
           _s1jc3::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jc2::P64 = R2;
           R2 = _s1jc3::P64;
           P64[Sp - 16] = _s1jc2::P64;
           P64[Sp - 8] = _s1jc3::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1moH() //  [R1]
         { info_tbl: [(c1moH,
                       label: block_c1moH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1moH: // global
           if (R1 == 1) goto c1moL; else goto c1moK;
       c1moL: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1moK: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.093052301 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cmod_closure" {
     GHC.Real.$fIntegralInteger_$cmod_closure:
         const GHC.Real.$fIntegralInteger_$cmod_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c1mp4,
                       label: GHC.Real.$fIntegralInteger_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mp4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mp5; else goto c1mp6;
       c1mp5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mp6: // global
           I64[Sp - 24] = block_c1moZ_info;
           _s1jc6::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jc5::P64 = R2;
           R2 = _s1jc6::P64;
           P64[Sp - 16] = _s1jc5::P64;
           P64[Sp - 8] = _s1jc6::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1moZ() //  [R1]
         { info_tbl: [(c1moZ,
                       label: block_c1moZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1moZ: // global
           if (R1 == 1) goto c1mp3; else goto c1mp2;
       c1mp3: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1mp2: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.094571534 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cquotRem_closure" {
     GHC.Real.$fIntegralInteger_$cquotRem_closure:
         const GHC.Real.$fIntegralInteger_$cquotRem_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c1mpm,
                       label: GHC.Real.$fIntegralInteger_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mpm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mpn; else goto c1mpo;
       c1mpn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mpo: // global
           I64[Sp - 24] = block_c1mph_info;
           _s1jc9::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jc8::P64 = R2;
           R2 = _s1jc9::P64;
           P64[Sp - 16] = _s1jc8::P64;
           P64[Sp - 8] = _s1jc9::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mph() //  [R1]
         { info_tbl: [(c1mph,
                       label: block_c1mph_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mph: // global
           if (R1 == 1) goto c1mpl; else goto c1mpk;
       c1mpl: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1mpk: // global
           _s1jc9::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mpr_info;
           R3 = _s1jc9::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mpr() //  [R1, R2]
         { info_tbl: [(c1mpr,
                       label: block_c1mpr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mpr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mpx; else goto c1mpw;
       c1mpx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mpw: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.096243545 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cdivMod_closure" {
     GHC.Real.$fIntegralInteger_$cdivMod_closure:
         const GHC.Real.$fIntegralInteger_$cdivMod_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c1mpK,
                       label: GHC.Real.$fIntegralInteger_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mpK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mpL; else goto c1mpM;
       c1mpL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mpM: // global
           I64[Sp - 24] = block_c1mpF_info;
           _s1jcf::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jce::P64 = R2;
           R2 = _s1jcf::P64;
           P64[Sp - 16] = _s1jce::P64;
           P64[Sp - 8] = _s1jcf::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mpF() //  [R1]
         { info_tbl: [(c1mpF,
                       label: block_c1mpF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mpF: // global
           if (R1 == 1) goto c1mpJ; else goto c1mpI;
       c1mpJ: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1mpI: // global
           _s1jcf::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mpP_info;
           R3 = _s1jcf::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mpP() //  [R1, R2]
         { info_tbl: [(c1mpP,
                       label: block_c1mpP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mpP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mpV; else goto c1mpU;
       c1mpV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mpU: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.09763488 UTC

[section ""data" . GHC.Real.$fIntegralInteger_closure" {
     GHC.Real.$fIntegralInteger_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Real.$fRealInteger_closure+1;
         const GHC.Enum.$fEnumInteger_closure;
         const GHC.Real.$fIntegralInteger_$cquot_closure+2;
         const GHC.Real.$fIntegralInteger_$crem_closure+2;
         const GHC.Real.$fIntegralInteger_$cdiv_closure+2;
         const GHC.Real.$fIntegralInteger_$cmod_closure+2;
         const GHC.Real.$fIntegralInteger_$cquotRem_closure+2;
         const GHC.Real.$fIntegralInteger_$cdivMod_closure+2;
         const GHC.Real.$fIntegralInteger_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.098673504 UTC

[section ""data" . GHC.Real.$fIntegralWord_$cquot_closure" {
     GHC.Real.$fIntegralWord_$cquot_closure:
         const GHC.Real.$fIntegralWord_$cquot_info;
         const 0;
 },
 GHC.Real.$fIntegralWord_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c1mq6,
                       label: GHC.Real.$fIntegralWord_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mq6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mqa; else goto c1mqb;
       c1mqa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mqb: // global
           I64[Sp - 16] = block_c1mq3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mqu; else goto c1mq4;
       u1mqu: // global
           call _c1mq3(R1) args: 0, res: 0, upd: 0;
       c1mq4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mq3() //  [R1]
         { info_tbl: [(c1mq3,
                       label: block_c1mq3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mq3: // global
           I64[Sp] = block_c1mq9_info;
           _s1jcn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jcn::I64;
           if (R1 & 7 != 0) goto u1mqt; else goto c1mqd;
       u1mqt: // global
           call _c1mq9(R1) args: 0, res: 0, upd: 0;
       c1mqd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mq9() //  [R1]
         { info_tbl: [(c1mq9,
                       label: block_c1mq9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mq9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1mqj; else goto c1mqi;
       c1mqj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mqi: // global
           _s1jcq::I64 = I64[R1 + 7];
           if (_s1jcq::I64 != 0) goto c1mqr; else goto c1mqs;
       c1mqr: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] / _s1jcq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mqs: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.100453984 UTC

[section ""data" . GHC.Real.$fIntegralWord_$crem_closure" {
     GHC.Real.$fIntegralWord_$crem_closure:
         const GHC.Real.$fIntegralWord_$crem_info;
         const 0;
 },
 GHC.Real.$fIntegralWord_$crem_entry() //  [R2, R3]
         { info_tbl: [(c1mqC,
                       label: GHC.Real.$fIntegralWord_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mqC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mqG; else goto c1mqH;
       c1mqG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mqH: // global
           I64[Sp - 16] = block_c1mqz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mr0; else goto c1mqA;
       u1mr0: // global
           call _c1mqz(R1) args: 0, res: 0, upd: 0;
       c1mqA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mqz() //  [R1]
         { info_tbl: [(c1mqz,
                       label: block_c1mqz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mqz: // global
           I64[Sp] = block_c1mqF_info;
           _s1jcv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jcv::I64;
           if (R1 & 7 != 0) goto u1mqZ; else goto c1mqJ;
       u1mqZ: // global
           call _c1mqF(R1) args: 0, res: 0, upd: 0;
       c1mqJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mqF() //  [R1]
         { info_tbl: [(c1mqF,
                       label: block_c1mqF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mqF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1mqP; else goto c1mqO;
       c1mqP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mqO: // global
           _s1jcy::I64 = I64[R1 + 7];
           if (_s1jcy::I64 != 0) goto c1mqX; else goto c1mqY;
       c1mqX: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] % _s1jcy::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mqY: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.102413757 UTC

[section ""data" . GHC.Real.$fIntegralWord_$cquotRem_closure" {
     GHC.Real.$fIntegralWord_$cquotRem_closure:
         const GHC.Real.$fIntegralWord_$cquotRem_info;
         const 0;
 },
 GHC.Real.$fIntegralWord_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c1mr8,
                       label: GHC.Real.$fIntegralWord_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mr8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mrc; else goto c1mrd;
       c1mrc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mrd: // global
           I64[Sp - 16] = block_c1mr5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mrv; else goto c1mr6;
       u1mrv: // global
           call _c1mr5(R1) args: 0, res: 0, upd: 0;
       c1mr6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mr5() //  [R1]
         { info_tbl: [(c1mr5,
                       label: block_c1mr5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mr5: // global
           I64[Sp] = block_c1mrb_info;
           _s1jcD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jcD::I64;
           if (R1 & 7 != 0) goto u1mru; else goto c1mrf;
       u1mru: // global
           call _c1mrb(R1) args: 0, res: 0, upd: 0;
       c1mrf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mrb() //  [R1]
         { info_tbl: [(c1mrb,
                       label: block_c1mrb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mrb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1mrl; else goto c1mrk;
       c1mrl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mrk: // global
           _s1jcG::I64 = I64[R1 + 7];
           if (_s1jcG::I64 != 0) goto c1mrs; else goto c1mrt;
       c1mrs: // global
           (_s1jcI::I64, _s1jcJ::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s1jcG::I64);
           I64[Hp - 48] = GHC.Types.W#_con_info;
           I64[Hp - 40] = _s1jcJ::I64;
           I64[Hp - 32] = GHC.Types.W#_con_info;
           I64[Hp - 24] = _s1jcI::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mrt: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.104611186 UTC

[section ""data" . GHC.Real.$fIntegralWord_$cdivMod_closure" {
     GHC.Real.$fIntegralWord_$cdivMod_closure:
         const GHC.Real.$fIntegralWord_$cdivMod_info;
         const 0;
 },
 sat_s1jcW_entry() //  [R1]
         { info_tbl: [(c1mrS,
                       label: sat_s1jcW_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mrS: // global
           _s1jcW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1mrV; else goto c1mrW;
       c1mrW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1mrY; else goto c1mrX;
       c1mrY: // global
           HpAlloc = 16;
           goto c1mrV;
       c1mrV: // global
           R1 = _s1jcW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mrX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jcW::P64;
           _s1jcV::I64 = I64[_s1jcW::P64 + 16] % I64[_s1jcW::P64 + 24];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1jcV::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jcU_entry() //  [R1]
         { info_tbl: [(c1ms5,
                       label: sat_s1jcU_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ms5: // global
           _s1jcU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1ms8; else goto c1ms9;
       c1ms9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1msb; else goto c1msa;
       c1msb: // global
           HpAlloc = 16;
           goto c1ms8;
       c1ms8: // global
           R1 = _s1jcU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1msa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jcU::P64;
           _s1jcT::I64 = I64[_s1jcU::P64 + 16] / I64[_s1jcU::P64 + 24];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1jcT::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fIntegralWord_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c1msc,
                       label: GHC.Real.$fIntegralWord_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1msc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1msd; else goto c1mse;
       c1msd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mse: // global
           I64[Sp - 16] = block_c1mrA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mso; else goto c1mrB;
       u1mso: // global
           call _c1mrA(R1) args: 0, res: 0, upd: 0;
       c1mrB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mrA() //  [R1]
         { info_tbl: [(c1mrA,
                       label: block_c1mrA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mrA: // global
           I64[Sp] = block_c1mrF_info;
           _s1jcP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jcP::I64;
           if (R1 & 7 != 0) goto u1msn; else goto c1mrG;
       u1msn: // global
           call _c1mrF(R1) args: 0, res: 0, upd: 0;
       c1mrG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mrF() //  [R1]
         { info_tbl: [(c1mrF,
                       label: block_c1mrF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mrF: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1msi; else goto c1msh;
       c1msi: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1msh: // global
           _s1jcS::I64 = I64[R1 + 7];
           if (_s1jcS::I64 != 0) goto c1msl; else goto c1msm;
       c1msl: // global
           I64[Hp - 80] = sat_s1jcW_info;
           _s1jcP::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s1jcP::I64;
           I64[Hp - 56] = _s1jcS::I64;
           I64[Hp - 48] = sat_s1jcU_info;
           I64[Hp - 32] = _s1jcP::I64;
           I64[Hp - 24] = _s1jcS::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1msm: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.106904156 UTC

[section ""data" . GHC.Real.ratioZeroDenominatorError_closure" {
     GHC.Real.ratioZeroDenominatorError_closure:
         const GHC.Real.ratioZeroDenominatorError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.ratioZeroDenominatorError_entry() //  [R1]
         { info_tbl: [(c1msv,
                       label: GHC.Real.ratioZeroDenominatorError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1msv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1msw; else goto c1msx;
       c1msw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1msx: // global
           (_c1mss::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1mss::I64 == 0) goto c1msu; else goto c1mst;
       c1msu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1mst: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1mss::I64;
           R1 = GHC.Exception.ratioZeroDenomException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.108380661 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$crecip_closure" {
     GHC.Real.$fFractionalRatio_$s$crecip_closure:
         const GHC.Real.$fFractionalRatio_$s$crecip_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$crecip_entry() //  [R2]
         { info_tbl: [(c1msF,
                       label: GHC.Real.$fFractionalRatio_$s$crecip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1msF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1msG; else goto c1msH;
       c1msG: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$crecip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1msH: // global
           I64[Sp - 8] = block_c1msC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mtn; else goto c1msD;
       u1mtn: // global
           call _c1msC(R1) args: 0, res: 0, upd: 0;
       c1msD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1msC() //  [R1]
         { info_tbl: [(c1msC,
                       label: block_c1msC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1msC: // global
           I64[Sp - 16] = block_c1msK_info;
           R3 = GHC.Real.even1_closure;
           _s1jcZ::P64 = P64[R1 + 7];
           R2 = _s1jcZ::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _s1jcZ::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1msK() //  [R1]
         { info_tbl: [(c1msK,
                       label: block_c1msK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1msK: // global
           if (R1 == 1) goto c1mtm; else goto c1msS;
       c1mtm: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1msS: // global
           I64[Sp] = block_c1msP_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1msP() //  [R1]
         { info_tbl: [(c1msP,
                       label: block_c1msP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1msP: // global
           _s1jd0::P64 = P64[Sp + 8];
           if (R1 == 1) goto c1mte; else goto c1msY;
       c1mte: // global
           I64[Sp + 8] = block_c1mt4_info;
           R2 = _s1jd0::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       c1msY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mt1; else goto c1mt0;
       c1mt1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1mt0: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = _s1jd0::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1mt4() //  [R1]
         { info_tbl: [(c1mt4,
                       label: block_c1mt4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mt4: // global
           I64[Sp] = block_c1mt8_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mt8() //  [R1]
         { info_tbl: [(c1mt8,
                       label: block_c1mt8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mt8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mti; else goto c1mth;
       c1mti: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mth: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.110497009 UTC

[section ""data" . GHC.Real.overflowError_closure" {
     GHC.Real.overflowError_closure:
         const GHC.Real.overflowError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.overflowError_entry() //  [R1]
         { info_tbl: [(c1mtu,
                       label: GHC.Real.overflowError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mtu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mtv; else goto c1mtw;
       c1mtv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mtw: // global
           (_c1mtr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1mtr::I64 == 0) goto c1mtt; else goto c1mts;
       c1mtt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1mts: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1mtr::I64;
           R1 = GHC.Exception.overflowException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.111466225 UTC

[section ""data" . lvl_r1j38_closure" {
     lvl_r1j38_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Real.$fIntegralInt1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.113430893 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cdivMod_closure" {
     GHC.Real.$fIntegralInt_$cdivMod_closure:
         const GHC.Real.$fIntegralInt_$cdivMod_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c1mtE,
                       label: GHC.Real.$fIntegralInt_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mtE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mtI; else goto c1mtJ;
       c1mtI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mtJ: // global
           I64[Sp - 16] = block_c1mtB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mw6; else goto c1mtC;
       u1mw6: // global
           call _c1mtB(R1) args: 0, res: 0, upd: 0;
       c1mtC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mtB() //  [R1]
         { info_tbl: [(c1mtB,
                       label: block_c1mtB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mtB: // global
           I64[Sp] = block_c1mtH_info;
           _s1jd9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jd9::I64;
           if (R1 & 7 != 0) goto u1mw5; else goto c1mtL;
       u1mw5: // global
           call _c1mtH(R1) args: 0, res: 0, upd: 0;
       c1mtL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mtH() //  [R1]
         { info_tbl: [(c1mtH,
                       label: block_c1mtH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mtH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1mtR; else goto c1mtQ;
       c1mtR: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mtQ: // global
           _s1jd9::I64 = I64[Sp + 8];
           _s1jdc::I64 = I64[R1 + 7];
           if (_s1jdc::I64 != (-1)) goto u1mw4; else goto c1mw2;
       u1mw4: // global
           if (_s1jdc::I64 != 0) goto c1mvw; else goto c1mw3;
       c1mvw: // global
           if (%MO_S_Le_W64(_s1jd9::I64, 0)) goto c1mux; else goto c1mvu;
       c1mux: // global
           if (%MO_S_Ge_W64(_s1jd9::I64, 0)) goto c1mu4; else goto c1muv;
       c1mu4: // global
           (_s1jdg::I64, _s1jdh::I64) = call MO_S_QuotRem W64(_s1jd9::I64, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdh::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdg::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1muv: // global
           if (%MO_S_Le_W64(_s1jdc::I64, 0)) goto c1mud; else goto c1muu;
       c1mud: // global
           (_s1jdm::I64, _s1jdn::I64) = call MO_S_QuotRem W64(_s1jd9::I64, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdn::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdm::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1muu: // global
           (_s1jds::I64, _s1jdt::I64) = call MO_S_QuotRem W64(_s1jd9::I64 + 1, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdt::I64 + _s1jdc::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jds::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mvu: // global
           if (%MO_S_Ge_W64(_s1jdc::I64, 0)) goto c1mvc; else goto c1mvt;
       c1mvc: // global
           if (%MO_S_Ge_W64(_s1jd9::I64, 0)) goto c1muJ; else goto c1mva;
       c1muJ: // global
           (_s1jdC::I64, _s1jdD::I64) = call MO_S_QuotRem W64(_s1jd9::I64, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdD::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdC::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mva: // global
           if (%MO_S_Le_W64(_s1jdc::I64, 0)) goto c1muS; else goto c1mv9;
       c1muS: // global
           (_s1jdI::I64, _s1jdJ::I64) = call MO_S_QuotRem W64(_s1jd9::I64, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdJ::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdI::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mv9: // global
           (_s1jdO::I64, _s1jdP::I64) = call MO_S_QuotRem W64(_s1jd9::I64 + 1, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdP::I64 + _s1jdc::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdO::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mvt: // global
           (_s1jdX::I64, _s1jdY::I64) = call MO_S_QuotRem W64(_s1jd9::I64 - 1, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdY::I64 + _s1jdc::I64 + 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdX::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mw3: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1mw2: // global
           if (_s1jd9::I64 == (-9223372036854775808)) goto c1mw1; else goto c1mw0;
       c1mw1: // global
           Hp = Hp - 56;
           R1 = lvl_r1j38_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mw0: // global
           if (%MO_S_Le_W64(_s1jd9::I64, 0)) goto c1mvH; else goto c1mvY;
       c1mvH: // global
           (_s1je7::I64, _s1je8::I64) = call MO_S_QuotRem W64(_s1jd9::I64, (-1));
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1je8::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1je7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mvY: // global
           (_s1jed::I64, _s1jee::I64) = call MO_S_QuotRem W64(_s1jd9::I64 - 1, (-1));
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jee::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jed::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.117164117 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cquotRem_closure" {
     GHC.Real.$fIntegralInt_$cquotRem_closure:
         const GHC.Real.$fIntegralInt_$cquotRem_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c1mwe,
                       label: GHC.Real.$fIntegralInt_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mwe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mwi; else goto c1mwj;
       c1mwi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mwj: // global
           I64[Sp - 16] = block_c1mwb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mwM; else goto c1mwc;
       u1mwM: // global
           call _c1mwb(R1) args: 0, res: 0, upd: 0;
       c1mwc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mwb() //  [R1]
         { info_tbl: [(c1mwb,
                       label: block_c1mwb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mwb: // global
           I64[Sp] = block_c1mwh_info;
           _s1jeo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jeo::I64;
           if (R1 & 7 != 0) goto u1mwL; else goto c1mwl;
       u1mwL: // global
           call _c1mwh(R1) args: 0, res: 0, upd: 0;
       c1mwl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mwh() //  [R1]
         { info_tbl: [(c1mwh,
                       label: block_c1mwh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mwh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1mwr; else goto c1mwq;
       c1mwr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mwq: // global
           _s1jeo::I64 = I64[Sp + 8];
           _s1jer::I64 = I64[R1 + 7];
           if (_s1jer::I64 != (-1)) goto u1mwK; else goto c1mwI;
       u1mwK: // global
           if (_s1jer::I64 != 0) goto c1mwy; else goto c1mwJ;
       c1mwy: // global
           (_s1jet::I64, _s1jeu::I64) = call MO_S_QuotRem W64(_s1jeo::I64, _s1jer::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jeu::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jet::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mwJ: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1mwI: // global
           if (_s1jeo::I64 == (-9223372036854775808)) goto c1mwH; else goto c1mwG;
       c1mwH: // global
           Hp = Hp - 56;
           R1 = lvl_r1j38_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mwG: // global
           (_s1jez::I64, _s1jeA::I64) = call MO_S_QuotRem W64(_s1jeo::I64, (-1));
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jeA::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jez::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.120577349 UTC

[section ""data" . GHC.Real.$w$cdiv_closure" {
     GHC.Real.$w$cdiv_closure:
         const GHC.Real.$w$cdiv_info;
         const 0;
 },
 GHC.Real.$w$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c1mwW,
                       label: GHC.Real.$w$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mwW: // global
           if (R3 == (-1)) goto c1mwU; else goto u1mx5;
       c1mwU: // global
           if (R2 == (-9223372036854775808)) goto c1mx4; else goto c1mx3;
       c1mx4: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1mx3: // global
           R3 = (-1);
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
       u1mx5: // global
           if (R3 == 0) goto c1mwV; else goto c1mwT;
       c1mwV: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1mwT: // global
           R3 = R3;
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.122183903 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cdiv_closure" {
     GHC.Real.$fIntegralInt_$cdiv_closure:
         const GHC.Real.$fIntegralInt_$cdiv_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c1mxd,
                       label: GHC.Real.$fIntegralInt_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mxd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mxq; else goto c1mxr;
       c1mxq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mxr: // global
           I64[Sp - 16] = block_c1mxa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mxy; else goto c1mxb;
       u1mxy: // global
           call _c1mxa(R1) args: 0, res: 0, upd: 0;
       c1mxb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mxa() //  [R1]
         { info_tbl: [(c1mxa,
                       label: block_c1mxa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mxa: // global
           I64[Sp] = block_c1mxg_info;
           _s1jeN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jeN::I64;
           if (R1 & 7 != 0) goto u1mxx; else goto c1mxh;
       u1mxx: // global
           call _c1mxg(R1) args: 0, res: 0, upd: 0;
       c1mxh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mxg() //  [R1]
         { info_tbl: [(c1mxg,
                       label: block_c1mxg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mxg: // global
           _s1jeN::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1mxl_info;
           R3 = I64[R1 + 7];
           R2 = _s1jeN::I64;
           Sp = Sp + 8;
           call GHC.Real.$w$cdiv_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mxl() //  [R1]
         { info_tbl: [(c1mxl,
                       label: block_c1mxl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mxl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1mxw; else goto c1mxv;
       c1mxw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1mxv: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.124101994 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cquot_closure" {
     GHC.Real.$fIntegralInt_$cquot_closure:
         const GHC.Real.$fIntegralInt_$cquot_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c1mxG,
                       label: GHC.Real.$fIntegralInt_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mxG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mxK; else goto c1mxL;
       c1mxK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mxL: // global
           I64[Sp - 16] = block_c1mxD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1myg; else goto c1mxE;
       u1myg: // global
           call _c1mxD(R1) args: 0, res: 0, upd: 0;
       c1mxE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mxD() //  [R1]
         { info_tbl: [(c1mxD,
                       label: block_c1mxD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mxD: // global
           I64[Sp] = block_c1mxJ_info;
           _s1jeU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jeU::I64;
           if (R1 & 7 != 0) goto u1myf; else goto c1mxN;
       u1myf: // global
           call _c1mxJ(R1) args: 0, res: 0, upd: 0;
       c1mxN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mxJ() //  [R1]
         { info_tbl: [(c1mxJ,
                       label: block_c1mxJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mxJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1mxT; else goto c1mxS;
       c1mxT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mxS: // global
           _s1jeU::I64 = I64[Sp + 8];
           _s1jeX::I64 = I64[R1 + 7];
           if (_s1jeX::I64 != (-1)) goto u1mye; else goto c1myc;
       u1mye: // global
           if (_s1jeX::I64 != 0) goto c1my1; else goto c1myd;
       c1my1: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s1jeU::I64, _s1jeX::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1myd: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1myc: // global
           if (_s1jeU::I64 == (-9223372036854775808)) goto c1myb; else goto c1mya;
       c1myb: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1mya: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s1jeU::I64, (-1));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.125725908 UTC

[section ""data" . GHC.Real.$fIntegralInt_closure" {
     GHC.Real.$fIntegralInt_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Real.$fRealInt_closure+1;
         const GHC.Enum.$fEnumInt_closure;
         const GHC.Real.$fIntegralInt_$cquot_closure+2;
         const GHC.Real.$fIntegralInt_$crem_closure+2;
         const GHC.Real.$fIntegralInt_$cdiv_closure+2;
         const GHC.Real.$fIntegralInt_$cmod_closure+2;
         const GHC.Real.$fIntegralInt_$cquotRem_closure+2;
         const GHC.Real.$fIntegralInt_$cdivMod_closure+2;
         const GHC.Real.$fIntegralInt_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.126341455 UTC

[section ""data" . lvl1_r1j39_closure" {
     lvl1_r1j39_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.127539521 UTC

[section ""data" . lvl2_r1j3a_closure" {
     lvl2_r1j3a_closure:
         const lvl2_r1j3a_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r1j3a_entry() //  [R1]
         { info_tbl: [(c1myC,
                       label: lvl2_r1j3a_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1myC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1myD; else goto c1myE;
       c1myD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1myE: // global
           (_c1myz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1myz::I64 == 0) goto c1myB; else goto c1myA;
       c1myB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1myA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1myz::I64;
           R3 = 0;
           R2 = lvl1_r1j39_closure+1;
           Sp = Sp - 16;
           call GHC.Real.$wgcd'_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""data" . GHC.Real.$wgcd'_closure" {
     GHC.Real.$wgcd'_closure:
         const GHC.Real.$wgcd'_info;
         const 0;
 },
 GHC.Real.$wgcd'_entry() //  [R2, R3]
         { info_tbl: [(c1myJ,
                       label: GHC.Real.$wgcd'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1myJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1myK; else goto u1myQ;
       c1myK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wgcd'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1myQ: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1myj() args: 0, res: 0, upd: 0;
     }
 },
 _c1myj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1myj: // global
           _s1jf5::I64 = I64[Sp + 8];
           if (_s1jf5::I64 != (-1)) goto u1myP; else goto c1myH;
       u1myP: // global
           _s1jf3::P64 = P64[Sp];
           if (_s1jf5::I64 != 0) goto c1myG; else goto c1myI;
       c1myG: // global
           I64[Sp] = block_c1myo_info;
           R1 = _s1jf3::P64;
           I64[Sp + 8] = _s1jf5::I64;
           if (R1 & 7 != 0) goto u1myS; else goto c1myp;
       u1myS: // global
           call _c1myo(R1) args: 0, res: 0, upd: 0;
       c1myp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1myI: // global
           R1 = _s1jf3::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1myH: // global
           R1 = lvl2_r1j3a_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1myo() //  [R1]
         { info_tbl: [(c1myo,
                       label: block_c1myo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1myo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1myO; else goto c1myN;
       c1myO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1myN: // global
           _s1jf5::I64 = I64[Sp + 8];
           _s1jf8::I64 = %MO_S_Rem_W64(I64[R1 + 7], _s1jf5::I64);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1jf5::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s1jf8::I64;
           call _c1myj() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.129732804 UTC

[section ""data" . GHC.Real.$fEnumRatio_gcd'_closure" {
     GHC.Real.$fEnumRatio_gcd'_closure:
         const GHC.Real.$fEnumRatio_gcd'_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_gcd'_entry() //  [R2, R3]
         { info_tbl: [(c1mz4,
                       label: GHC.Real.$fEnumRatio_gcd'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mz4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mz5; else goto u1mzi;
       c1mz5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_gcd'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1mzi: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1myW() args: 0, res: 0, upd: 0;
     }
 },
 _c1myW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1myW: // global
           I64[Sp - 8] = block_c1myZ_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1myZ() //  [R1]
         { info_tbl: [(c1myZ,
                       label: block_c1myZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1myZ: // global
           _s1jfa::P64 = P64[Sp + 8];
           if (R1 == 1) goto c1mz3; else goto c1mz2;
       c1mz3: // global
           R1 = _s1jfa::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1mz2: // global
           I64[Sp + 8] = block_c1mz9_info;
           R3 = P64[Sp + 16];
           R2 = _s1jfa::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mz9() //  [R1]
         { info_tbl: [(c1mz9,
                       label: block_c1mz9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mz9: // global
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call _c1myW() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.132501431 UTC

[section ""data" . GHC.Real.gcd_closure" {
     GHC.Real.gcd_closure:
         const GHC.Real.gcd_info;
         const 0;
 },
 lvl8_s1jfi_entry() //  [R1]
         { info_tbl: [(c1mzY,
                       label: lvl8_s1jfi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mzY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mzZ; else goto c1mA0;
       c1mzZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mA0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1mzW_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mzW() //  [R1]
         { info_tbl: [(c1mzW,
                       label: block_c1mzW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mzW: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dNum_s1jfm_entry() //  [R1]
         { info_tbl: [(c1mA6,
                       label: $dNum_s1jfm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mA6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mA7; else goto c1mA8;
       c1mA7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mA8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jft_entry() //  [R1]
         { info_tbl: [(c1mAb,
                       label: sat_s1jft_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mAb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mAc; else goto c1mAd;
       c1mAc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mAd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jfs_entry() //  [R1]
         { info_tbl: [(c1mAg,
                       label: sat_s1jfs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mAg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mAh; else goto c1mAi;
       c1mAh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mAi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jfr_entry() //  [R1]
         { info_tbl: [(c1mAm,
                       label: sat_s1jfr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mAm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1mAn; else goto c1mAo;
       c1mAn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mAo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.rem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.gcd_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mAp,
                       label: GHC.Real.gcd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mAp: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1mAq; else goto c1mAr;
       c1mAq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.gcd_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mAr: // global
           I64[Sp - 32] = block_c1mzq_info;
           _s1jfe::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1jfe::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mzq() //  [R1]
         { info_tbl: [(c1mzq,
                       label: block_c1mzq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mzq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mAu; else goto c1mAt;
       c1mAu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mAt: // global
           I64[Hp - 16] = lvl8_s1jfi_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c1mzw_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mzw() //  [R1]
         { info_tbl: [(c1mzw,
                       label: block_c1mzw_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mzw: // global
           I64[Sp] = block_c1mzA_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mzA() //  [R1]
         { info_tbl: [(c1mzA,
                       label: block_c1mzA_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mzA: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1mAy; else goto c1mAx;
       c1mAy: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mAx: // global
           I64[Hp - 80] = $dNum_s1jfm_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s1jft_info;
           P64[Hp - 40] = P64[Sp + 40];
           _c1mzE::P64 = Hp - 80;
           P64[Hp - 32] = _c1mzE::P64;
           I64[Hp - 24] = sat_s1jfs_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _c1mzE::P64;
           P64[Sp + 8] = Hp - 56;
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _c1mzN() args: 0, res: 0, upd: 0;
     }
 },
 _c1mzN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mzN: // global
           I64[Sp - 8] = block_c1mzP_info;
           R2 = P64[Sp + 32];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp];
           P64[Sp - 16] = P64[Sp + 8];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1mzP() //  [R1]
         { info_tbl: [(c1mzP,
                       label: block_c1mzP_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mzP: // global
           _s1jfo::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c1mAB; else goto c1mAI;
       c1mAB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1mAE; else goto c1mAD;
       c1mAE: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mAD: // global
           I64[Hp - 32] = sat_s1jfr_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _s1jfo::P64;
           _s1jfp::P64 = P64[Sp + 8];
           P64[Hp] = _s1jfp::P64;
           _s1jfo::P64 = _s1jfp::P64;
           P64[Sp + 32] = _s1jfo::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _c1mzN() args: 0, res: 0, upd: 0;
       c1mAI: // global
           R1 = _s1jfo::P64;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.136563971 UTC

[section ""data" . GHC.Real.$w$sreduce_closure" {
     GHC.Real.$w$sreduce_closure:
         const GHC.Real.$w$sreduce_info;
         const 0;
 },
 section ""relreadonly" . u1mBG_srtd" {
     u1mBG_srtd:
         const S1jKw_srt+160;
         const 33;
         const 5905711105;
 },
 GHC.Real.$w$sreduce_entry() //  [R2, R3]
         { info_tbl: [(c1mAX,
                       label: GHC.Real.$w$sreduce_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mAX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mAY; else goto c1mAZ;
       c1mAY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$sreduce_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mAZ: // global
           I64[Sp - 24] = block_c1mAS_info;
           _s1jfv::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jfu::P64 = R2;
           R2 = _s1jfv::P64;
           P64[Sp - 16] = _s1jfu::P64;
           P64[Sp - 8] = _s1jfv::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mAS() //  [R1]
         { info_tbl: [(c1mAS,
                       label: block_c1mAS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mAS: // global
           if (R1 == 1) goto c1mAW; else goto c1mAV;
       c1mAW: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1mAV: // global
           I64[Sp] = block_c1mB2_info;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mB2() //  [R1]
         { info_tbl: [(c1mB2,
                       label: block_c1mB2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mB2: // global
           I64[Sp - 8] = block_c1mB6_info;
           R2 = P64[Sp + 8];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mB6() //  [R1]
         { info_tbl: [(c1mB6,
                       label: block_c1mB6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mB6: // global
           _s1jfz::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1mBa_info;
           R3 = _s1jfz::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$fEnumRatio_gcd'_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mBa() //  [R1]
         { info_tbl: [(c1mBa,
                       label: block_c1mBa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mBa: // global
           I64[Sp - 8] = block_c1mBh_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mBh() //  [R1]
         { info_tbl: [(c1mBh,
                       label: block_c1mBh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mBh: // global
           if (R1 == 1) goto c1mBC; else goto c1mBt;
       c1mBC: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1mBt: // global
           I64[Sp] = block_c1mBm_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mBm() //  [R1]
         { info_tbl: [(c1mBm,
                       label: block_c1mBm_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mBm: // global
           I64[Sp + 16] = block_c1mBq_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mBq() //  [R1]
         { info_tbl: [(c1mBq,
                       label: block_c1mBq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mBq: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.138835113 UTC

[section ""data" . GHC.Real.reduce_$sreduce_closure" {
     GHC.Real.reduce_$sreduce_closure:
         const GHC.Real.reduce_$sreduce_info;
         const 0;
 },
 GHC.Real.reduce_$sreduce_entry() //  [R2, R3]
         { info_tbl: [(c1mBO,
                       label: GHC.Real.reduce_$sreduce_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mBO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mBP; else goto c1mBQ;
       c1mBP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.reduce_$sreduce_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mBQ: // global
           I64[Sp - 8] = block_c1mBL_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mBL() //  [R1, R2]
         { info_tbl: [(c1mBL,
                       label: block_c1mBL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mBL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mBT; else goto c1mBS;
       c1mBT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mBS: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.140282754 UTC

[section ""data" . GHC.Real.$fRealWord_$ctoRational_closure" {
     GHC.Real.$fRealWord_$ctoRational_closure:
         const GHC.Real.$fRealWord_$ctoRational_info;
         const 0;
 },
 section ""relreadonly" . u1mCo_srtd" {
     u1mCo_srtd:
         const S1jKw_srt;
         const 56;
         const 40532396646335489;
 },
 GHC.Real.$fRealWord_$ctoRational_entry() //  [R2]
         { info_tbl: [(c1mC1,
                       label: GHC.Real.$fRealWord_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mC1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mCf; else goto c1mCg;
       c1mCf: // global
           R2 = R2;
           R1 = GHC.Real.$fRealWord_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mCg: // global
           I64[Sp - 8] = block_c1mBY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mCn; else goto c1mBZ;
       u1mCn: // global
           call _c1mBY(R1) args: 0, res: 0, upd: 0;
       c1mBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mCp_srtd" {
     u1mCp_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627371521;
 },
 _c1mBY() //  [R1]
         { info_tbl: [(c1mBY,
                       label: block_c1mBY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mBY: // global
           I64[Sp] = block_c1mC4_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mCq_srtd" {
     u1mCq_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627371521;
 },
 _c1mC4() //  [R1]
         { info_tbl: [(c1mC4,
                       label: block_c1mC4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mC4: // global
           I64[Sp] = block_c1mC8_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mCr_srtd" {
     u1mCr_srtd:
         const S1jKw_srt+80;
         const 43;
         const 4398046511105;
 },
 _c1mC8() //  [R1]
         { info_tbl: [(c1mC8,
                       label: block_c1mC8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mC8: // global
           I64[Sp] = block_c1mCc_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mCc() //  [R1, R2]
         { info_tbl: [(c1mCc,
                       label: block_c1mCc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mCc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mCm; else goto c1mCl;
       c1mCm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mCl: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.142082027 UTC

[section ""data" . GHC.Real.$fRealWord_closure" {
     GHC.Real.$fRealWord_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Num.$fNumWord_closure;
         const GHC.Classes.$fOrdWord_closure;
         const GHC.Real.$fRealWord_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.142649312 UTC

[section ""data" . GHC.Real.$fIntegralWord_closure" {
     GHC.Real.$fIntegralWord_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Real.$fRealWord_closure+1;
         const GHC.Enum.$fEnumWord_closure;
         const GHC.Real.$fIntegralWord_$cquot_closure+2;
         const GHC.Real.$fIntegralWord_$crem_closure+2;
         const GHC.Real.$fIntegralWord_$cquot_closure+2;
         const GHC.Real.$fIntegralWord_$crem_closure+2;
         const GHC.Real.$fIntegralWord_$cquotRem_closure+2;
         const GHC.Real.$fIntegralWord_$cdivMod_closure+2;
         const GHC.Real.$fIntegralWord_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.143751041 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$c*_closure" {
     GHC.Real.$fFractionalRatio_$s$c*_closure:
         const GHC.Real.$fFractionalRatio_$s$c*_info;
         const 0;
 },
 section ""relreadonly" . u1mD3_srtd" {
     u1mD3_srtd:
         const S1jKw_srt;
         const 57;
         const 76561193665298433;
 },
 GHC.Real.$fFractionalRatio_$s$c*_entry() //  [R2, R3]
         { info_tbl: [(c1mCz,
                       label: GHC.Real.$fFractionalRatio_$s$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mCz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mCS; else goto c1mCT;
       c1mCS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mCT: // global
           I64[Sp - 16] = block_c1mCw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mD2; else goto c1mCx;
       u1mD2: // global
           call _c1mCw(R1) args: 0, res: 0, upd: 0;
       c1mCx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mD4_srtd" {
     u1mD4_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1mCw() //  [R1]
         { info_tbl: [(c1mCw,
                       label: block_c1mCw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mCw: // global
           I64[Sp - 8] = block_c1mCC_info;
           _s1jfV::P64 = P64[R1 + 7];
           _s1jfW::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jfW::P64;
           P64[Sp + 8] = _s1jfV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mD1; else goto c1mCD;
       u1mD1: // global
           call _c1mCC(R1) args: 0, res: 0, upd: 0;
       c1mCD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mD5_srtd" {
     u1mD5_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1mCC() //  [R1]
         { info_tbl: [(c1mCC,
                       label: block_c1mCC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mCC: // global
           I64[Sp] = block_c1mCH_info;
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mD6_srtd" {
     u1mD6_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1mCH() //  [R1]
         { info_tbl: [(c1mCH,
                       label: block_c1mCH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mCH: // global
           _s1jfY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1mCL_info;
           R3 = _s1jfY::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mCL() //  [R1]
         { info_tbl: [(c1mCL,
                       label: block_c1mCL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mCL: // global
           _s1jg1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1mCP_info;
           R3 = _s1jg1::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mCP() //  [R1, R2]
         { info_tbl: [(c1mCP,
                       label: block_c1mCP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mCP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mD0; else goto c1mCZ;
       c1mD0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mCZ: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.14674372 UTC

[section ""data" . GHC.Real.$w$s$c-_closure" {
     GHC.Real.$w$s$c-_closure:
         const GHC.Real.$w$s$c-_info;
         const 0;
 },
 section ""relreadonly" . u1mDy_srtd" {
     u1mDy_srtd:
         const S1jKw_srt;
         const 59;
         const 436849163854938113;
 },
 GHC.Real.$w$s$c-_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1mDd,
                       label: GHC.Real.$w$s$c-_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mDd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1mDp; else goto c1mDq;
       c1mDp: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$c-_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mDq: // global
           I64[Sp - 40] = block_c1mDb_info;
           _s1jg6::P64 = R3;
           R3 = R5;
           _s1jg5::P64 = R2;
           R2 = _s1jg6::P64;
           P64[Sp - 32] = _s1jg5::P64;
           P64[Sp - 24] = _s1jg6::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mDz_srtd" {
     u1mDz_srtd:
         const S1jKw_srt;
         const 58;
         const 148618787703226369;
 },
 _c1mDb() //  [R1]
         { info_tbl: [(c1mDb,
                       label: block_c1mDb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mDb: // global
           I64[Sp] = block_c1mDg_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mDA_srtd" {
     u1mDA_srtd:
         const S1jKw_srt;
         const 58;
         const 148618787703226369;
 },
 _c1mDg() //  [R1]
         { info_tbl: [(c1mDg,
                       label: block_c1mDg_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mDg: // global
           I64[Sp + 16] = block_c1mDk_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mDk() //  [R1]
         { info_tbl: [(c1mDk,
                       label: block_c1mDk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mDk: // global
           I64[Sp] = block_c1mDo_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mDo() //  [R1]
         { info_tbl: [(c1mDo,
                       label: block_c1mDo_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mDo: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.148803503 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c-_closure" {
     GHC.Real.$fEnumRatio_$s$c-_closure:
         const GHC.Real.$fEnumRatio_$s$c-_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c-_entry() //  [R2, R3]
         { info_tbl: [(c1mDI,
                       label: GHC.Real.$fEnumRatio_$s$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mDI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mDT; else goto c1mDU;
       c1mDT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mDU: // global
           I64[Sp - 16] = block_c1mDF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mE1; else goto c1mDG;
       u1mE1: // global
           call _c1mDF(R1) args: 0, res: 0, upd: 0;
       c1mDG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mDF() //  [R1]
         { info_tbl: [(c1mDF,
                       label: block_c1mDF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mDF: // global
           I64[Sp - 8] = block_c1mDL_info;
           _s1jgg::P64 = P64[R1 + 7];
           _s1jgh::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jgh::P64;
           P64[Sp + 8] = _s1jgg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mE0; else goto c1mDM;
       u1mE0: // global
           call _c1mDL(R1) args: 0, res: 0, upd: 0;
       c1mDM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mDL() //  [R1]
         { info_tbl: [(c1mDL,
                       label: block_c1mDL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mDL: // global
           _s1jgg::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mDQ_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1jgg::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mDQ() //  [R1, R2]
         { info_tbl: [(c1mDQ,
                       label: block_c1mDQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mDQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mDZ; else goto c1mDY;
       c1mDZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mDY: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.15090999 UTC

[section ""data" . GHC.Real.$w$s$c+_closure" {
     GHC.Real.$w$s$c+_closure:
         const GHC.Real.$w$s$c+_info;
         const 0;
 },
 section ""relreadonly" . u1mEt_srtd" {
     u1mEt_srtd:
         const S1jKw_srt;
         const 62;
         const 3463268113447911425;
 },
 GHC.Real.$w$s$c+_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1mE8,
                       label: GHC.Real.$w$s$c+_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mE8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1mEk; else goto c1mEl;
       c1mEk: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$c+_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mEl: // global
           I64[Sp - 40] = block_c1mE6_info;
           _s1jgp::P64 = R3;
           R3 = R5;
           _s1jgo::P64 = R2;
           R2 = _s1jgp::P64;
           P64[Sp - 32] = _s1jgo::P64;
           P64[Sp - 24] = _s1jgp::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mEu_srtd" {
     u1mEu_srtd:
         const S1jKw_srt;
         const 61;
         const 1157425104234217473;
 },
 _c1mE6() //  [R1]
         { info_tbl: [(c1mE6,
                       label: block_c1mE6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mE6: // global
           I64[Sp] = block_c1mEb_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mEv_srtd" {
     u1mEv_srtd:
         const S1jKw_srt;
         const 61;
         const 1157425104234217473;
 },
 _c1mEb() //  [R1]
         { info_tbl: [(c1mEb,
                       label: block_c1mEb_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mEb: // global
           I64[Sp + 16] = block_c1mEf_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mEf() //  [R1]
         { info_tbl: [(c1mEf,
                       label: block_c1mEf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mEf: // global
           I64[Sp] = block_c1mEj_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mEj() //  [R1]
         { info_tbl: [(c1mEj,
                       label: block_c1mEj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mEj: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.154774836 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c+_closure" {
     GHC.Real.$fEnumRatio_$s$c+_closure:
         const GHC.Real.$fEnumRatio_$s$c+_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c+_entry() //  [R2, R3]
         { info_tbl: [(c1mED,
                       label: GHC.Real.$fEnumRatio_$s$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mED: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mEO; else goto c1mEP;
       c1mEO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mEP: // global
           I64[Sp - 16] = block_c1mEA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mEW; else goto c1mEB;
       u1mEW: // global
           call _c1mEA(R1) args: 0, res: 0, upd: 0;
       c1mEB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mEA() //  [R1]
         { info_tbl: [(c1mEA,
                       label: block_c1mEA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mEA: // global
           I64[Sp - 8] = block_c1mEG_info;
           _s1jgz::P64 = P64[R1 + 7];
           _s1jgA::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jgA::P64;
           P64[Sp + 8] = _s1jgz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mEV; else goto c1mEH;
       u1mEV: // global
           call _c1mEG(R1) args: 0, res: 0, upd: 0;
       c1mEH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mEG() //  [R1]
         { info_tbl: [(c1mEG,
                       label: block_c1mEG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mEG: // global
           _s1jgz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mEL_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1jgz::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mEL() //  [R1, R2]
         { info_tbl: [(c1mEL,
                       label: block_c1mEL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mEL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mEU; else goto c1mET;
       c1mEU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mET: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.156386597 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$fNumRatio_closure" {
     GHC.Real.$fFractionalRatio_$s$fNumRatio_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Real.$fEnumRatio_$s$c+_closure+2;
         const GHC.Real.$fEnumRatio_$s$c-_closure+2;
         const GHC.Real.$fFractionalRatio_$s$c*_closure+2;
         const GHC.Real.$fFractionalRatio_$s$cnegate_closure+1;
         const GHC.Real.$fFractionalRatio_$s$cabs_closure+1;
         const GHC.Real.$fFractionalRatio_$s$csignum_closure+1;
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.157354703 UTC

[section ""data" . GHC.Real.$w$s$cfromRational_closure" {
     GHC.Real.$w$s$cfromRational_closure:
         const GHC.Real.$w$s$cfromRational_info;
         const 0;
 },
 section ""relreadonly" . u1mFj_srtd" {
     u1mFj_srtd:
         const S1jKw_srt;
         const 64;
         const 9227875636482146305;
 },
 GHC.Real.$w$s$cfromRational_entry() //  [R2, R3]
         { info_tbl: [(c1mF3,
                       label: GHC.Real.$w$s$cfromRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mF3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mFb; else goto c1mFc;
       c1mFb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cfromRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mFc: // global
           I64[Sp - 24] = block_c1mF1_info;
           _s1jgH::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _s1jgH::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mFk_srtd" {
     u1mFk_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1mF1() //  [R1]
         { info_tbl: [(c1mF1,
                       label: block_c1mF1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mF1: // global
           I64[Sp] = block_c1mF6_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mFl_srtd" {
     u1mFl_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1mF6() //  [R1]
         { info_tbl: [(c1mF6,
                       label: block_c1mF6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mF6: // global
           _s1jgH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1mFa_info;
           R3 = R1;
           R2 = _s1jgH::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mFa() //  [R1]
         { info_tbl: [(c1mFa,
                       label: block_c1mFa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mFa: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.159053828 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cfromRational_closure" {
     GHC.Real.$fFractionalRatio_$s$cfromRational_closure:
         const GHC.Real.$fFractionalRatio_$s$cfromRational_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$cfromRational_entry() //  [R2]
         { info_tbl: [(c1mFt,
                       label: GHC.Real.$fFractionalRatio_$s$cfromRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mFt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mFz; else goto c1mFA;
       c1mFz: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cfromRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mFA: // global
           I64[Sp - 8] = block_c1mFq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mFF; else goto c1mFr;
       u1mFF: // global
           call _c1mFq(R1) args: 0, res: 0, upd: 0;
       c1mFr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mFq() //  [R1]
         { info_tbl: [(c1mFq,
                       label: block_c1mFq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mFq: // global
           I64[Sp] = block_c1mFw_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$cfromRational_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mFw() //  [R1, R2]
         { info_tbl: [(c1mFw,
                       label: block_c1mFw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mFw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mFE; else goto c1mFD;
       c1mFE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mFD: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.160630148 UTC

[section ""data" . GHC.Real.$w$s$c/_closure" {
     GHC.Real.$w$s$c/_closure:
         const GHC.Real.$w$s$c/_info;
         const 0;
 },
 section ""relreadonly" . u1mGc_srtd" {
     u1mGc_srtd:
         const S1jKw_srt;
         const 66;
         const 4503599627370497;
         const 2;
 },
 GHC.Real.$w$s$c/_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1mFM,
                       label: GHC.Real.$w$s$c/_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mFM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mG2; else goto c1mG3;
       c1mG2: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$c/_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mG3: // global
           I64[Sp - 24] = block_c1mFK_info;
           _s1jgU::P64 = R3;
           R3 = R4;
           _s1jgT::P64 = R2;
           R2 = _s1jgU::P64;
           P64[Sp - 16] = _s1jgT::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mGd_srtd" {
     u1mGd_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1mFK() //  [R1]
         { info_tbl: [(c1mFK,
                       label: block_c1mFK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mFK: // global
           I64[Sp - 8] = block_c1mFP_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mGe_srtd" {
     u1mGe_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1mFP() //  [R1]
         { info_tbl: [(c1mFP,
                       label: block_c1mFP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mFP: // global
           I64[Sp] = block_c1mFT_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mGf_srtd" {
     u1mGf_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1mFT() //  [R1]
         { info_tbl: [(c1mFT,
                       label: block_c1mFT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mFT: // global
           I64[Sp] = block_c1mFX_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mGg_srtd" {
     u1mGg_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1mFX() //  [R1]
         { info_tbl: [(c1mFX,
                       label: block_c1mFX_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mFX: // global
           I64[Sp] = block_c1mG1_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mG1() //  [R1]
         { info_tbl: [(c1mG1,
                       label: block_c1mG1_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mG1: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.162869518 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$c/_closure" {
     GHC.Real.$fFractionalRatio_$s$c/_closure:
         const GHC.Real.$fFractionalRatio_$s$c/_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$c/_entry() //  [R2, R3]
         { info_tbl: [(c1mGo,
                       label: GHC.Real.$fFractionalRatio_$s$c/_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mGo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mGz; else goto c1mGA;
       c1mGz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$c/_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mGA: // global
           I64[Sp - 16] = block_c1mGl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mGH; else goto c1mGm;
       u1mGH: // global
           call _c1mGl(R1) args: 0, res: 0, upd: 0;
       c1mGm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mGl() //  [R1]
         { info_tbl: [(c1mGl,
                       label: block_c1mGl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mGl: // global
           I64[Sp - 8] = block_c1mGr_info;
           _s1jh5::P64 = P64[R1 + 7];
           _s1jh6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jh6::P64;
           P64[Sp + 8] = _s1jh5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mGG; else goto c1mGs;
       u1mGG: // global
           call _c1mGr(R1) args: 0, res: 0, upd: 0;
       c1mGs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mGr() //  [R1]
         { info_tbl: [(c1mGr,
                       label: block_c1mGr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mGr: // global
           _s1jh5::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mGw_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1jh5::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mGw() //  [R1, R2]
         { info_tbl: [(c1mGw,
                       label: block_c1mGw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mGw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mGF; else goto c1mGE;
       c1mGF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mGE: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.16437937 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$fFractionalRatio_closure" {
     GHC.Real.$fFractionalRatio_$s$fFractionalRatio_closure:
         const GHC.Real.C:Fractional_con_info;
         const GHC.Real.$fFractionalRatio_$s$fNumRatio_closure+1;
         const GHC.Real.$fFractionalRatio_$s$c/_closure+2;
         const GHC.Real.$fFractionalRatio_$s$crecip_closure+1;
         const GHC.Real.$fFractionalRatio_$s$cfromRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.164947926 UTC

[section ""data" . GHC.Real.ratioPrec_closure" {
     GHC.Real.ratioPrec_closure:
         const GHC.Types.I#_con_info;
         const 7;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.165560612 UTC

[section ""data" . GHC.Real.infinity_closure" {
     GHC.Real.infinity_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.even1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.166098092 UTC

[section ""data" . GHC.Real.notANumber_closure" {
     GHC.Real.notANumber_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.even1_closure;
         const GHC.Real.even1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.166874673 UTC

[section ""data" . GHC.Real.numerator_closure" {
     GHC.Real.numerator_closure:
         const GHC.Real.numerator_info;
 },
 GHC.Real.numerator_entry() //  [R2]
         { info_tbl: [(c1mGP,
                       label: GHC.Real.numerator_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mGP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mGQ; else goto c1mGR;
       c1mGQ: // global
           R2 = R2;
           R1 = GHC.Real.numerator_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mGR: // global
           I64[Sp - 8] = block_c1mGM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mGV; else goto c1mGN;
       u1mGV: // global
           call _c1mGM(R1) args: 0, res: 0, upd: 0;
       c1mGN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mGM() //  [R1]
         { info_tbl: [(c1mGM,
                       label: block_c1mGM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mGM: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.168012097 UTC

[section ""data" . GHC.Real.denominator_closure" {
     GHC.Real.denominator_closure:
         const GHC.Real.denominator_info;
 },
 GHC.Real.denominator_entry() //  [R2]
         { info_tbl: [(c1mH3,
                       label: GHC.Real.denominator_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mH3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mH4; else goto c1mH5;
       c1mH4: // global
           R2 = R2;
           R1 = GHC.Real.denominator_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mH5: // global
           I64[Sp - 8] = block_c1mH0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mH9; else goto c1mH1;
       u1mH9: // global
           call _c1mH0(R1) args: 0, res: 0, upd: 0;
       c1mH1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mH0() //  [R1]
         { info_tbl: [(c1mH0,
                       label: block_c1mH0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mH0: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.169527365 UTC

[section ""data" . GHC.Real.$w$snumericEnumFrom_closure" {
     GHC.Real.$w$snumericEnumFrom_closure:
         const GHC.Real.$w$snumericEnumFrom_info;
         const 0;
 },
 section ""relreadonly" . u1mHA_srtd" {
     u1mHA_srtd:
         const S1jKw_srt+80;
         const 58;
         const 146366987889541121;
 },
 sat_s1jhu_entry() //  [R1]
         { info_tbl: [(c1mHn,
                       label: sat_s1jhu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mHn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mHo; else goto c1mHp;
       c1mHo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mHp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1mHi_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mHi() //  [R1, R2]
         { info_tbl: [(c1mHi,
                       label: block_c1mHi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mHi: // global
           I64[Sp] = block_c1mHk_info;
           R3 = R2;
           R2 = R1;
           call GHC.Real.$w$snumericEnumFrom_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mHk() //  [R1, R2]
         { info_tbl: [(c1mHk,
                       label: block_c1mHk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mHk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mHt; else goto c1mHs;
       c1mHt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1mHs: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1mHB_srtd" {
     u1mHB_srtd:
         const S1jKw_srt+80;
         const 58;
         const 146366987889541121;
 },
 GHC.Real.$w$snumericEnumFrom_entry() //  [R2, R3]
         { info_tbl: [(c1mHv,
                       label: GHC.Real.$w$snumericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mHv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1mHz; else goto c1mHy;
       c1mHz: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mHy: // global
           I64[Hp - 48] = sat_s1jhu_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.171525851 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFrom_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFrom_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFrom_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFrom_entry() //  [R2]
         { info_tbl: [(c1mHJ,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mHJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mHP; else goto c1mHQ;
       c1mHP: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mHQ: // global
           I64[Sp - 8] = block_c1mHG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mHV; else goto c1mHH;
       u1mHV: // global
           call _c1mHG(R1) args: 0, res: 0, upd: 0;
       c1mHH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mHG() //  [R1]
         { info_tbl: [(c1mHG,
                       label: block_c1mHG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mHG: // global
           I64[Sp] = block_c1mHM_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$snumericEnumFrom_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mHM() //  [R1, R2]
         { info_tbl: [(c1mHM,
                       label: block_c1mHM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mHM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mHU; else goto c1mHT;
       c1mHU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mHT: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.173583428 UTC

[section ""data" . GHC.Real.$wnumericEnumFrom_closure" {
     GHC.Real.$wnumericEnumFrom_closure:
         const GHC.Real.$wnumericEnumFrom_info;
         const 0;
 },
 sat_s1jhG_entry() //  [R1]
         { info_tbl: [(c1mIe,
                       label: sat_s1jhG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mIe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mIf; else goto c1mIg;
       c1mIf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mIg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jhL_entry() //  [R1]
         { info_tbl: [(c1mIh,
                       label: sat_s1jhL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mIh: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1mIn; else goto c1mIo;
       c1mIn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mIo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c1mI6_info;
           _s1jhC::P64 = P64[R1 + 16];
           R2 = _s1jhC::P64;
           P64[Sp - 32] = _s1jhC::P64;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mI6() //  [R1]
         { info_tbl: [(c1mI6,
                       label: block_c1mI6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mI6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mIr; else goto c1mIq;
       c1mIr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1mIq: // global
           I64[Hp - 16] = sat_s1jhG_info;
           P64[Hp] = R1;
           I64[Sp] = block_c1mIi_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call GHC.Num.+_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1mIi() //  [R1]
         { info_tbl: [(c1mIi,
                       label: block_c1mIi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mIi: // global
           I64[Sp + 16] = block_c1mIk_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mIk() //  [R1, R2]
         { info_tbl: [(c1mIk,
                       label: block_c1mIk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mIk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mIv; else goto c1mIu;
       c1mIv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1mIu: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$wnumericEnumFrom_entry() //  [R2, R3]
         { info_tbl: [(c1mIw,
                       label: GHC.Real.$wnumericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mIw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mIx; else goto c1mIy;
       c1mIx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wnumericEnumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mIy: // global
           I64[Sp - 16] = block_c1mI0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mI0() //  [R1]
         { info_tbl: [(c1mI0,
                       label: block_c1mI0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mI0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1mIB; else goto c1mIA;
       c1mIB: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mIA: // global
           I64[Hp - 24] = sat_s1jhL_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = Hp - 24;
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.176092033 UTC

[section ""data" . GHC.Real.numericEnumFrom_closure" {
     GHC.Real.numericEnumFrom_closure:
         const GHC.Real.numericEnumFrom_info;
         const 0;
 },
 GHC.Real.numericEnumFrom_entry() //  [R2, R3]
         { info_tbl: [(c1mIJ,
                       label: GHC.Real.numericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mIJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mIK; else goto c1mIL;
       c1mIK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mIL: // global
           I64[Sp - 8] = block_c1mIG_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mIG() //  [R1, R2]
         { info_tbl: [(c1mIG,
                       label: block_c1mIG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mIG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mIO; else goto c1mIN;
       c1mIO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mIN: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.17719292 UTC

[section ""data" . sat_s1jhR_closure" {
     sat_s1jhR_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.177812334 UTC

[section ""data" . sat_s1jhS_closure" {
     sat_s1jhS_closure:
         const :_con_info;
         const sat_s1jhR_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.178569351 UTC

[section ""data" . GHC.Real.even2_closure" {
     GHC.Real.even2_closure:
         const GHC.Real.even2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.even2_entry() //  [R1]
         { info_tbl: [(c1mIV,
                       label: GHC.Real.even2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mIV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mIW; else goto c1mIX;
       c1mIW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mIX: // global
           (_c1mIS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1mIS::I64 == 0) goto c1mIU; else goto c1mIT;
       c1mIU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1mIT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1mIS::I64;
           R3 = sat_s1jhS_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.179790574 UTC

[section ""data" . GHC.Real.$fEnumRatio2_closure" {
     GHC.Real.$fEnumRatio2_closure:
         const GHC.Real.$fEnumRatio2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fEnumRatio2_entry() //  [R1]
         { info_tbl: [(c1mJ7,
                       label: GHC.Real.$fEnumRatio2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mJ7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mJ8; else goto c1mJ9;
       c1mJ8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mJ9: // global
           (_c1mJ1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1mJ1::I64 == 0) goto c1mJ3; else goto c1mJ2;
       c1mJ3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1mJ2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1mJ1::I64;
           I64[Sp - 24] = block_c1mJ4_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even2_closure;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 24;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mJ4() //  [R1, R2]
         { info_tbl: [(c1mJ4,
                       label: block_c1mJ4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mJ4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mJc; else goto c1mJb;
       c1mJc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1mJb: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.182424424 UTC

[section ""data" . GHC.Real.$w$snumericEnumFromTo_closure" {
     GHC.Real.$w$snumericEnumFromTo_closure:
         const GHC.Real.$w$snumericEnumFromTo_info;
         const 0;
 },
 ds_s1ji2_entry() //  [R1]
         { info_tbl: [(c1mJr,
                       label: ds_s1ji2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mJr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1mJC; else goto c1mJD;
       c1mJC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mJD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1mJo_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1mJK; else goto c1mJp;
       u1mJK: // global
           call _c1mJo(R1) args: 0, res: 0, upd: 0;
       c1mJp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1mJo() //  [R1]
         { info_tbl: [(c1mJo,
                       label: block_c1mJo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mJo: // global
           I64[Sp - 16] = block_c1mJu_info;
           _s1ji4::P64 = P64[R1 + 7];
           _s1ji5::P64 = P64[R1 + 15];
           R1 = GHC.Real.$fEnumRatio2_closure;
           P64[Sp - 8] = _s1ji5::P64;
           P64[Sp] = _s1ji4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mJJ; else goto c1mJv;
       u1mJJ: // global
           call _c1mJu(R1) args: 0, res: 0, upd: 0;
       c1mJv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1mJu() //  [R1]
         { info_tbl: [(c1mJu,
                       label: block_c1mJu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mJu: // global
           _s1ji4::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mJz_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1ji4::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mJz() //  [R1, R2]
         { info_tbl: [(c1mJz,
                       label: block_c1mJz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mJz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mJI; else goto c1mJH;
       c1mJI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1mJH: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jid_entry() //  [R1, R2]
         { info_tbl: [(c1mJQ,
                       label: sat_s1jid_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mJQ: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call GHC.Real.$fEnumRatio_$s$c<=_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$w$snumericEnumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mJT,
                       label: GHC.Real.$w$snumericEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mJT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mJU; else goto c1mJV;
       c1mJU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mJV: // global
           I64[Sp - 16] = block_c1mJh_info;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Real.$w$snumericEnumFrom_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mJh() //  [R1, R2]
         { info_tbl: [(c1mJh,
                       label: block_c1mJh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mJh: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1mJY; else goto c1mJX;
       c1mJY: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mJX: // global
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = R1;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = ds_s1ji2_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_s1jid_info;
           P64[Hp] = Hp - 32;
           R3 = Hp - 54;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.184994591 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFromTo_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c1mK6,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mK6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mK7; else goto c1mK8;
       c1mK7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mK8: // global
           I64[Sp - 16] = block_c1mK3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mKc; else goto c1mK4;
       u1mKc: // global
           call _c1mK3(R1) args: 0, res: 0, upd: 0;
       c1mK4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mK3() //  [R1]
         { info_tbl: [(c1mK3,
                       label: block_c1mK3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mK3: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Real.$w$snumericEnumFromTo_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.188587375 UTC

[section ""data" . GHC.Real.numericEnumFromTo_closure" {
     GHC.Real.numericEnumFromTo_closure:
         const GHC.Real.numericEnumFromTo_info;
         const 0;
 },
 $dNum_s1jir_entry() //  [R1]
         { info_tbl: [(c1mKn,
                       label: $dNum_s1jir_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mKn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mKo; else goto c1mKp;
       c1mKo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mKp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jiu_entry() //  [R1]
         { info_tbl: [(c1mKD,
                       label: sat_s1jiu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mKD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mKE; else goto c1mKF;
       c1mKE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mKF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jit_entry() //  [R1]
         { info_tbl: [(c1mKK,
                       label: sat_s1jit_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mKK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mKL; else goto c1mKM;
       c1mKL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mKM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jiv_entry() //  [R1]
         { info_tbl: [(c1mKN,
                       label: sat_s1jiv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mKN: // global
           _s1jiv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1mKO; else goto c1mKP;
       c1mKP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1mKR; else goto c1mKQ;
       c1mKR: // global
           HpAlloc = 48;
           goto c1mKO;
       c1mKO: // global
           R1 = _s1jiv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mKQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jiv::P64;
           _s1jil::P64 = P64[_s1jiv::P64 + 16];
           _s1jir::P64 = P64[_s1jiv::P64 + 24];
           I64[Hp - 40] = sat_s1jiu_info;
           P64[Hp - 24] = _s1jir::P64;
           I64[Hp - 16] = sat_s1jit_info;
           P64[Hp] = _s1jir::P64;
           R2 = _s1jil::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           Sp = Sp - 40;
           call GHC.Real./_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds_s1jis_entry() //  [R1]
         { info_tbl: [(c1mKS,
                       label: ds_s1jis_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mKS: // global
           _s1jis::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1mKT; else goto c1mKU;
       c1mKU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1mKW; else goto c1mKV;
       c1mKW: // global
           HpAlloc = 32;
           goto c1mKT;
       c1mKT: // global
           R1 = _s1jis::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mKV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jis::P64;
           _s1jil::P64 = P64[_s1jis::P64 + 16];
           _s1jin::P64 = P64[_s1jis::P64 + 24];
           _s1jir::P64 = P64[_s1jis::P64 + 32];
           I64[Hp - 24] = sat_s1jiv_info;
           P64[Hp - 8] = _s1jil::P64;
           P64[Hp] = _s1jir::P64;
           R2 = _s1jir::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1jin::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jix_entry() //  [R1, R2]
         { info_tbl: [(c1mL2,
                       label: sat_s1jix_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mL2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mL3; else goto c1mL4;
       c1mL3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mL4: // global
           _s1jiw::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jiw::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Real.numericEnumFromTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1mL5,
                       label: GHC.Real.numericEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mL5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mL6; else goto c1mL7;
       c1mL6: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFromTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mL7: // global
           I64[Sp - 32] = block_c1mKh_info;
           _s1jil::P64 = R3;
           R3 = R4;
           _s1jik::P64 = R2;
           R2 = _s1jil::P64;
           P64[Sp - 24] = _s1jik::P64;
           P64[Sp - 16] = _s1jil::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mKh() //  [R1, R2]
         { info_tbl: [(c1mKh,
                       label: block_c1mKh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mKh: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1mLa; else goto c1mL9;
       c1mLa: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mL9: // global
           I64[Hp - 104] = $dNum_s1jir_info;
           _s1jil::P64 = P64[Sp + 16];
           P64[Hp - 88] = _s1jil::P64;
           I64[Hp - 80] = :_con_info;
           P64[Hp - 72] = R1;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = ds_s1jis_info;
           P64[Hp - 40] = _s1jil::P64;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = sat_s1jix_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 56;
           R3 = Hp - 78;
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.192455422 UTC

[section ""data" . GHC.Real.$w$snumericEnumFromThen_closure" {
     GHC.Real.$w$snumericEnumFromThen_closure:
         const GHC.Real.$w$snumericEnumFromThen_info;
         const 0;
 },
 sat_s1jiN_entry() //  [R1]
         { info_tbl: [(c1mLq,
                       label: sat_s1jiN_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mLq: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1mLr; else goto c1mLs;
       c1mLr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mLs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_c1mLj_info;
           _s1jiC::P64 = P64[R1 + 40];
           R5 = _s1jiC::P64;
           _s1jiB::P64 = P64[R1 + 32];
           R4 = _s1jiB::P64;
           R3 = _s1jiC::P64;
           R2 = _s1jiB::P64;
           P64[Sp - 48] = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = _s1jiB::P64;
           P64[Sp - 24] = _s1jiC::P64;
           Sp = Sp - 56;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mLj() //  [R1, R2]
         { info_tbl: [(c1mLj,
                       label: block_c1mLj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mLj: // global
           _s1jiA::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mLl_info;
           R5 = _s1jiA::P64;
           R4 = P64[Sp + 8];
           R3 = R2;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mLl() //  [R1, R2]
         { info_tbl: [(c1mLl,
                       label: block_c1mLl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mLl: // global
           _s1jiC::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mLn_info;
           R5 = R2;
           R4 = R1;
           R3 = _s1jiC::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$snumericEnumFromThen_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mLn() //  [R1, R2]
         { info_tbl: [(c1mLn,
                       label: block_c1mLn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mLn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mLx; else goto c1mLw;
       c1mLx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1mLw: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$snumericEnumFromThen_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1mLz,
                       label: GHC.Real.$w$snumericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mLz: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1mLD; else goto c1mLC;
       c1mLD: // global
           HpAlloc = 72;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFromThen_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mLC: // global
           I64[Hp - 64] = sat_s1jiN_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.194912815 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFromThen_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c1mLL,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mLL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mLW; else goto c1mLX;
       c1mLW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mLX: // global
           I64[Sp - 16] = block_c1mLI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1mM4; else goto c1mLJ;
       u1mM4: // global
           call _c1mLI(R1) args: 0, res: 0, upd: 0;
       c1mLJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mLI() //  [R1]
         { info_tbl: [(c1mLI,
                       label: block_c1mLI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mLI: // global
           I64[Sp - 8] = block_c1mLO_info;
           _s1jiR::P64 = P64[R1 + 7];
           _s1jiS::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jiS::P64;
           P64[Sp + 8] = _s1jiR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mM3; else goto c1mLP;
       u1mM3: // global
           call _c1mLO(R1) args: 0, res: 0, upd: 0;
       c1mLP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mLO() //  [R1]
         { info_tbl: [(c1mLO,
                       label: block_c1mLO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mLO: // global
           _s1jiR::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mLT_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1jiR::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$snumericEnumFromThen_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mLT() //  [R1, R2]
         { info_tbl: [(c1mLT,
                       label: block_c1mLT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mLT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mM2; else goto c1mM1;
       c1mM2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mM1: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.19733597 UTC

[section ""data" . GHC.Real.$wnumericEnumFromThen_closure" {
     GHC.Real.$wnumericEnumFromThen_closure:
         const GHC.Real.$wnumericEnumFromThen_info;
 },
 sat_s1jj5_entry() //  [R1]
         { info_tbl: [(c1mMp,
                       label: sat_s1jj5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mMp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1mMq; else goto c1mMr;
       c1mMq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mMr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jj3::P64 = P64[R1 + 16];
           P64[Sp - 32] = _s1jj3::P64;
           P64[Sp - 24] = _s1jj3::P64;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jja_entry() //  [R1]
         { info_tbl: [(c1mMs,
                       label: sat_s1jja_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mMs: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1mMy; else goto c1mMz;
       c1mMy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mMz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_c1mMh_info;
           _s1jiZ::P64 = P64[R1 + 16];
           R2 = _s1jiZ::P64;
           P64[Sp - 40] = _s1jiZ::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mMh() //  [R1]
         { info_tbl: [(c1mMh,
                       label: block_c1mMh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mMh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1mMC; else goto c1mMB;
       c1mMC: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1mMB: // global
           I64[Hp - 24] = sat_s1jj5_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           I64[Sp] = block_c1mMt_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1mMt() //  [R1]
         { info_tbl: [(c1mMt,
                       label: block_c1mMt_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mMt: // global
           _s1jj3::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1mMv_info;
           R4 = R1;
           R3 = _s1jj3::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mMv() //  [R1, R2]
         { info_tbl: [(c1mMv,
                       label: block_c1mMv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mMv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mMG; else goto c1mMF;
       c1mMG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1mMF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$wnumericEnumFromThen_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mMH,
                       label: GHC.Real.$wnumericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mMH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mMI; else goto c1mMJ;
       c1mMI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wnumericEnumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mMJ: // global
           I64[Sp - 24] = block_c1mM9_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mM9() //  [R1]
         { info_tbl: [(c1mM9,
                       label: block_c1mM9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mM9: // global
           I64[Sp] = block_c1mMb_info;
           _s1jj2::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s1jj2::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mMb() //  [R1]
         { info_tbl: [(c1mMb,
                       label: block_c1mMb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mMb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1mMN; else goto c1mMM;
       c1mMN: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mMM: // global
           I64[Hp - 32] = sat_s1jja_info;
           P64[Hp - 16] = P64[Sp + 8];
           _s1jj2::P64 = P64[Sp + 16];
           P64[Hp - 8] = _s1jj2::P64;
           P64[Hp] = R1;
           R2 = Hp - 32;
           R1 = _s1jj2::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.200036335 UTC

[section ""data" . GHC.Real.numericEnumFromThen_closure" {
     GHC.Real.numericEnumFromThen_closure:
         const GHC.Real.numericEnumFromThen_info;
 },
 GHC.Real.numericEnumFromThen_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mMV,
                       label: GHC.Real.numericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mMV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mMW; else goto c1mMX;
       c1mMW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mMX: // global
           I64[Sp - 8] = block_c1mMS_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mMS() //  [R1, R2]
         { info_tbl: [(c1mMS,
                       label: block_c1mMS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mMS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mN0; else goto c1mMZ;
       c1mN0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mMZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.203026997 UTC

[section ""data" . GHC.Real.$w$snumericEnumFromThenTo_closure" {
     GHC.Real.$w$snumericEnumFromThenTo_closure:
         const GHC.Real.$w$snumericEnumFromThenTo_info;
         const 0;
 },
 ds_s1jjq_entry() //  [R1]
         { info_tbl: [(c1mNn,
                       label: ds_s1jjq_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mNn: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1mNx; else goto c1mNy;
       c1mNx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mNy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_c1mNk_info;
           _s1jjh::P64 = P64[R1 + 16];
           _s1jji::P64 = P64[R1 + 24];
           _s1jjj::P64 = P64[R1 + 32];
           _s1jjk::P64 = P64[R1 + 40];
           R1 = P64[R1 + 48];
           P64[Sp - 48] = _s1jjh::P64;
           P64[Sp - 40] = _s1jji::P64;
           P64[Sp - 32] = _s1jjj::P64;
           P64[Sp - 24] = _s1jjk::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u1mNF; else goto c1mNl;
       u1mNF: // global
           call _c1mNk(R1) args: 0, res: 0, upd: 0;
       c1mNl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1mNk() //  [R1]
         { info_tbl: [(c1mNk,
                       label: block_c1mNk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mNk: // global
           _s1jji::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mNq_info;
           R5 = _s1jji::P64;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 15];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mNq() //  [R1, R2]
         { info_tbl: [(c1mNq,
                       label: block_c1mNq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mNq: // global
           I64[Sp] = block_c1mNs_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even2_closure;
           R3 = R2;
           R2 = R1;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mNs() //  [R1, R2]
         { info_tbl: [(c1mNs,
                       label: block_c1mNs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mNs: // global
           _s1jjs::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mNu_info;
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = _s1jjs::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mNu() //  [R1, R2]
         { info_tbl: [(c1mNu,
                       label: block_c1mNu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mNu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mNE; else goto c1mND;
       c1mNE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1mND: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jjE_entry() //  [R1, R2]
         { info_tbl: [(c1mNL,
                       label: sat_s1jjE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mNL: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call GHC.Real.$fEnumRatio_$s$c<=_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_s1jjF_entry() //  [R1]
         { info_tbl: [(c1mNX,
                       label: ds_s1jjF_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mNX: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1mO7; else goto c1mO8;
       c1mO7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mO8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_c1mNU_info;
           _s1jjh::P64 = P64[R1 + 16];
           _s1jji::P64 = P64[R1 + 24];
           _s1jjj::P64 = P64[R1 + 32];
           _s1jjk::P64 = P64[R1 + 40];
           R1 = P64[R1 + 48];
           P64[Sp - 48] = _s1jjh::P64;
           P64[Sp - 40] = _s1jji::P64;
           P64[Sp - 32] = _s1jjj::P64;
           P64[Sp - 24] = _s1jjk::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u1mOf; else goto c1mNV;
       u1mOf: // global
           call _c1mNU(R1) args: 0, res: 0, upd: 0;
       c1mNV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1mNU() //  [R1]
         { info_tbl: [(c1mNU,
                       label: block_c1mNU_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mNU: // global
           _s1jji::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mO0_info;
           R5 = _s1jji::P64;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 15];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mO0() //  [R1, R2]
         { info_tbl: [(c1mO0,
                       label: block_c1mO0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mO0: // global
           I64[Sp] = block_c1mO2_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even2_closure;
           R3 = R2;
           R2 = R1;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mO2() //  [R1, R2]
         { info_tbl: [(c1mO2,
                       label: block_c1mO2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mO2: // global
           _s1jjH::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mO4_info;
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = _s1jjH::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mO4() //  [R1, R2]
         { info_tbl: [(c1mO4,
                       label: block_c1mO4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mO4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mOe; else goto c1mOd;
       c1mOe: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1mOd: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jjT_entry() //  [R1, R2]
         { info_tbl: [(c1mOl,
                       label: sat_s1jjT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mOl: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call GHC.Real.$fEnumRatio_$s$c>=_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1mOH_srtd" {
     u1mOH_srtd:
         const S1jKw_srt+24;
         const 79;
         const 4935945191598063617;
         const 16708;
 },
 sat_s1jjU_entry() //  [R1]
         { info_tbl: [(c1mOs,
                       label: sat_s1jjU_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mOs: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1mOt; else goto c1mOu;
       c1mOt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mOu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c1mNc_info;
           _s1jji::P64 = P64[R1 + 24];
           R5 = _s1jji::P64;
           _s1jjh::P64 = P64[R1 + 16];
           R4 = _s1jjh::P64;
           _s1jjk::P64 = P64[R1 + 40];
           R3 = _s1jjk::P64;
           _s1jjj::P64 = P64[R1 + 32];
           R2 = _s1jjj::P64;
           P64[Sp - 56] = _s1jjh::P64;
           P64[Sp - 48] = _s1jji::P64;
           P64[Sp - 40] = _s1jjj::P64;
           P64[Sp - 32] = _s1jjk::P64;
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 64;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mNc() //  [R1]
         { info_tbl: [(c1mNc,
                       label: block_c1mNc_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mNc: // global
           _s1jjh::P64 = P64[Sp + 8];
           _s1jji::P64 = P64[Sp + 16];
           _s1jjj::P64 = P64[Sp + 24];
           _s1jjk::P64 = P64[Sp + 32];
           _s1jjl::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c1mOq; else goto c1mOp;
       c1mOq: // global
           Hp = Hp + 72;
           _s1jjp::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1mOA; else goto c1mOz;
       c1mOz: // global
           I64[Hp - 64] = ds_s1jjF_info;
           P64[Hp - 48] = _s1jjh::P64;
           P64[Hp - 40] = _s1jji::P64;
           P64[Hp - 32] = _s1jjj::P64;
           P64[Hp - 24] = _s1jjk::P64;
           P64[Hp - 16] = _s1jjl::P64;
           I64[Hp - 8] = sat_s1jjT_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c1mOp: // global
           Hp = Hp + 72;
           _s1jjp::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1mOA; else goto c1mOw;
       c1mOA: // global
           HpAlloc = 72;
           R1 = _s1jjp::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1mOw: // global
           I64[Hp - 64] = ds_s1jjq_info;
           P64[Hp - 48] = _s1jjh::P64;
           P64[Hp - 40] = _s1jji::P64;
           P64[Hp - 32] = _s1jjj::P64;
           P64[Hp - 24] = _s1jjk::P64;
           P64[Hp - 16] = _s1jjl::P64;
           I64[Hp - 8] = sat_s1jjE_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1mOI_srtd" {
     u1mOI_srtd:
         const S1jKw_srt+24;
         const 80;
         const 4935945191598063617;
         const 53572;
 },
 GHC.Real.$w$snumericEnumFromThenTo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1mOB,
                       label: GHC.Real.$w$snumericEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mOB: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1mOC; else goto c1mOD;
       c1mOC: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFromThenTo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mOD: // global
           I64[Sp - 48] = block_c1mN5_info;
           _s1jjk::P64 = R5;
           R5 = R5;
           _s1jjj::P64 = R4;
           R4 = R4;
           _s1jji::P64 = R3;
           R3 = R3;
           _s1jjh::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = _s1jjh::P64;
           P64[Sp - 32] = _s1jji::P64;
           P64[Sp - 24] = _s1jjj::P64;
           P64[Sp - 16] = _s1jjk::P64;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$w$snumericEnumFromThen_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1mOJ_srtd" {
     u1mOJ_srtd:
         const S1jKw_srt+24;
         const 79;
         const 4935945191598063617;
         const 16708;
 },
 _c1mN5() //  [R1, R2]
         { info_tbl: [(c1mN5,
                       label: block_c1mN5_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mN5: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1mOG; else goto c1mOF;
       c1mOG: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mOF: // global
           I64[Hp - 72] = :_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s1jjU_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R3 = Hp - 70;
           R2 = Hp - 48;
           Sp = Sp + 48;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.20870738 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c1mOR,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mOR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mOV; else goto c1mOW;
       c1mOV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mOW: // global
           I64[Sp - 24] = block_c1mOO_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1mP4; else goto c1mOP;
       u1mP4: // global
           call _c1mOO(R1) args: 0, res: 0, upd: 0;
       c1mOP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mOO() //  [R1]
         { info_tbl: [(c1mOO,
                       label: block_c1mOO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mOO: // global
           I64[Sp - 8] = block_c1mOU_info;
           _s1jk0::P64 = P64[R1 + 7];
           _s1jk1::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jk1::P64;
           P64[Sp + 8] = _s1jk0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1mP3; else goto c1mOY;
       u1mP3: // global
           call _c1mOU(R1) args: 0, res: 0, upd: 0;
       c1mOY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mOU() //  [R1]
         { info_tbl: [(c1mOU,
                       label: block_c1mOU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mOU: // global
           R6 = P64[Sp + 24];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$snumericEnumFromThenTo_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.21202288 UTC

[section ""data" . GHC.Real.numericEnumFromThenTo_closure" {
     GHC.Real.numericEnumFromThenTo_closure:
         const GHC.Real.numericEnumFromThenTo_info;
         const 0;
 },
 $dNum_s1jkd_entry() //  [R1]
         { info_tbl: [(c1mPk,
                       label: $dNum_s1jkd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mPk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mPl; else goto c1mPm;
       c1mPl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mPm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jkg_entry() //  [R1]
         { info_tbl: [(c1mPv,
                       label: sat_s1jkg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mPv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mPw; else goto c1mPx;
       c1mPw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mPx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jkf_entry() //  [R1]
         { info_tbl: [(c1mPC,
                       label: sat_s1jkf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mPC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1mPD; else goto c1mPE;
       c1mPD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mPE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 mid_s1jke_entry() //  [R1]
         { info_tbl: [(c1mPF,
                       label: mid_s1jke_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mPF: // global
           _s1jke::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1mPG; else goto c1mPH;
       c1mPH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1mPJ; else goto c1mPI;
       c1mPJ: // global
           HpAlloc = 64;
           goto c1mPG;
       c1mPG: // global
           R1 = _s1jke::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mPI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jke::P64;
           _s1jk6::P64 = P64[_s1jke::P64 + 16];
           _s1jk7::P64 = P64[_s1jke::P64 + 24];
           _s1jk8::P64 = P64[_s1jke::P64 + 32];
           _s1jkd::P64 = P64[_s1jke::P64 + 40];
           I64[Hp - 56] = sat_s1jkg_info;
           P64[Hp - 40] = _s1jkd::P64;
           I64[Hp - 32] = sat_s1jkf_info;
           P64[Hp - 16] = _s1jk7::P64;
           P64[Hp - 8] = _s1jk8::P64;
           P64[Hp] = _s1jkd::P64;
           R2 = _s1jk6::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Real./_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds_s1jki_entry() //  [R1]
         { info_tbl: [(c1mPS,
                       label: ds_s1jki_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mPS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1mPT; else goto c1mPU;
       c1mPT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mPU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jkk_entry() //  [R1, R2]
         { info_tbl: [(c1mQ0,
                       label: sat_s1jkk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mQ0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mQ1; else goto c1mQ2;
       c1mQ1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mQ2: // global
           _s1jkj::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jkj::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 ds_s1jkl_entry() //  [R1]
         { info_tbl: [(c1mQ9,
                       label: ds_s1jkl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mQ9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1mQa; else goto c1mQb;
       c1mQa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mQb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jkn_entry() //  [R1, R2]
         { info_tbl: [(c1mQh,
                       label: sat_s1jkn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mQh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mQi; else goto c1mQj;
       c1mQi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mQj: // global
           _s1jkm::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jkm::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s1jko_entry() //  [R1]
         { info_tbl: [(c1mQo,
                       label: sat_s1jko_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mQo: // global
           _s1jko::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto c1mQp; else goto c1mQq;
       c1mQq: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1mQs; else goto c1mQr;
       c1mQs: // global
           HpAlloc = 72;
           goto c1mQp;
       c1mQp: // global
           R1 = _s1jko::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mQr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jko::P64;
           _s1jk5::P64 = P64[_s1jko::P64 + 16];
           _s1jk6::P64 = P64[_s1jko::P64 + 24];
           _s1jk7::P64 = P64[_s1jko::P64 + 32];
           _s1jk8::P64 = P64[_s1jko::P64 + 40];
           _s1jk9::P64 = P64[_s1jko::P64 + 48];
           I64[Hp - 64] = $dNum_s1jkd_info;
           P64[Hp - 48] = _s1jk6::P64;
           I64[Hp - 40] = mid_s1jke_info;
           P64[Hp - 24] = _s1jk6::P64;
           P64[Hp - 16] = _s1jk7::P64;
           P64[Hp - 8] = _s1jk8::P64;
           _c1mPg::P64 = Hp - 64;
           P64[Hp] = _c1mPg::P64;
           I64[Sp - 56] = block_c1mPK_info;
           R2 = _s1jk5::P64;
           I64[Sp - 80] = stg_ap_pp_info;
           P64[Sp - 72] = _s1jk8::P64;
           P64[Sp - 64] = _s1jk7::P64;
           P64[Sp - 48] = _c1mPg::P64;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = _s1jk5::P64;
           P64[Sp - 24] = _s1jk9::P64;
           Sp = Sp - 80;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1mPK() //  [R1]
         { info_tbl: [(c1mPK,
                       label: block_c1mPK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mPK: // global
           _c1mPg::P64 = P64[Sp + 8];
           _c1mPn::P64 = P64[Sp + 16];
           _s1jk5::P64 = P64[Sp + 24];
           _s1jk9::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c1mQl; else goto c1mQm;
       c1mQl: // global
           Hp = Hp + 64;
           _s1jkh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1mQy; else goto c1mQu;
       c1mQu: // global
           I64[Hp - 56] = ds_s1jki_info;
           P64[Hp - 40] = _s1jk9::P64;
           P64[Hp - 32] = _c1mPg::P64;
           P64[Hp - 24] = _c1mPn::P64;
           I64[Hp - 16] = sat_s1jkk_info;
           P64[Hp - 8] = _s1jk5::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c1mQm: // global
           Hp = Hp + 64;
           _s1jkh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1mQy; else goto c1mQx;
       c1mQy: // global
           HpAlloc = 64;
           R1 = _s1jkh::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1mQx: // global
           I64[Hp - 56] = ds_s1jkl_info;
           P64[Hp - 40] = _s1jk9::P64;
           P64[Hp - 32] = _c1mPg::P64;
           P64[Hp - 24] = _c1mPn::P64;
           I64[Hp - 16] = sat_s1jkn_info;
           P64[Hp - 8] = _s1jk5::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.numericEnumFromThenTo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1mQz,
                       label: GHC.Real.numericEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mQz: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1mQA; else goto c1mQB;
       c1mQA: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFromThenTo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mQB: // global
           I64[Sp - 48] = block_c1mP9_info;
           _s1jk7::P64 = R4;
           R4 = R5;
           _s1jk6::P64 = R3;
           R3 = _s1jk7::P64;
           _s1jk5::P64 = R2;
           R2 = _s1jk6::P64;
           P64[Sp - 40] = _s1jk5::P64;
           P64[Sp - 32] = _s1jk6::P64;
           P64[Sp - 24] = _s1jk7::P64;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mP9() //  [R1, R2]
         { info_tbl: [(c1mP9,
                       label: block_c1mP9_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mP9: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1mQE; else goto c1mQD;
       c1mQE: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1mQD: // global
           I64[Hp - 72] = :_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s1jko_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R3 = Hp - 70;
           R2 = Hp - 48;
           Sp = Sp + 48;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.217162528 UTC

[section ""data" . GHC.Real.fromIntegral_closure" {
     GHC.Real.fromIntegral_closure:
         const GHC.Real.fromIntegral_info;
 },
 sat_s1jkt_entry() //  [R1]
         { info_tbl: [(c1mQN,
                       label: sat_s1jkt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mQN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mQO; else goto c1mQP;
       c1mQO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mQP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.fromIntegral_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mQQ,
                       label: GHC.Real.fromIntegral_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mQQ: // global
           _s1jks::P64 = R4;
           _s1jkr::P64 = R3;
           _s1jkq::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c1mQR; else goto c1mQS;
       c1mQS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1mQU; else goto c1mQT;
       c1mQU: // global
           HpAlloc = 32;
           goto c1mQR;
       c1mQR: // global
           R4 = _s1jks::P64;
           R3 = _s1jkr::P64;
           R2 = _s1jkq::P64;
           R1 = GHC.Real.fromIntegral_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mQT: // global
           I64[Hp - 24] = sat_s1jkt_info;
           P64[Hp - 8] = _s1jkq::P64;
           P64[Hp] = _s1jks::P64;
           R2 = _s1jkr::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.21881822 UTC

[section ""data" . GHC.Real.realToFrac_closure" {
     GHC.Real.realToFrac_closure:
         const GHC.Real.realToFrac_info;
 },
 sat_s1jkx_entry() //  [R1]
         { info_tbl: [(c1mR3,
                       label: sat_s1jkx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mR3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mR4; else goto c1mR5;
       c1mR4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mR5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.realToFrac_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mR6,
                       label: GHC.Real.realToFrac_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mR6: // global
           _s1jkw::P64 = R4;
           _s1jkv::P64 = R3;
           _s1jku::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c1mR7; else goto c1mR8;
       c1mR8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1mRa; else goto c1mR9;
       c1mRa: // global
           HpAlloc = 32;
           goto c1mR7;
       c1mR7: // global
           R4 = _s1jkw::P64;
           R3 = _s1jkv::P64;
           R2 = _s1jku::P64;
           R1 = GHC.Real.realToFrac_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mR9: // global
           I64[Hp - 24] = sat_s1jkx_info;
           P64[Hp - 8] = _s1jku::P64;
           P64[Hp] = _s1jkw::P64;
           R2 = _s1jkv::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Real.fromRational_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.221650172 UTC

[section ""data" . GHC.Real.showSigned1_closure" {
     GHC.Real.showSigned1_closure:
         const GHC.Types.C#_con_info;
         const 45;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.223883912 UTC

[section ""data" . GHC.Real.showSigned_closure" {
     GHC.Real.showSigned_closure:
         const GHC.Real.showSigned_info;
         const 0;
 },
 $dNum_s1jkC_entry() //  [R1]
         { info_tbl: [(c1mRj,
                       label: $dNum_s1jkC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mRj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mRk; else goto c1mRl;
       c1mRk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mRl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jkE_entry() //  [R1]
         { info_tbl: [(c1mRq,
                       label: sat_s1jkE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mRq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mRr; else goto c1mRs;
       c1mRr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mRs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jkJ_entry() //  [R1]
         { info_tbl: [(c1mRP,
                       label: sat_s1jkJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mRP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mRQ; else goto c1mRR;
       c1mRQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mRR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 g1_s1jkI_entry() //  [R1]
         { info_tbl: [(c1mRS,
                       label: g1_s1jkI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mRS: // global
           _s1jkI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1mRT; else goto c1mRU;
       c1mRU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1mRW; else goto c1mRV;
       c1mRW: // global
           HpAlloc = 32;
           goto c1mRT;
       c1mRT: // global
           R1 = _s1jkI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mRV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jkI::P64;
           _s1jkz::P64 = P64[_s1jkI::P64 + 16];
           _s1jkB::P64 = P64[_s1jkI::P64 + 24];
           _s1jkC::P64 = P64[_s1jkI::P64 + 32];
           I64[Hp - 24] = sat_s1jkJ_info;
           P64[Hp - 8] = _s1jkB::P64;
           P64[Hp] = _s1jkC::P64;
           R2 = Hp - 24;
           R1 = _s1jkz::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jkN_entry() //  [R1, R2]
         { info_tbl: [(c1mS7,
                       label: sat_s1jkN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mS7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1mSb; else goto c1mSa;
       c1mSb: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mSa: // global
           _s1jkI::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _s1jkI::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Real.showSigned1_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jkQ_entry() //  [R1]
         { info_tbl: [(c1mSn,
                       label: sat_s1jkQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mSn: // global
           _s1jkQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1mSo; else goto c1mSp;
       c1mSp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mSr; else goto c1mSq;
       c1mSr: // global
           HpAlloc = 24;
           goto c1mSo;
       c1mSo: // global
           R1 = _s1jkQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mSq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jkQ::P64;
           _s1jkI::P64 = P64[_s1jkQ::P64 + 16];
           _s1jkO::P64 = P64[_s1jkQ::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s1jkO::P64;
           R2 = Hp - 14;
           R1 = _s1jkI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jkS_entry() //  [R1, R2]
         { info_tbl: [(c1mSu,
                       label: sat_s1jkS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mSu: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1mSy; else goto c1mSx;
       c1mSy: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mSx: // global
           _s1jkI::P64 = P64[R1 + 7];
           I64[Hp - 72] = sat_s1jkQ_info;
           P64[Hp - 56] = _s1jkI::P64;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = GHC.Real.showSigned1_closure+1;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.showSigned_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1mSz,
                       label: GHC.Real.showSigned_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mSz: // global
           _s1jkB::P64 = R5;
           _s1jkA::P64 = R4;
           _s1jkz::P64 = R3;
           _s1jky::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto c1mSA; else goto c1mSB;
       c1mSB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1mSD; else goto c1mSC;
       c1mSD: // global
           HpAlloc = 48;
           goto c1mSA;
       c1mSA: // global
           R5 = _s1jkB::P64;
           R4 = _s1jkA::P64;
           R3 = _s1jkz::P64;
           R2 = _s1jky::P64;
           R1 = GHC.Real.showSigned_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mSC: // global
           I64[Hp - 40] = $dNum_s1jkC_info;
           P64[Hp - 24] = _s1jky::P64;
           I64[Hp - 16] = sat_s1jkE_info;
           _c1mRf::P64 = Hp - 40;
           P64[Hp] = _c1mRf::P64;
           I64[Sp - 48] = block_c1mRt_info;
           R2 = _s1jky::P64;
           P64[Sp - 40] = _c1mRf::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _s1jkz::P64;
           P64[Sp - 16] = _s1jkA::P64;
           P64[Sp - 8] = _s1jkB::P64;
           Sp = Sp - 48;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mRt() //  [R1]
         { info_tbl: [(c1mRt,
                       label: block_c1mRt_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mRt: // global
           I64[Sp] = block_c1mRx_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1mRx() //  [R1]
         { info_tbl: [(c1mRx,
                       label: block_c1mRx_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mRx: // global
           if (R1 & 7 == 1) goto c1mSI; else goto c1mSK;
       c1mSI: // global
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 24];
           Sp = Sp + 48;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       c1mSK: // global
           I64[Sp] = block_c1mRC_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1mSS; else goto c1mRD;
       u1mSS: // global
           call _c1mRC(R1) args: 0, res: 0, upd: 0;
       c1mRD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1mRC() //  [R1]
         { info_tbl: [(c1mRC,
                       label: block_c1mRC_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mRC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1mSN; else goto c1mSM;
       c1mSN: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mSM: // global
           _s1jkH::I64 = I64[R1 + 7];
           I64[Hp - 48] = g1_s1jkI_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = P64[Sp + 8];
           _c1mRH::P64 = Hp - 48;
           if (%MO_S_Le_W64(_s1jkH::I64, 6)) goto c1mSP; else goto c1mSQ;
       c1mSP: // global
           I64[Hp - 8] = sat_s1jkN_info;
           P64[Hp] = _c1mRH::P64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mSQ: // global
           I64[Hp - 8] = sat_s1jkS_info;
           P64[Hp] = _c1mRH::P64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.22868581 UTC

[section ""data" . GHC.Real.even_closure" {
     GHC.Real.even_closure:
         const GHC.Real.even_info;
         const 0;
 },
 $dNum_s1jkW_entry() //  [R1]
         { info_tbl: [(c1mT5,
                       label: $dNum_s1jkW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mT5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mT6; else goto c1mT7;
       c1mT6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mT7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jl1_entry() //  [R1]
         { info_tbl: [(c1mTc,
                       label: sat_s1jl1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mTc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mTd; else goto c1mTe;
       c1mTd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mTe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jkZ_entry() //  [R1]
         { info_tbl: [(c1mTn,
                       label: sat_s1jkZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mTn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mTo; else goto c1mTp;
       c1mTo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mTp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jl0_entry() //  [R1]
         { info_tbl: [(c1mTq,
                       label: sat_s1jl0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mTq: // global
           _s1jl0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1mTr; else goto c1mTs;
       c1mTs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mTu; else goto c1mTt;
       c1mTu: // global
           HpAlloc = 24;
           goto c1mTr;
       c1mTr: // global
           R1 = _s1jl0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mTt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jl0::P64;
           _s1jkT::P64 = P64[_s1jl0::P64 + 16];
           _s1jkU::P64 = P64[_s1jl0::P64 + 24];
           _s1jkW::P64 = P64[_s1jl0::P64 + 32];
           I64[Hp - 16] = sat_s1jkZ_info;
           P64[Hp] = _s1jkW::P64;
           R2 = _s1jkT::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1jkU::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Real.rem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.even_entry() //  [R2, R3]
         { info_tbl: [(c1mTv,
                       label: GHC.Real.even_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mTv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mTB; else goto c1mTC;
       c1mTB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.even_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mTC: // global
           I64[Sp - 24] = block_c1mSX_info;
           _s1jkT::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1jkT::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mSX() //  [R1]
         { info_tbl: [(c1mSX,
                       label: block_c1mSX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mSX: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1mTF; else goto c1mTE;
       c1mTF: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mTE: // global
           I64[Hp - 80] = $dNum_s1jkW_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_s1jl1_info;
           _c1mT1::P64 = Hp - 80;
           P64[Hp - 40] = _c1mT1::P64;
           I64[Hp - 32] = sat_s1jl0_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _c1mT1::P64;
           I64[Sp] = block_c1mTw_info;
           R2 = R1;
           P64[Sp + 8] = Hp - 32;
           P64[Sp + 16] = Hp - 56;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mTw() //  [R1]
         { info_tbl: [(c1mTw,
                       label: block_c1mTw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mTw: // global
           I64[Sp] = block_c1mTA_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mTA() //  [R1]
         { info_tbl: [(c1mTA,
                       label: block_c1mTA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mTA: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.231445217 UTC

[section ""data" . GHC.Real.odd_closure" {
     GHC.Real.odd_closure:
         const GHC.Real.odd_info;
         const 0;
 },
 GHC.Real.odd_entry() //  [R2, R3]
         { info_tbl: [(c1mTV,
                       label: GHC.Real.odd_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mTV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1mTW; else goto c1mTX;
       c1mTW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.odd_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mTX: // global
           I64[Sp - 8] = block_c1mTP_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mTP() //  [R1]
         { info_tbl: [(c1mTP,
                       label: block_c1mTP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mTP: // global
           if (R1 & 7 == 1) goto c1mTS; else goto c1mTT;
       c1mTS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mTT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.232461709 UTC

[section ""data" . lvl3_r1j3b_closure" {
     lvl3_r1j3b_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.even2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.233045184 UTC

[section ""cstring" . lvl4_r1j3c_bytes" {
     lvl4_r1j3c_bytes:
         I8[] [114,111,117,110,100,32,100,101,102,97,117,108,116,32,100,101,102,110,58,32,66,97,100,32,118,97,108,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.233916916 UTC

[section ""data" . GHC.Real.$fRealFracRatio1_closure" {
     GHC.Real.$fRealFracRatio1_closure:
         const GHC.Real.$fRealFracRatio1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fRealFracRatio1_entry() //  [R1]
         { info_tbl: [(c1mUc,
                       label: GHC.Real.$fRealFracRatio1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mUc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1mUd; else goto c1mUe;
       c1mUd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mUe: // global
           (_c1mU7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1mU7::I64 == 0) goto c1mU9; else goto c1mU8;
       c1mU9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1mU8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1mU7::I64;
           I64[Sp - 24] = block_c1mUa_info;
           R2 = lvl4_r1j3c_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mUa() //  [R1]
         { info_tbl: [(c1mUa,
                       label: block_c1mUa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mUa: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.238192812 UTC

[section ""data" . GHC.Real.$dmround_closure" {
     GHC.Real.$dmround_closure:
         const GHC.Real.$dmround_info;
         const 0;
 },
 ds_s1jl9_entry() //  [R1]
         { info_tbl: [(c1mUq,
                       label: ds_s1jl9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mUq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1mUr; else goto c1mUs;
       c1mUr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mUs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.properFraction_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $dNum_s1jld_entry() //  [R1]
         { info_tbl: [(c1mUJ,
                       label: $dNum_s1jld_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mUJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mUK; else goto c1mUL;
       c1mUK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mUL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jll_entry() //  [R1]
         { info_tbl: [(c1mV1,
                       label: sat_s1jll_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mV1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mV2; else goto c1mV3;
       c1mV2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mV3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1mUZ_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p2RealFrac_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mUZ() //  [R1]
         { info_tbl: [(c1mUZ,
                       label: block_c1mUZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mUZ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = lvl3_r1j3b_closure+1;
           Sp = Sp - 8;
           call GHC.Real.fromRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlj_entry() //  [R1]
         { info_tbl: [(c1mVb,
                       label: sat_s1jlj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mVb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mVc; else goto c1mVd;
       c1mVc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mVd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlm_entry() //  [R1]
         { info_tbl: [(c1mVe,
                       label: sat_s1jlm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mVe: // global
           _s1jlm::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1mVf; else goto c1mVg;
       c1mVg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1mVi; else goto c1mVh;
       c1mVi: // global
           HpAlloc = 56;
           goto c1mVf;
       c1mVf: // global
           R1 = _s1jlm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mVh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jlm::P64;
           _s1jl6::P64 = P64[_s1jlm::P64 + 16];
           _s1jld::P64 = P64[_s1jlm::P64 + 24];
           _s1jle::P64 = P64[_s1jlm::P64 + 32];
           I64[Hp - 48] = sat_s1jll_info;
           P64[Hp - 32] = _s1jl6::P64;
           I64[Hp - 24] = sat_s1jlj_info;
           P64[Hp - 8] = _s1jld::P64;
           P64[Hp] = _s1jle::P64;
           R2 = _s1jld::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds1_s1jli_entry() //  [R1]
         { info_tbl: [(c1mVj,
                       label: ds1_s1jli_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mVj: // global
           _s1jli::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1mVk; else goto c1mVl;
       c1mVl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1mVn; else goto c1mVm;
       c1mVn: // global
           HpAlloc = 40;
           goto c1mVk;
       c1mVk: // global
           R1 = _s1jli::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mVm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jli::P64;
           _s1jl6::P64 = P64[_s1jli::P64 + 16];
           _s1jld::P64 = P64[_s1jli::P64 + 24];
           _s1jle::P64 = P64[_s1jli::P64 + 32];
           I64[Hp - 32] = sat_s1jlm_info;
           P64[Hp - 16] = _s1jl6::P64;
           P64[Hp - 8] = _s1jld::P64;
           P64[Hp] = _s1jle::P64;
           R2 = _s1jld::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlr_entry() //  [R1]
         { info_tbl: [(c1mVx,
                       label: sat_s1jlr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mVx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mVy; else goto c1mVz;
       c1mVy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mVz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jls_entry() //  [R1]
         { info_tbl: [(c1mVA,
                       label: sat_s1jls_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mVA: // global
           _s1jls::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1mVB; else goto c1mVC;
       c1mVC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mVE; else goto c1mVD;
       c1mVE: // global
           HpAlloc = 24;
           goto c1mVB;
       c1mVB: // global
           R1 = _s1jls::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mVD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jls::P64;
           _s1jld::P64 = P64[_s1jls::P64 + 16];
           I64[Hp - 16] = sat_s1jlr_info;
           P64[Hp] = _s1jld::P64;
           R2 = _s1jld::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlB_entry() //  [R1]
         { info_tbl: [(c1mVN,
                       label: sat_s1jlB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mVN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mVO; else goto c1mVP;
       c1mVO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mVP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlx_entry() //  [R1]
         { info_tbl: [(c1mW7,
                       label: sat_s1jlx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mW7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mW8; else goto c1mW9;
       c1mW8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mW9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlz_entry() //  [R1]
         { info_tbl: [(c1mWi,
                       label: sat_s1jlz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mWi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mWj; else goto c1mWk;
       c1mWj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mWk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlA_entry() //  [R1]
         { info_tbl: [(c1mWr,
                       label: sat_s1jlA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mWr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mWs; else goto c1mWt;
       c1mWs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mWt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlD_entry() //  [R1]
         { info_tbl: [(c1mWC,
                       label: sat_s1jlD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mWC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mWD; else goto c1mWE;
       c1mWD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mWE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmround_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mWF,
                       label: GHC.Real.$dmround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mWF: // global
           _s1jl8::P64 = R4;
           _s1jl7::P64 = R3;
           _s1jl6::P64 = R2;
           if ((Sp + -88) < SpLim) (likely: False) goto c1mWG; else goto c1mWH;
       c1mWH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1mWJ; else goto c1mWI;
       c1mWJ: // global
           HpAlloc = 40;
           goto c1mWG;
       c1mWG: // global
           R4 = _s1jl8::P64;
           R3 = _s1jl7::P64;
           R2 = _s1jl6::P64;
           R1 = GHC.Real.$dmround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mWI: // global
           I64[Hp - 32] = ds_s1jl9_info;
           P64[Hp - 16] = _s1jl6::P64;
           P64[Hp - 8] = _s1jl7::P64;
           P64[Hp] = _s1jl8::P64;
           I64[Sp - 32] = block_c1mUt_info;
           R2 = _s1jl6::P64;
           P64[Sp - 24] = Hp - 32;
           P64[Sp - 16] = _s1jl6::P64;
           P64[Sp - 8] = _s1jl7::P64;
           Sp = Sp - 32;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mUt() //  [R1]
         { info_tbl: [(c1mUt,
                       label: block_c1mUt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mUt: // global
           I64[Sp - 8] = block_c1mUx_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mUx() //  [R1]
         { info_tbl: [(c1mUx,
                       label: block_c1mUx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mUx: // global
           I64[Sp - 8] = block_c1mUB_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mUB() //  [R1]
         { info_tbl: [(c1mUB,
                       label: block_c1mUB_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mUB: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c1mWO; else goto c1mWN;
       c1mWO: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mWN: // global
           I64[Hp - 128] = $dNum_s1jld_info;
           P64[Hp - 112] = P64[Sp + 16];
           I64[Hp - 104] = stg_sel_1_upd_info;
           _c1mUm::P64 = P64[Sp + 24];
           P64[Hp - 88] = _c1mUm::P64;
           I64[Hp - 80] = ds1_s1jli_info;
           P64[Hp - 64] = P64[Sp + 32];
           _c1mUF::P64 = Hp - 128;
           P64[Hp - 56] = _c1mUF::P64;
           _c1mUM::P64 = Hp - 104;
           P64[Hp - 48] = _c1mUM::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1mUm::P64;
           I64[Hp - 16] = sat_s1jls_info;
           P64[Hp] = _c1mUF::P64;
           I64[Sp - 16] = block_c1mVF_info;
           R2 = R1;
           I64[Sp - 40] = stg_ap_pp_info;
           _c1mUN::P64 = Hp - 80;
           P64[Sp - 32] = _c1mUN::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 40;
           P64[Sp + 16] = _c1mUN::P64;
           P64[Sp + 24] = _c1mUM::P64;
           P64[Sp + 32] = _c1mUF::P64;
           Sp = Sp - 40;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1mVF() //  [R1]
         { info_tbl: [(c1mVF,
                       label: block_c1mVF_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mVF: // global
           if (R1 & 7 == 1) goto c1mWQ; else goto u1mXM;
       c1mWQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mWT; else goto c1mWS;
       c1mWT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mWS: // global
           I64[Hp - 16] = sat_s1jlB_info;
           P64[Hp] = P64[Sp + 48];
           I64[Sp] = block_c1mWu_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       u1mXM: // global
           Sp = Sp + 16;
           call _c1mXG() args: 0, res: 0, upd: 0;
     }
 },
 _c1mWu() //  [R1]
         { info_tbl: [(c1mWu,
                       label: block_c1mWu_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mWu: // global
           if (R1 & 7 == 1) goto c1mXa; else goto c1mXs;
       c1mXa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mXd; else goto c1mXc;
       c1mXd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mXc: // global
           I64[Hp - 16] = sat_s1jlD_info;
           P64[Hp] = P64[Sp + 48];
           _s1jlc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1mX8_info;
           R2 = _s1jlc::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c1mXs: // global
           I64[Sp + 8] = block_c1mXq_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 56];
           Sp = Sp + 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mX8() //  [R1]
         { info_tbl: [(c1mX8,
                       label: block_c1mX8_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mX8: // global
           if (R1 & 7 == 1) goto c1mXj; else goto u1mXP;
       c1mXj: // global
           R1 = GHC.Real.$fRealFracRatio1_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       u1mXP: // global
           Sp = Sp + 8;
           call _s1jlu() args: 0, res: 0, upd: 0;
     }
 },
 _c1mXq() //  [R1]
         { info_tbl: [(c1mXq,
                       label: block_c1mXq_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mXq: // global
           if (R1 & 7 == 1) goto u1mXN; else goto u1mXO;
       u1mXN: // global
           Sp = Sp + 8;
           call _s1jlu() args: 0, res: 0, upd: 0;
       u1mXO: // global
           Sp = Sp + 8;
           call _c1mXG() args: 0, res: 0, upd: 0;
     }
 },
 _s1jlu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jlu: // global
           I64[Sp - 8] = block_c1mVV_info;
           R2 = P64[Sp + 40];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mVV() //  [R1]
         { info_tbl: [(c1mVV,
                       label: block_c1mVV_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mVV: // global
           I64[Sp] = block_c1mVZ_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mVZ() //  [R1]
         { info_tbl: [(c1mVZ,
                       label: block_c1mVZ_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mVZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mWY; else goto c1mWX;
       c1mWY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mWX: // global
           I64[Hp - 16] = sat_s1jlx_info;
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_c1mWa_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 48] = R1;
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1mWa() //  [R1]
         { info_tbl: [(c1mWa,
                       label: block_c1mWa_info
                       rep:StackRep [False, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mWa: // global
           _c1mVo::P64 = P64[Sp + 8];
           _s1jlw::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto c1mX0; else goto c1mX4;
       c1mX0: // global
           Hp = Hp + 24;
           _s1jly::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1mX7; else goto c1mX2;
       c1mX2: // global
           I64[Hp - 16] = sat_s1jlz_info;
           P64[Hp] = _s1jlw::P64;
           R2 = _s1jlw::P64;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = _c1mVo::P64;
           P64[Sp + 48] = Hp - 16;
           Sp = Sp + 32;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
       c1mX4: // global
           Hp = Hp + 24;
           _s1jly::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1mX7; else goto c1mX6;
       c1mX7: // global
           HpAlloc = 24;
           R1 = _s1jly::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mX6: // global
           I64[Hp - 16] = sat_s1jlA_info;
           P64[Hp] = _s1jlw::P64;
           R2 = _s1jlw::P64;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = _c1mVo::P64;
           P64[Sp + 48] = Hp - 16;
           Sp = Sp + 32;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _c1mXG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mXG: // global
           R1 = P64[Sp];
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.247234149 UTC

[section ""data" . GHC.Real.integralEnumFrom_closure" {
     GHC.Real.integralEnumFrom_closure:
         const GHC.Real.integralEnumFrom_info;
         const 0;
 },
 f_s1jlJ_entry() //  [R1]
         { info_tbl: [(c1mY2,
                       label: f_s1jlJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mY2: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jlK_entry() //  [R1]
         { info_tbl: [(c1mY9,
                       label: f1_s1jlK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mY9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mYa; else goto c1mYb;
       c1mYa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mYb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jlM_entry() //  [R1]
         { info_tbl: [(c1mYg,
                       label: sat_s1jlM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mYg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mYh; else goto c1mYi;
       c1mYh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mYi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jlS_entry() //  [R1]
         { info_tbl: [(c1mYC,
                       label: sat_s1jlS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mYC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mYD; else goto c1mYE;
       c1mYD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mYE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1mYA_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1mYA() //  [R1]
         { info_tbl: [(c1mYA,
                       label: block_c1mYA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mYA: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jlN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jlQ_entry() //  [R1]
         { info_tbl: [(c1mYM,
                       label: sat_s1jlQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mYM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mYN; else goto c1mYO;
       c1mYN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mYO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jlN_entry() //  [R1, R2]
         { info_tbl: [(c1mYS,
                       label: go_s1jlN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mYS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1mYT; else goto c1mYU;
       c1mYT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1mYU: // global
           I64[Sp - 32] = block_c1mYs_info;
           R3 = P64[R1 + 15];
           _s1jlO::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jlO::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mYs() //  [R1]
         { info_tbl: [(c1mYs,
                       label: block_c1mYs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mYs: // global
           if (R1 == 1) goto c1mYR; else goto c1mYQ;
       c1mYR: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1mYQ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1mYY; else goto c1mYX;
       c1mYY: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1mYX: // global
           I64[Hp - 80] = sat_s1jlS_info;
           P64[Hp - 64] = P64[Sp + 16];
           _s1jlO::P64 = P64[Sp + 24];
           P64[Hp - 56] = _s1jlO::P64;
           I64[Hp - 48] = sat_s1jlQ_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s1jlO::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1mZf_srtd" {
     u1mZf_srtd:
         const S1jKw_srt+480;
         const 34;
         const 8589935105;
 },
 GHC.Real.integralEnumFrom_entry() //  [R2, R3, R4]
         { info_tbl: [(c1mZ2,
                       label: GHC.Real.integralEnumFrom_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mZ2: // global
           _s1jlI::P64 = R4;
           _s1jlH::P64 = R3;
           _s1jlG::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1mZ4; else goto c1mZ5;
       c1mZ5: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1mZ7; else goto c1mZ6;
       c1mZ7: // global
           HpAlloc = 72;
           goto c1mZ4;
       c1mZ4: // global
           R4 = _s1jlI::P64;
           R3 = _s1jlH::P64;
           R2 = _s1jlG::P64;
           R1 = GHC.Real.integralEnumFrom_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1mZ6: // global
           I64[Hp - 64] = f_s1jlJ_info;
           P64[Hp - 48] = _s1jlG::P64;
           I64[Hp - 40] = f1_s1jlK_info;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = sat_s1jlM_info;
           P64[Hp] = _s1jlH::P64;
           I64[Sp - 32] = block_c1mYj_info;
           R2 = _s1jlG::P64;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = _s1jlG::P64;
           P64[Sp - 8] = _s1jlI::P64;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1mYj() //  [R1]
         { info_tbl: [(c1mYj,
                       label: block_c1mYj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mYj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1mZa; else goto c1mZ9;
       c1mZa: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1mZ9: // global
           I64[Hp - 16] = go_s1jlN_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           _s1jlG::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1mZ3_info;
           R2 = _s1jlG::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 15;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1mZ3() //  [R1]
         { info_tbl: [(c1mZ3,
                       label: block_c1mZ3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mZ3: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jlN_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.259700269 UTC

[section ""data" . GHC.Real.integralEnumFromThen_closure" {
     GHC.Real.integralEnumFromThen_closure:
         const GHC.Real.integralEnumFromThen_info;
         const 0;
 },
 f_s1jm2_entry() //  [R1]
         { info_tbl: [(c1mZE,
                       label: f_s1jm2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mZE: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jm3_entry() //  [R1]
         { info_tbl: [(c1mZL,
                       label: f1_s1jm3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mZL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mZM; else goto c1mZN;
       c1mZM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mZN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jm6_entry() //  [R1]
         { info_tbl: [(c1mZW,
                       label: sat_s1jm6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mZW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1mZX; else goto c1mZY;
       c1mZX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1mZY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmc_entry() //  [R1]
         { info_tbl: [(c1n0i,
                       label: sat_s1jmc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n0i: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n0j; else goto c1n0k;
       c1n0j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n0k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1n0g_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1n0g() //  [R1]
         { info_tbl: [(c1n0g,
                       label: block_c1n0g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n0g: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jm7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jma_entry() //  [R1]
         { info_tbl: [(c1n0s,
                       label: sat_s1jma_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n0s: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n0t; else goto c1n0u;
       c1n0t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n0u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jm7_entry() //  [R1, R2]
         { info_tbl: [(c1n0y,
                       label: go_s1jm7_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n0y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1n0z; else goto c1n0A;
       c1n0z: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1n0A: // global
           I64[Sp - 40] = block_c1n08_info;
           R3 = P64[R1 + 23];
           _s1jm8::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jm8::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n08() //  [R1]
         { info_tbl: [(c1n08,
                       label: block_c1n08_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n08: // global
           if (R1 == 1) goto c1n0x; else goto c1n0w;
       c1n0x: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1n0w: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1n0E; else goto c1n0D;
       c1n0E: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1n0D: // global
           I64[Hp - 88] = sat_s1jmc_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jm8::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jm8::P64;
           I64[Hp - 48] = sat_s1jma_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jm8::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jme_entry() //  [R1]
         { info_tbl: [(c1n0O,
                       label: sat_s1jme_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n0O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1n0P; else goto c1n0Q;
       c1n0P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n0Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmk_entry() //  [R1]
         { info_tbl: [(c1n1a,
                       label: sat_s1jmk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n1a: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n1b; else goto c1n1c;
       c1n1b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n1c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1n18_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1n18() //  [R1]
         { info_tbl: [(c1n18,
                       label: block_c1n18_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n18: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmf_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmi_entry() //  [R1]
         { info_tbl: [(c1n1k,
                       label: sat_s1jmi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n1k: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n1l; else goto c1n1m;
       c1n1l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n1m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jmf_entry() //  [R1, R2]
         { info_tbl: [(c1n1q,
                       label: go_s1jmf_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n1q: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1n1r; else goto c1n1s;
       c1n1r: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1n1s: // global
           I64[Sp - 40] = block_c1n10_info;
           R3 = P64[R1 + 23];
           _s1jmg::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jmg::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n10() //  [R1]
         { info_tbl: [(c1n10,
                       label: block_c1n10_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n10: // global
           if (R1 == 1) goto c1n1p; else goto c1n1o;
       c1n1p: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1n1o: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1n1w; else goto c1n1v;
       c1n1w: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1n1v: // global
           I64[Hp - 88] = sat_s1jmk_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jmg::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jmg::P64;
           I64[Hp - 48] = sat_s1jmi_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jmg::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 f_s1jmm_entry() //  [R1]
         { info_tbl: [(c1n1K,
                       label: f_s1jmm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n1K: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jmn_entry() //  [R1]
         { info_tbl: [(c1n1R,
                       label: f1_s1jmn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n1R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1n1S; else goto c1n1T;
       c1n1S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n1T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmq_entry() //  [R1]
         { info_tbl: [(c1n22,
                       label: sat_s1jmq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n22: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1n23; else goto c1n24;
       c1n23: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n24: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmw_entry() //  [R1]
         { info_tbl: [(c1n2o,
                       label: sat_s1jmw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n2o: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n2p; else goto c1n2q;
       c1n2p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n2q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1n2m_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1n2m() //  [R1]
         { info_tbl: [(c1n2m,
                       label: block_c1n2m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n2m: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmr_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmu_entry() //  [R1]
         { info_tbl: [(c1n2y,
                       label: sat_s1jmu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n2y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n2z; else goto c1n2A;
       c1n2z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n2A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jmr_entry() //  [R1, R2]
         { info_tbl: [(c1n2E,
                       label: go_s1jmr_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n2E: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1n2F; else goto c1n2G;
       c1n2F: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1n2G: // global
           I64[Sp - 40] = block_c1n2e_info;
           R3 = P64[R1 + 23];
           _s1jms::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jms::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n2e() //  [R1]
         { info_tbl: [(c1n2e,
                       label: block_c1n2e_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n2e: // global
           if (R1 == 1) goto c1n2D; else goto c1n2C;
       c1n2D: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1n2C: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1n2K; else goto c1n2J;
       c1n2K: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1n2J: // global
           I64[Hp - 88] = sat_s1jmw_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jms::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jms::P64;
           I64[Hp - 48] = sat_s1jmu_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jms::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jmy_entry() //  [R1]
         { info_tbl: [(c1n2U,
                       label: sat_s1jmy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n2U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1n2V; else goto c1n2W;
       c1n2V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n2W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmE_entry() //  [R1]
         { info_tbl: [(c1n3g,
                       label: sat_s1jmE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n3g: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n3h; else goto c1n3i;
       c1n3h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n3i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1n3e_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1n3e() //  [R1]
         { info_tbl: [(c1n3e,
                       label: block_c1n3e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n3e: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmC_entry() //  [R1]
         { info_tbl: [(c1n3q,
                       label: sat_s1jmC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n3q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n3r; else goto c1n3s;
       c1n3r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n3s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jmz_entry() //  [R1, R2]
         { info_tbl: [(c1n3w,
                       label: go_s1jmz_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n3w: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1n3x; else goto c1n3y;
       c1n3x: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1n3y: // global
           I64[Sp - 40] = block_c1n36_info;
           R3 = P64[R1 + 23];
           _s1jmA::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jmA::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n36() //  [R1]
         { info_tbl: [(c1n36,
                       label: block_c1n36_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n36: // global
           if (R1 == 1) goto c1n3v; else goto c1n3u;
       c1n3v: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1n3u: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1n3C; else goto c1n3B;
       c1n3C: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1n3B: // global
           I64[Hp - 88] = sat_s1jmE_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jmA::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jmA::P64;
           I64[Hp - 48] = sat_s1jmC_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jmA::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1n4q_srtd" {
     u1n4q_srtd:
         const S1jKw_srt+456;
         const 39;
         const 412585295873;
 },
 GHC.Real.integralEnumFromThen_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1n3G,
                       label: GHC.Real.integralEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n3G: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1n3H; else goto c1n3I;
       c1n3H: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.integralEnumFromThen_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1n3I: // global
           I64[Sp - 32] = block_c1mZk_info;
           _s1jlU::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s1jlU::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1n4r_srtd" {
     u1n4r_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1mZk() //  [R1]
         { info_tbl: [(c1mZk,
                       label: block_c1mZk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mZk: // global
           I64[Sp] = block_c1mZo_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1n4s_srtd" {
     u1n4s_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1mZo() //  [R1]
         { info_tbl: [(c1mZo,
                       label: block_c1mZo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mZo: // global
           I64[Sp - 8] = block_c1mZs_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1n4t_srtd" {
     u1n4t_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1mZs() //  [R1]
         { info_tbl: [(c1mZs,
                       label: block_c1mZs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mZs: // global
           _s1jlY::P64 = P64[Sp + 32];
           _s1jlZ::P64 = P64[Sp + 8];
           if (R1 == 1) goto c1n47; else goto c1n3N;
       c1n47: // global
           I64[Sp] = block_c1n1C_info;
           R3 = _s1jlZ::P64;
           R2 = _s1jlY::P64;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       c1n3N: // global
           I64[Sp] = block_c1mZw_info;
           R3 = _s1jlZ::P64;
           R2 = _s1jlY::P64;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n1C() //  [R1]
         { info_tbl: [(c1n1C,
                       label: block_c1n1C_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n1C: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1n4a; else goto c1n49;
       c1n4a: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1n49: // global
           I64[Hp - 40] = f_s1jmm_info;
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = f1_s1jmn_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_c1n1U_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp] = R1;
           P64[Sp + 32] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n1U() //  [R1]
         { info_tbl: [(c1n1U,
                       label: block_c1n1U_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n1U: // global
           _s1jlU::P64 = P64[Sp + 24];
           _s1jlV::P64 = P64[Sp + 32];
           if (R1 == 1) goto c1n4j; else goto c1n4c;
       c1n4j: // global
           Hp = Hp + 24;
           _s1jmo::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1n4m; else goto c1n4l;
       c1n4l: // global
           I64[Hp - 16] = sat_s1jmy_info;
           P64[Hp] = _s1jlV::P64;
           I64[Sp] = block_c1n2X_info;
           R2 = _s1jlU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c1n4c: // global
           Hp = Hp + 24;
           _s1jmo::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1n4m; else goto c1n4e;
       c1n4m: // global
           HpAlloc = 24;
           R1 = _s1jmo::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1n4e: // global
           I64[Hp - 16] = sat_s1jmq_info;
           P64[Hp] = _s1jlV::P64;
           I64[Sp] = block_c1n25_info;
           R2 = _s1jlU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1n2X() //  [R1]
         { info_tbl: [(c1n2X,
                       label: block_c1n2X_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n2X: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1n4p; else goto c1n4o;
       c1n4p: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1n4o: // global
           I64[Hp - 24] = go_s1jmz_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jmz_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1n25() //  [R1]
         { info_tbl: [(c1n25,
                       label: block_c1n25_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n25: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1n4i; else goto c1n4h;
       c1n4i: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1n4h: // global
           I64[Hp - 24] = go_s1jmr_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jmr_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1mZw() //  [R1]
         { info_tbl: [(c1mZw,
                       label: block_c1mZw_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mZw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1n3Q; else goto c1n3P;
       c1n3Q: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1n3P: // global
           I64[Hp - 40] = f_s1jm2_info;
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = f1_s1jm3_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_c1mZO_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp] = R1;
           P64[Sp + 32] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1mZO() //  [R1]
         { info_tbl: [(c1mZO,
                       label: block_c1mZO_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mZO: // global
           _s1jlU::P64 = P64[Sp + 24];
           _s1jlV::P64 = P64[Sp + 32];
           if (R1 == 1) goto c1n3Z; else goto c1n3S;
       c1n3Z: // global
           Hp = Hp + 24;
           _s1jm4::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1n42; else goto c1n41;
       c1n41: // global
           I64[Hp - 16] = sat_s1jme_info;
           P64[Hp] = _s1jlV::P64;
           I64[Sp] = block_c1n0R_info;
           R2 = _s1jlU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c1n3S: // global
           Hp = Hp + 24;
           _s1jm4::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1n42; else goto c1n3U;
       c1n42: // global
           HpAlloc = 24;
           R1 = _s1jm4::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1n3U: // global
           I64[Hp - 16] = sat_s1jm6_info;
           P64[Hp] = _s1jlV::P64;
           I64[Sp] = block_c1mZZ_info;
           R2 = _s1jlU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1n0R() //  [R1]
         { info_tbl: [(c1n0R,
                       label: block_c1n0R_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n0R: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1n45; else goto c1n44;
       c1n45: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1n44: // global
           I64[Hp - 24] = go_s1jmf_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jmf_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1mZZ() //  [R1]
         { info_tbl: [(c1mZZ,
                       label: block_c1mZZ_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1mZZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1n3Y; else goto c1n3X;
       c1n3Y: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1n3X: // global
           I64[Hp - 24] = go_s1jm7_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jm7_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.272314933 UTC

[section ""data" . GHC.Real.integralEnumFromTo_closure" {
     GHC.Real.integralEnumFromTo_closure:
         const GHC.Real.integralEnumFromTo_info;
         const 0;
 },
 f_s1jmI_entry() //  [R1]
         { info_tbl: [(c1n4C,
                       label: f_s1jmI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n4C: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jmJ_entry() //  [R1]
         { info_tbl: [(c1n4J,
                       label: f1_s1jmJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n4J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1n4K; else goto c1n4L;
       c1n4K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n4L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmQ_entry() //  [R1]
         { info_tbl: [(c1n55,
                       label: sat_s1jmQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n55: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n56; else goto c1n57;
       c1n56: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n57: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1n53_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1n53() //  [R1]
         { info_tbl: [(c1n53,
                       label: block_c1n53_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n53: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmL_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmO_entry() //  [R1]
         { info_tbl: [(c1n5f,
                       label: sat_s1jmO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n5f: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n5g; else goto c1n5h;
       c1n5g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n5h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jmL_entry() //  [R1, R2]
         { info_tbl: [(c1n5l,
                       label: go_s1jmL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n5l: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n5m; else goto c1n5n;
       c1n5m: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1n5n: // global
           I64[Sp - 32] = block_c1n4V_info;
           R3 = P64[R1 + 15];
           _s1jmM::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jmM::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n4V() //  [R1]
         { info_tbl: [(c1n4V,
                       label: block_c1n4V_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n4V: // global
           if (R1 == 1) goto c1n5k; else goto c1n5j;
       c1n5k: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1n5j: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1n5r; else goto c1n5q;
       c1n5r: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1n5q: // global
           I64[Hp - 80] = sat_s1jmQ_info;
           P64[Hp - 64] = P64[Sp + 16];
           _s1jmM::P64 = P64[Sp + 24];
           P64[Hp - 56] = _s1jmM::P64;
           I64[Hp - 48] = sat_s1jmO_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s1jmM::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.integralEnumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c1n5v,
                       label: GHC.Real.integralEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n5v: // global
           _s1jmH::P64 = R4;
           _s1jmG::P64 = R3;
           _s1jmF::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1n5x; else goto c1n5y;
       c1n5y: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1n5A; else goto c1n5z;
       c1n5A: // global
           HpAlloc = 48;
           goto c1n5x;
       c1n5x: // global
           R4 = _s1jmH::P64;
           R3 = _s1jmG::P64;
           R2 = _s1jmF::P64;
           R1 = GHC.Real.integralEnumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1n5z: // global
           I64[Hp - 40] = f_s1jmI_info;
           P64[Hp - 24] = _s1jmF::P64;
           I64[Hp - 16] = f1_s1jmJ_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 32] = block_c1n4M_info;
           R2 = _s1jmF::P64;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = _s1jmH::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _s1jmF::P64;
           P64[Sp - 8] = _s1jmG::P64;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1n4M() //  [R1]
         { info_tbl: [(c1n4M,
                       label: block_c1n4M_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n4M: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1n5D; else goto c1n5C;
       c1n5D: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1n5C: // global
           I64[Hp - 16] = go_s1jmL_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           _s1jmF::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1n5w_info;
           R2 = _s1jmF::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 15;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1n5w() //  [R1]
         { info_tbl: [(c1n5w,
                       label: block_c1n5w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n5w: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmL_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.277690769 UTC

[section ""data" . GHC.Real.integralEnumFromThenTo_closure" {
     GHC.Real.integralEnumFromThenTo_closure:
         const GHC.Real.integralEnumFromThenTo_info;
         const 0;
 },
 f_s1jmZ_entry() //  [R1]
         { info_tbl: [(c1n62,
                       label: f_s1jmZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n62: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jn0_entry() //  [R1]
         { info_tbl: [(c1n69,
                       label: f1_s1jn0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n69: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1n6a; else goto c1n6b;
       c1n6a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n6b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jn8_entry() //  [R1]
         { info_tbl: [(c1n6z,
                       label: sat_s1jn8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n6z: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n6A; else goto c1n6B;
       c1n6A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n6B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1n6x_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1n6x() //  [R1]
         { info_tbl: [(c1n6x,
                       label: block_c1n6x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n6x: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jn3_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jn6_entry() //  [R1]
         { info_tbl: [(c1n6J,
                       label: sat_s1jn6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n6J: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n6K; else goto c1n6L;
       c1n6K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n6L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jn3_entry() //  [R1, R2]
         { info_tbl: [(c1n6P,
                       label: go_s1jn3_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n6P: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1n6Q; else goto c1n6R;
       c1n6Q: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1n6R: // global
           I64[Sp - 40] = block_c1n6p_info;
           R3 = P64[R1 + 23];
           _s1jn4::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jn4::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n6p() //  [R1]
         { info_tbl: [(c1n6p,
                       label: block_c1n6p_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n6p: // global
           if (R1 == 1) goto c1n6O; else goto c1n6N;
       c1n6O: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1n6N: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1n6V; else goto c1n6U;
       c1n6V: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1n6U: // global
           I64[Hp - 88] = sat_s1jn8_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jn4::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jn4::P64;
           I64[Hp - 48] = sat_s1jn6_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jn4::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jnf_entry() //  [R1]
         { info_tbl: [(c1n7k,
                       label: sat_s1jnf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n7k: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n7l; else goto c1n7m;
       c1n7l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n7m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1n7i_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1n7i() //  [R1]
         { info_tbl: [(c1n7i,
                       label: block_c1n7i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n7i: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jna_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jnd_entry() //  [R1]
         { info_tbl: [(c1n7u,
                       label: sat_s1jnd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n7u: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n7v; else goto c1n7w;
       c1n7v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n7w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jna_entry() //  [R1, R2]
         { info_tbl: [(c1n7A,
                       label: go_s1jna_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n7A: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1n7B; else goto c1n7C;
       c1n7B: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1n7C: // global
           I64[Sp - 40] = block_c1n7a_info;
           R3 = P64[R1 + 23];
           _s1jnb::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jnb::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n7a() //  [R1]
         { info_tbl: [(c1n7a,
                       label: block_c1n7a_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n7a: // global
           if (R1 == 1) goto c1n7z; else goto c1n7y;
       c1n7z: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1n7y: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1n7G; else goto c1n7F;
       c1n7G: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1n7F: // global
           I64[Hp - 88] = sat_s1jnf_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jnb::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jnb::P64;
           I64[Hp - 48] = sat_s1jnd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jnb::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1n83_srtd" {
     u1n83_srtd:
         const S1jKw_srt+456;
         const 41;
         const 1237219016705;
 },
 GHC.Real.integralEnumFromThenTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1n7K,
                       label: GHC.Real.integralEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n7K: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1n7L; else goto c1n7M;
       c1n7L: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.integralEnumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1n7M: // global
           I64[Sp - 32] = block_c1n5M_info;
           _s1jmS::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = R3;
           P64[Sp - 24] = _s1jmS::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1n84_srtd" {
     u1n84_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1n5M() //  [R1]
         { info_tbl: [(c1n5M,
                       label: block_c1n5M_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n5M: // global
           I64[Sp] = block_c1n5Q_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1n85_srtd" {
     u1n85_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1n5Q() //  [R1]
         { info_tbl: [(c1n5Q,
                       label: block_c1n5Q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n5Q: // global
           I64[Sp] = block_c1n5U_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n5U() //  [R1]
         { info_tbl: [(c1n5U,
                       label: block_c1n5U_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n5U: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1n7R; else goto c1n7Q;
       c1n7R: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1n7Q: // global
           I64[Hp - 40] = f_s1jmZ_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = f1_s1jn0_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 16] = block_c1n6c_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n6c() //  [R1]
         { info_tbl: [(c1n6c,
                       label: block_c1n6c_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n6c: // global
           _s1jmS::P64 = P64[Sp + 24];
           _s1jmV::P64 = P64[Sp + 40];
           if (R1 == 1) goto c1n7Z; else goto c1n7U;
       c1n7Z: // global
           I64[Sp] = block_c1n71_info;
           R2 = _s1jmS::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s1jmV::P64;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c1n7U: // global
           I64[Sp] = block_c1n6g_info;
           R2 = _s1jmS::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s1jmV::P64;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1n71() //  [R1]
         { info_tbl: [(c1n71,
                       label: block_c1n71_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n71: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1n82; else goto c1n81;
       c1n82: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1n81: // global
           I64[Hp - 24] = go_s1jna_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = P64[Sp + 32];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jna_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1n6g() //  [R1]
         { info_tbl: [(c1n6g,
                       label: block_c1n6g_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n6g: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1n7X; else goto c1n7W;
       c1n7X: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1n7W: // global
           I64[Hp - 24] = go_s1jn3_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = P64[Sp + 32];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jn3_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.283057836 UTC

[section ""cstring" . GHC.Real.$trModule4_bytes" {
     GHC.Real.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.2836001 UTC

[section ""data" . GHC.Real.$trModule3_closure" {
     GHC.Real.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.284132581 UTC

[section ""cstring" . GHC.Real.$trModule2_bytes" {
     GHC.Real.$trModule2_bytes:
         I8[] [71,72,67,46,82,101,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.284669597 UTC

[section ""data" . GHC.Real.$trModule1_closure" {
     GHC.Real.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.2853038 UTC

[section ""data" . GHC.Real.$trModule_closure" {
     GHC.Real.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Real.$trModule3_closure+1;
         const GHC.Real.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.285850233 UTC

[section ""data" . $krep_r1j3d_closure" {
     $krep_r1j3d_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.286439227 UTC

[section ""data" . $krep1_r1j3e_closure" {
     $krep1_r1j3e_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.288436481 UTC

[section ""data" . GHC.Real.$tcFractional1_closure" {
     GHC.Real.$tcFractional1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep1_r1j3e_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.289015548 UTC

[section ""data" . $krep2_r1j3f_closure" {
     $krep2_r1j3f_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.289595065 UTC

[section ""data" . $krep3_r1j3g_closure" {
     $krep3_r1j3g_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep2_r1j3f_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.290135252 UTC

[section ""data" . $krep4_r1j3h_closure" {
     $krep4_r1j3h_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep3_r1j3g_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.290688131 UTC

[section ""data" . $krep5_r1j3i_closure" {
     $krep5_r1j3i_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep_r1j3d_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.291235149 UTC

[section ""data" . $krep6_r1j3j_closure" {
     $krep6_r1j3j_closure:
         const :_con_info;
         const $krep2_r1j3f_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.291779392 UTC

[section ""data" . $krep7_r1j3k_closure" {
     $krep7_r1j3k_closure:
         const :_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.29231243 UTC

[section ""data" . $krep8_r1j3l_closure" {
     $krep8_r1j3l_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep7_r1j3k_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.292865984 UTC

[section ""data" . $krep9_r1j3m_closure" {
     $krep9_r1j3m_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep8_r1j3l_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.293452084 UTC

[section ""data" . $krep10_r1j3n_closure" {
     $krep10_r1j3n_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep9_r1j3m_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.294022826 UTC

[section ""data" . $krep11_r1j3o_closure" {
     $krep11_r1j3o_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Num.$tcNum_closure;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.29455926 UTC

[section ""data" . $krep12_r1j3p_closure" {
     $krep12_r1j3p_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Enum.$tcEnum_closure;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.295128122 UTC

[section ""data" . $krep13_r1j3q_closure" {
     $krep13_r1j3q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Classes.$tcOrd_closure;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.295688762 UTC

[section ""cstring" . GHC.Real.$tcRatio2_bytes" {
     GHC.Real.$tcRatio2_bytes:
         I8[] [82,97,116,105,111]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.296257888 UTC

[section ""data" . GHC.Real.$tcRatio1_closure" {
     GHC.Real.$tcRatio1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcRatio2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.296798101 UTC

[section ""data" . GHC.Real.$tcRatio_closure" {
     GHC.Real.$tcRatio_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcRatio1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 17658523810845794968;
         const 1271393732863050253;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.297458148 UTC

[section ""data" . $krep14_r1j3r_closure" {
     $krep14_r1j3r_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcRatio_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.298017083 UTC

[section ""data" . $krep15_r1j3s_closure" {
     $krep15_r1j3s_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep14_r1j3r_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.298586938 UTC

[section ""data" . GHC.Real.$tc':%1_closure" {
     GHC.Real.$tc':%1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep15_r1j3s_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.299146681 UTC

[section ""cstring" . GHC.Real.$tc':%3_bytes" {
     GHC.Real.$tc':%3_bytes:
         I8[] [39,58,37]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.299705746 UTC

[section ""data" . GHC.Real.$tc':%2_closure" {
     GHC.Real.$tc':%2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc':%3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.300242361 UTC

[section ""data" . GHC.Real.$tc':%_closure" {
     GHC.Real.$tc':%_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc':%2_closure+1;
         const GHC.Real.$tc':%1_closure+4;
         const 11952989868638128372;
         const 6861245286732044789;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.300839526 UTC

[section ""data" . $krep16_r1j3t_closure" {
     $krep16_r1j3t_closure:
         const :_con_info;
         const $krep_r1j3d_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.301485619 UTC

[section ""data" . $krep17_r1j3u_closure" {
     $krep17_r1j3u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcRatio_closure+1;
         const $krep16_r1j3t_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.302060295 UTC

[section ""data" . $krep18_r1j3v_closure" {
     $krep18_r1j3v_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep17_r1j3u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.302589561 UTC

[section ""data" . $krep19_r1j3w_closure" {
     $krep19_r1j3w_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep17_r1j3u_closure+1;
         const $krep2_r1j3f_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.303156361 UTC

[section ""cstring" . GHC.Real.$tcReal2_bytes" {
     GHC.Real.$tcReal2_bytes:
         I8[] [82,101,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.303699571 UTC

[section ""data" . GHC.Real.$tcReal1_closure" {
     GHC.Real.$tcReal1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcReal2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.304255047 UTC

[section ""data" . GHC.Real.$tcReal_closure" {
     GHC.Real.$tcReal_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcReal1_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 1826502536394630182;
         const 14487785779892251413;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.304861777 UTC

[section ""data" . $krep20_r1j3x_closure" {
     $krep20_r1j3x_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcReal_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.305510094 UTC

[section ""data" . $krep21_r1j3y_closure" {
     $krep21_r1j3y_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep18_r1j3v_closure+4;
         const $krep20_r1j3x_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.306072639 UTC

[section ""data" . $krep22_r1j3z_closure" {
     $krep22_r1j3z_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_r1j3q_closure+1;
         const $krep21_r1j3y_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.306674374 UTC

[section ""data" . GHC.Real.$tc'C:Real1_closure" {
     GHC.Real.$tc'C:Real1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1j3o_closure+1;
         const $krep22_r1j3z_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.307229171 UTC

[section ""cstring" . GHC.Real.$tc'C:Real3_bytes" {
     GHC.Real.$tc'C:Real3_bytes:
         I8[] [39,67,58,82,101,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.307734471 UTC

[section ""data" . GHC.Real.$tc'C:Real2_closure" {
     GHC.Real.$tc'C:Real2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc'C:Real3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.308269721 UTC

[section ""data" . GHC.Real.$tc'C:Real_closure" {
     GHC.Real.$tc'C:Real_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc'C:Real2_closure+1;
         const GHC.Real.$tc'C:Real1_closure+4;
         const 5938283050841830427;
         const 8926187074226767634;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.308779746 UTC

[section ""cstring" . GHC.Real.$tcIntegral2_bytes" {
     GHC.Real.$tcIntegral2_bytes:
         I8[] [73,110,116,101,103,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.309359038 UTC

[section ""data" . GHC.Real.$tcIntegral1_closure" {
     GHC.Real.$tcIntegral1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcIntegral2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.309908986 UTC

[section ""data" . GHC.Real.$tcIntegral_closure" {
     GHC.Real.$tcIntegral_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcIntegral1_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 16601157811546713973;
         const 3304955164956033666;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.310494 UTC

[section ""data" . $krep23_r1j3A_closure" {
     $krep23_r1j3A_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcIntegral_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.311001667 UTC

[section ""data" . $krep24_r1j3B_closure" {
     $krep24_r1j3B_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r1j3i_closure+4;
         const $krep23_r1j3A_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.311633792 UTC

[section ""data" . $krep25_r1j3C_closure" {
     $krep25_r1j3C_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_r1j3n_closure+4;
         const $krep24_r1j3B_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.313038034 UTC

[section ""data" . $krep26_r1j3D_closure" {
     $krep26_r1j3D_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_r1j3n_closure+4;
         const $krep25_r1j3C_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.313700927 UTC

[section ""data" . $krep27_r1j3E_closure" {
     $krep27_r1j3E_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep26_r1j3D_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.31426708 UTC

[section ""data" . $krep28_r1j3F_closure" {
     $krep28_r1j3F_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep27_r1j3E_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.314808291 UTC

[section ""data" . $krep29_r1j3G_closure" {
     $krep29_r1j3G_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep28_r1j3F_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.315371331 UTC

[section ""data" . $krep30_r1j3H_closure" {
     $krep30_r1j3H_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep29_r1j3G_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.315916119 UTC

[section ""data" . $krep31_r1j3I_closure" {
     $krep31_r1j3I_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_r1j3p_closure+1;
         const $krep30_r1j3H_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.316454365 UTC

[section ""data" . GHC.Real.$tc'C:Integral1_closure" {
     GHC.Real.$tc'C:Integral1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep20_r1j3x_closure+1;
         const $krep31_r1j3I_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.316932585 UTC

[section ""cstring" . GHC.Real.$tc'C:Integral3_bytes" {
     GHC.Real.$tc'C:Integral3_bytes:
         I8[] [39,67,58,73,110,116,101,103,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.317611298 UTC

[section ""data" . GHC.Real.$tc'C:Integral2_closure" {
     GHC.Real.$tc'C:Integral2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc'C:Integral3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.318177803 UTC

[section ""data" . GHC.Real.$tc'C:Integral_closure" {
     GHC.Real.$tc'C:Integral_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc'C:Integral2_closure+1;
         const GHC.Real.$tc'C:Integral1_closure+4;
         const 12141017740256829283;
         const 17564033539811245778;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.318749668 UTC

[section ""cstring" . GHC.Real.$tcFractional3_bytes" {
     GHC.Real.$tcFractional3_bytes:
         I8[] [70,114,97,99,116,105,111,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.319274306 UTC

[section ""data" . GHC.Real.$tcFractional2_closure" {
     GHC.Real.$tcFractional2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcFractional3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.319825886 UTC

[section ""data" . GHC.Real.$tcFractional_closure" {
     GHC.Real.$tcFractional_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcFractional2_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 14968870971062750857;
         const 13774835939651899219;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.320383287 UTC

[section ""data" . $krep32_r1j3J_closure" {
     $krep32_r1j3J_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcFractional_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.32092788 UTC

[section ""data" . $krep33_r1j3K_closure" {
     $krep33_r1j3K_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep19_r1j3w_closure+4;
         const $krep32_r1j3J_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.321525458 UTC

[section ""data" . $krep34_r1j3L_closure" {
     $krep34_r1j3L_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r1j3g_closure+4;
         const $krep33_r1j3K_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.322112988 UTC

[section ""data" . $krep35_r1j3M_closure" {
     $krep35_r1j3M_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep34_r1j3L_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.322685524 UTC

[section ""data" . GHC.Real.$tc'C:Fractional1_closure" {
     GHC.Real.$tc'C:Fractional1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1j3o_closure+1;
         const $krep35_r1j3M_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.32319505 UTC

[section ""cstring" . GHC.Real.$tc'C:Fractional3_bytes" {
     GHC.Real.$tc'C:Fractional3_bytes:
         I8[] [39,67,58,70,114,97,99,116,105,111,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.323712921 UTC

[section ""data" . GHC.Real.$tc'C:Fractional2_closure" {
     GHC.Real.$tc'C:Fractional2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc'C:Fractional3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.324273953 UTC

[section ""data" . GHC.Real.$tc'C:Fractional_closure" {
     GHC.Real.$tc'C:Fractional_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc'C:Fractional2_closure+1;
         const GHC.Real.$tc'C:Fractional1_closure+4;
         const 15706435530565718930;
         const 11021884564355505453;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.324877773 UTC

[section ""cstring" . GHC.Real.$tcRealFrac2_bytes" {
     GHC.Real.$tcRealFrac2_bytes:
         I8[] [82,101,97,108,70,114,97,99]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.325515658 UTC

[section ""data" . GHC.Real.$tcRealFrac1_closure" {
     GHC.Real.$tcRealFrac1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcRealFrac2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.326088642 UTC

[section ""data" . GHC.Real.$tcRealFrac_closure" {
     GHC.Real.$tcRealFrac_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcRealFrac1_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 2318913099678420819;
         const 6373121509494083706;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.327595756 UTC

[section ""data" . GHC.Real.$w$c<_closure" {
     GHC.Real.$w$c<_closure:
         const GHC.Real.$w$c<_info;
 },
 $dNum_s1jnm_entry() //  [R1]
         { info_tbl: [(c1n8i,
                       label: $dNum_s1jnm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n8i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1n8j; else goto c1n8k;
       c1n8j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n8k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jnp_entry() //  [R1]
         { info_tbl: [(c1n8p,
                       label: sat_s1jnp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n8p: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1n8q; else goto c1n8r;
       c1n8q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n8r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jno_entry() //  [R1]
         { info_tbl: [(c1n8w,
                       label: sat_s1jno_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n8w: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1n8x; else goto c1n8y;
       c1n8x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n8y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1n8z,
                       label: GHC.Real.$w$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n8z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1n8B; else goto c1n8C;
       c1n8B: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1n8C: // global
           I64[Sp - 40] = block_c1n8a_info;
           R2 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n8a() //  [R1]
         { info_tbl: [(c1n8a,
                       label: block_c1n8a_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n8a: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c1n8F; else goto c1n8E;
       c1n8F: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1n8E: // global
           I64[Hp - 96] = $dNum_s1jnm_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s1jnp_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           _c1n8e::P64 = Hp - 96;
           P64[Hp - 40] = _c1n8e::P64;
           I64[Hp - 32] = sat_s1jno_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _c1n8e::P64;
           I64[Sp + 16] = block_c1n8A_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n8A() //  [R1]
         { info_tbl: [(c1n8A,
                       label: block_c1n8A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n8A: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.<_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.330095041 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c<_closure" {
     GHC.Real.$fOrdRatio_$c<_closure:
         const GHC.Real.$fOrdRatio_$c<_info;
 },
 GHC.Real.$fOrdRatio_$c<_entry() //  [R2, R3, R4]
         { info_tbl: [(c1n8R,
                       label: GHC.Real.$fOrdRatio_$c<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n8R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n8V; else goto c1n8W;
       c1n8V: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1n8W: // global
           I64[Sp - 24] = block_c1n8O_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1n94; else goto c1n8P;
       u1n94: // global
           call _c1n8O(R1) args: 0, res: 0, upd: 0;
       c1n8P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1n8O() //  [R1]
         { info_tbl: [(c1n8O,
                       label: block_c1n8O_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n8O: // global
           I64[Sp - 8] = block_c1n8U_info;
           _s1jnu::P64 = P64[R1 + 7];
           _s1jnv::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jnv::P64;
           P64[Sp + 16] = _s1jnu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1n93; else goto c1n8Y;
       u1n93: // global
           call _c1n8U(R1) args: 0, res: 0, upd: 0;
       c1n8Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1n8U() //  [R1]
         { info_tbl: [(c1n8U,
                       label: block_c1n8U_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n8U: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.332094553 UTC

[section ""data" . GHC.Real.$w$c<=_closure" {
     GHC.Real.$w$c<=_closure:
         const GHC.Real.$w$c<=_info;
 },
 $dNum_s1jnF_entry() //  [R1]
         { info_tbl: [(c1n9h,
                       label: $dNum_s1jnF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n9h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1n9i; else goto c1n9j;
       c1n9i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n9j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jnI_entry() //  [R1]
         { info_tbl: [(c1n9o,
                       label: sat_s1jnI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n9o: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1n9p; else goto c1n9q;
       c1n9p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n9q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jnH_entry() //  [R1]
         { info_tbl: [(c1n9v,
                       label: sat_s1jnH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n9v: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1n9w; else goto c1n9x;
       c1n9w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1n9x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1n9y,
                       label: GHC.Real.$w$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n9y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1n9A; else goto c1n9B;
       c1n9A: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1n9B: // global
           I64[Sp - 40] = block_c1n99_info;
           R2 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n99() //  [R1]
         { info_tbl: [(c1n99,
                       label: block_c1n99_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n99: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c1n9E; else goto c1n9D;
       c1n9E: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1n9D: // global
           I64[Hp - 96] = $dNum_s1jnF_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s1jnI_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           _c1n9d::P64 = Hp - 96;
           P64[Hp - 40] = _c1n9d::P64;
           I64[Hp - 32] = sat_s1jnH_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _c1n9d::P64;
           I64[Sp + 16] = block_c1n9z_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1n9z() //  [R1]
         { info_tbl: [(c1n9z,
                       label: block_c1n9z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n9z: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.<=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.334467692 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c<=_closure" {
     GHC.Real.$fOrdRatio_$c<=_closure:
         const GHC.Real.$fOrdRatio_$c<=_info;
 },
 GHC.Real.$fOrdRatio_$c<=_entry() //  [R2, R3, R4]
         { info_tbl: [(c1n9Q,
                       label: GHC.Real.$fOrdRatio_$c<=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n9Q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1n9U; else goto c1n9V;
       c1n9U: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1n9V: // global
           I64[Sp - 24] = block_c1n9N_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1na3; else goto c1n9O;
       u1na3: // global
           call _c1n9N(R1) args: 0, res: 0, upd: 0;
       c1n9O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1n9N() //  [R1]
         { info_tbl: [(c1n9N,
                       label: block_c1n9N_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n9N: // global
           I64[Sp - 8] = block_c1n9T_info;
           _s1jnN::P64 = P64[R1 + 7];
           _s1jnO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jnO::P64;
           P64[Sp + 16] = _s1jnN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1na2; else goto c1n9X;
       u1na2: // global
           call _c1n9T(R1) args: 0, res: 0, upd: 0;
       c1n9X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1n9T() //  [R1]
         { info_tbl: [(c1n9T,
                       label: block_c1n9T_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1n9T: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.336170667 UTC

[section ""data" . GHC.Real.$fOrdRatio_$cmax_closure" {
     GHC.Real.$fOrdRatio_$cmax_closure:
         const GHC.Real.$fOrdRatio_$cmax_info;
 },
 GHC.Real.$fOrdRatio_$cmax_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nab,
                       label: GHC.Real.$fOrdRatio_$cmax_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nab: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1naf; else goto c1nag;
       c1naf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nag: // global
           I64[Sp - 24] = block_c1na8_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1naA; else goto c1na9;
       u1naA: // global
           call _c1na8(R1) args: 0, res: 0, upd: 0;
       c1na9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1na8() //  [R1]
         { info_tbl: [(c1na8,
                       label: block_c1na8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1na8: // global
           I64[Sp - 16] = block_c1nae_info;
           _s1jnV::P64 = R1;
           _s1jnW::P64 = P64[R1 + 7];
           _s1jnX::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s1jnX::P64;
           P64[Sp] = _s1jnW::P64;
           P64[Sp + 16] = _s1jnV::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1naz; else goto c1nai;
       u1naz: // global
           call _c1nae(R1) args: 0, res: 0, upd: 0;
       c1nai: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nae() //  [R1]
         { info_tbl: [(c1nae,
                       label: block_c1nae_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nae: // global
           _s1jnW::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1nam_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jnW::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nam() //  [R1]
         { info_tbl: [(c1nam,
                       label: block_c1nam_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nam: // global
           if (R1 & 7 == 1) goto c1nat; else goto c1nax;
       c1nat: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1nax: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.338217438 UTC

[section ""data" . GHC.Real.$fOrdRatio_$cmin_closure" {
     GHC.Real.$fOrdRatio_$cmin_closure:
         const GHC.Real.$fOrdRatio_$cmin_info;
 },
 GHC.Real.$fOrdRatio_$cmin_entry() //  [R2, R3, R4]
         { info_tbl: [(c1naI,
                       label: GHC.Real.$fOrdRatio_$cmin_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1naI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1naM; else goto c1naN;
       c1naM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1naN: // global
           I64[Sp - 24] = block_c1naF_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1nb7; else goto c1naG;
       u1nb7: // global
           call _c1naF(R1) args: 0, res: 0, upd: 0;
       c1naG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1naF() //  [R1]
         { info_tbl: [(c1naF,
                       label: block_c1naF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1naF: // global
           I64[Sp - 16] = block_c1naL_info;
           _s1jo5::P64 = R1;
           _s1jo6::P64 = P64[R1 + 7];
           _s1jo7::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s1jo7::P64;
           P64[Sp] = _s1jo6::P64;
           P64[Sp + 16] = _s1jo5::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nb6; else goto c1naP;
       u1nb6: // global
           call _c1naL(R1) args: 0, res: 0, upd: 0;
       c1naP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1naL() //  [R1]
         { info_tbl: [(c1naL,
                       label: block_c1naL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1naL: // global
           _s1jo6::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1naT_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jo6::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1naT() //  [R1]
         { info_tbl: [(c1naT,
                       label: block_c1naT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1naT: // global
           if (R1 & 7 == 1) goto c1nb0; else goto c1nb4;
       c1nb0: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1nb4: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.340540318 UTC

[section ""data" . GHC.Real.$w$ccompare_closure" {
     GHC.Real.$w$ccompare_closure:
         const GHC.Real.$w$ccompare_info;
 },
 GHC.Real.$w$ccompare_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1nbe,
                       label: GHC.Real.$w$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nbe: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c1nbm; else goto c1nbn;
       c1nbm: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nbn: // global
           I64[Sp - 48] = block_c1nbc_info;
           _s1joc::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = _s1joc::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nbc() //  [R1]
         { info_tbl: [(c1nbc,
                       label: block_c1nbc_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nbc: // global
           I64[Sp] = block_c1nbh_info;
           R2 = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nbh() //  [R1]
         { info_tbl: [(c1nbh,
                       label: block_c1nbh_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nbh: // global
           I64[Sp] = block_c1nbl_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nbl() //  [R1]
         { info_tbl: [(c1nbl,
                       label: block_c1nbl_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nbl: // global
           I64[Sp - 8] = block_c1nbt_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1nbt() //  [R1]
         { info_tbl: [(c1nbt,
                       label: block_c1nbt_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nbt: // global
           _s1joe::P64 = P64[Sp + 32];
           _s1jog::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto c1nbB; else goto c1nbQ;
       c1nbB: // global
           I64[Sp + 48] = block_c1nby_info;
           R6 = _s1jog::P64;
           R5 = P64[Sp + 40];
           R4 = _s1joe::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 48;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
       c1nbQ: // global
           _s1joj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nbO_info;
           R2 = _s1joj::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s1joe::P64;
           P64[Sp] = _s1jog::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1nby() //  [R1]
         { info_tbl: [(c1nby,
                       label: block_c1nby_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nby: // global
           if (R1 & 7 == 1) goto u1nci; else goto u1ncj;
       u1nci: // global
           Sp = Sp + 8;
           call _c1nc3() args: 0, res: 0, upd: 0;
       u1ncj: // global
           Sp = Sp + 8;
           call _c1nc7() args: 0, res: 0, upd: 0;
     }
 },
 _c1nbO() //  [R1]
         { info_tbl: [(c1nbO,
                       label: block_c1nbO_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nbO: // global
           if (R1 & 7 == 1) goto c1nbX; else goto c1ncb;
       c1nbX: // global
           _s1jog::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_c1nbU_info;
           R6 = _s1jog::P64;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
       c1ncb: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1nbU() //  [R1]
         { info_tbl: [(c1nbU,
                       label: block_c1nbU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nbU: // global
           if (R1 & 7 == 1) goto u1ncg; else goto u1nch;
       u1ncg: // global
           Sp = Sp + 8;
           call _c1nc3() args: 0, res: 0, upd: 0;
       u1nch: // global
           Sp = Sp + 8;
           call _c1nc7() args: 0, res: 0, upd: 0;
     }
 },
 _c1nc3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nc3: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1nc7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nc7: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.344247221 UTC

[section ""data" . GHC.Real.$fOrdRatio_$ccompare_closure" {
     GHC.Real.$fOrdRatio_$ccompare_closure:
         const GHC.Real.$fOrdRatio_$ccompare_info;
 },
 GHC.Real.$fOrdRatio_$ccompare_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ncv,
                       label: GHC.Real.$fOrdRatio_$ccompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ncv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ncz; else goto c1ncA;
       c1ncz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ncA: // global
           I64[Sp - 24] = block_c1ncs_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1ncI; else goto c1nct;
       u1ncI: // global
           call _c1ncs(R1) args: 0, res: 0, upd: 0;
       c1nct: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ncs() //  [R1]
         { info_tbl: [(c1ncs,
                       label: block_c1ncs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ncs: // global
           I64[Sp - 8] = block_c1ncy_info;
           _s1jos::P64 = P64[R1 + 7];
           _s1jot::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jot::P64;
           P64[Sp + 16] = _s1jos::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ncH; else goto c1ncC;
       u1ncH: // global
           call _c1ncy(R1) args: 0, res: 0, upd: 0;
       c1ncC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ncy() //  [R1]
         { info_tbl: [(c1ncy,
                       label: block_c1ncy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ncy: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.346021634 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c>_closure" {
     GHC.Real.$fOrdRatio_$c>_closure:
         const GHC.Real.$fOrdRatio_$c>_info;
 },
 GHC.Real.$fOrdRatio_$c>_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ncQ,
                       label: GHC.Real.$fOrdRatio_$c>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ncQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ncU; else goto c1ncV;
       c1ncU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ncV: // global
           I64[Sp - 24] = block_c1ncN_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1ndf; else goto c1ncO;
       u1ndf: // global
           call _c1ncN(R1) args: 0, res: 0, upd: 0;
       c1ncO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ncN() //  [R1]
         { info_tbl: [(c1ncN,
                       label: block_c1ncN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ncN: // global
           I64[Sp - 8] = block_c1ncT_info;
           _s1joB::P64 = P64[R1 + 7];
           _s1joC::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1joC::P64;
           P64[Sp + 16] = _s1joB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1nde; else goto c1ncX;
       u1nde: // global
           call _c1ncT(R1) args: 0, res: 0, upd: 0;
       c1ncX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ncT() //  [R1]
         { info_tbl: [(c1ncT,
                       label: block_c1ncT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ncT: // global
           _s1joB::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1nd1_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1joB::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nd1() //  [R1]
         { info_tbl: [(c1nd1,
                       label: block_c1nd1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nd1: // global
           if (R1 & 7 == 3) goto c1ndc; else goto c1nd8;
       c1ndc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1nd8: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.347900661 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c>=_closure" {
     GHC.Real.$fOrdRatio_$c>=_closure:
         const GHC.Real.$fOrdRatio_$c>=_info;
 },
 GHC.Real.$fOrdRatio_$c>=_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ndn,
                       label: GHC.Real.$fOrdRatio_$c>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ndn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ndr; else goto c1nds;
       c1ndr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nds: // global
           I64[Sp - 24] = block_c1ndk_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1ndM; else goto c1ndl;
       u1ndM: // global
           call _c1ndk(R1) args: 0, res: 0, upd: 0;
       c1ndl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ndk() //  [R1]
         { info_tbl: [(c1ndk,
                       label: block_c1ndk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ndk: // global
           I64[Sp - 8] = block_c1ndq_info;
           _s1joL::P64 = P64[R1 + 7];
           _s1joM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1joM::P64;
           P64[Sp + 16] = _s1joL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ndL; else goto c1ndu;
       u1ndL: // global
           call _c1ndq(R1) args: 0, res: 0, upd: 0;
       c1ndu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ndq() //  [R1]
         { info_tbl: [(c1ndq,
                       label: block_c1ndq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ndq: // global
           _s1joL::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1ndy_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1joL::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ndy() //  [R1]
         { info_tbl: [(c1ndy,
                       label: block_c1ndy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ndy: // global
           if (R1 & 7 == 1) goto c1ndJ; else goto c1ndF;
       c1ndJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1ndF: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.351381481 UTC

[section ""data" . GHC.Real.$fOrdRatio_closure" {
     GHC.Real.$fOrdRatio_closure:
         const GHC.Real.$fOrdRatio_info;
 },
 sat_s1joZ_entry() //  [R1, R2, R3]
         { info_tbl: [(c1ndW,
                       label: sat_s1joZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ndW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joY_entry() //  [R1, R2, R3]
         { info_tbl: [(c1ne4,
                       label: sat_s1joY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ne4: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joX_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nec,
                       label: sat_s1joX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nec: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joW_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nek,
                       label: sat_s1joW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nek: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c>_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joV_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nes,
                       label: sat_s1joV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nes: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joU_entry() //  [R1, R2, R3]
         { info_tbl: [(c1neA,
                       label: sat_s1joU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1neA: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joT_entry() //  [R1, R2, R3]
         { info_tbl: [(c1neI,
                       label: sat_s1joT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1neI: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joS_entry() //  [R1]
         { info_tbl: [(c1neP,
                       label: sat_s1joS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1neP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1neQ; else goto c1neR;
       c1neQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1neR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fOrdRatio_entry() //  [R2]
         { info_tbl: [(c1neT,
                       label: GHC.Real.$fOrdRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1neT: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c1neX; else goto c1neW;
       c1neX: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1neW: // global
           I64[Hp - 200] = sat_s1joZ_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s1joY_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s1joX_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1joW_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s1joV_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s1joU_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s1joT_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s1joS_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.35428017 UTC

[section ""data" . GHC.Real.$fNumRatio_$cnegate_closure" {
     GHC.Real.$fNumRatio_$cnegate_closure:
         const GHC.Real.$fNumRatio_$cnegate_info;
 },
 GHC.Real.$fNumRatio_$cnegate_entry() //  [R2, R3]
         { info_tbl: [(c1nf5,
                       label: GHC.Real.$fNumRatio_$cnegate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nf5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nfj; else goto c1nfk;
       c1nfj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$cnegate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nfk: // global
           I64[Sp - 16] = block_c1nf2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nfr; else goto c1nf3;
       u1nfr: // global
           call _c1nf2(R1) args: 0, res: 0, upd: 0;
       c1nf3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nf2() //  [R1]
         { info_tbl: [(c1nf2,
                       label: block_c1nf2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nf2: // global
           I64[Sp - 8] = block_c1nf8_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nf8() //  [R1]
         { info_tbl: [(c1nf8,
                       label: block_c1nf8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nf8: // global
           I64[Sp] = block_c1nfc_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nfc() //  [R1]
         { info_tbl: [(c1nfc,
                       label: block_c1nfc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nfc: // global
           I64[Sp] = block_c1nfg_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1nfg() //  [R1]
         { info_tbl: [(c1nfg,
                       label: block_c1nfg_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nfg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nfq; else goto c1nfp;
       c1nfq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nfp: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.356173851 UTC

[section ""data" . GHC.Real.$fNumRatio_$cabs_closure" {
     GHC.Real.$fNumRatio_$cabs_closure:
         const GHC.Real.$fNumRatio_$cabs_info;
 },
 GHC.Real.$fNumRatio_$cabs_entry() //  [R2, R3]
         { info_tbl: [(c1nfz,
                       label: GHC.Real.$fNumRatio_$cabs_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nfz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nfN; else goto c1nfO;
       c1nfN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$cabs_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nfO: // global
           I64[Sp - 16] = block_c1nfw_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nfV; else goto c1nfx;
       u1nfV: // global
           call _c1nfw(R1) args: 0, res: 0, upd: 0;
       c1nfx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nfw() //  [R1]
         { info_tbl: [(c1nfw,
                       label: block_c1nfw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nfw: // global
           I64[Sp - 8] = block_c1nfC_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nfC() //  [R1]
         { info_tbl: [(c1nfC,
                       label: block_c1nfC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nfC: // global
           I64[Sp] = block_c1nfG_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nfG() //  [R1]
         { info_tbl: [(c1nfG,
                       label: block_c1nfG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nfG: // global
           I64[Sp] = block_c1nfK_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1nfK() //  [R1]
         { info_tbl: [(c1nfK,
                       label: block_c1nfK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nfK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nfU; else goto c1nfT;
       c1nfU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nfT: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.358024267 UTC

[section ""data" . GHC.Real.$w$csignum_closure" {
     GHC.Real.$w$csignum_closure:
         const GHC.Real.$w$csignum_info;
         const 0;
 },
 GHC.Real.$w$csignum_entry() //  [R2, R3]
         { info_tbl: [(c1ng2,
                       label: GHC.Real.$w$csignum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ng2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ngc; else goto c1ngd;
       c1ngc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$csignum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ngd: // global
           I64[Sp - 16] = block_c1ng0_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ng0() //  [R1]
         { info_tbl: [(c1ng0,
                       label: block_c1ng0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ng0: // global
           I64[Sp] = block_c1ng5_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ng5() //  [R1]
         { info_tbl: [(c1ng5,
                       label: block_c1ng5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ng5: // global
           I64[Sp] = block_c1ng9_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1ng9() //  [R1]
         { info_tbl: [(c1ng9,
                       label: block_c1ng9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ng9: // global
           I64[Sp] = block_c1ngb_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Real.$fEnumRatio1_closure;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1ngb() //  [R1]
         { info_tbl: [(c1ngb,
                       label: block_c1ngb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ngb: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.359707982 UTC

[section ""data" . GHC.Real.$fNumRatio_$csignum_closure" {
     GHC.Real.$fNumRatio_$csignum_closure:
         const GHC.Real.$fNumRatio_$csignum_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$csignum_entry() //  [R2, R3]
         { info_tbl: [(c1ngq,
                       label: GHC.Real.$fNumRatio_$csignum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ngq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ngw; else goto c1ngx;
       c1ngw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$csignum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ngx: // global
           I64[Sp - 16] = block_c1ngn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1ngC; else goto c1ngo;
       u1ngC: // global
           call _c1ngn(R1) args: 0, res: 0, upd: 0;
       c1ngo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ngn() //  [R1]
         { info_tbl: [(c1ngn,
                       label: block_c1ngn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ngn: // global
           _s1jpm::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1ngt_info;
           R3 = P64[R1 + 7];
           R2 = _s1jpm::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$csignum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ngt() //  [R1, R2]
         { info_tbl: [(c1ngt,
                       label: block_c1ngt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ngt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ngB; else goto c1ngA;
       c1ngB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1ngA: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.361309088 UTC

[section ""data" . GHC.Real.$w$cfromInteger_closure" {
     GHC.Real.$w$cfromInteger_closure:
         const GHC.Real.$w$cfromInteger_info;
         const 0;
 },
 GHC.Real.$w$cfromInteger_entry() //  [R2, R3]
         { info_tbl: [(c1ngJ,
                       label: GHC.Real.$w$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ngJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ngT; else goto c1ngU;
       c1ngT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cfromInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ngU: // global
           I64[Sp - 16] = block_c1ngH_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ngH() //  [R1]
         { info_tbl: [(c1ngH,
                       label: block_c1ngH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ngH: // global
           I64[Sp] = block_c1ngM_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ngM() //  [R1]
         { info_tbl: [(c1ngM,
                       label: block_c1ngM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ngM: // global
           I64[Sp] = block_c1ngQ_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1ngQ() //  [R1]
         { info_tbl: [(c1ngQ,
                       label: block_c1ngQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ngQ: // global
           I64[Sp] = block_c1ngS_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Real.$fEnumRatio1_closure;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1ngS() //  [R1]
         { info_tbl: [(c1ngS,
                       label: block_c1ngS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ngS: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.362936743 UTC

[section ""data" . GHC.Real.$fNumRatio_$cfromInteger_closure" {
     GHC.Real.$fNumRatio_$cfromInteger_closure:
         const GHC.Real.$fNumRatio_$cfromInteger_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$cfromInteger_entry() //  [R2, R3]
         { info_tbl: [(c1nh7,
                       label: GHC.Real.$fNumRatio_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nh7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1nh8; else goto c1nh9;
       c1nh8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$cfromInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nh9: // global
           I64[Sp - 8] = block_c1nh4_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nh4() //  [R1, R2]
         { info_tbl: [(c1nh4,
                       label: block_c1nh4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nh4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nhc; else goto c1nhb;
       c1nhc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nhb: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.364123144 UTC

[section ""data" . GHC.Real.$fRealRatio_$s$ctoRational_closure" {
     GHC.Real.$fRealRatio_$s$ctoRational_closure:
         const GHC.Real.$fRealRatio_$s$ctoRational_info;
 },
 GHC.Real.$fRealRatio_$s$ctoRational_entry() //  [R2]
         { info_tbl: [(c1nhh,
                       label: GHC.Real.$fRealRatio_$s$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nhh: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.365231058 UTC

[section ""data" . GHC.Real.$fRealRatio_$ctoRational_closure" {
     GHC.Real.$fRealRatio_$ctoRational_closure:
         const GHC.Real.$fRealRatio_$ctoRational_info;
 },
 GHC.Real.$fRealRatio_$ctoRational_entry() //  [R2, R3]
         { info_tbl: [(c1nhr,
                       label: GHC.Real.$fRealRatio_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nhr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nhD; else goto c1nhE;
       c1nhD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealRatio_$ctoRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nhE: // global
           I64[Sp - 16] = block_c1nho_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nhK; else goto c1nhp;
       u1nhK: // global
           call _c1nho(R1) args: 0, res: 0, upd: 0;
       c1nhp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nho() //  [R1]
         { info_tbl: [(c1nho,
                       label: block_c1nho_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nho: // global
           I64[Sp - 8] = block_c1nhu_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1nhu() //  [R1]
         { info_tbl: [(c1nhu,
                       label: block_c1nhu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nhu: // global
           _s1jpK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nhy_info;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = _s1jpK::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 8;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1nhy() //  [R1]
         { info_tbl: [(c1nhy,
                       label: block_c1nhy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nhy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nhJ; else goto c1nhI;
       c1nhJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nhI: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.368083889 UTC

[section ""data" . GHC.Real.$w$crecip_closure" {
     GHC.Real.$w$crecip_closure:
         const GHC.Real.$w$crecip_info;
         const 0;
 },
 $dNum_s1jpR_entry() //  [R1]
         { info_tbl: [(c1nhX,
                       label: $dNum_s1jpR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nhX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nhY; else goto c1nhZ;
       c1nhY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nhZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jpU_entry() //  [R1]
         { info_tbl: [(c1ni8,
                       label: sat_s1jpU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ni8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ni9; else goto c1nia;
       c1ni9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nia: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jpW_entry() //  [R1]
         { info_tbl: [(c1nin,
                       label: sat_s1jpW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nin: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nio; else goto c1nip;
       c1nio: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nip: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1nj2_srtd" {
     u1nj2_srtd:
         const S1jKw_srt+296;
         const 66;
         const 281474976710657;
         const 2;
 },
 GHC.Real.$w$crecip_entry() //  [R2, R3, R4]
         { info_tbl: [(c1niq,
                       label: GHC.Real.$w$crecip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1niq: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1nir; else goto c1nis;
       c1nir: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$crecip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nis: // global
           I64[Sp - 24] = block_c1nhP_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nj3_srtd" {
     u1nj3_srtd:
         const S1jKw_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1nhP() //  [R1]
         { info_tbl: [(c1nhP,
                       label: block_c1nhP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nhP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1niv; else goto c1niu;
       c1niv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1niu: // global
           I64[Hp - 16] = $dNum_s1jpR_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1ni0_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nj4_srtd" {
     u1nj4_srtd:
         const S1jKw_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1ni0() //  [R1]
         { info_tbl: [(c1ni0,
                       label: block_c1ni0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ni0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1niy; else goto c1nix;
       c1niy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nix: // global
           I64[Hp - 16] = sat_s1jpU_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = block_c1nib_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nj5_srtd" {
     u1nj5_srtd:
         const S1jKw_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1nib() //  [R1]
         { info_tbl: [(c1nib,
                       label: block_c1nib_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nib: // global
           I64[Sp] = block_c1nif_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nj6_srtd" {
     u1nj6_srtd:
         const S1jKw_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1nif() //  [R1]
         { info_tbl: [(c1nif,
                       label: block_c1nif_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nif: // global
           if (R1 & 7 == 1) goto c1niC; else goto c1niZ;
       c1niC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1niF; else goto c1niE;
       c1niF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1niE: // global
           I64[Hp - 16] = sat_s1jpW_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 16] = block_c1niA_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 32];
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
       c1niZ: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1niA() //  [R1]
         { info_tbl: [(c1niA,
                       label: block_c1niA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1niA: // global
           _s1jpP::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c1niL; else goto c1niS;
       c1niL: // global
           R2 = P64[Sp + 16];
           R1 = _s1jpP::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c1niS: // global
           I64[Sp] = block_c1niO_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s1jpP::P64;
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1niO() //  [R1]
         { info_tbl: [(c1niO,
                       label: block_c1niO_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1niO: // global
           _s1jpO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1niQ_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = _s1jpO::P64;
           P64[Sp + 24] = R1;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1niQ() //  [R1]
         { info_tbl: [(c1niQ,
                       label: block_c1niQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1niQ: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.371970277 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$crecip_closure" {
     GHC.Real.$fFractionalRatio_$crecip_closure:
         const GHC.Real.$fFractionalRatio_$crecip_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$crecip_entry() //  [R2, R3]
         { info_tbl: [(c1nje,
                       label: GHC.Real.$fFractionalRatio_$crecip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nje: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1njk; else goto c1njl;
       c1njk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$crecip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1njl: // global
           I64[Sp - 16] = block_c1njb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1njq; else goto c1njc;
       u1njq: // global
           call _c1njb(R1) args: 0, res: 0, upd: 0;
       c1njc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1njb() //  [R1]
         { info_tbl: [(c1njb,
                       label: block_c1njb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1njb: // global
           _s1jq1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1njh_info;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = _s1jq1::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$crecip_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1njh() //  [R1, R2]
         { info_tbl: [(c1njh,
                       label: block_c1njh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1njh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1njp; else goto c1njo;
       c1njp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1njo: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.376017618 UTC

[section ""data" . GHC.Real.$w$s$cproperFraction_closure" {
     GHC.Real.$w$s$cproperFraction_closure:
         const GHC.Real.$w$s$cproperFraction_info;
         const 0;
 },
 section ""relreadonly" . u1nkG_srtd" {
     u1nkG_srtd:
         const S1jKw_srt+424;
         const 33;
         const 4294967297;
 },
 ds_s1jqc_entry() //  [R1]
         { info_tbl: [(c1njE,
                       label: ds_s1jqc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1njE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1njF; else goto c1njG;
       c1njF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1njG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c1njz_info;
           R3 = GHC.Real.even1_closure;
           _s1jqb::P64 = P64[R1 + 24];
           R2 = _s1jqb::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s1jqb::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1njz() //  [R1]
         { info_tbl: [(c1njz,
                       label: block_c1njz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1njz: // global
           if (R1 == 1) goto c1njD; else goto c1njC;
       c1njD: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c1njC: // global
           _s1jqb::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1njJ_info;
           R3 = _s1jqb::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1njJ() //  [R1, R2]
         { info_tbl: [(c1njJ,
                       label: block_c1njJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1njJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1njP; else goto c1njO;
       c1njP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1njO: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jqs_entry() //  [R1]
         { info_tbl: [(c1nk0,
                       label: sat_s1jqs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nk0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nk9; else goto c1nka;
       c1nk9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nka: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1njX_info;
           _s1jqb::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s1jqb::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1nkg; else goto c1njY;
       u1nkg: // global
           call _c1njX(R1) args: 0, res: 0, upd: 0;
       c1njY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1njX() //  [R1]
         { info_tbl: [(c1njX,
                       label: block_c1njX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1njX: // global
           I64[Sp] = block_c1nk3_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto u1nkf; else goto c1nk4;
       u1nkf: // global
           call _c1nk3(R1) args: 0, res: 0, upd: 0;
       c1nk4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1nk3() //  [R1]
         { info_tbl: [(c1nk3,
                       label: block_c1nk3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nk3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nke; else goto c1nkd;
       c1nke: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1nkd: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jqn_entry() //  [R1]
         { info_tbl: [(c1nko,
                       label: sat_s1jqn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nko: // global
           _s1jqn::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1nks; else goto c1nkt;
       c1nkt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nkv; else goto c1nku;
       c1nkv: // global
           HpAlloc = 24;
           goto c1nks;
       c1nks: // global
           R1 = _s1jqn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nku: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jqn::P64;
           _s1jq9::P64 = P64[_s1jqn::P64 + 16];
           _s1jqc::P64 = P64[_s1jqn::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1jqc::P64;
           I64[Sp - 32] = block_c1nkm_info;
           R2 = _s1jq9::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1nkm() //  [R1]
         { info_tbl: [(c1nkm,
                       label: block_c1nkm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nkm: // global
           I64[Sp] = block_c1nkr_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1nkr() //  [R1]
         { info_tbl: [(c1nkr,
                       label: block_c1nkr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nkr: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$s$cproperFraction_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nkB,
                       label: GHC.Real.$w$s$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nkB: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1nkF; else goto c1nkE;
       c1nkF: // global
           HpAlloc = 96;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nkE: // global
           I64[Hp - 88] = ds_s1jqc_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_s1jqs_info;
           P64[Hp - 40] = R4;
           _c1njv::P64 = Hp - 88;
           P64[Hp - 32] = _c1njv::P64;
           I64[Hp - 24] = sat_s1jqn_info;
           P64[Hp - 8] = R2;
           P64[Hp] = _c1njv::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.379457179 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$cproperFraction_closure" {
     GHC.Real.$fEnumRatio_$s$cproperFraction_closure:
         const GHC.Real.$fEnumRatio_$s$cproperFraction_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$cproperFraction_entry() //  [R2, R3]
         { info_tbl: [(c1nkO,
                       label: GHC.Real.$fEnumRatio_$s$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nkO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nkU; else goto c1nkV;
       c1nkU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$cproperFraction_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nkV: // global
           I64[Sp - 16] = block_c1nkL_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nl0; else goto c1nkM;
       u1nl0: // global
           call _c1nkL(R1) args: 0, res: 0, upd: 0;
       c1nkM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nkL() //  [R1]
         { info_tbl: [(c1nkL,
                       label: block_c1nkL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nkL: // global
           _s1jqt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nkR_info;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = _s1jqt::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nkR() //  [R1, R2]
         { info_tbl: [(c1nkR,
                       label: block_c1nkR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nkR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nkZ; else goto c1nkY;
       c1nkZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nkY: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.381929195 UTC

[section ""data" . GHC.Real.$w$cproperFraction_closure" {
     GHC.Real.$w$cproperFraction_closure:
         const GHC.Real.$w$cproperFraction_info;
 },
 ds_s1jqF_entry() //  [R1]
         { info_tbl: [(c1nl9,
                       label: ds_s1jqF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nl9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nla; else goto c1nlb;
       c1nla: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nlb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.quotRem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jqS_entry() //  [R1]
         { info_tbl: [(c1nlj,
                       label: sat_s1jqS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nlj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nlp; else goto c1nlq;
       c1nlp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nlq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1nlg_info;
           _s1jqE::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s1jqE::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1nlv; else goto c1nlh;
       u1nlv: // global
           call _c1nlg(R1) args: 0, res: 0, upd: 0;
       c1nlh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1nlg() //  [R1]
         { info_tbl: [(c1nlg,
                       label: block_c1nlg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nlg: // global
           I64[Sp] = block_c1nlm_info;
           R1 = P64[R1 + 15];
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1nlm() //  [R1]
         { info_tbl: [(c1nlm,
                       label: block_c1nlm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nlm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nlu; else goto c1nlt;
       c1nlu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1nlt: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jqM_entry() //  [R1]
         { info_tbl: [(c1nlF,
                       label: sat_s1jqM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nlF: // global
           _s1jqM::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1nlG; else goto c1nlH;
       c1nlH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nlJ; else goto c1nlI;
       c1nlJ: // global
           HpAlloc = 24;
           goto c1nlG;
       c1nlG: // global
           R1 = _s1jqM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nlI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jqM::P64;
           _s1jqB::P64 = P64[_s1jqM::P64 + 16];
           _s1jqF::P64 = P64[_s1jqM::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1jqF::P64;
           R2 = _s1jqB::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jqN_entry() //  [R1]
         { info_tbl: [(c1nlM,
                       label: sat_s1jqN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nlM: // global
           _s1jqN::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1nlQ; else goto c1nlR;
       c1nlR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1nlT; else goto c1nlS;
       c1nlT: // global
           HpAlloc = 32;
           goto c1nlQ;
       c1nlQ: // global
           R1 = _s1jqN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nlS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jqN::P64;
           _s1jqB::P64 = P64[_s1jqN::P64 + 16];
           _s1jqC::P64 = P64[_s1jqN::P64 + 24];
           _s1jqF::P64 = P64[_s1jqN::P64 + 32];
           I64[Hp - 24] = sat_s1jqM_info;
           P64[Hp - 8] = _s1jqB::P64;
           P64[Hp] = _s1jqF::P64;
           I64[Sp - 32] = block_c1nlK_info;
           R2 = _s1jqC::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1nlK() //  [R1]
         { info_tbl: [(c1nlK,
                       label: block_c1nlK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nlK: // global
           I64[Sp] = block_c1nlP_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1nlP() //  [R1]
         { info_tbl: [(c1nlP,
                       label: block_c1nlP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nlP: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$cproperFraction_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1nlZ,
                       label: GHC.Real.$w$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nlZ: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1nm3; else goto c1nm2;
       c1nm3: // global
           HpAlloc = 112;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cproperFraction_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nm2: // global
           I64[Hp - 104] = ds_s1jqF_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R5;
           I64[Hp - 64] = sat_s1jqS_info;
           P64[Hp - 48] = R5;
           _c1nl5::P64 = Hp - 104;
           P64[Hp - 40] = _c1nl5::P64;
           I64[Hp - 32] = sat_s1jqN_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = _c1nl5::P64;
           R2 = Hp - 64;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.385053069 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cproperFraction_closure" {
     GHC.Real.$fEnumRatio_$cproperFraction_closure:
         const GHC.Real.$fEnumRatio_$cproperFraction_info;
 },
 GHC.Real.$fEnumRatio_$cproperFraction_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nmb,
                       label: GHC.Real.$fEnumRatio_$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nmb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nmh; else goto c1nmi;
       c1nmh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nmi: // global
           I64[Sp - 24] = block_c1nm8_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1nmn; else goto c1nm9;
       u1nmn: // global
           call _c1nm8(R1) args: 0, res: 0, upd: 0;
       c1nm9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nm8() //  [R1]
         { info_tbl: [(c1nm8,
                       label: block_c1nm8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nm8: // global
           _s1jqU::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1nme_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _s1jqU::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nme() //  [R1, R2]
         { info_tbl: [(c1nme,
                       label: block_c1nme_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nme: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nmm; else goto c1nml;
       c1nmm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nml: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.387429381 UTC

[section ""data" . GHC.Real.$wreduce_closure" {
     GHC.Real.$wreduce_closure:
         const GHC.Real.$wreduce_info;
         const 0;
 },
 sat_s1jr9_entry() //  [R1]
         { info_tbl: [(c1nmC,
                       label: sat_s1jr9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nmC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nmD; else goto c1nmE;
       c1nmD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nmE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1nmA_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1nmA() //  [R1]
         { info_tbl: [(c1nmA,
                       label: block_c1nmA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nmA: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 d_s1jrb_entry() //  [R1]
         { info_tbl: [(c1nmY,
                       label: d_s1jrb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nmY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nmZ; else goto c1nn0;
       c1nmZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nn0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.gcd_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1nnp_srtd" {
     u1nnp_srtd:
         const S1jKw_srt+296;
         const 72;
         const 281474976710657;
         const 192;
 },
 GHC.Real.$wreduce_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nn1,
                       label: GHC.Real.$wreduce_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nn1: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1nn2; else goto c1nn3;
       c1nn2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wreduce_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nn3: // global
           I64[Sp - 32] = block_c1nms_info;
           _s1jr2::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1jr2::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nnq_srtd" {
     u1nnq_srtd:
         const S1jKw_srt+296;
         const 71;
         const 281474976710657;
         const 64;
 },
 _c1nms() //  [R1]
         { info_tbl: [(c1nms,
                       label: block_c1nms_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nms: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nn6; else goto c1nn5;
       c1nn6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nn5: // global
           I64[Hp - 16] = sat_s1jr9_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1nmI_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nnr_srtd" {
     u1nnr_srtd:
         const S1jKw_srt+296;
         const 71;
         const 1;
         const 64;
 },
 _c1nmI() //  [R1]
         { info_tbl: [(c1nmI,
                       label: block_c1nmI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nmI: // global
           I64[Sp] = block_c1nmM_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nns_srtd" {
     u1nns_srtd:
         const S1jKw_srt+296;
         const 71;
         const 1;
         const 64;
 },
 _c1nmM() //  [R1]
         { info_tbl: [(c1nmM,
                       label: block_c1nmM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nmM: // global
           _c1nmw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nmQ_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = _c1nmw::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nnt_srtd" {
     u1nnt_srtd:
         const S1jKw_srt+296;
         const 71;
         const 1;
         const 64;
 },
 _c1nmQ() //  [R1]
         { info_tbl: [(c1nmQ,
                       label: block_c1nmQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nmQ: // global
           if (R1 & 7 == 1) goto c1nnd; else goto c1nnn;
       c1nnd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1nng; else goto c1nnf;
       c1nng: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nnf: // global
           I64[Hp - 32] = d_s1jrb_info;
           _s1jr2::P64 = P64[Sp + 8];
           P64[Hp - 16] = _s1jr2::P64;
           _s1jr3::P64 = P64[Sp + 16];
           P64[Hp - 8] = _s1jr3::P64;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_c1nn9_info;
           R2 = _s1jr2::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jr3::P64;
           _c1nmU::P64 = Hp - 32;
           P64[Sp - 8] = _c1nmU::P64;
           P64[Sp + 16] = _c1nmU::P64;
           Sp = Sp - 24;
           call GHC.Real.quot_entry(R2) args: 32, res: 8, upd: 8;
       c1nnn: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1nn9() //  [R1]
         { info_tbl: [(c1nn9,
                       label: block_c1nn9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nn9: // global
           _c1nmU::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1nnb_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 24];
           P64[Sp + 8] = _c1nmU::P64;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call GHC.Real.quot_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1nnb() //  [R1]
         { info_tbl: [(c1nnb,
                       label: block_c1nnb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nnb: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.390731391 UTC

[section ""data" . GHC.Real.reduce_closure" {
     GHC.Real.reduce_closure:
         const GHC.Real.reduce_info;
         const 0;
 },
 GHC.Real.reduce_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nnB,
                       label: GHC.Real.reduce_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nnB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1nnC; else goto c1nnD;
       c1nnC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.reduce_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nnD: // global
           I64[Sp - 8] = block_c1nny_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nny() //  [R1, R2]
         { info_tbl: [(c1nny,
                       label: block_c1nny_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nny: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nnG; else goto c1nnF;
       c1nnG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nnF: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.392063865 UTC

[section ""data" . GHC.Real.%_$s%_closure" {
     GHC.Real.%_$s%_closure:
         const GHC.Real.%_$s%_info;
         const 0;
 },
 GHC.Real.%_$s%_entry() //  [R2, R3]
         { info_tbl: [(c1nnO,
                       label: GHC.Real.%_$s%_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nnO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1nnP; else goto c1nnQ;
       c1nnP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.%_$s%_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nnQ: // global
           I64[Sp - 8] = block_c1nnL_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$s$cfromRational_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nnL() //  [R1, R2]
         { info_tbl: [(c1nnL,
                       label: block_c1nnL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nnL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nnT; else goto c1nnS;
       c1nnT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nnS: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.394389687 UTC

[section ""data" . GHC.Real.$w%_closure" {
     GHC.Real.$w%_closure:
         const GHC.Real.$w%_info;
         const 0;
 },
 $dReal_s1jrt_entry() //  [R1]
         { info_tbl: [(c1no2,
                       label: $dReal_s1jrt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1no2: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jru_entry() //  [R1]
         { info_tbl: [(c1no9,
                       label: $dNum_s1jru_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1no9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1noa; else goto c1nob;
       c1noa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nob: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jrx_entry() //  [R1]
         { info_tbl: [(c1nog,
                       label: sat_s1jrx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nog: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1noh; else goto c1noi;
       c1noh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1noi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jrv_entry() //  [R1]
         { info_tbl: [(c1nor,
                       label: sat_s1jrv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nor: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nos; else goto c1not;
       c1nos: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1not: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jrw_entry() //  [R1]
         { info_tbl: [(c1nou,
                       label: sat_s1jrw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nou: // global
           _s1jrw::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1nov; else goto c1now;
       c1now: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1noy; else goto c1nox;
       c1noy: // global
           HpAlloc = 32;
           goto c1nov;
       c1nov: // global
           R1 = _s1jrw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nox: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jrw::P64;
           _s1jrr::P64 = P64[_s1jrw::P64 + 16];
           _s1jrs::P64 = P64[_s1jrw::P64 + 24];
           _s1jru::P64 = P64[_s1jrw::P64 + 32];
           I64[Hp - 24] = sat_s1jrv_info;
           P64[Hp - 8] = _s1jrs::P64;
           P64[Hp] = _s1jru::P64;
           R2 = _s1jru::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1jrr::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w%_entry() //  [R2, R3, R4]
         { info_tbl: [(c1noz,
                       label: GHC.Real.$w%_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1noz: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c1noD; else goto c1noC;
       c1noD: // global
           HpAlloc = 120;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w%_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1noC: // global
           I64[Hp - 112] = $dReal_s1jrt_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = $dNum_s1jru_info;
           P64[Hp - 72] = Hp - 112;
           I64[Hp - 64] = sat_s1jrx_info;
           P64[Hp - 48] = R4;
           _c1no5::P64 = Hp - 88;
           P64[Hp - 40] = _c1no5::P64;
           I64[Hp - 32] = sat_s1jrw_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = _c1no5::P64;
           R4 = Hp - 64;
           R3 = Hp - 32;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.396823987 UTC

[section ""data" . GHC.Real.%_closure" {
     GHC.Real.%_closure:
         const GHC.Real.%_info;
         const 0;
 },
 GHC.Real.%_entry() //  [R2, R3, R4]
         { info_tbl: [(c1noL,
                       label: GHC.Real.%_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1noL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1noM; else goto c1noN;
       c1noM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.%_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1noN: // global
           I64[Sp - 8] = block_c1noI_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w%_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1noI() //  [R1, R2]
         { info_tbl: [(c1noI,
                       label: block_c1noI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1noI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1noQ; else goto c1noP;
       c1noQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1noP: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.398637754 UTC

[section ""data" . GHC.Real.$w$c/_closure" {
     GHC.Real.$w$c/_closure:
         const GHC.Real.$w$c/_info;
         const 0;
 },
 $dReal_s1jrJ_entry() //  [R1]
         { info_tbl: [(c1noZ,
                       label: $dReal_s1jrJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1noZ: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jrK_entry() //  [R1]
         { info_tbl: [(c1np6,
                       label: $dNum_s1jrK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1np6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1np7; else goto c1np8;
       c1np7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1np8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jrM_entry() //  [R1]
         { info_tbl: [(c1npd,
                       label: sat_s1jrM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1npd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1npe; else goto c1npf;
       c1npe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1npf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jrL_entry() //  [R1]
         { info_tbl: [(c1npk,
                       label: sat_s1jrL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1npk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1npl; else goto c1npm;
       c1npl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1npm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c/_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1npn,
                       label: GHC.Real.$w$c/_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1npn: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto c1npr; else goto c1npq;
       c1npr: // global
           HpAlloc = 128;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c/_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1npq: // global
           I64[Hp - 120] = $dReal_s1jrJ_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = $dNum_s1jrK_info;
           P64[Hp - 80] = Hp - 120;
           I64[Hp - 72] = sat_s1jrM_info;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           _c1np2::P64 = Hp - 96;
           P64[Hp - 40] = _c1np2::P64;
           I64[Hp - 32] = sat_s1jrL_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R6;
           P64[Hp] = _c1np2::P64;
           R4 = Hp - 72;
           R3 = Hp - 32;
           R2 = R2;
           call GHC.Real.$w%_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.400903436 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$c/_closure" {
     GHC.Real.$fFractionalRatio_$c/_closure:
         const GHC.Real.$fFractionalRatio_$c/_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$c/_entry() //  [R2, R3, R4]
         { info_tbl: [(c1npz,
                       label: GHC.Real.$fFractionalRatio_$c/_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1npz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1npK; else goto c1npL;
       c1npK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$c/_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1npL: // global
           I64[Sp - 24] = block_c1npw_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1npS; else goto c1npx;
       u1npS: // global
           call _c1npw(R1) args: 0, res: 0, upd: 0;
       c1npx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1npw() //  [R1]
         { info_tbl: [(c1npw,
                       label: block_c1npw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1npw: // global
           I64[Sp - 8] = block_c1npC_info;
           _s1jrR::P64 = P64[R1 + 7];
           _s1jrS::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jrS::P64;
           P64[Sp + 16] = _s1jrR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1npR; else goto c1npD;
       u1npR: // global
           call _c1npC(R1) args: 0, res: 0, upd: 0;
       c1npD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1npC() //  [R1]
         { info_tbl: [(c1npC,
                       label: block_c1npC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1npC: // global
           _s1jrR::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1npH_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jrR::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c/_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1npH() //  [R1, R2]
         { info_tbl: [(c1npH,
                       label: block_c1npH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1npH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1npQ; else goto c1npP;
       c1npQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1npP: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.403195949 UTC

[section ""data" . GHC.Real.$w$cfromRational_closure" {
     GHC.Real.$w$cfromRational_closure:
         const GHC.Real.$w$cfromRational_info;
         const 0;
 },
 $dReal_s1js2_entry() //  [R1]
         { info_tbl: [(c1nq1,
                       label: $dReal_s1js2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nq1: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1js3_entry() //  [R1]
         { info_tbl: [(c1nq8,
                       label: $dNum_s1js3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nq8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nq9; else goto c1nqa;
       c1nq9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nqa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1js5_entry() //  [R1]
         { info_tbl: [(c1nqf,
                       label: sat_s1js5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nqf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nqg; else goto c1nqh;
       c1nqg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nqh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1js4_entry() //  [R1]
         { info_tbl: [(c1nqm,
                       label: sat_s1js4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nqm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nqn; else goto c1nqo;
       c1nqn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nqo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$cfromRational_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nqp,
                       label: GHC.Real.$w$cfromRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nqp: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1nqt; else goto c1nqs;
       c1nqt: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cfromRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nqs: // global
           I64[Hp - 104] = $dReal_s1js2_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_s1js3_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = sat_s1js5_info;
           P64[Hp - 40] = R4;
           _c1nq4::P64 = Hp - 80;
           P64[Hp - 32] = _c1nq4::P64;
           I64[Hp - 24] = sat_s1js4_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _c1nq4::P64;
           R4 = Hp - 56;
           R3 = Hp - 24;
           R2 = R2;
           call GHC.Real.$w%_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.405489322 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$cfromRational_closure" {
     GHC.Real.$fFractionalRatio_$cfromRational_closure:
         const GHC.Real.$fFractionalRatio_$cfromRational_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$cfromRational_entry() //  [R2, R3]
         { info_tbl: [(c1nqB,
                       label: GHC.Real.$fFractionalRatio_$cfromRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nqB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nqH; else goto c1nqI;
       c1nqH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$cfromRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nqI: // global
           I64[Sp - 16] = block_c1nqy_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nqN; else goto c1nqz;
       u1nqN: // global
           call _c1nqy(R1) args: 0, res: 0, upd: 0;
       c1nqz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nqy() //  [R1]
         { info_tbl: [(c1nqy,
                       label: block_c1nqy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nqy: // global
           _s1js6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nqE_info;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = _s1js6::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$cfromRational_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nqE() //  [R1, R2]
         { info_tbl: [(c1nqE,
                       label: block_c1nqE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nqE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nqM; else goto c1nqL;
       c1nqM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nqL: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.409653854 UTC

[section ""data" . GHC.Real.$w$c+_closure" {
     GHC.Real.$w$c+_closure:
         const GHC.Real.$w$c+_info;
         const 0;
 },
 $dReal_s1jsj_entry() //  [R1]
         { info_tbl: [(c1nqW,
                       label: $dReal_s1jsj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nqW: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jsk_entry() //  [R1]
         { info_tbl: [(c1nr3,
                       label: $dNum_s1jsk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nr3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nr4; else goto c1nr5;
       c1nr4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nr5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jso_entry() //  [R1]
         { info_tbl: [(c1nra,
                       label: sat_s1jso_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nra: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nrb; else goto c1nrc;
       c1nrb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nrc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsm_entry() //  [R1]
         { info_tbl: [(c1nrl,
                       label: sat_s1jsm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nrl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nrm; else goto c1nrn;
       c1nrm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nrn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsl_entry() //  [R1]
         { info_tbl: [(c1nrs,
                       label: sat_s1jsl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nrs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nrt; else goto c1nru;
       c1nrt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nru: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsn_entry() //  [R1]
         { info_tbl: [(c1nrv,
                       label: sat_s1jsn_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nrv: // global
           _s1jsn::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1nrw; else goto c1nrx;
       c1nrx: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1nrz; else goto c1nry;
       c1nrz: // global
           HpAlloc = 80;
           goto c1nrw;
       c1nrw: // global
           R1 = _s1jsn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nry: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jsn::P64;
           _s1jsf::P64 = P64[_s1jsn::P64 + 16];
           _s1jsg::P64 = P64[_s1jsn::P64 + 24];
           _s1jsh::P64 = P64[_s1jsn::P64 + 32];
           _s1jsi::P64 = P64[_s1jsn::P64 + 40];
           _s1jsk::P64 = P64[_s1jsn::P64 + 48];
           I64[Hp - 72] = sat_s1jsm_info;
           P64[Hp - 56] = _s1jsg::P64;
           P64[Hp - 48] = _s1jsh::P64;
           P64[Hp - 40] = _s1jsk::P64;
           I64[Hp - 32] = sat_s1jsl_info;
           P64[Hp - 16] = _s1jsf::P64;
           P64[Hp - 8] = _s1jsi::P64;
           P64[Hp] = _s1jsk::P64;
           R2 = _s1jsk::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c+_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1nrA,
                       label: GHC.Real.$w$c+_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nrA: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1nrE; else goto c1nrD;
       c1nrE: // global
           HpAlloc = 144;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c+_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nrD: // global
           I64[Hp - 136] = $dReal_s1jsj_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = $dNum_s1jsk_info;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = sat_s1jso_info;
           P64[Hp - 72] = R4;
           P64[Hp - 64] = R6;
           _c1nqZ::P64 = Hp - 112;
           P64[Hp - 56] = _c1nqZ::P64;
           I64[Hp - 48] = sat_s1jsn_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _c1nqZ::P64;
           R4 = Hp - 88;
           R3 = Hp - 48;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.412700963 UTC

[section ""data" . GHC.Real.$fNumRatio_$c+_closure" {
     GHC.Real.$fNumRatio_$c+_closure:
         const GHC.Real.$fNumRatio_$c+_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$c+_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nrM,
                       label: GHC.Real.$fNumRatio_$c+_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nrM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nrX; else goto c1nrY;
       c1nrX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$c+_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nrY: // global
           I64[Sp - 24] = block_c1nrJ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1ns5; else goto c1nrK;
       u1ns5: // global
           call _c1nrJ(R1) args: 0, res: 0, upd: 0;
       c1nrK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nrJ() //  [R1]
         { info_tbl: [(c1nrJ,
                       label: block_c1nrJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nrJ: // global
           I64[Sp - 8] = block_c1nrP_info;
           _s1jst::P64 = P64[R1 + 7];
           _s1jsu::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jsu::P64;
           P64[Sp + 16] = _s1jst::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ns4; else goto c1nrQ;
       u1ns4: // global
           call _c1nrP(R1) args: 0, res: 0, upd: 0;
       c1nrQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nrP() //  [R1]
         { info_tbl: [(c1nrP,
                       label: block_c1nrP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nrP: // global
           _s1jst::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1nrU_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jst::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c+_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nrU() //  [R1, R2]
         { info_tbl: [(c1nrU,
                       label: block_c1nrU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nrU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ns3; else goto c1ns2;
       c1ns3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1ns2: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.415694113 UTC

[section ""data" . GHC.Real.$w$c-_closure" {
     GHC.Real.$w$c-_closure:
         const GHC.Real.$w$c-_info;
         const 0;
 },
 $dReal_s1jsG_entry() //  [R1]
         { info_tbl: [(c1nse,
                       label: $dReal_s1jsG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nse: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jsH_entry() //  [R1]
         { info_tbl: [(c1nsl,
                       label: $dNum_s1jsH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nsl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nsm; else goto c1nsn;
       c1nsm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nsn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jsL_entry() //  [R1]
         { info_tbl: [(c1nss,
                       label: sat_s1jsL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nss: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nst; else goto c1nsu;
       c1nst: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nsu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsJ_entry() //  [R1]
         { info_tbl: [(c1nsD,
                       label: sat_s1jsJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nsD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nsE; else goto c1nsF;
       c1nsE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nsF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsI_entry() //  [R1]
         { info_tbl: [(c1nsK,
                       label: sat_s1jsI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nsK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nsL; else goto c1nsM;
       c1nsL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nsM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsK_entry() //  [R1]
         { info_tbl: [(c1nsN,
                       label: sat_s1jsK_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nsN: // global
           _s1jsK::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1nsO; else goto c1nsP;
       c1nsP: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1nsR; else goto c1nsQ;
       c1nsR: // global
           HpAlloc = 80;
           goto c1nsO;
       c1nsO: // global
           R1 = _s1jsK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nsQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jsK::P64;
           _s1jsC::P64 = P64[_s1jsK::P64 + 16];
           _s1jsD::P64 = P64[_s1jsK::P64 + 24];
           _s1jsE::P64 = P64[_s1jsK::P64 + 32];
           _s1jsF::P64 = P64[_s1jsK::P64 + 40];
           _s1jsH::P64 = P64[_s1jsK::P64 + 48];
           I64[Hp - 72] = sat_s1jsJ_info;
           P64[Hp - 56] = _s1jsD::P64;
           P64[Hp - 48] = _s1jsE::P64;
           P64[Hp - 40] = _s1jsH::P64;
           I64[Hp - 32] = sat_s1jsI_info;
           P64[Hp - 16] = _s1jsC::P64;
           P64[Hp - 8] = _s1jsF::P64;
           P64[Hp] = _s1jsH::P64;
           R2 = _s1jsH::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c-_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1nsS,
                       label: GHC.Real.$w$c-_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nsS: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1nsW; else goto c1nsV;
       c1nsW: // global
           HpAlloc = 144;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c-_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nsV: // global
           I64[Hp - 136] = $dReal_s1jsG_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = $dNum_s1jsH_info;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = sat_s1jsL_info;
           P64[Hp - 72] = R4;
           P64[Hp - 64] = R6;
           _c1nsh::P64 = Hp - 112;
           P64[Hp - 56] = _c1nsh::P64;
           I64[Hp - 48] = sat_s1jsK_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _c1nsh::P64;
           R4 = Hp - 88;
           R3 = Hp - 48;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.418777297 UTC

[section ""data" . GHC.Real.$fNumRatio_$c-_closure" {
     GHC.Real.$fNumRatio_$c-_closure:
         const GHC.Real.$fNumRatio_$c-_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$c-_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nt4,
                       label: GHC.Real.$fNumRatio_$c-_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nt4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ntf; else goto c1ntg;
       c1ntf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$c-_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ntg: // global
           I64[Sp - 24] = block_c1nt1_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1ntn; else goto c1nt2;
       u1ntn: // global
           call _c1nt1(R1) args: 0, res: 0, upd: 0;
       c1nt2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nt1() //  [R1]
         { info_tbl: [(c1nt1,
                       label: block_c1nt1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nt1: // global
           I64[Sp - 8] = block_c1nt7_info;
           _s1jsQ::P64 = P64[R1 + 7];
           _s1jsR::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jsR::P64;
           P64[Sp + 16] = _s1jsQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ntm; else goto c1nt8;
       u1ntm: // global
           call _c1nt7(R1) args: 0, res: 0, upd: 0;
       c1nt8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nt7() //  [R1]
         { info_tbl: [(c1nt7,
                       label: block_c1nt7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nt7: // global
           _s1jsQ::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1ntc_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jsQ::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c-_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ntc() //  [R1, R2]
         { info_tbl: [(c1ntc,
                       label: block_c1ntc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ntc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ntl; else goto c1ntk;
       c1ntl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1ntk: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.421089569 UTC

[section ""data" . GHC.Real.$w$c*_closure" {
     GHC.Real.$w$c*_closure:
         const GHC.Real.$w$c*_info;
         const 0;
 },
 $dReal_s1jt3_entry() //  [R1]
         { info_tbl: [(c1ntw,
                       label: $dReal_s1jt3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ntw: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jt4_entry() //  [R1]
         { info_tbl: [(c1ntD,
                       label: $dNum_s1jt4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ntD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ntE; else goto c1ntF;
       c1ntE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ntF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jt6_entry() //  [R1]
         { info_tbl: [(c1ntK,
                       label: sat_s1jt6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ntK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ntL; else goto c1ntM;
       c1ntL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ntM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jt5_entry() //  [R1]
         { info_tbl: [(c1ntR,
                       label: sat_s1jt5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ntR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ntS; else goto c1ntT;
       c1ntS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ntT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c*_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1ntU,
                       label: GHC.Real.$w$c*_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ntU: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto c1ntY; else goto c1ntX;
       c1ntY: // global
           HpAlloc = 128;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c*_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ntX: // global
           I64[Hp - 120] = $dReal_s1jt3_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = $dNum_s1jt4_info;
           P64[Hp - 80] = Hp - 120;
           I64[Hp - 72] = sat_s1jt6_info;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R6;
           _c1ntz::P64 = Hp - 96;
           P64[Hp - 40] = _c1ntz::P64;
           I64[Hp - 32] = sat_s1jt5_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R5;
           P64[Hp] = _c1ntz::P64;
           R4 = Hp - 72;
           R3 = Hp - 32;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.423440544 UTC

[section ""data" . GHC.Real.$fNumRatio_$c*_closure" {
     GHC.Real.$fNumRatio_$c*_closure:
         const GHC.Real.$fNumRatio_$c*_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$c*_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nu6,
                       label: GHC.Real.$fNumRatio_$c*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nu6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nuh; else goto c1nui;
       c1nuh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$c*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nui: // global
           I64[Sp - 24] = block_c1nu3_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1nup; else goto c1nu4;
       u1nup: // global
           call _c1nu3(R1) args: 0, res: 0, upd: 0;
       c1nu4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nu3() //  [R1]
         { info_tbl: [(c1nu3,
                       label: block_c1nu3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nu3: // global
           I64[Sp - 8] = block_c1nu9_info;
           _s1jtb::P64 = P64[R1 + 7];
           _s1jtc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jtc::P64;
           P64[Sp + 16] = _s1jtb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1nuo; else goto c1nua;
       u1nuo: // global
           call _c1nu9(R1) args: 0, res: 0, upd: 0;
       c1nua: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nu9() //  [R1]
         { info_tbl: [(c1nu9,
                       label: block_c1nu9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nu9: // global
           _s1jtb::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1nue_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jtb::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c*_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nue() //  [R1, R2]
         { info_tbl: [(c1nue,
                       label: block_c1nue_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nue: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nun; else goto c1num;
       c1nun: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1num: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.425951346 UTC

[section ""data" . GHC.Real.$fNumRatio_closure" {
     GHC.Real.$fNumRatio_closure:
         const GHC.Real.$fNumRatio_info;
         const 0;
 },
 sat_s1jtq_entry() //  [R1, R2]
         { info_tbl: [(c1nuz,
                       label: sat_s1jtq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nuz: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$cfromInteger_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtp_entry() //  [R1, R2]
         { info_tbl: [(c1nuH,
                       label: sat_s1jtp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nuH: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$csignum_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jto_entry() //  [R1, R2]
         { info_tbl: [(c1nuP,
                       label: sat_s1jto_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nuP: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$cabs_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtn_entry() //  [R1, R2]
         { info_tbl: [(c1nuX,
                       label: sat_s1jtn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nuX: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$cnegate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtm_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nv5,
                       label: sat_s1jtm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nv5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fNumRatio_$c*_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtl_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nvd,
                       label: sat_s1jtl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nvd: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fNumRatio_$c-_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtk_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nvl,
                       label: sat_s1jtk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nvl: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fNumRatio_$c+_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fNumRatio_entry() //  [R2]
         { info_tbl: [(c1nvp,
                       label: GHC.Real.$fNumRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nvp: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c1nvt; else goto c1nvs;
       c1nvt: // global
           HpAlloc = 176;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nvs: // global
           I64[Hp - 168] = sat_s1jtq_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1jtp_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s1jto_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s1jtn_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s1jtm_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s1jtl_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1jtk_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 70;
           P64[Hp - 40] = Hp - 86;
           P64[Hp - 32] = Hp - 102;
           P64[Hp - 24] = Hp - 119;
           P64[Hp - 16] = Hp - 135;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 167;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.428033909 UTC

[section ""data" . GHC.Real.$fEnumRatio3_closure" {
     GHC.Real.$fEnumRatio3_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.428915689 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$csucc_closure" {
     GHC.Real.$fEnumRatio_$s$csucc_closure:
         const GHC.Real.$fEnumRatio_$s$csucc_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$csucc_entry() //  [R2]
         { info_tbl: [(c1nvB,
                       label: GHC.Real.$fEnumRatio_$s$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nvB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1nvH; else goto c1nvI;
       c1nvH: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nvI: // global
           I64[Sp - 8] = block_c1nvy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1nvN; else goto c1nvz;
       u1nvN: // global
           call _c1nvy(R1) args: 0, res: 0, upd: 0;
       c1nvz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nvy() //  [R1]
         { info_tbl: [(c1nvy,
                       label: block_c1nvy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nvy: // global
           I64[Sp] = block_c1nvE_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nvE() //  [R1, R2]
         { info_tbl: [(c1nvE,
                       label: block_c1nvE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nvE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nvM; else goto c1nvL;
       c1nvM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nvL: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.430616945 UTC

[section ""data" . GHC.Real.$fEnumRatio_$csucc_closure" {
     GHC.Real.$fEnumRatio_$csucc_closure:
         const GHC.Real.$fEnumRatio_$csucc_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$csucc_entry() //  [R2, R3]
         { info_tbl: [(c1nvV,
                       label: GHC.Real.$fEnumRatio_$csucc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nvV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nw3; else goto c1nw4;
       c1nw3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$csucc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nw4: // global
           I64[Sp - 16] = block_c1nvS_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nwa; else goto c1nvT;
       u1nwa: // global
           call _c1nvS(R1) args: 0, res: 0, upd: 0;
       c1nvT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nvS() //  [R1]
         { info_tbl: [(c1nvS,
                       label: block_c1nvS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nvS: // global
           I64[Sp - 16] = block_c1nvY_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nvY() //  [R1, R2]
         { info_tbl: [(c1nvY,
                       label: block_c1nvY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nvY: // global
           _s1jty::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1nw0_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = _s1jty::P64;
           Sp = Sp + 24;
           call GHC.Real.$w$c+_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nw0() //  [R1, R2]
         { info_tbl: [(c1nw0,
                       label: block_c1nw0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nw0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nw9; else goto c1nw8;
       c1nw9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nw8: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.432463723 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$cpred_closure" {
     GHC.Real.$fEnumRatio_$s$cpred_closure:
         const GHC.Real.$fEnumRatio_$s$cpred_info;
         const 0;
 },
 section ""relreadonly" . u1nwv_srtd" {
     u1nwv_srtd:
         const S1jKw_srt+464;
         const 72;
         const 1;
         const 144;
 },
 GHC.Real.$fEnumRatio_$s$cpred_entry() //  [R2]
         { info_tbl: [(c1nwi,
                       label: GHC.Real.$fEnumRatio_$s$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nwi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1nwo; else goto c1nwp;
       c1nwo: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nwp: // global
           I64[Sp - 8] = block_c1nwf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1nwu; else goto c1nwg;
       u1nwu: // global
           call _c1nwf(R1) args: 0, res: 0, upd: 0;
       c1nwg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nww_srtd" {
     u1nww_srtd:
         const S1jKw_srt+464;
         const 69;
         const 1;
         const 16;
 },
 _c1nwf() //  [R1]
         { info_tbl: [(c1nwf,
                       label: block_c1nwf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nwf: // global
           I64[Sp] = block_c1nwl_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nwl() //  [R1, R2]
         { info_tbl: [(c1nwl,
                       label: block_c1nwl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nwl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nwt; else goto c1nws;
       c1nwt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nws: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.434264974 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cpred_closure" {
     GHC.Real.$fEnumRatio_$cpred_closure:
         const GHC.Real.$fEnumRatio_$cpred_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$cpred_entry() //  [R2, R3]
         { info_tbl: [(c1nwE,
                       label: GHC.Real.$fEnumRatio_$cpred_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nwE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nwM; else goto c1nwN;
       c1nwM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cpred_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nwN: // global
           I64[Sp - 16] = block_c1nwB_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nwT; else goto c1nwC;
       u1nwT: // global
           call _c1nwB(R1) args: 0, res: 0, upd: 0;
       c1nwC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nwB() //  [R1]
         { info_tbl: [(c1nwB,
                       label: block_c1nwB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nwB: // global
           I64[Sp - 16] = block_c1nwH_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nwH() //  [R1, R2]
         { info_tbl: [(c1nwH,
                       label: block_c1nwH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nwH: // global
           _s1jtQ::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1nwJ_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = _s1jtQ::P64;
           Sp = Sp + 24;
           call GHC.Real.$w$c-_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nwJ() //  [R1, R2]
         { info_tbl: [(c1nwJ,
                       label: block_c1nwJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nwJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nwS; else goto c1nwR;
       c1nwS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nwR: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.43636182 UTC

[section ""data" . GHC.Real.$fFractionalRatio_closure" {
     GHC.Real.$fFractionalRatio_closure:
         const GHC.Real.$fFractionalRatio_info;
         const 0;
 },
 sat_s1ju5_entry() //  [R1, R2]
         { info_tbl: [(c1nx3,
                       label: sat_s1ju5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nx3: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fFractionalRatio_$cfromRational_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ju4_entry() //  [R1, R2]
         { info_tbl: [(c1nxb,
                       label: sat_s1ju4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nxb: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fFractionalRatio_$crecip_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ju3_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nxj,
                       label: sat_s1ju3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nxj: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fFractionalRatio_$c/_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ju2_entry() //  [R1]
         { info_tbl: [(c1nxq,
                       label: sat_s1ju2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nxq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nxr; else goto c1nxs;
       c1nxr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nxs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fNumRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fFractionalRatio_entry() //  [R2]
         { info_tbl: [(c1nxu,
                       label: GHC.Real.$fFractionalRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nxu: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1nxy; else goto c1nxx;
       c1nxy: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nxx: // global
           I64[Hp - 104] = sat_s1ju5_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s1ju4_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1ju3_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1ju2_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.438563764 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFrom_closure" {
     GHC.Real.$fEnumRatio_$cenumFrom_closure:
         const GHC.Real.$fEnumRatio_$cenumFrom_info;
         const 0;
 },
 w_s1ju7_entry() //  [R1]
         { info_tbl: [(c1nxH,
                       label: w_s1ju7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nxH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nxI; else goto c1nxJ;
       c1nxI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nxJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1juc_entry() //  [R1, R2]
         { info_tbl: [(c1nxS,
                       label: sat_s1juc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nxS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1nxT; else goto c1nxU;
       c1nxT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nxU: // global
           I64[Sp - 8] = block_c1nxP_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nxP() //  [R1, R2]
         { info_tbl: [(c1nxP,
                       label: block_c1nxP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nxP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nxX; else goto c1nxW;
       c1nxX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nxW: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEnumRatio_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c1nxY,
                       label: GHC.Real.$fEnumRatio_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nxY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1ny2; else goto c1ny1;
       c1ny2: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1ny1: // global
           I64[Hp - 32] = w_s1ju7_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s1juc_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.442172009 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFromThen_closure" {
     GHC.Real.$fEnumRatio_$cenumFromThen_closure:
         const GHC.Real.$fEnumRatio_$cenumFromThen_info;
         const 0;
 },
 w_s1jue_entry() //  [R1]
         { info_tbl: [(c1nyb,
                       label: w_s1jue_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nyb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nyc; else goto c1nyd;
       c1nyc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nyd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1juk_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nym,
                       label: sat_s1juk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nym: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1nyn; else goto c1nyo;
       c1nyn: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nyo: // global
           I64[Sp - 8] = block_c1nyj_info;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nyj() //  [R1, R2]
         { info_tbl: [(c1nyj,
                       label: block_c1nyj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nyj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nyr; else goto c1nyq;
       c1nyr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nyq: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEnumRatio_$cenumFromThen_entry() //  [R2]
         { info_tbl: [(c1nys,
                       label: GHC.Real.$fEnumRatio_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nys: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1nyw; else goto c1nyv;
       c1nyw: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFromThen_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nyv: // global
           I64[Hp - 32] = w_s1jue_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s1juk_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.444143171 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFromTo_closure" {
     GHC.Real.$fEnumRatio_$cenumFromTo_closure:
         const GHC.Real.$fEnumRatio_$cenumFromTo_info;
         const 0;
 },
 sat_s1jun_entry() //  [R1]
         { info_tbl: [(c1nyF,
                       label: sat_s1jun_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nyF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nyG; else goto c1nyH;
       c1nyG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nyH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jum_entry() //  [R1]
         { info_tbl: [(c1nyM,
                       label: sat_s1jum_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nyM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nyN; else goto c1nyO;
       c1nyN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nyO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1nyU_srtd" {
     u1nyU_srtd:
         const S1jKw_srt+624;
         const 58;
         const 153122387330596865;
 },
 GHC.Real.$fEnumRatio_$cenumFromTo_entry() //  [R2]
         { info_tbl: [(c1nyP,
                       label: GHC.Real.$fEnumRatio_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nyP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1nyT; else goto c1nyS;
       c1nyT: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFromTo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nyS: // global
           I64[Hp - 40] = sat_s1jun_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s1jum_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.Real.numericEnumFromTo_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.445934308 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFromThenTo_closure" {
     GHC.Real.$fEnumRatio_$cenumFromThenTo_closure:
         const GHC.Real.$fEnumRatio_$cenumFromThenTo_info;
         const 0;
 },
 sat_s1juq_entry() //  [R1]
         { info_tbl: [(c1nz3,
                       label: sat_s1juq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nz3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nz4; else goto c1nz5;
       c1nz4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nz5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jup_entry() //  [R1]
         { info_tbl: [(c1nza,
                       label: sat_s1jup_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nza: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nzb; else goto c1nzc;
       c1nzb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nzc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1nzi_srtd" {
     u1nzi_srtd:
         const S1jKw_srt+672;
         const 53;
         const 4644337115725825;
 },
 GHC.Real.$fEnumRatio_$cenumFromThenTo_entry() //  [R2]
         { info_tbl: [(c1nzd,
                       label: GHC.Real.$fEnumRatio_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nzd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1nzh; else goto c1nzg;
       c1nzh: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nzg: // global
           I64[Hp - 40] = sat_s1juq_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s1jup_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.Real.numericEnumFromThenTo_closure+5;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.447238543 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$fRealRatio_closure" {
     GHC.Real.$fRealFracRatio_$s$fRealRatio_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Real.$fFractionalRatio_$s$fNumRatio_closure+1;
         const GHC.Real.$fOrdRatio_$s$fOrdRatio_closure+1;
         const GHC.Real.$fRealRatio_$s$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.448260451 UTC

[section ""data" . GHC.Real.$fRealRatio_closure" {
     GHC.Real.$fRealRatio_closure:
         const GHC.Real.$fRealRatio_info;
         const 0;
 },
 sat_s1juu_entry() //  [R1, R2]
         { info_tbl: [(c1nzs,
                       label: sat_s1juu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nzs: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fRealRatio_$ctoRational_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jut_entry() //  [R1]
         { info_tbl: [(c1nzz,
                       label: sat_s1jut_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nzz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nzA; else goto c1nzB;
       c1nzA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nzB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jus_entry() //  [R1]
         { info_tbl: [(c1nzG,
                       label: sat_s1jus_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nzG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nzH; else goto c1nzI;
       c1nzH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nzI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fNumRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fRealRatio_entry() //  [R2]
         { info_tbl: [(c1nzK,
                       label: GHC.Real.$fRealRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nzK: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1nzO; else goto c1nzN;
       c1nzO: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = GHC.Real.$fRealRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nzN: // global
           I64[Hp - 88] = sat_s1juu_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1jut_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s1jus_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 87;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.450463368 UTC

[section ""data" . GHC.Real.$w$s$cceiling_closure" {
     GHC.Real.$w$s$cceiling_closure:
         const GHC.Real.$w$s$cceiling_info;
         const 0;
 },
 sat_s1juH_entry() //  [R1]
         { info_tbl: [(c1nAh,
                       label: sat_s1juH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nAh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nAi; else goto c1nAj;
       c1nAi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nAj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1nAB_srtd" {
     u1nAB_srtd:
         const S1jKw_srt+24;
         const 136;
         const 1;
         const 576461027181592576;
         const 128;
 },
 GHC.Real.$w$s$cceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nAk,
                       label: GHC.Real.$w$s$cceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nAk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nAl; else goto c1nAm;
       c1nAl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nAm: // global
           I64[Sp - 16] = block_c1nzT_info;
           R4 = R4;
           R3 = R3;
           _s1juv::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s1juv::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nAC_srtd" {
     u1nAC_srtd:
         const S1jKw_srt+24;
         const 124;
         const 1;
         const 576460752303685632;
 },
 _c1nzT() //  [R1, R2]
         { info_tbl: [(c1nzT,
                       label: block_c1nzT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nzT: // global
           I64[Sp - 8] = block_c1nzV_info;
           _s1juz::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1juz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1nAA; else goto c1nzW;
       u1nAA: // global
           call _c1nzV(R1) args: 0, res: 0, upd: 0;
       c1nzW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nAD_srtd" {
     u1nAD_srtd:
         const S1jKw_srt+24;
         const 124;
         const 1;
         const 576460752303685632;
 },
 _c1nzV() //  [R1]
         { info_tbl: [(c1nzV,
                       label: block_c1nzV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nzV: // global
           I64[Sp] = block_c1nA0_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even1_closure;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nA0() //  [R1]
         { info_tbl: [(c1nA0,
                       label: block_c1nA0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nA0: // global
           if (R1 & 7 == 3) goto c1nAu; else goto c1nAs;
       c1nAu: // global
           I64[Sp] = block_c1nA5_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
       c1nAs: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1nA5() //  [R1]
         { info_tbl: [(c1nA5,
                       label: block_c1nA5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nA5: // global
           I64[Sp] = block_c1nA9_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nA9() //  [R1]
         { info_tbl: [(c1nA9,
                       label: block_c1nA9_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nA9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nAy; else goto c1nAx;
       c1nAy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nAx: // global
           I64[Hp - 16] = sat_s1juH_info;
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.45281201 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$cceiling_closure" {
     GHC.Real.$fRealFracRatio_$s$cceiling_closure:
         const GHC.Real.$fRealFracRatio_$s$cceiling_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$s$cceiling_entry() //  [R2, R3]
         { info_tbl: [(c1nAL,
                       label: GHC.Real.$fRealFracRatio_$s$cceiling_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nAL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nAM; else goto c1nAN;
       c1nAM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$cceiling_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nAN: // global
           I64[Sp - 16] = block_c1nAI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nAR; else goto c1nAJ;
       u1nAR: // global
           call _c1nAI(R1) args: 0, res: 0, upd: 0;
       c1nAJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nAI() //  [R1]
         { info_tbl: [(c1nAI,
                       label: block_c1nAI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nAI: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cceiling_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.454591903 UTC

[section ""data" . GHC.Real.$w$cceiling_closure" {
     GHC.Real.$w$cceiling_closure:
         const GHC.Real.$w$cceiling_info;
         const 0;
 },
 sat_s1jv3_entry() //  [R1]
         { info_tbl: [(c1nBm,
                       label: sat_s1jv3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nBm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nBn; else goto c1nBo;
       c1nBn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nBo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1nBH_srtd" {
     u1nBH_srtd:
         const S1jKw_srt+680;
         const 56;
         const 36030996042252289;
 },
 GHC.Real.$w$cceiling_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1nBp,
                       label: GHC.Real.$w$cceiling_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nBp: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1nBq; else goto c1nBr;
       c1nBq: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cceiling_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nBr: // global
           I64[Sp - 24] = block_c1nAW_info;
           R5 = R5;
           R4 = R4;
           _s1juO::P64 = R3;
           R3 = R3;
           _s1juN::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1juN::P64;
           P64[Sp - 8] = _s1juO::P64;
           Sp = Sp - 24;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nBI_srtd" {
     u1nBI_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1nAW() //  [R1, R2]
         { info_tbl: [(c1nAW,
                       label: block_c1nAW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nAW: // global
           I64[Sp - 8] = block_c1nAY_info;
           _s1juS::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1juS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1nBG; else goto c1nAZ;
       u1nBG: // global
           call _c1nAY(R1) args: 0, res: 0, upd: 0;
       c1nAZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nBJ_srtd" {
     u1nBJ_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1nAY() //  [R1]
         { info_tbl: [(c1nAY,
                       label: block_c1nAY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nAY: // global
           I64[Sp - 16] = block_c1nB3_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nB3() //  [R1, R2]
         { info_tbl: [(c1nB3,
                       label: block_c1nB3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nB3: // global
           _s1juV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1nB5_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = _s1juV::P64;
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nB5() //  [R1]
         { info_tbl: [(c1nB5,
                       label: block_c1nB5_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nB5: // global
           if (R1 & 7 == 3) goto c1nBA; else goto c1nBy;
       c1nBA: // global
           I64[Sp] = block_c1nBa_info;
           R2 = P64[Sp + 24];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
       c1nBy: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1nBa() //  [R1]
         { info_tbl: [(c1nBa,
                       label: block_c1nBa_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nBa: // global
           I64[Sp] = block_c1nBe_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nBe() //  [R1]
         { info_tbl: [(c1nBe,
                       label: block_c1nBe_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nBe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nBE; else goto c1nBD;
       c1nBE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nBD: // global
           I64[Hp - 16] = sat_s1jv3_info;
           P64[Hp] = R1;
           R2 = R1;
           _s1juS::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1juS::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.457315367 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$cceiling_closure" {
     GHC.Real.$fRealFracRatio_$cceiling_closure:
         const GHC.Real.$fRealFracRatio_$cceiling_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$cceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nBR,
                       label: GHC.Real.$fRealFracRatio_$cceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nBR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nBS; else goto c1nBT;
       c1nBS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$cceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nBT: // global
           I64[Sp - 24] = block_c1nBO_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1nBX; else goto c1nBP;
       u1nBX: // global
           call _c1nBO(R1) args: 0, res: 0, upd: 0;
       c1nBP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nBO() //  [R1]
         { info_tbl: [(c1nBO,
                       label: block_c1nBO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nBO: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cceiling_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.459112499 UTC

[section ""data" . GHC.Real.$w$s$cfloor_closure" {
     GHC.Real.$w$s$cfloor_closure:
         const GHC.Real.$w$s$cfloor_info;
         const 0;
 },
 sat_s1jvo_entry() //  [R1]
         { info_tbl: [(c1nCy,
                       label: sat_s1jvo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nCy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nCz; else goto c1nCA;
       c1nCz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nCA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1nCT_srtd" {
     u1nCT_srtd:
         const S1jKw_srt;
         const 143;
         const 1;
         const 4611688217452740608;
         const 16384;
 },
 GHC.Real.$w$s$cfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nCB,
                       label: GHC.Real.$w$s$cfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nCB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nCC; else goto c1nCD;
       c1nCC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nCD: // global
           I64[Sp - 16] = block_c1nC2_info;
           R4 = R4;
           R3 = R3;
           _s1jva::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s1jva::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nCU_srtd" {
     u1nCU_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1nC2() //  [R1, R2]
         { info_tbl: [(c1nC2,
                       label: block_c1nC2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nC2: // global
           I64[Sp - 8] = block_c1nC4_info;
           _s1jve::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1jve::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1nCS; else goto c1nC5;
       u1nCS: // global
           call _c1nC4(R1) args: 0, res: 0, upd: 0;
       c1nC5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nCV_srtd" {
     u1nCV_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1nC4() //  [R1]
         { info_tbl: [(c1nC4,
                       label: block_c1nC4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nC4: // global
           I64[Sp - 8] = block_c1nC9_info;
           R3 = P64[R1 + 15];
           R2 = GHC.Real.even1_closure;
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nCW_srtd" {
     u1nCW_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018427387904;
 },
 _c1nC9() //  [R1]
         { info_tbl: [(c1nC9,
                       label: block_c1nC9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nC9: // global
           I64[Sp] = block_c1nCd_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nCd() //  [R1]
         { info_tbl: [(c1nCd,
                       label: block_c1nCd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nCd: // global
           _s1jvk::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nCh_info;
           R3 = _s1jvk::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nCh() //  [R1]
         { info_tbl: [(c1nCh,
                       label: block_c1nCh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nCh: // global
           if (R1 == 1) goto c1nCN; else goto c1nCL;
       c1nCN: // global
           I64[Sp] = block_c1nCm_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
       c1nCL: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1nCm() //  [R1]
         { info_tbl: [(c1nCm,
                       label: block_c1nCm_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nCm: // global
           I64[Sp] = block_c1nCq_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nCq() //  [R1]
         { info_tbl: [(c1nCq,
                       label: block_c1nCq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nCq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nCR; else goto c1nCQ;
       c1nCR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nCQ: // global
           I64[Hp - 16] = sat_s1jvo_info;
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.461908742 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$cfloor_closure" {
     GHC.Real.$fRealFracRatio_$s$cfloor_closure:
         const GHC.Real.$fRealFracRatio_$s$cfloor_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$s$cfloor_entry() //  [R2, R3]
         { info_tbl: [(c1nD4,
                       label: GHC.Real.$fRealFracRatio_$s$cfloor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nD4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nD5; else goto c1nD6;
       c1nD5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$cfloor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nD6: // global
           I64[Sp - 16] = block_c1nD1_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nDa; else goto c1nD2;
       u1nDa: // global
           call _c1nD1(R1) args: 0, res: 0, upd: 0;
       c1nD2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nD1() //  [R1]
         { info_tbl: [(c1nD1,
                       label: block_c1nD1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nD1: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.46364243 UTC

[section ""data" . GHC.Real.$w$cfloor_closure" {
     GHC.Real.$w$cfloor_closure:
         const GHC.Real.$w$cfloor_info;
         const 0;
 },
 sat_s1jvK_entry() //  [R1]
         { info_tbl: [(c1nDF,
                       label: sat_s1jvK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nDF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nDG; else goto c1nDH;
       c1nDG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nDH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1nE0_srtd" {
     u1nE0_srtd:
         const S1jKw_srt+680;
         const 60;
         const 576462951326711809;
 },
 GHC.Real.$w$cfloor_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1nDI,
                       label: GHC.Real.$w$cfloor_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nDI: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1nDJ; else goto c1nDK;
       c1nDJ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cfloor_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nDK: // global
           I64[Sp - 24] = block_c1nDf_info;
           R5 = R5;
           R4 = R4;
           _s1jvv::P64 = R3;
           R3 = R3;
           _s1jvu::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1jvu::P64;
           P64[Sp - 8] = _s1jvv::P64;
           Sp = Sp - 24;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nE1_srtd" {
     u1nE1_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1nDf() //  [R1, R2]
         { info_tbl: [(c1nDf,
                       label: block_c1nDf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nDf: // global
           I64[Sp - 8] = block_c1nDh_info;
           _s1jvz::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1jvz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1nDZ; else goto c1nDi;
       u1nDZ: // global
           call _c1nDh(R1) args: 0, res: 0, upd: 0;
       c1nDi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nE2_srtd" {
     u1nE2_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1nDh() //  [R1]
         { info_tbl: [(c1nDh,
                       label: block_c1nDh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nDh: // global
           I64[Sp - 16] = block_c1nDm_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nDm() //  [R1, R2]
         { info_tbl: [(c1nDm,
                       label: block_c1nDm_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nDm: // global
           _s1jvC::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1nDo_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = _s1jvC::P64;
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Real.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nDo() //  [R1]
         { info_tbl: [(c1nDo,
                       label: block_c1nDo_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nDo: // global
           if (R1 & 7 == 1) goto c1nDR; else goto c1nDT;
       c1nDR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1nDT: // global
           I64[Sp] = block_c1nDt_info;
           R2 = P64[Sp + 24];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nDt() //  [R1]
         { info_tbl: [(c1nDt,
                       label: block_c1nDt_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nDt: // global
           I64[Sp] = block_c1nDx_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nDx() //  [R1]
         { info_tbl: [(c1nDx,
                       label: block_c1nDx_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nDx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nDX; else goto c1nDW;
       c1nDX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nDW: // global
           I64[Hp - 16] = sat_s1jvK_info;
           P64[Hp] = R1;
           R2 = R1;
           _s1jvz::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1jvz::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.466421572 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$cfloor_closure" {
     GHC.Real.$fRealFracRatio_$cfloor_closure:
         const GHC.Real.$fRealFracRatio_$cfloor_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$cfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nEa,
                       label: GHC.Real.$fRealFracRatio_$cfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nEa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nEb; else goto c1nEc;
       c1nEb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$cfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nEc: // global
           I64[Sp - 24] = block_c1nE7_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1nEg; else goto c1nE8;
       u1nEg: // global
           call _c1nE7(R1) args: 0, res: 0, upd: 0;
       c1nE8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nE7() //  [R1]
         { info_tbl: [(c1nE7,
                       label: block_c1nE7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nE7: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cfloor_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.46762755 UTC

[section ""data" . sat_s1jvR_closure" {
     sat_s1jvR_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.468162207 UTC

[section ""data" . sat_s1jvS_closure" {
     sat_s1jvS_closure:
         const :_con_info;
         const sat_s1jvR_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.468920826 UTC

[section ""data" . GHC.Real.$fRealFracRatio2_closure" {
     GHC.Real.$fRealFracRatio2_closure:
         const GHC.Real.$fRealFracRatio2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fRealFracRatio2_entry() //  [R1]
         { info_tbl: [(c1nEn,
                       label: GHC.Real.$fRealFracRatio2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nEn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nEo; else goto c1nEp;
       c1nEo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nEp: // global
           (_c1nEk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1nEk::I64 == 0) goto c1nEm; else goto c1nEl;
       c1nEm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1nEl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1nEk::I64;
           R3 = sat_s1jvS_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.471450195 UTC

[section ""data" . GHC.Real.$w$s$cround_closure" {
     GHC.Real.$w$s$cround_closure:
         const GHC.Real.$w$s$cround_info;
         const 0;
 },
 sat_s1jwe_entry() //  [R1]
         { info_tbl: [(c1nFi,
                       label: sat_s1jwe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nFi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nFj; else goto c1nFk;
       c1nFj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nFk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jwf_entry() //  [R1]
         { info_tbl: [(c1nFr,
                       label: sat_s1jwf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nFr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nFs; else goto c1nFt;
       c1nFs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nFt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1nGE_srtd" {
     u1nGE_srtd:
         const S1jKw_srt;
         const 149;
         const 288230376151711745;
         const 4611688217729565184;
         const 1572864;
 },
 GHC.Real.$w$s$cround_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nFu,
                       label: GHC.Real.$w$s$cround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nFu: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1nFv; else goto c1nFw;
       c1nFv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nFw: // global
           I64[Sp - 16] = block_c1nEu_info;
           R4 = R4;
           R3 = R3;
           _s1jvT::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s1jvT::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nGF_srtd" {
     u1nGF_srtd:
         const S1jKw_srt;
         const 149;
         const 288230376151711745;
         const 4611686018706309632;
         const 1048576;
 },
 _c1nEu() //  [R1, R2]
         { info_tbl: [(c1nEu,
                       label: block_c1nEu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nEu: // global
           I64[Sp - 8] = block_c1nEw_info;
           _s1jvX::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1jvX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1nGz; else goto c1nEx;
       u1nGz: // global
           call _c1nEw(R1) args: 0, res: 0, upd: 0;
       c1nEx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nGG_srtd" {
     u1nGG_srtd:
         const S1jKw_srt;
         const 149;
         const 288230376151711745;
         const 4611686018706309632;
         const 1048576;
 },
 _c1nEw() //  [R1]
         { info_tbl: [(c1nEw,
                       label: block_c1nEw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nEw: // global
           I64[Sp - 16] = block_c1nEB_info;
           _s1jw0::P64 = P64[R1 + 7];
           R2 = _s1jw0::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _s1jw0::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nGH_srtd" {
     u1nGH_srtd:
         const S1jKw_srt;
         const 149;
         const 288230376151711745;
         const 4611686018706309632;
         const 1048576;
 },
 _c1nEB() //  [R1]
         { info_tbl: [(c1nEB,
                       label: block_c1nEB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nEB: // global
           I64[Sp] = block_c1nEF_info;
           R5 = GHC.Real.even2_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[Sp + 8];
           R2 = R1;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nGI_srtd" {
     u1nGI_srtd:
         const S1jKw_srt;
         const 149;
         const 1;
         const 4611686018706309120;
         const 1048576;
 },
 _c1nEF() //  [R1]
         { info_tbl: [(c1nEF,
                       label: block_c1nEF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nEF: // global
           I64[Sp] = block_c1nEH_info;
           R2 = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nGJ_srtd" {
     u1nGJ_srtd:
         const S1jKw_srt;
         const 149;
         const 1;
         const 4611686018706309120;
         const 1048576;
 },
 _c1nEH() //  [R1]
         { info_tbl: [(c1nEH,
                       label: block_c1nEH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nEH: // global
           I64[Sp - 8] = block_c1nEL_info;
           R3 = GHC.Real.$fRealFracRatio2_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nGK_srtd" {
     u1nGK_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018706309120;
 },
 _c1nEL() //  [R1]
         { info_tbl: [(c1nEL,
                       label: block_c1nEL_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nEL: // global
           if (R1 == 1) goto u1nGv; else goto c1nFT;
       u1nGv: // global
           Sp = Sp + 32;
           call _c1nGt() args: 0, res: 0, upd: 0;
       c1nFT: // global
           I64[Sp] = block_c1nFC_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nGL_srtd" {
     u1nGL_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018706309120;
 },
 _c1nFC() //  [R1]
         { info_tbl: [(c1nFC,
                       label: block_c1nFC_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nFC: // global
           if (R1 == 1) goto c1nGf; else goto c1nG0;
       c1nGf: // global
           I64[Sp + 8] = block_c1nGd_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
       c1nG0: // global
           _s1jw6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nFX_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _s1jw6::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nGM_srtd" {
     u1nGM_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1nGd() //  [R1]
         { info_tbl: [(c1nGd,
                       label: block_c1nGd_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nGd: // global
           if (R1 & 7 == 1) goto u1nGx; else goto u1nGy;
       u1nGx: // global
           Sp = Sp + 8;
           call _s1jw8() args: 0, res: 0, upd: 0;
       u1nGy: // global
           Sp = Sp + 24;
           call _c1nGt() args: 0, res: 0, upd: 0;
     }
 },
 _c1nGt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nGt: // global
           R1 = P64[Sp];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1nGN_srtd" {
     u1nGN_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018697920512;
 },
 _c1nFX() //  [R1]
         { info_tbl: [(c1nFX,
                       label: block_c1nFX_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nFX: // global
           if (R1 == 1) goto u1nGw; else goto c1nG6;
       u1nGw: // global
           Sp = Sp + 8;
           call _s1jw8() args: 0, res: 0, upd: 0;
       c1nG6: // global
           R1 = GHC.Real.$fRealFracRatio1_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s1jw8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jw8: // global
           I64[Sp - 8] = block_c1nEU_info;
           R2 = P64[Sp + 24];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nGO_srtd" {
     u1nGO_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1nEU() //  [R1]
         { info_tbl: [(c1nEU,
                       label: block_c1nEU_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nEU: // global
           I64[Sp] = block_c1nEY_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nGP_srtd" {
     u1nGP_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1nEY() //  [R1]
         { info_tbl: [(c1nEY,
                       label: block_c1nEY_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nEY: // global
           _s1jw1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nF2_info;
           R3 = _s1jw1::P64;
           R2 = GHC.Real.even1_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nGQ_srtd" {
     u1nGQ_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018427387904;
 },
 _c1nF2() //  [R1]
         { info_tbl: [(c1nF2,
                       label: block_c1nF2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nF2: // global
           I64[Sp] = block_c1nF6_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nF6() //  [R1]
         { info_tbl: [(c1nF6,
                       label: block_c1nF6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nF6: // global
           _s1jwc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nFa_info;
           R3 = _s1jwc::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nFa() //  [R1]
         { info_tbl: [(c1nFa,
                       label: block_c1nFa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nFa: // global
           _s1jwa::P64 = P64[Sp + 16];
           if (R1 == 1) goto c1nFO; else goto c1nFK;
       c1nFO: // global
           Hp = Hp + 24;
           _s1jwd::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1nFR; else goto c1nFQ;
       c1nFQ: // global
           I64[Hp - 16] = sat_s1jwf_info;
           P64[Hp] = _s1jwa::P64;
           R2 = _s1jwa::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
       c1nFK: // global
           Hp = Hp + 24;
           _s1jwd::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1nFR; else goto c1nFM;
       c1nFR: // global
           HpAlloc = 24;
           R1 = _s1jwd::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1nFM: // global
           I64[Hp - 16] = sat_s1jwe_info;
           P64[Hp] = _s1jwa::P64;
           R2 = _s1jwa::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.478270533 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$cround_closure" {
     GHC.Real.$fRealFracRatio_$s$cround_closure:
         const GHC.Real.$fRealFracRatio_$s$cround_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$s$cround_entry() //  [R2, R3]
         { info_tbl: [(c1nGY,
                       label: GHC.Real.$fRealFracRatio_$s$cround_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nGY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nGZ; else goto c1nH0;
       c1nGZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$cround_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nH0: // global
           I64[Sp - 16] = block_c1nGV_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nH4; else goto c1nGW;
       u1nH4: // global
           call _c1nGV(R1) args: 0, res: 0, upd: 0;
       c1nGW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nGV() //  [R1]
         { info_tbl: [(c1nGV,
                       label: block_c1nGV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nGV: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cround_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.481970715 UTC

[section ""data" . GHC.Real.$w$cround_closure" {
     GHC.Real.$w$cround_closure:
         const GHC.Real.$w$cround_info;
         const 0;
 },
 sat_s1jx1_entry() //  [R1]
         { info_tbl: [(c1nIm,
                       label: sat_s1jx1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nIm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nIn; else goto c1nIo;
       c1nIn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nIo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jx2_entry() //  [R1]
         { info_tbl: [(c1nIv,
                       label: sat_s1jx2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nIv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nIw; else goto c1nIx;
       c1nIw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nIx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1nKS_srtd" {
     u1nKS_srtd:
         const S1jKw_srt+584;
         const 78;
         const 9156733004435457;
         const 8192;
 },
 GHC.Real.$w$cround_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1nIy,
                       label: GHC.Real.$w$cround_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nIy: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c1nIz; else goto c1nIA;
       c1nIz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cround_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nIA: // global
           I64[Sp - 24] = block_c1nH9_info;
           R5 = R5;
           R4 = R4;
           _s1jwp::P64 = R3;
           R3 = R3;
           _s1jwo::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1jwo::P64;
           P64[Sp - 8] = _s1jwp::P64;
           Sp = Sp - 24;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nKT_srtd" {
     u1nKT_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1nH9() //  [R1, R2]
         { info_tbl: [(c1nH9,
                       label: block_c1nH9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nH9: // global
           I64[Sp - 8] = block_c1nHb_info;
           _s1jwt::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1jwt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1nKH; else goto c1nHc;
       u1nKH: // global
           call _c1nHb(R1) args: 0, res: 0, upd: 0;
       c1nHc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nKU_srtd" {
     u1nKU_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1nHb() //  [R1]
         { info_tbl: [(c1nHb,
                       label: block_c1nHb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHb: // global
           I64[Sp - 16] = block_c1nHg_info;
           R2 = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nKV_srtd" {
     u1nKV_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1nHg() //  [R1]
         { info_tbl: [(c1nHg,
                       label: block_c1nHg_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHg: // global
           I64[Sp] = block_c1nHk_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nKW_srtd" {
     u1nKW_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1nHk() //  [R1]
         { info_tbl: [(c1nHk,
                       label: block_c1nHk_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHk: // global
           I64[Sp] = block_c1nHo_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nKX_srtd" {
     u1nKX_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1nHo() //  [R1]
         { info_tbl: [(c1nHo,
                       label: block_c1nHo_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHo: // global
           I64[Sp - 8] = block_c1nHq_info;
           R4 = GHC.Real.even2_closure;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 32];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$w$cfromRational_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nKY_srtd" {
     u1nKY_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2233383035013;
 },
 _c1nHq() //  [R1, R2]
         { info_tbl: [(c1nHq,
                       label: block_c1nHq_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHq: // global
           _s1jwA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nHs_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 16];
           R3 = _s1jwA::P64;
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call GHC.Real.$w$c-_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nKZ_srtd" {
     u1nKZ_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023296645;
 },
 _c1nHs() //  [R1]
         { info_tbl: [(c1nHs,
                       label: block_c1nHs_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHs: // global
           I64[Sp] = block_c1nHu_info;
           R3 = R1;
           R2 = P64[Sp + 32];
           call GHC.Real.$w$csignum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nL0_srtd" {
     u1nL0_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1nHu() //  [R1, R2]
         { info_tbl: [(c1nHu,
                       label: block_c1nHu_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHu: // global
           I64[Sp - 16] = block_c1nHw_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           _s1jwJ::P64 = R2;
           R2 = P64[Sp + 32];
           P64[Sp - 8] = _s1jwJ::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nL1_srtd" {
     u1nL1_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1nHw() //  [R1, R2]
         { info_tbl: [(c1nHw,
                       label: block_c1nHw_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHw: // global
           I64[Sp - 16] = block_c1nHy_info;
           _s1jwM::P64 = R2;
           R2 = P64[Sp + 48];
           P64[Sp - 8] = _s1jwM::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nL2_srtd" {
     u1nL2_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1nHy() //  [R1]
         { info_tbl: [(c1nHy,
                       label: block_c1nHy_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHy: // global
           I64[Sp] = block_c1nHC_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nL3_srtd" {
     u1nL3_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1nHC() //  [R1]
         { info_tbl: [(c1nHC,
                       label: block_c1nHC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHC: // global
           I64[Sp] = block_c1nHG_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nL4_srtd" {
     u1nL4_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1nHG() //  [R1]
         { info_tbl: [(c1nHG,
                       label: block_c1nHG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHG: // global
           I64[Sp - 8] = block_c1nHI_info;
           R2 = P64[Sp + 64];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nL5_srtd" {
     u1nL5_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1nHI() //  [R1]
         { info_tbl: [(c1nHI,
                       label: block_c1nHI_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHI: // global
           I64[Sp] = block_c1nHM_info;
           R2 = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nL6_srtd" {
     u1nL6_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1nHM() //  [R1]
         { info_tbl: [(c1nHM,
                       label: block_c1nHM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHM: // global
           I64[Sp] = block_c1nHQ_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nL7_srtd" {
     u1nL7_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1nHQ() //  [R1]
         { info_tbl: [(c1nHQ,
                       label: block_c1nHQ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHQ: // global
           I64[Sp] = block_c1nIP_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nL8_srtd" {
     u1nL8_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1nIP() //  [R1]
         { info_tbl: [(c1nIP,
                       label: block_c1nIP_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nIP: // global
           if (R1 & 7 == 1) goto u1nKx; else goto c1nKe;
       u1nKx: // global
           Sp = Sp + 8;
           call _s1jwT() args: 0, res: 0, upd: 0;
       c1nKe: // global
           I64[Sp] = block_c1nKc_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nL9_srtd" {
     u1nL9_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1nKc() //  [R1]
         { info_tbl: [(c1nKc,
                       label: block_c1nKc_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nKc: // global
           if (R1 & 7 == 1) goto u1nKy; else goto u1nKz;
       u1nKy: // global
           Sp = Sp + 8;
           call _s1jwT() args: 0, res: 0, upd: 0;
       u1nKz: // global
           Sp = Sp + 64;
           call _c1nKo() args: 0, res: 0, upd: 0;
     }
 },
 _s1jwT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jwT: // global
           I64[Sp - 8] = block_c1nHZ_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 64];
           Sp = Sp - 8;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nLa_srtd" {
     u1nLa_srtd:
         const S1jKw_srt+696;
         const 40;
         const 549755813921;
 },
 _c1nHZ() //  [R1, R2]
         { info_tbl: [(c1nHZ,
                       label: block_c1nHZ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nHZ: // global
           I64[Sp - 16] = block_c1nIT_info;
           _s1jwW::P64 = R2;
           R2 = P64[Sp + 8];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[Sp + 40];
           P64[Sp - 24] = R1;
           P64[Sp - 8] = _s1jwW::P64;
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nLb_srtd" {
     u1nLb_srtd:
         const S1jKw_srt+696;
         const 40;
         const 549755813921;
 },
 _c1nIT() //  [R1]
         { info_tbl: [(c1nIT,
                       label: block_c1nIT_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nIT: // global
           if (R1 & 7 == 1) goto u1nKA; else goto c1nJI;
       u1nKA: // global
           Sp = Sp + 8;
           call _s1jx3() args: 0, res: 0, upd: 0;
       c1nJI: // global
           I64[Sp] = block_c1nJG_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 48];
           P64[Sp - 8] = P64[Sp + 8];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nLc_srtd" {
     u1nLc_srtd:
         const S1jKw_srt+696;
         const 40;
         const 549755813921;
 },
 _c1nJG() //  [R1]
         { info_tbl: [(c1nJG,
                       label: block_c1nJG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nJG: // global
           if (R1 & 7 == 1) goto u1nKB; else goto c1nJT;
       u1nKB: // global
           Sp = Sp + 8;
           call _s1jx3() args: 0, res: 0, upd: 0;
       c1nJT: // global
           I64[Sp] = block_c1nJR_info;
           R3 = P64[Sp + 80];
           R2 = P64[Sp + 96];
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _s1jx3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jx3: // global
           I64[Sp - 8] = block_c1nJb_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 48];
           P64[Sp - 16] = P64[Sp + 32];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nLd_srtd" {
     u1nLd_srtd:
         const S1jKw_srt+736;
         const 35;
         const 17179869185;
 },
 _c1nJb() //  [R1]
         { info_tbl: [(c1nJb,
                       label: block_c1nJb_info
                       rep:StackRep [False, False, False, False, True, False, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nJb: // global
           if (R1 & 7 == 1) goto u1nKE; else goto c1nJn;
       u1nKE: // global
           Sp = Sp + 104;
           call _c1nJt() args: 0, res: 0, upd: 0;
       c1nJn: // global
           I64[Sp] = block_c1nJl_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 48];
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nLe_srtd" {
     u1nLe_srtd:
         const S1jKw_srt+736;
         const 35;
         const 17179869185;
 },
 _c1nJl() //  [R1]
         { info_tbl: [(c1nJl,
                       label: block_c1nJl_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nJl: // global
           if (R1 & 7 == 1) goto u1nKF; else goto u1nKG;
       u1nKF: // global
           Sp = Sp + 104;
           call _c1nJt() args: 0, res: 0, upd: 0;
       u1nKG: // global
           Sp = Sp + 8;
           call _s1jwX() args: 0, res: 0, upd: 0;
     }
 },
 _c1nJt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nJt: // global
           R1 = GHC.Real.$fRealFracRatio1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1nJR() //  [R1]
         { info_tbl: [(c1nJR,
                       label: block_c1nJR_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nJR: // global
           if (R1 & 7 == 1) goto u1nKC; else goto u1nKD;
       u1nKC: // global
           Sp = Sp + 8;
           call _s1jwX() args: 0, res: 0, upd: 0;
       u1nKD: // global
           Sp = Sp + 80;
           call _c1nKo() args: 0, res: 0, upd: 0;
     }
 },
 _s1jwX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jwX: // global
           I64[Sp - 8] = block_c1nI6_info;
           R2 = P64[Sp + 88];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nI6() //  [R1]
         { info_tbl: [(c1nI6,
                       label: block_c1nI6_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nI6: // global
           I64[Sp] = block_c1nIa_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nIa() //  [R1]
         { info_tbl: [(c1nIa,
                       label: block_c1nIa_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nIa: // global
           _s1jww::P64 = P64[Sp + 72];
           I64[Sp + 72] = block_c1nIe_info;
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 64];
           R3 = _s1jww::P64;
           R2 = P64[Sp + 88];
           P64[Sp + 96] = R1;
           Sp = Sp + 72;
           call GHC.Real.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nIe() //  [R1]
         { info_tbl: [(c1nIe,
                       label: block_c1nIe_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nIe: // global
           _s1jwt::P64 = P64[Sp + 8];
           _s1jwZ::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c1nJ0; else goto c1nJ4;
       c1nJ0: // global
           Hp = Hp + 24;
           _s1jx0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1nJ7; else goto c1nJ2;
       c1nJ2: // global
           I64[Hp - 16] = sat_s1jx1_info;
           P64[Hp] = _s1jwZ::P64;
           R2 = _s1jwZ::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1jwt::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
       c1nJ4: // global
           Hp = Hp + 24;
           _s1jx0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1nJ7; else goto c1nJ6;
       c1nJ7: // global
           HpAlloc = 24;
           R1 = _s1jx0::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nJ6: // global
           I64[Hp - 16] = sat_s1jx2_info;
           P64[Hp] = _s1jwZ::P64;
           R2 = _s1jwZ::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1jwt::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _c1nKo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nKo: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.490355423 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$cround_closure" {
     GHC.Real.$fRealFracRatio_$cround_closure:
         const GHC.Real.$fRealFracRatio_$cround_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$cround_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nLm,
                       label: GHC.Real.$fRealFracRatio_$cround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nLm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nLn; else goto c1nLo;
       c1nLn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$cround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nLo: // global
           I64[Sp - 24] = block_c1nLj_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1nLs; else goto c1nLk;
       u1nLs: // global
           call _c1nLj(R1) args: 0, res: 0, upd: 0;
       c1nLk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nLj() //  [R1]
         { info_tbl: [(c1nLj,
                       label: block_c1nLj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nLj: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cround_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.49219969 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$ctruncate_closure" {
     GHC.Real.$fRealFracRatio_$s$ctruncate_closure:
         const GHC.Real.$fRealFracRatio_$s$ctruncate_info;
         const 0;
 },
 sat_s1jxt_entry() //  [R1]
         { info_tbl: [(c1nLL,
                       label: sat_s1jxt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nLL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nLM; else goto c1nLN;
       c1nLM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nLN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c1nLG_info;
           R3 = GHC.Real.even1_closure;
           _s1jxl::P64 = P64[R1 + 24];
           R2 = _s1jxl::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s1jxl::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1nLG() //  [R1]
         { info_tbl: [(c1nLG,
                       label: block_c1nLG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nLG: // global
           if (R1 == 1) goto c1nLK; else goto c1nLJ;
       c1nLK: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c1nLJ: // global
           _s1jxl::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1nLQ_info;
           R3 = _s1jxl::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1nLQ() //  [R1]
         { info_tbl: [(c1nLQ,
                       label: block_c1nLQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nLQ: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fRealFracRatio_$s$ctruncate_entry() //  [R2, R3]
         { info_tbl: [(c1nLX,
                       label: GHC.Real.$fRealFracRatio_$s$ctruncate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nLX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nM3; else goto c1nM4;
       c1nM3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$ctruncate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nM4: // global
           I64[Sp - 16] = block_c1nLx_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nMd; else goto c1nLy;
       u1nMd: // global
           call _c1nLx(R1) args: 0, res: 0, upd: 0;
       c1nLy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nLx() //  [R1]
         { info_tbl: [(c1nLx,
                       label: block_c1nLx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nLx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1nM7; else goto c1nM6;
       c1nM7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nM6: // global
           _s1jxk::P64 = P64[R1 + 7];
           _s1jxl::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s1jxt_info;
           P64[Hp - 8] = _s1jxk::P64;
           P64[Hp] = _s1jxl::P64;
           I64[Sp] = block_c1nLY_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nLY() //  [R1]
         { info_tbl: [(c1nLY,
                       label: block_c1nLY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nLY: // global
           I64[Sp] = block_c1nM2_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nM2() //  [R1]
         { info_tbl: [(c1nM2,
                       label: block_c1nM2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nM2: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.494539372 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$ctruncate_closure" {
     GHC.Real.$fRealFracRatio_$ctruncate_closure:
         const GHC.Real.$fRealFracRatio_$ctruncate_info;
 },
 GHC.Real.$fRealFracRatio_$ctruncate_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nMl,
                       label: GHC.Real.$fRealFracRatio_$ctruncate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nMl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nMp; else goto c1nMq;
       c1nMp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$ctruncate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nMq: // global
           I64[Sp - 24] = block_c1nMi_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1nMu; else goto c1nMj;
       u1nMu: // global
           call _c1nMi(R1) args: 0, res: 0, upd: 0;
       c1nMj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nMi() //  [R1]
         { info_tbl: [(c1nMi,
                       label: block_c1nMi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nMi: // global
           _s1jxv::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1nMo_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _s1jxv::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nMo() //  [R1]
         { info_tbl: [(c1nMo,
                       label: block_c1nMo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nMo: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.49571255 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$fRealFracRatio_closure" {
     GHC.Real.$fRealFracRatio_$s$fRealFracRatio_closure:
         const GHC.Real.C:RealFrac_con_info;
         const GHC.Real.$fRealFracRatio_$s$fRealRatio_closure+1;
         const GHC.Real.$fFractionalRatio_$s$fFractionalRatio_closure+1;
         const GHC.Real.$fEnumRatio_$s$cproperFraction_closure+2;
         const GHC.Real.$fRealFracRatio_$s$ctruncate_closure+2;
         const GHC.Real.$fRealFracRatio_$s$cround_closure+2;
         const GHC.Real.$fRealFracRatio_$s$cceiling_closure+2;
         const GHC.Real.$fRealFracRatio_$s$cfloor_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.497294594 UTC

[section ""data" . GHC.Real.$fRealFracRatio_closure" {
     GHC.Real.$fRealFracRatio_closure:
         const GHC.Real.$fRealFracRatio_info;
         const 0;
 },
 sat_s1jxK_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nME,
                       label: sat_s1jxK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nME: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$cfloor_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxJ_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nMM,
                       label: sat_s1jxJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nMM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$cceiling_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxI_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nMU,
                       label: sat_s1jxI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nMU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$cround_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxH_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nN2,
                       label: sat_s1jxH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nN2: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$ctruncate_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxG_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nNa,
                       label: sat_s1jxG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nNa: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fEnumRatio_$cproperFraction_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxF_entry() //  [R1]
         { info_tbl: [(c1nNh,
                       label: sat_s1jxF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nNh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nNi; else goto c1nNj;
       c1nNi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nNj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jxE_entry() //  [R1]
         { info_tbl: [(c1nNo,
                       label: sat_s1jxE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nNo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nNp; else goto c1nNq;
       c1nNp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nNq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fRealRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fRealFracRatio_entry() //  [R2]
         { info_tbl: [(c1nNs,
                       label: GHC.Real.$fRealFracRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nNs: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c1nNw; else goto c1nNv;
       c1nNw: // global
           HpAlloc = 192;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nNv: // global
           I64[Hp - 184] = sat_s1jxK_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s1jxJ_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1jxI_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s1jxH_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s1jxG_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s1jxF_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s1jxE_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 118;
           P64[Hp - 24] = Hp - 134;
           P64[Hp - 16] = Hp - 150;
           P64[Hp - 8] = Hp - 166;
           P64[Hp] = Hp - 182;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.500239828 UTC

[section ""data" . g_r1j3N_closure" {
     g_r1j3N_closure:
         const g_r1j3N_info;
         const 0;
 },
 section ""relreadonly" . u1nOA_srtd" {
     u1nOA_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 g_r1j3N_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nND,
                       label: g_r1j3N_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nND: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1nNE; else goto u1nOu;
       c1nNE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = g_r1j3N_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u1nOu: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c1nNy() args: 0, res: 0, upd: 0;
     }
 },
 _c1nNy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nNy: // global
           I64[Sp - 8] = block_c1nNB_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nOB_srtd" {
     u1nOB_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1nNB() //  [R1]
         { info_tbl: [(c1nNB,
                       label: block_c1nNB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nNB: // global
           I64[Sp] = block_c1nNI_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nOC_srtd" {
     u1nOC_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1nNI() //  [R1]
         { info_tbl: [(c1nNI,
                       label: block_c1nNI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nNI: // global
           _s1jxM::P64 = P64[Sp + 16];
           if (R1 == 1) goto c1nOo; else goto c1nNQ;
       c1nOo: // global
           I64[Sp] = block_c1nOi_info;
           R3 = GHC.Real.even2_closure;
           R2 = _s1jxM::P64;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       c1nNQ: // global
           I64[Sp] = block_c1nNN_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _s1jxM::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nOD_srtd" {
     u1nOD_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1nOi() //  [R1]
         { info_tbl: [(c1nOi,
                       label: block_c1nOi_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nOi: // global
           _s1jxL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nOm_info;
           R3 = _s1jxL::P64;
           R2 = _s1jxL::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nOE_srtd" {
     u1nOE_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1nOm() //  [R1]
         { info_tbl: [(c1nOm,
                       label: block_c1nOm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nOm: // global
           P64[Sp] = R1;
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           call _c1nNy() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1nOF_srtd" {
     u1nOF_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1nNN() //  [R1]
         { info_tbl: [(c1nNN,
                       label: block_c1nNN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nNN: // global
           _s1jxL::P64 = P64[Sp + 8];
           _s1jxN::P64 = P64[Sp + 24];
           if (R1 == 1) goto c1nOf; else goto c1nO5;
       c1nOf: // global
           R3 = _s1jxN::P64;
           R2 = _s1jxL::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
       c1nO5: // global
           I64[Sp] = block_c1nNU_info;
           R3 = _s1jxN::P64;
           R2 = _s1jxL::P64;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nOG_srtd" {
     u1nOG_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1nNU() //  [R1]
         { info_tbl: [(c1nNU,
                       label: block_c1nNU_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nNU: // global
           I64[Sp] = block_c1nNY_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 16];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nOH_srtd" {
     u1nOH_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1nNY() //  [R1]
         { info_tbl: [(c1nNY,
                       label: block_c1nNY_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nNY: // global
           _s1jxL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nO2_info;
           R3 = _s1jxL::P64;
           R2 = _s1jxL::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nOI_srtd" {
     u1nOI_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1nO2() //  [R1]
         { info_tbl: [(c1nO2,
                       label: block_c1nO2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nO2: // global
           P64[Sp] = R1;
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           call _c1nNy() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.503863109 UTC

[section ""data" . GHC.Real.^_f_closure" {
     GHC.Real.^_f_closure:
         const GHC.Real.^_f_info;
         const 0;
 },
 section ""relreadonly" . u1nPF_srtd" {
     u1nPF_srtd:
         const S1jKw_srt;
         const 158;
         const 1;
         const 4611686018427388416;
         const 838860800;
 },
 GHC.Real.^_f_entry() //  [R2, R3]
         { info_tbl: [(c1nOP,
                       label: GHC.Real.^_f_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nOP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nOQ; else goto u1nPB;
       c1nOQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_f_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1nPB: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1nOK() args: 0, res: 0, upd: 0;
     }
 },
 _c1nOK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nOK: // global
           I64[Sp - 8] = block_c1nON_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nPG_srtd" {
     u1nPG_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1nON() //  [R1]
         { info_tbl: [(c1nON,
                       label: block_c1nON_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nON: // global
           I64[Sp] = block_c1nOU_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nPH_srtd" {
     u1nPH_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1nOU() //  [R1]
         { info_tbl: [(c1nOU,
                       label: block_c1nOU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nOU: // global
           _s1jxX::P64 = P64[Sp + 16];
           if (R1 == 1) goto c1nPv; else goto c1nP2;
       c1nPv: // global
           I64[Sp] = block_c1nPp_info;
           R3 = GHC.Real.even2_closure;
           R2 = _s1jxX::P64;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       c1nP2: // global
           I64[Sp] = block_c1nOZ_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _s1jxX::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nPI_srtd" {
     u1nPI_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1nPp() //  [R1]
         { info_tbl: [(c1nPp,
                       label: block_c1nPp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nPp: // global
           _s1jxW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nPt_info;
           R3 = _s1jxW::P64;
           R2 = _s1jxW::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nPJ_srtd" {
     u1nPJ_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1nPt() //  [R1]
         { info_tbl: [(c1nPt,
                       label: block_c1nPt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nPt: // global
           P64[Sp] = R1;
           P64[Sp + 8] = P64[Sp + 8];
           call _c1nOK() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1nPK_srtd" {
     u1nPK_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 512;
         const 268435456;
 },
 _c1nOZ() //  [R1]
         { info_tbl: [(c1nOZ,
                       label: block_c1nOZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nOZ: // global
           if (R1 == 1) goto c1nPm; else goto c1nPd;
       c1nPm: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1nPd: // global
           I64[Sp] = block_c1nP6_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nPL_srtd" {
     u1nPL_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 0;
         const 268435456;
 },
 _c1nP6() //  [R1]
         { info_tbl: [(c1nP6,
                       label: block_c1nP6_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nP6: // global
           I64[Sp] = block_c1nPa_info;
           _s1jxW::P64 = P64[Sp + 8];
           R3 = _s1jxW::P64;
           R2 = _s1jxW::P64;
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nPa() //  [R1]
         { info_tbl: [(c1nPa,
                       label: block_c1nPa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nPa: // global
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = R1;
           Sp = Sp + 24;
           call g_r1j3N_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.507944266 UTC

[section ""cstring" . lvl5_r1j3O_bytes" {
     lvl5_r1j3O_bytes:
         I8[] [78,101,103,97,116,105,118,101,32,101,120,112,111,110,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.508780806 UTC

[section ""data" . GHC.Real.^1_closure" {
     GHC.Real.^1_closure:
         const GHC.Real.^1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.^1_entry() //  [R1]
         { info_tbl: [(c1nPU,
                       label: GHC.Real.^1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nPU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nPV; else goto c1nPW;
       c1nPV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nPW: // global
           (_c1nPP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1nPP::I64 == 0) goto c1nPR; else goto c1nPQ;
       c1nPR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1nPQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1nPP::I64;
           I64[Sp - 24] = block_c1nPS_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1nPS() //  [R1]
         { info_tbl: [(c1nPS,
                       label: block_c1nPS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nPS: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.510122393 UTC

[section ""data" . GHC.Real.^_$s^_closure" {
     GHC.Real.^_$s^_closure:
         const GHC.Real.^_$s^_info;
         const 0;
 },
 section ""relreadonly" . u1nQt_srtd" {
     u1nQt_srtd:
         const S1jKw_srt+1008;
         const 35;
         const 28051505153;
 },
 GHC.Real.^_$s^_entry() //  [R2, R3]
         { info_tbl: [(c1nQ9,
                       label: GHC.Real.^_$s^_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nQ9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nQa; else goto c1nQb;
       c1nQa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_$s^_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nQb: // global
           I64[Sp - 24] = block_c1nQ4_info;
           _s1jy7::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jy6::P64 = R2;
           R2 = _s1jy7::P64;
           P64[Sp - 16] = _s1jy6::P64;
           P64[Sp - 8] = _s1jy7::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nQu_srtd" {
     u1nQu_srtd:
         const S1jKw_srt+1008;
         const 35;
         const 19461570561;
 },
 _c1nQ4() //  [R1]
         { info_tbl: [(c1nQ4,
                       label: block_c1nQ4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nQ4: // global
           if (R1 == 1) goto c1nQ8; else goto c1nQ7;
       c1nQ8: // global
           R1 = GHC.Real.^1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1nQ7: // global
           I64[Sp] = block_c1nQe_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nQe() //  [R1]
         { info_tbl: [(c1nQe,
                       label: block_c1nQe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nQe: // global
           if (R1 == 1) goto c1nQp; else goto c1nQl;
       c1nQp: // global
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1nQl: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.^_f_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.511739514 UTC

[section ""data" . GHC.Real.$w$s$cfromEnum_closure" {
     GHC.Real.$w$s$cfromEnum_closure:
         const GHC.Real.$w$s$cfromEnum_info;
         const 0;
 },
 GHC.Real.$w$s$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c1nQE,
                       label: GHC.Real.$w$s$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nQE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nQF; else goto c1nQG;
       c1nQF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nQG: // global
           I64[Sp - 24] = block_c1nQz_info;
           _s1jyb::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jya::P64 = R2;
           R2 = _s1jyb::P64;
           P64[Sp - 16] = _s1jya::P64;
           P64[Sp - 8] = _s1jyb::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nQz() //  [R1]
         { info_tbl: [(c1nQz,
                       label: block_c1nQz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nQz: // global
           if (R1 == 1) goto c1nQD; else goto c1nQC;
       c1nQD: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1nQC: // global
           _s1jyb::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1nQJ_info;
           R3 = _s1jyb::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nQJ() //  [R1]
         { info_tbl: [(c1nQJ,
                       label: block_c1nQJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nQJ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.513789856 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$cfromEnum_closure" {
     GHC.Real.$fEnumRatio_$s$cfromEnum_closure:
         const GHC.Real.$fEnumRatio_$s$cfromEnum_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$cfromEnum_entry() //  [R2]
         { info_tbl: [(c1nQX,
                       label: GHC.Real.$fEnumRatio_$s$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nQX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1nR5; else goto c1nR6;
       c1nR5: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nR6: // global
           I64[Sp - 8] = block_c1nQU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1nRb; else goto c1nQV;
       u1nRb: // global
           call _c1nQU(R1) args: 0, res: 0, upd: 0;
       c1nQV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nQU() //  [R1]
         { info_tbl: [(c1nQU,
                       label: block_c1nQU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nQU: // global
           I64[Sp] = block_c1nR0_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$cfromEnum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nR0() //  [R1]
         { info_tbl: [(c1nR0,
                       label: block_c1nR0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nR0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1nRa; else goto c1nR9;
       c1nRa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1nR9: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.515534947 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cfromEnum_closure" {
     GHC.Real.$fEnumRatio_$cfromEnum_closure:
         const GHC.Real.$fEnumRatio_$cfromEnum_info;
 },
 sat_s1jyu_entry() //  [R1]
         { info_tbl: [(c1nRr,
                       label: sat_s1jyu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nRr: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1nRs; else goto c1nRt;
       c1nRs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nRt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1nRp_info;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_pp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1nRp() //  [R1]
         { info_tbl: [(c1nRp,
                       label: block_c1nRp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nRp: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fEnumRatio_$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c1nRx,
                       label: GHC.Real.$fEnumRatio_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nRx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nRH; else goto c1nRI;
       c1nRH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nRI: // global
           I64[Sp - 16] = block_c1nRg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nRQ; else goto c1nRh;
       u1nRQ: // global
           call _c1nRg(R1) args: 0, res: 0, upd: 0;
       c1nRh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nRg() //  [R1]
         { info_tbl: [(c1nRg,
                       label: block_c1nRg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nRg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1nRL; else goto c1nRK;
       c1nRL: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nRK: // global
           _s1jyp::P64 = P64[R1 + 7];
           _s1jyq::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s1jyu_info;
           _s1jym::P64 = P64[Sp + 8];
           P64[Hp - 16] = _s1jym::P64;
           P64[Hp - 8] = _s1jyp::P64;
           P64[Hp] = _s1jyq::P64;
           I64[Sp + 8] = block_c1nRy_info;
           R2 = _s1jym::P64;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Hp - 32;
           Sp = Sp - 8;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1nRy() //  [R1]
         { info_tbl: [(c1nRy,
                       label: block_c1nRy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nRy: // global
           I64[Sp] = block_c1nRC_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nRC() //  [R1]
         { info_tbl: [(c1nRC,
                       label: block_c1nRC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nRC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1nRP; else goto c1nRO;
       c1nRP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1nRO: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.517417168 UTC

[section ""data" . GHC.Real.ratioPrec1_closure" {
     GHC.Real.ratioPrec1_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.517902125 UTC

[section ""cstring" . GHC.Real.$fShowRatio2_bytes" {
     GHC.Real.$fShowRatio2_bytes:
         I8[] [32,37,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.519848463 UTC

[section ""data" . GHC.Real.$w$s$cshowsPrec_closure" {
     GHC.Real.$w$s$cshowsPrec_closure:
         const GHC.Real.$w$s$cshowsPrec_info;
         const 0;
 },
 GHC.Real.$w$s$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nRS: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Real.$w$s$cshowsPrec_entry(R5,
                                               R4,
                                               R3,
                                               R2,
                                               R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jyF_entry() //  [R1]
         { info_tbl: [(c1nSa,
                       label: sat_s1jyF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nSa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nSb; else goto c1nSc;
       c1nSb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nSc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1nS7_info;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1nS7() //  [R1, R2]
         { info_tbl: [(c1nS7,
                       label: block_c1nS7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nS7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nSf; else goto c1nSe;
       c1nSf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1nSe: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jyG_entry() //  [R1]
         { info_tbl: [(c1nSg,
                       label: sat_s1jyG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nSg: // global
           _s1jyG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1nSh; else goto c1nSi;
       c1nSi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1nSk; else goto c1nSj;
       c1nSk: // global
           HpAlloc = 32;
           goto c1nSh;
       c1nSh: // global
           R1 = _s1jyG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nSj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jyG::P64;
           _s1jyz::P64 = P64[_s1jyG::P64 + 16];
           _s1jyA::P64 = P64[_s1jyG::P64 + 24];
           I64[Hp - 24] = sat_s1jyF_info;
           P64[Hp - 8] = _s1jyz::P64;
           P64[Hp] = _s1jyA::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jyL_entry() //  [R1]
         { info_tbl: [(c1nSC,
                       label: sat_s1jyL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nSC: // global
           _s1jyL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1nSD; else goto c1nSE;
       c1nSE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nSG; else goto c1nSF;
       c1nSG: // global
           HpAlloc = 24;
           goto c1nSD;
       c1nSD: // global
           R1 = _s1jyL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nSF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jyL::P64;
           _s1jyz::P64 = P64[_s1jyL::P64 + 16];
           _s1jyA::P64 = P64[_s1jyL::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s1jyA::P64;
           I64[Sp - 24] = block_c1nSz_info;
           R4 = Hp - 14;
           R3 = _s1jyz::P64;
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1nSz() //  [R1, R2]
         { info_tbl: [(c1nSz,
                       label: block_c1nSz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nSz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nSJ; else goto c1nSI;
       c1nSJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1nSI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jyM_entry() //  [R1]
         { info_tbl: [(c1nSK,
                       label: sat_s1jyM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nSK: // global
           _s1jyM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1nSL; else goto c1nSM;
       c1nSM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1nSO; else goto c1nSN;
       c1nSO: // global
           HpAlloc = 32;
           goto c1nSL;
       c1nSL: // global
           R1 = _s1jyM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nSN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jyM::P64;
           _s1jyz::P64 = P64[_s1jyM::P64 + 16];
           _s1jyA::P64 = P64[_s1jyM::P64 + 24];
           I64[Hp - 24] = sat_s1jyL_info;
           P64[Hp - 8] = _s1jyz::P64;
           P64[Hp] = _s1jyA::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jyQ_entry() //  [R1]
         { info_tbl: [(c1nSS,
                       label: sat_s1jyQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nSS: // global
           _s1jyQ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1nST; else goto c1nSU;
       c1nSU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1nSW; else goto c1nSV;
       c1nSW: // global
           HpAlloc = 32;
           goto c1nST;
       c1nST: // global
           R1 = _s1jyQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nSV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jyQ::P64;
           _s1jyy::P64 = P64[_s1jyQ::P64 + 16];
           _s1jyz::P64 = P64[_s1jyQ::P64 + 24];
           _s1jyA::P64 = P64[_s1jyQ::P64 + 32];
           I64[Hp - 24] = sat_s1jyM_info;
           P64[Hp - 8] = _s1jyz::P64;
           P64[Hp] = _s1jyA::P64;
           I64[Sp - 24] = block_c1nSP_info;
           R4 = Hp - 24;
           R3 = _s1jyy::P64;
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1nSP() //  [R1, R2]
         { info_tbl: [(c1nSP,
                       label: block_c1nSP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nSP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nSZ; else goto c1nSY;
       c1nSZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1nSY: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$s$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1nT3,
                       label: GHC.Real.$w$s$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nT3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1nT7; else goto c1nT6;
       c1nT7: // global
           HpAlloc = 40;
           R1 = GHC.Real.$w$s$cshowsPrec_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c1nT6: // global
           if (%MO_S_Le_W64(R2, 7)) goto c1nT1; else goto c1nT2;
       c1nT1: // global
           I64[Hp - 32] = sat_s1jyG_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           _c1nRZ::P64 = Hp - 32;
           Hp = Hp - 8;
           R4 = _c1nRZ::P64;
           R3 = R3;
           R2 = 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
       c1nT2: // global
           I64[Hp - 32] = sat_s1jyQ_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 32;
           R1 = GHC.Show.$fShow(,)4_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.523949462 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$cshowsPrec_closure" {
     GHC.Real.$fShowRatio_$s$cshowsPrec_closure:
         const GHC.Real.$fShowRatio_$s$cshowsPrec_info;
         const 0;
 },
 GHC.Real.$fShowRatio_$s$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nTf,
                       label: GHC.Real.$fShowRatio_$s$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nTf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nTq; else goto c1nTr;
       c1nTq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$s$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nTr: // global
           I64[Sp - 24] = block_c1nTc_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1nTy; else goto c1nTd;
       u1nTy: // global
           call _c1nTc(R1) args: 0, res: 0, upd: 0;
       c1nTd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nTc() //  [R1]
         { info_tbl: [(c1nTc,
                       label: block_c1nTc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nTc: // global
           I64[Sp] = block_c1nTi_info;
           _s1jyV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jyV::I64;
           if (R1 & 7 != 0) goto u1nTx; else goto c1nTj;
       u1nTx: // global
           call _c1nTi(R1) args: 0, res: 0, upd: 0;
       c1nTj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nTi() //  [R1]
         { info_tbl: [(c1nTi,
                       label: block_c1nTi_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nTi: // global
           _s1jyT::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1nTn_info;
           R5 = _s1jyT::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cshowsPrec_entry(R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nTn() //  [R1, R2]
         { info_tbl: [(c1nTn,
                       label: block_c1nTn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nTn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nTw; else goto c1nTv;
       c1nTw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nTv: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.527118568 UTC

[section ""data" . GHC.Real.$w$cshowsPrec_closure" {
     GHC.Real.$w$cshowsPrec_closure:
         const GHC.Real.$w$cshowsPrec_info;
 },
 GHC.Real.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nTA: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Real.$w$cshowsPrec_entry(R5,
                                             R4,
                                             R3,
                                             R2,
                                             R1) args: 8, res: 0, upd: 8;
     }
 },
 f_s1jz6_entry() //  [R1]
         { info_tbl: [(c1nTI,
                       label: f_s1jz6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nTI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nTJ; else goto c1nTK;
       c1nTJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nTK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 g1_s1jz7_entry() //  [R1]
         { info_tbl: [(c1nTP,
                       label: g1_s1jz7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nTP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nTQ; else goto c1nTR;
       c1nTQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nTR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jzb_entry() //  [R1]
         { info_tbl: [(c1nU5,
                       label: sat_s1jzb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nU5: // global
           _s1jzb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1nU6; else goto c1nU7;
       c1nU7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1nU9; else goto c1nU8;
       c1nU9: // global
           HpAlloc = 32;
           goto c1nU6;
       c1nU6: // global
           R1 = _s1jzb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nU8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzb::P64;
           _s1jz7::P64 = P64[_s1jzb::P64 + 16];
           _s1jz9::P64 = P64[_s1jzb::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s1jz7::P64;
           P64[Hp] = _s1jz9::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzc_entry() //  [R1, R2]
         { info_tbl: [(c1nUa,
                       label: sat_s1jzc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nUa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1nUe; else goto c1nUd;
       c1nUe: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nUd: // global
           _s1jz6::P64 = P64[R1 + 7];
           _s1jz7::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s1jzb_info;
           P64[Hp - 8] = _s1jz7::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _s1jz6::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jzf_entry() //  [R1]
         { info_tbl: [(c1nUy,
                       label: sat_s1jzf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nUy: // global
           _s1jzf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1nUz; else goto c1nUA;
       c1nUA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nUC; else goto c1nUB;
       c1nUC: // global
           HpAlloc = 24;
           goto c1nUz;
       c1nUz: // global
           R1 = _s1jzf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nUB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzf::P64;
           _s1jz7::P64 = P64[_s1jzf::P64 + 16];
           _s1jzd::P64 = P64[_s1jzf::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s1jzd::P64;
           R2 = Hp - 14;
           R1 = _s1jz7::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzg_entry() //  [R1]
         { info_tbl: [(c1nUD,
                       label: sat_s1jzg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nUD: // global
           _s1jzg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1nUE; else goto c1nUF;
       c1nUF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1nUH; else goto c1nUG;
       c1nUH: // global
           HpAlloc = 32;
           goto c1nUE;
       c1nUE: // global
           R1 = _s1jzg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nUG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzg::P64;
           _s1jz7::P64 = P64[_s1jzg::P64 + 16];
           _s1jzd::P64 = P64[_s1jzg::P64 + 24];
           I64[Hp - 24] = sat_s1jzf_info;
           P64[Hp - 8] = _s1jz7::P64;
           P64[Hp] = _s1jzd::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzh_entry() //  [R1]
         { info_tbl: [(c1nUI,
                       label: sat_s1jzh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nUI: // global
           _s1jzh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1nUJ; else goto c1nUK;
       c1nUK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1nUM; else goto c1nUL;
       c1nUM: // global
           HpAlloc = 32;
           goto c1nUJ;
       c1nUJ: // global
           R1 = _s1jzh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nUL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzh::P64;
           _s1jz6::P64 = P64[_s1jzh::P64 + 16];
           _s1jz7::P64 = P64[_s1jzh::P64 + 24];
           _s1jzd::P64 = P64[_s1jzh::P64 + 32];
           I64[Hp - 24] = sat_s1jzg_info;
           P64[Hp - 8] = _s1jz7::P64;
           P64[Hp] = _s1jzd::P64;
           R2 = Hp - 24;
           R1 = _s1jz6::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzi_entry() //  [R1, R2]
         { info_tbl: [(c1nUO,
                       label: sat_s1jzi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nUO: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1nUS; else goto c1nUR;
       c1nUS: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nUR: // global
           _s1jz6::P64 = P64[R1 + 7];
           _s1jz7::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s1jzh_info;
           P64[Hp - 40] = _s1jz6::P64;
           P64[Hp - 32] = _s1jz7::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$w$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1nUW,
                       label: GHC.Real.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nUW: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1nV0; else goto c1nUZ;
       c1nV0: // global
           HpAlloc = 88;
           R1 = GHC.Real.$w$cshowsPrec_closure;
           P64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c1nUZ: // global
           I64[Hp - 80] = f_s1jz6_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = g1_s1jz7_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R5;
           _c1nTE::P64 = Hp - 80;
           _c1nTL::P64 = Hp - 48;
           if (%MO_S_Le_W64(R3, 7)) goto c1nUU; else goto c1nUV;
       c1nUU: // global
           I64[Hp - 16] = sat_s1jzc_info;
           P64[Hp - 8] = _c1nTE::P64;
           P64[Hp] = _c1nTL::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1nUV: // global
           I64[Hp - 16] = sat_s1jzi_info;
           P64[Hp - 8] = _c1nTE::P64;
           P64[Hp] = _c1nTL::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.531459058 UTC

[section ""data" . GHC.Real.$fShowRatio_$cshowsPrec_closure" {
     GHC.Real.$fShowRatio_$cshowsPrec_closure:
         const GHC.Real.$fShowRatio_$cshowsPrec_info;
 },
 GHC.Real.$fShowRatio_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nV8,
                       label: GHC.Real.$fShowRatio_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nV8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nVc; else goto c1nVd;
       c1nVc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nVd: // global
           I64[Sp - 24] = block_c1nV5_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1nVl; else goto c1nV6;
       u1nVl: // global
           call _c1nV5(R1) args: 0, res: 0, upd: 0;
       c1nV6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nV5() //  [R1]
         { info_tbl: [(c1nV5,
                       label: block_c1nV5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nV5: // global
           I64[Sp] = block_c1nVb_info;
           _s1jzn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s1jzn::I64;
           if (R1 & 7 != 0) goto u1nVk; else goto c1nVf;
       u1nVk: // global
           call _c1nVb(R1) args: 0, res: 0, upd: 0;
       c1nVf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nVb() //  [R1]
         { info_tbl: [(c1nVb,
                       label: block_c1nVb_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nVb: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cshowsPrec_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.533072252 UTC

[section ""data" . GHC.Real.$fShowRatio1_closure" {
     GHC.Real.$fShowRatio1_closure:
         const GHC.Real.$fShowRatio1_info;
         const 0;
 },
 GHC.Real.$fShowRatio1_entry() //  [R2, R3]
         { info_tbl: [(c1nVt,
                       label: GHC.Real.$fShowRatio1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nVt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nVz; else goto c1nVA;
       c1nVz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nVA: // global
           I64[Sp - 16] = block_c1nVq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nVF; else goto c1nVr;
       u1nVF: // global
           call _c1nVq(R1) args: 0, res: 0, upd: 0;
       c1nVr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nVq() //  [R1]
         { info_tbl: [(c1nVq,
                       label: block_c1nVq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nVq: // global
           _s1jzs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nVw_info;
           R5 = _s1jzs::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cshowsPrec_entry(R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nVw() //  [R1, R2]
         { info_tbl: [(c1nVw,
                       label: block_c1nVw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nVw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nVE; else goto c1nVD;
       c1nVE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nVD: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.53455378 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$cshowList_closure" {
     GHC.Real.$fShowRatio_$s$cshowList_closure:
         const GHC.Real.$fShowRatio_$s$cshowList_info;
         const 0;
 },
 GHC.Real.$fShowRatio_$s$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c1nVK,
                       label: GHC.Real.$fShowRatio_$s$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nVK: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Real.$fShowRatio1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.535700299 UTC

[section ""data" . GHC.Real.$fShowRatio_$cshowList_closure" {
     GHC.Real.$fShowRatio_$cshowList_closure:
         const GHC.Real.$fShowRatio_$cshowList_info;
 },
 sat_s1jzI_entry() //  [R1, R2]
         { info_tbl: [(c1nVZ,
                       label: sat_s1jzI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nVZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nW0; else goto c1nW1;
       c1nW0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nW1: // global
           I64[Sp - 16] = block_c1nVW_info;
           _s1jzB::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s1jzB::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nW5; else goto c1nVX;
       u1nW5: // global
           call _c1nVW(R1) args: 0, res: 0, upd: 0;
       c1nVX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nVW() //  [R1]
         { info_tbl: [(c1nVW,
                       label: block_c1nVW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nVW: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = 0;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cshowsPrec_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fShowRatio_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nW6,
                       label: GHC.Real.$fShowRatio_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nW6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1nWa; else goto c1nW9;
       c1nWa: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nW9: // global
           I64[Hp - 8] = sat_s1jzI_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.539169351 UTC

[section ""data" . GHC.Real.$w$s$cshow_closure" {
     GHC.Real.$w$s$cshow_closure:
         const GHC.Real.$w$s$cshow_info;
         const 0;
 },
 sat_s1jzO_entry() //  [R1]
         { info_tbl: [(c1nWq,
                       label: sat_s1jzO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nWq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nWr; else goto c1nWs;
       c1nWr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nWs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1nWn_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[R1 + 16];
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1nWn() //  [R1, R2]
         { info_tbl: [(c1nWn,
                       label: block_c1nWn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nWn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nWv; else goto c1nWu;
       c1nWv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1nWu: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzP_entry() //  [R1]
         { info_tbl: [(c1nWw,
                       label: sat_s1jzP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nWw: // global
           _s1jzP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1nWx; else goto c1nWy;
       c1nWy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nWA; else goto c1nWz;
       c1nWA: // global
           HpAlloc = 24;
           goto c1nWx;
       c1nWx: // global
           R1 = _s1jzP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nWz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzP::P64;
           _s1jzK::P64 = P64[_s1jzP::P64 + 16];
           I64[Hp - 16] = sat_s1jzO_info;
           P64[Hp] = _s1jzK::P64;
           R3 = Hp - 16;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$s$cshow_entry() //  [R2, R3]
         { info_tbl: [(c1nWB,
                       label: GHC.Real.$w$s$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nWB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nWF; else goto c1nWE;
       c1nWF: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nWE: // global
           I64[Hp - 16] = sat_s1jzP_info;
           P64[Hp] = R3;
           R4 = Hp - 16;
           R3 = R2;
           R2 = 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.541181742 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$cshow_closure" {
     GHC.Real.$fShowRatio_$s$cshow_closure:
         const GHC.Real.$fShowRatio_$s$cshow_info;
         const 0;
 },
 GHC.Real.$fShowRatio_$s$cshow_entry() //  [R2]
         { info_tbl: [(c1nWN,
                       label: GHC.Real.$fShowRatio_$s$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nWN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1nWT; else goto c1nWU;
       c1nWT: // global
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$s$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nWU: // global
           I64[Sp - 8] = block_c1nWK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1nWZ; else goto c1nWL;
       u1nWZ: // global
           call _c1nWK(R1) args: 0, res: 0, upd: 0;
       c1nWL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nWK() //  [R1]
         { info_tbl: [(c1nWK,
                       label: block_c1nWK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nWK: // global
           I64[Sp] = block_c1nWQ_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$cshow_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nWQ() //  [R1, R2]
         { info_tbl: [(c1nWQ,
                       label: block_c1nWQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nWQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1nWY; else goto c1nWX;
       c1nWY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1nWX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.542938039 UTC

[section ""data" . GHC.Real.$w$cshow_closure" {
     GHC.Real.$w$cshow_closure:
         const GHC.Real.$w$cshow_info;
 },
 sat_s1jA0_entry() //  [R1]
         { info_tbl: [(c1nXc,
                       label: sat_s1jA0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nXc: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1nXd; else goto c1nXe;
       c1nXd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nXe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s1jA1_entry() //  [R1]
         { info_tbl: [(c1nXf,
                       label: sat_s1jA1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nXf: // global
           _s1jA1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1nXg; else goto c1nXh;
       c1nXh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1nXj; else goto c1nXi;
       c1nXj: // global
           HpAlloc = 32;
           goto c1nXg;
       c1nXg: // global
           R1 = _s1jA1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nXi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jA1::P64;
           _s1jzX::P64 = P64[_s1jA1::P64 + 16];
           _s1jzZ::P64 = P64[_s1jA1::P64 + 24];
           I64[Hp - 24] = sat_s1jA0_info;
           P64[Hp - 8] = _s1jzX::P64;
           P64[Hp] = _s1jzZ::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$cshow_entry() //  [R2, R3, R4]
         { info_tbl: [(c1nXk,
                       label: GHC.Real.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nXk: // global
           _s1jzZ::P64 = R4;
           _s1jzY::P64 = R3;
           _s1jzX::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto c1nXl; else goto c1nXm;
       c1nXm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1nXo; else goto c1nXn;
       c1nXo: // global
           HpAlloc = 32;
           goto c1nXl;
       c1nXl: // global
           R4 = _s1jzZ::P64;
           R3 = _s1jzY::P64;
           R2 = _s1jzX::P64;
           R1 = GHC.Real.$w$cshow_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nXn: // global
           I64[Hp - 24] = sat_s1jA1_info;
           P64[Hp - 8] = _s1jzX::P64;
           P64[Hp] = _s1jzZ::P64;
           R2 = _s1jzX::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 16] = _s1jzY::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.544716478 UTC

[section ""data" . GHC.Real.$fShowRatio_$cshow_closure" {
     GHC.Real.$fShowRatio_$cshow_closure:
         const GHC.Real.$fShowRatio_$cshow_info;
 },
 GHC.Real.$fShowRatio_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c1nXw,
                       label: GHC.Real.$fShowRatio_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nXw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nXx; else goto c1nXy;
       c1nXx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nXy: // global
           I64[Sp - 16] = block_c1nXt_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nXC; else goto c1nXu;
       u1nXC: // global
           call _c1nXt(R1) args: 0, res: 0, upd: 0;
       c1nXu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nXt() //  [R1]
         { info_tbl: [(c1nXt,
                       label: block_c1nXt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nXt: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cshow_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.545799721 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$fShowRatio_closure" {
     GHC.Real.$fShowRatio_$s$fShowRatio_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Real.$fShowRatio_$s$cshowsPrec_closure+3;
         const GHC.Real.$fShowRatio_$s$cshow_closure+1;
         const GHC.Real.$fShowRatio_$s$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.546888432 UTC

[section ""data" . GHC.Real.$fShowRatio_closure" {
     GHC.Real.$fShowRatio_closure:
         const GHC.Real.$fShowRatio_info;
 },
 sat_s1jAa_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nXM,
                       label: sat_s1jAa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nXM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fShowRatio_$cshowList_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jA9_entry() //  [R1, R2]
         { info_tbl: [(c1nXU,
                       label: sat_s1jA9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nXU: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fShowRatio_$cshow_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jA8_entry() //  [R1, R2, R3]
         { info_tbl: [(c1nY2,
                       label: sat_s1jA8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nY2: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fShowRatio_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fShowRatio_entry() //  [R2]
         { info_tbl: [(c1nY6,
                       label: GHC.Real.$fShowRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nY6: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1nYa; else goto c1nY9;
       c1nYa: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1nY9: // global
           I64[Hp - 72] = sat_s1jAa_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1jA9_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s1jA8_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.548747752 UTC

[section ""data" . GHC.Real.$w$slcm_closure" {
     GHC.Real.$w$slcm_closure:
         const GHC.Real.$w$slcm_info;
         const 0;
 },
 section ""relreadonly" . u1nYQ_srtd" {
     u1nYQ_srtd:
         const S1jKw_srt+856;
         const 64;
         const 13835093239654252545;
 },
 GHC.Real.$w$slcm_entry() //  [R2, R3]
         { info_tbl: [(c1nYj,
                       label: GHC.Real.$w$slcm_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nYj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1nYk; else goto c1nYl;
       c1nYk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$slcm_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nYl: // global
           if (R3 == 0) goto c1nYi; else goto c1nYh;
       c1nYi: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1nYh: // global
           I64[Sp - 16] = block_c1nYn_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nYP; else goto c1nYo;
       u1nYP: // global
           call _c1nYn(R1) args: 0, res: 0, upd: 0;
       c1nYo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1nYR_srtd" {
     u1nYR_srtd:
         const S1jKw_srt+856;
         const 63;
         const 4611721202799476737;
 },
 _c1nYn() //  [R1]
         { info_tbl: [(c1nYn,
                       label: block_c1nYn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nYn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1nYu; else goto c1nYt;
       c1nYu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1nYt: // global
           _s1jAg::I64 = I64[R1 + 7];
           if (_s1jAg::I64 == 0) goto c1nYO; else goto c1nYA;
       c1nYO: // global
           Hp = Hp - 16;
           R1 = 0;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1nYA: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp - 8] = block_c1nYy_info;
           R4 = Hp - 7;
           R3 = R1;
           R2 = GHC.Real.$fIntegralWord_closure+1;
           I64[Sp] = _s1jAg::I64;
           Sp = Sp - 8;
           call GHC.Real.gcd_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nYy() //  [R1]
         { info_tbl: [(c1nYy,
                       label: block_c1nYy_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nYy: // global
           _s1jAk::I64 = I64[R1 + 7];
           if (_s1jAk::I64 != 0) goto c1nYM; else goto c1nYN;
       c1nYM: // global
           R1 = I64[Sp + 8] / _s1jAk::I64 * I64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1nYN: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.550697553 UTC

[section ""data" . GHC.Real.lcm_$slcm_closure" {
     GHC.Real.lcm_$slcm_closure:
         const GHC.Real.lcm_$slcm_info;
         const 0;
 },
 GHC.Real.lcm_$slcm_entry() //  [R2, R3]
         { info_tbl: [(c1nYZ,
                       label: GHC.Real.lcm_$slcm_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nYZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1nZ7; else goto c1nZ8;
       c1nZ7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.lcm_$slcm_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nZ8: // global
           I64[Sp - 16] = block_c1nYW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1nZd; else goto c1nYX;
       u1nZd: // global
           call _c1nYW(R1) args: 0, res: 0, upd: 0;
       c1nYX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1nYW() //  [R1]
         { info_tbl: [(c1nYW,
                       label: block_c1nYW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nYW: // global
           _s1jAn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1nZ2_info;
           R3 = I64[R1 + 7];
           R2 = _s1jAn::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$slcm_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1nZ2() //  [R1]
         { info_tbl: [(c1nZ2,
                       label: block_c1nZ2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nZ2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1nZc; else goto c1nZb;
       c1nZc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1nZb: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.553183552 UTC

[section ""data" . GHC.Real.$w$slcm1_closure" {
     GHC.Real.$w$slcm1_closure:
         const GHC.Real.$w$slcm1_info;
         const 0;
 },
 sat_s1jAC_entry() //  [R1]
         { info_tbl: [(c1nZF,
                       label: sat_s1jAC_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nZF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1nZJ; else goto c1nZI;
       c1nZJ: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1nZI: // global
           _s1jAx::I64 = I64[R1 + 24];
           if (%MO_S_Lt_W64(_s1jAx::I64, 0)) goto c1nZD; else goto c1nZE;
       c1nZD: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_s1jAx::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1nZE: // global
           _s1jAv::P64 = P64[R1 + 16];
           Hp = Hp - 16;
           R1 = _s1jAv::P64 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1o11_srtd" {
     u1o11_srtd:
         const S1jKw_srt+344;
         const 130;
         const 17;
         const 35184372088832;
         const 2;
 },
 GHC.Real.$w$slcm1_entry() //  [R2, R3]
         { info_tbl: [(c1nZS,
                       label: GHC.Real.$w$slcm1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nZS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1nZT; else goto c1nZU;
       c1nZT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$slcm1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1nZU: // global
           if (R3 == 0) goto u1o10; else goto c1nZQ;
       u1o10: // global
           call _c1nZR() args: 0, res: 0, upd: 0;
       c1nZQ: // global
           I64[Sp - 16] = block_c1nZk_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1o0Z; else goto c1nZl;
       u1o0Z: // global
           call _c1nZk(R1) args: 0, res: 0, upd: 0;
       c1nZl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1o12_srtd" {
     u1o12_srtd:
         const S1jKw_srt+344;
         const 110;
         const 17;
         const 35184372088832;
 },
 _c1nZk() //  [R1]
         { info_tbl: [(c1nZk,
                       label: block_c1nZk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nZk: // global
           _s1jAx::I64 = I64[R1 + 7];
           if (_s1jAx::I64 == 0) goto u1o0R; else goto c1o0M;
       u1o0R: // global
           Sp = Sp + 16;
           call _c1nZR() args: 0, res: 0, upd: 0;
       c1o0M: // global
           _s1jAu::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s1jAu::I64, 0)) goto c1o0J; else goto c1o0K;
       c1o0J: // global
           I64[Sp - 16] = _s1jAx::I64;
           I64[Sp - 8] = -_s1jAu::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           goto u1o0X;
       c1o0K: // global
           P64[Sp] = R1;
           I64[Sp - 16] = _s1jAx::I64;
           I64[Sp - 8] = _s1jAu::I64;
           Sp = Sp - 16;
           goto u1o0X;
       u1o0X: // global
           call _c1nZu() args: 0, res: 0, upd: 0;
     }
 },
 _c1nZR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nZR: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1nZu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nZu: // global
           Hp = Hp + 32;
           _s1jAz::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c1nZZ; else goto c1nZY;
       c1nZZ: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_c1nZt_info;
           R1 = _s1jAz::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1nZY: // global
           I64[Hp - 24] = sat_s1jAC_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp];
           I64[Sp - 8] = block_c1nZW_info;
           R3 = _s1jAz::I64;
           R2 = Hp - 24;
           Sp = Sp - 8;
           call GHC.Real.$wgcd'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1o13_srtd" {
     u1o13_srtd:
         const S1jKw_srt+344;
         const 110;
         const 17;
         const 35184372088832;
 },
 _c1nZt() //  [R1]
         { info_tbl: [(c1nZt,
                       label: block_c1nZt_info
                       rep:StackRep [True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nZt: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c1nZu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1o14_srtd" {
     u1o14_srtd:
         const S1jKw_srt+344;
         const 110;
         const 1;
         const 35184372088832;
 },
 _c1nZW() //  [R1]
         { info_tbl: [(c1nZW,
                       label: block_c1nZW_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1nZW: // global
           _s1jAu::I64 = I64[Sp + 32];
           _s1jAx::I64 = I64[Sp + 8];
           _s1jAF::I64 = I64[R1 + 7];
           if (_s1jAF::I64 != (-1)) goto u1o0Q; else goto c1o0E;
       u1o0Q: // global
           if (_s1jAF::I64 != 0) goto c1o0k; else goto c1o0F;
       c1o0k: // global
           _s1jAH::I64 = %MO_S_Quot_W64(_s1jAx::I64,
                                        _s1jAF::I64) * _s1jAu::I64;
           if (%MO_S_Lt_W64(_s1jAH::I64, 0)) goto c1o0h; else goto c1o0i;
       c1o0h: // global
           R1 = -_s1jAH::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1o0i: // global
           R1 = _s1jAH::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1o0F: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1o0E: // global
           if (_s1jAx::I64 == (-9223372036854775808)) goto c1o0D; else goto c1o0C;
       c1o0D: // global
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1o0C: // global
           _s1jAK::I64 = %MO_S_Quot_W64(_s1jAx::I64, (-1)) * _s1jAu::I64;
           if (%MO_S_Lt_W64(_s1jAK::I64, 0)) goto c1o0z; else goto c1o0A;
       c1o0z: // global
           R1 = -_s1jAK::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1o0A: // global
           R1 = _s1jAK::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.556289224 UTC

[section ""data" . GHC.Real.lcm_$slcm1_closure" {
     GHC.Real.lcm_$slcm1_closure:
         const GHC.Real.lcm_$slcm1_info;
         const 0;
 },
 GHC.Real.lcm_$slcm1_entry() //  [R2, R3]
         { info_tbl: [(c1o1c,
                       label: GHC.Real.lcm_$slcm1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o1c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1o1k; else goto c1o1l;
       c1o1k: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.lcm_$slcm1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1o1l: // global
           I64[Sp - 16] = block_c1o19_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1o1q; else goto c1o1a;
       u1o1q: // global
           call _c1o19(R1) args: 0, res: 0, upd: 0;
       c1o1a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1o19() //  [R1]
         { info_tbl: [(c1o19,
                       label: block_c1o19_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o19: // global
           _s1jAR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1o1f_info;
           R3 = I64[R1 + 7];
           R2 = _s1jAR::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$slcm1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1o1f() //  [R1]
         { info_tbl: [(c1o1f,
                       label: block_c1o1f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o1f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1o1p; else goto c1o1o;
       c1o1p: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1o1o: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.559077426 UTC

[section ""data" . GHC.Real.lcm_closure" {
     GHC.Real.lcm_closure:
         const GHC.Real.lcm_info;
         const 0;
 },
 sat_s1jB3_entry() //  [R1]
         { info_tbl: [(c1o1P,
                       label: sat_s1jB3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o1P: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1o1Q; else goto c1o1R;
       c1o1Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1o1R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jB5_entry() //  [R1]
         { info_tbl: [(c1o20,
                       label: sat_s1jB5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o20: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1o21; else goto c1o22;
       c1o21: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1o22: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jB7_entry() //  [R1]
         { info_tbl: [(c1o2j,
                       label: sat_s1jB7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o2j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1o2k; else goto c1o2l;
       c1o2k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1o2l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.gcd_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jB8_entry() //  [R1]
         { info_tbl: [(c1o2m,
                       label: sat_s1jB8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o2m: // global
           _s1jB8::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1o2n; else goto c1o2o;
       c1o2o: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1o2q; else goto c1o2p;
       c1o2q: // global
           HpAlloc = 40;
           goto c1o2n;
       c1o2n: // global
           R1 = _s1jB8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1o2p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jB8::P64;
           _s1jAW::P64 = P64[_s1jB8::P64 + 16];
           _s1jAX::P64 = P64[_s1jB8::P64 + 24];
           _s1jAY::P64 = P64[_s1jB8::P64 + 32];
           I64[Hp - 32] = sat_s1jB7_info;
           P64[Hp - 16] = _s1jAW::P64;
           P64[Hp - 8] = _s1jAX::P64;
           P64[Hp] = _s1jAY::P64;
           R2 = _s1jAW::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1jAX::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jB9_entry() //  [R1]
         { info_tbl: [(c1o2r,
                       label: sat_s1jB9_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o2r: // global
           _s1jB9::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1o2s; else goto c1o2t;
       c1o2t: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1o2v; else goto c1o2u;
       c1o2v: // global
           HpAlloc = 40;
           goto c1o2s;
       c1o2s: // global
           R1 = _s1jB9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1o2u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jB9::P64;
           _s1jAW::P64 = P64[_s1jB9::P64 + 16];
           _s1jAX::P64 = P64[_s1jB9::P64 + 24];
           _s1jAY::P64 = P64[_s1jB9::P64 + 32];
           _s1jB0::P64 = P64[_s1jB9::P64 + 40];
           I64[Hp - 32] = sat_s1jB8_info;
           P64[Hp - 16] = _s1jAW::P64;
           P64[Hp - 8] = _s1jAX::P64;
           P64[Hp] = _s1jAY::P64;
           R2 = _s1jB0::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _s1jAY::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.lcm_entry() //  [R2, R3, R4]
         { info_tbl: [(c1o2w,
                       label: GHC.Real.lcm_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o2w: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1o2x; else goto c1o2y;
       c1o2x: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.lcm_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1o2y: // global
           I64[Sp - 32] = block_c1o1v_info;
           _s1jAW::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1jAW::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1o1v() //  [R1]
         { info_tbl: [(c1o1v,
                       label: block_c1o1v_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o1v: // global
           I64[Sp - 8] = block_c1o1z_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1o1z() //  [R1]
         { info_tbl: [(c1o1z,
                       label: block_c1o1z_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o1z: // global
           I64[Sp] = block_c1o1D_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1o1D() //  [R1]
         { info_tbl: [(c1o1D,
                       label: block_c1o1D_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o1D: // global
           I64[Sp] = block_c1o1H_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1o1H() //  [R1]
         { info_tbl: [(c1o1H,
                       label: block_c1o1H_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o1H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1o2E; else goto c1o2D;
       c1o2E: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1o2D: // global
           I64[Hp - 16] = sat_s1jB3_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1o1S_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1o1S() //  [R1]
         { info_tbl: [(c1o1S,
                       label: block_c1o1S_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o1S: // global
           if (R1 & 7 == 1) goto c1o2G; else goto u1o2Z;
       c1o2G: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1o2J; else goto c1o2I;
       c1o2J: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1o2I: // global
           I64[Hp - 16] = sat_s1jB5_info;
           P64[Hp] = P64[Sp + 16];
           _s1jB2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1o23_info;
           R2 = _s1jB2::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       u1o2Z: // global
           Sp = Sp + 16;
           call _c1o2W() args: 0, res: 0, upd: 0;
     }
 },
 _c1o23() //  [R1]
         { info_tbl: [(c1o23,
                       label: block_c1o23_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o23: // global
           if (R1 & 7 == 1) goto c1o2L; else goto u1o30;
       c1o2L: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1o2O; else goto c1o2N;
       c1o2O: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1o2N: // global
           I64[Hp - 40] = sat_s1jB9_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           _s1jB0::P64 = P64[Sp + 8];
           P64[Hp] = _s1jB0::P64;
           R2 = _s1jB0::P64;
           I64[Sp + 24] = stg_ap_p_info;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 8;
       u1o30: // global
           Sp = Sp + 8;
           call _c1o2W() args: 0, res: 0, upd: 0;
     }
 },
 _c1o2W() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o2W: // global
           R2 = P64[Sp];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = GHC.Real.even1_closure;
           Sp = Sp + 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.563570239 UTC

[section ""data" . GHC.Real.$w$ctoEnum_closure" {
     GHC.Real.$w$ctoEnum_closure:
         const GHC.Real.$w$ctoEnum_info;
         const 0;
 },
 sat_s1jBg_entry() //  [R1]
         { info_tbl: [(c1o3m,
                       label: sat_s1jBg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o3m: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1o3n; else goto c1o3o;
       c1o3n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1o3o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1o3j_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1o3s; else goto c1o3k;
       u1o3s: // global
           call _c1o3j(R1) args: 0, res: 0, upd: 0;
       c1o3k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1o3j() //  [R1]
         { info_tbl: [(c1o3j,
                       label: block_c1o3j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o3j: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c1o3t,
                       label: GHC.Real.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o3t: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1o3x; else goto c1o3y;
       c1o3x: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1o3y: // global
           I64[Sp - 16] = block_c1o37_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1o37() //  [R1]
         { info_tbl: [(c1o37,
                       label: block_c1o37_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o37: // global
           I64[Sp] = block_c1o3b_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1o3b() //  [R1]
         { info_tbl: [(c1o3b,
                       label: block_c1o3b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o3b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1o3C; else goto c1o3B;
       c1o3C: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1o3B: // global
           I64[Hp - 16] = sat_s1jBg_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c1o3u_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1o3u() //  [R1]
         { info_tbl: [(c1o3u,
                       label: block_c1o3u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o3u: // global
           I64[Sp] = block_c1o3w_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Real.$fEnumRatio1_closure;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1o3w() //  [R1]
         { info_tbl: [(c1o3w,
                       label: block_c1o3w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o3w: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.565757603 UTC

[section ""data" . GHC.Real.$fEnumRatio_$ctoEnum_closure" {
     GHC.Real.$fEnumRatio_$ctoEnum_closure:
         const GHC.Real.$fEnumRatio_$ctoEnum_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c1o3N,
                       label: GHC.Real.$fEnumRatio_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o3N: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1o3O; else goto c1o3P;
       c1o3O: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1o3P: // global
           I64[Sp - 8] = block_c1o3K_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$ctoEnum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1o3K() //  [R1, R2]
         { info_tbl: [(c1o3K,
                       label: block_c1o3K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o3K: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1o3S; else goto c1o3R;
       c1o3S: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1o3R: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.566882786 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$fEnumRatio_closure" {
     GHC.Real.$fEnumRatio_$s$fEnumRatio_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Real.$fEnumRatio_$s$csucc_closure+1;
         const GHC.Real.$fEnumRatio_$s$cpred_closure+1;
         const GHC.Real.$fEnumRatio_$ctoRational_closure+1;
         const GHC.Real.$fEnumRatio_$s$cfromEnum_closure+1;
         const GHC.Real.$fEnumRatio_$snumericEnumFrom_closure+1;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure+2;
         const GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure+2;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.568574205 UTC

[section ""data" . GHC.Real.$fEnumRatio_closure" {
     GHC.Real.$fEnumRatio_closure:
         const GHC.Real.$fEnumRatio_info;
         const 0;
 },
 sat_s1jBw_entry() //  [R1]
         { info_tbl: [(c1o41,
                       label: sat_s1jBw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o41: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1o42; else goto c1o43;
       c1o42: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1o43: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jBv_entry() //  [R1]
         { info_tbl: [(c1o48,
                       label: sat_s1jBv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o48: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1o49; else goto c1o4a;
       c1o49: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1o4a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jBu_entry() //  [R1]
         { info_tbl: [(c1o4f,
                       label: sat_s1jBu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o4f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1o4g; else goto c1o4h;
       c1o4g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1o4h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jBt_entry() //  [R1]
         { info_tbl: [(c1o4m,
                       label: sat_s1jBt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o4m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1o4n; else goto c1o4o;
       c1o4n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1o4o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jBs_entry() //  [R1, R2]
         { info_tbl: [(c1o4u,
                       label: sat_s1jBs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o4u: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$cfromEnum_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jBr_entry() //  [R1, R2]
         { info_tbl: [(c1o4C,
                       label: sat_s1jBr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o4C: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$ctoEnum_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jBq_entry() //  [R1, R2]
         { info_tbl: [(c1o4K,
                       label: sat_s1jBq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o4K: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$cpred_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jBp_entry() //  [R1, R2]
         { info_tbl: [(c1o4S,
                       label: sat_s1jBp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o4S: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$csucc_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEnumRatio_entry() //  [R2]
         { info_tbl: [(c1o4W,
                       label: GHC.Real.$fEnumRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o4W: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c1o50; else goto c1o4Z;
       c1o50: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1o4Z: // global
           I64[Hp - 224] = sat_s1jBw_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s1jBv_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s1jBu_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1jBt_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s1jBs_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s1jBr_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s1jBq_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s1jBp_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = Hp - 95;
           P64[Hp - 40] = Hp - 111;
           P64[Hp - 32] = Hp - 127;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.572898785 UTC

[section ""data" . $wg_r1j3P_closure" {
     $wg_r1j3P_closure:
         const $wg_r1j3P_info;
 },
 $wg_r1j3P_entry() //  [R2, R3, R4]
         { info_tbl: [(c1o5a,
                       label: $wg_r1j3P_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o5a: // global
           _s1jBz::I64 = R4;
           _s1jBy::I64 = R3;
           _s1jBx::I64 = R2;
           goto c1o52;
       c1o52: // global
           if (_s1jBy::I64 - (_s1jBy::I64 + (_s1jBy::I64 >> 63)) & (-2) == 0) goto c1o59; else goto c1o58;
       c1o59: // global
           _s1jBy::I64 = %MO_S_Shr_W64(_s1jBy::I64 + (_s1jBy::I64 >> 63), 1);
           _s1jBx::I64 = _s1jBx::I64 * _s1jBx::I64;
           goto c1o52;
       c1o58: // global
           if (_s1jBy::I64 == 1) goto c1o5o; else goto c1o5k;
       c1o5o: // global
           R1 = _s1jBx::I64 * _s1jBz::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1o5k: // global
           _s1jBz::I64 = _s1jBx::I64 * _s1jBz::I64;
           _s1jBy::I64 = %MO_S_Shr_W64(_s1jBy::I64 + (_s1jBy::I64 >> 63), 1);
           _s1jBx::I64 = _s1jBx::I64 * _s1jBx::I64;
           goto c1o52;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.574217095 UTC

[section ""data" . GHC.Real.$wf1_closure" {
     GHC.Real.$wf1_closure:
         const GHC.Real.$wf1_info;
 },
 GHC.Real.$wf1_entry() //  [R2, R3]
         { info_tbl: [(c1o5O,
                       label: GHC.Real.$wf1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o5O: // global
           _s1jBI::I64 = R3;
           _s1jBH::I64 = R2;
           goto c1o5G;
       c1o5G: // global
           if (_s1jBI::I64 - (_s1jBI::I64 + (_s1jBI::I64 >> 63)) & (-2) == 0) goto c1o5N; else goto c1o5M;
       c1o5N: // global
           _s1jBI::I64 = %MO_S_Shr_W64(_s1jBI::I64 + (_s1jBI::I64 >> 63), 1);
           _s1jBH::I64 = _s1jBH::I64 * _s1jBH::I64;
           goto c1o5G;
       c1o5M: // global
           if (_s1jBI::I64 == 1) goto c1o5Z; else goto c1o5Y;
       c1o5Z: // global
           R1 = _s1jBH::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1o5Y: // global
           R4 = _s1jBH::I64;
           R3 = %MO_S_Shr_W64(_s1jBI::I64 + (_s1jBI::I64 >> 63), 1);
           R2 = _s1jBH::I64 * _s1jBH::I64;
           call $wg_r1j3P_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.57558176 UTC

[section ""data" . GHC.Real.^_f2_closure" {
     GHC.Real.^_f2_closure:
         const GHC.Real.^_f2_info;
 },
 GHC.Real.^_f2_entry() //  [R2, R3]
         { info_tbl: [(c1o6l,
                       label: GHC.Real.^_f2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o6l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1o6y; else goto c1o6z;
       c1o6y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_f2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1o6z: // global
           I64[Sp - 16] = block_c1o6i_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1o6G; else goto c1o6j;
       u1o6G: // global
           call _c1o6i(R1) args: 0, res: 0, upd: 0;
       c1o6j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1o6i() //  [R1]
         { info_tbl: [(c1o6i,
                       label: block_c1o6i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o6i: // global
           I64[Sp] = block_c1o6o_info;
           _s1jBS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jBS::I64;
           if (R1 & 7 != 0) goto u1o6F; else goto c1o6p;
       u1o6F: // global
           call _c1o6o(R1) args: 0, res: 0, upd: 0;
       c1o6p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1o6o() //  [R1]
         { info_tbl: [(c1o6o,
                       label: block_c1o6o_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o6o: // global
           _s1jBS::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1o6t_info;
           R3 = I64[R1 + 7];
           R2 = _s1jBS::I64;
           Sp = Sp + 8;
           call GHC.Real.$wf1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1o6t() //  [R1]
         { info_tbl: [(c1o6t,
                       label: block_c1o6t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o6t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1o6E; else goto c1o6D;
       c1o6E: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1o6D: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.576940832 UTC

[section ""data" . GHC.Real.^3_closure" {
     GHC.Real.^3_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.577855167 UTC

[section ""data" . GHC.Real.^2_closure" {
     GHC.Real.^2_closure:
         const GHC.Real.^2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.^2_entry() //  [R1]
         { info_tbl: [(c1o6P,
                       label: GHC.Real.^2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o6P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1o6Q; else goto c1o6R;
       c1o6Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1o6R: // global
           (_c1o6K::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1o6K::I64 == 0) goto c1o6M; else goto c1o6L;
       c1o6M: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1o6L: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1o6K::I64;
           I64[Sp - 24] = block_c1o6N_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1o6N() //  [R1]
         { info_tbl: [(c1o6N,
                       label: block_c1o6N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o6N: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.579335286 UTC

[section ""data" . GHC.Real.^_$s^2_closure" {
     GHC.Real.^_$s^2_closure:
         const GHC.Real.^_$s^2_info;
         const 0;
 },
 GHC.Real.^_$s^2_entry() //  [R2, R3]
         { info_tbl: [(c1o72,
                       label: GHC.Real.^_$s^2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o72: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1o73; else goto c1o74;
       c1o73: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_$s^2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1o74: // global
           I64[Sp - 16] = block_c1o6Z_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1o7y; else goto c1o70;
       u1o7y: // global
           call _c1o6Z(R1) args: 0, res: 0, upd: 0;
       c1o70: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1o6Z() //  [R1]
         { info_tbl: [(c1o6Z,
                       label: block_c1o6Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o6Z: // global
           _s1jC0::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1jC0::I64, 0)) goto c1o7v; else goto c1o7w;
       c1o7v: // global
           if (_s1jC0::I64 == 0) goto c1o7t; else goto c1o7o;
       c1o7t: // global
           R1 = GHC.Real.^3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1o7o: // global
           I64[Sp] = block_c1o7d_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jC0::I64;
           if (R1 & 7 != 0) goto u1o7x; else goto c1o7e;
       u1o7x: // global
           call _c1o7d(R1) args: 0, res: 0, upd: 0;
       c1o7e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1o7w: // global
           R1 = GHC.Real.^2_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1o7d() //  [R1]
         { info_tbl: [(c1o7d,
                       label: block_c1o7d_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o7d: // global
           _s1jC2::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1o7i_info;
           R3 = _s1jC2::I64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Real.$wf1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1o7i() //  [R1]
         { info_tbl: [(c1o7i,
                       label: block_c1o7i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o7i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1o7s; else goto c1o7r;
       c1o7s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1o7r: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.581577528 UTC

[section ""data" . $wg1_r1j3Q_closure" {
     $wg1_r1j3Q_closure:
         const $wg1_r1j3Q_info;
         const 0;
 },
 $wg1_r1j3Q_entry() //  [R2, R3, R4]
         { info_tbl: [(c1o7I,
                       label: $wg1_r1j3Q_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o7I: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1o7J; else goto u1o8l;
       c1o7J: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wg1_r1j3Q_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u1o8l: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c1o7A() args: 0, res: 0, upd: 0;
     }
 },
 _c1o7A() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o7A: // global
           _s1jC6::P64 = P64[Sp];
           _s1jC7::I64 = I64[Sp + 8];
           if (_s1jC7::I64 - (_s1jC7::I64 + (_s1jC7::I64 >> 63)) & (-2) == 0) goto c1o7H; else goto c1o7G;
       c1o7H: // global
           I64[Sp] = block_c1o8f_info;
           R3 = _s1jC6::P64;
           R2 = _s1jC6::P64;
           I64[Sp + 8] = %MO_S_Shr_W64(_s1jC7::I64 + (_s1jC7::I64 >> 63), 1);
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       c1o7G: // global
           _s1jC8::P64 = P64[Sp + 16];
           if (_s1jC7::I64 == 1) goto c1o87; else goto c1o81;
       c1o87: // global
           R3 = _s1jC8::P64;
           R2 = _s1jC6::P64;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
       c1o81: // global
           I64[Sp - 8] = block_c1o7S_info;
           R3 = _s1jC8::P64;
           R2 = _s1jC6::P64;
           I64[Sp + 16] = _s1jC7::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1o8f() //  [R1]
         { info_tbl: [(c1o8f,
                       label: block_c1o8f_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o8f: // global
           P64[Sp] = R1;
           I64[Sp + 8] = I64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           call _c1o7A() args: 0, res: 0, upd: 0;
     }
 },
 _c1o7S() //  [R1]
         { info_tbl: [(c1o7S,
                       label: block_c1o7S_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o7S: // global
           _s1jC6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1o7Z_info;
           R3 = _s1jC6::P64;
           R2 = _s1jC6::P64;
           P64[Sp + 16] = R1;
           _s1jCa::I64 = I64[Sp + 24];
           I64[Sp + 24] = %MO_S_Shr_W64(_s1jCa::I64 + (_s1jCa::I64 >> 63), 1);
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1o7Z() //  [R1]
         { info_tbl: [(c1o7Z,
                       label: block_c1o7Z_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o7Z: // global
           P64[Sp] = R1;
           _s1jC8::P64 = P64[Sp + 8];
           I64[Sp + 8] = I64[Sp + 16];
           P64[Sp + 16] = _s1jC8::P64;
           call _c1o7A() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.583745834 UTC

[section ""data" . GHC.Real.$wf_closure" {
     GHC.Real.$wf_closure:
         const GHC.Real.$wf_info;
         const 0;
 },
 GHC.Real.$wf_entry() //  [R2, R3]
         { info_tbl: [(c1o8A,
                       label: GHC.Real.$wf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o8A: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1o8B; else goto u1o98;
       c1o8B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wf_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1o98: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1o8s() args: 0, res: 0, upd: 0;
     }
 },
 _c1o8s() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o8s: // global
           _s1jCg::P64 = P64[Sp];
           _s1jCh::I64 = I64[Sp + 8];
           if (_s1jCh::I64 - (_s1jCh::I64 + (_s1jCh::I64 >> 63)) & (-2) == 0) goto c1o8z; else goto c1o8y;
       c1o8z: // global
           I64[Sp] = block_c1o92_info;
           R3 = _s1jCg::P64;
           R2 = _s1jCg::P64;
           I64[Sp + 8] = %MO_S_Shr_W64(_s1jCh::I64 + (_s1jCh::I64 >> 63), 1);
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       c1o8y: // global
           if (_s1jCh::I64 == 1) goto c1o8U; else goto c1o8P;
       c1o8U: // global
           R1 = _s1jCg::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1o8P: // global
           I64[Sp - 8] = block_c1o8N_info;
           R3 = _s1jCg::P64;
           R2 = _s1jCg::P64;
           I64[Sp + 8] = %MO_S_Shr_W64(_s1jCh::I64 + (_s1jCh::I64 >> 63), 1);
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1o92() //  [R1]
         { info_tbl: [(c1o92,
                       label: block_c1o92_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o92: // global
           P64[Sp] = R1;
           I64[Sp + 8] = I64[Sp + 8];
           call _c1o8s() args: 0, res: 0, upd: 0;
     }
 },
 _c1o8N() //  [R1]
         { info_tbl: [(c1o8N,
                       label: block_c1o8N_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o8N: // global
           R4 = P64[Sp + 8];
           R3 = I64[Sp + 16];
           R2 = R1;
           Sp = Sp + 24;
           call $wg1_r1j3Q_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.585517372 UTC

[section ""data" . GHC.Real.^_f1_closure" {
     GHC.Real.^_f1_closure:
         const GHC.Real.^_f1_info;
         const 0;
 },
 GHC.Real.^_f1_entry() //  [R2, R3]
         { info_tbl: [(c1o9j,
                       label: GHC.Real.^_f1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o9j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1o9k; else goto c1o9l;
       c1o9k: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_f1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1o9l: // global
           I64[Sp - 16] = block_c1o9g_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1o9p; else goto c1o9h;
       u1o9p: // global
           call _c1o9g(R1) args: 0, res: 0, upd: 0;
       c1o9h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1o9g() //  [R1]
         { info_tbl: [(c1o9g,
                       label: block_c1o9g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o9g: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$wf_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.586875151 UTC

[section ""data" . GHC.Real.^_$s^1_closure" {
     GHC.Real.^_$s^1_closure:
         const GHC.Real.^_$s^1_info;
         const 0;
 },
 section ""relreadonly" . u1o9O_srtd" {
     u1o9O_srtd:
         const S1jKw_srt+1280;
         const 33;
         const 5368840193;
 },
 GHC.Real.^_$s^1_entry() //  [R2, R3]
         { info_tbl: [(c1o9x,
                       label: GHC.Real.^_$s^1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o9x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1o9y; else goto c1o9z;
       c1o9y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_$s^1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1o9z: // global
           I64[Sp - 16] = block_c1o9u_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1o9N; else goto c1o9v;
       u1o9N: // global
           call _c1o9u(R1) args: 0, res: 0, upd: 0;
       c1o9v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1o9u() //  [R1]
         { info_tbl: [(c1o9u,
                       label: block_c1o9u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o9u: // global
           _s1jCv::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1jCv::I64, 0)) goto c1o9L; else goto c1o9M;
       c1o9L: // global
           if (_s1jCv::I64 == 0) goto c1o9J; else goto c1o9I;
       c1o9J: // global
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1o9I: // global
           R3 = _s1jCv::I64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$wf_entry(R3, R2) args: 8, res: 0, upd: 8;
       c1o9M: // global
           R1 = GHC.Real.^1_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.58832979 UTC

[section ""data" . lvl6_r1j3R_closure" {
     lvl6_r1j3R_closure:
         const lvl6_r1j3R_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r1j3R_entry() //  [R1]
         { info_tbl: [(c1o9X,
                       label: lvl6_r1j3R_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o9X: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1o9Y; else goto c1o9Z;
       c1o9Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1o9Z: // global
           (_c1o9S::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1o9S::I64 == 0) goto c1o9U; else goto c1o9T;
       c1o9U: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1o9T: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1o9S::I64;
           I64[Sp - 24] = block_c1o9V_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1o9V() //  [R1]
         { info_tbl: [(c1o9V,
                       label: block_c1o9V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1o9V: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.589587727 UTC

[section ""data" . lvl7_r1j3S_closure" {
     lvl7_r1j3S_closure:
         const lvl7_r1j3S_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r1j3S_entry() //  [R1]
         { info_tbl: [(c1oab,
                       label: lvl7_r1j3S_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oab: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1oac; else goto c1oad;
       c1oac: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oad: // global
           (_c1oa6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1oa6::I64 == 0) goto c1oa8; else goto c1oa7;
       c1oa8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1oa7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1oa6::I64;
           I64[Sp - 24] = block_c1oa9_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1oa9() //  [R1]
         { info_tbl: [(c1oa9,
                       label: block_c1oa9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oa9: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.595995187 UTC

[section ""data" . GHC.Real.^_closure" {
     GHC.Real.^_closure:
         const GHC.Real.^_info;
         const 0;
 },
 $dNum1_s1jCF_entry() //  [R1]
         { info_tbl: [(c1obK,
                       label: $dNum1_s1jCF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1obK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1obL; else goto c1obM;
       c1obL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1obM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jCH_entry() //  [R1]
         { info_tbl: [(c1obP,
                       label: sat_s1jCH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1obP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1obQ; else goto c1obR;
       c1obQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1obR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jCK_entry() //  [R1]
         { info_tbl: [(c1obU,
                       label: sat_s1jCK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1obU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1obV; else goto c1obW;
       c1obV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1obW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl8_s1jCM_entry() //  [R1]
         { info_tbl: [(c1obZ,
                       label: lvl8_s1jCM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1obZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oc0; else goto c1oc1;
       c1oc0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oc1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl9_s1jCR_entry() //  [R1]
         { info_tbl: [(c1oc4,
                       label: lvl9_s1jCR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oc4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oc5; else goto c1oc6;
       c1oc5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oc6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jD8_entry() //  [R1]
         { info_tbl: [(c1oc9,
                       label: sat_s1jD8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oc9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1oca; else goto c1ocb;
       c1oca: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ocb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD7_entry() //  [R1]
         { info_tbl: [(c1oce,
                       label: sat_s1jD7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oce: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ocf; else goto c1ocg;
       c1ocf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ocg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jCO::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1jCO::P64;
           P64[Sp - 24] = _s1jCO::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD4_entry() //  [R1]
         { info_tbl: [(c1ocj,
                       label: sat_s1jD4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ocj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ock; else goto c1ocl;
       c1ock: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ocl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD3_entry() //  [R1]
         { info_tbl: [(c1oco,
                       label: sat_s1jD3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oco: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ocp; else goto c1ocq;
       c1ocp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ocq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD2_entry() //  [R1]
         { info_tbl: [(c1ocu,
                       label: sat_s1jD2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ocu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ocv; else goto c1ocw;
       c1ocv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ocw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jCX::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1jCX::P64;
           P64[Sp - 24] = _s1jCX::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD6_entry() //  [R1]
         { info_tbl: [(c1ocz,
                       label: sat_s1jD6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ocz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ocA; else goto c1ocB;
       c1ocA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ocB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD5_entry() //  [R1]
         { info_tbl: [(c1ocF,
                       label: sat_s1jD5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ocF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ocG; else goto c1ocH;
       c1ocG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ocH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jCX::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1jCX::P64;
           P64[Sp - 24] = _s1jCX::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jDe_entry() //  [R1]
         { info_tbl: [(c1ocK,
                       label: sat_s1jDe_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ocK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ocL; else goto c1ocM;
       c1ocL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ocM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jDd_entry() //  [R1]
         { info_tbl: [(c1ocQ,
                       label: sat_s1jDd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ocQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ocR; else goto c1ocS;
       c1ocR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ocS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jDa::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1jDa::P64;
           P64[Sp - 24] = _s1jDa::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1ofX_srtd" {
     u1ofX_srtd:
         const S1jKw_srt+696;
         const 111;
         const 1;
         const 131941462441984;
 },
 GHC.Real.^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1ocT,
                       label: GHC.Real.^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ocT: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c1ocU; else goto c1ocV;
       c1ocU: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ocV: // global
           I64[Sp - 40] = block_c1oal_info;
           _s1jCA::P64 = R2;
           R2 = R3;
           P64[Sp - 32] = _s1jCA::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ofY_srtd" {
     u1ofY_srtd:
         const S1jKw_srt+696;
         const 111;
         const 1;
         const 96757090353152;
 },
 _c1oal() //  [R1]
         { info_tbl: [(c1oal,
                       label: block_c1oal_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oal: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ocY; else goto c1ocX;
       c1ocY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ocX: // global
           I64[Hp - 16] = $dNum1_s1jCF_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1oar_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ofZ_srtd" {
     u1ofZ_srtd:
         const S1jKw_srt+696;
         const 111;
         const 1;
         const 96757090353152;
 },
 _c1oar() //  [R1]
         { info_tbl: [(c1oar,
                       label: block_c1oar_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oar: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1od1; else goto c1od0;
       c1od1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1od0: // global
           I64[Hp - 16] = sat_s1jCH_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1oax_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 40];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1og0_srtd" {
     u1og0_srtd:
         const S1jKw_srt+696;
         const 111;
         const 1;
         const 96757090353152;
 },
 _c1oax() //  [R1]
         { info_tbl: [(c1oax,
                       label: block_c1oax_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oax: // global
           if (R1 & 7 == 1) goto c1od3; else goto c1oe1;
       c1od3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1od6; else goto c1od5;
       c1od6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1od5: // global
           I64[Hp - 16] = sat_s1jCK_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 8] = block_c1oaD_info;
           R2 = P64[Sp + 8];
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1oe1: // global
           R1 = lvl7_r1j3S_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1og1_srtd" {
     u1og1_srtd:
         const S1jKw_srt+696;
         const 109;
         const 1;
         const 17592253153280;
 },
 _c1oaD() //  [R1]
         { info_tbl: [(c1oaD,
                       label: block_c1oaD_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oaD: // global
           _c1oaB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1oaH_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 56];
           P64[Sp] = _c1oaB::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1og2_srtd" {
     u1og2_srtd:
         const S1jKw_srt+696;
         const 109;
         const 1;
         const 17592253153280;
 },
 _c1oaH() //  [R1]
         { info_tbl: [(c1oaH,
                       label: block_c1oaH_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oaH: // global
           if (R1 & 7 == 1) goto c1od9; else goto c1odX;
       c1od9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1odc; else goto c1odb;
       c1odc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1odb: // global
           I64[Hp - 16] = lvl8_s1jCM_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp] = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = Hp - 16;
           call _c1oby() args: 0, res: 0, upd: 0;
       c1odX: // global
           R2 = P64[Sp + 24];
           I64[Sp + 40] = stg_ap_p_info;
           P64[Sp + 48] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 40;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 _c1oby() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oby: // global
           I64[Sp - 8] = block_c1obA_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1og3_srtd" {
     u1og3_srtd:
         const S1jKw_srt+696;
         const 91;
         const 1;
         const 67108864;
 },
 _c1obA() //  [R1]
         { info_tbl: [(c1obA,
                       label: block_c1obA_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1obA: // global
           _s1jDa::P64 = P64[Sp + 48];
           _s1jDb::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c1odP; else goto c1odQ;
       c1odP: // global
           I64[Sp + 8] = block_c1oaS_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = _s1jDb::P64;
           P64[Sp + 48] = _s1jDa::P64;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1odQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1odT; else goto c1odS;
       c1odT: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1odS: // global
           I64[Hp - 64] = sat_s1jDe_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = _s1jDb::P64;
           I64[Hp - 24] = sat_s1jDd_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _s1jDa::P64;
           P64[Sp + 48] = Hp - 24;
           P64[Sp + 8] = Hp - 64;
           Sp = Sp + 8;
           call _c1oby() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1og4_srtd" {
     u1og4_srtd:
         const S1jKw_srt+696;
         const 91;
         const 1;
         const 67108864;
 },
 _c1oaS() //  [R1]
         { info_tbl: [(c1oaS,
                       label: block_c1oaS_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oaS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1odg; else goto c1odf;
       c1odg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1odf: // global
           I64[Hp - 16] = lvl9_s1jCR_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 8] = block_c1oaY_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 8];
           _c1oaW::P64 = Hp - 16;
           P64[Sp - 16] = _c1oaW::P64;
           P64[Sp] = R1;
           P64[Sp + 16] = _c1oaW::P64;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1oaY() //  [R1]
         { info_tbl: [(c1oaY,
                       label: block_c1oaY_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oaY: // global
           _s1jCO::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto c1odi; else goto c1odK;
       c1odi: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1odl; else goto c1odk;
       c1odl: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1odk: // global
           I64[Hp - 64] = sat_s1jD8_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = sat_s1jD7_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _s1jCO::P64;
           P64[Sp] = _s1jCO::P64;
           P64[Sp + 16] = Hp - 64;
           P64[Sp + 48] = Hp - 24;
           call _c1obb() args: 0, res: 0, upd: 0;
       c1odK: // global
           R1 = _s1jCO::P64;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1obb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1obb: // global
           I64[Sp - 8] = block_c1obd_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 40];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1obd() //  [R1]
         { info_tbl: [(c1obd,
                       label: block_c1obd_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1obd: // global
           _s1jCY::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c1odt; else goto c1odD;
       c1odt: // global
           I64[Sp] = block_c1obh_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jCY::P64;
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c1odD: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1odG; else goto c1odF;
       c1odG: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1odF: // global
           I64[Hp - 64] = sat_s1jD6_info;
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = _s1jCY::P64;
           I64[Hp - 24] = sat_s1jD5_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 56];
           P64[Sp + 56] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c1obb() args: 0, res: 0, upd: 0;
     }
 },
 _c1obh() //  [R1]
         { info_tbl: [(c1obh,
                       label: block_c1obh_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1obh: // global
           _s1jCA::P64 = P64[Sp + 40];
           _s1jCX::P64 = P64[Sp + 56];
           _s1jCZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c1odv; else goto c1odC;
       c1odv: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1ody; else goto c1odx;
       c1ody: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1odx: // global
           I64[Hp - 104] = sat_s1jD4_info;
           P64[Hp - 88] = _s1jCA::P64;
           P64[Hp - 80] = _s1jCX::P64;
           P64[Hp - 72] = _s1jCZ::P64;
           I64[Hp - 64] = sat_s1jD3_info;
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_s1jD2_info;
           P64[Hp - 8] = _s1jCA::P64;
           P64[Hp] = _s1jCX::P64;
           P64[Sp + 56] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = Hp - 104;
           Sp = Sp + 8;
           call _c1obb() args: 0, res: 0, upd: 0;
       c1odC: // global
           R2 = _s1jCA::P64;
           I64[Sp + 48] = stg_ap_pp_info;
           P64[Sp + 56] = _s1jCX::P64;
           P64[Sp + 64] = _s1jCZ::P64;
           Sp = Sp + 48;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Real.^%^_closure" {
     GHC.Real.^%^_closure:
         const GHC.Real.^%^_info;
         const 0;
 },
 GHC.Real.^%^_entry() //  [R2, R3, R4]
         { info_tbl: [(c1oep,
                       label: GHC.Real.^%^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oep: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1oev; else goto c1oew;
       c1oev: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^%^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oew: // global
           I64[Sp - 24] = block_c1oem_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1oeB; else goto c1oen;
       u1oeB: // global
           call _c1oem(R1) args: 0, res: 0, upd: 0;
       c1oen: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oem() //  [R1]
         { info_tbl: [(c1oem,
                       label: block_c1oem_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oem: // global
           _s1jDh::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1oes_info;
           R5 = _s1jDh::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w^%^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oes() //  [R1, R2]
         { info_tbl: [(c1oes,
                       label: block_c1oes_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oes: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1oeA; else goto c1oez;
       c1oeA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1oez: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Real.$w^%^_closure" {
     GHC.Real.$w^%^_closure:
         const GHC.Real.$w^%^_info;
         const 0;
 },
 $dNum_s1jDt_entry() //  [R1]
         { info_tbl: [(c1oeO,
                       label: $dNum_s1jDt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oeO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1oeP; else goto c1oeQ;
       c1oeP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oeQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jDv_entry() //  [R1]
         { info_tbl: [(c1oeZ,
                       label: sat_s1jDv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oeZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1of0; else goto c1of1;
       c1of0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1of1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jDy_entry() //  [R1]
         { info_tbl: [(c1ofa,
                       label: sat_s1jDy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ofa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ofb; else goto c1ofc;
       c1ofb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ofc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w^%^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1ofd,
                       label: GHC.Real.$w^%^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ofd: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c1ofe; else goto c1off;
       c1ofe: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w^%^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1off: // global
           I64[Sp - 40] = block_c1oeG_info;
           _s1jDo::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s1jDo::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oeG() //  [R1]
         { info_tbl: [(c1oeG,
                       label: block_c1oeG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oeG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ofi; else goto c1ofh;
       c1ofi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ofh: // global
           I64[Hp - 16] = $dNum_s1jDt_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1oeR_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oeR() //  [R1]
         { info_tbl: [(c1oeR,
                       label: block_c1oeR_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oeR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ofl; else goto c1ofk;
       c1ofl: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ofk: // global
           I64[Hp - 16] = sat_s1jDv_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1of2_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 40];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1of2() //  [R1]
         { info_tbl: [(c1of2,
                       label: block_c1of2_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1of2: // global
           if (R1 & 7 == 1) goto c1ofo; else goto c1ofU;
       c1ofo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ofr; else goto c1ofq;
       c1ofr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ofq: // global
           I64[Hp - 16] = sat_s1jDy_info;
           P64[Hp] = P64[Sp + 16];
           _s1jDu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1ofm_info;
           R2 = _s1jDu::P64;
           P64[Sp + 16] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1ofU: // global
           R1 = lvl6_r1j3R_closure;
           Sp = Sp + 56;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1ofm() //  [R1]
         { info_tbl: [(c1ofm,
                       label: block_c1ofm_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ofm: // global
           _c1of6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1ofv_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = _c1of6::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1ofv() //  [R1]
         { info_tbl: [(c1ofv,
                       label: block_c1ofv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ofv: // global
           if (R1 & 7 == 1) goto c1ofH; else goto c1ofQ;
       c1ofH: // global
           I64[Sp] = block_c1ofA_info;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = GHC.Num.$fNumInteger_closure;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
       c1ofQ: // global
           R2 = GHC.Real.$fEnumRatio1_closure;
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1ofA() //  [R1]
         { info_tbl: [(c1ofA,
                       label: block_c1ofA_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ofA: // global
           _s1jDq::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1ofE_info;
           R5 = P64[Sp + 32];
           R4 = _s1jDq::P64;
           R3 = P64[Sp + 8];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ofE() //  [R1]
         { info_tbl: [(c1ofE,
                       label: block_c1ofE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ofE: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.612411443 UTC

[section ""data" . GHC.Real.$w^^%^^_closure" {
     GHC.Real.$w^^%^^_closure:
         const GHC.Real.$w^^%^^_info;
         const 0;
 },
 $dNum_s1jDI_entry() //  [R1]
         { info_tbl: [(c1ogh,
                       label: $dNum_s1jDI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ogh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ogi; else goto c1ogj;
       c1ogi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ogj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jDK_entry() //  [R1]
         { info_tbl: [(c1ogs,
                       label: sat_s1jDK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ogs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ogt; else goto c1ogu;
       c1ogt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ogu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jDN_entry() //  [R1]
         { info_tbl: [(c1ogD,
                       label: sat_s1jDN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ogD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ogE; else goto c1ogF;
       c1ogE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ogF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jDT_entry() //  [R1]
         { info_tbl: [(c1oh0,
                       label: sat_s1jDT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oh0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oh1; else goto c1oh2;
       c1oh1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oh2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jDS_entry() //  [R1]
         { info_tbl: [(c1oh7,
                       label: sat_s1jDS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oh7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1oh8; else goto c1oh9;
       c1oh8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oh9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jDV_entry() //  [R1]
         { info_tbl: [(c1ohi,
                       label: sat_s1jDV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ohi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ohj; else goto c1ohk;
       c1ohj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ohk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jE2_entry() //  [R1]
         { info_tbl: [(c1ohr,
                       label: sat_s1jE2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ohr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ohs; else goto c1oht;
       c1ohs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oht: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jE4_entry() //  [R1]
         { info_tbl: [(c1ohC,
                       label: sat_s1jE4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ohC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ohD; else goto c1ohE;
       c1ohD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ohE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1ojp_srtd" {
     u1ojp_srtd:
         const S1jKw_srt+296;
         const 167;
         const 1;
         const 0;
         const 354871676928;
 },
 GHC.Real.$w^^%^^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1ohF,
                       label: GHC.Real.$w^^%^^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ohF: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c1ohG; else goto c1ohH;
       c1ohG: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w^^%^^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ohH: // global
           I64[Sp - 40] = block_c1og9_info;
           _s1jDD::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s1jDD::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ojq_srtd" {
     u1ojq_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1og9() //  [R1]
         { info_tbl: [(c1og9,
                       label: block_c1og9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1og9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ohK; else goto c1ohJ;
       c1ohK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ohJ: // global
           I64[Hp - 16] = $dNum_s1jDI_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1ogk_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ojr_srtd" {
     u1ojr_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1ogk() //  [R1]
         { info_tbl: [(c1ogk,
                       label: block_c1ogk_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ogk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ohN; else goto c1ohM;
       c1ohN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ohM: // global
           I64[Hp - 16] = sat_s1jDK_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1ogv_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 40];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.>_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ojs_srtd" {
     u1ojs_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1ogv() //  [R1]
         { info_tbl: [(c1ogv,
                       label: block_c1ogv_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ogv: // global
           if (R1 & 7 == 1) goto c1ohP; else goto c1ojd;
       c1ohP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ohS; else goto c1ohR;
       c1ohS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ohR: // global
           I64[Hp - 16] = sat_s1jDN_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp] = block_c1ogG_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1ojd: // global
           I64[Sp + 16] = block_c1oj7_info;
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = GHC.Num.$fNumInteger_closure;
           Sp = Sp + 16;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ojt_srtd" {
     u1ojt_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1ogG() //  [R1]
         { info_tbl: [(c1ogG,
                       label: block_c1ogG_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ogG: // global
           _c1ogz::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1ogK_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 48];
           P64[Sp] = _c1ogz::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1oju_srtd" {
     u1oju_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1ogK() //  [R1]
         { info_tbl: [(c1ogK,
                       label: block_c1ogK_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ogK: // global
           if (R1 & 7 == 1) goto c1ohW; else goto c1oj4;
       c1ohW: // global
           I64[Sp] = block_c1ogO_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       c1oj4: // global
           R2 = GHC.Real.$fEnumRatio1_closure;
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1ojv_srtd" {
     u1ojv_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993765888;
 },
 _c1ogO() //  [R1]
         { info_tbl: [(c1ogO,
                       label: block_c1ogO_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ogO: // global
           if (R1 == 1) goto c1oiQ; else goto c1ohZ;
       c1oiQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1oiT; else goto c1oiS;
       c1oiT: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1oiS: // global
           I64[Hp - 24] = sat_s1jE2_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c1ohu_info;
           R5 = Hp - 24;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
       c1ohZ: // global
           I64[Sp] = block_c1ogS_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ohu() //  [R1]
         { info_tbl: [(c1ohu,
                       label: block_c1ohu_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ohu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1oiW; else goto c1oiV;
       c1oiW: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oiV: // global
           I64[Hp - 24] = sat_s1jE4_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 32] = block_c1oiP_info;
           R5 = Hp - 24;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 40] = R1;
           Sp = Sp + 32;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oiP() //  [R1]
         { info_tbl: [(c1oiP,
                       label: block_c1oiP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oiP: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1ojw_srtd" {
     u1ojw_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79456894976;
 },
 _c1ogS() //  [R1]
         { info_tbl: [(c1ogS,
                       label: block_c1ogS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ogS: // global
           if (R1 == 1) goto c1oiO; else goto c1oi2;
       c1oiO: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1oi2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1oi5; else goto c1oi4;
       c1oi5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1oi4: // global
           I64[Hp - 48] = sat_s1jDT_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = sat_s1jDS_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_c1oha_info;
           R5 = Hp - 48;
           R4 = Hp - 16;
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oha() //  [R1]
         { info_tbl: [(c1oha,
                       label: block_c1oha_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oha: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1oi8; else goto c1oi7;
       c1oi8: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oi7: // global
           I64[Hp - 24] = sat_s1jDV_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c1oi0_info;
           R5 = Hp - 24;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oi0() //  [R1]
         { info_tbl: [(c1oi0,
                       label: block_c1oi0_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oi0: // global
           I64[Sp + 16] = block_c1oic_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oic() //  [R1]
         { info_tbl: [(c1oic,
                       label: block_c1oic_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oic: // global
           _s1jDU::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1oio; else goto c1oiE;
       c1oio: // global
           I64[Sp] = block_c1oih_info;
           R2 = _s1jDU::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       c1oiE: // global
           I64[Sp] = block_c1oix_info;
           R1 = _s1jDU::P64;
           if (R1 & 7 != 0) goto u1ojm; else goto c1oiy;
       u1ojm: // global
           call _c1oix(R1) args: 0, res: 0, upd: 0;
       c1oiy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oih() //  [R1]
         { info_tbl: [(c1oih,
                       label: block_c1oih_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oih: // global
           _s1jDR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1oil_info;
           _s1jDX::P64 = R1;
           R1 = _s1jDR::P64;
           P64[Sp + 16] = _s1jDX::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1ojn; else goto c1oiq;
       u1ojn: // global
           call _c1oil(R1) args: 0, res: 0, upd: 0;
       c1oiq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oil() //  [R1]
         { info_tbl: [(c1oil,
                       label: block_c1oil_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oil: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1oix() //  [R1]
         { info_tbl: [(c1oix,
                       label: block_c1oix_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oix: // global
           _s1jDR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1oiC_info;
           _s1jDZ::P64 = R1;
           R1 = _s1jDR::P64;
           P64[Sp + 16] = _s1jDZ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1ojo; else goto c1oiG;
       u1ojo: // global
           call _c1oiC(R1) args: 0, res: 0, upd: 0;
       c1oiG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oiC() //  [R1]
         { info_tbl: [(c1oiC,
                       label: block_c1oiC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oiC: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1oj7() //  [R1]
         { info_tbl: [(c1oj7,
                       label: block_c1oj7_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oj7: // global
           _s1jDF::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1ojb_info;
           R5 = P64[Sp + 32];
           R4 = _s1jDF::P64;
           R3 = P64[Sp + 8];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ojb() //  [R1]
         { info_tbl: [(c1ojb,
                       label: block_c1ojb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ojb: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.620258543 UTC

[section ""data" . GHC.Real.^^%^^_closure" {
     GHC.Real.^^%^^_closure:
         const GHC.Real.^^%^^_info;
         const 0;
 },
 GHC.Real.^^%^^_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ojE,
                       label: GHC.Real.^^%^^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ojE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1ojK; else goto c1ojL;
       c1ojK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^^%^^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ojL: // global
           I64[Sp - 24] = block_c1ojB_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1ojQ; else goto c1ojC;
       u1ojQ: // global
           call _c1ojB(R1) args: 0, res: 0, upd: 0;
       c1ojC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ojB() //  [R1]
         { info_tbl: [(c1ojB,
                       label: block_c1ojB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ojB: // global
           _s1jEa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1ojH_info;
           R5 = _s1jEa::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w^^%^^_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ojH() //  [R1, R2]
         { info_tbl: [(c1ojH,
                       label: block_c1ojH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ojH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ojP; else goto c1ojO;
       c1ojP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1ojO: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.62309153 UTC

[section ""data" . GHC.Real.^^_closure" {
     GHC.Real.^^_closure:
         const GHC.Real.^^_info;
         const 0;
 },
 $dNum_s1jEm_entry() //  [R1]
         { info_tbl: [(c1ok3,
                       label: $dNum_s1jEm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ok3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ok4; else goto c1ok5;
       c1ok4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ok5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jEo_entry() //  [R1]
         { info_tbl: [(c1oka,
                       label: sat_s1jEo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oka: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1okb; else goto c1okc;
       c1okb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1okc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jEr_entry() //  [R1]
         { info_tbl: [(c1okt,
                       label: sat_s1jEr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1okt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oku; else goto c1okv;
       c1oku: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1okv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jEq_entry() //  [R1]
         { info_tbl: [(c1okA,
                       label: sat_s1jEq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1okA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1okB; else goto c1okC;
       c1okB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1okC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jEs_entry() //  [R1]
         { info_tbl: [(c1okD,
                       label: sat_s1jEs_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1okD: // global
           _s1jEs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1okE; else goto c1okF;
       c1okF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1okH; else goto c1okG;
       c1okH: // global
           HpAlloc = 56;
           goto c1okE;
       c1okE: // global
           R1 = _s1jEs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1okG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jEs::P64;
           _s1jEh::P64 = P64[_s1jEs::P64 + 16];
           _s1jEi::P64 = P64[_s1jEs::P64 + 24];
           _s1jEj::P64 = P64[_s1jEs::P64 + 32];
           _s1jEk::P64 = P64[_s1jEs::P64 + 40];
           _s1jEm::P64 = P64[_s1jEs::P64 + 48];
           I64[Hp - 48] = sat_s1jEr_info;
           P64[Hp - 32] = _s1jEk::P64;
           P64[Hp - 24] = _s1jEm::P64;
           I64[Hp - 16] = sat_s1jEq_info;
           P64[Hp] = _s1jEh::P64;
           R5 = Hp - 48;
           R4 = _s1jEj::P64;
           R3 = _s1jEi::P64;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jEt_entry() //  [R1]
         { info_tbl: [(c1okO,
                       label: sat_s1jEt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1okO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1okP; else goto c1okQ;
       c1okP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1okQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.^^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1okR,
                       label: GHC.Real.^^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1okR: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1okS; else goto c1okT;
       c1okS: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1okT: // global
           I64[Sp - 40] = block_c1ojV_info;
           _s1jEh::P64 = R2;
           R2 = R3;
           P64[Sp - 32] = _s1jEh::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ojV() //  [R1]
         { info_tbl: [(c1ojV,
                       label: block_c1ojV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ojV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1okW; else goto c1okV;
       c1okW: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1okV: // global
           I64[Hp - 40] = $dNum_s1jEm_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_s1jEo_info;
           _c1ojZ::P64 = Hp - 40;
           P64[Hp] = _c1ojZ::P64;
           I64[Sp - 16] = block_c1okd_info;
           R2 = R1;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = _c1ojZ::P64;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1okd() //  [R1]
         { info_tbl: [(c1okd,
                       label: block_c1okd_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1okd: // global
           _c1ok6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1okh_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 48];
           P64[Sp] = _c1ok6::P64;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1okh() //  [R1]
         { info_tbl: [(c1okh,
                       label: block_c1okh_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1okh: // global
           _s1jEh::P64 = P64[Sp + 16];
           _s1jEi::P64 = P64[Sp + 24];
           _s1jEj::P64 = P64[Sp + 32];
           _s1jEk::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c1okZ; else goto c1ol3;
       c1okZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1ol2; else goto c1ol1;
       c1ol2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ol1: // global
           I64[Hp - 48] = sat_s1jEs_info;
           P64[Hp - 32] = _s1jEh::P64;
           P64[Hp - 24] = _s1jEi::P64;
           P64[Hp - 16] = _s1jEj::P64;
           P64[Hp - 8] = _s1jEk::P64;
           P64[Hp] = P64[Sp + 8];
           R2 = _s1jEh::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 48;
           Sp = Sp + 32;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 8;
       c1ol3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ol6; else goto c1ol5;
       c1ol6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ol5: // global
           I64[Hp - 16] = sat_s1jEt_info;
           P64[Hp] = _s1jEh::P64;
           R5 = _s1jEk::P64;
           R4 = _s1jEj::P64;
           R3 = _s1jEi::P64;
           R2 = Hp - 16;
           Sp = Sp + 48;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.626895908 UTC

[section ""data" . GHC.Real.C:Fractional_closure" {
     GHC.Real.C:Fractional_closure:
         const GHC.Real.C:Fractional_info;
 },
 GHC.Real.C:Fractional_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1old,
                       label: GHC.Real.C:Fractional_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1old: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1olh; else goto c1olg;
       c1olh: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.C:Fractional_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1olg: // global
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.628143051 UTC

[section ""data" . GHC.Real.C:Integral_closure" {
     GHC.Real.C:Integral_closure:
         const GHC.Real.C:Integral_info;
 },
 GHC.Real.C:Integral_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1olj: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Real.C:Integral_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 GHC.Real.C:Integral_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1olo,
                       label: GHC.Real.C:Integral_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1olo: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1ols; else goto c1olr;
       c1ols: // global
           HpAlloc = 80;
           R1 = GHC.Real.C:Integral_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       c1olr: // global
           I64[Hp - 72] = GHC.Real.C:Integral_con_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = R6;
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 71;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.629584701 UTC

[section ""data" . GHC.Real.C:Real_closure" {
     GHC.Real.C:Real_closure:
         const GHC.Real.C:Real_info;
 },
 GHC.Real.C:Real_entry() //  [R2, R3, R4]
         { info_tbl: [(c1oly,
                       label: GHC.Real.C:Real_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oly: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1olC; else goto c1olB;
       c1olC: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.C:Real_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1olB: // global
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.63075721 UTC

[section ""data" . GHC.Real.C:RealFrac_closure" {
     GHC.Real.C:RealFrac_closure:
         const GHC.Real.C:RealFrac_info;
 },
 GHC.Real.C:RealFrac_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1olE: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Real.C:RealFrac_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Real.C:RealFrac_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1olJ,
                       label: GHC.Real.C:RealFrac_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1olJ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1olN; else goto c1olM;
       c1olN: // global
           HpAlloc = 64;
           R1 = GHC.Real.C:RealFrac_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       c1olM: // global
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.632104809 UTC

[section ""data" . GHC.Real.:%_closure" {
     GHC.Real.:%_closure:
         const GHC.Real.:%_info;
 },
 GHC.Real.:%_entry() //  [R2, R3]
         { info_tbl: [(c1olT,
                       label: GHC.Real.:%_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1olT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1olX; else goto c1olW;
       c1olX: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.:%_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1olW: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.634518095 UTC

[GHC.Real.C:Fractional_con_entry() //  [R1]
         { info_tbl: [(c1olY,
                       label: GHC.Real.C:Fractional_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,70,114,97,99,116,105,111,110,97,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1olY: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.635252908 UTC

[GHC.Real.C:Integral_con_entry() //  [R1]
         { info_tbl: [(c1om0,
                       label: GHC.Real.C:Integral_con_info
                       rep:HeapRep 9 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,73,110,116,101,103,114,97,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1om0: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.635943645 UTC

[GHC.Real.C:Real_con_entry() //  [R1]
         { info_tbl: [(c1om2,
                       label: GHC.Real.C:Real_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,82,101,97,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1om2: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.636628003 UTC

[GHC.Real.C:RealFrac_con_entry() //  [R1]
         { info_tbl: [(c1om4,
                       label: GHC.Real.C:RealFrac_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,82,101,97,108,70,114,97,99]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1om4: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.637369536 UTC

[GHC.Real.:%_con_entry() //  [R1]
         { info_tbl: [(c1om6,
                       label: GHC.Real.:%_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,58,37]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1om6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.637979476 UTC

[section ""relreadonly" . S1jKw_srt" {
     S1jKw_srt:
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$fOrdRatio_$s$c<_closure;
         const GHC.Real.$fEnumRatio_$s$c<=_closure;
         const GHC.Real.$w$s$ccompare_closure;
         const GHC.Real.$fEnumRatio_$s$ccompare_closure;
         const GHC.Real.$fEnumRatio_$s$c>=_closure;
         const GHC.Real.$fOrdRatio_$s$c>_closure;
         const GHC.Real.$fOrdRatio_$s$cmin_closure;
         const GHC.Real.$fOrdRatio_$s$cmax_closure;
         const sat_s1j8H_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$fFractionalRatio_$s$csignum_closure;
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure;
         const GHC.Real.$fEnumRatio_$ctoRational_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.$dmfloor_closure;
         const GHC.Real.$dmceiling_closure;
         const GHC.Real.$dmrecip_closure;
         const GHC.Real.$dmdivMod_closure;
         const GHC.Exception.divZeroException_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.$fIntegralInt_$cmod_closure;
         const GHC.Real.$fIntegralInt_$crem_closure;
         const GHC.Real.$fIntegralInteger_$cquot_closure;
         const GHC.Real.$fIntegralInteger_$crem_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Real.$fIntegralInteger_$cdiv_closure;
         const GHC.Integer.Type.modInteger_closure;
         const GHC.Real.$fIntegralInteger_$cmod_closure;
         const GHC.Real.$fIntegralInteger_$cquotRem_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Real.$fIntegralInteger_$cdivMod_closure;
         const GHC.Real.$fIntegralWord_$cquot_closure;
         const GHC.Real.$fIntegralWord_$crem_closure;
         const GHC.Real.$fIntegralWord_$cquotRem_closure;
         const GHC.Real.$fIntegralWord_$cdivMod_closure;
         const GHC.Exception.ratioZeroDenomException_closure;
         const GHC.Real.ratioZeroDenominatorError_closure;
         const GHC.Real.$fFractionalRatio_$s$crecip_closure;
         const GHC.Exception.overflowException_closure;
         const GHC.Real.$fIntegralInt_$cdivMod_closure;
         const lvl_r1j38_closure;
         const GHC.Real.$fIntegralInt_$cquotRem_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Real.$fIntegralInt_$cdiv_closure;
         const GHC.Real.$w$cdiv_closure;
         const GHC.Real.$fIntegralInt_$cquot_closure;
         const GHC.Real.$wgcd'_closure;
         const lvl2_r1j3a_closure;
         const GHC.Real.$fEnumRatio_gcd'_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.gcd_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.reduce_$sreduce_closure;
         const GHC.Real.$fRealWord_$ctoRational_closure;
         const GHC.Real.$fFractionalRatio_$s$c*_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Real.$w$s$c-_closure;
         const GHC.Real.$fEnumRatio_$s$c-_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$fEnumRatio_$s$c+_closure;
         const GHC.Real.$w$s$cfromRational_closure;
         const GHC.Real.$fFractionalRatio_$s$cfromRational_closure;
         const GHC.Real.$w$s$c/_closure;
         const GHC.Real.$fFractionalRatio_$s$c/_closure;
         const GHC.Real.$w$snumericEnumFrom_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFrom_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$wnumericEnumFrom_closure;
         const GHC.Real.numericEnumFrom_closure;
         const sat_s1jhS_closure;
         const GHC.Real.even2_closure;
         const GHC.Real.$fEnumRatio2_closure;
         const GHC.Real.$fEnumRatio_$s$c<=_closure;
         const GHC.Real.$w$snumericEnumFromTo_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure;
         const GHC.Real.numericEnumFromTo_closure;
         const GHC.Real.$w$snumericEnumFromThen_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure;
         const GHC.Real.$fEnumRatio_$s$c>=_closure;
         const GHC.Real.$w$snumericEnumFromThenTo_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure;
         const GHC.Real.numericEnumFromThenTo_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.showSigned_closure;
         const GHC.Real.even_closure;
         const GHC.Real.odd_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const lvl3_r1j3b_closure;
         const GHC.Real.$dmround_closure;
         const GHC.Real.$fRealFracRatio1_closure;
         const GHC.Real.integralEnumFrom_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Real.integralEnumFromThen_closure;
         const GHC.Real.integralEnumFromTo_closure;
         const GHC.Real.integralEnumFromThenTo_closure;
         const GHC.Real.$w$csignum_closure;
         const GHC.Real.$fNumRatio_$csignum_closure;
         const GHC.Real.$w$cfromInteger_closure;
         const GHC.Real.$fNumRatio_$cfromInteger_closure;
         const GHC.Real.$w$crecip_closure;
         const GHC.Real.$fFractionalRatio_$crecip_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.$w$s$cproperFraction_closure;
         const GHC.Real.$fEnumRatio_$s$cproperFraction_closure;
         const GHC.Real.gcd_closure;
         const GHC.Real.$wreduce_closure;
         const GHC.Real.reduce_closure;
         const GHC.Real.%_$s%_closure;
         const GHC.Real.$w$s$cfromRational_closure;
         const GHC.Real.$w%_closure;
         const GHC.Real.%_closure;
         const GHC.Real.$w$c/_closure;
         const GHC.Real.$fFractionalRatio_$c/_closure;
         const GHC.Real.$w$cfromRational_closure;
         const GHC.Real.$fFractionalRatio_$cfromRational_closure;
         const GHC.Real.$w$c+_closure;
         const GHC.Real.$fNumRatio_$c+_closure;
         const GHC.Real.$w$c-_closure;
         const GHC.Real.$fNumRatio_$c-_closure;
         const GHC.Real.$w$c*_closure;
         const GHC.Real.$fNumRatio_$c*_closure;
         const GHC.Real.$fNumRatio_closure;
         const GHC.Real.$fEnumRatio_$s$csucc_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$fEnumRatio_$csucc_closure;
         const GHC.Real.$fEnumRatio_$s$cpred_closure;
         const GHC.Real.$fEnumRatio_$cpred_closure;
         const GHC.Real.$fFractionalRatio_closure;
         const GHC.Real.$wnumericEnumFrom_closure;
         const GHC.Real.$fEnumRatio_$cenumFrom_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThen_closure;
         const GHC.Real.$fEnumRatio_$cenumFromTo_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThenTo_closure;
         const GHC.Real.$fRealRatio_closure;
         const GHC.Real.$w$s$cceiling_closure;
         const GHC.Real.$fRealFracRatio_$s$cceiling_closure;
         const GHC.Real.$w$cceiling_closure;
         const GHC.Real.$fRealFracRatio_$cceiling_closure;
         const GHC.Real.$w$s$cfloor_closure;
         const GHC.Real.$fRealFracRatio_$s$cfloor_closure;
         const GHC.Real.$w$cfloor_closure;
         const GHC.Real.$fRealFracRatio_$cfloor_closure;
         const sat_s1jvS_closure;
         const GHC.Real.$w$s$cround_closure;
         const GHC.Real.$fRealFracRatio2_closure;
         const GHC.Real.$fRealFracRatio_$s$cround_closure;
         const GHC.Real.$w$cround_closure;
         const GHC.Real.$fRealFracRatio_$cround_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.$fRealFracRatio_$s$ctruncate_closure;
         const GHC.Real.$fRealFracRatio_closure;
         const g_r1j3N_closure;
         const GHC.Real.^_f_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Real.^_$s^_closure;
         const GHC.Real.^1_closure;
         const GHC.Real.$w$s$cfromEnum_closure;
         const GHC.Real.$fEnumRatio_$s$cfromEnum_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Real.$w$s$cshowsPrec_closure;
         const GHC.Real.$fShowRatio_$s$cshowsPrec_closure;
         const GHC.Real.$fShowRatio1_closure;
         const GHC.Real.$w$s$cshow_closure;
         const GHC.Real.$fShowRatio_$s$cshow_closure;
         const GHC.Real.$fIntegralWord_closure;
         const GHC.Real.$w$slcm_closure;
         const GHC.Real.lcm_$slcm_closure;
         const GHC.Real.$w$slcm1_closure;
         const GHC.Real.lcm_$slcm1_closure;
         const GHC.Real.gcd_closure;
         const GHC.Real.lcm_closure;
         const GHC.Real.$w$ctoEnum_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$fEnumRatio_$ctoEnum_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThenTo_closure;
         const GHC.Real.$fEnumRatio_$cenumFromTo_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThen_closure;
         const GHC.Real.$fEnumRatio_$cenumFrom_closure;
         const GHC.Real.$fEnumRatio_$cpred_closure;
         const GHC.Real.$fEnumRatio_$csucc_closure;
         const GHC.Real.$fEnumRatio_closure;
         const GHC.Real.^_$s^2_closure;
         const GHC.Real.^2_closure;
         const $wg1_r1j3Q_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$wf_closure;
         const GHC.Real.^_f1_closure;
         const GHC.Real.^_$s^1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.even2_closure;
         const GHC.Real.^_closure;
         const lvl7_r1j3S_closure;
         const GHC.Real.even_closure;
         const GHC.Real.^%^_closure;
         const GHC.Real.$w^%^_closure;
         const GHC.Num.$fNumInteger_closure;
         const lvl6_r1j3R_closure;
         const GHC.Real.$w^^%^^_closure;
         const GHC.Real.^^%^^_closure;
         const GHC.Real.^^_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.639917551 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:56:03.641374081 UTC

[section ""data" . GHC.Real.$p1Fractional_closure" {
     GHC.Real.$p1Fractional_closure:
         const GHC.Real.$p1Fractional_info;
 },
 GHC.Real.$p1Fractional_entry() //  [R2]
         { info_tbl: [(c1omf,
                       label: GHC.Real.$p1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1omf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1omg; else goto c1omh;
       c1omg: // global
           R2 = R2;
           R1 = GHC.Real.$p1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1omh: // global
           I64[Sp - 8] = block_c1omc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oml; else goto c1omd;
       u1oml: // global
           call _c1omc(R1) args: 0, res: 0, upd: 0;
       c1omd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1omc() //  [R1]
         { info_tbl: [(c1omc,
                       label: block_c1omc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1omc: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.64740001 UTC

[section ""data" . GHC.Real./_closure" {
     GHC.Real./_closure:
         const GHC.Real./_info;
 },
 GHC.Real./_entry() //  [R2]
         { info_tbl: [(c1omE,
                       label: GHC.Real./_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1omE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1omF; else goto c1omG;
       c1omF: // global
           R2 = R2;
           R1 = GHC.Real./_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1omG: // global
           I64[Sp - 8] = block_c1omB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1omK; else goto c1omC;
       u1omK: // global
           call _c1omB(R1) args: 0, res: 0, upd: 0;
       c1omC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1omB() //  [R1]
         { info_tbl: [(c1omB,
                       label: block_c1omB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1omB: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.652747306 UTC

[section ""data" . GHC.Real.recip_closure" {
     GHC.Real.recip_closure:
         const GHC.Real.recip_info;
 },
 GHC.Real.recip_entry() //  [R2]
         { info_tbl: [(c1on1,
                       label: GHC.Real.recip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1on1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1on2; else goto c1on3;
       c1on2: // global
           R2 = R2;
           R1 = GHC.Real.recip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1on3: // global
           I64[Sp - 8] = block_c1omY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1on7; else goto c1omZ;
       u1on7: // global
           call _c1omY(R1) args: 0, res: 0, upd: 0;
       c1omZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1omY() //  [R1]
         { info_tbl: [(c1omY,
                       label: block_c1omY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1omY: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.658251506 UTC

[section ""data" . GHC.Real.fromRational_closure" {
     GHC.Real.fromRational_closure:
         const GHC.Real.fromRational_info;
 },
 GHC.Real.fromRational_entry() //  [R2]
         { info_tbl: [(c1ono,
                       label: GHC.Real.fromRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ono: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1onp; else goto c1onq;
       c1onp: // global
           R2 = R2;
           R1 = GHC.Real.fromRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1onq: // global
           I64[Sp - 8] = block_c1onl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1onu; else goto c1onm;
       u1onu: // global
           call _c1onl(R1) args: 0, res: 0, upd: 0;
       c1onm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1onl() //  [R1]
         { info_tbl: [(c1onl,
                       label: block_c1onl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1onl: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.664485356 UTC

[section ""data" . GHC.Real.$p1Integral_closure" {
     GHC.Real.$p1Integral_closure:
         const GHC.Real.$p1Integral_info;
 },
 GHC.Real.$p1Integral_entry() //  [R2]
         { info_tbl: [(c1onL,
                       label: GHC.Real.$p1Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1onL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1onM; else goto c1onN;
       c1onM: // global
           R2 = R2;
           R1 = GHC.Real.$p1Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1onN: // global
           I64[Sp - 8] = block_c1onI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1onR; else goto c1onJ;
       u1onR: // global
           call _c1onI(R1) args: 0, res: 0, upd: 0;
       c1onJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1onI() //  [R1]
         { info_tbl: [(c1onI,
                       label: block_c1onI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1onI: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.67012096 UTC

[section ""data" . GHC.Real.$p2Integral_closure" {
     GHC.Real.$p2Integral_closure:
         const GHC.Real.$p2Integral_info;
 },
 GHC.Real.$p2Integral_entry() //  [R2]
         { info_tbl: [(c1ooa,
                       label: GHC.Real.$p2Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ooa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1oob; else goto c1ooc;
       c1oob: // global
           R2 = R2;
           R1 = GHC.Real.$p2Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1ooc: // global
           I64[Sp - 8] = block_c1oo7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oog; else goto c1oo8;
       u1oog: // global
           call _c1oo7(R1) args: 0, res: 0, upd: 0;
       c1oo8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oo7() //  [R1]
         { info_tbl: [(c1oo7,
                       label: block_c1oo7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oo7: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.675419615 UTC

[section ""data" . GHC.Real.quot_closure" {
     GHC.Real.quot_closure:
         const GHC.Real.quot_info;
 },
 GHC.Real.quot_entry() //  [R2]
         { info_tbl: [(c1ooz,
                       label: GHC.Real.quot_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ooz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1ooA; else goto c1ooB;
       c1ooA: // global
           R2 = R2;
           R1 = GHC.Real.quot_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1ooB: // global
           I64[Sp - 8] = block_c1oow_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ooF; else goto c1oox;
       u1ooF: // global
           call _c1oow(R1) args: 0, res: 0, upd: 0;
       c1oox: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oow() //  [R1]
         { info_tbl: [(c1oow,
                       label: block_c1oow_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oow: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.680751657 UTC

[section ""data" . GHC.Real.rem_closure" {
     GHC.Real.rem_closure:
         const GHC.Real.rem_info;
 },
 GHC.Real.rem_entry() //  [R2]
         { info_tbl: [(c1ooW,
                       label: GHC.Real.rem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ooW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1ooX; else goto c1ooY;
       c1ooX: // global
           R2 = R2;
           R1 = GHC.Real.rem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1ooY: // global
           I64[Sp - 8] = block_c1ooT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1op2; else goto c1ooU;
       u1op2: // global
           call _c1ooT(R1) args: 0, res: 0, upd: 0;
       c1ooU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ooT() //  [R1]
         { info_tbl: [(c1ooT,
                       label: block_c1ooT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ooT: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.686266377 UTC

[section ""data" . GHC.Real.div_closure" {
     GHC.Real.div_closure:
         const GHC.Real.div_info;
 },
 GHC.Real.div_entry() //  [R2]
         { info_tbl: [(c1opj,
                       label: GHC.Real.div_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1opj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1opk; else goto c1opl;
       c1opk: // global
           R2 = R2;
           R1 = GHC.Real.div_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1opl: // global
           I64[Sp - 8] = block_c1opg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1opp; else goto c1oph;
       u1opp: // global
           call _c1opg(R1) args: 0, res: 0, upd: 0;
       c1oph: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1opg() //  [R1]
         { info_tbl: [(c1opg,
                       label: block_c1opg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1opg: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.692197543 UTC

[section ""data" . GHC.Real.mod_closure" {
     GHC.Real.mod_closure:
         const GHC.Real.mod_info;
 },
 GHC.Real.mod_entry() //  [R2]
         { info_tbl: [(c1opG,
                       label: GHC.Real.mod_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1opG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1opH; else goto c1opI;
       c1opH: // global
           R2 = R2;
           R1 = GHC.Real.mod_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1opI: // global
           I64[Sp - 8] = block_c1opD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1opM; else goto c1opE;
       u1opM: // global
           call _c1opD(R1) args: 0, res: 0, upd: 0;
       c1opE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1opD() //  [R1]
         { info_tbl: [(c1opD,
                       label: block_c1opD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1opD: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.697576465 UTC

[section ""data" . GHC.Real.quotRem_closure" {
     GHC.Real.quotRem_closure:
         const GHC.Real.quotRem_info;
 },
 GHC.Real.quotRem_entry() //  [R2]
         { info_tbl: [(c1oq3,
                       label: GHC.Real.quotRem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oq3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1oq4; else goto c1oq5;
       c1oq4: // global
           R2 = R2;
           R1 = GHC.Real.quotRem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oq5: // global
           I64[Sp - 8] = block_c1oq0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oq9; else goto c1oq1;
       u1oq9: // global
           call _c1oq0(R1) args: 0, res: 0, upd: 0;
       c1oq1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oq0() //  [R1]
         { info_tbl: [(c1oq0,
                       label: block_c1oq0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oq0: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.702823376 UTC

[section ""data" . GHC.Real.divMod_closure" {
     GHC.Real.divMod_closure:
         const GHC.Real.divMod_info;
 },
 GHC.Real.divMod_entry() //  [R2]
         { info_tbl: [(c1oqq,
                       label: GHC.Real.divMod_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oqq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1oqr; else goto c1oqs;
       c1oqr: // global
           R2 = R2;
           R1 = GHC.Real.divMod_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oqs: // global
           I64[Sp - 8] = block_c1oqn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oqw; else goto c1oqo;
       u1oqw: // global
           call _c1oqn(R1) args: 0, res: 0, upd: 0;
       c1oqo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oqn() //  [R1]
         { info_tbl: [(c1oqn,
                       label: block_c1oqn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oqn: // global
           R1 = P64[R1 + 63];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.708067299 UTC

[section ""data" . GHC.Real.toInteger_closure" {
     GHC.Real.toInteger_closure:
         const GHC.Real.toInteger_info;
 },
 GHC.Real.toInteger_entry() //  [R2]
         { info_tbl: [(c1oqN,
                       label: GHC.Real.toInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oqN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1oqO; else goto c1oqP;
       c1oqO: // global
           R2 = R2;
           R1 = GHC.Real.toInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oqP: // global
           I64[Sp - 8] = block_c1oqK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oqT; else goto c1oqL;
       u1oqT: // global
           call _c1oqK(R1) args: 0, res: 0, upd: 0;
       c1oqL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oqK() //  [R1]
         { info_tbl: [(c1oqK,
                       label: block_c1oqK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oqK: // global
           R1 = P64[R1 + 71];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.714264048 UTC

[section ""data" . GHC.Real.$p1Real_closure" {
     GHC.Real.$p1Real_closure:
         const GHC.Real.$p1Real_info;
 },
 GHC.Real.$p1Real_entry() //  [R2]
         { info_tbl: [(c1ora,
                       label: GHC.Real.$p1Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ora: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1orb; else goto c1orc;
       c1orb: // global
           R2 = R2;
           R1 = GHC.Real.$p1Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1orc: // global
           I64[Sp - 8] = block_c1or7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1org; else goto c1or8;
       u1org: // global
           call _c1or7(R1) args: 0, res: 0, upd: 0;
       c1or8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1or7() //  [R1]
         { info_tbl: [(c1or7,
                       label: block_c1or7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1or7: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.720158463 UTC

[section ""data" . GHC.Real.$p2Real_closure" {
     GHC.Real.$p2Real_closure:
         const GHC.Real.$p2Real_info;
 },
 GHC.Real.$p2Real_entry() //  [R2]
         { info_tbl: [(c1orz,
                       label: GHC.Real.$p2Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1orz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1orA; else goto c1orB;
       c1orA: // global
           R2 = R2;
           R1 = GHC.Real.$p2Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1orB: // global
           I64[Sp - 8] = block_c1orw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1orF; else goto c1orx;
       u1orF: // global
           call _c1orw(R1) args: 0, res: 0, upd: 0;
       c1orx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1orw() //  [R1]
         { info_tbl: [(c1orw,
                       label: block_c1orw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1orw: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.725685458 UTC

[section ""data" . GHC.Real.toRational_closure" {
     GHC.Real.toRational_closure:
         const GHC.Real.toRational_info;
 },
 GHC.Real.toRational_entry() //  [R2]
         { info_tbl: [(c1orY,
                       label: GHC.Real.toRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1orY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1orZ; else goto c1os0;
       c1orZ: // global
           R2 = R2;
           R1 = GHC.Real.toRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1os0: // global
           I64[Sp - 8] = block_c1orV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1os4; else goto c1orW;
       u1os4: // global
           call _c1orV(R1) args: 0, res: 0, upd: 0;
       c1orW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1orV() //  [R1]
         { info_tbl: [(c1orV,
                       label: block_c1orV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1orV: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.730922681 UTC

[section ""data" . GHC.Real.$p1RealFrac_closure" {
     GHC.Real.$p1RealFrac_closure:
         const GHC.Real.$p1RealFrac_info;
 },
 GHC.Real.$p1RealFrac_entry() //  [R2]
         { info_tbl: [(c1osl,
                       label: GHC.Real.$p1RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1osl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1osm; else goto c1osn;
       c1osm: // global
           R2 = R2;
           R1 = GHC.Real.$p1RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1osn: // global
           I64[Sp - 8] = block_c1osi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1osr; else goto c1osj;
       u1osr: // global
           call _c1osi(R1) args: 0, res: 0, upd: 0;
       c1osj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1osi() //  [R1]
         { info_tbl: [(c1osi,
                       label: block_c1osi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1osi: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.736427388 UTC

[section ""data" . GHC.Real.$p2RealFrac_closure" {
     GHC.Real.$p2RealFrac_closure:
         const GHC.Real.$p2RealFrac_info;
 },
 GHC.Real.$p2RealFrac_entry() //  [R2]
         { info_tbl: [(c1osK,
                       label: GHC.Real.$p2RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1osK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1osL; else goto c1osM;
       c1osL: // global
           R2 = R2;
           R1 = GHC.Real.$p2RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1osM: // global
           I64[Sp - 8] = block_c1osH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1osQ; else goto c1osI;
       u1osQ: // global
           call _c1osH(R1) args: 0, res: 0, upd: 0;
       c1osI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1osH() //  [R1]
         { info_tbl: [(c1osH,
                       label: block_c1osH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1osH: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.741834972 UTC

[section ""data" . GHC.Real.properFraction_closure" {
     GHC.Real.properFraction_closure:
         const GHC.Real.properFraction_info;
 },
 GHC.Real.properFraction_entry() //  [R2]
         { info_tbl: [(c1ot9,
                       label: GHC.Real.properFraction_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ot9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1ota; else goto c1otb;
       c1ota: // global
           R2 = R2;
           R1 = GHC.Real.properFraction_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1otb: // global
           I64[Sp - 8] = block_c1ot6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1otf; else goto c1ot7;
       u1otf: // global
           call _c1ot6(R1) args: 0, res: 0, upd: 0;
       c1ot7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ot6() //  [R1]
         { info_tbl: [(c1ot6,
                       label: block_c1ot6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ot6: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.747530952 UTC

[section ""data" . GHC.Real.truncate_closure" {
     GHC.Real.truncate_closure:
         const GHC.Real.truncate_info;
 },
 GHC.Real.truncate_entry() //  [R2]
         { info_tbl: [(c1otw,
                       label: GHC.Real.truncate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1otw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1otx; else goto c1oty;
       c1otx: // global
           R2 = R2;
           R1 = GHC.Real.truncate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oty: // global
           I64[Sp - 8] = block_c1ott_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1otC; else goto c1otu;
       u1otC: // global
           call _c1ott(R1) args: 0, res: 0, upd: 0;
       c1otu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ott() //  [R1]
         { info_tbl: [(c1ott,
                       label: block_c1ott_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ott: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.752565433 UTC

[section ""data" . GHC.Real.round_closure" {
     GHC.Real.round_closure:
         const GHC.Real.round_info;
 },
 GHC.Real.round_entry() //  [R2]
         { info_tbl: [(c1otT,
                       label: GHC.Real.round_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1otT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1otU; else goto c1otV;
       c1otU: // global
           R2 = R2;
           R1 = GHC.Real.round_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1otV: // global
           I64[Sp - 8] = block_c1otQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1otZ; else goto c1otR;
       u1otZ: // global
           call _c1otQ(R1) args: 0, res: 0, upd: 0;
       c1otR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1otQ() //  [R1]
         { info_tbl: [(c1otQ,
                       label: block_c1otQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1otQ: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.758169965 UTC

[section ""data" . GHC.Real.ceiling_closure" {
     GHC.Real.ceiling_closure:
         const GHC.Real.ceiling_info;
 },
 GHC.Real.ceiling_entry() //  [R2]
         { info_tbl: [(c1oug,
                       label: GHC.Real.ceiling_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oug: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1ouh; else goto c1oui;
       c1ouh: // global
           R2 = R2;
           R1 = GHC.Real.ceiling_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oui: // global
           I64[Sp - 8] = block_c1oud_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oum; else goto c1oue;
       u1oum: // global
           call _c1oud(R1) args: 0, res: 0, upd: 0;
       c1oue: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oud() //  [R1]
         { info_tbl: [(c1oud,
                       label: block_c1oud_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oud: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.763346749 UTC

[section ""data" . GHC.Real.floor_closure" {
     GHC.Real.floor_closure:
         const GHC.Real.floor_info;
 },
 GHC.Real.floor_entry() //  [R2]
         { info_tbl: [(c1ouD,
                       label: GHC.Real.floor_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ouD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1ouE; else goto c1ouF;
       c1ouE: // global
           R2 = R2;
           R1 = GHC.Real.floor_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1ouF: // global
           I64[Sp - 8] = block_c1ouA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ouJ; else goto c1ouB;
       u1ouJ: // global
           call _c1ouA(R1) args: 0, res: 0, upd: 0;
       c1ouB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ouA() //  [R1]
         { info_tbl: [(c1ouA,
                       label: block_c1ouA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ouA: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.768899627 UTC

[section ""data" . GHC.Real.$W:%_closure" {
     GHC.Real.$W:%_closure:
         const GHC.Real.$W:%_info;
 },
 GHC.Real.$W:%_entry() //  [R2, R3]
         { info_tbl: [(c1ov2,
                       label: GHC.Real.$W:%_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ov2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ov3; else goto c1ov4;
       c1ov3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$W:%_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ov4: // global
           I64[Sp - 16] = block_c1ouX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ouX() //  [R1]
         { info_tbl: [(c1ouX,
                       label: block_c1ouX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ouX: // global
           I64[Sp] = block_c1ouZ_info;
           _s1j7b::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1j7b::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ouZ() //  [R1]
         { info_tbl: [(c1ouZ,
                       label: block_c1ouZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ouZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ov8; else goto c1ov7;
       c1ov8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ov7: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.776908323 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$c<_closure" {
     GHC.Real.$fOrdRatio_$s$c<_closure:
         const GHC.Real.$fOrdRatio_$s$c<_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$c<_entry() //  [R2, R3]
         { info_tbl: [(c1ovt,
                       label: GHC.Real.$fOrdRatio_$s$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ovt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1ovK; else goto c1ovL;
       c1ovK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ovL: // global
           I64[Sp - 16] = block_c1ovq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1ovV; else goto c1ovr;
       u1ovV: // global
           call _c1ovq(R1) args: 0, res: 0, upd: 0;
       c1ovr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ovq() //  [R1]
         { info_tbl: [(c1ovq,
                       label: block_c1ovq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ovq: // global
           I64[Sp - 8] = block_c1ovw_info;
           _s1j7g::P64 = P64[R1 + 7];
           _s1j7h::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j7h::P64;
           P64[Sp + 8] = _s1j7g::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ovU; else goto c1ovx;
       u1ovU: // global
           call _c1ovw(R1) args: 0, res: 0, upd: 0;
       c1ovx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ovw() //  [R1]
         { info_tbl: [(c1ovw,
                       label: block_c1ovw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ovw: // global
           I64[Sp] = block_c1ovB_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp + 8] = P64[R1 + 15];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ovB() //  [R1]
         { info_tbl: [(c1ovB,
                       label: block_c1ovB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ovB: // global
           _s1j7k::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1ovF_info;
           R3 = _s1j7k::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ovF() //  [R1]
         { info_tbl: [(c1ovF,
                       label: block_c1ovF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ovF: // global
           _s1j7m::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1ovJ_info;
           R3 = _s1j7m::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ovJ() //  [R1]
         { info_tbl: [(c1ovJ,
                       label: block_c1ovJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ovJ: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.79129741 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c<=_closure" {
     GHC.Real.$fEnumRatio_$s$c<=_closure:
         const GHC.Real.$fEnumRatio_$s$c<=_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c<=_entry() //  [R2, R3]
         { info_tbl: [(c1ows,
                       label: GHC.Real.$fEnumRatio_$s$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ows: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1owJ; else goto c1owK;
       c1owJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1owK: // global
           I64[Sp - 16] = block_c1owp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1owU; else goto c1owq;
       u1owU: // global
           call _c1owp(R1) args: 0, res: 0, upd: 0;
       c1owq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1owp() //  [R1]
         { info_tbl: [(c1owp,
                       label: block_c1owp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1owp: // global
           I64[Sp - 8] = block_c1owv_info;
           _s1j7r::P64 = P64[R1 + 7];
           _s1j7s::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j7s::P64;
           P64[Sp + 8] = _s1j7r::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1owT; else goto c1oww;
       u1owT: // global
           call _c1owv(R1) args: 0, res: 0, upd: 0;
       c1oww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1owv() //  [R1]
         { info_tbl: [(c1owv,
                       label: block_c1owv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1owv: // global
           I64[Sp] = block_c1owA_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp + 8] = P64[R1 + 15];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1owA() //  [R1]
         { info_tbl: [(c1owA,
                       label: block_c1owA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1owA: // global
           _s1j7v::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1owE_info;
           R3 = _s1j7v::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1owE() //  [R1]
         { info_tbl: [(c1owE,
                       label: block_c1owE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1owE: // global
           _s1j7x::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1owI_info;
           R3 = _s1j7x::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1owI() //  [R1]
         { info_tbl: [(c1owI,
                       label: block_c1owI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1owI: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.804432557 UTC

[section ""data" . GHC.Real.$w$s$ccompare_closure" {
     GHC.Real.$w$s$ccompare_closure:
         const GHC.Real.$w$s$ccompare_info;
         const 0;
 },
 GHC.Real.$w$s$ccompare_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1oxq,
                       label: GHC.Real.$w$s$ccompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oxq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1oxr; else goto c1oxs;
       c1oxr: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$ccompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oxs: // global
           I64[Sp - 40] = block_c1oxo_info;
           _s1j7A::P64 = R3;
           R3 = R4;
           _s1j7z::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s1j7z::P64;
           P64[Sp - 24] = _s1j7A::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oxo() //  [R1]
         { info_tbl: [(c1oxo,
                       label: block_c1oxo_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oxo: // global
           if (R1 == 1) goto c1oy3; else goto u1oye;
       c1oy3: // global
           I64[Sp] = block_c1oy2_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       u1oye: // global
           Sp = Sp + 8;
           call _s1j7E() args: 0, res: 0, upd: 0;
     }
 },
 _c1oy2() //  [R1]
         { info_tbl: [(c1oy2,
                       label: block_c1oy2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oy2: // global
           if (R1 == 1) goto c1oyd; else goto u1oyf;
       c1oyd: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1oyf: // global
           Sp = Sp + 8;
           call _s1j7E() args: 0, res: 0, upd: 0;
     }
 },
 _s1j7E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1j7E: // global
           I64[Sp - 8] = block_c1oxB_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oxB() //  [R1]
         { info_tbl: [(c1oxB,
                       label: block_c1oxB_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oxB: // global
           I64[Sp + 24] = block_c1oxF_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oxF() //  [R1]
         { info_tbl: [(c1oxF,
                       label: block_c1oxF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oxF: // global
           _s1j7G::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1oxL_info;
           R3 = _s1j7G::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oxL() //  [R1]
         { info_tbl: [(c1oxL,
                       label: block_c1oxL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oxL: // global
           if (R1 == 1) goto c1oxW; else goto c1oxS;
       c1oxW: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1oxS: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.817971902 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$ccompare_closure" {
     GHC.Real.$fEnumRatio_$s$ccompare_closure:
         const GHC.Real.$fEnumRatio_$s$ccompare_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c1oyO,
                       label: GHC.Real.$fEnumRatio_$s$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oyO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1oyS; else goto c1oyT;
       c1oyS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oyT: // global
           I64[Sp - 16] = block_c1oyL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1oz1; else goto c1oyM;
       u1oz1: // global
           call _c1oyL(R1) args: 0, res: 0, upd: 0;
       c1oyM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oyL() //  [R1]
         { info_tbl: [(c1oyL,
                       label: block_c1oyL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oyL: // global
           I64[Sp - 8] = block_c1oyR_info;
           _s1j7N::P64 = P64[R1 + 7];
           _s1j7O::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j7O::P64;
           P64[Sp + 8] = _s1j7N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oz0; else goto c1oyV;
       u1oz0: // global
           call _c1oyR(R1) args: 0, res: 0, upd: 0;
       c1oyV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oyR() //  [R1]
         { info_tbl: [(c1oyR,
                       label: block_c1oyR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oyR: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.825705171 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c>=_closure" {
     GHC.Real.$fEnumRatio_$s$c>=_closure:
         const GHC.Real.$fEnumRatio_$s$c>=_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c>=_entry() //  [R2, R3]
         { info_tbl: [(c1ozm,
                       label: GHC.Real.$fEnumRatio_$s$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ozm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1ozq; else goto c1ozr;
       c1ozq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ozr: // global
           I64[Sp - 16] = block_c1ozj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1ozL; else goto c1ozk;
       u1ozL: // global
           call _c1ozj(R1) args: 0, res: 0, upd: 0;
       c1ozk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ozj() //  [R1]
         { info_tbl: [(c1ozj,
                       label: block_c1ozj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ozj: // global
           I64[Sp - 8] = block_c1ozp_info;
           _s1j7V::P64 = P64[R1 + 7];
           _s1j7W::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j7W::P64;
           P64[Sp + 8] = _s1j7V::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ozK; else goto c1ozt;
       u1ozK: // global
           call _c1ozp(R1) args: 0, res: 0, upd: 0;
       c1ozt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ozp() //  [R1]
         { info_tbl: [(c1ozp,
                       label: block_c1ozp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ozp: // global
           _s1j7V::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1ozx_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1j7V::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ozx() //  [R1]
         { info_tbl: [(c1ozx,
                       label: block_c1ozx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ozx: // global
           if (R1 & 7 == 1) goto c1ozI; else goto c1ozE;
       c1ozI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1ozE: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.835751167 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$c>_closure" {
     GHC.Real.$fOrdRatio_$s$c>_closure:
         const GHC.Real.$fOrdRatio_$s$c>_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$c>_entry() //  [R2, R3]
         { info_tbl: [(c1oAd,
                       label: GHC.Real.$fOrdRatio_$s$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oAd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1oAh; else goto c1oAi;
       c1oAh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oAi: // global
           I64[Sp - 16] = block_c1oAa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1oAC; else goto c1oAb;
       u1oAC: // global
           call _c1oAa(R1) args: 0, res: 0, upd: 0;
       c1oAb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oAa() //  [R1]
         { info_tbl: [(c1oAa,
                       label: block_c1oAa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oAa: // global
           I64[Sp - 8] = block_c1oAg_info;
           _s1j84::P64 = P64[R1 + 7];
           _s1j85::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j85::P64;
           P64[Sp + 8] = _s1j84::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oAB; else goto c1oAk;
       u1oAB: // global
           call _c1oAg(R1) args: 0, res: 0, upd: 0;
       c1oAk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oAg() //  [R1]
         { info_tbl: [(c1oAg,
                       label: block_c1oAg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oAg: // global
           _s1j84::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1oAo_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1j84::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oAo() //  [R1]
         { info_tbl: [(c1oAo,
                       label: block_c1oAo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oAo: // global
           if (R1 & 7 == 3) goto c1oAz; else goto c1oAv;
       c1oAz: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1oAv: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.845970556 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$cmin_closure" {
     GHC.Real.$fOrdRatio_$s$cmin_closure:
         const GHC.Real.$fOrdRatio_$s$cmin_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$cmin_entry() //  [R2, R3]
         { info_tbl: [(c1oB4,
                       label: GHC.Real.$fOrdRatio_$s$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oB4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1oBh; else goto c1oBi;
       c1oBh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oBi: // global
           I64[Sp - 16] = block_c1oB1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1oBC; else goto c1oB2;
       u1oBC: // global
           call _c1oB1(R1) args: 0, res: 0, upd: 0;
       c1oB2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oB1() //  [R1]
         { info_tbl: [(c1oB1,
                       label: block_c1oB1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oB1: // global
           I64[Sp - 16] = block_c1oB7_info;
           _s1j8c::P64 = R1;
           _s1j8d::P64 = P64[R1 + 7];
           _s1j8e::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s1j8e::P64;
           P64[Sp] = _s1j8d::P64;
           P64[Sp + 8] = _s1j8c::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1oBB; else goto c1oB8;
       u1oBB: // global
           call _c1oB7(R1) args: 0, res: 0, upd: 0;
       c1oB8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oB7() //  [R1]
         { info_tbl: [(c1oB7,
                       label: block_c1oB7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oB7: // global
           I64[Sp - 8] = block_c1oBc_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oBc() //  [R1]
         { info_tbl: [(c1oBc,
                       label: block_c1oBc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oBc: // global
           _s1j8h::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1oBg_info;
           R3 = _s1j8h::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oBg() //  [R1]
         { info_tbl: [(c1oBg,
                       label: block_c1oBg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oBg: // global
           I64[Sp] = block_c1oBp_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oBp() //  [R1]
         { info_tbl: [(c1oBp,
                       label: block_c1oBp_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oBp: // global
           if (R1 == 1) goto c1oBA; else goto c1oBw;
       c1oBA: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1oBw: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.859327218 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$cmax_closure" {
     GHC.Real.$fOrdRatio_$s$cmax_closure:
         const GHC.Real.$fOrdRatio_$s$cmax_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$cmax_entry() //  [R2, R3]
         { info_tbl: [(c1oCb,
                       label: GHC.Real.$fOrdRatio_$s$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oCb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1oCo; else goto c1oCp;
       c1oCo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oCp: // global
           I64[Sp - 16] = block_c1oC8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1oCJ; else goto c1oC9;
       u1oCJ: // global
           call _c1oC8(R1) args: 0, res: 0, upd: 0;
       c1oC9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oC8() //  [R1]
         { info_tbl: [(c1oC8,
                       label: block_c1oC8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oC8: // global
           I64[Sp - 16] = block_c1oCe_info;
           _s1j8n::P64 = R1;
           _s1j8o::P64 = P64[R1 + 7];
           _s1j8p::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s1j8p::P64;
           P64[Sp] = _s1j8o::P64;
           P64[Sp + 8] = _s1j8n::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1oCI; else goto c1oCf;
       u1oCI: // global
           call _c1oCe(R1) args: 0, res: 0, upd: 0;
       c1oCf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oCe() //  [R1]
         { info_tbl: [(c1oCe,
                       label: block_c1oCe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oCe: // global
           I64[Sp - 8] = block_c1oCj_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oCj() //  [R1]
         { info_tbl: [(c1oCj,
                       label: block_c1oCj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oCj: // global
           _s1j8s::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1oCn_info;
           R3 = _s1j8s::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oCn() //  [R1]
         { info_tbl: [(c1oCn,
                       label: block_c1oCn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oCn: // global
           I64[Sp] = block_c1oCw_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oCw() //  [R1]
         { info_tbl: [(c1oCw,
                       label: block_c1oCw_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oCw: // global
           if (R1 == 1) goto c1oCH; else goto c1oCD;
       c1oCH: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1oCD: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.871854416 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cnegate_closure" {
     GHC.Real.$fFractionalRatio_$s$cnegate_closure:
         const GHC.Real.$fFractionalRatio_$s$cnegate_info;
 },
 GHC.Real.$fFractionalRatio_$s$cnegate_entry() //  [R2]
         { info_tbl: [(c1oDi,
                       label: GHC.Real.$fFractionalRatio_$s$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oDi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1oDq; else goto c1oDr;
       c1oDq: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oDr: // global
           I64[Sp - 8] = block_c1oDf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oDw; else goto c1oDg;
       u1oDw: // global
           call _c1oDf(R1) args: 0, res: 0, upd: 0;
       c1oDg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oDf() //  [R1]
         { info_tbl: [(c1oDf,
                       label: block_c1oDf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oDf: // global
           I64[Sp - 8] = block_c1oDl_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oDl() //  [R1]
         { info_tbl: [(c1oDl,
                       label: block_c1oDl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oDl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1oDv; else goto c1oDu;
       c1oDv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oDu: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.879337532 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cabs_closure" {
     GHC.Real.$fFractionalRatio_$s$cabs_closure:
         const GHC.Real.$fFractionalRatio_$s$cabs_info;
 },
 GHC.Real.$fFractionalRatio_$s$cabs_entry() //  [R2]
         { info_tbl: [(c1oDT,
                       label: GHC.Real.$fFractionalRatio_$s$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oDT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1oE1; else goto c1oE2;
       c1oE1: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oE2: // global
           I64[Sp - 8] = block_c1oDQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oE7; else goto c1oDR;
       u1oE7: // global
           call _c1oDQ(R1) args: 0, res: 0, upd: 0;
       c1oDR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oDQ() //  [R1]
         { info_tbl: [(c1oDQ,
                       label: block_c1oDQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oDQ: // global
           I64[Sp - 8] = block_c1oDW_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oDW() //  [R1]
         { info_tbl: [(c1oDW,
                       label: block_c1oDW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oDW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1oE6; else goto c1oE5;
       c1oE6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oE5: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.886870907 UTC

[section ""data" . sat_s1j8G_closure" {
     sat_s1j8G_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.888505637 UTC

[section ""data" . sat_s1j8H_closure" {
     sat_s1j8H_closure:
         const :_con_info;
         const sat_s1j8G_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.890484469 UTC

[section ""data" . GHC.Real.$fEnumRatio1_closure" {
     GHC.Real.$fEnumRatio1_closure:
         const GHC.Real.$fEnumRatio1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fEnumRatio1_entry() //  [R1]
         { info_tbl: [(c1oEv,
                       label: GHC.Real.$fEnumRatio1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oEv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1oEw; else goto c1oEx;
       c1oEw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oEx: // global
           (_c1oEs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1oEs::I64 == 0) goto c1oEu; else goto c1oEt;
       c1oEu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1oEt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1oEs::I64;
           R3 = sat_s1j8H_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.894958185 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$csignum_closure" {
     GHC.Real.$fFractionalRatio_$s$csignum_closure:
         const GHC.Real.$fFractionalRatio_$s$csignum_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$csignum_entry() //  [R2]
         { info_tbl: [(c1oEM,
                       label: GHC.Real.$fFractionalRatio_$s$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oEM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1oEU; else goto c1oEV;
       c1oEU: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oEV: // global
           I64[Sp - 8] = block_c1oEJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oF0; else goto c1oEK;
       u1oF0: // global
           call _c1oEJ(R1) args: 0, res: 0, upd: 0;
       c1oEK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oEJ() //  [R1]
         { info_tbl: [(c1oEJ,
                       label: block_c1oEJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oEJ: // global
           I64[Sp] = block_c1oEP_info;
           R2 = P64[R1 + 7];
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oEP() //  [R1]
         { info_tbl: [(c1oEP,
                       label: block_c1oEP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oEP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1oEZ; else goto c1oEY;
       c1oEZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oEY: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Real.$fEnumRatio1_closure;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.90228141 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cfromInteger_closure" {
     GHC.Real.$fFractionalRatio_$s$cfromInteger_closure:
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$cfromInteger_entry() //  [R2]
         { info_tbl: [(c1oFl,
                       label: GHC.Real.$fFractionalRatio_$s$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oFl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1oFp; else goto c1oFq;
       c1oFp: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oFq: // global
           I64[Sp - 8] = block_c1oFi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oFu; else goto c1oFj;
       u1oFu: // global
           call _c1oFi(R1) args: 0, res: 0, upd: 0;
       c1oFj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oFi() //  [R1]
         { info_tbl: [(c1oFi,
                       label: block_c1oFi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oFi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1oFt; else goto c1oFs;
       c1oFt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oFs: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Real.$fEnumRatio1_closure;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.907971635 UTC

[section ""data" . GHC.Real.$fRealInteger_closure" {
     GHC.Real.$fRealInteger_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Num.$fNumInteger_closure;
         const GHC.Integer.Type.$fOrdInteger_closure;
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.911719434 UTC

[section ""data" . GHC.Real.$fIntegralInt_$ctoInteger_closure" {
     GHC.Real.$fIntegralInt_$ctoInteger_closure:
         const GHC.Real.$fIntegralInt_$ctoInteger_info;
 },
 GHC.Real.$fIntegralInt_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c1oFN,
                       label: GHC.Real.$fIntegralInt_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oFN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1oFO; else goto c1oFP;
       c1oFO: // global
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oFP: // global
           I64[Sp - 8] = block_c1oFK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oFT; else goto c1oFL;
       u1oFT: // global
           call _c1oFK(R1) args: 0, res: 0, upd: 0;
       c1oFL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oFK() //  [R1]
         { info_tbl: [(c1oFK,
                       label: block_c1oFK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oFK: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.917442375 UTC

[section ""data" . GHC.Real.$fEnumRatio_$ctoRational_closure" {
     GHC.Real.$fEnumRatio_$ctoRational_closure:
         const GHC.Real.$fEnumRatio_$ctoRational_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$ctoRational_entry() //  [R2]
         { info_tbl: [(c1oGa,
                       label: GHC.Real.$fEnumRatio_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oGa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1oGi; else goto c1oGj;
       c1oGi: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oGj: // global
           I64[Sp - 8] = block_c1oG7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oGo; else goto c1oG8;
       u1oGo: // global
           call _c1oG7(R1) args: 0, res: 0, upd: 0;
       c1oG8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oG7() //  [R1]
         { info_tbl: [(c1oG7,
                       label: block_c1oG7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oG7: // global
           I64[Sp] = block_c1oGd_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oGd() //  [R1]
         { info_tbl: [(c1oGd,
                       label: block_c1oGd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oGd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1oGn; else goto c1oGm;
       c1oGn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oGm: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Real.$fEnumRatio1_closure;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.924390536 UTC

[section ""data" . GHC.Real.$fRealInt_closure" {
     GHC.Real.$fRealInt_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Num.$fNumInt_closure;
         const GHC.Classes.$fOrdInt_closure;
         const GHC.Real.$fEnumRatio_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.92641612 UTC

[section ""data" . GHC.Real.$fIntegralWord_$ctoInteger_closure" {
     GHC.Real.$fIntegralWord_$ctoInteger_closure:
         const GHC.Real.$fIntegralWord_$ctoInteger_info;
 },
 GHC.Real.$fIntegralWord_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c1oGK,
                       label: GHC.Real.$fIntegralWord_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oGK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1oGL; else goto c1oGM;
       c1oGL: // global
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oGM: // global
           I64[Sp - 8] = block_c1oGH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oGQ; else goto c1oGI;
       u1oGQ: // global
           call _c1oGH(R1) args: 0, res: 0, upd: 0;
       c1oGI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oGH() //  [R1]
         { info_tbl: [(c1oGH,
                       label: block_c1oGH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oGH: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.931780593 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$ctoInteger_closure" {
     GHC.Real.$fIntegralInteger_$ctoInteger_closure:
         const GHC.Real.$fIntegralInteger_$ctoInteger_info;
 },
 GHC.Real.$fIntegralInteger_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c1oH4,
                       label: GHC.Real.$fIntegralInteger_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oH4: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.935487497 UTC

[section ""data" . GHC.Real.$fEqRatio_$s$c==_closure" {
     GHC.Real.$fEqRatio_$s$c==_closure:
         const GHC.Real.$fEqRatio_$s$c==_info;
 },
 GHC.Real.$fEqRatio_$s$c==_entry() //  [R2, R3]
         { info_tbl: [(c1oHk,
                       label: GHC.Real.$fEqRatio_$s$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oHk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1oHo; else goto c1oHp;
       c1oHo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_$s$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oHp: // global
           I64[Sp - 16] = block_c1oHh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1oHN; else goto c1oHi;
       u1oHN: // global
           call _c1oHh(R1) args: 0, res: 0, upd: 0;
       c1oHi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oHh() //  [R1]
         { info_tbl: [(c1oHh,
                       label: block_c1oHh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oHh: // global
           I64[Sp - 8] = block_c1oHn_info;
           _s1j93::P64 = P64[R1 + 7];
           _s1j94::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j94::P64;
           P64[Sp + 8] = _s1j93::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oHM; else goto c1oHr;
       u1oHM: // global
           call _c1oHn(R1) args: 0, res: 0, upd: 0;
       c1oHr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oHn() //  [R1]
         { info_tbl: [(c1oHn,
                       label: block_c1oHn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oHn: // global
           I64[Sp] = block_c1oHv_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 15];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oHv() //  [R1]
         { info_tbl: [(c1oHv,
                       label: block_c1oHv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oHv: // global
           if (R1 == 1) goto c1oHH; else goto c1oHC;
       c1oHH: // global
           _s1j97::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1oHF_info;
           R3 = _s1j97::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       c1oHC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1oHF() //  [R1]
         { info_tbl: [(c1oHF,
                       label: block_c1oHF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oHF: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.947313867 UTC

[section ""data" . GHC.Real.$fEqRatio_$c==_closure" {
     GHC.Real.$fEqRatio_$c==_closure:
         const GHC.Real.$fEqRatio_$c==_info;
 },
 GHC.Real.$fEqRatio_$c==_entry() //  [R2, R3, R4]
         { info_tbl: [(c1oIi,
                       label: GHC.Real.$fEqRatio_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oIi: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1oIm; else goto c1oIn;
       c1oIm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oIn: // global
           I64[Sp - 24] = block_c1oIf_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1oIH; else goto c1oIg;
       u1oIH: // global
           call _c1oIf(R1) args: 0, res: 0, upd: 0;
       c1oIg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oIf() //  [R1]
         { info_tbl: [(c1oIf,
                       label: block_c1oIf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oIf: // global
           I64[Sp - 8] = block_c1oIl_info;
           _s1j9e::P64 = P64[R1 + 7];
           _s1j9f::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1j9f::P64;
           P64[Sp + 16] = _s1j9e::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oIG; else goto c1oIp;
       u1oIG: // global
           call _c1oIl(R1) args: 0, res: 0, upd: 0;
       c1oIp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oIl() //  [R1]
         { info_tbl: [(c1oIl,
                       label: block_c1oIl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oIl: // global
           I64[Sp] = block_c1oIt_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1oIt() //  [R1]
         { info_tbl: [(c1oIt,
                       label: block_c1oIt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oIt: // global
           if (R1 & 7 == 1) goto c1oIA; else goto c1oIE;
       c1oIA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1oIE: // global
           R2 = P64[Sp + 16];
           _s1j9f::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1j9f::P64;
           Sp = Sp + 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.956923868 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$c/=_closure" {
     GHC.Real.$fOrdRatio_$s$c/=_closure:
         const GHC.Real.$fOrdRatio_$s$c/=_info;
 },
 GHC.Real.$fOrdRatio_$s$c/=_entry() //  [R2, R3]
         { info_tbl: [(c1oJb,
                       label: GHC.Real.$fOrdRatio_$s$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oJb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1oJf; else goto c1oJg;
       c1oJf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oJg: // global
           I64[Sp - 16] = block_c1oJ8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1oJM; else goto c1oJ9;
       u1oJM: // global
           call _c1oJ8(R1) args: 0, res: 0, upd: 0;
       c1oJ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oJ8() //  [R1]
         { info_tbl: [(c1oJ8,
                       label: block_c1oJ8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oJ8: // global
           I64[Sp - 8] = block_c1oJe_info;
           _s1j9n::P64 = P64[R1 + 7];
           _s1j9o::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1j9o::P64;
           P64[Sp + 8] = _s1j9n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oJL; else goto c1oJi;
       u1oJL: // global
           call _c1oJe(R1) args: 0, res: 0, upd: 0;
       c1oJi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oJe() //  [R1]
         { info_tbl: [(c1oJe,
                       label: block_c1oJe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oJe: // global
           I64[Sp] = block_c1oJm_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 15];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oJm() //  [R1]
         { info_tbl: [(c1oJm,
                       label: block_c1oJm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oJm: // global
           if (R1 == 1) goto c1oJy; else goto u1oJJ;
       c1oJy: // global
           _s1j9r::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1oJw_info;
           R3 = _s1j9r::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       u1oJJ: // global
           Sp = Sp + 24;
           call _c1oJE() args: 0, res: 0, upd: 0;
     }
 },
 _c1oJw() //  [R1]
         { info_tbl: [(c1oJw,
                       label: block_c1oJw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oJw: // global
           if (R1 == 1) goto c1oJI; else goto u1oJK;
       c1oJI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1oJK: // global
           Sp = Sp + 8;
           call _c1oJE() args: 0, res: 0, upd: 0;
     }
 },
 _c1oJE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oJE: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.977623313 UTC

[section ""data" . GHC.Real.$fEqRatio_$c/=_closure" {
     GHC.Real.$fEqRatio_$c/=_closure:
         const GHC.Real.$fEqRatio_$c/=_info;
 },
 GHC.Real.$fEqRatio_$c/=_entry() //  [R2, R3, R4]
         { info_tbl: [(c1oKk,
                       label: GHC.Real.$fEqRatio_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oKk: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1oKo; else goto c1oKp;
       c1oKo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oKp: // global
           I64[Sp - 24] = block_c1oKh_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1oKX; else goto c1oKi;
       u1oKX: // global
           call _c1oKh(R1) args: 0, res: 0, upd: 0;
       c1oKi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oKh() //  [R1]
         { info_tbl: [(c1oKh,
                       label: block_c1oKh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oKh: // global
           I64[Sp - 8] = block_c1oKn_info;
           _s1j9y::P64 = P64[R1 + 7];
           _s1j9z::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1j9z::P64;
           P64[Sp + 16] = _s1j9y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1oKW; else goto c1oKr;
       u1oKW: // global
           call _c1oKn(R1) args: 0, res: 0, upd: 0;
       c1oKr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oKn() //  [R1]
         { info_tbl: [(c1oKn,
                       label: block_c1oKn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oKn: // global
           I64[Sp] = block_c1oKv_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1oKv() //  [R1]
         { info_tbl: [(c1oKv,
                       label: block_c1oKv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oKv: // global
           if (R1 & 7 == 1) goto u1oKU; else goto c1oKH;
       u1oKU: // global
           Sp = Sp + 32;
           call _c1oKN() args: 0, res: 0, upd: 0;
       c1oKH: // global
           _s1j9C::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1oKF_info;
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = _s1j9C::P64;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1oKF() //  [R1]
         { info_tbl: [(c1oKF,
                       label: block_c1oKF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oKF: // global
           if (R1 & 7 == 1) goto u1oKV; else goto c1oKR;
       u1oKV: // global
           Sp = Sp + 8;
           call _c1oKN() args: 0, res: 0, upd: 0;
       c1oKR: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1oKN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oKN: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.996538114 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$fEqRatio_closure" {
     GHC.Real.$fOrdRatio_$s$fEqRatio_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Real.$fEqRatio_$s$c==_closure+2;
         const GHC.Real.$fOrdRatio_$s$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:03.999833269 UTC

[section ""data" . GHC.Real.$fEqRatio_closure" {
     GHC.Real.$fEqRatio_closure:
         const GHC.Real.$fEqRatio_info;
 },
 sat_s1j9H_entry() //  [R1, R2, R3]
         { info_tbl: [(c1oLE,
                       label: sat_s1j9H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oLE: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fEqRatio_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1j9G_entry() //  [R1, R2, R3]
         { info_tbl: [(c1oLM,
                       label: sat_s1j9G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oLM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fEqRatio_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEqRatio_entry() //  [R2]
         { info_tbl: [(c1oLQ,
                       label: GHC.Real.$fEqRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oLQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1oLU; else goto c1oLT;
       c1oLU: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oLT: // global
           I64[Hp - 48] = sat_s1j9H_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s1j9G_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.009393242 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$fOrdRatio_closure" {
     GHC.Real.$fOrdRatio_$s$fOrdRatio_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Real.$fOrdRatio_$s$fEqRatio_closure+1;
         const GHC.Real.$fEnumRatio_$s$ccompare_closure+2;
         const GHC.Real.$fOrdRatio_$s$c<_closure+2;
         const GHC.Real.$fEnumRatio_$s$c<=_closure+2;
         const GHC.Real.$fOrdRatio_$s$c>_closure+2;
         const GHC.Real.$fEnumRatio_$s$c>=_closure+2;
         const GHC.Real.$fOrdRatio_$s$cmax_closure+2;
         const GHC.Real.$fOrdRatio_$s$cmin_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.012432649 UTC

[section ""data" . GHC.Real.$fOrdRatio_$cp1Ord_closure" {
     GHC.Real.$fOrdRatio_$cp1Ord_closure:
         const GHC.Real.$fOrdRatio_$cp1Ord_info;
 },
 sat_s1j9L_entry() //  [R1]
         { info_tbl: [(c1oMj,
                       label: sat_s1j9L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oMj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1oMn; else goto c1oMo;
       c1oMn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oMo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1oMh_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1oMh() //  [R1]
         { info_tbl: [(c1oMh,
                       label: block_c1oMh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oMh: // global
           I64[Sp] = block_c1oMm_info;
           R2 = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1oMm() //  [R1]
         { info_tbl: [(c1oMm,
                       label: block_c1oMm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oMm: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fOrdRatio_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c1oMu,
                       label: GHC.Real.$fOrdRatio_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oMu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1oMy; else goto c1oMx;
       c1oMy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1oMx: // global
           I64[Hp - 16] = sat_s1j9L_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Real.$fEqRatio_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.021350112 UTC

[section ""data" . GHC.Real.even1_closure" {
     GHC.Real.even1_closure:
         const GHC.Real.even1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.even1_entry() //  [R1]
         { info_tbl: [(c1oMT,
                       label: GHC.Real.even1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oMT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1oMU; else goto c1oMV;
       c1oMU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oMV: // global
           (_c1oMQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1oMQ::I64 == 0) goto c1oMS; else goto c1oMR;
       c1oMS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1oMR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1oMQ::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.026507935 UTC

[section ""data" . GHC.Real.$dmfloor_closure" {
     GHC.Real.$dmfloor_closure:
         const GHC.Real.$dmfloor_info;
         const 0;
 },
 ds_s1j9P_entry() //  [R1]
         { info_tbl: [(c1oNb,
                       label: ds_s1j9P_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oNb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1oNc; else goto c1oNd;
       c1oNc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oNd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.properFraction_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1j9X_entry() //  [R1]
         { info_tbl: [(c1oNo,
                       label: sat_s1j9X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oNo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oNp; else goto c1oNq;
       c1oNp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oNq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1oNm_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1oNm() //  [R1]
         { info_tbl: [(c1oNm,
                       label: block_c1oNm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oNm: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1ja8_entry() //  [R1]
         { info_tbl: [(c1oNQ,
                       label: sat_s1ja8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oNQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oNR; else goto c1oNS;
       c1oNR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oNS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(c1oNT,
                       label: GHC.Real.$dmfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oNT: // global
           _s1j9O::P64 = R4;
           _s1j9N::P64 = R3;
           _s1j9M::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1oNU; else goto c1oNV;
       c1oNV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1oNX; else goto c1oNW;
       c1oNX: // global
           HpAlloc = 40;
           goto c1oNU;
       c1oNU: // global
           R4 = _s1j9O::P64;
           R3 = _s1j9N::P64;
           R2 = _s1j9M::P64;
           R1 = GHC.Real.$dmfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oNW: // global
           I64[Hp - 32] = ds_s1j9P_info;
           P64[Hp - 16] = _s1j9M::P64;
           P64[Hp - 8] = _s1j9N::P64;
           P64[Hp] = _s1j9O::P64;
           I64[Sp - 24] = block_c1oNe_info;
           R2 = _s1j9M::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s1j9N::P64;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oNe() //  [R1]
         { info_tbl: [(c1oNe,
                       label: block_c1oNe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oNe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1oO0; else goto c1oNZ;
       c1oO0: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oNZ: // global
           I64[Hp - 40] = sat_s1j9X_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = block_c1oNv_info;
           R2 = R1;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oNv() //  [R1]
         { info_tbl: [(c1oNv,
                       label: block_c1oNv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oNv: // global
           _c1oNi::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1oNz_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _c1oNi::P64;
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1oNz() //  [R1]
         { info_tbl: [(c1oNz,
                       label: block_c1oNz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oNz: // global
           if (R1 & 7 == 1) goto c1oO6; else goto c1oOd;
       c1oO6: // global
           I64[Sp + 16] = block_c1oO3_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u1oOk; else goto c1oO7;
       u1oOk: // global
           call _c1oO3(R1) args: 0, res: 0, upd: 0;
       c1oO7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1oOd: // global
           I64[Sp] = block_c1oNE_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oO3() //  [R1]
         { info_tbl: [(c1oO3,
                       label: block_c1oO3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oO3: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1oNE() //  [R1]
         { info_tbl: [(c1oNE,
                       label: block_c1oNE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oNE: // global
           I64[Sp] = block_c1oNI_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oNI() //  [R1]
         { info_tbl: [(c1oNI,
                       label: block_c1oNI_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oNI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1oOh; else goto c1oOg;
       c1oOh: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oOg: // global
           I64[Hp - 40] = sat_s1ja8_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = Hp - 40;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.049834256 UTC

[section ""data" . GHC.Real.$dmceiling_closure" {
     GHC.Real.$dmceiling_closure:
         const GHC.Real.$dmceiling_info;
         const 0;
 },
 ds_s1jac_entry() //  [R1]
         { info_tbl: [(c1oPi,
                       label: ds_s1jac_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oPi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1oPj; else goto c1oPk;
       c1oPj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oPk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.properFraction_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jak_entry() //  [R1]
         { info_tbl: [(c1oPv,
                       label: sat_s1jak_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oPv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oPw; else goto c1oPx;
       c1oPw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oPx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1oPt_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1oPt() //  [R1]
         { info_tbl: [(c1oPt,
                       label: block_c1oPt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oPt: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jav_entry() //  [R1]
         { info_tbl: [(c1oPX,
                       label: sat_s1jav_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oPX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oPY; else goto c1oPZ;
       c1oPY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oPZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(c1oQ0,
                       label: GHC.Real.$dmceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oQ0: // global
           _s1jab::P64 = R4;
           _s1jaa::P64 = R3;
           _s1ja9::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1oQ1; else goto c1oQ2;
       c1oQ2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1oQ4; else goto c1oQ3;
       c1oQ4: // global
           HpAlloc = 40;
           goto c1oQ1;
       c1oQ1: // global
           R4 = _s1jab::P64;
           R3 = _s1jaa::P64;
           R2 = _s1ja9::P64;
           R1 = GHC.Real.$dmceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oQ3: // global
           I64[Hp - 32] = ds_s1jac_info;
           P64[Hp - 16] = _s1ja9::P64;
           P64[Hp - 8] = _s1jaa::P64;
           P64[Hp] = _s1jab::P64;
           I64[Sp - 24] = block_c1oPl_info;
           R2 = _s1ja9::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s1jaa::P64;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oPl() //  [R1]
         { info_tbl: [(c1oPl,
                       label: block_c1oPl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oPl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1oQ7; else goto c1oQ6;
       c1oQ7: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oQ6: // global
           I64[Hp - 40] = sat_s1jak_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = block_c1oPC_info;
           R2 = R1;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oPC() //  [R1]
         { info_tbl: [(c1oPC,
                       label: block_c1oPC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oPC: // global
           _c1oPp::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1oPG_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _c1oPp::P64;
           Sp = Sp - 8;
           call GHC.Classes.>_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1oPG() //  [R1]
         { info_tbl: [(c1oPG,
                       label: block_c1oPG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oPG: // global
           if (R1 & 7 == 1) goto c1oQd; else goto c1oQk;
       c1oQd: // global
           I64[Sp + 16] = block_c1oQa_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u1oQr; else goto c1oQe;
       u1oQr: // global
           call _c1oQa(R1) args: 0, res: 0, upd: 0;
       c1oQe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1oQk: // global
           I64[Sp] = block_c1oPL_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oQa() //  [R1]
         { info_tbl: [(c1oQa,
                       label: block_c1oQa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oQa: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1oPL() //  [R1]
         { info_tbl: [(c1oPL,
                       label: block_c1oPL_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oPL: // global
           I64[Sp] = block_c1oPP_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oPP() //  [R1]
         { info_tbl: [(c1oPP,
                       label: block_c1oPP_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oPP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1oQo; else goto c1oQn;
       c1oQo: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oQn: // global
           I64[Hp - 40] = sat_s1jav_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = Hp - 40;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.072257019 UTC

[section ""data" . GHC.Real.$dmtruncate_closure" {
     GHC.Real.$dmtruncate_closure:
         const GHC.Real.$dmtruncate_info;
 },
 GHC.Real.$dmtruncate_entry() //  [R2, R3, R4]
         { info_tbl: [(c1oRn,
                       label: GHC.Real.$dmtruncate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oRn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oRo; else goto c1oRp;
       c1oRo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmtruncate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oRp: // global
           I64[Sp - 8] = block_c1oRl_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.properFraction_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1oRl() //  [R1]
         { info_tbl: [(c1oRl,
                       label: block_c1oRl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oRl: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.079204582 UTC

[section ""data" . GHC.Real.$dmrecip_closure" {
     GHC.Real.$dmrecip_closure:
         const GHC.Real.$dmrecip_info;
         const 0;
 },
 sat_s1jaF_entry() //  [R1]
         { info_tbl: [(c1oRL,
                       label: sat_s1jaF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oRL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oRM; else goto c1oRN;
       c1oRM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oRN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1oRJ_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1oRJ() //  [R1]
         { info_tbl: [(c1oRJ,
                       label: block_c1oRJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oRJ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmrecip_entry() //  [R2, R3]
         { info_tbl: [(c1oRR,
                       label: GHC.Real.$dmrecip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oRR: // global
           _s1jaD::P64 = R3;
           _s1jaC::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1oRS; else goto c1oRT;
       c1oRT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1oRV; else goto c1oRU;
       c1oRV: // global
           HpAlloc = 24;
           goto c1oRS;
       c1oRS: // global
           R3 = _s1jaD::P64;
           R2 = _s1jaC::P64;
           R1 = GHC.Real.$dmrecip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oRU: // global
           I64[Hp - 16] = sat_s1jaF_info;
           P64[Hp] = _s1jaC::P64;
           R2 = _s1jaC::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s1jaD::P64;
           Sp = Sp - 24;
           call GHC.Real./_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.086862111 UTC

[section ""data" . GHC.Real.$dm/_closure" {
     GHC.Real.$dm/_closure:
         const GHC.Real.$dm/_info;
 },
 sat_s1jaK_entry() //  [R1]
         { info_tbl: [(c1oSh,
                       label: sat_s1jaK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oSh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oSi; else goto c1oSj;
       c1oSi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oSj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.recip_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dm/_entry() //  [R2, R3, R4]
         { info_tbl: [(c1oSm,
                       label: GHC.Real.$dm/_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oSm: // global
           _s1jaI::P64 = R4;
           _s1jaH::P64 = R3;
           _s1jaG::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1oSn; else goto c1oSo;
       c1oSo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1oSq; else goto c1oSp;
       c1oSq: // global
           HpAlloc = 32;
           goto c1oSn;
       c1oSn: // global
           R4 = _s1jaI::P64;
           R3 = _s1jaH::P64;
           R2 = _s1jaG::P64;
           R1 = GHC.Real.$dm/_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oSp: // global
           I64[Hp - 24] = sat_s1jaK_info;
           P64[Hp - 8] = _s1jaG::P64;
           P64[Hp] = _s1jaI::P64;
           I64[Sp - 24] = block_c1oSk_info;
           R2 = _s1jaG::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s1jaH::P64;
           Sp = Sp - 24;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oSk() //  [R1]
         { info_tbl: [(c1oSk,
                       label: block_c1oSk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oSk: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _c1oSd::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _c1oSd::P64;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.096200252 UTC

[section ""data" . GHC.Real.$dmdivMod_closure" {
     GHC.Real.$dmdivMod_closure:
         const GHC.Real.$dmdivMod_info;
         const 0;
 },
 $dNum_s1jaP_entry() //  [R1]
         { info_tbl: [(c1oSV,
                       label: $dNum_s1jaP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oSV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1oSW; else goto c1oSX;
       c1oSW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oSX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_s1jaQ_entry() //  [R1]
         { info_tbl: [(c1oT4,
                       label: ds_s1jaQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oT4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1oT8; else goto c1oT9;
       c1oT8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oT9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1oT2_info;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_pp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1oT2() //  [R1]
         { info_tbl: [(c1oT2,
                       label: block_c1oT2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oT2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1oTc; else goto c1oTb;
       c1oTc: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1oTb: // global
           _s1jaS::P64 = P64[R1 + 7];
           _s1jaT::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = _s1jaS::P64;
           P64[Hp] = _s1jaT::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jb2_entry() //  [R1]
         { info_tbl: [(c1oTm,
                       label: sat_s1jb2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oTm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oTn; else goto c1oTo;
       c1oTn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oTo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jb3_entry() //  [R1]
         { info_tbl: [(c1oTp,
                       label: sat_s1jb3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oTp: // global
           _s1jb3::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1oTq; else goto c1oTr;
       c1oTr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1oTt; else goto c1oTs;
       c1oTt: // global
           HpAlloc = 32;
           goto c1oTq;
       c1oTq: // global
           R1 = _s1jb3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oTs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jb3::P64;
           _s1jaN::P64 = P64[_s1jb3::P64 + 16];
           _s1jaP::P64 = P64[_s1jb3::P64 + 24];
           I64[Hp - 24] = sat_s1jb2_info;
           P64[Hp - 8] = _s1jaN::P64;
           P64[Hp] = _s1jaP::P64;
           R2 = _s1jaP::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jb1_entry() //  [R1]
         { info_tbl: [(c1oTy,
                       label: sat_s1jb1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oTy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oTz; else goto c1oTA;
       c1oTz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oTA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jbg_entry() //  [R1]
         { info_tbl: [(c1oTS,
                       label: sat_s1jbg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oTS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1oTT; else goto c1oTU;
       c1oTT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oTU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jbe_entry() //  [R1]
         { info_tbl: [(c1oU3,
                       label: sat_s1jbe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oU3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oU4; else goto c1oU5;
       c1oU4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oU5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jbf_entry() //  [R1]
         { info_tbl: [(c1oU7,
                       label: sat_s1jbf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oU7: // global
           _s1jbf::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1oU8; else goto c1oU9;
       c1oU9: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1oUb; else goto c1oUa;
       c1oUb: // global
           HpAlloc = 48;
           goto c1oU8;
       c1oU8: // global
           R1 = _s1jbf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oUa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jbf::P64;
           _s1jaP::P64 = P64[_s1jbf::P64 + 16];
           _s1jaQ::P64 = P64[_s1jbf::P64 + 24];
           I64[Hp - 40] = sat_s1jbe_info;
           P64[Hp - 24] = _s1jaP::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1jaQ::P64;
           R2 = _s1jaP::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmdivMod_entry() //  [R2, R3, R4]
         { info_tbl: [(c1oUc,
                       label: GHC.Real.$dmdivMod_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oUc: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1oUd; else goto c1oUe;
       c1oUd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmdivMod_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oUe: // global
           I64[Sp - 32] = block_c1oSN_info;
           _s1jaL::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1jaL::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oSN() //  [R1]
         { info_tbl: [(c1oSN,
                       label: block_c1oSN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oSN: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c1oUh; else goto c1oUg;
       c1oUh: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oUg: // global
           I64[Hp - 144] = $dNum_s1jaP_info;
           P64[Hp - 128] = R1;
           I64[Hp - 120] = ds_s1jaQ_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = P64[Sp + 16];
           _s1jaN::P64 = P64[Sp + 24];
           P64[Hp - 88] = _s1jaN::P64;
           I64[Hp - 80] = stg_sel_2_upd_info;
           _c1oSY::P64 = Hp - 120;
           P64[Hp - 64] = _c1oSY::P64;
           I64[Hp - 56] = sat_s1jb3_info;
           P64[Hp - 40] = _s1jaN::P64;
           _c1oSR::P64 = Hp - 144;
           P64[Hp - 32] = _c1oSR::P64;
           I64[Hp - 24] = sat_s1jb1_info;
           P64[Hp - 8] = _c1oSR::P64;
           _c1oTd::P64 = Hp - 80;
           P64[Hp] = _c1oTd::P64;
           I64[Sp - 24] = block_c1oTB_info;
           R2 = R1;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 24;
           P64[Sp] = _c1oTd::P64;
           P64[Sp + 8] = _c1oSY::P64;
           P64[Sp + 16] = _c1oSR::P64;
           Sp = Sp - 24;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oTB() //  [R1]
         { info_tbl: [(c1oTB,
                       label: block_c1oTB_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oTB: // global
           I64[Sp] = block_c1oTF_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oTF() //  [R1]
         { info_tbl: [(c1oTF,
                       label: block_c1oTF_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oTF: // global
           _c1oTu::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1oTJ_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _c1oTu::P64;
           Sp = Sp - 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1oTJ() //  [R1]
         { info_tbl: [(c1oTJ,
                       label: block_c1oTJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oTJ: // global
           _c1oSY::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1oUo; else goto c1oUv;
       c1oUo: // global
           I64[Sp + 32] = block_c1oUl_info;
           R1 = _c1oSY::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u1oUA; else goto c1oUp;
       u1oUA: // global
           call _c1oUl(R1) args: 0, res: 0, upd: 0;
       c1oUp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1oUv: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1oUy; else goto c1oUx;
       c1oUy: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oUx: // global
           I64[Hp - 88] = sat_s1jbg_info;
           P64[Hp - 72] = P64[Sp + 32];
           _c1oSR::P64 = P64[Sp + 24];
           P64[Hp - 64] = _c1oSR::P64;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = sat_s1jbf_info;
           P64[Hp - 32] = _c1oSR::P64;
           P64[Hp - 24] = _c1oSY::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1oUl() //  [R1]
         { info_tbl: [(c1oUl,
                       label: block_c1oUl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oUl: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.127857153 UTC

[section ""data" . GHC.Real.$dmmod_closure" {
     GHC.Real.$dmmod_closure:
         const GHC.Real.$dmmod_info;
 },
 GHC.Real.$dmmod_entry() //  [R2, R3, R4]
         { info_tbl: [(c1oVY,
                       label: GHC.Real.$dmmod_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oVY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oVZ; else goto c1oW0;
       c1oVZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmmod_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oW0: // global
           I64[Sp - 8] = block_c1oVW_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.divMod_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1oVW() //  [R1]
         { info_tbl: [(c1oVW,
                       label: block_c1oVW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oVW: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.133767121 UTC

[section ""data" . GHC.Real.$dmdiv_closure" {
     GHC.Real.$dmdiv_closure:
         const GHC.Real.$dmdiv_info;
 },
 GHC.Real.$dmdiv_entry() //  [R2, R3, R4]
         { info_tbl: [(c1oWi,
                       label: GHC.Real.$dmdiv_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oWi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oWj; else goto c1oWk;
       c1oWj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmdiv_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oWk: // global
           I64[Sp - 8] = block_c1oWg_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.divMod_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1oWg() //  [R1]
         { info_tbl: [(c1oWg,
                       label: block_c1oWg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oWg: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.138985508 UTC

[section ""data" . GHC.Real.$dmrem_closure" {
     GHC.Real.$dmrem_closure:
         const GHC.Real.$dmrem_info;
 },
 GHC.Real.$dmrem_entry() //  [R2, R3, R4]
         { info_tbl: [(c1oWC,
                       label: GHC.Real.$dmrem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oWC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oWD; else goto c1oWE;
       c1oWD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmrem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oWE: // global
           I64[Sp - 8] = block_c1oWA_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1oWA() //  [R1]
         { info_tbl: [(c1oWA,
                       label: block_c1oWA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oWA: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.144228139 UTC

[section ""data" . GHC.Real.$dmquot_closure" {
     GHC.Real.$dmquot_closure:
         const GHC.Real.$dmquot_info;
 },
 GHC.Real.$dmquot_entry() //  [R2, R3, R4]
         { info_tbl: [(c1oWW,
                       label: GHC.Real.$dmquot_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oWW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1oWX; else goto c1oWY;
       c1oWX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmquot_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oWY: // global
           I64[Sp - 8] = block_c1oWU_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1oWU() //  [R1]
         { info_tbl: [(c1oWU,
                       label: block_c1oWU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oWU: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.149639078 UTC

[section ""data" . GHC.Real.divZeroError_closure" {
     GHC.Real.divZeroError_closure:
         const GHC.Real.divZeroError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.divZeroError_entry() //  [R1]
         { info_tbl: [(c1oXg,
                       label: GHC.Real.divZeroError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oXg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1oXh; else goto c1oXi;
       c1oXh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oXi: // global
           (_c1oXd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1oXd::I64 == 0) goto c1oXf; else goto c1oXe;
       c1oXf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1oXe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1oXd::I64;
           R1 = GHC.Exception.divZeroException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.15422596 UTC

[section ""data" . GHC.Real.$fIntegralInt1_closure" {
     GHC.Real.$fIntegralInt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.156524366 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cmod_closure" {
     GHC.Real.$fIntegralInt_$cmod_closure:
         const GHC.Real.$fIntegralInt_$cmod_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c1oXy,
                       label: GHC.Real.$fIntegralInt_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oXy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1oXz; else goto c1oXA;
       c1oXz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oXA: // global
           I64[Sp - 16] = block_c1oXv_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1oY0; else goto c1oXw;
       u1oY0: // global
           call _c1oXv(R1) args: 0, res: 0, upd: 0;
       c1oXw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oXv() //  [R1]
         { info_tbl: [(c1oXv,
                       label: block_c1oXv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oXv: // global
           _s1jbJ::I64 = I64[R1 + 7];
           if (_s1jbJ::I64 != (-1)) goto u1oXY; else goto c1oXW;
       u1oXY: // global
           if (_s1jbJ::I64 != 0) goto c1oXR; else goto c1oXX;
       c1oXR: // global
           I64[Sp] = block_c1oXG_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jbJ::I64;
           if (R1 & 7 != 0) goto u1oXZ; else goto c1oXH;
       u1oXZ: // global
           call _c1oXG(R1) args: 0, res: 0, upd: 0;
       c1oXH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1oXX: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1oXW: // global
           R1 = GHC.Real.$fIntegralInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1oXG() //  [R1]
         { info_tbl: [(c1oXG,
                       label: block_c1oXG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oXG: // global
           _s1jbJ::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1oXL_info;
           R3 = _s1jbJ::I64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oXL() //  [R1]
         { info_tbl: [(c1oXL,
                       label: block_c1oXL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oXL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1oXV; else goto c1oXU;
       c1oXV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1oXU: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.16722126 UTC

[section ""data" . GHC.Real.$fIntegralInt_$crem_closure" {
     GHC.Real.$fIntegralInt_$crem_closure:
         const GHC.Real.$fIntegralInt_$crem_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$crem_entry() //  [R2, R3]
         { info_tbl: [(c1oYq,
                       label: GHC.Real.$fIntegralInt_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oYq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1oYr; else goto c1oYs;
       c1oYr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oYs: // global
           I64[Sp - 16] = block_c1oYn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1oYQ; else goto c1oYo;
       u1oYQ: // global
           call _c1oYn(R1) args: 0, res: 0, upd: 0;
       c1oYo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1oYn() //  [R1]
         { info_tbl: [(c1oYn,
                       label: block_c1oYn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oYn: // global
           _s1jbS::I64 = I64[R1 + 7];
           if (_s1jbS::I64 != (-1)) goto u1oYO; else goto c1oYM;
       u1oYO: // global
           if (_s1jbS::I64 != 0) goto c1oYI; else goto c1oYN;
       c1oYI: // global
           I64[Sp] = block_c1oYy_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jbS::I64;
           if (R1 & 7 != 0) goto u1oYP; else goto c1oYz;
       u1oYP: // global
           call _c1oYy(R1) args: 0, res: 0, upd: 0;
       c1oYz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1oYN: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1oYM: // global
           R1 = GHC.Real.$fIntegralInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1oYy() //  [R1]
         { info_tbl: [(c1oYy,
                       label: block_c1oYy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oYy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1oYL; else goto c1oYK;
       c1oYL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1oYK: // global
           _s1jbV::I64 = %MO_S_Rem_W64(I64[R1 + 7], I64[Sp + 8]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1jbV::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.175622984 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cquot_closure" {
     GHC.Real.$fIntegralInteger_$cquot_closure:
         const GHC.Real.$fIntegralInteger_$cquot_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c1oZf,
                       label: GHC.Real.$fIntegralInteger_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oZf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1oZg; else goto c1oZh;
       c1oZg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oZh: // global
           I64[Sp - 24] = block_c1oZa_info;
           _s1jbX::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jbW::P64 = R2;
           R2 = _s1jbX::P64;
           P64[Sp - 16] = _s1jbW::P64;
           P64[Sp - 8] = _s1jbX::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oZa() //  [R1]
         { info_tbl: [(c1oZa,
                       label: block_c1oZa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oZa: // global
           if (R1 == 1) goto c1oZe; else goto c1oZd;
       c1oZe: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1oZd: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.182368222 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$crem_closure" {
     GHC.Real.$fIntegralInteger_$crem_closure:
         const GHC.Real.$fIntegralInteger_$crem_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$crem_entry() //  [R2, R3]
         { info_tbl: [(c1oZF,
                       label: GHC.Real.$fIntegralInteger_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oZF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1oZG; else goto c1oZH;
       c1oZG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1oZH: // global
           I64[Sp - 24] = block_c1oZA_info;
           _s1jc0::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jbZ::P64 = R2;
           R2 = _s1jc0::P64;
           P64[Sp - 16] = _s1jbZ::P64;
           P64[Sp - 8] = _s1jc0::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1oZA() //  [R1]
         { info_tbl: [(c1oZA,
                       label: block_c1oZA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oZA: // global
           if (R1 == 1) goto c1oZE; else goto c1oZD;
       c1oZE: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1oZD: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.188067177 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cdiv_closure" {
     GHC.Real.$fIntegralInteger_$cdiv_closure:
         const GHC.Real.$fIntegralInteger_$cdiv_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c1p05,
                       label: GHC.Real.$fIntegralInteger_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p05: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1p06; else goto c1p07;
       c1p06: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1p07: // global
           I64[Sp - 24] = block_c1p00_info;
           _s1jc3::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jc2::P64 = R2;
           R2 = _s1jc3::P64;
           P64[Sp - 16] = _s1jc2::P64;
           P64[Sp - 8] = _s1jc3::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1p00() //  [R1]
         { info_tbl: [(c1p00,
                       label: block_c1p00_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p00: // global
           if (R1 == 1) goto c1p04; else goto c1p03;
       c1p04: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1p03: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.193835402 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cmod_closure" {
     GHC.Real.$fIntegralInteger_$cmod_closure:
         const GHC.Real.$fIntegralInteger_$cmod_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c1p0v,
                       label: GHC.Real.$fIntegralInteger_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p0v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1p0w; else goto c1p0x;
       c1p0w: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1p0x: // global
           I64[Sp - 24] = block_c1p0q_info;
           _s1jc6::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jc5::P64 = R2;
           R2 = _s1jc6::P64;
           P64[Sp - 16] = _s1jc5::P64;
           P64[Sp - 8] = _s1jc6::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1p0q() //  [R1]
         { info_tbl: [(c1p0q,
                       label: block_c1p0q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p0q: // global
           if (R1 == 1) goto c1p0u; else goto c1p0t;
       c1p0u: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1p0t: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.199657262 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cquotRem_closure" {
     GHC.Real.$fIntegralInteger_$cquotRem_closure:
         const GHC.Real.$fIntegralInteger_$cquotRem_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c1p0V,
                       label: GHC.Real.$fIntegralInteger_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p0V: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1p0W; else goto c1p0X;
       c1p0W: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1p0X: // global
           I64[Sp - 24] = block_c1p0Q_info;
           _s1jc9::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jc8::P64 = R2;
           R2 = _s1jc9::P64;
           P64[Sp - 16] = _s1jc8::P64;
           P64[Sp - 8] = _s1jc9::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1p0Q() //  [R1]
         { info_tbl: [(c1p0Q,
                       label: block_c1p0Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p0Q: // global
           if (R1 == 1) goto c1p0U; else goto c1p0T;
       c1p0U: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1p0T: // global
           _s1jc9::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1p10_info;
           R3 = _s1jc9::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1p10() //  [R1, R2]
         { info_tbl: [(c1p10,
                       label: block_c1p10_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p10: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1p16; else goto c1p15;
       c1p16: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1p15: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.207555339 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cdivMod_closure" {
     GHC.Real.$fIntegralInteger_$cdivMod_closure:
         const GHC.Real.$fIntegralInteger_$cdivMod_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c1p1v,
                       label: GHC.Real.$fIntegralInteger_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p1v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1p1w; else goto c1p1x;
       c1p1w: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1p1x: // global
           I64[Sp - 24] = block_c1p1q_info;
           _s1jcf::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jce::P64 = R2;
           R2 = _s1jcf::P64;
           P64[Sp - 16] = _s1jce::P64;
           P64[Sp - 8] = _s1jcf::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1p1q() //  [R1]
         { info_tbl: [(c1p1q,
                       label: block_c1p1q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p1q: // global
           if (R1 == 1) goto c1p1u; else goto c1p1t;
       c1p1u: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1p1t: // global
           _s1jcf::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1p1A_info;
           R3 = _s1jcf::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1p1A() //  [R1, R2]
         { info_tbl: [(c1p1A,
                       label: block_c1p1A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p1A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1p1G; else goto c1p1F;
       c1p1G: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1p1F: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.215566668 UTC

[section ""data" . GHC.Real.$fIntegralInteger_closure" {
     GHC.Real.$fIntegralInteger_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Real.$fRealInteger_closure+1;
         const GHC.Enum.$fEnumInteger_closure;
         const GHC.Real.$fIntegralInteger_$cquot_closure+2;
         const GHC.Real.$fIntegralInteger_$crem_closure+2;
         const GHC.Real.$fIntegralInteger_$cdiv_closure+2;
         const GHC.Real.$fIntegralInteger_$cmod_closure+2;
         const GHC.Real.$fIntegralInteger_$cquotRem_closure+2;
         const GHC.Real.$fIntegralInteger_$cdivMod_closure+2;
         const GHC.Real.$fIntegralInteger_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.218082976 UTC

[section ""data" . GHC.Real.$fIntegralWord_$cquot_closure" {
     GHC.Real.$fIntegralWord_$cquot_closure:
         const GHC.Real.$fIntegralWord_$cquot_info;
         const 0;
 },
 GHC.Real.$fIntegralWord_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c1p24,
                       label: GHC.Real.$fIntegralWord_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p24: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1p28; else goto c1p29;
       c1p28: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1p29: // global
           I64[Sp - 16] = block_c1p21_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1p2s; else goto c1p22;
       u1p2s: // global
           call _c1p21(R1) args: 0, res: 0, upd: 0;
       c1p22: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1p21() //  [R1]
         { info_tbl: [(c1p21,
                       label: block_c1p21_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p21: // global
           I64[Sp] = block_c1p27_info;
           _s1jcn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jcn::I64;
           if (R1 & 7 != 0) goto u1p2r; else goto c1p2b;
       u1p2r: // global
           call _c1p27(R1) args: 0, res: 0, upd: 0;
       c1p2b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1p27() //  [R1]
         { info_tbl: [(c1p27,
                       label: block_c1p27_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p27: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1p2h; else goto c1p2g;
       c1p2h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1p2g: // global
           _s1jcq::I64 = I64[R1 + 7];
           if (_s1jcq::I64 != 0) goto c1p2p; else goto c1p2q;
       c1p2p: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] / _s1jcq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1p2q: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.227268448 UTC

[section ""data" . GHC.Real.$fIntegralWord_$crem_closure" {
     GHC.Real.$fIntegralWord_$crem_closure:
         const GHC.Real.$fIntegralWord_$crem_info;
         const 0;
 },
 GHC.Real.$fIntegralWord_$crem_entry() //  [R2, R3]
         { info_tbl: [(c1p2P,
                       label: GHC.Real.$fIntegralWord_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p2P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1p2T; else goto c1p2U;
       c1p2T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1p2U: // global
           I64[Sp - 16] = block_c1p2M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1p3d; else goto c1p2N;
       u1p3d: // global
           call _c1p2M(R1) args: 0, res: 0, upd: 0;
       c1p2N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1p2M() //  [R1]
         { info_tbl: [(c1p2M,
                       label: block_c1p2M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p2M: // global
           I64[Sp] = block_c1p2S_info;
           _s1jcv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jcv::I64;
           if (R1 & 7 != 0) goto u1p3c; else goto c1p2W;
       u1p3c: // global
           call _c1p2S(R1) args: 0, res: 0, upd: 0;
       c1p2W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1p2S() //  [R1]
         { info_tbl: [(c1p2S,
                       label: block_c1p2S_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p2S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1p32; else goto c1p31;
       c1p32: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1p31: // global
           _s1jcy::I64 = I64[R1 + 7];
           if (_s1jcy::I64 != 0) goto c1p3a; else goto c1p3b;
       c1p3a: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] % _s1jcy::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1p3b: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.235447687 UTC

[section ""data" . GHC.Real.$fIntegralWord_$cquotRem_closure" {
     GHC.Real.$fIntegralWord_$cquotRem_closure:
         const GHC.Real.$fIntegralWord_$cquotRem_info;
         const 0;
 },
 GHC.Real.$fIntegralWord_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c1p3A,
                       label: GHC.Real.$fIntegralWord_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p3A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1p3E; else goto c1p3F;
       c1p3E: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1p3F: // global
           I64[Sp - 16] = block_c1p3x_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1p3X; else goto c1p3y;
       u1p3X: // global
           call _c1p3x(R1) args: 0, res: 0, upd: 0;
       c1p3y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1p3x() //  [R1]
         { info_tbl: [(c1p3x,
                       label: block_c1p3x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p3x: // global
           I64[Sp] = block_c1p3D_info;
           _s1jcD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jcD::I64;
           if (R1 & 7 != 0) goto u1p3W; else goto c1p3H;
       u1p3W: // global
           call _c1p3D(R1) args: 0, res: 0, upd: 0;
       c1p3H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1p3D() //  [R1]
         { info_tbl: [(c1p3D,
                       label: block_c1p3D_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p3D: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1p3N; else goto c1p3M;
       c1p3N: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1p3M: // global
           _s1jcG::I64 = I64[R1 + 7];
           if (_s1jcG::I64 != 0) goto c1p3U; else goto c1p3V;
       c1p3U: // global
           (_s1jcI::I64, _s1jcJ::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s1jcG::I64);
           I64[Hp - 48] = GHC.Types.W#_con_info;
           I64[Hp - 40] = _s1jcJ::I64;
           I64[Hp - 32] = GHC.Types.W#_con_info;
           I64[Hp - 24] = _s1jcI::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1p3V: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.244768081 UTC

[section ""data" . GHC.Real.$fIntegralWord_$cdivMod_closure" {
     GHC.Real.$fIntegralWord_$cdivMod_closure:
         const GHC.Real.$fIntegralWord_$cdivMod_info;
         const 0;
 },
 sat_s1jcW_entry() //  [R1]
         { info_tbl: [(c1p4A,
                       label: sat_s1jcW_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p4A: // global
           _s1jcW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1p4D; else goto c1p4E;
       c1p4E: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1p4G; else goto c1p4F;
       c1p4G: // global
           HpAlloc = 16;
           goto c1p4D;
       c1p4D: // global
           R1 = _s1jcW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1p4F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jcW::P64;
           _s1jcV::I64 = I64[_s1jcW::P64 + 16] % I64[_s1jcW::P64 + 24];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1jcV::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jcU_entry() //  [R1]
         { info_tbl: [(c1p4N,
                       label: sat_s1jcU_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p4N: // global
           _s1jcU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1p4Q; else goto c1p4R;
       c1p4R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1p4T; else goto c1p4S;
       c1p4T: // global
           HpAlloc = 16;
           goto c1p4Q;
       c1p4Q: // global
           R1 = _s1jcU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1p4S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jcU::P64;
           _s1jcT::I64 = I64[_s1jcU::P64 + 16] / I64[_s1jcU::P64 + 24];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1jcT::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fIntegralWord_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c1p4U,
                       label: GHC.Real.$fIntegralWord_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p4U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1p4V; else goto c1p4W;
       c1p4V: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1p4W: // global
           I64[Sp - 16] = block_c1p4i_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1p56; else goto c1p4j;
       u1p56: // global
           call _c1p4i(R1) args: 0, res: 0, upd: 0;
       c1p4j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1p4i() //  [R1]
         { info_tbl: [(c1p4i,
                       label: block_c1p4i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p4i: // global
           I64[Sp] = block_c1p4n_info;
           _s1jcP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jcP::I64;
           if (R1 & 7 != 0) goto u1p55; else goto c1p4o;
       u1p55: // global
           call _c1p4n(R1) args: 0, res: 0, upd: 0;
       c1p4o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1p4n() //  [R1]
         { info_tbl: [(c1p4n,
                       label: block_c1p4n_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p4n: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1p50; else goto c1p4Z;
       c1p50: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1p4Z: // global
           _s1jcS::I64 = I64[R1 + 7];
           if (_s1jcS::I64 != 0) goto c1p53; else goto c1p54;
       c1p53: // global
           I64[Hp - 80] = sat_s1jcW_info;
           _s1jcP::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s1jcP::I64;
           I64[Hp - 56] = _s1jcS::I64;
           I64[Hp - 48] = sat_s1jcU_info;
           I64[Hp - 32] = _s1jcP::I64;
           I64[Hp - 24] = _s1jcS::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1p54: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.257045998 UTC

[section ""data" . GHC.Real.ratioZeroDenominatorError_closure" {
     GHC.Real.ratioZeroDenominatorError_closure:
         const GHC.Real.ratioZeroDenominatorError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.ratioZeroDenominatorError_entry() //  [R1]
         { info_tbl: [(c1p5D,
                       label: GHC.Real.ratioZeroDenominatorError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p5D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1p5E; else goto c1p5F;
       c1p5E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1p5F: // global
           (_c1p5A::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1p5A::I64 == 0) goto c1p5C; else goto c1p5B;
       c1p5C: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1p5B: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1p5A::I64;
           R1 = GHC.Exception.ratioZeroDenomException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.261799757 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$crecip_closure" {
     GHC.Real.$fFractionalRatio_$s$crecip_closure:
         const GHC.Real.$fFractionalRatio_$s$crecip_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$crecip_entry() //  [R2]
         { info_tbl: [(c1p5U,
                       label: GHC.Real.$fFractionalRatio_$s$crecip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p5U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1p5V; else goto c1p5W;
       c1p5V: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$crecip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1p5W: // global
           I64[Sp - 8] = block_c1p5R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1p6C; else goto c1p5S;
       u1p6C: // global
           call _c1p5R(R1) args: 0, res: 0, upd: 0;
       c1p5S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1p5R() //  [R1]
         { info_tbl: [(c1p5R,
                       label: block_c1p5R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p5R: // global
           I64[Sp - 16] = block_c1p5Z_info;
           R3 = GHC.Real.even1_closure;
           _s1jcZ::P64 = P64[R1 + 7];
           R2 = _s1jcZ::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _s1jcZ::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1p5Z() //  [R1]
         { info_tbl: [(c1p5Z,
                       label: block_c1p5Z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p5Z: // global
           if (R1 == 1) goto c1p6B; else goto c1p67;
       c1p6B: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1p67: // global
           I64[Sp] = block_c1p64_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1p64() //  [R1]
         { info_tbl: [(c1p64,
                       label: block_c1p64_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p64: // global
           _s1jd0::P64 = P64[Sp + 8];
           if (R1 == 1) goto c1p6t; else goto c1p6d;
       c1p6t: // global
           I64[Sp + 8] = block_c1p6j_info;
           R2 = _s1jd0::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       c1p6d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1p6g; else goto c1p6f;
       c1p6g: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1p6f: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = _s1jd0::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1p6j() //  [R1]
         { info_tbl: [(c1p6j,
                       label: block_c1p6j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p6j: // global
           I64[Sp] = block_c1p6n_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1p6n() //  [R1]
         { info_tbl: [(c1p6n,
                       label: block_c1p6n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p6n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1p6x; else goto c1p6w;
       c1p6x: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1p6w: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.275063758 UTC

[section ""data" . GHC.Real.overflowError_closure" {
     GHC.Real.overflowError_closure:
         const GHC.Real.overflowError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.overflowError_entry() //  [R1]
         { info_tbl: [(c1p79,
                       label: GHC.Real.overflowError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p79: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1p7a; else goto c1p7b;
       c1p7a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1p7b: // global
           (_c1p76::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1p76::I64 == 0) goto c1p78; else goto c1p77;
       c1p78: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1p77: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1p76::I64;
           R1 = GHC.Exception.overflowException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.278987459 UTC

[section ""data" . lvl_r1j38_closure" {
     lvl_r1j38_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Real.$fIntegralInt1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.282163519 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cdivMod_closure" {
     GHC.Real.$fIntegralInt_$cdivMod_closure:
         const GHC.Real.$fIntegralInt_$cdivMod_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c1p7r,
                       label: GHC.Real.$fIntegralInt_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p7r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1p7v; else goto c1p7w;
       c1p7v: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1p7w: // global
           I64[Sp - 16] = block_c1p7o_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1p9T; else goto c1p7p;
       u1p9T: // global
           call _c1p7o(R1) args: 0, res: 0, upd: 0;
       c1p7p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1p7o() //  [R1]
         { info_tbl: [(c1p7o,
                       label: block_c1p7o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p7o: // global
           I64[Sp] = block_c1p7u_info;
           _s1jd9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jd9::I64;
           if (R1 & 7 != 0) goto u1p9S; else goto c1p7y;
       u1p9S: // global
           call _c1p7u(R1) args: 0, res: 0, upd: 0;
       c1p7y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1p7u() //  [R1]
         { info_tbl: [(c1p7u,
                       label: block_c1p7u_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p7u: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1p7E; else goto c1p7D;
       c1p7E: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1p7D: // global
           _s1jd9::I64 = I64[Sp + 8];
           _s1jdc::I64 = I64[R1 + 7];
           if (_s1jdc::I64 != (-1)) goto u1p9R; else goto c1p9P;
       u1p9R: // global
           if (_s1jdc::I64 != 0) goto c1p9j; else goto c1p9Q;
       c1p9j: // global
           if (%MO_S_Le_W64(_s1jd9::I64, 0)) goto c1p8k; else goto c1p9h;
       c1p8k: // global
           if (%MO_S_Ge_W64(_s1jd9::I64, 0)) goto c1p7R; else goto c1p8i;
       c1p7R: // global
           (_s1jdg::I64, _s1jdh::I64) = call MO_S_QuotRem W64(_s1jd9::I64, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdh::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdg::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1p8i: // global
           if (%MO_S_Le_W64(_s1jdc::I64, 0)) goto c1p80; else goto c1p8h;
       c1p80: // global
           (_s1jdm::I64, _s1jdn::I64) = call MO_S_QuotRem W64(_s1jd9::I64, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdn::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdm::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1p8h: // global
           (_s1jds::I64, _s1jdt::I64) = call MO_S_QuotRem W64(_s1jd9::I64 + 1, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdt::I64 + _s1jdc::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jds::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1p9h: // global
           if (%MO_S_Ge_W64(_s1jdc::I64, 0)) goto c1p8Z; else goto c1p9g;
       c1p8Z: // global
           if (%MO_S_Ge_W64(_s1jd9::I64, 0)) goto c1p8w; else goto c1p8X;
       c1p8w: // global
           (_s1jdC::I64, _s1jdD::I64) = call MO_S_QuotRem W64(_s1jd9::I64, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdD::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdC::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1p8X: // global
           if (%MO_S_Le_W64(_s1jdc::I64, 0)) goto c1p8F; else goto c1p8W;
       c1p8F: // global
           (_s1jdI::I64, _s1jdJ::I64) = call MO_S_QuotRem W64(_s1jd9::I64, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdJ::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdI::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1p8W: // global
           (_s1jdO::I64, _s1jdP::I64) = call MO_S_QuotRem W64(_s1jd9::I64 + 1, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdP::I64 + _s1jdc::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdO::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1p9g: // global
           (_s1jdX::I64, _s1jdY::I64) = call MO_S_QuotRem W64(_s1jd9::I64 - 1, _s1jdc::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jdY::I64 + _s1jdc::I64 + 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jdX::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1p9Q: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1p9P: // global
           if (_s1jd9::I64 == (-9223372036854775808)) goto c1p9O; else goto c1p9N;
       c1p9O: // global
           Hp = Hp - 56;
           R1 = lvl_r1j38_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1p9N: // global
           if (%MO_S_Le_W64(_s1jd9::I64, 0)) goto c1p9u; else goto c1p9L;
       c1p9u: // global
           (_s1je7::I64, _s1je8::I64) = call MO_S_QuotRem W64(_s1jd9::I64, (-1));
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1je8::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1je7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1p9L: // global
           (_s1jed::I64, _s1jee::I64) = call MO_S_QuotRem W64(_s1jd9::I64 - 1, (-1));
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jee::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jed::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.296560041 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cquotRem_closure" {
     GHC.Real.$fIntegralInt_$cquotRem_closure:
         const GHC.Real.$fIntegralInt_$cquotRem_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c1paW,
                       label: GHC.Real.$fIntegralInt_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1paW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pb0; else goto c1pb1;
       c1pb0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pb1: // global
           I64[Sp - 16] = block_c1paT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1pbu; else goto c1paU;
       u1pbu: // global
           call _c1paT(R1) args: 0, res: 0, upd: 0;
       c1paU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1paT() //  [R1]
         { info_tbl: [(c1paT,
                       label: block_c1paT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1paT: // global
           I64[Sp] = block_c1paZ_info;
           _s1jeo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jeo::I64;
           if (R1 & 7 != 0) goto u1pbt; else goto c1pb3;
       u1pbt: // global
           call _c1paZ(R1) args: 0, res: 0, upd: 0;
       c1pb3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1paZ() //  [R1]
         { info_tbl: [(c1paZ,
                       label: block_c1paZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1paZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1pb9; else goto c1pb8;
       c1pb9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pb8: // global
           _s1jeo::I64 = I64[Sp + 8];
           _s1jer::I64 = I64[R1 + 7];
           if (_s1jer::I64 != (-1)) goto u1pbs; else goto c1pbq;
       u1pbs: // global
           if (_s1jer::I64 != 0) goto c1pbg; else goto c1pbr;
       c1pbg: // global
           (_s1jet::I64, _s1jeu::I64) = call MO_S_QuotRem W64(_s1jeo::I64, _s1jer::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jeu::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jet::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1pbr: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1pbq: // global
           if (_s1jeo::I64 == (-9223372036854775808)) goto c1pbp; else goto c1pbo;
       c1pbp: // global
           Hp = Hp - 56;
           R1 = lvl_r1j38_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1pbo: // global
           (_s1jez::I64, _s1jeA::I64) = call MO_S_QuotRem W64(_s1jeo::I64, (-1));
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1jeA::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1jez::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.306849178 UTC

[section ""data" . GHC.Real.$w$cdiv_closure" {
     GHC.Real.$w$cdiv_closure:
         const GHC.Real.$w$cdiv_info;
         const 0;
 },
 GHC.Real.$w$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c1pc0,
                       label: GHC.Real.$w$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pc0: // global
           if (R3 == (-1)) goto c1pbY; else goto u1pc9;
       c1pbY: // global
           if (R2 == (-9223372036854775808)) goto c1pc8; else goto c1pc7;
       c1pc8: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1pc7: // global
           R3 = (-1);
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
       u1pc9: // global
           if (R3 == 0) goto c1pbZ; else goto c1pbX;
       c1pbZ: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1pbX: // global
           R3 = R3;
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.311241501 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cdiv_closure" {
     GHC.Real.$fIntegralInt_$cdiv_closure:
         const GHC.Real.$fIntegralInt_$cdiv_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c1pcm,
                       label: GHC.Real.$fIntegralInt_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pcm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pcz; else goto c1pcA;
       c1pcz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pcA: // global
           I64[Sp - 16] = block_c1pcj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1pcH; else goto c1pck;
       u1pcH: // global
           call _c1pcj(R1) args: 0, res: 0, upd: 0;
       c1pck: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pcj() //  [R1]
         { info_tbl: [(c1pcj,
                       label: block_c1pcj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pcj: // global
           I64[Sp] = block_c1pcp_info;
           _s1jeN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jeN::I64;
           if (R1 & 7 != 0) goto u1pcG; else goto c1pcq;
       u1pcG: // global
           call _c1pcp(R1) args: 0, res: 0, upd: 0;
       c1pcq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pcp() //  [R1]
         { info_tbl: [(c1pcp,
                       label: block_c1pcp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pcp: // global
           _s1jeN::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1pcu_info;
           R3 = I64[R1 + 7];
           R2 = _s1jeN::I64;
           Sp = Sp + 8;
           call GHC.Real.$w$cdiv_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pcu() //  [R1]
         { info_tbl: [(c1pcu,
                       label: block_c1pcu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pcu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1pcF; else goto c1pcE;
       c1pcF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1pcE: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.320872051 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cquot_closure" {
     GHC.Real.$fIntegralInt_$cquot_closure:
         const GHC.Real.$fIntegralInt_$cquot_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c1pd6,
                       label: GHC.Real.$fIntegralInt_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pd6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pda; else goto c1pdb;
       c1pda: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pdb: // global
           I64[Sp - 16] = block_c1pd3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1pdG; else goto c1pd4;
       u1pdG: // global
           call _c1pd3(R1) args: 0, res: 0, upd: 0;
       c1pd4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pd3() //  [R1]
         { info_tbl: [(c1pd3,
                       label: block_c1pd3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pd3: // global
           I64[Sp] = block_c1pd9_info;
           _s1jeU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jeU::I64;
           if (R1 & 7 != 0) goto u1pdF; else goto c1pdd;
       u1pdF: // global
           call _c1pd9(R1) args: 0, res: 0, upd: 0;
       c1pdd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pd9() //  [R1]
         { info_tbl: [(c1pd9,
                       label: block_c1pd9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pd9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1pdj; else goto c1pdi;
       c1pdj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pdi: // global
           _s1jeU::I64 = I64[Sp + 8];
           _s1jeX::I64 = I64[R1 + 7];
           if (_s1jeX::I64 != (-1)) goto u1pdE; else goto c1pdC;
       u1pdE: // global
           if (_s1jeX::I64 != 0) goto c1pdr; else goto c1pdD;
       c1pdr: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s1jeU::I64, _s1jeX::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1pdD: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1pdC: // global
           if (_s1jeU::I64 == (-9223372036854775808)) goto c1pdB; else goto c1pdA;
       c1pdB: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1pdA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s1jeU::I64, (-1));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.330162158 UTC

[section ""data" . GHC.Real.$fIntegralInt_closure" {
     GHC.Real.$fIntegralInt_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Real.$fRealInt_closure+1;
         const GHC.Enum.$fEnumInt_closure;
         const GHC.Real.$fIntegralInt_$cquot_closure+2;
         const GHC.Real.$fIntegralInt_$crem_closure+2;
         const GHC.Real.$fIntegralInt_$cdiv_closure+2;
         const GHC.Real.$fIntegralInt_$cmod_closure+2;
         const GHC.Real.$fIntegralInt_$cquotRem_closure+2;
         const GHC.Real.$fIntegralInt_$cdivMod_closure+2;
         const GHC.Real.$fIntegralInt_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.332158637 UTC

[section ""data" . lvl1_r1j39_closure" {
     lvl1_r1j39_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.334659023 UTC

[section ""data" . lvl2_r1j3a_closure" {
     lvl2_r1j3a_closure:
         const lvl2_r1j3a_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r1j3a_entry() //  [R1]
         { info_tbl: [(c1pen,
                       label: lvl2_r1j3a_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pen: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1peo; else goto c1pep;
       c1peo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pep: // global
           (_c1pek::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1pek::I64 == 0) goto c1pem; else goto c1pel;
       c1pem: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1pel: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1pek::I64;
           R3 = 0;
           R2 = lvl1_r1j39_closure+1;
           Sp = Sp - 16;
           call GHC.Real.$wgcd'_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""data" . GHC.Real.$wgcd'_closure" {
     GHC.Real.$wgcd'_closure:
         const GHC.Real.$wgcd'_info;
         const 0;
 },
 GHC.Real.$wgcd'_entry() //  [R2, R3]
         { info_tbl: [(c1peu,
                       label: GHC.Real.$wgcd'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1peu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pev; else goto u1peB;
       c1pev: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wgcd'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1peB: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1pe4() args: 0, res: 0, upd: 0;
     }
 },
 _c1pe4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pe4: // global
           _s1jf5::I64 = I64[Sp + 8];
           if (_s1jf5::I64 != (-1)) goto u1peA; else goto c1pes;
       u1peA: // global
           _s1jf3::P64 = P64[Sp];
           if (_s1jf5::I64 != 0) goto c1per; else goto c1pet;
       c1per: // global
           I64[Sp] = block_c1pe9_info;
           R1 = _s1jf3::P64;
           I64[Sp + 8] = _s1jf5::I64;
           if (R1 & 7 != 0) goto u1peD; else goto c1pea;
       u1peD: // global
           call _c1pe9(R1) args: 0, res: 0, upd: 0;
       c1pea: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1pet: // global
           R1 = _s1jf3::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1pes: // global
           R1 = lvl2_r1j3a_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1pe9() //  [R1]
         { info_tbl: [(c1pe9,
                       label: block_c1pe9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pe9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1pez; else goto c1pey;
       c1pez: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pey: // global
           _s1jf5::I64 = I64[Sp + 8];
           _s1jf8::I64 = %MO_S_Rem_W64(I64[R1 + 7], _s1jf5::I64);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1jf5::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s1jf8::I64;
           call _c1pe4() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.345490292 UTC

[section ""data" . GHC.Real.$fEnumRatio_gcd'_closure" {
     GHC.Real.$fEnumRatio_gcd'_closure:
         const GHC.Real.$fEnumRatio_gcd'_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_gcd'_entry() //  [R2, R3]
         { info_tbl: [(c1pfb,
                       label: GHC.Real.$fEnumRatio_gcd'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pfb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1pfc; else goto u1pfp;
       c1pfc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_gcd'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1pfp: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1pf3() args: 0, res: 0, upd: 0;
     }
 },
 _c1pf3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pf3: // global
           I64[Sp - 8] = block_c1pf6_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pf6() //  [R1]
         { info_tbl: [(c1pf6,
                       label: block_c1pf6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pf6: // global
           _s1jfa::P64 = P64[Sp + 8];
           if (R1 == 1) goto c1pfa; else goto c1pf9;
       c1pfa: // global
           R1 = _s1jfa::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1pf9: // global
           I64[Sp + 8] = block_c1pfg_info;
           R3 = P64[Sp + 16];
           R2 = _s1jfa::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pfg() //  [R1]
         { info_tbl: [(c1pfg,
                       label: block_c1pfg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pfg: // global
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call _c1pf3() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.356044589 UTC

[section ""data" . GHC.Real.gcd_closure" {
     GHC.Real.gcd_closure:
         const GHC.Real.gcd_info;
         const 0;
 },
 lvl8_s1jfi_entry() //  [R1]
         { info_tbl: [(c1pgl,
                       label: lvl8_s1jfi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pgl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pgm; else goto c1pgn;
       c1pgm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pgn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1pgj_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pgj() //  [R1]
         { info_tbl: [(c1pgj,
                       label: block_c1pgj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pgj: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dNum_s1jfm_entry() //  [R1]
         { info_tbl: [(c1pgt,
                       label: $dNum_s1jfm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pgt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pgu; else goto c1pgv;
       c1pgu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pgv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jft_entry() //  [R1]
         { info_tbl: [(c1pgy,
                       label: sat_s1jft_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pgy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pgz; else goto c1pgA;
       c1pgz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pgA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jfs_entry() //  [R1]
         { info_tbl: [(c1pgD,
                       label: sat_s1jfs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pgD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pgE; else goto c1pgF;
       c1pgE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pgF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jfr_entry() //  [R1]
         { info_tbl: [(c1pgJ,
                       label: sat_s1jfr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pgJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1pgK; else goto c1pgL;
       c1pgK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pgL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.rem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.gcd_entry() //  [R2, R3, R4]
         { info_tbl: [(c1pgM,
                       label: GHC.Real.gcd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pgM: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1pgN; else goto c1pgO;
       c1pgN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.gcd_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pgO: // global
           I64[Sp - 32] = block_c1pfN_info;
           _s1jfe::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1jfe::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pfN() //  [R1]
         { info_tbl: [(c1pfN,
                       label: block_c1pfN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pfN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pgR; else goto c1pgQ;
       c1pgR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pgQ: // global
           I64[Hp - 16] = lvl8_s1jfi_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c1pfT_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pfT() //  [R1]
         { info_tbl: [(c1pfT,
                       label: block_c1pfT_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pfT: // global
           I64[Sp] = block_c1pfX_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pfX() //  [R1]
         { info_tbl: [(c1pfX,
                       label: block_c1pfX_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pfX: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1pgV; else goto c1pgU;
       c1pgV: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pgU: // global
           I64[Hp - 80] = $dNum_s1jfm_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s1jft_info;
           P64[Hp - 40] = P64[Sp + 40];
           _c1pg1::P64 = Hp - 80;
           P64[Hp - 32] = _c1pg1::P64;
           I64[Hp - 24] = sat_s1jfs_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _c1pg1::P64;
           P64[Sp + 8] = Hp - 56;
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _c1pga() args: 0, res: 0, upd: 0;
     }
 },
 _c1pga() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pga: // global
           I64[Sp - 8] = block_c1pgc_info;
           R2 = P64[Sp + 32];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp];
           P64[Sp - 16] = P64[Sp + 8];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1pgc() //  [R1]
         { info_tbl: [(c1pgc,
                       label: block_c1pgc_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pgc: // global
           _s1jfo::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c1pgY; else goto c1ph5;
       c1pgY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1ph1; else goto c1ph0;
       c1ph1: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ph0: // global
           I64[Hp - 32] = sat_s1jfr_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _s1jfo::P64;
           _s1jfp::P64 = P64[Sp + 8];
           P64[Hp] = _s1jfp::P64;
           _s1jfo::P64 = _s1jfp::P64;
           P64[Sp + 32] = _s1jfo::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _c1pga() args: 0, res: 0, upd: 0;
       c1ph5: // global
           R1 = _s1jfo::P64;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.380243405 UTC

[section ""data" . GHC.Real.$w$sreduce_closure" {
     GHC.Real.$w$sreduce_closure:
         const GHC.Real.$w$sreduce_info;
         const 0;
 },
 section ""relreadonly" . u1piZ_srtd" {
     u1piZ_srtd:
         const S1jKw_srt+160;
         const 33;
         const 5905711105;
 },
 GHC.Real.$w$sreduce_entry() //  [R2, R3]
         { info_tbl: [(c1pig,
                       label: GHC.Real.$w$sreduce_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pig: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pih; else goto c1pii;
       c1pih: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$sreduce_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pii: // global
           I64[Sp - 24] = block_c1pib_info;
           _s1jfv::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jfu::P64 = R2;
           R2 = _s1jfv::P64;
           P64[Sp - 16] = _s1jfu::P64;
           P64[Sp - 8] = _s1jfv::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pib() //  [R1]
         { info_tbl: [(c1pib,
                       label: block_c1pib_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pib: // global
           if (R1 == 1) goto c1pif; else goto c1pie;
       c1pif: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1pie: // global
           I64[Sp] = block_c1pil_info;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pil() //  [R1]
         { info_tbl: [(c1pil,
                       label: block_c1pil_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pil: // global
           I64[Sp - 8] = block_c1pip_info;
           R2 = P64[Sp + 8];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pip() //  [R1]
         { info_tbl: [(c1pip,
                       label: block_c1pip_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pip: // global
           _s1jfz::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1pit_info;
           R3 = _s1jfz::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$fEnumRatio_gcd'_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pit() //  [R1]
         { info_tbl: [(c1pit,
                       label: block_c1pit_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pit: // global
           I64[Sp - 8] = block_c1piA_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1piA() //  [R1]
         { info_tbl: [(c1piA,
                       label: block_c1piA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1piA: // global
           if (R1 == 1) goto c1piV; else goto c1piM;
       c1piV: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1piM: // global
           I64[Sp] = block_c1piF_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1piF() //  [R1]
         { info_tbl: [(c1piF,
                       label: block_c1piF_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1piF: // global
           I64[Sp + 16] = block_c1piJ_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1piJ() //  [R1]
         { info_tbl: [(c1piJ,
                       label: block_c1piJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1piJ: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.396481464 UTC

[section ""data" . GHC.Real.reduce_$sreduce_closure" {
     GHC.Real.reduce_$sreduce_closure:
         const GHC.Real.reduce_$sreduce_info;
         const 0;
 },
 GHC.Real.reduce_$sreduce_entry() //  [R2, R3]
         { info_tbl: [(c1pjz,
                       label: GHC.Real.reduce_$sreduce_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pjz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1pjA; else goto c1pjB;
       c1pjA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.reduce_$sreduce_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pjB: // global
           I64[Sp - 8] = block_c1pjw_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pjw() //  [R1, R2]
         { info_tbl: [(c1pjw,
                       label: block_c1pjw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pjw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pjE; else goto c1pjD;
       c1pjE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1pjD: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.40267003 UTC

[section ""data" . GHC.Real.$fRealWord_$ctoRational_closure" {
     GHC.Real.$fRealWord_$ctoRational_closure:
         const GHC.Real.$fRealWord_$ctoRational_info;
         const 0;
 },
 section ""relreadonly" . u1pki_srtd" {
     u1pki_srtd:
         const S1jKw_srt;
         const 56;
         const 40532396646335489;
 },
 GHC.Real.$fRealWord_$ctoRational_entry() //  [R2]
         { info_tbl: [(c1pjV,
                       label: GHC.Real.$fRealWord_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pjV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1pk9; else goto c1pka;
       c1pk9: // global
           R2 = R2;
           R1 = GHC.Real.$fRealWord_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1pka: // global
           I64[Sp - 8] = block_c1pjS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1pkh; else goto c1pjT;
       u1pkh: // global
           call _c1pjS(R1) args: 0, res: 0, upd: 0;
       c1pjT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1pkj_srtd" {
     u1pkj_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627371521;
 },
 _c1pjS() //  [R1]
         { info_tbl: [(c1pjS,
                       label: block_c1pjS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pjS: // global
           I64[Sp] = block_c1pjY_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1pkk_srtd" {
     u1pkk_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627371521;
 },
 _c1pjY() //  [R1]
         { info_tbl: [(c1pjY,
                       label: block_c1pjY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pjY: // global
           I64[Sp] = block_c1pk2_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1pkl_srtd" {
     u1pkl_srtd:
         const S1jKw_srt+80;
         const 43;
         const 4398046511105;
 },
 _c1pk2() //  [R1]
         { info_tbl: [(c1pk2,
                       label: block_c1pk2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pk2: // global
           I64[Sp] = block_c1pk6_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pk6() //  [R1, R2]
         { info_tbl: [(c1pk6,
                       label: block_c1pk6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pk6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pkg; else goto c1pkf;
       c1pkg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1pkf: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.417015481 UTC

[section ""data" . GHC.Real.$fRealWord_closure" {
     GHC.Real.$fRealWord_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Num.$fNumWord_closure;
         const GHC.Classes.$fOrdWord_closure;
         const GHC.Real.$fRealWord_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.418839325 UTC

[section ""data" . GHC.Real.$fIntegralWord_closure" {
     GHC.Real.$fIntegralWord_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Real.$fRealWord_closure+1;
         const GHC.Enum.$fEnumWord_closure;
         const GHC.Real.$fIntegralWord_$cquot_closure+2;
         const GHC.Real.$fIntegralWord_$crem_closure+2;
         const GHC.Real.$fIntegralWord_$cquot_closure+2;
         const GHC.Real.$fIntegralWord_$crem_closure+2;
         const GHC.Real.$fIntegralWord_$cquotRem_closure+2;
         const GHC.Real.$fIntegralWord_$cdivMod_closure+2;
         const GHC.Real.$fIntegralWord_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.421492655 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$c*_closure" {
     GHC.Real.$fFractionalRatio_$s$c*_closure:
         const GHC.Real.$fFractionalRatio_$s$c*_info;
         const 0;
 },
 section ""relreadonly" . u1plm_srtd" {
     u1plm_srtd:
         const S1jKw_srt;
         const 57;
         const 76561193665298433;
 },
 GHC.Real.$fFractionalRatio_$s$c*_entry() //  [R2, R3]
         { info_tbl: [(c1pkS,
                       label: GHC.Real.$fFractionalRatio_$s$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pkS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1plb; else goto c1plc;
       c1plb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1plc: // global
           I64[Sp - 16] = block_c1pkP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1pll; else goto c1pkQ;
       u1pll: // global
           call _c1pkP(R1) args: 0, res: 0, upd: 0;
       c1pkQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1pln_srtd" {
     u1pln_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1pkP() //  [R1]
         { info_tbl: [(c1pkP,
                       label: block_c1pkP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pkP: // global
           I64[Sp - 8] = block_c1pkV_info;
           _s1jfV::P64 = P64[R1 + 7];
           _s1jfW::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jfW::P64;
           P64[Sp + 8] = _s1jfV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1plk; else goto c1pkW;
       u1plk: // global
           call _c1pkV(R1) args: 0, res: 0, upd: 0;
       c1pkW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1plo_srtd" {
     u1plo_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1pkV() //  [R1]
         { info_tbl: [(c1pkV,
                       label: block_c1pkV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pkV: // global
           I64[Sp] = block_c1pl0_info;
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1plp_srtd" {
     u1plp_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1pl0() //  [R1]
         { info_tbl: [(c1pl0,
                       label: block_c1pl0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pl0: // global
           _s1jfY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1pl4_info;
           R3 = _s1jfY::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pl4() //  [R1]
         { info_tbl: [(c1pl4,
                       label: block_c1pl4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pl4: // global
           _s1jg1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1pl8_info;
           R3 = _s1jg1::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pl8() //  [R1, R2]
         { info_tbl: [(c1pl8,
                       label: block_c1pl8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pl8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1plj; else goto c1pli;
       c1plj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1pli: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.438492509 UTC

[section ""data" . GHC.Real.$w$s$c-_closure" {
     GHC.Real.$w$s$c-_closure:
         const GHC.Real.$w$s$c-_info;
         const 0;
 },
 section ""relreadonly" . u1pmj_srtd" {
     u1pmj_srtd:
         const S1jKw_srt;
         const 59;
         const 436849163854938113;
 },
 GHC.Real.$w$s$c-_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1plY,
                       label: GHC.Real.$w$s$c-_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1plY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1pma; else goto c1pmb;
       c1pma: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$c-_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pmb: // global
           I64[Sp - 40] = block_c1plW_info;
           _s1jg6::P64 = R3;
           R3 = R5;
           _s1jg5::P64 = R2;
           R2 = _s1jg6::P64;
           P64[Sp - 32] = _s1jg5::P64;
           P64[Sp - 24] = _s1jg6::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1pmk_srtd" {
     u1pmk_srtd:
         const S1jKw_srt;
         const 58;
         const 148618787703226369;
 },
 _c1plW() //  [R1]
         { info_tbl: [(c1plW,
                       label: block_c1plW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1plW: // global
           I64[Sp] = block_c1pm1_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1pml_srtd" {
     u1pml_srtd:
         const S1jKw_srt;
         const 58;
         const 148618787703226369;
 },
 _c1pm1() //  [R1]
         { info_tbl: [(c1pm1,
                       label: block_c1pm1_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pm1: // global
           I64[Sp + 16] = block_c1pm5_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pm5() //  [R1]
         { info_tbl: [(c1pm5,
                       label: block_c1pm5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pm5: // global
           I64[Sp] = block_c1pm9_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pm9() //  [R1]
         { info_tbl: [(c1pm9,
                       label: block_c1pm9_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pm9: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.450875812 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c-_closure" {
     GHC.Real.$fEnumRatio_$s$c-_closure:
         const GHC.Real.$fEnumRatio_$s$c-_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c-_entry() //  [R2, R3]
         { info_tbl: [(c1pmN,
                       label: GHC.Real.$fEnumRatio_$s$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pmN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1pmY; else goto c1pmZ;
       c1pmY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pmZ: // global
           I64[Sp - 16] = block_c1pmK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1pn6; else goto c1pmL;
       u1pn6: // global
           call _c1pmK(R1) args: 0, res: 0, upd: 0;
       c1pmL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pmK() //  [R1]
         { info_tbl: [(c1pmK,
                       label: block_c1pmK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pmK: // global
           I64[Sp - 8] = block_c1pmQ_info;
           _s1jgg::P64 = P64[R1 + 7];
           _s1jgh::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jgh::P64;
           P64[Sp + 8] = _s1jgg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1pn5; else goto c1pmR;
       u1pn5: // global
           call _c1pmQ(R1) args: 0, res: 0, upd: 0;
       c1pmR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pmQ() //  [R1]
         { info_tbl: [(c1pmQ,
                       label: block_c1pmQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pmQ: // global
           _s1jgg::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1pmV_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1jgg::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pmV() //  [R1, R2]
         { info_tbl: [(c1pmV,
                       label: block_c1pmV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pmV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pn4; else goto c1pn3;
       c1pn4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1pn3: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.461145257 UTC

[section ""data" . GHC.Real.$w$s$c+_closure" {
     GHC.Real.$w$s$c+_closure:
         const GHC.Real.$w$s$c+_info;
         const 0;
 },
 section ""relreadonly" . u1pnP_srtd" {
     u1pnP_srtd:
         const S1jKw_srt;
         const 62;
         const 3463268113447911425;
 },
 GHC.Real.$w$s$c+_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1pnu,
                       label: GHC.Real.$w$s$c+_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pnu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1pnG; else goto c1pnH;
       c1pnG: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$c+_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pnH: // global
           I64[Sp - 40] = block_c1pns_info;
           _s1jgp::P64 = R3;
           R3 = R5;
           _s1jgo::P64 = R2;
           R2 = _s1jgp::P64;
           P64[Sp - 32] = _s1jgo::P64;
           P64[Sp - 24] = _s1jgp::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1pnQ_srtd" {
     u1pnQ_srtd:
         const S1jKw_srt;
         const 61;
         const 1157425104234217473;
 },
 _c1pns() //  [R1]
         { info_tbl: [(c1pns,
                       label: block_c1pns_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pns: // global
           I64[Sp] = block_c1pnx_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1pnR_srtd" {
     u1pnR_srtd:
         const S1jKw_srt;
         const 61;
         const 1157425104234217473;
 },
 _c1pnx() //  [R1]
         { info_tbl: [(c1pnx,
                       label: block_c1pnx_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pnx: // global
           I64[Sp + 16] = block_c1pnB_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pnB() //  [R1]
         { info_tbl: [(c1pnB,
                       label: block_c1pnB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pnB: // global
           I64[Sp] = block_c1pnF_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pnF() //  [R1]
         { info_tbl: [(c1pnF,
                       label: block_c1pnF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pnF: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.473891531 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c+_closure" {
     GHC.Real.$fEnumRatio_$s$c+_closure:
         const GHC.Real.$fEnumRatio_$s$c+_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c+_entry() //  [R2, R3]
         { info_tbl: [(c1poj,
                       label: GHC.Real.$fEnumRatio_$s$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1poj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1pou; else goto c1pov;
       c1pou: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pov: // global
           I64[Sp - 16] = block_c1pog_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1poC; else goto c1poh;
       u1poC: // global
           call _c1pog(R1) args: 0, res: 0, upd: 0;
       c1poh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pog() //  [R1]
         { info_tbl: [(c1pog,
                       label: block_c1pog_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pog: // global
           I64[Sp - 8] = block_c1pom_info;
           _s1jgz::P64 = P64[R1 + 7];
           _s1jgA::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jgA::P64;
           P64[Sp + 8] = _s1jgz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1poB; else goto c1pon;
       u1poB: // global
           call _c1pom(R1) args: 0, res: 0, upd: 0;
       c1pon: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pom() //  [R1]
         { info_tbl: [(c1pom,
                       label: block_c1pom_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pom: // global
           _s1jgz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1por_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1jgz::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1por() //  [R1, R2]
         { info_tbl: [(c1por,
                       label: block_c1por_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1por: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1poA; else goto c1poz;
       c1poA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1poz: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.483022317 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$fNumRatio_closure" {
     GHC.Real.$fFractionalRatio_$s$fNumRatio_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Real.$fEnumRatio_$s$c+_closure+2;
         const GHC.Real.$fEnumRatio_$s$c-_closure+2;
         const GHC.Real.$fFractionalRatio_$s$c*_closure+2;
         const GHC.Real.$fFractionalRatio_$s$cnegate_closure+1;
         const GHC.Real.$fFractionalRatio_$s$cabs_closure+1;
         const GHC.Real.$fFractionalRatio_$s$csignum_closure+1;
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.485430318 UTC

[section ""data" . GHC.Real.$w$s$cfromRational_closure" {
     GHC.Real.$w$s$cfromRational_closure:
         const GHC.Real.$w$s$cfromRational_info;
         const 0;
 },
 section ""relreadonly" . u1pph_srtd" {
     u1pph_srtd:
         const S1jKw_srt;
         const 64;
         const 9227875636482146305;
 },
 GHC.Real.$w$s$cfromRational_entry() //  [R2, R3]
         { info_tbl: [(c1pp1,
                       label: GHC.Real.$w$s$cfromRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pp1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1pp9; else goto c1ppa;
       c1pp9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cfromRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ppa: // global
           I64[Sp - 24] = block_c1poZ_info;
           _s1jgH::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _s1jgH::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ppi_srtd" {
     u1ppi_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1poZ() //  [R1]
         { info_tbl: [(c1poZ,
                       label: block_c1poZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1poZ: // global
           I64[Sp] = block_c1pp4_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ppj_srtd" {
     u1ppj_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1pp4() //  [R1]
         { info_tbl: [(c1pp4,
                       label: block_c1pp4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pp4: // global
           _s1jgH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1pp8_info;
           R3 = R1;
           R2 = _s1jgH::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pp8() //  [R1]
         { info_tbl: [(c1pp8,
                       label: block_c1pp8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pp8: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.497806453 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cfromRational_closure" {
     GHC.Real.$fFractionalRatio_$s$cfromRational_closure:
         const GHC.Real.$fFractionalRatio_$s$cfromRational_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$cfromRational_entry() //  [R2]
         { info_tbl: [(c1ppI,
                       label: GHC.Real.$fFractionalRatio_$s$cfromRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ppI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1ppO; else goto c1ppP;
       c1ppO: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cfromRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1ppP: // global
           I64[Sp - 8] = block_c1ppF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ppU; else goto c1ppG;
       u1ppU: // global
           call _c1ppF(R1) args: 0, res: 0, upd: 0;
       c1ppG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ppF() //  [R1]
         { info_tbl: [(c1ppF,
                       label: block_c1ppF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ppF: // global
           I64[Sp] = block_c1ppL_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$cfromRational_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ppL() //  [R1, R2]
         { info_tbl: [(c1ppL,
                       label: block_c1ppL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ppL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ppT; else goto c1ppS;
       c1ppT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1ppS: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.506654682 UTC

[section ""data" . GHC.Real.$w$s$c/_closure" {
     GHC.Real.$w$s$c/_closure:
         const GHC.Real.$w$s$c/_info;
         const 0;
 },
 section ""relreadonly" . u1pqE_srtd" {
     u1pqE_srtd:
         const S1jKw_srt;
         const 66;
         const 4503599627370497;
         const 2;
 },
 GHC.Real.$w$s$c/_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1pqe,
                       label: GHC.Real.$w$s$c/_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pqe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pqu; else goto c1pqv;
       c1pqu: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$c/_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pqv: // global
           I64[Sp - 24] = block_c1pqc_info;
           _s1jgU::P64 = R3;
           R3 = R4;
           _s1jgT::P64 = R2;
           R2 = _s1jgU::P64;
           P64[Sp - 16] = _s1jgT::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1pqF_srtd" {
     u1pqF_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1pqc() //  [R1]
         { info_tbl: [(c1pqc,
                       label: block_c1pqc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pqc: // global
           I64[Sp - 8] = block_c1pqh_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1pqG_srtd" {
     u1pqG_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1pqh() //  [R1]
         { info_tbl: [(c1pqh,
                       label: block_c1pqh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pqh: // global
           I64[Sp] = block_c1pql_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1pqH_srtd" {
     u1pqH_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1pql() //  [R1]
         { info_tbl: [(c1pql,
                       label: block_c1pql_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pql: // global
           I64[Sp] = block_c1pqp_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1pqI_srtd" {
     u1pqI_srtd:
         const S1jKw_srt;
         const 53;
         const 4503599627370497;
 },
 _c1pqp() //  [R1]
         { info_tbl: [(c1pqp,
                       label: block_c1pqp_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pqp: // global
           I64[Sp] = block_c1pqt_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pqt() //  [R1]
         { info_tbl: [(c1pqt,
                       label: block_c1pqt_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pqt: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.523835976 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$c/_closure" {
     GHC.Real.$fFractionalRatio_$s$c/_closure:
         const GHC.Real.$fFractionalRatio_$s$c/_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$c/_entry() //  [R2, R3]
         { info_tbl: [(c1prf,
                       label: GHC.Real.$fFractionalRatio_$s$c/_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1prf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1prq; else goto c1prr;
       c1prq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$c/_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1prr: // global
           I64[Sp - 16] = block_c1prc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1pry; else goto c1prd;
       u1pry: // global
           call _c1prc(R1) args: 0, res: 0, upd: 0;
       c1prd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1prc() //  [R1]
         { info_tbl: [(c1prc,
                       label: block_c1prc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1prc: // global
           I64[Sp - 8] = block_c1pri_info;
           _s1jh5::P64 = P64[R1 + 7];
           _s1jh6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jh6::P64;
           P64[Sp + 8] = _s1jh5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1prx; else goto c1prj;
       u1prx: // global
           call _c1pri(R1) args: 0, res: 0, upd: 0;
       c1prj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pri() //  [R1]
         { info_tbl: [(c1pri,
                       label: block_c1pri_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pri: // global
           _s1jh5::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1prn_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1jh5::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1prn() //  [R1, R2]
         { info_tbl: [(c1prn,
                       label: block_c1prn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1prn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1prw; else goto c1prv;
       c1prw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1prv: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.533139395 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$fFractionalRatio_closure" {
     GHC.Real.$fFractionalRatio_$s$fFractionalRatio_closure:
         const GHC.Real.C:Fractional_con_info;
         const GHC.Real.$fFractionalRatio_$s$fNumRatio_closure+1;
         const GHC.Real.$fFractionalRatio_$s$c/_closure+2;
         const GHC.Real.$fFractionalRatio_$s$crecip_closure+1;
         const GHC.Real.$fFractionalRatio_$s$cfromRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.53501949 UTC

[section ""data" . GHC.Real.ratioPrec_closure" {
     GHC.Real.ratioPrec_closure:
         const GHC.Types.I#_con_info;
         const 7;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.537095131 UTC

[section ""data" . GHC.Real.infinity_closure" {
     GHC.Real.infinity_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.even1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.539806457 UTC

[section ""data" . GHC.Real.notANumber_closure" {
     GHC.Real.notANumber_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.even1_closure;
         const GHC.Real.even1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.543881071 UTC

[section ""data" . GHC.Real.numerator_closure" {
     GHC.Real.numerator_closure:
         const GHC.Real.numerator_info;
 },
 GHC.Real.numerator_entry() //  [R2]
         { info_tbl: [(c1ps1,
                       label: GHC.Real.numerator_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ps1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1ps2; else goto c1ps3;
       c1ps2: // global
           R2 = R2;
           R1 = GHC.Real.numerator_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1ps3: // global
           I64[Sp - 8] = block_c1prY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ps7; else goto c1prZ;
       u1ps7: // global
           call _c1prY(R1) args: 0, res: 0, upd: 0;
       c1prZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1prY() //  [R1]
         { info_tbl: [(c1prY,
                       label: block_c1prY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1prY: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.550115101 UTC

[section ""data" . GHC.Real.denominator_closure" {
     GHC.Real.denominator_closure:
         const GHC.Real.denominator_info;
 },
 GHC.Real.denominator_entry() //  [R2]
         { info_tbl: [(c1pso,
                       label: GHC.Real.denominator_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pso: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1psp; else goto c1psq;
       c1psp: // global
           R2 = R2;
           R1 = GHC.Real.denominator_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1psq: // global
           I64[Sp - 8] = block_c1psl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1psu; else goto c1psm;
       u1psu: // global
           call _c1psl(R1) args: 0, res: 0, upd: 0;
       c1psm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1psl() //  [R1]
         { info_tbl: [(c1psl,
                       label: block_c1psl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1psl: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.556447149 UTC

[section ""data" . GHC.Real.$w$snumericEnumFrom_closure" {
     GHC.Real.$w$snumericEnumFrom_closure:
         const GHC.Real.$w$snumericEnumFrom_info;
         const 0;
 },
 section ""relreadonly" . u1pt4_srtd" {
     u1pt4_srtd:
         const S1jKw_srt+80;
         const 58;
         const 146366987889541121;
 },
 sat_s1jhu_entry() //  [R1]
         { info_tbl: [(c1psR,
                       label: sat_s1jhu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1psR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1psS; else goto c1psT;
       c1psS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1psT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1psM_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1psM() //  [R1, R2]
         { info_tbl: [(c1psM,
                       label: block_c1psM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1psM: // global
           I64[Sp] = block_c1psO_info;
           R3 = R2;
           R2 = R1;
           call GHC.Real.$w$snumericEnumFrom_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1psO() //  [R1, R2]
         { info_tbl: [(c1psO,
                       label: block_c1psO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1psO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1psX; else goto c1psW;
       c1psX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1psW: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1pt5_srtd" {
     u1pt5_srtd:
         const S1jKw_srt+80;
         const 58;
         const 146366987889541121;
 },
 GHC.Real.$w$snumericEnumFrom_entry() //  [R2, R3]
         { info_tbl: [(c1psZ,
                       label: GHC.Real.$w$snumericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1psZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1pt3; else goto c1pt2;
       c1pt3: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pt2: // global
           I64[Hp - 48] = sat_s1jhu_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.568297873 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFrom_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFrom_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFrom_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFrom_entry() //  [R2]
         { info_tbl: [(c1ptv,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ptv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1ptB; else goto c1ptC;
       c1ptB: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1ptC: // global
           I64[Sp - 8] = block_c1pts_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ptH; else goto c1ptt;
       u1ptH: // global
           call _c1pts(R1) args: 0, res: 0, upd: 0;
       c1ptt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pts() //  [R1]
         { info_tbl: [(c1pts,
                       label: block_c1pts_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pts: // global
           I64[Sp] = block_c1pty_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$snumericEnumFrom_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pty() //  [R1, R2]
         { info_tbl: [(c1pty,
                       label: block_c1pty_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pty: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ptG; else goto c1ptF;
       c1ptG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1ptF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.578011525 UTC

[section ""data" . GHC.Real.$wnumericEnumFrom_closure" {
     GHC.Real.$wnumericEnumFrom_closure:
         const GHC.Real.$wnumericEnumFrom_info;
         const 0;
 },
 sat_s1jhG_entry() //  [R1]
         { info_tbl: [(c1pud,
                       label: sat_s1jhG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pud: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pue; else goto c1puf;
       c1pue: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1puf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jhL_entry() //  [R1]
         { info_tbl: [(c1pug,
                       label: sat_s1jhL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pug: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1pum; else goto c1pun;
       c1pum: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pun: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c1pu5_info;
           _s1jhC::P64 = P64[R1 + 16];
           R2 = _s1jhC::P64;
           P64[Sp - 32] = _s1jhC::P64;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pu5() //  [R1]
         { info_tbl: [(c1pu5,
                       label: block_c1pu5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pu5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1puq; else goto c1pup;
       c1puq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1pup: // global
           I64[Hp - 16] = sat_s1jhG_info;
           P64[Hp] = R1;
           I64[Sp] = block_c1puh_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call GHC.Num.+_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1puh() //  [R1]
         { info_tbl: [(c1puh,
                       label: block_c1puh_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1puh: // global
           I64[Sp + 16] = block_c1puj_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1puj() //  [R1, R2]
         { info_tbl: [(c1puj,
                       label: block_c1puj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1puj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1puu; else goto c1put;
       c1puu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1put: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$wnumericEnumFrom_entry() //  [R2, R3]
         { info_tbl: [(c1puv,
                       label: GHC.Real.$wnumericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1puv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1puw; else goto c1pux;
       c1puw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wnumericEnumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pux: // global
           I64[Sp - 16] = block_c1ptZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ptZ() //  [R1]
         { info_tbl: [(c1ptZ,
                       label: block_c1ptZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ptZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1puA; else goto c1puz;
       c1puA: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1puz: // global
           I64[Hp - 24] = sat_s1jhL_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = Hp - 24;
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.593857394 UTC

[section ""data" . GHC.Real.numericEnumFrom_closure" {
     GHC.Real.numericEnumFrom_closure:
         const GHC.Real.numericEnumFrom_info;
         const 0;
 },
 GHC.Real.numericEnumFrom_entry() //  [R2, R3]
         { info_tbl: [(c1pvd,
                       label: GHC.Real.numericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pvd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1pve; else goto c1pvf;
       c1pve: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pvf: // global
           I64[Sp - 8] = block_c1pva_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pva() //  [R1, R2]
         { info_tbl: [(c1pva,
                       label: block_c1pva_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pva: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pvi; else goto c1pvh;
       c1pvi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1pvh: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.599413392 UTC

[section ""data" . sat_s1jhR_closure" {
     sat_s1jhR_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.601065043 UTC

[section ""data" . sat_s1jhS_closure" {
     sat_s1jhS_closure:
         const :_con_info;
         const sat_s1jhR_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.603089488 UTC

[section ""data" . GHC.Real.even2_closure" {
     GHC.Real.even2_closure:
         const GHC.Real.even2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.even2_entry() //  [R1]
         { info_tbl: [(c1pvA,
                       label: GHC.Real.even2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pvA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pvB; else goto c1pvC;
       c1pvB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pvC: // global
           (_c1pvx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1pvx::I64 == 0) goto c1pvz; else goto c1pvy;
       c1pvz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1pvy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1pvx::I64;
           R3 = sat_s1jhS_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.608095406 UTC

[section ""data" . GHC.Real.$fEnumRatio2_closure" {
     GHC.Real.$fEnumRatio2_closure:
         const GHC.Real.$fEnumRatio2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fEnumRatio2_entry() //  [R1]
         { info_tbl: [(c1pvT,
                       label: GHC.Real.$fEnumRatio2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pvT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1pvU; else goto c1pvV;
       c1pvU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pvV: // global
           (_c1pvN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1pvN::I64 == 0) goto c1pvP; else goto c1pvO;
       c1pvP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1pvO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1pvN::I64;
           I64[Sp - 24] = block_c1pvQ_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even2_closure;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 24;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pvQ() //  [R1, R2]
         { info_tbl: [(c1pvQ,
                       label: block_c1pvQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pvQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pvY; else goto c1pvX;
       c1pvY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1pvX: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.614976222 UTC

[section ""data" . GHC.Real.$w$snumericEnumFromTo_closure" {
     GHC.Real.$w$snumericEnumFromTo_closure:
         const GHC.Real.$w$snumericEnumFromTo_info;
         const 0;
 },
 ds_s1ji2_entry() //  [R1]
         { info_tbl: [(c1pwo,
                       label: ds_s1ji2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pwo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1pwz; else goto c1pwA;
       c1pwz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pwA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1pwl_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1pwH; else goto c1pwm;
       u1pwH: // global
           call _c1pwl(R1) args: 0, res: 0, upd: 0;
       c1pwm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1pwl() //  [R1]
         { info_tbl: [(c1pwl,
                       label: block_c1pwl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pwl: // global
           I64[Sp - 16] = block_c1pwr_info;
           _s1ji4::P64 = P64[R1 + 7];
           _s1ji5::P64 = P64[R1 + 15];
           R1 = GHC.Real.$fEnumRatio2_closure;
           P64[Sp - 8] = _s1ji5::P64;
           P64[Sp] = _s1ji4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1pwG; else goto c1pws;
       u1pwG: // global
           call _c1pwr(R1) args: 0, res: 0, upd: 0;
       c1pws: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1pwr() //  [R1]
         { info_tbl: [(c1pwr,
                       label: block_c1pwr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pwr: // global
           _s1ji4::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1pww_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1ji4::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pww() //  [R1, R2]
         { info_tbl: [(c1pww,
                       label: block_c1pww_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pww: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pwF; else goto c1pwE;
       c1pwF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1pwE: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jid_entry() //  [R1, R2]
         { info_tbl: [(c1pwN,
                       label: sat_s1jid_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pwN: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call GHC.Real.$fEnumRatio_$s$c<=_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$w$snumericEnumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c1pwQ,
                       label: GHC.Real.$w$snumericEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pwQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pwR; else goto c1pwS;
       c1pwR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pwS: // global
           I64[Sp - 16] = block_c1pwe_info;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Real.$w$snumericEnumFrom_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pwe() //  [R1, R2]
         { info_tbl: [(c1pwe,
                       label: block_c1pwe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pwe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1pwV; else goto c1pwU;
       c1pwV: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1pwU: // global
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = R1;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = ds_s1ji2_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_s1jid_info;
           P64[Hp] = Hp - 32;
           R3 = Hp - 54;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.629689105 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFromTo_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c1pxw,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pxw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pxx; else goto c1pxy;
       c1pxx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pxy: // global
           I64[Sp - 16] = block_c1pxt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1pxC; else goto c1pxu;
       u1pxC: // global
           call _c1pxt(R1) args: 0, res: 0, upd: 0;
       c1pxu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pxt() //  [R1]
         { info_tbl: [(c1pxt,
                       label: block_c1pxt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pxt: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Real.$w$snumericEnumFromTo_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.637188195 UTC

[section ""data" . GHC.Real.numericEnumFromTo_closure" {
     GHC.Real.numericEnumFromTo_closure:
         const GHC.Real.numericEnumFromTo_info;
         const 0;
 },
 $dNum_s1jir_entry() //  [R1]
         { info_tbl: [(c1pxW,
                       label: $dNum_s1jir_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pxW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pxX; else goto c1pxY;
       c1pxX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pxY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jiu_entry() //  [R1]
         { info_tbl: [(c1pyc,
                       label: sat_s1jiu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pyc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pyd; else goto c1pye;
       c1pyd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pye: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jit_entry() //  [R1]
         { info_tbl: [(c1pyj,
                       label: sat_s1jit_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pyj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pyk; else goto c1pyl;
       c1pyk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pyl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jiv_entry() //  [R1]
         { info_tbl: [(c1pym,
                       label: sat_s1jiv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pym: // global
           _s1jiv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1pyn; else goto c1pyo;
       c1pyo: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1pyq; else goto c1pyp;
       c1pyq: // global
           HpAlloc = 48;
           goto c1pyn;
       c1pyn: // global
           R1 = _s1jiv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pyp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jiv::P64;
           _s1jil::P64 = P64[_s1jiv::P64 + 16];
           _s1jir::P64 = P64[_s1jiv::P64 + 24];
           I64[Hp - 40] = sat_s1jiu_info;
           P64[Hp - 24] = _s1jir::P64;
           I64[Hp - 16] = sat_s1jit_info;
           P64[Hp] = _s1jir::P64;
           R2 = _s1jil::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           Sp = Sp - 40;
           call GHC.Real./_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds_s1jis_entry() //  [R1]
         { info_tbl: [(c1pyr,
                       label: ds_s1jis_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pyr: // global
           _s1jis::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1pys; else goto c1pyt;
       c1pyt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1pyv; else goto c1pyu;
       c1pyv: // global
           HpAlloc = 32;
           goto c1pys;
       c1pys: // global
           R1 = _s1jis::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pyu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jis::P64;
           _s1jil::P64 = P64[_s1jis::P64 + 16];
           _s1jin::P64 = P64[_s1jis::P64 + 24];
           _s1jir::P64 = P64[_s1jis::P64 + 32];
           I64[Hp - 24] = sat_s1jiv_info;
           P64[Hp - 8] = _s1jil::P64;
           P64[Hp] = _s1jir::P64;
           R2 = _s1jir::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1jin::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jix_entry() //  [R1, R2]
         { info_tbl: [(c1pyB,
                       label: sat_s1jix_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pyB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1pyC; else goto c1pyD;
       c1pyC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1pyD: // global
           _s1jiw::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jiw::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Real.numericEnumFromTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1pyE,
                       label: GHC.Real.numericEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pyE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pyF; else goto c1pyG;
       c1pyF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFromTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pyG: // global
           I64[Sp - 32] = block_c1pxQ_info;
           _s1jil::P64 = R3;
           R3 = R4;
           _s1jik::P64 = R2;
           R2 = _s1jil::P64;
           P64[Sp - 24] = _s1jik::P64;
           P64[Sp - 16] = _s1jil::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pxQ() //  [R1, R2]
         { info_tbl: [(c1pxQ,
                       label: block_c1pxQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pxQ: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1pyJ; else goto c1pyI;
       c1pyJ: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1pyI: // global
           I64[Hp - 104] = $dNum_s1jir_info;
           _s1jil::P64 = P64[Sp + 16];
           P64[Hp - 88] = _s1jil::P64;
           I64[Hp - 80] = :_con_info;
           P64[Hp - 72] = R1;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = ds_s1jis_info;
           P64[Hp - 40] = _s1jil::P64;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = sat_s1jix_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 56;
           R3 = Hp - 78;
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.655990542 UTC

[section ""data" . GHC.Real.$w$snumericEnumFromThen_closure" {
     GHC.Real.$w$snumericEnumFromThen_closure:
         const GHC.Real.$w$snumericEnumFromThen_info;
         const 0;
 },
 sat_s1jiN_entry() //  [R1]
         { info_tbl: [(c1pzD,
                       label: sat_s1jiN_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pzD: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1pzE; else goto c1pzF;
       c1pzE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pzF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_c1pzw_info;
           _s1jiC::P64 = P64[R1 + 40];
           R5 = _s1jiC::P64;
           _s1jiB::P64 = P64[R1 + 32];
           R4 = _s1jiB::P64;
           R3 = _s1jiC::P64;
           R2 = _s1jiB::P64;
           P64[Sp - 48] = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = _s1jiB::P64;
           P64[Sp - 24] = _s1jiC::P64;
           Sp = Sp - 56;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pzw() //  [R1, R2]
         { info_tbl: [(c1pzw,
                       label: block_c1pzw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pzw: // global
           _s1jiA::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1pzy_info;
           R5 = _s1jiA::P64;
           R4 = P64[Sp + 8];
           R3 = R2;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pzy() //  [R1, R2]
         { info_tbl: [(c1pzy,
                       label: block_c1pzy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pzy: // global
           _s1jiC::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1pzA_info;
           R5 = R2;
           R4 = R1;
           R3 = _s1jiC::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$snumericEnumFromThen_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pzA() //  [R1, R2]
         { info_tbl: [(c1pzA,
                       label: block_c1pzA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pzA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pzK; else goto c1pzJ;
       c1pzK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1pzJ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$snumericEnumFromThen_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1pzM,
                       label: GHC.Real.$w$snumericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pzM: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1pzQ; else goto c1pzP;
       c1pzQ: // global
           HpAlloc = 72;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFromThen_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pzP: // global
           I64[Hp - 64] = sat_s1jiN_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.669564551 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFromThen_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c1pAj,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pAj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1pAu; else goto c1pAv;
       c1pAu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pAv: // global
           I64[Sp - 16] = block_c1pAg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1pAC; else goto c1pAh;
       u1pAC: // global
           call _c1pAg(R1) args: 0, res: 0, upd: 0;
       c1pAh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pAg() //  [R1]
         { info_tbl: [(c1pAg,
                       label: block_c1pAg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pAg: // global
           I64[Sp - 8] = block_c1pAm_info;
           _s1jiR::P64 = P64[R1 + 7];
           _s1jiS::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jiS::P64;
           P64[Sp + 8] = _s1jiR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1pAB; else goto c1pAn;
       u1pAB: // global
           call _c1pAm(R1) args: 0, res: 0, upd: 0;
       c1pAn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pAm() //  [R1]
         { info_tbl: [(c1pAm,
                       label: block_c1pAm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pAm: // global
           _s1jiR::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1pAr_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1jiR::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$snumericEnumFromThen_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pAr() //  [R1, R2]
         { info_tbl: [(c1pAr,
                       label: block_c1pAr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pAr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pAA; else goto c1pAz;
       c1pAA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1pAz: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.680034959 UTC

[section ""data" . GHC.Real.$wnumericEnumFromThen_closure" {
     GHC.Real.$wnumericEnumFromThen_closure:
         const GHC.Real.$wnumericEnumFromThen_info;
 },
 sat_s1jj5_entry() //  [R1]
         { info_tbl: [(c1pBe,
                       label: sat_s1jj5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pBe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1pBf; else goto c1pBg;
       c1pBf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pBg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jj3::P64 = P64[R1 + 16];
           P64[Sp - 32] = _s1jj3::P64;
           P64[Sp - 24] = _s1jj3::P64;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jja_entry() //  [R1]
         { info_tbl: [(c1pBh,
                       label: sat_s1jja_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pBh: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1pBn; else goto c1pBo;
       c1pBn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pBo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_c1pB6_info;
           _s1jiZ::P64 = P64[R1 + 16];
           R2 = _s1jiZ::P64;
           P64[Sp - 40] = _s1jiZ::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pB6() //  [R1]
         { info_tbl: [(c1pB6,
                       label: block_c1pB6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pB6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1pBr; else goto c1pBq;
       c1pBr: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1pBq: // global
           I64[Hp - 24] = sat_s1jj5_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           I64[Sp] = block_c1pBi_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1pBi() //  [R1]
         { info_tbl: [(c1pBi,
                       label: block_c1pBi_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pBi: // global
           _s1jj3::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1pBk_info;
           R4 = R1;
           R3 = _s1jj3::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pBk() //  [R1, R2]
         { info_tbl: [(c1pBk,
                       label: block_c1pBk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pBk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pBv; else goto c1pBu;
       c1pBv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1pBu: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$wnumericEnumFromThen_entry() //  [R2, R3, R4]
         { info_tbl: [(c1pBw,
                       label: GHC.Real.$wnumericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pBw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1pBx; else goto c1pBy;
       c1pBx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wnumericEnumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pBy: // global
           I64[Sp - 24] = block_c1pAY_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pAY() //  [R1]
         { info_tbl: [(c1pAY,
                       label: block_c1pAY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pAY: // global
           I64[Sp] = block_c1pB0_info;
           _s1jj2::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s1jj2::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pB0() //  [R1]
         { info_tbl: [(c1pB0,
                       label: block_c1pB0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pB0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1pBC; else goto c1pBB;
       c1pBC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pBB: // global
           I64[Hp - 32] = sat_s1jja_info;
           P64[Hp - 16] = P64[Sp + 8];
           _s1jj2::P64 = P64[Sp + 16];
           P64[Hp - 8] = _s1jj2::P64;
           P64[Hp] = R1;
           R2 = Hp - 32;
           R1 = _s1jj2::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.697438274 UTC

[section ""data" . GHC.Real.numericEnumFromThen_closure" {
     GHC.Real.numericEnumFromThen_closure:
         const GHC.Real.numericEnumFromThen_info;
 },
 GHC.Real.numericEnumFromThen_entry() //  [R2, R3, R4]
         { info_tbl: [(c1pCk,
                       label: GHC.Real.numericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pCk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1pCl; else goto c1pCm;
       c1pCl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pCm: // global
           I64[Sp - 8] = block_c1pCh_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pCh() //  [R1, R2]
         { info_tbl: [(c1pCh,
                       label: block_c1pCh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pCh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pCp; else goto c1pCo;
       c1pCp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1pCo: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.704861332 UTC

[section ""data" . GHC.Real.$w$snumericEnumFromThenTo_closure" {
     GHC.Real.$w$snumericEnumFromThenTo_closure:
         const GHC.Real.$w$snumericEnumFromThenTo_info;
         const 0;
 },
 ds_s1jjq_entry() //  [R1]
         { info_tbl: [(c1pCV,
                       label: ds_s1jjq_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pCV: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1pD5; else goto c1pD6;
       c1pD5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pD6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_c1pCS_info;
           _s1jjh::P64 = P64[R1 + 16];
           _s1jji::P64 = P64[R1 + 24];
           _s1jjj::P64 = P64[R1 + 32];
           _s1jjk::P64 = P64[R1 + 40];
           R1 = P64[R1 + 48];
           P64[Sp - 48] = _s1jjh::P64;
           P64[Sp - 40] = _s1jji::P64;
           P64[Sp - 32] = _s1jjj::P64;
           P64[Sp - 24] = _s1jjk::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u1pDd; else goto c1pCT;
       u1pDd: // global
           call _c1pCS(R1) args: 0, res: 0, upd: 0;
       c1pCT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1pCS() //  [R1]
         { info_tbl: [(c1pCS,
                       label: block_c1pCS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pCS: // global
           _s1jji::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1pCY_info;
           R5 = _s1jji::P64;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 15];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pCY() //  [R1, R2]
         { info_tbl: [(c1pCY,
                       label: block_c1pCY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pCY: // global
           I64[Sp] = block_c1pD0_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even2_closure;
           R3 = R2;
           R2 = R1;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pD0() //  [R1, R2]
         { info_tbl: [(c1pD0,
                       label: block_c1pD0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pD0: // global
           _s1jjs::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1pD2_info;
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = _s1jjs::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pD2() //  [R1, R2]
         { info_tbl: [(c1pD2,
                       label: block_c1pD2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pD2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pDc; else goto c1pDb;
       c1pDc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1pDb: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jjE_entry() //  [R1, R2]
         { info_tbl: [(c1pDj,
                       label: sat_s1jjE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pDj: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call GHC.Real.$fEnumRatio_$s$c<=_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_s1jjF_entry() //  [R1]
         { info_tbl: [(c1pDv,
                       label: ds_s1jjF_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pDv: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1pDF; else goto c1pDG;
       c1pDF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pDG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_c1pDs_info;
           _s1jjh::P64 = P64[R1 + 16];
           _s1jji::P64 = P64[R1 + 24];
           _s1jjj::P64 = P64[R1 + 32];
           _s1jjk::P64 = P64[R1 + 40];
           R1 = P64[R1 + 48];
           P64[Sp - 48] = _s1jjh::P64;
           P64[Sp - 40] = _s1jji::P64;
           P64[Sp - 32] = _s1jjj::P64;
           P64[Sp - 24] = _s1jjk::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u1pDN; else goto c1pDt;
       u1pDN: // global
           call _c1pDs(R1) args: 0, res: 0, upd: 0;
       c1pDt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1pDs() //  [R1]
         { info_tbl: [(c1pDs,
                       label: block_c1pDs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pDs: // global
           _s1jji::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1pDy_info;
           R5 = _s1jji::P64;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 15];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pDy() //  [R1, R2]
         { info_tbl: [(c1pDy,
                       label: block_c1pDy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pDy: // global
           I64[Sp] = block_c1pDA_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even2_closure;
           R3 = R2;
           R2 = R1;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pDA() //  [R1, R2]
         { info_tbl: [(c1pDA,
                       label: block_c1pDA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pDA: // global
           _s1jjH::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1pDC_info;
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = _s1jjH::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pDC() //  [R1, R2]
         { info_tbl: [(c1pDC,
                       label: block_c1pDC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pDC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pDM; else goto c1pDL;
       c1pDM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1pDL: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jjT_entry() //  [R1, R2]
         { info_tbl: [(c1pDT,
                       label: sat_s1jjT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pDT: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call GHC.Real.$fEnumRatio_$s$c>=_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1pEf_srtd" {
     u1pEf_srtd:
         const S1jKw_srt+24;
         const 79;
         const 4935945191598063617;
         const 16708;
 },
 sat_s1jjU_entry() //  [R1]
         { info_tbl: [(c1pE0,
                       label: sat_s1jjU_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pE0: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1pE1; else goto c1pE2;
       c1pE1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pE2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c1pCK_info;
           _s1jji::P64 = P64[R1 + 24];
           R5 = _s1jji::P64;
           _s1jjh::P64 = P64[R1 + 16];
           R4 = _s1jjh::P64;
           _s1jjk::P64 = P64[R1 + 40];
           R3 = _s1jjk::P64;
           _s1jjj::P64 = P64[R1 + 32];
           R2 = _s1jjj::P64;
           P64[Sp - 56] = _s1jjh::P64;
           P64[Sp - 48] = _s1jji::P64;
           P64[Sp - 40] = _s1jjj::P64;
           P64[Sp - 32] = _s1jjk::P64;
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 64;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pCK() //  [R1]
         { info_tbl: [(c1pCK,
                       label: block_c1pCK_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pCK: // global
           _s1jjh::P64 = P64[Sp + 8];
           _s1jji::P64 = P64[Sp + 16];
           _s1jjj::P64 = P64[Sp + 24];
           _s1jjk::P64 = P64[Sp + 32];
           _s1jjl::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c1pDY; else goto c1pDX;
       c1pDY: // global
           Hp = Hp + 72;
           _s1jjp::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1pE8; else goto c1pE7;
       c1pE7: // global
           I64[Hp - 64] = ds_s1jjF_info;
           P64[Hp - 48] = _s1jjh::P64;
           P64[Hp - 40] = _s1jji::P64;
           P64[Hp - 32] = _s1jjj::P64;
           P64[Hp - 24] = _s1jjk::P64;
           P64[Hp - 16] = _s1jjl::P64;
           I64[Hp - 8] = sat_s1jjT_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c1pDX: // global
           Hp = Hp + 72;
           _s1jjp::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1pE8; else goto c1pE4;
       c1pE8: // global
           HpAlloc = 72;
           R1 = _s1jjp::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1pE4: // global
           I64[Hp - 64] = ds_s1jjq_info;
           P64[Hp - 48] = _s1jjh::P64;
           P64[Hp - 40] = _s1jji::P64;
           P64[Hp - 32] = _s1jjj::P64;
           P64[Hp - 24] = _s1jjk::P64;
           P64[Hp - 16] = _s1jjl::P64;
           I64[Hp - 8] = sat_s1jjE_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1pEg_srtd" {
     u1pEg_srtd:
         const S1jKw_srt+24;
         const 80;
         const 4935945191598063617;
         const 53572;
 },
 GHC.Real.$w$snumericEnumFromThenTo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1pE9,
                       label: GHC.Real.$w$snumericEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pE9: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1pEa; else goto c1pEb;
       c1pEa: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFromThenTo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pEb: // global
           I64[Sp - 48] = block_c1pCD_info;
           _s1jjk::P64 = R5;
           R5 = R5;
           _s1jjj::P64 = R4;
           R4 = R4;
           _s1jji::P64 = R3;
           R3 = R3;
           _s1jjh::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = _s1jjh::P64;
           P64[Sp - 32] = _s1jji::P64;
           P64[Sp - 24] = _s1jjj::P64;
           P64[Sp - 16] = _s1jjk::P64;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$w$snumericEnumFromThen_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1pEh_srtd" {
     u1pEh_srtd:
         const S1jKw_srt+24;
         const 79;
         const 4935945191598063617;
         const 16708;
 },
 _c1pCD() //  [R1, R2]
         { info_tbl: [(c1pCD,
                       label: block_c1pCD_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pCD: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1pEe; else goto c1pEd;
       c1pEe: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1pEd: // global
           I64[Hp - 72] = :_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s1jjU_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R3 = Hp - 70;
           R2 = Hp - 48;
           Sp = Sp + 48;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.742830675 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c1pFD,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pFD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pFH; else goto c1pFI;
       c1pFH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pFI: // global
           I64[Sp - 24] = block_c1pFA_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1pFQ; else goto c1pFB;
       u1pFQ: // global
           call _c1pFA(R1) args: 0, res: 0, upd: 0;
       c1pFB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pFA() //  [R1]
         { info_tbl: [(c1pFA,
                       label: block_c1pFA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pFA: // global
           I64[Sp - 8] = block_c1pFG_info;
           _s1jk0::P64 = P64[R1 + 7];
           _s1jk1::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1jk1::P64;
           P64[Sp + 8] = _s1jk0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1pFP; else goto c1pFK;
       u1pFP: // global
           call _c1pFG(R1) args: 0, res: 0, upd: 0;
       c1pFK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pFG() //  [R1]
         { info_tbl: [(c1pFG,
                       label: block_c1pFG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pFG: // global
           R6 = P64[Sp + 24];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$snumericEnumFromThenTo_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.753521181 UTC

[section ""data" . GHC.Real.numericEnumFromThenTo_closure" {
     GHC.Real.numericEnumFromThenTo_closure:
         const GHC.Real.numericEnumFromThenTo_info;
         const 0;
 },
 $dNum_s1jkd_entry() //  [R1]
         { info_tbl: [(c1pGj,
                       label: $dNum_s1jkd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pGj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pGk; else goto c1pGl;
       c1pGk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pGl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jkg_entry() //  [R1]
         { info_tbl: [(c1pGu,
                       label: sat_s1jkg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pGu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pGv; else goto c1pGw;
       c1pGv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pGw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jkf_entry() //  [R1]
         { info_tbl: [(c1pGB,
                       label: sat_s1jkf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pGB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1pGC; else goto c1pGD;
       c1pGC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pGD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 mid_s1jke_entry() //  [R1]
         { info_tbl: [(c1pGE,
                       label: mid_s1jke_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pGE: // global
           _s1jke::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1pGF; else goto c1pGG;
       c1pGG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1pGI; else goto c1pGH;
       c1pGI: // global
           HpAlloc = 64;
           goto c1pGF;
       c1pGF: // global
           R1 = _s1jke::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pGH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jke::P64;
           _s1jk6::P64 = P64[_s1jke::P64 + 16];
           _s1jk7::P64 = P64[_s1jke::P64 + 24];
           _s1jk8::P64 = P64[_s1jke::P64 + 32];
           _s1jkd::P64 = P64[_s1jke::P64 + 40];
           I64[Hp - 56] = sat_s1jkg_info;
           P64[Hp - 40] = _s1jkd::P64;
           I64[Hp - 32] = sat_s1jkf_info;
           P64[Hp - 16] = _s1jk7::P64;
           P64[Hp - 8] = _s1jk8::P64;
           P64[Hp] = _s1jkd::P64;
           R2 = _s1jk6::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Real./_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds_s1jki_entry() //  [R1]
         { info_tbl: [(c1pGR,
                       label: ds_s1jki_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pGR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1pGS; else goto c1pGT;
       c1pGS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pGT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jkk_entry() //  [R1, R2]
         { info_tbl: [(c1pGZ,
                       label: sat_s1jkk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pGZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1pH0; else goto c1pH1;
       c1pH0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1pH1: // global
           _s1jkj::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jkj::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 ds_s1jkl_entry() //  [R1]
         { info_tbl: [(c1pH8,
                       label: ds_s1jkl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pH8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1pH9; else goto c1pHa;
       c1pH9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pHa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jkn_entry() //  [R1, R2]
         { info_tbl: [(c1pHg,
                       label: sat_s1jkn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pHg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1pHh; else goto c1pHi;
       c1pHh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1pHi: // global
           _s1jkm::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jkm::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s1jko_entry() //  [R1]
         { info_tbl: [(c1pHn,
                       label: sat_s1jko_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pHn: // global
           _s1jko::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto c1pHo; else goto c1pHp;
       c1pHp: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1pHr; else goto c1pHq;
       c1pHr: // global
           HpAlloc = 72;
           goto c1pHo;
       c1pHo: // global
           R1 = _s1jko::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pHq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jko::P64;
           _s1jk5::P64 = P64[_s1jko::P64 + 16];
           _s1jk6::P64 = P64[_s1jko::P64 + 24];
           _s1jk7::P64 = P64[_s1jko::P64 + 32];
           _s1jk8::P64 = P64[_s1jko::P64 + 40];
           _s1jk9::P64 = P64[_s1jko::P64 + 48];
           I64[Hp - 64] = $dNum_s1jkd_info;
           P64[Hp - 48] = _s1jk6::P64;
           I64[Hp - 40] = mid_s1jke_info;
           P64[Hp - 24] = _s1jk6::P64;
           P64[Hp - 16] = _s1jk7::P64;
           P64[Hp - 8] = _s1jk8::P64;
           _c1pGf::P64 = Hp - 64;
           P64[Hp] = _c1pGf::P64;
           I64[Sp - 56] = block_c1pGJ_info;
           R2 = _s1jk5::P64;
           I64[Sp - 80] = stg_ap_pp_info;
           P64[Sp - 72] = _s1jk8::P64;
           P64[Sp - 64] = _s1jk7::P64;
           P64[Sp - 48] = _c1pGf::P64;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = _s1jk5::P64;
           P64[Sp - 24] = _s1jk9::P64;
           Sp = Sp - 80;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1pGJ() //  [R1]
         { info_tbl: [(c1pGJ,
                       label: block_c1pGJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pGJ: // global
           _c1pGf::P64 = P64[Sp + 8];
           _c1pGm::P64 = P64[Sp + 16];
           _s1jk5::P64 = P64[Sp + 24];
           _s1jk9::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c1pHk; else goto c1pHl;
       c1pHk: // global
           Hp = Hp + 64;
           _s1jkh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1pHx; else goto c1pHt;
       c1pHt: // global
           I64[Hp - 56] = ds_s1jki_info;
           P64[Hp - 40] = _s1jk9::P64;
           P64[Hp - 32] = _c1pGf::P64;
           P64[Hp - 24] = _c1pGm::P64;
           I64[Hp - 16] = sat_s1jkk_info;
           P64[Hp - 8] = _s1jk5::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c1pHl: // global
           Hp = Hp + 64;
           _s1jkh::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1pHx; else goto c1pHw;
       c1pHx: // global
           HpAlloc = 64;
           R1 = _s1jkh::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1pHw: // global
           I64[Hp - 56] = ds_s1jkl_info;
           P64[Hp - 40] = _s1jk9::P64;
           P64[Hp - 32] = _c1pGf::P64;
           P64[Hp - 24] = _c1pGm::P64;
           I64[Hp - 16] = sat_s1jkn_info;
           P64[Hp - 8] = _s1jk5::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.numericEnumFromThenTo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1pHy,
                       label: GHC.Real.numericEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pHy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1pHz; else goto c1pHA;
       c1pHz: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFromThenTo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pHA: // global
           I64[Sp - 48] = block_c1pG8_info;
           _s1jk7::P64 = R4;
           R4 = R5;
           _s1jk6::P64 = R3;
           R3 = _s1jk7::P64;
           _s1jk5::P64 = R2;
           R2 = _s1jk6::P64;
           P64[Sp - 40] = _s1jk5::P64;
           P64[Sp - 32] = _s1jk6::P64;
           P64[Sp - 24] = _s1jk7::P64;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pG8() //  [R1, R2]
         { info_tbl: [(c1pG8,
                       label: block_c1pG8_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pG8: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1pHD; else goto c1pHC;
       c1pHD: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1pHC: // global
           I64[Hp - 72] = :_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s1jko_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R3 = Hp - 70;
           R2 = Hp - 48;
           Sp = Sp + 48;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.783476276 UTC

[section ""data" . GHC.Real.fromIntegral_closure" {
     GHC.Real.fromIntegral_closure:
         const GHC.Real.fromIntegral_info;
 },
 sat_s1jkt_entry() //  [R1]
         { info_tbl: [(c1pIT,
                       label: sat_s1jkt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pIT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pIU; else goto c1pIV;
       c1pIU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pIV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.fromIntegral_entry() //  [R2, R3, R4]
         { info_tbl: [(c1pIW,
                       label: GHC.Real.fromIntegral_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pIW: // global
           _s1jks::P64 = R4;
           _s1jkr::P64 = R3;
           _s1jkq::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c1pIX; else goto c1pIY;
       c1pIY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1pJ0; else goto c1pIZ;
       c1pJ0: // global
           HpAlloc = 32;
           goto c1pIX;
       c1pIX: // global
           R4 = _s1jks::P64;
           R3 = _s1jkr::P64;
           R2 = _s1jkq::P64;
           R1 = GHC.Real.fromIntegral_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pIZ: // global
           I64[Hp - 24] = sat_s1jkt_info;
           P64[Hp - 8] = _s1jkq::P64;
           P64[Hp] = _s1jks::P64;
           R2 = _s1jkr::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.790011967 UTC

[section ""data" . GHC.Real.realToFrac_closure" {
     GHC.Real.realToFrac_closure:
         const GHC.Real.realToFrac_info;
 },
 sat_s1jkx_entry() //  [R1]
         { info_tbl: [(c1pJk,
                       label: sat_s1jkx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pJk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pJl; else goto c1pJm;
       c1pJl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pJm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.realToFrac_entry() //  [R2, R3, R4]
         { info_tbl: [(c1pJn,
                       label: GHC.Real.realToFrac_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pJn: // global
           _s1jkw::P64 = R4;
           _s1jkv::P64 = R3;
           _s1jku::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c1pJo; else goto c1pJp;
       c1pJp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1pJr; else goto c1pJq;
       c1pJr: // global
           HpAlloc = 32;
           goto c1pJo;
       c1pJo: // global
           R4 = _s1jkw::P64;
           R3 = _s1jkv::P64;
           R2 = _s1jku::P64;
           R1 = GHC.Real.realToFrac_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pJq: // global
           I64[Hp - 24] = sat_s1jkx_info;
           P64[Hp - 8] = _s1jku::P64;
           P64[Hp] = _s1jkw::P64;
           R2 = _s1jkv::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Real.fromRational_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.795982221 UTC

[section ""data" . GHC.Real.showSigned1_closure" {
     GHC.Real.showSigned1_closure:
         const GHC.Types.C#_con_info;
         const 45;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.79972386 UTC

[section ""data" . GHC.Real.showSigned_closure" {
     GHC.Real.showSigned_closure:
         const GHC.Real.showSigned_info;
         const 0;
 },
 $dNum_s1jkC_entry() //  [R1]
         { info_tbl: [(c1pJM,
                       label: $dNum_s1jkC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pJM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pJN; else goto c1pJO;
       c1pJN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pJO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jkE_entry() //  [R1]
         { info_tbl: [(c1pJT,
                       label: sat_s1jkE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pJT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pJU; else goto c1pJV;
       c1pJU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pJV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jkJ_entry() //  [R1]
         { info_tbl: [(c1pKi,
                       label: sat_s1jkJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pKi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pKj; else goto c1pKk;
       c1pKj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pKk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 g1_s1jkI_entry() //  [R1]
         { info_tbl: [(c1pKl,
                       label: g1_s1jkI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pKl: // global
           _s1jkI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1pKm; else goto c1pKn;
       c1pKn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1pKp; else goto c1pKo;
       c1pKp: // global
           HpAlloc = 32;
           goto c1pKm;
       c1pKm: // global
           R1 = _s1jkI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pKo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jkI::P64;
           _s1jkz::P64 = P64[_s1jkI::P64 + 16];
           _s1jkB::P64 = P64[_s1jkI::P64 + 24];
           _s1jkC::P64 = P64[_s1jkI::P64 + 32];
           I64[Hp - 24] = sat_s1jkJ_info;
           P64[Hp - 8] = _s1jkB::P64;
           P64[Hp] = _s1jkC::P64;
           R2 = Hp - 24;
           R1 = _s1jkz::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jkN_entry() //  [R1, R2]
         { info_tbl: [(c1pKA,
                       label: sat_s1jkN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pKA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1pKE; else goto c1pKD;
       c1pKE: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1pKD: // global
           _s1jkI::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _s1jkI::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Real.showSigned1_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jkQ_entry() //  [R1]
         { info_tbl: [(c1pKQ,
                       label: sat_s1jkQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pKQ: // global
           _s1jkQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1pKR; else goto c1pKS;
       c1pKS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pKU; else goto c1pKT;
       c1pKU: // global
           HpAlloc = 24;
           goto c1pKR;
       c1pKR: // global
           R1 = _s1jkQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pKT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jkQ::P64;
           _s1jkI::P64 = P64[_s1jkQ::P64 + 16];
           _s1jkO::P64 = P64[_s1jkQ::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s1jkO::P64;
           R2 = Hp - 14;
           R1 = _s1jkI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jkS_entry() //  [R1, R2]
         { info_tbl: [(c1pKX,
                       label: sat_s1jkS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pKX: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1pL1; else goto c1pL0;
       c1pL1: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1pL0: // global
           _s1jkI::P64 = P64[R1 + 7];
           I64[Hp - 72] = sat_s1jkQ_info;
           P64[Hp - 56] = _s1jkI::P64;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = GHC.Real.showSigned1_closure+1;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.showSigned_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1pL2,
                       label: GHC.Real.showSigned_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pL2: // global
           _s1jkB::P64 = R5;
           _s1jkA::P64 = R4;
           _s1jkz::P64 = R3;
           _s1jky::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto c1pL3; else goto c1pL4;
       c1pL4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1pL6; else goto c1pL5;
       c1pL6: // global
           HpAlloc = 48;
           goto c1pL3;
       c1pL3: // global
           R5 = _s1jkB::P64;
           R4 = _s1jkA::P64;
           R3 = _s1jkz::P64;
           R2 = _s1jky::P64;
           R1 = GHC.Real.showSigned_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pL5: // global
           I64[Hp - 40] = $dNum_s1jkC_info;
           P64[Hp - 24] = _s1jky::P64;
           I64[Hp - 16] = sat_s1jkE_info;
           _c1pJI::P64 = Hp - 40;
           P64[Hp] = _c1pJI::P64;
           I64[Sp - 48] = block_c1pJW_info;
           R2 = _s1jky::P64;
           P64[Sp - 40] = _c1pJI::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _s1jkz::P64;
           P64[Sp - 16] = _s1jkA::P64;
           P64[Sp - 8] = _s1jkB::P64;
           Sp = Sp - 48;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pJW() //  [R1]
         { info_tbl: [(c1pJW,
                       label: block_c1pJW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pJW: // global
           I64[Sp] = block_c1pK0_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1pK0() //  [R1]
         { info_tbl: [(c1pK0,
                       label: block_c1pK0_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pK0: // global
           if (R1 & 7 == 1) goto c1pLb; else goto c1pLd;
       c1pLb: // global
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 24];
           Sp = Sp + 48;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       c1pLd: // global
           I64[Sp] = block_c1pK5_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1pLl; else goto c1pK6;
       u1pLl: // global
           call _c1pK5(R1) args: 0, res: 0, upd: 0;
       c1pK6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1pK5() //  [R1]
         { info_tbl: [(c1pK5,
                       label: block_c1pK5_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pK5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1pLg; else goto c1pLf;
       c1pLg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pLf: // global
           _s1jkH::I64 = I64[R1 + 7];
           I64[Hp - 48] = g1_s1jkI_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = P64[Sp + 8];
           _c1pKa::P64 = Hp - 48;
           if (%MO_S_Le_W64(_s1jkH::I64, 6)) goto c1pLi; else goto c1pLj;
       c1pLi: // global
           I64[Hp - 8] = sat_s1jkN_info;
           P64[Hp] = _c1pKa::P64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1pLj: // global
           I64[Hp - 8] = sat_s1jkS_info;
           P64[Hp] = _c1pKa::P64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.825490072 UTC

[section ""data" . GHC.Real.even_closure" {
     GHC.Real.even_closure:
         const GHC.Real.even_info;
         const 0;
 },
 $dNum_s1jkW_entry() //  [R1]
         { info_tbl: [(c1pMt,
                       label: $dNum_s1jkW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pMt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pMu; else goto c1pMv;
       c1pMu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pMv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jl1_entry() //  [R1]
         { info_tbl: [(c1pMA,
                       label: sat_s1jl1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pMA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pMB; else goto c1pMC;
       c1pMB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pMC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jkZ_entry() //  [R1]
         { info_tbl: [(c1pML,
                       label: sat_s1jkZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pML: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pMM; else goto c1pMN;
       c1pMM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pMN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jl0_entry() //  [R1]
         { info_tbl: [(c1pMO,
                       label: sat_s1jl0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pMO: // global
           _s1jl0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1pMP; else goto c1pMQ;
       c1pMQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pMS; else goto c1pMR;
       c1pMS: // global
           HpAlloc = 24;
           goto c1pMP;
       c1pMP: // global
           R1 = _s1jl0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pMR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jl0::P64;
           _s1jkT::P64 = P64[_s1jl0::P64 + 16];
           _s1jkU::P64 = P64[_s1jl0::P64 + 24];
           _s1jkW::P64 = P64[_s1jl0::P64 + 32];
           I64[Hp - 16] = sat_s1jkZ_info;
           P64[Hp] = _s1jkW::P64;
           R2 = _s1jkT::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1jkU::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Real.rem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.even_entry() //  [R2, R3]
         { info_tbl: [(c1pMT,
                       label: GHC.Real.even_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pMT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1pMZ; else goto c1pN0;
       c1pMZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.even_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pN0: // global
           I64[Sp - 24] = block_c1pMl_info;
           _s1jkT::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1jkT::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pMl() //  [R1]
         { info_tbl: [(c1pMl,
                       label: block_c1pMl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pMl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1pN3; else goto c1pN2;
       c1pN3: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pN2: // global
           I64[Hp - 80] = $dNum_s1jkW_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_s1jl1_info;
           _c1pMp::P64 = Hp - 80;
           P64[Hp - 40] = _c1pMp::P64;
           I64[Hp - 32] = sat_s1jl0_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _c1pMp::P64;
           I64[Sp] = block_c1pMU_info;
           R2 = R1;
           P64[Sp + 8] = Hp - 32;
           P64[Sp + 16] = Hp - 56;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pMU() //  [R1]
         { info_tbl: [(c1pMU,
                       label: block_c1pMU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pMU: // global
           I64[Sp] = block_c1pMY_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pMY() //  [R1]
         { info_tbl: [(c1pMY,
                       label: block_c1pMY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pMY: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.843093808 UTC

[section ""data" . GHC.Real.odd_closure" {
     GHC.Real.odd_closure:
         const GHC.Real.odd_info;
         const 0;
 },
 GHC.Real.odd_entry() //  [R2, R3]
         { info_tbl: [(c1pNS,
                       label: GHC.Real.odd_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pNS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1pNT; else goto c1pNU;
       c1pNT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.odd_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pNU: // global
           I64[Sp - 8] = block_c1pNM_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pNM() //  [R1]
         { info_tbl: [(c1pNM,
                       label: block_c1pNM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pNM: // global
           if (R1 & 7 == 1) goto c1pNP; else goto c1pNQ;
       c1pNP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1pNQ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.848546289 UTC

[section ""data" . lvl3_r1j3b_closure" {
     lvl3_r1j3b_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.even2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.850313842 UTC

[section ""cstring" . lvl4_r1j3c_bytes" {
     lvl4_r1j3c_bytes:
         I8[] [114,111,117,110,100,32,100,101,102,97,117,108,116,32,100,101,102,110,58,32,66,97,100,32,118,97,108,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.852432519 UTC

[section ""data" . GHC.Real.$fRealFracRatio1_closure" {
     GHC.Real.$fRealFracRatio1_closure:
         const GHC.Real.$fRealFracRatio1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fRealFracRatio1_entry() //  [R1]
         { info_tbl: [(c1pOn,
                       label: GHC.Real.$fRealFracRatio1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pOn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1pOo; else goto c1pOp;
       c1pOo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pOp: // global
           (_c1pOi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1pOi::I64 == 0) goto c1pOk; else goto c1pOj;
       c1pOk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1pOj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1pOi::I64;
           I64[Sp - 24] = block_c1pOl_info;
           R2 = lvl4_r1j3c_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pOl() //  [R1]
         { info_tbl: [(c1pOl,
                       label: block_c1pOl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pOl: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.862223312 UTC

[section ""data" . GHC.Real.$dmround_closure" {
     GHC.Real.$dmround_closure:
         const GHC.Real.$dmround_info;
         const 0;
 },
 ds_s1jl9_entry() //  [R1]
         { info_tbl: [(c1pOL,
                       label: ds_s1jl9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pOL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1pOM; else goto c1pON;
       c1pOM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pON: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.properFraction_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $dNum_s1jld_entry() //  [R1]
         { info_tbl: [(c1pP4,
                       label: $dNum_s1jld_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pP4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pP5; else goto c1pP6;
       c1pP5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pP6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jll_entry() //  [R1]
         { info_tbl: [(c1pPm,
                       label: sat_s1jll_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pPm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pPn; else goto c1pPo;
       c1pPn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pPo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1pPk_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p2RealFrac_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pPk() //  [R1]
         { info_tbl: [(c1pPk,
                       label: block_c1pPk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pPk: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = lvl3_r1j3b_closure+1;
           Sp = Sp - 8;
           call GHC.Real.fromRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlj_entry() //  [R1]
         { info_tbl: [(c1pPw,
                       label: sat_s1jlj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pPw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pPx; else goto c1pPy;
       c1pPx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pPy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlm_entry() //  [R1]
         { info_tbl: [(c1pPz,
                       label: sat_s1jlm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pPz: // global
           _s1jlm::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1pPA; else goto c1pPB;
       c1pPB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1pPD; else goto c1pPC;
       c1pPD: // global
           HpAlloc = 56;
           goto c1pPA;
       c1pPA: // global
           R1 = _s1jlm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pPC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jlm::P64;
           _s1jl6::P64 = P64[_s1jlm::P64 + 16];
           _s1jld::P64 = P64[_s1jlm::P64 + 24];
           _s1jle::P64 = P64[_s1jlm::P64 + 32];
           I64[Hp - 48] = sat_s1jll_info;
           P64[Hp - 32] = _s1jl6::P64;
           I64[Hp - 24] = sat_s1jlj_info;
           P64[Hp - 8] = _s1jld::P64;
           P64[Hp] = _s1jle::P64;
           R2 = _s1jld::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds1_s1jli_entry() //  [R1]
         { info_tbl: [(c1pPE,
                       label: ds1_s1jli_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pPE: // global
           _s1jli::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1pPF; else goto c1pPG;
       c1pPG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1pPI; else goto c1pPH;
       c1pPI: // global
           HpAlloc = 40;
           goto c1pPF;
       c1pPF: // global
           R1 = _s1jli::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pPH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jli::P64;
           _s1jl6::P64 = P64[_s1jli::P64 + 16];
           _s1jld::P64 = P64[_s1jli::P64 + 24];
           _s1jle::P64 = P64[_s1jli::P64 + 32];
           I64[Hp - 32] = sat_s1jlm_info;
           P64[Hp - 16] = _s1jl6::P64;
           P64[Hp - 8] = _s1jld::P64;
           P64[Hp] = _s1jle::P64;
           R2 = _s1jld::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlr_entry() //  [R1]
         { info_tbl: [(c1pPS,
                       label: sat_s1jlr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pPS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pPT; else goto c1pPU;
       c1pPT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pPU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jls_entry() //  [R1]
         { info_tbl: [(c1pPV,
                       label: sat_s1jls_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pPV: // global
           _s1jls::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1pPW; else goto c1pPX;
       c1pPX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pPZ; else goto c1pPY;
       c1pPZ: // global
           HpAlloc = 24;
           goto c1pPW;
       c1pPW: // global
           R1 = _s1jls::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pPY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jls::P64;
           _s1jld::P64 = P64[_s1jls::P64 + 16];
           I64[Hp - 16] = sat_s1jlr_info;
           P64[Hp] = _s1jld::P64;
           R2 = _s1jld::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlB_entry() //  [R1]
         { info_tbl: [(c1pQ8,
                       label: sat_s1jlB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pQ8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pQ9; else goto c1pQa;
       c1pQ9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pQa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlx_entry() //  [R1]
         { info_tbl: [(c1pQs,
                       label: sat_s1jlx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pQs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pQt; else goto c1pQu;
       c1pQt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pQu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlz_entry() //  [R1]
         { info_tbl: [(c1pQD,
                       label: sat_s1jlz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pQD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pQE; else goto c1pQF;
       c1pQE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pQF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlA_entry() //  [R1]
         { info_tbl: [(c1pQM,
                       label: sat_s1jlA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pQM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pQN; else goto c1pQO;
       c1pQN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pQO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jlD_entry() //  [R1]
         { info_tbl: [(c1pQX,
                       label: sat_s1jlD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pQX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pQY; else goto c1pQZ;
       c1pQY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pQZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmround_entry() //  [R2, R3, R4]
         { info_tbl: [(c1pR0,
                       label: GHC.Real.$dmround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pR0: // global
           _s1jl8::P64 = R4;
           _s1jl7::P64 = R3;
           _s1jl6::P64 = R2;
           if ((Sp + -88) < SpLim) (likely: False) goto c1pR1; else goto c1pR2;
       c1pR2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1pR4; else goto c1pR3;
       c1pR4: // global
           HpAlloc = 40;
           goto c1pR1;
       c1pR1: // global
           R4 = _s1jl8::P64;
           R3 = _s1jl7::P64;
           R2 = _s1jl6::P64;
           R1 = GHC.Real.$dmround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pR3: // global
           I64[Hp - 32] = ds_s1jl9_info;
           P64[Hp - 16] = _s1jl6::P64;
           P64[Hp - 8] = _s1jl7::P64;
           P64[Hp] = _s1jl8::P64;
           I64[Sp - 32] = block_c1pOO_info;
           R2 = _s1jl6::P64;
           P64[Sp - 24] = Hp - 32;
           P64[Sp - 16] = _s1jl6::P64;
           P64[Sp - 8] = _s1jl7::P64;
           Sp = Sp - 32;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pOO() //  [R1]
         { info_tbl: [(c1pOO,
                       label: block_c1pOO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pOO: // global
           I64[Sp - 8] = block_c1pOS_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pOS() //  [R1]
         { info_tbl: [(c1pOS,
                       label: block_c1pOS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pOS: // global
           I64[Sp - 8] = block_c1pOW_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pOW() //  [R1]
         { info_tbl: [(c1pOW,
                       label: block_c1pOW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pOW: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c1pR9; else goto c1pR8;
       c1pR9: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pR8: // global
           I64[Hp - 128] = $dNum_s1jld_info;
           P64[Hp - 112] = P64[Sp + 16];
           I64[Hp - 104] = stg_sel_1_upd_info;
           _c1pOH::P64 = P64[Sp + 24];
           P64[Hp - 88] = _c1pOH::P64;
           I64[Hp - 80] = ds1_s1jli_info;
           P64[Hp - 64] = P64[Sp + 32];
           _c1pP0::P64 = Hp - 128;
           P64[Hp - 56] = _c1pP0::P64;
           _c1pP7::P64 = Hp - 104;
           P64[Hp - 48] = _c1pP7::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1pOH::P64;
           I64[Hp - 16] = sat_s1jls_info;
           P64[Hp] = _c1pP0::P64;
           I64[Sp - 16] = block_c1pQ0_info;
           R2 = R1;
           I64[Sp - 40] = stg_ap_pp_info;
           _c1pP8::P64 = Hp - 80;
           P64[Sp - 32] = _c1pP8::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 40;
           P64[Sp + 16] = _c1pP8::P64;
           P64[Sp + 24] = _c1pP7::P64;
           P64[Sp + 32] = _c1pP0::P64;
           Sp = Sp - 40;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1pQ0() //  [R1]
         { info_tbl: [(c1pQ0,
                       label: block_c1pQ0_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pQ0: // global
           if (R1 & 7 == 1) goto c1pRb; else goto u1pS7;
       c1pRb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pRe; else goto c1pRd;
       c1pRe: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pRd: // global
           I64[Hp - 16] = sat_s1jlB_info;
           P64[Hp] = P64[Sp + 48];
           I64[Sp] = block_c1pQP_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       u1pS7: // global
           Sp = Sp + 16;
           call _c1pS1() args: 0, res: 0, upd: 0;
     }
 },
 _c1pQP() //  [R1]
         { info_tbl: [(c1pQP,
                       label: block_c1pQP_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pQP: // global
           if (R1 & 7 == 1) goto c1pRv; else goto c1pRN;
       c1pRv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pRy; else goto c1pRx;
       c1pRy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pRx: // global
           I64[Hp - 16] = sat_s1jlD_info;
           P64[Hp] = P64[Sp + 48];
           _s1jlc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1pRt_info;
           R2 = _s1jlc::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c1pRN: // global
           I64[Sp + 8] = block_c1pRL_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 56];
           Sp = Sp + 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pRt() //  [R1]
         { info_tbl: [(c1pRt,
                       label: block_c1pRt_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pRt: // global
           if (R1 & 7 == 1) goto c1pRE; else goto u1pSa;
       c1pRE: // global
           R1 = GHC.Real.$fRealFracRatio1_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       u1pSa: // global
           Sp = Sp + 8;
           call _s1jlu() args: 0, res: 0, upd: 0;
     }
 },
 _c1pRL() //  [R1]
         { info_tbl: [(c1pRL,
                       label: block_c1pRL_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pRL: // global
           if (R1 & 7 == 1) goto u1pS8; else goto u1pS9;
       u1pS8: // global
           Sp = Sp + 8;
           call _s1jlu() args: 0, res: 0, upd: 0;
       u1pS9: // global
           Sp = Sp + 8;
           call _c1pS1() args: 0, res: 0, upd: 0;
     }
 },
 _s1jlu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jlu: // global
           I64[Sp - 8] = block_c1pQg_info;
           R2 = P64[Sp + 40];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pQg() //  [R1]
         { info_tbl: [(c1pQg,
                       label: block_c1pQg_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pQg: // global
           I64[Sp] = block_c1pQk_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pQk() //  [R1]
         { info_tbl: [(c1pQk,
                       label: block_c1pQk_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pQk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pRj; else goto c1pRi;
       c1pRj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pRi: // global
           I64[Hp - 16] = sat_s1jlx_info;
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_c1pQv_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 48] = R1;
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1pQv() //  [R1]
         { info_tbl: [(c1pQv,
                       label: block_c1pQv_info
                       rep:StackRep [False, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pQv: // global
           _c1pPJ::P64 = P64[Sp + 8];
           _s1jlw::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto c1pRl; else goto c1pRp;
       c1pRl: // global
           Hp = Hp + 24;
           _s1jly::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1pRs; else goto c1pRn;
       c1pRn: // global
           I64[Hp - 16] = sat_s1jlz_info;
           P64[Hp] = _s1jlw::P64;
           R2 = _s1jlw::P64;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = _c1pPJ::P64;
           P64[Sp + 48] = Hp - 16;
           Sp = Sp + 32;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
       c1pRp: // global
           Hp = Hp + 24;
           _s1jly::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1pRs; else goto c1pRr;
       c1pRs: // global
           HpAlloc = 24;
           R1 = _s1jly::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pRr: // global
           I64[Hp - 16] = sat_s1jlA_info;
           P64[Hp] = _s1jlw::P64;
           R2 = _s1jlw::P64;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = _c1pPJ::P64;
           P64[Sp + 48] = Hp - 16;
           Sp = Sp + 32;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _c1pS1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pS1: // global
           R1 = P64[Sp];
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.918030744 UTC

[section ""data" . GHC.Real.integralEnumFrom_closure" {
     GHC.Real.integralEnumFrom_closure:
         const GHC.Real.integralEnumFrom_info;
         const 0;
 },
 f_s1jlJ_entry() //  [R1]
         { info_tbl: [(c1pUq,
                       label: f_s1jlJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pUq: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jlK_entry() //  [R1]
         { info_tbl: [(c1pUx,
                       label: f1_s1jlK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pUx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pUy; else goto c1pUz;
       c1pUy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pUz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jlM_entry() //  [R1]
         { info_tbl: [(c1pUE,
                       label: sat_s1jlM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pUE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pUF; else goto c1pUG;
       c1pUF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pUG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jlS_entry() //  [R1]
         { info_tbl: [(c1pV0,
                       label: sat_s1jlS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pV0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pV1; else goto c1pV2;
       c1pV1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pV2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1pUY_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pUY() //  [R1]
         { info_tbl: [(c1pUY,
                       label: block_c1pUY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pUY: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jlN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jlQ_entry() //  [R1]
         { info_tbl: [(c1pVa,
                       label: sat_s1jlQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pVa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pVb; else goto c1pVc;
       c1pVb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pVc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jlN_entry() //  [R1, R2]
         { info_tbl: [(c1pVg,
                       label: go_s1jlN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pVg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pVh; else goto c1pVi;
       c1pVh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1pVi: // global
           I64[Sp - 32] = block_c1pUQ_info;
           R3 = P64[R1 + 15];
           _s1jlO::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jlO::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pUQ() //  [R1]
         { info_tbl: [(c1pUQ,
                       label: block_c1pUQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pUQ: // global
           if (R1 == 1) goto c1pVf; else goto c1pVe;
       c1pVf: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1pVe: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1pVm; else goto c1pVl;
       c1pVm: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1pVl: // global
           I64[Hp - 80] = sat_s1jlS_info;
           P64[Hp - 64] = P64[Sp + 16];
           _s1jlO::P64 = P64[Sp + 24];
           P64[Hp - 56] = _s1jlO::P64;
           I64[Hp - 48] = sat_s1jlQ_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s1jlO::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1pVD_srtd" {
     u1pVD_srtd:
         const S1jKw_srt+480;
         const 34;
         const 8589935105;
 },
 GHC.Real.integralEnumFrom_entry() //  [R2, R3, R4]
         { info_tbl: [(c1pVq,
                       label: GHC.Real.integralEnumFrom_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pVq: // global
           _s1jlI::P64 = R4;
           _s1jlH::P64 = R3;
           _s1jlG::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1pVs; else goto c1pVt;
       c1pVt: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1pVv; else goto c1pVu;
       c1pVv: // global
           HpAlloc = 72;
           goto c1pVs;
       c1pVs: // global
           R4 = _s1jlI::P64;
           R3 = _s1jlH::P64;
           R2 = _s1jlG::P64;
           R1 = GHC.Real.integralEnumFrom_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1pVu: // global
           I64[Hp - 64] = f_s1jlJ_info;
           P64[Hp - 48] = _s1jlG::P64;
           I64[Hp - 40] = f1_s1jlK_info;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = sat_s1jlM_info;
           P64[Hp] = _s1jlH::P64;
           I64[Sp - 32] = block_c1pUH_info;
           R2 = _s1jlG::P64;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = _s1jlG::P64;
           P64[Sp - 8] = _s1jlI::P64;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1pUH() //  [R1]
         { info_tbl: [(c1pUH,
                       label: block_c1pUH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pUH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1pVy; else goto c1pVx;
       c1pVy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1pVx: // global
           I64[Hp - 16] = go_s1jlN_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           _s1jlG::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1pVr_info;
           R2 = _s1jlG::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 15;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1pVr() //  [R1]
         { info_tbl: [(c1pVr,
                       label: block_c1pVr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pVr: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jlN_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:04.947986668 UTC

[section ""data" . GHC.Real.integralEnumFromThen_closure" {
     GHC.Real.integralEnumFromThen_closure:
         const GHC.Real.integralEnumFromThen_info;
         const 0;
 },
 f_s1jm2_entry() //  [R1]
         { info_tbl: [(c1pWW,
                       label: f_s1jm2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pWW: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jm3_entry() //  [R1]
         { info_tbl: [(c1pX3,
                       label: f1_s1jm3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pX3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pX4; else goto c1pX5;
       c1pX4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pX5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jm6_entry() //  [R1]
         { info_tbl: [(c1pXe,
                       label: sat_s1jm6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pXe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pXf; else goto c1pXg;
       c1pXf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pXg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmc_entry() //  [R1]
         { info_tbl: [(c1pXA,
                       label: sat_s1jmc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pXA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pXB; else goto c1pXC;
       c1pXB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pXC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1pXy_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pXy() //  [R1]
         { info_tbl: [(c1pXy,
                       label: block_c1pXy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pXy: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jm7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jma_entry() //  [R1]
         { info_tbl: [(c1pXK,
                       label: sat_s1jma_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pXK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pXL; else goto c1pXM;
       c1pXL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pXM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jm7_entry() //  [R1, R2]
         { info_tbl: [(c1pXQ,
                       label: go_s1jm7_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pXQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1pXR; else goto c1pXS;
       c1pXR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1pXS: // global
           I64[Sp - 40] = block_c1pXq_info;
           R3 = P64[R1 + 23];
           _s1jm8::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jm8::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pXq() //  [R1]
         { info_tbl: [(c1pXq,
                       label: block_c1pXq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pXq: // global
           if (R1 == 1) goto c1pXP; else goto c1pXO;
       c1pXP: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1pXO: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1pXW; else goto c1pXV;
       c1pXW: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1pXV: // global
           I64[Hp - 88] = sat_s1jmc_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jm8::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jm8::P64;
           I64[Hp - 48] = sat_s1jma_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jm8::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jme_entry() //  [R1]
         { info_tbl: [(c1pY6,
                       label: sat_s1jme_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pY6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pY7; else goto c1pY8;
       c1pY7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pY8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmk_entry() //  [R1]
         { info_tbl: [(c1pYs,
                       label: sat_s1jmk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pYs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pYt; else goto c1pYu;
       c1pYt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pYu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1pYq_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pYq() //  [R1]
         { info_tbl: [(c1pYq,
                       label: block_c1pYq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pYq: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmf_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmi_entry() //  [R1]
         { info_tbl: [(c1pYC,
                       label: sat_s1jmi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pYC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pYD; else goto c1pYE;
       c1pYD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pYE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jmf_entry() //  [R1, R2]
         { info_tbl: [(c1pYI,
                       label: go_s1jmf_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pYI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1pYJ; else goto c1pYK;
       c1pYJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1pYK: // global
           I64[Sp - 40] = block_c1pYi_info;
           R3 = P64[R1 + 23];
           _s1jmg::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jmg::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pYi() //  [R1]
         { info_tbl: [(c1pYi,
                       label: block_c1pYi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pYi: // global
           if (R1 == 1) goto c1pYH; else goto c1pYG;
       c1pYH: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1pYG: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1pYO; else goto c1pYN;
       c1pYO: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1pYN: // global
           I64[Hp - 88] = sat_s1jmk_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jmg::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jmg::P64;
           I64[Hp - 48] = sat_s1jmi_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jmg::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 f_s1jmm_entry() //  [R1]
         { info_tbl: [(c1pZ2,
                       label: f_s1jmm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pZ2: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jmn_entry() //  [R1]
         { info_tbl: [(c1pZ9,
                       label: f1_s1jmn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pZ9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pZa; else goto c1pZb;
       c1pZa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pZb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmq_entry() //  [R1]
         { info_tbl: [(c1pZk,
                       label: sat_s1jmq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pZk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1pZl; else goto c1pZm;
       c1pZl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pZm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmw_entry() //  [R1]
         { info_tbl: [(c1pZG,
                       label: sat_s1jmw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pZG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pZH; else goto c1pZI;
       c1pZH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pZI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1pZE_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1pZE() //  [R1]
         { info_tbl: [(c1pZE,
                       label: block_c1pZE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pZE: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmr_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmu_entry() //  [R1]
         { info_tbl: [(c1pZQ,
                       label: sat_s1jmu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pZQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1pZR; else goto c1pZS;
       c1pZR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pZS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jmr_entry() //  [R1, R2]
         { info_tbl: [(c1pZW,
                       label: go_s1jmr_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pZW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1pZX; else goto c1pZY;
       c1pZX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1pZY: // global
           I64[Sp - 40] = block_c1pZw_info;
           R3 = P64[R1 + 23];
           _s1jms::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jms::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pZw() //  [R1]
         { info_tbl: [(c1pZw,
                       label: block_c1pZw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pZw: // global
           if (R1 == 1) goto c1pZV; else goto c1pZU;
       c1pZV: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1pZU: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1q02; else goto c1q01;
       c1q02: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1q01: // global
           I64[Hp - 88] = sat_s1jmw_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jms::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jms::P64;
           I64[Hp - 48] = sat_s1jmu_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jms::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jmy_entry() //  [R1]
         { info_tbl: [(c1q0c,
                       label: sat_s1jmy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q0c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1q0d; else goto c1q0e;
       c1q0d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1q0e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmE_entry() //  [R1]
         { info_tbl: [(c1q0y,
                       label: sat_s1jmE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q0y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1q0z; else goto c1q0A;
       c1q0z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1q0A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1q0w_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1q0w() //  [R1]
         { info_tbl: [(c1q0w,
                       label: block_c1q0w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q0w: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmC_entry() //  [R1]
         { info_tbl: [(c1q0I,
                       label: sat_s1jmC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q0I: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1q0J; else goto c1q0K;
       c1q0J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1q0K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jmz_entry() //  [R1, R2]
         { info_tbl: [(c1q0O,
                       label: go_s1jmz_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q0O: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1q0P; else goto c1q0Q;
       c1q0P: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1q0Q: // global
           I64[Sp - 40] = block_c1q0o_info;
           R3 = P64[R1 + 23];
           _s1jmA::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jmA::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1q0o() //  [R1]
         { info_tbl: [(c1q0o,
                       label: block_c1q0o_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q0o: // global
           if (R1 == 1) goto c1q0N; else goto c1q0M;
       c1q0N: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1q0M: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1q0U; else goto c1q0T;
       c1q0U: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1q0T: // global
           I64[Hp - 88] = sat_s1jmE_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jmA::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jmA::P64;
           I64[Hp - 48] = sat_s1jmC_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jmA::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1q1I_srtd" {
     u1q1I_srtd:
         const S1jKw_srt+456;
         const 39;
         const 412585295873;
 },
 GHC.Real.integralEnumFromThen_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1q0Y,
                       label: GHC.Real.integralEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q0Y: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1q0Z; else goto c1q10;
       c1q0Z: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.integralEnumFromThen_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1q10: // global
           I64[Sp - 32] = block_c1pWC_info;
           _s1jlU::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s1jlU::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1q1J_srtd" {
     u1q1J_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1pWC() //  [R1]
         { info_tbl: [(c1pWC,
                       label: block_c1pWC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pWC: // global
           I64[Sp] = block_c1pWG_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1q1K_srtd" {
     u1q1K_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1pWG() //  [R1]
         { info_tbl: [(c1pWG,
                       label: block_c1pWG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pWG: // global
           I64[Sp - 8] = block_c1pWK_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1q1L_srtd" {
     u1q1L_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1pWK() //  [R1]
         { info_tbl: [(c1pWK,
                       label: block_c1pWK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pWK: // global
           _s1jlY::P64 = P64[Sp + 32];
           _s1jlZ::P64 = P64[Sp + 8];
           if (R1 == 1) goto c1q1p; else goto c1q15;
       c1q1p: // global
           I64[Sp] = block_c1pYU_info;
           R3 = _s1jlZ::P64;
           R2 = _s1jlY::P64;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       c1q15: // global
           I64[Sp] = block_c1pWO_info;
           R3 = _s1jlZ::P64;
           R2 = _s1jlY::P64;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pYU() //  [R1]
         { info_tbl: [(c1pYU,
                       label: block_c1pYU_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pYU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1q1s; else goto c1q1r;
       c1q1s: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1q1r: // global
           I64[Hp - 40] = f_s1jmm_info;
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = f1_s1jmn_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_c1pZc_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp] = R1;
           P64[Sp + 32] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pZc() //  [R1]
         { info_tbl: [(c1pZc,
                       label: block_c1pZc_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pZc: // global
           _s1jlU::P64 = P64[Sp + 24];
           _s1jlV::P64 = P64[Sp + 32];
           if (R1 == 1) goto c1q1B; else goto c1q1u;
       c1q1B: // global
           Hp = Hp + 24;
           _s1jmo::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1q1E; else goto c1q1D;
       c1q1D: // global
           I64[Hp - 16] = sat_s1jmy_info;
           P64[Hp] = _s1jlV::P64;
           I64[Sp] = block_c1q0f_info;
           R2 = _s1jlU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c1q1u: // global
           Hp = Hp + 24;
           _s1jmo::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1q1E; else goto c1q1w;
       c1q1E: // global
           HpAlloc = 24;
           R1 = _s1jmo::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1q1w: // global
           I64[Hp - 16] = sat_s1jmq_info;
           P64[Hp] = _s1jlV::P64;
           I64[Sp] = block_c1pZn_info;
           R2 = _s1jlU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1q0f() //  [R1]
         { info_tbl: [(c1q0f,
                       label: block_c1q0f_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q0f: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1q1H; else goto c1q1G;
       c1q1H: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1q1G: // global
           I64[Hp - 24] = go_s1jmz_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jmz_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1pZn() //  [R1]
         { info_tbl: [(c1pZn,
                       label: block_c1pZn_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pZn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1q1A; else goto c1q1z;
       c1q1A: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1q1z: // global
           I64[Hp - 24] = go_s1jmr_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jmr_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1pWO() //  [R1]
         { info_tbl: [(c1pWO,
                       label: block_c1pWO_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pWO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1q18; else goto c1q17;
       c1q18: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1q17: // global
           I64[Hp - 40] = f_s1jm2_info;
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = f1_s1jm3_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_c1pX6_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp] = R1;
           P64[Sp + 32] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1pX6() //  [R1]
         { info_tbl: [(c1pX6,
                       label: block_c1pX6_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pX6: // global
           _s1jlU::P64 = P64[Sp + 24];
           _s1jlV::P64 = P64[Sp + 32];
           if (R1 == 1) goto c1q1h; else goto c1q1a;
       c1q1h: // global
           Hp = Hp + 24;
           _s1jm4::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1q1k; else goto c1q1j;
       c1q1j: // global
           I64[Hp - 16] = sat_s1jme_info;
           P64[Hp] = _s1jlV::P64;
           I64[Sp] = block_c1pY9_info;
           R2 = _s1jlU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c1q1a: // global
           Hp = Hp + 24;
           _s1jm4::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1q1k; else goto c1q1c;
       c1q1k: // global
           HpAlloc = 24;
           R1 = _s1jm4::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1q1c: // global
           I64[Hp - 16] = sat_s1jm6_info;
           P64[Hp] = _s1jlV::P64;
           I64[Sp] = block_c1pXh_info;
           R2 = _s1jlU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1pY9() //  [R1]
         { info_tbl: [(c1pY9,
                       label: block_c1pY9_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pY9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1q1n; else goto c1q1m;
       c1q1n: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1q1m: // global
           I64[Hp - 24] = go_s1jmf_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jmf_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1pXh() //  [R1]
         { info_tbl: [(c1pXh,
                       label: block_c1pXh_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1pXh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1q1g; else goto c1q1f;
       c1q1g: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1q1f: // global
           I64[Hp - 24] = go_s1jm7_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jm7_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.03040722 UTC

[section ""data" . GHC.Real.integralEnumFromTo_closure" {
     GHC.Real.integralEnumFromTo_closure:
         const GHC.Real.integralEnumFromTo_info;
         const 0;
 },
 f_s1jmI_entry() //  [R1]
         { info_tbl: [(c1q5f,
                       label: f_s1jmI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q5f: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jmJ_entry() //  [R1]
         { info_tbl: [(c1q5m,
                       label: f1_s1jmJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q5m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1q5n; else goto c1q5o;
       c1q5n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1q5o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmQ_entry() //  [R1]
         { info_tbl: [(c1q5I,
                       label: sat_s1jmQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q5I: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1q5J; else goto c1q5K;
       c1q5J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1q5K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1q5G_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1q5G() //  [R1]
         { info_tbl: [(c1q5G,
                       label: block_c1q5G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q5G: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmL_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jmO_entry() //  [R1]
         { info_tbl: [(c1q5S,
                       label: sat_s1jmO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q5S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1q5T; else goto c1q5U;
       c1q5T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1q5U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jmL_entry() //  [R1, R2]
         { info_tbl: [(c1q5Y,
                       label: go_s1jmL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q5Y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1q5Z; else goto c1q60;
       c1q5Z: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1q60: // global
           I64[Sp - 32] = block_c1q5y_info;
           R3 = P64[R1 + 15];
           _s1jmM::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jmM::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1q5y() //  [R1]
         { info_tbl: [(c1q5y,
                       label: block_c1q5y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q5y: // global
           if (R1 == 1) goto c1q5X; else goto c1q5W;
       c1q5X: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1q5W: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1q64; else goto c1q63;
       c1q64: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1q63: // global
           I64[Hp - 80] = sat_s1jmQ_info;
           P64[Hp - 64] = P64[Sp + 16];
           _s1jmM::P64 = P64[Sp + 24];
           P64[Hp - 56] = _s1jmM::P64;
           I64[Hp - 48] = sat_s1jmO_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s1jmM::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.integralEnumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c1q68,
                       label: GHC.Real.integralEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q68: // global
           _s1jmH::P64 = R4;
           _s1jmG::P64 = R3;
           _s1jmF::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1q6a; else goto c1q6b;
       c1q6b: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1q6d; else goto c1q6c;
       c1q6d: // global
           HpAlloc = 48;
           goto c1q6a;
       c1q6a: // global
           R4 = _s1jmH::P64;
           R3 = _s1jmG::P64;
           R2 = _s1jmF::P64;
           R1 = GHC.Real.integralEnumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1q6c: // global
           I64[Hp - 40] = f_s1jmI_info;
           P64[Hp - 24] = _s1jmF::P64;
           I64[Hp - 16] = f1_s1jmJ_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 32] = block_c1q5p_info;
           R2 = _s1jmF::P64;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = _s1jmH::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _s1jmF::P64;
           P64[Sp - 8] = _s1jmG::P64;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1q5p() //  [R1]
         { info_tbl: [(c1q5p,
                       label: block_c1q5p_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q5p: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1q6g; else goto c1q6f;
       c1q6g: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1q6f: // global
           I64[Hp - 16] = go_s1jmL_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           _s1jmF::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1q69_info;
           R2 = _s1jmF::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 15;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1q69() //  [R1]
         { info_tbl: [(c1q69,
                       label: block_c1q69_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q69: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jmL_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.054779757 UTC

[section ""data" . GHC.Real.integralEnumFromThenTo_closure" {
     GHC.Real.integralEnumFromThenTo_closure:
         const GHC.Real.integralEnumFromThenTo_info;
         const 0;
 },
 f_s1jmZ_entry() //  [R1]
         { info_tbl: [(c1q7t,
                       label: f_s1jmZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q7t: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1jn0_entry() //  [R1]
         { info_tbl: [(c1q7A,
                       label: f1_s1jn0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q7A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1q7B; else goto c1q7C;
       c1q7B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1q7C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jn8_entry() //  [R1]
         { info_tbl: [(c1q80,
                       label: sat_s1jn8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q80: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1q81; else goto c1q82;
       c1q81: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1q82: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1q7Y_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1q7Y() //  [R1]
         { info_tbl: [(c1q7Y,
                       label: block_c1q7Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q7Y: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jn3_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jn6_entry() //  [R1]
         { info_tbl: [(c1q8a,
                       label: sat_s1jn6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q8a: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1q8b; else goto c1q8c;
       c1q8b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1q8c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jn3_entry() //  [R1, R2]
         { info_tbl: [(c1q8g,
                       label: go_s1jn3_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q8g: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1q8h; else goto c1q8i;
       c1q8h: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1q8i: // global
           I64[Sp - 40] = block_c1q7Q_info;
           R3 = P64[R1 + 23];
           _s1jn4::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jn4::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1q7Q() //  [R1]
         { info_tbl: [(c1q7Q,
                       label: block_c1q7Q_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q7Q: // global
           if (R1 == 1) goto c1q8f; else goto c1q8e;
       c1q8f: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1q8e: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1q8m; else goto c1q8l;
       c1q8m: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1q8l: // global
           I64[Hp - 88] = sat_s1jn8_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jn4::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jn4::P64;
           I64[Hp - 48] = sat_s1jn6_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jn4::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jnf_entry() //  [R1]
         { info_tbl: [(c1q8L,
                       label: sat_s1jnf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q8L: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1q8M; else goto c1q8N;
       c1q8M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1q8N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1q8J_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1q8J() //  [R1]
         { info_tbl: [(c1q8J,
                       label: block_c1q8J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q8J: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1jna_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jnd_entry() //  [R1]
         { info_tbl: [(c1q8V,
                       label: sat_s1jnd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q8V: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1q8W; else goto c1q8X;
       c1q8W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1q8X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1jna_entry() //  [R1, R2]
         { info_tbl: [(c1q91,
                       label: go_s1jna_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q91: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1q92; else goto c1q93;
       c1q92: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1q93: // global
           I64[Sp - 40] = block_c1q8B_info;
           R3 = P64[R1 + 23];
           _s1jnb::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1jnb::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1q8B() //  [R1]
         { info_tbl: [(c1q8B,
                       label: block_c1q8B_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q8B: // global
           if (R1 == 1) goto c1q90; else goto c1q8Z;
       c1q90: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1q8Z: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1q97; else goto c1q96;
       c1q97: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1q96: // global
           I64[Hp - 88] = sat_s1jnf_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1jnb::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1jnb::P64;
           I64[Hp - 48] = sat_s1jnd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1jnb::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1q9u_srtd" {
     u1q9u_srtd:
         const S1jKw_srt+456;
         const 41;
         const 1237219016705;
 },
 GHC.Real.integralEnumFromThenTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1q9b,
                       label: GHC.Real.integralEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q9b: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1q9c; else goto c1q9d;
       c1q9c: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.integralEnumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1q9d: // global
           I64[Sp - 32] = block_c1q7d_info;
           _s1jmS::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = R3;
           P64[Sp - 24] = _s1jmS::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1q9v_srtd" {
     u1q9v_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1q7d() //  [R1]
         { info_tbl: [(c1q7d,
                       label: block_c1q7d_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q7d: // global
           I64[Sp] = block_c1q7h_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1q9w_srtd" {
     u1q9w_srtd:
         const S1jKw_srt+456;
         const 38;
         const 137707388929;
 },
 _c1q7h() //  [R1]
         { info_tbl: [(c1q7h,
                       label: block_c1q7h_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q7h: // global
           I64[Sp] = block_c1q7l_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1q7l() //  [R1]
         { info_tbl: [(c1q7l,
                       label: block_c1q7l_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q7l: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1q9i; else goto c1q9h;
       c1q9i: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1q9h: // global
           I64[Hp - 40] = f_s1jmZ_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = f1_s1jn0_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 16] = block_c1q7D_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1q7D() //  [R1]
         { info_tbl: [(c1q7D,
                       label: block_c1q7D_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q7D: // global
           _s1jmS::P64 = P64[Sp + 24];
           _s1jmV::P64 = P64[Sp + 40];
           if (R1 == 1) goto c1q9q; else goto c1q9l;
       c1q9q: // global
           I64[Sp] = block_c1q8s_info;
           R2 = _s1jmS::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s1jmV::P64;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c1q9l: // global
           I64[Sp] = block_c1q7H_info;
           R2 = _s1jmS::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s1jmV::P64;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1q8s() //  [R1]
         { info_tbl: [(c1q8s,
                       label: block_c1q8s_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q8s: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1q9t; else goto c1q9s;
       c1q9t: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1q9s: // global
           I64[Hp - 24] = go_s1jna_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = P64[Sp + 32];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jna_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1q7H() //  [R1]
         { info_tbl: [(c1q7H,
                       label: block_c1q7H_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1q7H: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1q9o; else goto c1q9n;
       c1q9o: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1q9n: // global
           I64[Hp - 24] = go_s1jn3_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = P64[Sp + 32];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1jn3_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.094756333 UTC

[section ""cstring" . GHC.Real.$trModule4_bytes" {
     GHC.Real.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.096425212 UTC

[section ""data" . GHC.Real.$trModule3_closure" {
     GHC.Real.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.09809542 UTC

[section ""cstring" . GHC.Real.$trModule2_bytes" {
     GHC.Real.$trModule2_bytes:
         I8[] [71,72,67,46,82,101,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.099663799 UTC

[section ""data" . GHC.Real.$trModule1_closure" {
     GHC.Real.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.101925709 UTC

[section ""data" . GHC.Real.$trModule_closure" {
     GHC.Real.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Real.$trModule3_closure+1;
         const GHC.Real.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.103788058 UTC

[section ""data" . $krep_r1j3d_closure" {
     $krep_r1j3d_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.106126391 UTC

[section ""data" . $krep1_r1j3e_closure" {
     $krep1_r1j3e_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.107764696 UTC

[section ""data" . GHC.Real.$tcFractional1_closure" {
     GHC.Real.$tcFractional1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep1_r1j3e_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.109537319 UTC

[section ""data" . $krep2_r1j3f_closure" {
     $krep2_r1j3f_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.111198812 UTC

[section ""data" . $krep3_r1j3g_closure" {
     $krep3_r1j3g_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep2_r1j3f_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.112905994 UTC

[section ""data" . $krep4_r1j3h_closure" {
     $krep4_r1j3h_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep3_r1j3g_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.114653643 UTC

[section ""data" . $krep5_r1j3i_closure" {
     $krep5_r1j3i_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep_r1j3d_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.116381983 UTC

[section ""data" . $krep6_r1j3j_closure" {
     $krep6_r1j3j_closure:
         const :_con_info;
         const $krep2_r1j3f_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.118201868 UTC

[section ""data" . $krep7_r1j3k_closure" {
     $krep7_r1j3k_closure:
         const :_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.119951634 UTC

[section ""data" . $krep8_r1j3l_closure" {
     $krep8_r1j3l_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep7_r1j3k_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.123386529 UTC

[section ""data" . $krep9_r1j3m_closure" {
     $krep9_r1j3m_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep8_r1j3l_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.12507858 UTC

[section ""data" . $krep10_r1j3n_closure" {
     $krep10_r1j3n_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep9_r1j3m_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.126893584 UTC

[section ""data" . $krep11_r1j3o_closure" {
     $krep11_r1j3o_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Num.$tcNum_closure;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.128654255 UTC

[section ""data" . $krep12_r1j3p_closure" {
     $krep12_r1j3p_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Enum.$tcEnum_closure;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.131032069 UTC

[section ""data" . $krep13_r1j3q_closure" {
     $krep13_r1j3q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Classes.$tcOrd_closure;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.13264927 UTC

[section ""cstring" . GHC.Real.$tcRatio2_bytes" {
     GHC.Real.$tcRatio2_bytes:
         I8[] [82,97,116,105,111]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.134566711 UTC

[section ""data" . GHC.Real.$tcRatio1_closure" {
     GHC.Real.$tcRatio1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcRatio2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.136276641 UTC

[section ""data" . GHC.Real.$tcRatio_closure" {
     GHC.Real.$tcRatio_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcRatio1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 17658523810845794968;
         const 1271393732863050253;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.138121296 UTC

[section ""data" . $krep14_r1j3r_closure" {
     $krep14_r1j3r_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcRatio_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.139824088 UTC

[section ""data" . $krep15_r1j3s_closure" {
     $krep15_r1j3s_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep14_r1j3r_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.141519071 UTC

[section ""data" . GHC.Real.$tc':%1_closure" {
     GHC.Real.$tc':%1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep15_r1j3s_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.143192655 UTC

[section ""cstring" . GHC.Real.$tc':%3_bytes" {
     GHC.Real.$tc':%3_bytes:
         I8[] [39,58,37]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.144819952 UTC

[section ""data" . GHC.Real.$tc':%2_closure" {
     GHC.Real.$tc':%2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc':%3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.146521881 UTC

[section ""data" . GHC.Real.$tc':%_closure" {
     GHC.Real.$tc':%_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc':%2_closure+1;
         const GHC.Real.$tc':%1_closure+4;
         const 11952989868638128372;
         const 6861245286732044789;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.148398858 UTC

[section ""data" . $krep16_r1j3t_closure" {
     $krep16_r1j3t_closure:
         const :_con_info;
         const $krep_r1j3d_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.150897473 UTC

[section ""data" . $krep17_r1j3u_closure" {
     $krep17_r1j3u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcRatio_closure+1;
         const $krep16_r1j3t_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.152731936 UTC

[section ""data" . $krep18_r1j3v_closure" {
     $krep18_r1j3v_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep17_r1j3u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.155033026 UTC

[section ""data" . $krep19_r1j3w_closure" {
     $krep19_r1j3w_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep17_r1j3u_closure+1;
         const $krep2_r1j3f_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.156709465 UTC

[section ""cstring" . GHC.Real.$tcReal2_bytes" {
     GHC.Real.$tcReal2_bytes:
         I8[] [82,101,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.158377299 UTC

[section ""data" . GHC.Real.$tcReal1_closure" {
     GHC.Real.$tcReal1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcReal2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.15999312 UTC

[section ""data" . GHC.Real.$tcReal_closure" {
     GHC.Real.$tcReal_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcReal1_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 1826502536394630182;
         const 14487785779892251413;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.161763346 UTC

[section ""data" . $krep20_r1j3x_closure" {
     $krep20_r1j3x_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcReal_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.163462219 UTC

[section ""data" . $krep21_r1j3y_closure" {
     $krep21_r1j3y_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep18_r1j3v_closure+4;
         const $krep20_r1j3x_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.165161726 UTC

[section ""data" . $krep22_r1j3z_closure" {
     $krep22_r1j3z_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_r1j3q_closure+1;
         const $krep21_r1j3y_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.166876152 UTC

[section ""data" . GHC.Real.$tc'C:Real1_closure" {
     GHC.Real.$tc'C:Real1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1j3o_closure+1;
         const $krep22_r1j3z_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.168570453 UTC

[section ""cstring" . GHC.Real.$tc'C:Real3_bytes" {
     GHC.Real.$tc'C:Real3_bytes:
         I8[] [39,67,58,82,101,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.170281007 UTC

[section ""data" . GHC.Real.$tc'C:Real2_closure" {
     GHC.Real.$tc'C:Real2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc'C:Real3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.171943554 UTC

[section ""data" . GHC.Real.$tc'C:Real_closure" {
     GHC.Real.$tc'C:Real_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc'C:Real2_closure+1;
         const GHC.Real.$tc'C:Real1_closure+4;
         const 5938283050841830427;
         const 8926187074226767634;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.173790403 UTC

[section ""cstring" . GHC.Real.$tcIntegral2_bytes" {
     GHC.Real.$tcIntegral2_bytes:
         I8[] [73,110,116,101,103,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.175396832 UTC

[section ""data" . GHC.Real.$tcIntegral1_closure" {
     GHC.Real.$tcIntegral1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcIntegral2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.177661685 UTC

[section ""data" . GHC.Real.$tcIntegral_closure" {
     GHC.Real.$tcIntegral_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcIntegral1_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 16601157811546713973;
         const 3304955164956033666;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.179497345 UTC

[section ""data" . $krep23_r1j3A_closure" {
     $krep23_r1j3A_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcIntegral_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.181077119 UTC

[section ""data" . $krep24_r1j3B_closure" {
     $krep24_r1j3B_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r1j3i_closure+4;
         const $krep23_r1j3A_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.182847522 UTC

[section ""data" . $krep25_r1j3C_closure" {
     $krep25_r1j3C_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_r1j3n_closure+4;
         const $krep24_r1j3B_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.184560286 UTC

[section ""data" . $krep26_r1j3D_closure" {
     $krep26_r1j3D_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_r1j3n_closure+4;
         const $krep25_r1j3C_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.186312816 UTC

[section ""data" . $krep27_r1j3E_closure" {
     $krep27_r1j3E_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep26_r1j3D_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.187930761 UTC

[section ""data" . $krep28_r1j3F_closure" {
     $krep28_r1j3F_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep27_r1j3E_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.189641752 UTC

[section ""data" . $krep29_r1j3G_closure" {
     $krep29_r1j3G_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep28_r1j3F_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.191323375 UTC

[section ""data" . $krep30_r1j3H_closure" {
     $krep30_r1j3H_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep29_r1j3G_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.192935395 UTC

[section ""data" . $krep31_r1j3I_closure" {
     $krep31_r1j3I_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_r1j3p_closure+1;
         const $krep30_r1j3H_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.194985476 UTC

[section ""data" . GHC.Real.$tc'C:Integral1_closure" {
     GHC.Real.$tc'C:Integral1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep20_r1j3x_closure+1;
         const $krep31_r1j3I_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.196668988 UTC

[section ""cstring" . GHC.Real.$tc'C:Integral3_bytes" {
     GHC.Real.$tc'C:Integral3_bytes:
         I8[] [39,67,58,73,110,116,101,103,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.19834604 UTC

[section ""data" . GHC.Real.$tc'C:Integral2_closure" {
     GHC.Real.$tc'C:Integral2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc'C:Integral3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.200000262 UTC

[section ""data" . GHC.Real.$tc'C:Integral_closure" {
     GHC.Real.$tc'C:Integral_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc'C:Integral2_closure+1;
         const GHC.Real.$tc'C:Integral1_closure+4;
         const 12141017740256829283;
         const 17564033539811245778;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.202854757 UTC

[section ""cstring" . GHC.Real.$tcFractional3_bytes" {
     GHC.Real.$tcFractional3_bytes:
         I8[] [70,114,97,99,116,105,111,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.204482524 UTC

[section ""data" . GHC.Real.$tcFractional2_closure" {
     GHC.Real.$tcFractional2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcFractional3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.206150478 UTC

[section ""data" . GHC.Real.$tcFractional_closure" {
     GHC.Real.$tcFractional_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcFractional2_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 14968870971062750857;
         const 13774835939651899219;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.207888516 UTC

[section ""data" . $krep32_r1j3J_closure" {
     $krep32_r1j3J_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcFractional_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.209641712 UTC

[section ""data" . $krep33_r1j3K_closure" {
     $krep33_r1j3K_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep19_r1j3w_closure+4;
         const $krep32_r1j3J_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.211323071 UTC

[section ""data" . $krep34_r1j3L_closure" {
     $krep34_r1j3L_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r1j3g_closure+4;
         const $krep33_r1j3K_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.213005657 UTC

[section ""data" . $krep35_r1j3M_closure" {
     $krep35_r1j3M_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep34_r1j3L_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.214739612 UTC

[section ""data" . GHC.Real.$tc'C:Fractional1_closure" {
     GHC.Real.$tc'C:Fractional1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1j3o_closure+1;
         const $krep35_r1j3M_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.216411083 UTC

[section ""cstring" . GHC.Real.$tc'C:Fractional3_bytes" {
     GHC.Real.$tc'C:Fractional3_bytes:
         I8[] [39,67,58,70,114,97,99,116,105,111,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.218111791 UTC

[section ""data" . GHC.Real.$tc'C:Fractional2_closure" {
     GHC.Real.$tc'C:Fractional2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc'C:Fractional3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.219825008 UTC

[section ""data" . GHC.Real.$tc'C:Fractional_closure" {
     GHC.Real.$tc'C:Fractional_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc'C:Fractional2_closure+1;
         const GHC.Real.$tc'C:Fractional1_closure+4;
         const 15706435530565718930;
         const 11021884564355505453;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.221690506 UTC

[section ""cstring" . GHC.Real.$tcRealFrac2_bytes" {
     GHC.Real.$tcRealFrac2_bytes:
         I8[] [82,101,97,108,70,114,97,99]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.223287476 UTC

[section ""data" . GHC.Real.$tcRealFrac1_closure" {
     GHC.Real.$tcRealFrac1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcRealFrac2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.226712261 UTC

[section ""data" . GHC.Real.$tcRealFrac_closure" {
     GHC.Real.$tcRealFrac_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcRealFrac1_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 2318913099678420819;
         const 6373121509494083706;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.229537927 UTC

[section ""data" . GHC.Real.$w$c<_closure" {
     GHC.Real.$w$c<_closure:
         const GHC.Real.$w$c<_info;
 },
 $dNum_s1jnm_entry() //  [R1]
         { info_tbl: [(c1qcv,
                       label: $dNum_s1jnm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qcv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qcw; else goto c1qcx;
       c1qcw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qcx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jnp_entry() //  [R1]
         { info_tbl: [(c1qcC,
                       label: sat_s1jnp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qcC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qcD; else goto c1qcE;
       c1qcD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qcE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jno_entry() //  [R1]
         { info_tbl: [(c1qcJ,
                       label: sat_s1jno_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qcJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qcK; else goto c1qcL;
       c1qcK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qcL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1qcM,
                       label: GHC.Real.$w$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qcM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qcO; else goto c1qcP;
       c1qcO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qcP: // global
           I64[Sp - 40] = block_c1qcn_info;
           R2 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qcn() //  [R1]
         { info_tbl: [(c1qcn,
                       label: block_c1qcn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qcn: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c1qcS; else goto c1qcR;
       c1qcS: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1qcR: // global
           I64[Hp - 96] = $dNum_s1jnm_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s1jnp_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           _c1qcr::P64 = Hp - 96;
           P64[Hp - 40] = _c1qcr::P64;
           I64[Hp - 32] = sat_s1jno_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _c1qcr::P64;
           I64[Sp + 16] = block_c1qcN_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qcN() //  [R1]
         { info_tbl: [(c1qcN,
                       label: block_c1qcN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qcN: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.<_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.242834875 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c<_closure" {
     GHC.Real.$fOrdRatio_$c<_closure:
         const GHC.Real.$fOrdRatio_$c<_info;
 },
 GHC.Real.$fOrdRatio_$c<_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qdB,
                       label: GHC.Real.$fOrdRatio_$c<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qdB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qdF; else goto c1qdG;
       c1qdF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qdG: // global
           I64[Sp - 24] = block_c1qdy_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1qdO; else goto c1qdz;
       u1qdO: // global
           call _c1qdy(R1) args: 0, res: 0, upd: 0;
       c1qdz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qdy() //  [R1]
         { info_tbl: [(c1qdy,
                       label: block_c1qdy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qdy: // global
           I64[Sp - 8] = block_c1qdE_info;
           _s1jnu::P64 = P64[R1 + 7];
           _s1jnv::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jnv::P64;
           P64[Sp + 16] = _s1jnu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1qdN; else goto c1qdI;
       u1qdN: // global
           call _c1qdE(R1) args: 0, res: 0, upd: 0;
       c1qdI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qdE() //  [R1]
         { info_tbl: [(c1qdE,
                       label: block_c1qdE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qdE: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.250991629 UTC

[section ""data" . GHC.Real.$w$c<=_closure" {
     GHC.Real.$w$c<=_closure:
         const GHC.Real.$w$c<=_info;
 },
 $dNum_s1jnF_entry() //  [R1]
         { info_tbl: [(c1qee,
                       label: $dNum_s1jnF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qee: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qef; else goto c1qeg;
       c1qef: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qeg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jnI_entry() //  [R1]
         { info_tbl: [(c1qel,
                       label: sat_s1jnI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qel: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qem; else goto c1qen;
       c1qem: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qen: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jnH_entry() //  [R1]
         { info_tbl: [(c1qes,
                       label: sat_s1jnH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qes: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qet; else goto c1qeu;
       c1qet: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qeu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1qev,
                       label: GHC.Real.$w$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qev: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qex; else goto c1qey;
       c1qex: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qey: // global
           I64[Sp - 40] = block_c1qe6_info;
           R2 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qe6() //  [R1]
         { info_tbl: [(c1qe6,
                       label: block_c1qe6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qe6: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c1qeB; else goto c1qeA;
       c1qeB: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1qeA: // global
           I64[Hp - 96] = $dNum_s1jnF_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s1jnI_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           _c1qea::P64 = Hp - 96;
           P64[Hp - 40] = _c1qea::P64;
           I64[Hp - 32] = sat_s1jnH_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _c1qea::P64;
           I64[Sp + 16] = block_c1qew_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qew() //  [R1]
         { info_tbl: [(c1qew,
                       label: block_c1qew_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qew: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.<=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.265647306 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c<=_closure" {
     GHC.Real.$fOrdRatio_$c<=_closure:
         const GHC.Real.$fOrdRatio_$c<=_info;
 },
 GHC.Real.$fOrdRatio_$c<=_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qfk,
                       label: GHC.Real.$fOrdRatio_$c<=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qfk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qfo; else goto c1qfp;
       c1qfo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qfp: // global
           I64[Sp - 24] = block_c1qfh_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1qfx; else goto c1qfi;
       u1qfx: // global
           call _c1qfh(R1) args: 0, res: 0, upd: 0;
       c1qfi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qfh() //  [R1]
         { info_tbl: [(c1qfh,
                       label: block_c1qfh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qfh: // global
           I64[Sp - 8] = block_c1qfn_info;
           _s1jnN::P64 = P64[R1 + 7];
           _s1jnO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jnO::P64;
           P64[Sp + 16] = _s1jnN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1qfw; else goto c1qfr;
       u1qfw: // global
           call _c1qfn(R1) args: 0, res: 0, upd: 0;
       c1qfr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qfn() //  [R1]
         { info_tbl: [(c1qfn,
                       label: block_c1qfn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qfn: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.273575741 UTC

[section ""data" . GHC.Real.$fOrdRatio_$cmax_closure" {
     GHC.Real.$fOrdRatio_$cmax_closure:
         const GHC.Real.$fOrdRatio_$cmax_info;
 },
 GHC.Real.$fOrdRatio_$cmax_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qfS,
                       label: GHC.Real.$fOrdRatio_$cmax_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qfS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qfW; else goto c1qfX;
       c1qfW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qfX: // global
           I64[Sp - 24] = block_c1qfP_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1qgh; else goto c1qfQ;
       u1qgh: // global
           call _c1qfP(R1) args: 0, res: 0, upd: 0;
       c1qfQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qfP() //  [R1]
         { info_tbl: [(c1qfP,
                       label: block_c1qfP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qfP: // global
           I64[Sp - 16] = block_c1qfV_info;
           _s1jnV::P64 = R1;
           _s1jnW::P64 = P64[R1 + 7];
           _s1jnX::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s1jnX::P64;
           P64[Sp] = _s1jnW::P64;
           P64[Sp + 16] = _s1jnV::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1qgg; else goto c1qfZ;
       u1qgg: // global
           call _c1qfV(R1) args: 0, res: 0, upd: 0;
       c1qfZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qfV() //  [R1]
         { info_tbl: [(c1qfV,
                       label: block_c1qfV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qfV: // global
           _s1jnW::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1qg3_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jnW::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qg3() //  [R1]
         { info_tbl: [(c1qg3,
                       label: block_c1qg3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qg3: // global
           if (R1 & 7 == 1) goto c1qga; else goto c1qge;
       c1qga: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1qge: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.284124988 UTC

[section ""data" . GHC.Real.$fOrdRatio_$cmin_closure" {
     GHC.Real.$fOrdRatio_$cmin_closure:
         const GHC.Real.$fOrdRatio_$cmin_info;
 },
 GHC.Real.$fOrdRatio_$cmin_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qgL,
                       label: GHC.Real.$fOrdRatio_$cmin_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qgL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qgP; else goto c1qgQ;
       c1qgP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qgQ: // global
           I64[Sp - 24] = block_c1qgI_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1qha; else goto c1qgJ;
       u1qha: // global
           call _c1qgI(R1) args: 0, res: 0, upd: 0;
       c1qgJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qgI() //  [R1]
         { info_tbl: [(c1qgI,
                       label: block_c1qgI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qgI: // global
           I64[Sp - 16] = block_c1qgO_info;
           _s1jo5::P64 = R1;
           _s1jo6::P64 = P64[R1 + 7];
           _s1jo7::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s1jo7::P64;
           P64[Sp] = _s1jo6::P64;
           P64[Sp + 16] = _s1jo5::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1qh9; else goto c1qgS;
       u1qh9: // global
           call _c1qgO(R1) args: 0, res: 0, upd: 0;
       c1qgS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qgO() //  [R1]
         { info_tbl: [(c1qgO,
                       label: block_c1qgO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qgO: // global
           _s1jo6::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1qgW_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jo6::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qgW() //  [R1]
         { info_tbl: [(c1qgW,
                       label: block_c1qgW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qgW: // global
           if (R1 & 7 == 1) goto c1qh3; else goto c1qh7;
       c1qh3: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1qh7: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.294589905 UTC

[section ""data" . GHC.Real.$w$ccompare_closure" {
     GHC.Real.$w$ccompare_closure:
         const GHC.Real.$w$ccompare_info;
 },
 GHC.Real.$w$ccompare_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1qhD,
                       label: GHC.Real.$w$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qhD: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c1qhL; else goto c1qhM;
       c1qhL: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qhM: // global
           I64[Sp - 48] = block_c1qhB_info;
           _s1joc::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = _s1joc::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qhB() //  [R1]
         { info_tbl: [(c1qhB,
                       label: block_c1qhB_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qhB: // global
           I64[Sp] = block_c1qhG_info;
           R2 = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qhG() //  [R1]
         { info_tbl: [(c1qhG,
                       label: block_c1qhG_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qhG: // global
           I64[Sp] = block_c1qhK_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qhK() //  [R1]
         { info_tbl: [(c1qhK,
                       label: block_c1qhK_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qhK: // global
           I64[Sp - 8] = block_c1qhS_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1qhS() //  [R1]
         { info_tbl: [(c1qhS,
                       label: block_c1qhS_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qhS: // global
           _s1joe::P64 = P64[Sp + 32];
           _s1jog::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto c1qi0; else goto c1qif;
       c1qi0: // global
           I64[Sp + 48] = block_c1qhX_info;
           R6 = _s1jog::P64;
           R5 = P64[Sp + 40];
           R4 = _s1joe::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 48;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
       c1qif: // global
           _s1joj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1qid_info;
           R2 = _s1joj::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s1joe::P64;
           P64[Sp] = _s1jog::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1qhX() //  [R1]
         { info_tbl: [(c1qhX,
                       label: block_c1qhX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qhX: // global
           if (R1 & 7 == 1) goto u1qiH; else goto u1qiI;
       u1qiH: // global
           Sp = Sp + 8;
           call _c1qis() args: 0, res: 0, upd: 0;
       u1qiI: // global
           Sp = Sp + 8;
           call _c1qiw() args: 0, res: 0, upd: 0;
     }
 },
 _c1qid() //  [R1]
         { info_tbl: [(c1qid,
                       label: block_c1qid_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qid: // global
           if (R1 & 7 == 1) goto c1qim; else goto c1qiA;
       c1qim: // global
           _s1jog::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_c1qij_info;
           R6 = _s1jog::P64;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
       c1qiA: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1qij() //  [R1]
         { info_tbl: [(c1qij,
                       label: block_c1qij_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qij: // global
           if (R1 & 7 == 1) goto u1qiF; else goto u1qiG;
       u1qiF: // global
           Sp = Sp + 8;
           call _c1qis() args: 0, res: 0, upd: 0;
       u1qiG: // global
           Sp = Sp + 8;
           call _c1qiw() args: 0, res: 0, upd: 0;
     }
 },
 _c1qis() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qis: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1qiw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qiw: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.313037099 UTC

[section ""data" . GHC.Real.$fOrdRatio_$ccompare_closure" {
     GHC.Real.$fOrdRatio_$ccompare_closure:
         const GHC.Real.$fOrdRatio_$ccompare_info;
 },
 GHC.Real.$fOrdRatio_$ccompare_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qjB,
                       label: GHC.Real.$fOrdRatio_$ccompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qjB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qjF; else goto c1qjG;
       c1qjF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qjG: // global
           I64[Sp - 24] = block_c1qjy_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1qjO; else goto c1qjz;
       u1qjO: // global
           call _c1qjy(R1) args: 0, res: 0, upd: 0;
       c1qjz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qjy() //  [R1]
         { info_tbl: [(c1qjy,
                       label: block_c1qjy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qjy: // global
           I64[Sp - 8] = block_c1qjE_info;
           _s1jos::P64 = P64[R1 + 7];
           _s1jot::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jot::P64;
           P64[Sp + 16] = _s1jos::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1qjN; else goto c1qjI;
       u1qjN: // global
           call _c1qjE(R1) args: 0, res: 0, upd: 0;
       c1qjI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qjE() //  [R1]
         { info_tbl: [(c1qjE,
                       label: block_c1qjE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qjE: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.32065528 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c>_closure" {
     GHC.Real.$fOrdRatio_$c>_closure:
         const GHC.Real.$fOrdRatio_$c>_info;
 },
 GHC.Real.$fOrdRatio_$c>_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qk9,
                       label: GHC.Real.$fOrdRatio_$c>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qk9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qkd; else goto c1qke;
       c1qkd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qke: // global
           I64[Sp - 24] = block_c1qk6_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1qky; else goto c1qk7;
       u1qky: // global
           call _c1qk6(R1) args: 0, res: 0, upd: 0;
       c1qk7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qk6() //  [R1]
         { info_tbl: [(c1qk6,
                       label: block_c1qk6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qk6: // global
           I64[Sp - 8] = block_c1qkc_info;
           _s1joB::P64 = P64[R1 + 7];
           _s1joC::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1joC::P64;
           P64[Sp + 16] = _s1joB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1qkx; else goto c1qkg;
       u1qkx: // global
           call _c1qkc(R1) args: 0, res: 0, upd: 0;
       c1qkg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qkc() //  [R1]
         { info_tbl: [(c1qkc,
                       label: block_c1qkc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qkc: // global
           _s1joB::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1qkk_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1joB::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qkk() //  [R1]
         { info_tbl: [(c1qkk,
                       label: block_c1qkk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qkk: // global
           if (R1 & 7 == 3) goto c1qkv; else goto c1qkr;
       c1qkv: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1qkr: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.330251191 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c>=_closure" {
     GHC.Real.$fOrdRatio_$c>=_closure:
         const GHC.Real.$fOrdRatio_$c>=_info;
 },
 GHC.Real.$fOrdRatio_$c>=_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ql0,
                       label: GHC.Real.$fOrdRatio_$c>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ql0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ql4; else goto c1ql5;
       c1ql4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ql5: // global
           I64[Sp - 24] = block_c1qkX_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1qlp; else goto c1qkY;
       u1qlp: // global
           call _c1qkX(R1) args: 0, res: 0, upd: 0;
       c1qkY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qkX() //  [R1]
         { info_tbl: [(c1qkX,
                       label: block_c1qkX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qkX: // global
           I64[Sp - 8] = block_c1ql3_info;
           _s1joL::P64 = P64[R1 + 7];
           _s1joM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1joM::P64;
           P64[Sp + 16] = _s1joL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1qlo; else goto c1ql7;
       u1qlo: // global
           call _c1ql3(R1) args: 0, res: 0, upd: 0;
       c1ql7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ql3() //  [R1]
         { info_tbl: [(c1ql3,
                       label: block_c1ql3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ql3: // global
           _s1joL::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1qlb_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1joL::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qlb() //  [R1]
         { info_tbl: [(c1qlb,
                       label: block_c1qlb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qlb: // global
           if (R1 & 7 == 1) goto c1qlm; else goto c1qli;
       c1qlm: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1qli: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.341023883 UTC

[section ""data" . GHC.Real.$fOrdRatio_closure" {
     GHC.Real.$fOrdRatio_closure:
         const GHC.Real.$fOrdRatio_info;
 },
 sat_s1joZ_entry() //  [R1, R2, R3]
         { info_tbl: [(c1qlT,
                       label: sat_s1joZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qlT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joY_entry() //  [R1, R2, R3]
         { info_tbl: [(c1qm1,
                       label: sat_s1joY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qm1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joX_entry() //  [R1, R2, R3]
         { info_tbl: [(c1qm9,
                       label: sat_s1joX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qm9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joW_entry() //  [R1, R2, R3]
         { info_tbl: [(c1qmh,
                       label: sat_s1joW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qmh: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c>_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joV_entry() //  [R1, R2, R3]
         { info_tbl: [(c1qmp,
                       label: sat_s1joV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qmp: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joU_entry() //  [R1, R2, R3]
         { info_tbl: [(c1qmx,
                       label: sat_s1joU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qmx: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joT_entry() //  [R1, R2, R3]
         { info_tbl: [(c1qmF,
                       label: sat_s1joT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qmF: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1joS_entry() //  [R1]
         { info_tbl: [(c1qmM,
                       label: sat_s1joS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qmM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qmN; else goto c1qmO;
       c1qmN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qmO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fOrdRatio_entry() //  [R2]
         { info_tbl: [(c1qmQ,
                       label: GHC.Real.$fOrdRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qmQ: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c1qmU; else goto c1qmT;
       c1qmU: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1qmT: // global
           I64[Hp - 200] = sat_s1joZ_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s1joY_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s1joX_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1joW_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s1joV_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s1joU_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s1joT_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s1joS_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.36311163 UTC

[section ""data" . GHC.Real.$fNumRatio_$cnegate_closure" {
     GHC.Real.$fNumRatio_$cnegate_closure:
         const GHC.Real.$fNumRatio_$cnegate_info;
 },
 GHC.Real.$fNumRatio_$cnegate_entry() //  [R2, R3]
         { info_tbl: [(c1qnE,
                       label: GHC.Real.$fNumRatio_$cnegate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qnE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qnS; else goto c1qnT;
       c1qnS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$cnegate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qnT: // global
           I64[Sp - 16] = block_c1qnB_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1qo0; else goto c1qnC;
       u1qo0: // global
           call _c1qnB(R1) args: 0, res: 0, upd: 0;
       c1qnC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qnB() //  [R1]
         { info_tbl: [(c1qnB,
                       label: block_c1qnB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qnB: // global
           I64[Sp - 8] = block_c1qnH_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qnH() //  [R1]
         { info_tbl: [(c1qnH,
                       label: block_c1qnH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qnH: // global
           I64[Sp] = block_c1qnL_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qnL() //  [R1]
         { info_tbl: [(c1qnL,
                       label: block_c1qnL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qnL: // global
           I64[Sp] = block_c1qnP_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1qnP() //  [R1]
         { info_tbl: [(c1qnP,
                       label: block_c1qnP_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qnP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qnZ; else goto c1qnY;
       c1qnZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1qnY: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.379612051 UTC

[section ""data" . GHC.Real.$fNumRatio_$cabs_closure" {
     GHC.Real.$fNumRatio_$cabs_closure:
         const GHC.Real.$fNumRatio_$cabs_info;
 },
 GHC.Real.$fNumRatio_$cabs_entry() //  [R2, R3]
         { info_tbl: [(c1qov,
                       label: GHC.Real.$fNumRatio_$cabs_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qov: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qoJ; else goto c1qoK;
       c1qoJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$cabs_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qoK: // global
           I64[Sp - 16] = block_c1qos_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1qoR; else goto c1qot;
       u1qoR: // global
           call _c1qos(R1) args: 0, res: 0, upd: 0;
       c1qot: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qos() //  [R1]
         { info_tbl: [(c1qos,
                       label: block_c1qos_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qos: // global
           I64[Sp - 8] = block_c1qoy_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qoy() //  [R1]
         { info_tbl: [(c1qoy,
                       label: block_c1qoy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qoy: // global
           I64[Sp] = block_c1qoC_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qoC() //  [R1]
         { info_tbl: [(c1qoC,
                       label: block_c1qoC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qoC: // global
           I64[Sp] = block_c1qoG_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1qoG() //  [R1]
         { info_tbl: [(c1qoG,
                       label: block_c1qoG_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qoG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qoQ; else goto c1qoP;
       c1qoQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1qoP: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.394956802 UTC

[section ""data" . GHC.Real.$w$csignum_closure" {
     GHC.Real.$w$csignum_closure:
         const GHC.Real.$w$csignum_info;
         const 0;
 },
 GHC.Real.$w$csignum_entry() //  [R2, R3]
         { info_tbl: [(c1qpl,
                       label: GHC.Real.$w$csignum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qpl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qpv; else goto c1qpw;
       c1qpv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$csignum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qpw: // global
           I64[Sp - 16] = block_c1qpj_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qpj() //  [R1]
         { info_tbl: [(c1qpj,
                       label: block_c1qpj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qpj: // global
           I64[Sp] = block_c1qpo_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qpo() //  [R1]
         { info_tbl: [(c1qpo,
                       label: block_c1qpo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qpo: // global
           I64[Sp] = block_c1qps_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1qps() //  [R1]
         { info_tbl: [(c1qps,
                       label: block_c1qps_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qps: // global
           I64[Sp] = block_c1qpu_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Real.$fEnumRatio1_closure;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1qpu() //  [R1]
         { info_tbl: [(c1qpu,
                       label: block_c1qpu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qpu: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.408527832 UTC

[section ""data" . GHC.Real.$fNumRatio_$csignum_closure" {
     GHC.Real.$fNumRatio_$csignum_closure:
         const GHC.Real.$fNumRatio_$csignum_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$csignum_entry() //  [R2, R3]
         { info_tbl: [(c1qq2,
                       label: GHC.Real.$fNumRatio_$csignum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qq2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qq8; else goto c1qq9;
       c1qq8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$csignum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qq9: // global
           I64[Sp - 16] = block_c1qpZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1qqe; else goto c1qq0;
       u1qqe: // global
           call _c1qpZ(R1) args: 0, res: 0, upd: 0;
       c1qq0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qpZ() //  [R1]
         { info_tbl: [(c1qpZ,
                       label: block_c1qpZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qpZ: // global
           _s1jpm::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1qq5_info;
           R3 = P64[R1 + 7];
           R2 = _s1jpm::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$csignum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qq5() //  [R1, R2]
         { info_tbl: [(c1qq5,
                       label: block_c1qq5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qq5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qqd; else goto c1qqc;
       c1qqd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qqc: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.416392884 UTC

[section ""data" . GHC.Real.$w$cfromInteger_closure" {
     GHC.Real.$w$cfromInteger_closure:
         const GHC.Real.$w$cfromInteger_info;
         const 0;
 },
 GHC.Real.$w$cfromInteger_entry() //  [R2, R3]
         { info_tbl: [(c1qqy,
                       label: GHC.Real.$w$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qqy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qqI; else goto c1qqJ;
       c1qqI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cfromInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qqJ: // global
           I64[Sp - 16] = block_c1qqw_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qqw() //  [R1]
         { info_tbl: [(c1qqw,
                       label: block_c1qqw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qqw: // global
           I64[Sp] = block_c1qqB_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qqB() //  [R1]
         { info_tbl: [(c1qqB,
                       label: block_c1qqB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qqB: // global
           I64[Sp] = block_c1qqF_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1qqF() //  [R1]
         { info_tbl: [(c1qqF,
                       label: block_c1qqF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qqF: // global
           I64[Sp] = block_c1qqH_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Real.$fEnumRatio1_closure;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1qqH() //  [R1]
         { info_tbl: [(c1qqH,
                       label: block_c1qqH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qqH: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.426651307 UTC

[section ""data" . GHC.Real.$fNumRatio_$cfromInteger_closure" {
     GHC.Real.$fNumRatio_$cfromInteger_closure:
         const GHC.Real.$fNumRatio_$cfromInteger_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$cfromInteger_entry() //  [R2, R3]
         { info_tbl: [(c1qrf,
                       label: GHC.Real.$fNumRatio_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qrf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1qrg; else goto c1qrh;
       c1qrg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$cfromInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qrh: // global
           I64[Sp - 8] = block_c1qrc_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qrc() //  [R1, R2]
         { info_tbl: [(c1qrc,
                       label: block_c1qrc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qrc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qrk; else goto c1qrj;
       c1qrk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qrj: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.432915122 UTC

[section ""data" . GHC.Real.$fRealRatio_$s$ctoRational_closure" {
     GHC.Real.$fRealRatio_$s$ctoRational_closure:
         const GHC.Real.$fRealRatio_$s$ctoRational_info;
 },
 GHC.Real.$fRealRatio_$s$ctoRational_entry() //  [R2]
         { info_tbl: [(c1qry,
                       label: GHC.Real.$fRealRatio_$s$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qry: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.436801075 UTC

[section ""data" . GHC.Real.$fRealRatio_$ctoRational_closure" {
     GHC.Real.$fRealRatio_$ctoRational_closure:
         const GHC.Real.$fRealRatio_$ctoRational_info;
 },
 GHC.Real.$fRealRatio_$ctoRational_entry() //  [R2, R3]
         { info_tbl: [(c1qrO,
                       label: GHC.Real.$fRealRatio_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qrO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qs0; else goto c1qs1;
       c1qs0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealRatio_$ctoRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qs1: // global
           I64[Sp - 16] = block_c1qrL_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1qs7; else goto c1qrM;
       u1qs7: // global
           call _c1qrL(R1) args: 0, res: 0, upd: 0;
       c1qrM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qrL() //  [R1]
         { info_tbl: [(c1qrL,
                       label: block_c1qrL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qrL: // global
           I64[Sp - 8] = block_c1qrR_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1qrR() //  [R1]
         { info_tbl: [(c1qrR,
                       label: block_c1qrR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qrR: // global
           _s1jpK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1qrV_info;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = _s1jpK::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 8;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1qrV() //  [R1]
         { info_tbl: [(c1qrV,
                       label: block_c1qrV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qrV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qs6; else goto c1qs5;
       c1qs6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1qs5: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.446887734 UTC

[section ""data" . GHC.Real.$w$crecip_closure" {
     GHC.Real.$w$crecip_closure:
         const GHC.Real.$w$crecip_info;
         const 0;
 },
 $dNum_s1jpR_entry() //  [R1]
         { info_tbl: [(c1qsD,
                       label: $dNum_s1jpR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qsD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qsE; else goto c1qsF;
       c1qsE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qsF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jpU_entry() //  [R1]
         { info_tbl: [(c1qsO,
                       label: sat_s1jpU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qsO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qsP; else goto c1qsQ;
       c1qsP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qsQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jpW_entry() //  [R1]
         { info_tbl: [(c1qt3,
                       label: sat_s1jpW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qt3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qt4; else goto c1qt5;
       c1qt4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qt5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1qtI_srtd" {
     u1qtI_srtd:
         const S1jKw_srt+296;
         const 66;
         const 281474976710657;
         const 2;
 },
 GHC.Real.$w$crecip_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qt6,
                       label: GHC.Real.$w$crecip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qt6: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1qt7; else goto c1qt8;
       c1qt7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$crecip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qt8: // global
           I64[Sp - 24] = block_c1qsv_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1qtJ_srtd" {
     u1qtJ_srtd:
         const S1jKw_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1qsv() //  [R1]
         { info_tbl: [(c1qsv,
                       label: block_c1qsv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qsv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qtb; else goto c1qta;
       c1qtb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1qta: // global
           I64[Hp - 16] = $dNum_s1jpR_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1qsG_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1qtK_srtd" {
     u1qtK_srtd:
         const S1jKw_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1qsG() //  [R1]
         { info_tbl: [(c1qsG,
                       label: block_c1qsG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qsG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qte; else goto c1qtd;
       c1qte: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1qtd: // global
           I64[Hp - 16] = sat_s1jpU_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = block_c1qsR_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1qtL_srtd" {
     u1qtL_srtd:
         const S1jKw_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1qsR() //  [R1]
         { info_tbl: [(c1qsR,
                       label: block_c1qsR_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qsR: // global
           I64[Sp] = block_c1qsV_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1qtM_srtd" {
     u1qtM_srtd:
         const S1jKw_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1qsV() //  [R1]
         { info_tbl: [(c1qsV,
                       label: block_c1qsV_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qsV: // global
           if (R1 & 7 == 1) goto c1qti; else goto c1qtF;
       c1qti: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qtl; else goto c1qtk;
       c1qtl: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1qtk: // global
           I64[Hp - 16] = sat_s1jpW_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 16] = block_c1qtg_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 32];
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
       c1qtF: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1qtg() //  [R1]
         { info_tbl: [(c1qtg,
                       label: block_c1qtg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qtg: // global
           _s1jpP::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c1qtr; else goto c1qty;
       c1qtr: // global
           R2 = P64[Sp + 16];
           R1 = _s1jpP::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c1qty: // global
           I64[Sp] = block_c1qtu_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s1jpP::P64;
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1qtu() //  [R1]
         { info_tbl: [(c1qtu,
                       label: block_c1qtu_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qtu: // global
           _s1jpO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1qtw_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = _s1jpO::P64;
           P64[Sp + 24] = R1;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1qtw() //  [R1]
         { info_tbl: [(c1qtw,
                       label: block_c1qtw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qtw: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.472774381 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$crecip_closure" {
     GHC.Real.$fFractionalRatio_$crecip_closure:
         const GHC.Real.$fFractionalRatio_$crecip_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$crecip_entry() //  [R2, R3]
         { info_tbl: [(c1quP,
                       label: GHC.Real.$fFractionalRatio_$crecip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1quP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1quV; else goto c1quW;
       c1quV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$crecip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1quW: // global
           I64[Sp - 16] = block_c1quM_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1qv1; else goto c1quN;
       u1qv1: // global
           call _c1quM(R1) args: 0, res: 0, upd: 0;
       c1quN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1quM() //  [R1]
         { info_tbl: [(c1quM,
                       label: block_c1quM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1quM: // global
           _s1jq1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1quS_info;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = _s1jq1::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$crecip_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1quS() //  [R1, R2]
         { info_tbl: [(c1quS,
                       label: block_c1quS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1quS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qv0; else goto c1quZ;
       c1qv0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1quZ: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.481565223 UTC

[section ""data" . GHC.Real.$w$s$cproperFraction_closure" {
     GHC.Real.$w$s$cproperFraction_closure:
         const GHC.Real.$w$s$cproperFraction_info;
         const 0;
 },
 section ""relreadonly" . u1qwu_srtd" {
     u1qwu_srtd:
         const S1jKw_srt+424;
         const 33;
         const 4294967297;
 },
 ds_s1jqc_entry() //  [R1]
         { info_tbl: [(c1qvs,
                       label: ds_s1jqc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qvs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qvt; else goto c1qvu;
       c1qvt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qvu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c1qvn_info;
           R3 = GHC.Real.even1_closure;
           _s1jqb::P64 = P64[R1 + 24];
           R2 = _s1jqb::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s1jqb::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1qvn() //  [R1]
         { info_tbl: [(c1qvn,
                       label: block_c1qvn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qvn: // global
           if (R1 == 1) goto c1qvr; else goto c1qvq;
       c1qvr: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c1qvq: // global
           _s1jqb::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1qvx_info;
           R3 = _s1jqb::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1qvx() //  [R1, R2]
         { info_tbl: [(c1qvx,
                       label: block_c1qvx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qvx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qvD; else goto c1qvC;
       c1qvD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1qvC: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jqs_entry() //  [R1]
         { info_tbl: [(c1qvO,
                       label: sat_s1jqs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qvO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qvX; else goto c1qvY;
       c1qvX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qvY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1qvL_info;
           _s1jqb::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s1jqb::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1qw4; else goto c1qvM;
       u1qw4: // global
           call _c1qvL(R1) args: 0, res: 0, upd: 0;
       c1qvM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1qvL() //  [R1]
         { info_tbl: [(c1qvL,
                       label: block_c1qvL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qvL: // global
           I64[Sp] = block_c1qvR_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto u1qw3; else goto c1qvS;
       u1qw3: // global
           call _c1qvR(R1) args: 0, res: 0, upd: 0;
       c1qvS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1qvR() //  [R1]
         { info_tbl: [(c1qvR,
                       label: block_c1qvR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qvR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qw2; else goto c1qw1;
       c1qw2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1qw1: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jqn_entry() //  [R1]
         { info_tbl: [(c1qwc,
                       label: sat_s1jqn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qwc: // global
           _s1jqn::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1qwg; else goto c1qwh;
       c1qwh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qwj; else goto c1qwi;
       c1qwj: // global
           HpAlloc = 24;
           goto c1qwg;
       c1qwg: // global
           R1 = _s1jqn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qwi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jqn::P64;
           _s1jq9::P64 = P64[_s1jqn::P64 + 16];
           _s1jqc::P64 = P64[_s1jqn::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1jqc::P64;
           I64[Sp - 32] = block_c1qwa_info;
           R2 = _s1jq9::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1qwa() //  [R1]
         { info_tbl: [(c1qwa,
                       label: block_c1qwa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qwa: // global
           I64[Sp] = block_c1qwf_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1qwf() //  [R1]
         { info_tbl: [(c1qwf,
                       label: block_c1qwf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qwf: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$s$cproperFraction_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qwp,
                       label: GHC.Real.$w$s$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qwp: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1qwt; else goto c1qws;
       c1qwt: // global
           HpAlloc = 96;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qws: // global
           I64[Hp - 88] = ds_s1jqc_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_s1jqs_info;
           P64[Hp - 40] = R4;
           _c1qvj::P64 = Hp - 88;
           P64[Hp - 32] = _c1qvj::P64;
           I64[Hp - 24] = sat_s1jqn_info;
           P64[Hp - 8] = R2;
           P64[Hp] = _c1qvj::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.504696588 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$cproperFraction_closure" {
     GHC.Real.$fEnumRatio_$s$cproperFraction_closure:
         const GHC.Real.$fEnumRatio_$s$cproperFraction_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$cproperFraction_entry() //  [R2, R3]
         { info_tbl: [(c1qxj,
                       label: GHC.Real.$fEnumRatio_$s$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qxj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qxp; else goto c1qxq;
       c1qxp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$cproperFraction_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qxq: // global
           I64[Sp - 16] = block_c1qxg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1qxv; else goto c1qxh;
       u1qxv: // global
           call _c1qxg(R1) args: 0, res: 0, upd: 0;
       c1qxh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qxg() //  [R1]
         { info_tbl: [(c1qxg,
                       label: block_c1qxg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qxg: // global
           _s1jqt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1qxm_info;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = _s1jqt::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qxm() //  [R1, R2]
         { info_tbl: [(c1qxm,
                       label: block_c1qxm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qxm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qxu; else goto c1qxt;
       c1qxu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qxt: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.513344319 UTC

[section ""data" . GHC.Real.$w$cproperFraction_closure" {
     GHC.Real.$w$cproperFraction_closure:
         const GHC.Real.$w$cproperFraction_info;
 },
 ds_s1jqF_entry() //  [R1]
         { info_tbl: [(c1qxR,
                       label: ds_s1jqF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qxR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qxS; else goto c1qxT;
       c1qxS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qxT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.quotRem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jqS_entry() //  [R1]
         { info_tbl: [(c1qy1,
                       label: sat_s1jqS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qy1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qy7; else goto c1qy8;
       c1qy7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qy8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1qxY_info;
           _s1jqE::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s1jqE::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1qyd; else goto c1qxZ;
       u1qyd: // global
           call _c1qxY(R1) args: 0, res: 0, upd: 0;
       c1qxZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1qxY() //  [R1]
         { info_tbl: [(c1qxY,
                       label: block_c1qxY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qxY: // global
           I64[Sp] = block_c1qy4_info;
           R1 = P64[R1 + 15];
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1qy4() //  [R1]
         { info_tbl: [(c1qy4,
                       label: block_c1qy4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qy4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qyc; else goto c1qyb;
       c1qyc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1qyb: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jqM_entry() //  [R1]
         { info_tbl: [(c1qyn,
                       label: sat_s1jqM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qyn: // global
           _s1jqM::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1qyo; else goto c1qyp;
       c1qyp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qyr; else goto c1qyq;
       c1qyr: // global
           HpAlloc = 24;
           goto c1qyo;
       c1qyo: // global
           R1 = _s1jqM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qyq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jqM::P64;
           _s1jqB::P64 = P64[_s1jqM::P64 + 16];
           _s1jqF::P64 = P64[_s1jqM::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1jqF::P64;
           R2 = _s1jqB::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jqN_entry() //  [R1]
         { info_tbl: [(c1qyu,
                       label: sat_s1jqN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qyu: // global
           _s1jqN::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1qyy; else goto c1qyz;
       c1qyz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1qyB; else goto c1qyA;
       c1qyB: // global
           HpAlloc = 32;
           goto c1qyy;
       c1qyy: // global
           R1 = _s1jqN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qyA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jqN::P64;
           _s1jqB::P64 = P64[_s1jqN::P64 + 16];
           _s1jqC::P64 = P64[_s1jqN::P64 + 24];
           _s1jqF::P64 = P64[_s1jqN::P64 + 32];
           I64[Hp - 24] = sat_s1jqM_info;
           P64[Hp - 8] = _s1jqB::P64;
           P64[Hp] = _s1jqF::P64;
           I64[Sp - 32] = block_c1qys_info;
           R2 = _s1jqC::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1qys() //  [R1]
         { info_tbl: [(c1qys,
                       label: block_c1qys_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qys: // global
           I64[Sp] = block_c1qyx_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1qyx() //  [R1]
         { info_tbl: [(c1qyx,
                       label: block_c1qyx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qyx: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$cproperFraction_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1qyH,
                       label: GHC.Real.$w$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qyH: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1qyL; else goto c1qyK;
       c1qyL: // global
           HpAlloc = 112;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cproperFraction_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qyK: // global
           I64[Hp - 104] = ds_s1jqF_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R5;
           I64[Hp - 64] = sat_s1jqS_info;
           P64[Hp - 48] = R5;
           _c1qxN::P64 = Hp - 104;
           P64[Hp - 40] = _c1qxN::P64;
           I64[Hp - 32] = sat_s1jqN_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = _c1qxN::P64;
           R2 = Hp - 64;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.533641158 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cproperFraction_closure" {
     GHC.Real.$fEnumRatio_$cproperFraction_closure:
         const GHC.Real.$fEnumRatio_$cproperFraction_info;
 },
 GHC.Real.$fEnumRatio_$cproperFraction_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qzx,
                       label: GHC.Real.$fEnumRatio_$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qzx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1qzD; else goto c1qzE;
       c1qzD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qzE: // global
           I64[Sp - 24] = block_c1qzu_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1qzJ; else goto c1qzv;
       u1qzJ: // global
           call _c1qzu(R1) args: 0, res: 0, upd: 0;
       c1qzv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qzu() //  [R1]
         { info_tbl: [(c1qzu,
                       label: block_c1qzu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qzu: // global
           _s1jqU::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1qzA_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _s1jqU::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qzA() //  [R1, R2]
         { info_tbl: [(c1qzA,
                       label: block_c1qzA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qzA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qzI; else goto c1qzH;
       c1qzI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qzH: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.54234386 UTC

[section ""data" . GHC.Real.$wreduce_closure" {
     GHC.Real.$wreduce_closure:
         const GHC.Real.$wreduce_info;
         const 0;
 },
 sat_s1jr9_entry() //  [R1]
         { info_tbl: [(c1qAb,
                       label: sat_s1jr9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qAb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qAc; else goto c1qAd;
       c1qAc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qAd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1qA9_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1qA9() //  [R1]
         { info_tbl: [(c1qA9,
                       label: block_c1qA9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qA9: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 d_s1jrb_entry() //  [R1]
         { info_tbl: [(c1qAx,
                       label: d_s1jrb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qAx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qAy; else goto c1qAz;
       c1qAy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qAz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.gcd_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1qAY_srtd" {
     u1qAY_srtd:
         const S1jKw_srt+296;
         const 72;
         const 281474976710657;
         const 192;
 },
 GHC.Real.$wreduce_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qAA,
                       label: GHC.Real.$wreduce_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qAA: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1qAB; else goto c1qAC;
       c1qAB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wreduce_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qAC: // global
           I64[Sp - 32] = block_c1qA1_info;
           _s1jr2::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1jr2::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1qAZ_srtd" {
     u1qAZ_srtd:
         const S1jKw_srt+296;
         const 71;
         const 281474976710657;
         const 64;
 },
 _c1qA1() //  [R1]
         { info_tbl: [(c1qA1,
                       label: block_c1qA1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qA1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qAF; else goto c1qAE;
       c1qAF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1qAE: // global
           I64[Hp - 16] = sat_s1jr9_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1qAh_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1qB0_srtd" {
     u1qB0_srtd:
         const S1jKw_srt+296;
         const 71;
         const 1;
         const 64;
 },
 _c1qAh() //  [R1]
         { info_tbl: [(c1qAh,
                       label: block_c1qAh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qAh: // global
           I64[Sp] = block_c1qAl_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1qB1_srtd" {
     u1qB1_srtd:
         const S1jKw_srt+296;
         const 71;
         const 1;
         const 64;
 },
 _c1qAl() //  [R1]
         { info_tbl: [(c1qAl,
                       label: block_c1qAl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qAl: // global
           _c1qA5::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1qAp_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = _c1qA5::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1qB2_srtd" {
     u1qB2_srtd:
         const S1jKw_srt+296;
         const 71;
         const 1;
         const 64;
 },
 _c1qAp() //  [R1]
         { info_tbl: [(c1qAp,
                       label: block_c1qAp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qAp: // global
           if (R1 & 7 == 1) goto c1qAM; else goto c1qAW;
       c1qAM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1qAP; else goto c1qAO;
       c1qAP: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1qAO: // global
           I64[Hp - 32] = d_s1jrb_info;
           _s1jr2::P64 = P64[Sp + 8];
           P64[Hp - 16] = _s1jr2::P64;
           _s1jr3::P64 = P64[Sp + 16];
           P64[Hp - 8] = _s1jr3::P64;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_c1qAI_info;
           R2 = _s1jr2::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jr3::P64;
           _c1qAt::P64 = Hp - 32;
           P64[Sp - 8] = _c1qAt::P64;
           P64[Sp + 16] = _c1qAt::P64;
           Sp = Sp - 24;
           call GHC.Real.quot_entry(R2) args: 32, res: 8, upd: 8;
       c1qAW: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1qAI() //  [R1]
         { info_tbl: [(c1qAI,
                       label: block_c1qAI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qAI: // global
           _c1qAt::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1qAK_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 24];
           P64[Sp + 8] = _c1qAt::P64;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call GHC.Real.quot_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1qAK() //  [R1]
         { info_tbl: [(c1qAK,
                       label: block_c1qAK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qAK: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.567485645 UTC

[section ""data" . GHC.Real.reduce_closure" {
     GHC.Real.reduce_closure:
         const GHC.Real.reduce_info;
         const 0;
 },
 GHC.Real.reduce_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qBU,
                       label: GHC.Real.reduce_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qBU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1qBV; else goto c1qBW;
       c1qBV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.reduce_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qBW: // global
           I64[Sp - 8] = block_c1qBR_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qBR() //  [R1, R2]
         { info_tbl: [(c1qBR,
                       label: block_c1qBR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qBR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qBZ; else goto c1qBY;
       c1qBZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qBY: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.574024734 UTC

[section ""data" . GHC.Real.%_$s%_closure" {
     GHC.Real.%_$s%_closure:
         const GHC.Real.%_$s%_info;
         const 0;
 },
 GHC.Real.%_$s%_entry() //  [R2, R3]
         { info_tbl: [(c1qCg,
                       label: GHC.Real.%_$s%_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qCg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1qCh; else goto c1qCi;
       c1qCh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.%_$s%_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qCi: // global
           I64[Sp - 8] = block_c1qCd_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$s$cfromRational_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qCd() //  [R1, R2]
         { info_tbl: [(c1qCd,
                       label: block_c1qCd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qCd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qCl; else goto c1qCk;
       c1qCl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qCk: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.580511315 UTC

[section ""data" . GHC.Real.$w%_closure" {
     GHC.Real.$w%_closure:
         const GHC.Real.$w%_info;
         const 0;
 },
 $dReal_s1jrt_entry() //  [R1]
         { info_tbl: [(c1qCD,
                       label: $dReal_s1jrt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qCD: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jru_entry() //  [R1]
         { info_tbl: [(c1qCK,
                       label: $dNum_s1jru_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qCK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qCL; else goto c1qCM;
       c1qCL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qCM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jrx_entry() //  [R1]
         { info_tbl: [(c1qCR,
                       label: sat_s1jrx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qCR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qCS; else goto c1qCT;
       c1qCS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qCT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jrv_entry() //  [R1]
         { info_tbl: [(c1qD2,
                       label: sat_s1jrv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qD2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qD3; else goto c1qD4;
       c1qD3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qD4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jrw_entry() //  [R1]
         { info_tbl: [(c1qD5,
                       label: sat_s1jrw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qD5: // global
           _s1jrw::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1qD6; else goto c1qD7;
       c1qD7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1qD9; else goto c1qD8;
       c1qD9: // global
           HpAlloc = 32;
           goto c1qD6;
       c1qD6: // global
           R1 = _s1jrw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qD8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jrw::P64;
           _s1jrr::P64 = P64[_s1jrw::P64 + 16];
           _s1jrs::P64 = P64[_s1jrw::P64 + 24];
           _s1jru::P64 = P64[_s1jrw::P64 + 32];
           I64[Hp - 24] = sat_s1jrv_info;
           P64[Hp - 8] = _s1jrs::P64;
           P64[Hp] = _s1jru::P64;
           R2 = _s1jru::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1jrr::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w%_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qDa,
                       label: GHC.Real.$w%_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qDa: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c1qDe; else goto c1qDd;
       c1qDe: // global
           HpAlloc = 120;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w%_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qDd: // global
           I64[Hp - 112] = $dReal_s1jrt_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = $dNum_s1jru_info;
           P64[Hp - 72] = Hp - 112;
           I64[Hp - 64] = sat_s1jrx_info;
           P64[Hp - 48] = R4;
           _c1qCG::P64 = Hp - 88;
           P64[Hp - 40] = _c1qCG::P64;
           I64[Hp - 32] = sat_s1jrw_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = _c1qCG::P64;
           R4 = Hp - 64;
           R3 = Hp - 32;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.595016532 UTC

[section ""data" . GHC.Real.%_closure" {
     GHC.Real.%_closure:
         const GHC.Real.%_info;
         const 0;
 },
 GHC.Real.%_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qDN,
                       label: GHC.Real.%_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qDN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1qDO; else goto c1qDP;
       c1qDO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.%_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qDP: // global
           I64[Sp - 8] = block_c1qDK_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w%_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qDK() //  [R1, R2]
         { info_tbl: [(c1qDK,
                       label: block_c1qDK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qDK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qDS; else goto c1qDR;
       c1qDS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qDR: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.602235674 UTC

[section ""data" . GHC.Real.$w$c/_closure" {
     GHC.Real.$w$c/_closure:
         const GHC.Real.$w$c/_info;
         const 0;
 },
 $dReal_s1jrJ_entry() //  [R1]
         { info_tbl: [(c1qEa,
                       label: $dReal_s1jrJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qEa: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jrK_entry() //  [R1]
         { info_tbl: [(c1qEh,
                       label: $dNum_s1jrK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qEh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qEi; else goto c1qEj;
       c1qEi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qEj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jrM_entry() //  [R1]
         { info_tbl: [(c1qEo,
                       label: sat_s1jrM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qEo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qEp; else goto c1qEq;
       c1qEp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qEq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jrL_entry() //  [R1]
         { info_tbl: [(c1qEv,
                       label: sat_s1jrL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qEv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qEw; else goto c1qEx;
       c1qEw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qEx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c/_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1qEy,
                       label: GHC.Real.$w$c/_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qEy: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto c1qEC; else goto c1qEB;
       c1qEC: // global
           HpAlloc = 128;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c/_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qEB: // global
           I64[Hp - 120] = $dReal_s1jrJ_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = $dNum_s1jrK_info;
           P64[Hp - 80] = Hp - 120;
           I64[Hp - 72] = sat_s1jrM_info;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           _c1qEd::P64 = Hp - 96;
           P64[Hp - 40] = _c1qEd::P64;
           I64[Hp - 32] = sat_s1jrL_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R6;
           P64[Hp] = _c1qEd::P64;
           R4 = Hp - 72;
           R3 = Hp - 32;
           R2 = R2;
           call GHC.Real.$w%_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.614182419 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$c/_closure" {
     GHC.Real.$fFractionalRatio_$c/_closure:
         const GHC.Real.$fFractionalRatio_$c/_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$c/_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qF8,
                       label: GHC.Real.$fFractionalRatio_$c/_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qF8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qFj; else goto c1qFk;
       c1qFj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$c/_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qFk: // global
           I64[Sp - 24] = block_c1qF5_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1qFr; else goto c1qF6;
       u1qFr: // global
           call _c1qF5(R1) args: 0, res: 0, upd: 0;
       c1qF6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qF5() //  [R1]
         { info_tbl: [(c1qF5,
                       label: block_c1qF5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qF5: // global
           I64[Sp - 8] = block_c1qFb_info;
           _s1jrR::P64 = P64[R1 + 7];
           _s1jrS::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jrS::P64;
           P64[Sp + 16] = _s1jrR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1qFq; else goto c1qFc;
       u1qFq: // global
           call _c1qFb(R1) args: 0, res: 0, upd: 0;
       c1qFc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qFb() //  [R1]
         { info_tbl: [(c1qFb,
                       label: block_c1qFb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qFb: // global
           _s1jrR::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1qFg_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jrR::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c/_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qFg() //  [R1, R2]
         { info_tbl: [(c1qFg,
                       label: block_c1qFg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qFg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qFp; else goto c1qFo;
       c1qFp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qFo: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.624739564 UTC

[section ""data" . GHC.Real.$w$cfromRational_closure" {
     GHC.Real.$w$cfromRational_closure:
         const GHC.Real.$w$cfromRational_info;
         const 0;
 },
 $dReal_s1js2_entry() //  [R1]
         { info_tbl: [(c1qFR,
                       label: $dReal_s1js2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qFR: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1js3_entry() //  [R1]
         { info_tbl: [(c1qFY,
                       label: $dNum_s1js3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qFY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qFZ; else goto c1qG0;
       c1qFZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qG0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1js5_entry() //  [R1]
         { info_tbl: [(c1qG5,
                       label: sat_s1js5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qG5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qG6; else goto c1qG7;
       c1qG6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qG7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1js4_entry() //  [R1]
         { info_tbl: [(c1qGc,
                       label: sat_s1js4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qGc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qGd; else goto c1qGe;
       c1qGd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qGe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$cfromRational_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qGf,
                       label: GHC.Real.$w$cfromRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qGf: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1qGj; else goto c1qGi;
       c1qGj: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cfromRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qGi: // global
           I64[Hp - 104] = $dReal_s1js2_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_s1js3_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = sat_s1js5_info;
           P64[Hp - 40] = R4;
           _c1qFU::P64 = Hp - 80;
           P64[Hp - 32] = _c1qFU::P64;
           I64[Hp - 24] = sat_s1js4_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _c1qFU::P64;
           R4 = Hp - 56;
           R3 = Hp - 24;
           R2 = R2;
           call GHC.Real.$w%_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.637017473 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$cfromRational_closure" {
     GHC.Real.$fFractionalRatio_$cfromRational_closure:
         const GHC.Real.$fFractionalRatio_$cfromRational_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$cfromRational_entry() //  [R2, R3]
         { info_tbl: [(c1qGN,
                       label: GHC.Real.$fFractionalRatio_$cfromRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qGN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qGT; else goto c1qGU;
       c1qGT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$cfromRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qGU: // global
           I64[Sp - 16] = block_c1qGK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1qGZ; else goto c1qGL;
       u1qGZ: // global
           call _c1qGK(R1) args: 0, res: 0, upd: 0;
       c1qGL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qGK() //  [R1]
         { info_tbl: [(c1qGK,
                       label: block_c1qGK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qGK: // global
           _s1js6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1qGQ_info;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = _s1js6::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$cfromRational_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qGQ() //  [R1, R2]
         { info_tbl: [(c1qGQ,
                       label: block_c1qGQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qGQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qGY; else goto c1qGX;
       c1qGY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qGX: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.64573068 UTC

[section ""data" . GHC.Real.$w$c+_closure" {
     GHC.Real.$w$c+_closure:
         const GHC.Real.$w$c+_info;
         const 0;
 },
 $dReal_s1jsj_entry() //  [R1]
         { info_tbl: [(c1qHl,
                       label: $dReal_s1jsj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qHl: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jsk_entry() //  [R1]
         { info_tbl: [(c1qHs,
                       label: $dNum_s1jsk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qHs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qHt; else goto c1qHu;
       c1qHt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qHu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jso_entry() //  [R1]
         { info_tbl: [(c1qHz,
                       label: sat_s1jso_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qHz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qHA; else goto c1qHB;
       c1qHA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qHB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsm_entry() //  [R1]
         { info_tbl: [(c1qHK,
                       label: sat_s1jsm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qHK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qHL; else goto c1qHM;
       c1qHL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qHM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsl_entry() //  [R1]
         { info_tbl: [(c1qHR,
                       label: sat_s1jsl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qHR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qHS; else goto c1qHT;
       c1qHS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qHT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsn_entry() //  [R1]
         { info_tbl: [(c1qHU,
                       label: sat_s1jsn_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qHU: // global
           _s1jsn::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1qHV; else goto c1qHW;
       c1qHW: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1qHY; else goto c1qHX;
       c1qHY: // global
           HpAlloc = 80;
           goto c1qHV;
       c1qHV: // global
           R1 = _s1jsn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qHX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jsn::P64;
           _s1jsf::P64 = P64[_s1jsn::P64 + 16];
           _s1jsg::P64 = P64[_s1jsn::P64 + 24];
           _s1jsh::P64 = P64[_s1jsn::P64 + 32];
           _s1jsi::P64 = P64[_s1jsn::P64 + 40];
           _s1jsk::P64 = P64[_s1jsn::P64 + 48];
           I64[Hp - 72] = sat_s1jsm_info;
           P64[Hp - 56] = _s1jsg::P64;
           P64[Hp - 48] = _s1jsh::P64;
           P64[Hp - 40] = _s1jsk::P64;
           I64[Hp - 32] = sat_s1jsl_info;
           P64[Hp - 16] = _s1jsf::P64;
           P64[Hp - 8] = _s1jsi::P64;
           P64[Hp] = _s1jsk::P64;
           R2 = _s1jsk::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c+_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1qHZ,
                       label: GHC.Real.$w$c+_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qHZ: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1qI3; else goto c1qI2;
       c1qI3: // global
           HpAlloc = 144;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c+_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qI2: // global
           I64[Hp - 136] = $dReal_s1jsj_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = $dNum_s1jsk_info;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = sat_s1jso_info;
           P64[Hp - 72] = R4;
           P64[Hp - 64] = R6;
           _c1qHo::P64 = Hp - 112;
           P64[Hp - 56] = _c1qHo::P64;
           I64[Hp - 48] = sat_s1jsn_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _c1qHo::P64;
           R4 = Hp - 88;
           R3 = Hp - 48;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.66334889 UTC

[section ""data" . GHC.Real.$fNumRatio_$c+_closure" {
     GHC.Real.$fNumRatio_$c+_closure:
         const GHC.Real.$fNumRatio_$c+_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$c+_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qIL,
                       label: GHC.Real.$fNumRatio_$c+_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qIL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qIW; else goto c1qIX;
       c1qIW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$c+_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qIX: // global
           I64[Sp - 24] = block_c1qII_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1qJ4; else goto c1qIJ;
       u1qJ4: // global
           call _c1qII(R1) args: 0, res: 0, upd: 0;
       c1qIJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qII() //  [R1]
         { info_tbl: [(c1qII,
                       label: block_c1qII_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qII: // global
           I64[Sp - 8] = block_c1qIO_info;
           _s1jst::P64 = P64[R1 + 7];
           _s1jsu::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jsu::P64;
           P64[Sp + 16] = _s1jst::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1qJ3; else goto c1qIP;
       u1qJ3: // global
           call _c1qIO(R1) args: 0, res: 0, upd: 0;
       c1qIP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qIO() //  [R1]
         { info_tbl: [(c1qIO,
                       label: block_c1qIO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qIO: // global
           _s1jst::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1qIT_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jst::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c+_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qIT() //  [R1, R2]
         { info_tbl: [(c1qIT,
                       label: block_c1qIT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qIT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qJ2; else goto c1qJ1;
       c1qJ2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qJ1: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.674689989 UTC

[section ""data" . GHC.Real.$w$c-_closure" {
     GHC.Real.$w$c-_closure:
         const GHC.Real.$w$c-_info;
         const 0;
 },
 $dReal_s1jsG_entry() //  [R1]
         { info_tbl: [(c1qJu,
                       label: $dReal_s1jsG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qJu: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jsH_entry() //  [R1]
         { info_tbl: [(c1qJB,
                       label: $dNum_s1jsH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qJB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qJC; else goto c1qJD;
       c1qJC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qJD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jsL_entry() //  [R1]
         { info_tbl: [(c1qJI,
                       label: sat_s1jsL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qJI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qJJ; else goto c1qJK;
       c1qJJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qJK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsJ_entry() //  [R1]
         { info_tbl: [(c1qJT,
                       label: sat_s1jsJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qJT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qJU; else goto c1qJV;
       c1qJU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qJV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsI_entry() //  [R1]
         { info_tbl: [(c1qK0,
                       label: sat_s1jsI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qK0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qK1; else goto c1qK2;
       c1qK1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qK2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jsK_entry() //  [R1]
         { info_tbl: [(c1qK3,
                       label: sat_s1jsK_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qK3: // global
           _s1jsK::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1qK4; else goto c1qK5;
       c1qK5: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1qK7; else goto c1qK6;
       c1qK7: // global
           HpAlloc = 80;
           goto c1qK4;
       c1qK4: // global
           R1 = _s1jsK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qK6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jsK::P64;
           _s1jsC::P64 = P64[_s1jsK::P64 + 16];
           _s1jsD::P64 = P64[_s1jsK::P64 + 24];
           _s1jsE::P64 = P64[_s1jsK::P64 + 32];
           _s1jsF::P64 = P64[_s1jsK::P64 + 40];
           _s1jsH::P64 = P64[_s1jsK::P64 + 48];
           I64[Hp - 72] = sat_s1jsJ_info;
           P64[Hp - 56] = _s1jsD::P64;
           P64[Hp - 48] = _s1jsE::P64;
           P64[Hp - 40] = _s1jsH::P64;
           I64[Hp - 32] = sat_s1jsI_info;
           P64[Hp - 16] = _s1jsC::P64;
           P64[Hp - 8] = _s1jsF::P64;
           P64[Hp] = _s1jsH::P64;
           R2 = _s1jsH::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c-_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1qK8,
                       label: GHC.Real.$w$c-_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qK8: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1qKc; else goto c1qKb;
       c1qKc: // global
           HpAlloc = 144;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c-_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qKb: // global
           I64[Hp - 136] = $dReal_s1jsG_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = $dNum_s1jsH_info;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = sat_s1jsL_info;
           P64[Hp - 72] = R4;
           P64[Hp - 64] = R6;
           _c1qJx::P64 = Hp - 112;
           P64[Hp - 56] = _c1qJx::P64;
           I64[Hp - 48] = sat_s1jsK_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _c1qJx::P64;
           R4 = Hp - 88;
           R3 = Hp - 48;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.691955858 UTC

[section ""data" . GHC.Real.$fNumRatio_$c-_closure" {
     GHC.Real.$fNumRatio_$c-_closure:
         const GHC.Real.$fNumRatio_$c-_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$c-_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qKU,
                       label: GHC.Real.$fNumRatio_$c-_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qKU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qL5; else goto c1qL6;
       c1qL5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$c-_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qL6: // global
           I64[Sp - 24] = block_c1qKR_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1qLd; else goto c1qKS;
       u1qLd: // global
           call _c1qKR(R1) args: 0, res: 0, upd: 0;
       c1qKS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qKR() //  [R1]
         { info_tbl: [(c1qKR,
                       label: block_c1qKR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qKR: // global
           I64[Sp - 8] = block_c1qKX_info;
           _s1jsQ::P64 = P64[R1 + 7];
           _s1jsR::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jsR::P64;
           P64[Sp + 16] = _s1jsQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1qLc; else goto c1qKY;
       u1qLc: // global
           call _c1qKX(R1) args: 0, res: 0, upd: 0;
       c1qKY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qKX() //  [R1]
         { info_tbl: [(c1qKX,
                       label: block_c1qKX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qKX: // global
           _s1jsQ::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1qL2_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jsQ::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c-_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qL2() //  [R1, R2]
         { info_tbl: [(c1qL2,
                       label: block_c1qL2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qL2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qLb; else goto c1qLa;
       c1qLb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qLa: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.702441924 UTC

[section ""data" . GHC.Real.$w$c*_closure" {
     GHC.Real.$w$c*_closure:
         const GHC.Real.$w$c*_info;
         const 0;
 },
 $dReal_s1jt3_entry() //  [R1]
         { info_tbl: [(c1qLD,
                       label: $dReal_s1jt3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qLD: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1jt4_entry() //  [R1]
         { info_tbl: [(c1qLK,
                       label: $dNum_s1jt4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qLK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qLL; else goto c1qLM;
       c1qLL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qLM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jt6_entry() //  [R1]
         { info_tbl: [(c1qLR,
                       label: sat_s1jt6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qLR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qLS; else goto c1qLT;
       c1qLS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qLT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jt5_entry() //  [R1]
         { info_tbl: [(c1qLY,
                       label: sat_s1jt5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qLY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1qLZ; else goto c1qM0;
       c1qLZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qM0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c*_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1qM1,
                       label: GHC.Real.$w$c*_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qM1: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto c1qM5; else goto c1qM4;
       c1qM5: // global
           HpAlloc = 128;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c*_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qM4: // global
           I64[Hp - 120] = $dReal_s1jt3_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = $dNum_s1jt4_info;
           P64[Hp - 80] = Hp - 120;
           I64[Hp - 72] = sat_s1jt6_info;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R6;
           _c1qLG::P64 = Hp - 96;
           P64[Hp - 40] = _c1qLG::P64;
           I64[Hp - 32] = sat_s1jt5_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R5;
           P64[Hp] = _c1qLG::P64;
           R4 = Hp - 72;
           R3 = Hp - 32;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.714894927 UTC

[section ""data" . GHC.Real.$fNumRatio_$c*_closure" {
     GHC.Real.$fNumRatio_$c*_closure:
         const GHC.Real.$fNumRatio_$c*_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$c*_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qMB,
                       label: GHC.Real.$fNumRatio_$c*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qMB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qMM; else goto c1qMN;
       c1qMM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$c*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qMN: // global
           I64[Sp - 24] = block_c1qMy_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1qMU; else goto c1qMz;
       u1qMU: // global
           call _c1qMy(R1) args: 0, res: 0, upd: 0;
       c1qMz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qMy() //  [R1]
         { info_tbl: [(c1qMy,
                       label: block_c1qMy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qMy: // global
           I64[Sp - 8] = block_c1qME_info;
           _s1jtb::P64 = P64[R1 + 7];
           _s1jtc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1jtc::P64;
           P64[Sp + 16] = _s1jtb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1qMT; else goto c1qMF;
       u1qMT: // global
           call _c1qME(R1) args: 0, res: 0, upd: 0;
       c1qMF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qME() //  [R1]
         { info_tbl: [(c1qME,
                       label: block_c1qME_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qME: // global
           _s1jtb::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1qMJ_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1jtb::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c*_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qMJ() //  [R1, R2]
         { info_tbl: [(c1qMJ,
                       label: block_c1qMJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qMJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qMS; else goto c1qMR;
       c1qMS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qMR: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.725116642 UTC

[section ""data" . GHC.Real.$fNumRatio_closure" {
     GHC.Real.$fNumRatio_closure:
         const GHC.Real.$fNumRatio_info;
         const 0;
 },
 sat_s1jtq_entry() //  [R1, R2]
         { info_tbl: [(c1qNl,
                       label: sat_s1jtq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qNl: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$cfromInteger_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtp_entry() //  [R1, R2]
         { info_tbl: [(c1qNt,
                       label: sat_s1jtp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qNt: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$csignum_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jto_entry() //  [R1, R2]
         { info_tbl: [(c1qNB,
                       label: sat_s1jto_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qNB: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$cabs_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtn_entry() //  [R1, R2]
         { info_tbl: [(c1qNJ,
                       label: sat_s1jtn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qNJ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$cnegate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtm_entry() //  [R1, R2, R3]
         { info_tbl: [(c1qNR,
                       label: sat_s1jtm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qNR: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fNumRatio_$c*_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtl_entry() //  [R1, R2, R3]
         { info_tbl: [(c1qNZ,
                       label: sat_s1jtl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qNZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fNumRatio_$c-_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jtk_entry() //  [R1, R2, R3]
         { info_tbl: [(c1qO7,
                       label: sat_s1jtk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qO7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fNumRatio_$c+_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fNumRatio_entry() //  [R2]
         { info_tbl: [(c1qOb,
                       label: GHC.Real.$fNumRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qOb: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c1qOf; else goto c1qOe;
       c1qOf: // global
           HpAlloc = 176;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1qOe: // global
           I64[Hp - 168] = sat_s1jtq_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1jtp_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s1jto_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s1jtn_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s1jtm_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s1jtl_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1jtk_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 70;
           P64[Hp - 40] = Hp - 86;
           P64[Hp - 32] = Hp - 102;
           P64[Hp - 24] = Hp - 119;
           P64[Hp - 16] = Hp - 135;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 167;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.741975662 UTC

[section ""data" . GHC.Real.$fEnumRatio3_closure" {
     GHC.Real.$fEnumRatio3_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.744186107 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$csucc_closure" {
     GHC.Real.$fEnumRatio_$s$csucc_closure:
         const GHC.Real.$fEnumRatio_$s$csucc_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$csucc_entry() //  [R2]
         { info_tbl: [(c1qOV,
                       label: GHC.Real.$fEnumRatio_$s$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qOV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1qP1; else goto c1qP2;
       c1qP1: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1qP2: // global
           I64[Sp - 8] = block_c1qOS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1qP7; else goto c1qOT;
       u1qP7: // global
           call _c1qOS(R1) args: 0, res: 0, upd: 0;
       c1qOT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qOS() //  [R1]
         { info_tbl: [(c1qOS,
                       label: block_c1qOS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qOS: // global
           I64[Sp] = block_c1qOY_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qOY() //  [R1, R2]
         { info_tbl: [(c1qOY,
                       label: block_c1qOY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qOY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qP6; else goto c1qP5;
       c1qP6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qP5: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.75199871 UTC

[section ""data" . GHC.Real.$fEnumRatio_$csucc_closure" {
     GHC.Real.$fEnumRatio_$csucc_closure:
         const GHC.Real.$fEnumRatio_$csucc_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$csucc_entry() //  [R2, R3]
         { info_tbl: [(c1qPs,
                       label: GHC.Real.$fEnumRatio_$csucc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qPs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qPA; else goto c1qPB;
       c1qPA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$csucc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qPB: // global
           I64[Sp - 16] = block_c1qPp_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1qPH; else goto c1qPq;
       u1qPH: // global
           call _c1qPp(R1) args: 0, res: 0, upd: 0;
       c1qPq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qPp() //  [R1]
         { info_tbl: [(c1qPp,
                       label: block_c1qPp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qPp: // global
           I64[Sp - 16] = block_c1qPv_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qPv() //  [R1, R2]
         { info_tbl: [(c1qPv,
                       label: block_c1qPv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qPv: // global
           _s1jty::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1qPx_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = _s1jty::P64;
           Sp = Sp + 24;
           call GHC.Real.$w$c+_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qPx() //  [R1, R2]
         { info_tbl: [(c1qPx,
                       label: block_c1qPx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qPx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qPG; else goto c1qPF;
       c1qPG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qPF: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.761943529 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$cpred_closure" {
     GHC.Real.$fEnumRatio_$s$cpred_closure:
         const GHC.Real.$fEnumRatio_$s$cpred_info;
         const 0;
 },
 section ""relreadonly" . u1qQk_srtd" {
     u1qQk_srtd:
         const S1jKw_srt+464;
         const 72;
         const 1;
         const 144;
 },
 GHC.Real.$fEnumRatio_$s$cpred_entry() //  [R2]
         { info_tbl: [(c1qQ7,
                       label: GHC.Real.$fEnumRatio_$s$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qQ7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1qQd; else goto c1qQe;
       c1qQd: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1qQe: // global
           I64[Sp - 8] = block_c1qQ4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1qQj; else goto c1qQ5;
       u1qQj: // global
           call _c1qQ4(R1) args: 0, res: 0, upd: 0;
       c1qQ5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1qQl_srtd" {
     u1qQl_srtd:
         const S1jKw_srt+464;
         const 69;
         const 1;
         const 16;
 },
 _c1qQ4() //  [R1]
         { info_tbl: [(c1qQ4,
                       label: block_c1qQ4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qQ4: // global
           I64[Sp] = block_c1qQa_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qQa() //  [R1, R2]
         { info_tbl: [(c1qQa,
                       label: block_c1qQa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qQa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qQi; else goto c1qQh;
       c1qQi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qQh: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.771927786 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cpred_closure" {
     GHC.Real.$fEnumRatio_$cpred_closure:
         const GHC.Real.$fEnumRatio_$cpred_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$cpred_entry() //  [R2, R3]
         { info_tbl: [(c1qQI,
                       label: GHC.Real.$fEnumRatio_$cpred_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qQI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qQQ; else goto c1qQR;
       c1qQQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cpred_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qQR: // global
           I64[Sp - 16] = block_c1qQF_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1qQX; else goto c1qQG;
       u1qQX: // global
           call _c1qQF(R1) args: 0, res: 0, upd: 0;
       c1qQG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qQF() //  [R1]
         { info_tbl: [(c1qQF,
                       label: block_c1qQF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qQF: // global
           I64[Sp - 16] = block_c1qQL_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qQL() //  [R1, R2]
         { info_tbl: [(c1qQL,
                       label: block_c1qQL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qQL: // global
           _s1jtQ::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1qQN_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = _s1jtQ::P64;
           Sp = Sp + 24;
           call GHC.Real.$w$c-_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qQN() //  [R1, R2]
         { info_tbl: [(c1qQN,
                       label: block_c1qQN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qQN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qQW; else goto c1qQV;
       c1qQW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qQV: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.782263116 UTC

[section ""data" . GHC.Real.$fFractionalRatio_closure" {
     GHC.Real.$fFractionalRatio_closure:
         const GHC.Real.$fFractionalRatio_info;
         const 0;
 },
 sat_s1ju5_entry() //  [R1, R2]
         { info_tbl: [(c1qRp,
                       label: sat_s1ju5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qRp: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fFractionalRatio_$cfromRational_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ju4_entry() //  [R1, R2]
         { info_tbl: [(c1qRx,
                       label: sat_s1ju4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qRx: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fFractionalRatio_$crecip_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ju3_entry() //  [R1, R2, R3]
         { info_tbl: [(c1qRF,
                       label: sat_s1ju3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qRF: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fFractionalRatio_$c/_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ju2_entry() //  [R1]
         { info_tbl: [(c1qRM,
                       label: sat_s1ju2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qRM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qRN; else goto c1qRO;
       c1qRN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qRO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fNumRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fFractionalRatio_entry() //  [R2]
         { info_tbl: [(c1qRQ,
                       label: GHC.Real.$fFractionalRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qRQ: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1qRU; else goto c1qRT;
       c1qRU: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1qRT: // global
           I64[Hp - 104] = sat_s1ju5_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s1ju4_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1ju3_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1ju2_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.794210145 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFrom_closure" {
     GHC.Real.$fEnumRatio_$cenumFrom_closure:
         const GHC.Real.$fEnumRatio_$cenumFrom_info;
         const 0;
 },
 w_s1ju7_entry() //  [R1]
         { info_tbl: [(c1qSp,
                       label: w_s1ju7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qSp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qSq; else goto c1qSr;
       c1qSq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qSr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1juc_entry() //  [R1, R2]
         { info_tbl: [(c1qSA,
                       label: sat_s1juc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qSA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1qSB; else goto c1qSC;
       c1qSB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1qSC: // global
           I64[Sp - 8] = block_c1qSx_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qSx() //  [R1, R2]
         { info_tbl: [(c1qSx,
                       label: block_c1qSx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qSx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qSF; else goto c1qSE;
       c1qSF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qSE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEnumRatio_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c1qSG,
                       label: GHC.Real.$fEnumRatio_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qSG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1qSK; else goto c1qSJ;
       c1qSK: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1qSJ: // global
           I64[Hp - 32] = w_s1ju7_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s1juc_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.803982416 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFromThen_closure" {
     GHC.Real.$fEnumRatio_$cenumFromThen_closure:
         const GHC.Real.$fEnumRatio_$cenumFromThen_info;
         const 0;
 },
 w_s1jue_entry() //  [R1]
         { info_tbl: [(c1qTb,
                       label: w_s1jue_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qTb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qTc; else goto c1qTd;
       c1qTc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qTd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1juk_entry() //  [R1, R2, R3]
         { info_tbl: [(c1qTm,
                       label: sat_s1juk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qTm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1qTn; else goto c1qTo;
       c1qTn: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qTo: // global
           I64[Sp - 8] = block_c1qTj_info;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qTj() //  [R1, R2]
         { info_tbl: [(c1qTj,
                       label: block_c1qTj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qTj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qTr; else goto c1qTq;
       c1qTr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1qTq: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEnumRatio_$cenumFromThen_entry() //  [R2]
         { info_tbl: [(c1qTs,
                       label: GHC.Real.$fEnumRatio_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qTs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1qTw; else goto c1qTv;
       c1qTw: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFromThen_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1qTv: // global
           I64[Hp - 32] = w_s1jue_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s1juk_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.813966853 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFromTo_closure" {
     GHC.Real.$fEnumRatio_$cenumFromTo_closure:
         const GHC.Real.$fEnumRatio_$cenumFromTo_info;
         const 0;
 },
 sat_s1jun_entry() //  [R1]
         { info_tbl: [(c1qTX,
                       label: sat_s1jun_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qTX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qTY; else goto c1qTZ;
       c1qTY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qTZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jum_entry() //  [R1]
         { info_tbl: [(c1qU4,
                       label: sat_s1jum_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qU4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qU5; else goto c1qU6;
       c1qU5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qU6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1qUc_srtd" {
     u1qUc_srtd:
         const S1jKw_srt+624;
         const 58;
         const 153122387330596865;
 },
 GHC.Real.$fEnumRatio_$cenumFromTo_entry() //  [R2]
         { info_tbl: [(c1qU7,
                       label: GHC.Real.$fEnumRatio_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qU7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1qUb; else goto c1qUa;
       c1qUb: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFromTo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1qUa: // global
           I64[Hp - 40] = sat_s1jun_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s1jum_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.Real.numericEnumFromTo_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.823142024 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFromThenTo_closure" {
     GHC.Real.$fEnumRatio_$cenumFromThenTo_closure:
         const GHC.Real.$fEnumRatio_$cenumFromThenTo_info;
         const 0;
 },
 sat_s1juq_entry() //  [R1]
         { info_tbl: [(c1qUy,
                       label: sat_s1juq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qUy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qUz; else goto c1qUA;
       c1qUz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qUA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jup_entry() //  [R1]
         { info_tbl: [(c1qUF,
                       label: sat_s1jup_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qUF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qUG; else goto c1qUH;
       c1qUG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qUH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1qUN_srtd" {
     u1qUN_srtd:
         const S1jKw_srt+672;
         const 53;
         const 4644337115725825;
 },
 GHC.Real.$fEnumRatio_$cenumFromThenTo_entry() //  [R2]
         { info_tbl: [(c1qUI,
                       label: GHC.Real.$fEnumRatio_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qUI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1qUM; else goto c1qUL;
       c1qUM: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1qUL: // global
           I64[Hp - 40] = sat_s1juq_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s1jup_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.Real.numericEnumFromThenTo_closure+5;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.831130884 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$fRealRatio_closure" {
     GHC.Real.$fRealFracRatio_$s$fRealRatio_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Real.$fFractionalRatio_$s$fNumRatio_closure+1;
         const GHC.Real.$fOrdRatio_$s$fOrdRatio_closure+1;
         const GHC.Real.$fRealRatio_$s$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.833538584 UTC

[section ""data" . GHC.Real.$fRealRatio_closure" {
     GHC.Real.$fRealRatio_closure:
         const GHC.Real.$fRealRatio_info;
         const 0;
 },
 sat_s1juu_entry() //  [R1, R2]
         { info_tbl: [(c1qVb,
                       label: sat_s1juu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qVb: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fRealRatio_$ctoRational_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jut_entry() //  [R1]
         { info_tbl: [(c1qVi,
                       label: sat_s1jut_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qVi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qVj; else goto c1qVk;
       c1qVj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qVk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jus_entry() //  [R1]
         { info_tbl: [(c1qVp,
                       label: sat_s1jus_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qVp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qVq; else goto c1qVr;
       c1qVq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qVr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fNumRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fRealRatio_entry() //  [R2]
         { info_tbl: [(c1qVt,
                       label: GHC.Real.$fRealRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qVt: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1qVx; else goto c1qVw;
       c1qVx: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = GHC.Real.$fRealRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1qVw: // global
           I64[Hp - 88] = sat_s1juu_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1jut_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s1jus_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 87;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.843210112 UTC

[section ""data" . GHC.Real.$w$s$cceiling_closure" {
     GHC.Real.$w$s$cceiling_closure:
         const GHC.Real.$w$s$cceiling_info;
         const 0;
 },
 sat_s1juH_entry() //  [R1]
         { info_tbl: [(c1qWj,
                       label: sat_s1juH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qWj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qWk; else goto c1qWl;
       c1qWk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qWl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1qWD_srtd" {
     u1qWD_srtd:
         const S1jKw_srt+24;
         const 136;
         const 1;
         const 576461027181592576;
         const 128;
 },
 GHC.Real.$w$s$cceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qWm,
                       label: GHC.Real.$w$s$cceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qWm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1qWn; else goto c1qWo;
       c1qWn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qWo: // global
           I64[Sp - 16] = block_c1qVV_info;
           R4 = R4;
           R3 = R3;
           _s1juv::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s1juv::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1qWE_srtd" {
     u1qWE_srtd:
         const S1jKw_srt+24;
         const 124;
         const 1;
         const 576460752303685632;
 },
 _c1qVV() //  [R1, R2]
         { info_tbl: [(c1qVV,
                       label: block_c1qVV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qVV: // global
           I64[Sp - 8] = block_c1qVX_info;
           _s1juz::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1juz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1qWC; else goto c1qVY;
       u1qWC: // global
           call _c1qVX(R1) args: 0, res: 0, upd: 0;
       c1qVY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1qWF_srtd" {
     u1qWF_srtd:
         const S1jKw_srt+24;
         const 124;
         const 1;
         const 576460752303685632;
 },
 _c1qVX() //  [R1]
         { info_tbl: [(c1qVX,
                       label: block_c1qVX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qVX: // global
           I64[Sp] = block_c1qW2_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even1_closure;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qW2() //  [R1]
         { info_tbl: [(c1qW2,
                       label: block_c1qW2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qW2: // global
           if (R1 & 7 == 3) goto c1qWw; else goto c1qWu;
       c1qWw: // global
           I64[Sp] = block_c1qW7_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
       c1qWu: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1qW7() //  [R1]
         { info_tbl: [(c1qW7,
                       label: block_c1qW7_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qW7: // global
           I64[Sp] = block_c1qWb_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qWb() //  [R1]
         { info_tbl: [(c1qWb,
                       label: block_c1qWb_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qWb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qWA; else goto c1qWz;
       c1qWA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1qWz: // global
           I64[Hp - 16] = sat_s1juH_info;
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.860189662 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$cceiling_closure" {
     GHC.Real.$fRealFracRatio_$s$cceiling_closure:
         const GHC.Real.$fRealFracRatio_$s$cceiling_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$s$cceiling_entry() //  [R2, R3]
         { info_tbl: [(c1qXi,
                       label: GHC.Real.$fRealFracRatio_$s$cceiling_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qXi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1qXj; else goto c1qXk;
       c1qXj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$cceiling_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qXk: // global
           I64[Sp - 16] = block_c1qXf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1qXo; else goto c1qXg;
       u1qXo: // global
           call _c1qXf(R1) args: 0, res: 0, upd: 0;
       c1qXg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qXf() //  [R1]
         { info_tbl: [(c1qXf,
                       label: block_c1qXf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qXf: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cceiling_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.866595563 UTC

[section ""data" . GHC.Real.$w$cceiling_closure" {
     GHC.Real.$w$cceiling_closure:
         const GHC.Real.$w$cceiling_info;
         const 0;
 },
 sat_s1jv3_entry() //  [R1]
         { info_tbl: [(c1qY2,
                       label: sat_s1jv3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qY2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qY3; else goto c1qY4;
       c1qY3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qY4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1qYn_srtd" {
     u1qYn_srtd:
         const S1jKw_srt+680;
         const 56;
         const 36030996042252289;
 },
 GHC.Real.$w$cceiling_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1qY5,
                       label: GHC.Real.$w$cceiling_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qY5: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1qY6; else goto c1qY7;
       c1qY6: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cceiling_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qY7: // global
           I64[Sp - 24] = block_c1qXC_info;
           R5 = R5;
           R4 = R4;
           _s1juO::P64 = R3;
           R3 = R3;
           _s1juN::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1juN::P64;
           P64[Sp - 8] = _s1juO::P64;
           Sp = Sp - 24;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1qYo_srtd" {
     u1qYo_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1qXC() //  [R1, R2]
         { info_tbl: [(c1qXC,
                       label: block_c1qXC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qXC: // global
           I64[Sp - 8] = block_c1qXE_info;
           _s1juS::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1juS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1qYm; else goto c1qXF;
       u1qYm: // global
           call _c1qXE(R1) args: 0, res: 0, upd: 0;
       c1qXF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1qYp_srtd" {
     u1qYp_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1qXE() //  [R1]
         { info_tbl: [(c1qXE,
                       label: block_c1qXE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qXE: // global
           I64[Sp - 16] = block_c1qXJ_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qXJ() //  [R1, R2]
         { info_tbl: [(c1qXJ,
                       label: block_c1qXJ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qXJ: // global
           _s1juV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1qXL_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = _s1juV::P64;
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qXL() //  [R1]
         { info_tbl: [(c1qXL,
                       label: block_c1qXL_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qXL: // global
           if (R1 & 7 == 3) goto c1qYg; else goto c1qYe;
       c1qYg: // global
           I64[Sp] = block_c1qXQ_info;
           R2 = P64[Sp + 24];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
       c1qYe: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1qXQ() //  [R1]
         { info_tbl: [(c1qXQ,
                       label: block_c1qXQ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qXQ: // global
           I64[Sp] = block_c1qXU_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qXU() //  [R1]
         { info_tbl: [(c1qXU,
                       label: block_c1qXU_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qXU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1qYk; else goto c1qYj;
       c1qYk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1qYj: // global
           I64[Hp - 16] = sat_s1jv3_info;
           P64[Hp] = R1;
           R2 = R1;
           _s1juS::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1juS::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.88589124 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$cceiling_closure" {
     GHC.Real.$fRealFracRatio_$cceiling_closure:
         const GHC.Real.$fRealFracRatio_$cceiling_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$cceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(c1qZ7,
                       label: GHC.Real.$fRealFracRatio_$cceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qZ7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1qZ8; else goto c1qZ9;
       c1qZ8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$cceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1qZ9: // global
           I64[Sp - 24] = block_c1qZ4_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1qZd; else goto c1qZ5;
       u1qZd: // global
           call _c1qZ4(R1) args: 0, res: 0, upd: 0;
       c1qZ5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1qZ4() //  [R1]
         { info_tbl: [(c1qZ4,
                       label: block_c1qZ4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qZ4: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cceiling_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.892293329 UTC

[section ""data" . GHC.Real.$w$s$cfloor_closure" {
     GHC.Real.$w$s$cfloor_closure:
         const GHC.Real.$w$s$cfloor_info;
         const 0;
 },
 sat_s1jvo_entry() //  [R1]
         { info_tbl: [(c1qZX,
                       label: sat_s1jvo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qZX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1qZY; else goto c1qZZ;
       c1qZY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1qZZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1r0i_srtd" {
     u1r0i_srtd:
         const S1jKw_srt;
         const 143;
         const 1;
         const 4611688217452740608;
         const 16384;
 },
 GHC.Real.$w$s$cfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(c1r00,
                       label: GHC.Real.$w$s$cfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r00: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1r01; else goto c1r02;
       c1r01: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1r02: // global
           I64[Sp - 16] = block_c1qZr_info;
           R4 = R4;
           R3 = R3;
           _s1jva::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s1jva::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r0j_srtd" {
     u1r0j_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1qZr() //  [R1, R2]
         { info_tbl: [(c1qZr,
                       label: block_c1qZr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qZr: // global
           I64[Sp - 8] = block_c1qZt_info;
           _s1jve::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1jve::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1r0h; else goto c1qZu;
       u1r0h: // global
           call _c1qZt(R1) args: 0, res: 0, upd: 0;
       c1qZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r0k_srtd" {
     u1r0k_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1qZt() //  [R1]
         { info_tbl: [(c1qZt,
                       label: block_c1qZt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qZt: // global
           I64[Sp - 8] = block_c1qZy_info;
           R3 = P64[R1 + 15];
           R2 = GHC.Real.even1_closure;
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r0l_srtd" {
     u1r0l_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018427387904;
 },
 _c1qZy() //  [R1]
         { info_tbl: [(c1qZy,
                       label: block_c1qZy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qZy: // global
           I64[Sp] = block_c1qZC_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qZC() //  [R1]
         { info_tbl: [(c1qZC,
                       label: block_c1qZC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qZC: // global
           _s1jvk::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1qZG_info;
           R3 = _s1jvk::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qZG() //  [R1]
         { info_tbl: [(c1qZG,
                       label: block_c1qZG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qZG: // global
           if (R1 == 1) goto c1r0c; else goto c1r0a;
       c1r0c: // global
           I64[Sp] = block_c1qZL_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
       c1r0a: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1qZL() //  [R1]
         { info_tbl: [(c1qZL,
                       label: block_c1qZL_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qZL: // global
           I64[Sp] = block_c1qZP_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1qZP() //  [R1]
         { info_tbl: [(c1qZP,
                       label: block_c1qZP_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1qZP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1r0g; else goto c1r0f;
       c1r0g: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1r0f: // global
           I64[Hp - 16] = sat_s1jvo_info;
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.912880571 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$cfloor_closure" {
     GHC.Real.$fRealFracRatio_$s$cfloor_closure:
         const GHC.Real.$fRealFracRatio_$s$cfloor_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$s$cfloor_entry() //  [R2, R3]
         { info_tbl: [(c1r14,
                       label: GHC.Real.$fRealFracRatio_$s$cfloor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r14: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1r15; else goto c1r16;
       c1r15: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$cfloor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1r16: // global
           I64[Sp - 16] = block_c1r11_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1r1a; else goto c1r12;
       u1r1a: // global
           call _c1r11(R1) args: 0, res: 0, upd: 0;
       c1r12: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1r11() //  [R1]
         { info_tbl: [(c1r11,
                       label: block_c1r11_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r11: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.919980456 UTC

[section ""data" . GHC.Real.$w$cfloor_closure" {
     GHC.Real.$w$cfloor_closure:
         const GHC.Real.$w$cfloor_info;
         const 0;
 },
 sat_s1jvK_entry() //  [R1]
         { info_tbl: [(c1r1O,
                       label: sat_s1jvK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r1O: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1r1P; else goto c1r1Q;
       c1r1P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1r1Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1r29_srtd" {
     u1r29_srtd:
         const S1jKw_srt+680;
         const 60;
         const 576462951326711809;
 },
 GHC.Real.$w$cfloor_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1r1R,
                       label: GHC.Real.$w$cfloor_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r1R: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1r1S; else goto c1r1T;
       c1r1S: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cfloor_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1r1T: // global
           I64[Sp - 24] = block_c1r1o_info;
           R5 = R5;
           R4 = R4;
           _s1jvv::P64 = R3;
           R3 = R3;
           _s1jvu::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1jvu::P64;
           P64[Sp - 8] = _s1jvv::P64;
           Sp = Sp - 24;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r2a_srtd" {
     u1r2a_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1r1o() //  [R1, R2]
         { info_tbl: [(c1r1o,
                       label: block_c1r1o_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r1o: // global
           I64[Sp - 8] = block_c1r1q_info;
           _s1jvz::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1jvz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1r28; else goto c1r1r;
       u1r28: // global
           call _c1r1q(R1) args: 0, res: 0, upd: 0;
       c1r1r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r2b_srtd" {
     u1r2b_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1r1q() //  [R1]
         { info_tbl: [(c1r1q,
                       label: block_c1r1q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r1q: // global
           I64[Sp - 16] = block_c1r1v_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1r1v() //  [R1, R2]
         { info_tbl: [(c1r1v,
                       label: block_c1r1v_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r1v: // global
           _s1jvC::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1r1x_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = _s1jvC::P64;
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Real.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1r1x() //  [R1]
         { info_tbl: [(c1r1x,
                       label: block_c1r1x_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r1x: // global
           if (R1 & 7 == 1) goto c1r20; else goto c1r22;
       c1r20: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1r22: // global
           I64[Sp] = block_c1r1C_info;
           R2 = P64[Sp + 24];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1r1C() //  [R1]
         { info_tbl: [(c1r1C,
                       label: block_c1r1C_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r1C: // global
           I64[Sp] = block_c1r1G_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1r1G() //  [R1]
         { info_tbl: [(c1r1G,
                       label: block_c1r1G_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r1G: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1r26; else goto c1r25;
       c1r26: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1r25: // global
           I64[Hp - 16] = sat_s1jvK_info;
           P64[Hp] = R1;
           R2 = R1;
           _s1jvz::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1jvz::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.938742028 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$cfloor_closure" {
     GHC.Real.$fRealFracRatio_$cfloor_closure:
         const GHC.Real.$fRealFracRatio_$cfloor_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$cfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(c1r2T,
                       label: GHC.Real.$fRealFracRatio_$cfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r2T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1r2U; else goto c1r2V;
       c1r2U: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$cfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1r2V: // global
           I64[Sp - 24] = block_c1r2Q_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1r2Z; else goto c1r2R;
       u1r2Z: // global
           call _c1r2Q(R1) args: 0, res: 0, upd: 0;
       c1r2R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1r2Q() //  [R1]
         { info_tbl: [(c1r2Q,
                       label: block_c1r2Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r2Q: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cfloor_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.944189078 UTC

[section ""data" . sat_s1jvR_closure" {
     sat_s1jvR_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.94585966 UTC

[section ""data" . sat_s1jvS_closure" {
     sat_s1jvS_closure:
         const :_con_info;
         const sat_s1jvR_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.947784041 UTC

[section ""data" . GHC.Real.$fRealFracRatio2_closure" {
     GHC.Real.$fRealFracRatio2_closure:
         const GHC.Real.$fRealFracRatio2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fRealFracRatio2_entry() //  [R1]
         { info_tbl: [(c1r3h,
                       label: GHC.Real.$fRealFracRatio2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r3h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1r3i; else goto c1r3j;
       c1r3i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1r3j: // global
           (_c1r3e::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1r3e::I64 == 0) goto c1r3g; else goto c1r3f;
       c1r3g: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1r3f: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1r3e::I64;
           R3 = sat_s1jvS_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.954315244 UTC

[section ""data" . GHC.Real.$w$s$cround_closure" {
     GHC.Real.$w$s$cround_closure:
         const GHC.Real.$w$s$cround_info;
         const 0;
 },
 sat_s1jwe_entry() //  [R1]
         { info_tbl: [(c1r4j,
                       label: sat_s1jwe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r4j: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1r4k; else goto c1r4l;
       c1r4k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1r4l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jwf_entry() //  [R1]
         { info_tbl: [(c1r4s,
                       label: sat_s1jwf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r4s: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1r4t; else goto c1r4u;
       c1r4t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1r4u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1r5F_srtd" {
     u1r5F_srtd:
         const S1jKw_srt;
         const 149;
         const 288230376151711745;
         const 4611688217729565184;
         const 1572864;
 },
 GHC.Real.$w$s$cround_entry() //  [R2, R3, R4]
         { info_tbl: [(c1r4v,
                       label: GHC.Real.$w$s$cround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r4v: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1r4w; else goto c1r4x;
       c1r4w: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1r4x: // global
           I64[Sp - 16] = block_c1r3v_info;
           R4 = R4;
           R3 = R3;
           _s1jvT::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s1jvT::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r5G_srtd" {
     u1r5G_srtd:
         const S1jKw_srt;
         const 149;
         const 288230376151711745;
         const 4611686018706309632;
         const 1048576;
 },
 _c1r3v() //  [R1, R2]
         { info_tbl: [(c1r3v,
                       label: block_c1r3v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r3v: // global
           I64[Sp - 8] = block_c1r3x_info;
           _s1jvX::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1jvX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1r5A; else goto c1r3y;
       u1r5A: // global
           call _c1r3x(R1) args: 0, res: 0, upd: 0;
       c1r3y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r5H_srtd" {
     u1r5H_srtd:
         const S1jKw_srt;
         const 149;
         const 288230376151711745;
         const 4611686018706309632;
         const 1048576;
 },
 _c1r3x() //  [R1]
         { info_tbl: [(c1r3x,
                       label: block_c1r3x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r3x: // global
           I64[Sp - 16] = block_c1r3C_info;
           _s1jw0::P64 = P64[R1 + 7];
           R2 = _s1jw0::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _s1jw0::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r5I_srtd" {
     u1r5I_srtd:
         const S1jKw_srt;
         const 149;
         const 288230376151711745;
         const 4611686018706309632;
         const 1048576;
 },
 _c1r3C() //  [R1]
         { info_tbl: [(c1r3C,
                       label: block_c1r3C_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r3C: // global
           I64[Sp] = block_c1r3G_info;
           R5 = GHC.Real.even2_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[Sp + 8];
           R2 = R1;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r5J_srtd" {
     u1r5J_srtd:
         const S1jKw_srt;
         const 149;
         const 1;
         const 4611686018706309120;
         const 1048576;
 },
 _c1r3G() //  [R1]
         { info_tbl: [(c1r3G,
                       label: block_c1r3G_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r3G: // global
           I64[Sp] = block_c1r3I_info;
           R2 = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r5K_srtd" {
     u1r5K_srtd:
         const S1jKw_srt;
         const 149;
         const 1;
         const 4611686018706309120;
         const 1048576;
 },
 _c1r3I() //  [R1]
         { info_tbl: [(c1r3I,
                       label: block_c1r3I_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r3I: // global
           I64[Sp - 8] = block_c1r3M_info;
           R3 = GHC.Real.$fRealFracRatio2_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r5L_srtd" {
     u1r5L_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018706309120;
 },
 _c1r3M() //  [R1]
         { info_tbl: [(c1r3M,
                       label: block_c1r3M_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r3M: // global
           if (R1 == 1) goto u1r5w; else goto c1r4U;
       u1r5w: // global
           Sp = Sp + 32;
           call _c1r5u() args: 0, res: 0, upd: 0;
       c1r4U: // global
           I64[Sp] = block_c1r4D_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r5M_srtd" {
     u1r5M_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018706309120;
 },
 _c1r4D() //  [R1]
         { info_tbl: [(c1r4D,
                       label: block_c1r4D_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r4D: // global
           if (R1 == 1) goto c1r5g; else goto c1r51;
       c1r5g: // global
           I64[Sp + 8] = block_c1r5e_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
       c1r51: // global
           _s1jw6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1r4Y_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _s1jw6::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r5N_srtd" {
     u1r5N_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1r5e() //  [R1]
         { info_tbl: [(c1r5e,
                       label: block_c1r5e_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r5e: // global
           if (R1 & 7 == 1) goto u1r5y; else goto u1r5z;
       u1r5y: // global
           Sp = Sp + 8;
           call _s1jw8() args: 0, res: 0, upd: 0;
       u1r5z: // global
           Sp = Sp + 24;
           call _c1r5u() args: 0, res: 0, upd: 0;
     }
 },
 _c1r5u() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r5u: // global
           R1 = P64[Sp];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1r5O_srtd" {
     u1r5O_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018697920512;
 },
 _c1r4Y() //  [R1]
         { info_tbl: [(c1r4Y,
                       label: block_c1r4Y_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r4Y: // global
           if (R1 == 1) goto u1r5x; else goto c1r57;
       u1r5x: // global
           Sp = Sp + 8;
           call _s1jw8() args: 0, res: 0, upd: 0;
       c1r57: // global
           R1 = GHC.Real.$fRealFracRatio1_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s1jw8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jw8: // global
           I64[Sp - 8] = block_c1r3V_info;
           R2 = P64[Sp + 24];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r5P_srtd" {
     u1r5P_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1r3V() //  [R1]
         { info_tbl: [(c1r3V,
                       label: block_c1r3V_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r3V: // global
           I64[Sp] = block_c1r3Z_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r5Q_srtd" {
     u1r5Q_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1r3Z() //  [R1]
         { info_tbl: [(c1r3Z,
                       label: block_c1r3Z_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r3Z: // global
           _s1jw1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1r43_info;
           R3 = _s1jw1::P64;
           R2 = GHC.Real.even1_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1r5R_srtd" {
     u1r5R_srtd:
         const S1jKw_srt;
         const 127;
         const 1;
         const 4611686018427387904;
 },
 _c1r43() //  [R1]
         { info_tbl: [(c1r43,
                       label: block_c1r43_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r43: // global
           I64[Sp] = block_c1r47_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1r47() //  [R1]
         { info_tbl: [(c1r47,
                       label: block_c1r47_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r47: // global
           _s1jwc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1r4b_info;
           R3 = _s1jwc::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1r4b() //  [R1]
         { info_tbl: [(c1r4b,
                       label: block_c1r4b_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r4b: // global
           _s1jwa::P64 = P64[Sp + 16];
           if (R1 == 1) goto c1r4P; else goto c1r4L;
       c1r4P: // global
           Hp = Hp + 24;
           _s1jwd::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1r4S; else goto c1r4R;
       c1r4R: // global
           I64[Hp - 16] = sat_s1jwf_info;
           P64[Hp] = _s1jwa::P64;
           R2 = _s1jwa::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
       c1r4L: // global
           Hp = Hp + 24;
           _s1jwd::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1r4S; else goto c1r4N;
       c1r4S: // global
           HpAlloc = 24;
           R1 = _s1jwd::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1r4N: // global
           I64[Hp - 16] = sat_s1jwe_info;
           P64[Hp] = _s1jwa::P64;
           R2 = _s1jwa::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:05.996436236 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$cround_closure" {
     GHC.Real.$fRealFracRatio_$s$cround_closure:
         const GHC.Real.$fRealFracRatio_$s$cround_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$s$cround_entry() //  [R2, R3]
         { info_tbl: [(c1r7f,
                       label: GHC.Real.$fRealFracRatio_$s$cround_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r7f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1r7g; else goto c1r7h;
       c1r7g: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$cround_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1r7h: // global
           I64[Sp - 16] = block_c1r7c_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1r7l; else goto c1r7d;
       u1r7l: // global
           call _c1r7c(R1) args: 0, res: 0, upd: 0;
       c1r7d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1r7c() //  [R1]
         { info_tbl: [(c1r7c,
                       label: block_c1r7c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r7c: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cround_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.004418076 UTC

[section ""data" . GHC.Real.$w$cround_closure" {
     GHC.Real.$w$cround_closure:
         const GHC.Real.$w$cround_info;
         const 0;
 },
 sat_s1jx1_entry() //  [R1]
         { info_tbl: [(c1r8M,
                       label: sat_s1jx1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r8M: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1r8N; else goto c1r8O;
       c1r8N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1r8O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jx2_entry() //  [R1]
         { info_tbl: [(c1r8V,
                       label: sat_s1jx2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r8V: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1r8W; else goto c1r8X;
       c1r8W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1r8X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1rbi_srtd" {
     u1rbi_srtd:
         const S1jKw_srt+584;
         const 78;
         const 9156733004435457;
         const 8192;
 },
 GHC.Real.$w$cround_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1r8Y,
                       label: GHC.Real.$w$cround_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r8Y: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c1r8Z; else goto c1r90;
       c1r8Z: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cround_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1r90: // global
           I64[Sp - 24] = block_c1r7z_info;
           R5 = R5;
           R4 = R4;
           _s1jwp::P64 = R3;
           R3 = R3;
           _s1jwo::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1jwo::P64;
           P64[Sp - 8] = _s1jwp::P64;
           Sp = Sp - 24;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbj_srtd" {
     u1rbj_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1r7z() //  [R1, R2]
         { info_tbl: [(c1r7z,
                       label: block_c1r7z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r7z: // global
           I64[Sp - 8] = block_c1r7B_info;
           _s1jwt::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1jwt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1rb7; else goto c1r7C;
       u1rb7: // global
           call _c1r7B(R1) args: 0, res: 0, upd: 0;
       c1r7C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbk_srtd" {
     u1rbk_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1r7B() //  [R1]
         { info_tbl: [(c1r7B,
                       label: block_c1r7B_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r7B: // global
           I64[Sp - 16] = block_c1r7G_info;
           R2 = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbl_srtd" {
     u1rbl_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1r7G() //  [R1]
         { info_tbl: [(c1r7G,
                       label: block_c1r7G_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r7G: // global
           I64[Sp] = block_c1r7K_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbm_srtd" {
     u1rbm_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1r7K() //  [R1]
         { info_tbl: [(c1r7K,
                       label: block_c1r7K_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r7K: // global
           I64[Sp] = block_c1r7O_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbn_srtd" {
     u1rbn_srtd:
         const S1jKw_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1r7O() //  [R1]
         { info_tbl: [(c1r7O,
                       label: block_c1r7O_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r7O: // global
           I64[Sp - 8] = block_c1r7Q_info;
           R4 = GHC.Real.even2_closure;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 32];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$w$cfromRational_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbo_srtd" {
     u1rbo_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2233383035013;
 },
 _c1r7Q() //  [R1, R2]
         { info_tbl: [(c1r7Q,
                       label: block_c1r7Q_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r7Q: // global
           _s1jwA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1r7S_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 16];
           R3 = _s1jwA::P64;
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call GHC.Real.$w$c-_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbp_srtd" {
     u1rbp_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023296645;
 },
 _c1r7S() //  [R1]
         { info_tbl: [(c1r7S,
                       label: block_c1r7S_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r7S: // global
           I64[Sp] = block_c1r7U_info;
           R3 = R1;
           R2 = P64[Sp + 32];
           call GHC.Real.$w$csignum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbq_srtd" {
     u1rbq_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1r7U() //  [R1, R2]
         { info_tbl: [(c1r7U,
                       label: block_c1r7U_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r7U: // global
           I64[Sp - 16] = block_c1r7W_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           _s1jwJ::P64 = R2;
           R2 = P64[Sp + 32];
           P64[Sp - 8] = _s1jwJ::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbr_srtd" {
     u1rbr_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1r7W() //  [R1, R2]
         { info_tbl: [(c1r7W,
                       label: block_c1r7W_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r7W: // global
           I64[Sp - 16] = block_c1r7Y_info;
           _s1jwM::P64 = R2;
           R2 = P64[Sp + 48];
           P64[Sp - 8] = _s1jwM::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbs_srtd" {
     u1rbs_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1r7Y() //  [R1]
         { info_tbl: [(c1r7Y,
                       label: block_c1r7Y_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r7Y: // global
           I64[Sp] = block_c1r82_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbt_srtd" {
     u1rbt_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1r82() //  [R1]
         { info_tbl: [(c1r82,
                       label: block_c1r82_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r82: // global
           I64[Sp] = block_c1r86_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbu_srtd" {
     u1rbu_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1r86() //  [R1]
         { info_tbl: [(c1r86,
                       label: block_c1r86_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r86: // global
           I64[Sp - 8] = block_c1r88_info;
           R2 = P64[Sp + 64];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbv_srtd" {
     u1rbv_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1r88() //  [R1]
         { info_tbl: [(c1r88,
                       label: block_c1r88_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r88: // global
           I64[Sp] = block_c1r8c_info;
           R2 = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbw_srtd" {
     u1rbw_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1r8c() //  [R1]
         { info_tbl: [(c1r8c,
                       label: block_c1r8c_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r8c: // global
           I64[Sp] = block_c1r8g_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbx_srtd" {
     u1rbx_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1r8g() //  [R1]
         { info_tbl: [(c1r8g,
                       label: block_c1r8g_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r8g: // global
           I64[Sp] = block_c1r9f_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rby_srtd" {
     u1rby_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1r9f() //  [R1]
         { info_tbl: [(c1r9f,
                       label: block_c1r9f_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r9f: // global
           if (R1 & 7 == 1) goto u1raX; else goto c1raE;
       u1raX: // global
           Sp = Sp + 8;
           call _s1jwT() args: 0, res: 0, upd: 0;
       c1raE: // global
           I64[Sp] = block_c1raC_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbz_srtd" {
     u1rbz_srtd:
         const S1jKw_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1raC() //  [R1]
         { info_tbl: [(c1raC,
                       label: block_c1raC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1raC: // global
           if (R1 & 7 == 1) goto u1raY; else goto u1raZ;
       u1raY: // global
           Sp = Sp + 8;
           call _s1jwT() args: 0, res: 0, upd: 0;
       u1raZ: // global
           Sp = Sp + 64;
           call _c1raO() args: 0, res: 0, upd: 0;
     }
 },
 _s1jwT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jwT: // global
           I64[Sp - 8] = block_c1r8p_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 64];
           Sp = Sp - 8;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbA_srtd" {
     u1rbA_srtd:
         const S1jKw_srt+696;
         const 40;
         const 549755813921;
 },
 _c1r8p() //  [R1, R2]
         { info_tbl: [(c1r8p,
                       label: block_c1r8p_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r8p: // global
           I64[Sp - 16] = block_c1r9j_info;
           _s1jwW::P64 = R2;
           R2 = P64[Sp + 8];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[Sp + 40];
           P64[Sp - 24] = R1;
           P64[Sp - 8] = _s1jwW::P64;
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbB_srtd" {
     u1rbB_srtd:
         const S1jKw_srt+696;
         const 40;
         const 549755813921;
 },
 _c1r9j() //  [R1]
         { info_tbl: [(c1r9j,
                       label: block_c1r9j_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r9j: // global
           if (R1 & 7 == 1) goto u1rb0; else goto c1ra8;
       u1rb0: // global
           Sp = Sp + 8;
           call _s1jx3() args: 0, res: 0, upd: 0;
       c1ra8: // global
           I64[Sp] = block_c1ra6_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 48];
           P64[Sp - 8] = P64[Sp + 8];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbC_srtd" {
     u1rbC_srtd:
         const S1jKw_srt+696;
         const 40;
         const 549755813921;
 },
 _c1ra6() //  [R1]
         { info_tbl: [(c1ra6,
                       label: block_c1ra6_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ra6: // global
           if (R1 & 7 == 1) goto u1rb1; else goto c1raj;
       u1rb1: // global
           Sp = Sp + 8;
           call _s1jx3() args: 0, res: 0, upd: 0;
       c1raj: // global
           I64[Sp] = block_c1rah_info;
           R3 = P64[Sp + 80];
           R2 = P64[Sp + 96];
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _s1jx3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jx3: // global
           I64[Sp - 8] = block_c1r9B_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 48];
           P64[Sp - 16] = P64[Sp + 32];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbD_srtd" {
     u1rbD_srtd:
         const S1jKw_srt+736;
         const 35;
         const 17179869185;
 },
 _c1r9B() //  [R1]
         { info_tbl: [(c1r9B,
                       label: block_c1r9B_info
                       rep:StackRep [False, False, False, False, True, False, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r9B: // global
           if (R1 & 7 == 1) goto u1rb4; else goto c1r9N;
       u1rb4: // global
           Sp = Sp + 104;
           call _c1r9T() args: 0, res: 0, upd: 0;
       c1r9N: // global
           I64[Sp] = block_c1r9L_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 48];
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rbE_srtd" {
     u1rbE_srtd:
         const S1jKw_srt+736;
         const 35;
         const 17179869185;
 },
 _c1r9L() //  [R1]
         { info_tbl: [(c1r9L,
                       label: block_c1r9L_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r9L: // global
           if (R1 & 7 == 1) goto u1rb5; else goto u1rb6;
       u1rb5: // global
           Sp = Sp + 104;
           call _c1r9T() args: 0, res: 0, upd: 0;
       u1rb6: // global
           Sp = Sp + 8;
           call _s1jwX() args: 0, res: 0, upd: 0;
     }
 },
 _c1r9T() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r9T: // global
           R1 = GHC.Real.$fRealFracRatio1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1rah() //  [R1]
         { info_tbl: [(c1rah,
                       label: block_c1rah_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rah: // global
           if (R1 & 7 == 1) goto u1rb2; else goto u1rb3;
       u1rb2: // global
           Sp = Sp + 8;
           call _s1jwX() args: 0, res: 0, upd: 0;
       u1rb3: // global
           Sp = Sp + 80;
           call _c1raO() args: 0, res: 0, upd: 0;
     }
 },
 _s1jwX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1jwX: // global
           I64[Sp - 8] = block_c1r8w_info;
           R2 = P64[Sp + 88];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1r8w() //  [R1]
         { info_tbl: [(c1r8w,
                       label: block_c1r8w_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r8w: // global
           I64[Sp] = block_c1r8A_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1r8A() //  [R1]
         { info_tbl: [(c1r8A,
                       label: block_c1r8A_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r8A: // global
           _s1jww::P64 = P64[Sp + 72];
           I64[Sp + 72] = block_c1r8E_info;
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 64];
           R3 = _s1jww::P64;
           R2 = P64[Sp + 88];
           P64[Sp + 96] = R1;
           Sp = Sp + 72;
           call GHC.Real.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1r8E() //  [R1]
         { info_tbl: [(c1r8E,
                       label: block_c1r8E_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1r8E: // global
           _s1jwt::P64 = P64[Sp + 8];
           _s1jwZ::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c1r9q; else goto c1r9u;
       c1r9q: // global
           Hp = Hp + 24;
           _s1jx0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1r9x; else goto c1r9s;
       c1r9s: // global
           I64[Hp - 16] = sat_s1jx1_info;
           P64[Hp] = _s1jwZ::P64;
           R2 = _s1jwZ::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1jwt::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
       c1r9u: // global
           Hp = Hp + 24;
           _s1jx0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1r9x; else goto c1r9w;
       c1r9x: // global
           HpAlloc = 24;
           R1 = _s1jx0::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1r9w: // global
           I64[Hp - 16] = sat_s1jx2_info;
           P64[Hp] = _s1jwZ::P64;
           R2 = _s1jwZ::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1jwt::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _c1raO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1raO: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.076526236 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$cround_closure" {
     GHC.Real.$fRealFracRatio_$cround_closure:
         const GHC.Real.$fRealFracRatio_$cround_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$cround_entry() //  [R2, R3, R4]
         { info_tbl: [(c1rek,
                       label: GHC.Real.$fRealFracRatio_$cround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rek: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rel; else goto c1rem;
       c1rel: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$cround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rem: // global
           I64[Sp - 24] = block_c1reh_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1req; else goto c1rei;
       u1req: // global
           call _c1reh(R1) args: 0, res: 0, upd: 0;
       c1rei: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1reh() //  [R1]
         { info_tbl: [(c1reh,
                       label: block_c1reh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1reh: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cround_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.082932954 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$ctruncate_closure" {
     GHC.Real.$fRealFracRatio_$s$ctruncate_closure:
         const GHC.Real.$fRealFracRatio_$s$ctruncate_info;
         const 0;
 },
 sat_s1jxt_entry() //  [R1]
         { info_tbl: [(c1reS,
                       label: sat_s1jxt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1reS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1reT; else goto c1reU;
       c1reT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1reU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c1reN_info;
           R3 = GHC.Real.even1_closure;
           _s1jxl::P64 = P64[R1 + 24];
           R2 = _s1jxl::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s1jxl::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1reN() //  [R1]
         { info_tbl: [(c1reN,
                       label: block_c1reN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1reN: // global
           if (R1 == 1) goto c1reR; else goto c1reQ;
       c1reR: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c1reQ: // global
           _s1jxl::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1reX_info;
           R3 = _s1jxl::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1reX() //  [R1]
         { info_tbl: [(c1reX,
                       label: block_c1reX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1reX: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fRealFracRatio_$s$ctruncate_entry() //  [R2, R3]
         { info_tbl: [(c1rf4,
                       label: GHC.Real.$fRealFracRatio_$s$ctruncate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rf4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rfa; else goto c1rfb;
       c1rfa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$ctruncate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rfb: // global
           I64[Sp - 16] = block_c1reE_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1rfk; else goto c1reF;
       u1rfk: // global
           call _c1reE(R1) args: 0, res: 0, upd: 0;
       c1reF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1reE() //  [R1]
         { info_tbl: [(c1reE,
                       label: block_c1reE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1reE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1rfe; else goto c1rfd;
       c1rfe: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rfd: // global
           _s1jxk::P64 = P64[R1 + 7];
           _s1jxl::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s1jxt_info;
           P64[Hp - 8] = _s1jxk::P64;
           P64[Hp] = _s1jxl::P64;
           I64[Sp] = block_c1rf5_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rf5() //  [R1]
         { info_tbl: [(c1rf5,
                       label: block_c1rf5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rf5: // global
           I64[Sp] = block_c1rf9_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rf9() //  [R1]
         { info_tbl: [(c1rf9,
                       label: block_c1rf9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rf9: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.098232912 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$ctruncate_closure" {
     GHC.Real.$fRealFracRatio_$ctruncate_closure:
         const GHC.Real.$fRealFracRatio_$ctruncate_info;
 },
 GHC.Real.$fRealFracRatio_$ctruncate_entry() //  [R2, R3, R4]
         { info_tbl: [(c1rfV,
                       label: GHC.Real.$fRealFracRatio_$ctruncate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rfV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rfZ; else goto c1rg0;
       c1rfZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$ctruncate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rg0: // global
           I64[Sp - 24] = block_c1rfS_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1rg4; else goto c1rfT;
       u1rg4: // global
           call _c1rfS(R1) args: 0, res: 0, upd: 0;
       c1rfT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rfS() //  [R1]
         { info_tbl: [(c1rfS,
                       label: block_c1rfS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rfS: // global
           _s1jxv::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1rfY_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _s1jxv::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rfY() //  [R1]
         { info_tbl: [(c1rfY,
                       label: block_c1rfY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rfY: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.105302725 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$fRealFracRatio_closure" {
     GHC.Real.$fRealFracRatio_$s$fRealFracRatio_closure:
         const GHC.Real.C:RealFrac_con_info;
         const GHC.Real.$fRealFracRatio_$s$fRealRatio_closure+1;
         const GHC.Real.$fFractionalRatio_$s$fFractionalRatio_closure+1;
         const GHC.Real.$fEnumRatio_$s$cproperFraction_closure+2;
         const GHC.Real.$fRealFracRatio_$s$ctruncate_closure+2;
         const GHC.Real.$fRealFracRatio_$s$cround_closure+2;
         const GHC.Real.$fRealFracRatio_$s$cceiling_closure+2;
         const GHC.Real.$fRealFracRatio_$s$cfloor_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.108294195 UTC

[section ""data" . GHC.Real.$fRealFracRatio_closure" {
     GHC.Real.$fRealFracRatio_closure:
         const GHC.Real.$fRealFracRatio_info;
         const 0;
 },
 sat_s1jxK_entry() //  [R1, R2, R3]
         { info_tbl: [(c1rgr,
                       label: sat_s1jxK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rgr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$cfloor_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxJ_entry() //  [R1, R2, R3]
         { info_tbl: [(c1rgz,
                       label: sat_s1jxJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rgz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$cceiling_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxI_entry() //  [R1, R2, R3]
         { info_tbl: [(c1rgH,
                       label: sat_s1jxI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rgH: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$cround_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxH_entry() //  [R1, R2, R3]
         { info_tbl: [(c1rgP,
                       label: sat_s1jxH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rgP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$ctruncate_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxG_entry() //  [R1, R2, R3]
         { info_tbl: [(c1rgX,
                       label: sat_s1jxG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rgX: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fEnumRatio_$cproperFraction_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jxF_entry() //  [R1]
         { info_tbl: [(c1rh4,
                       label: sat_s1jxF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rh4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rh5; else goto c1rh6;
       c1rh5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rh6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jxE_entry() //  [R1]
         { info_tbl: [(c1rhb,
                       label: sat_s1jxE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rhb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rhc; else goto c1rhd;
       c1rhc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rhd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fRealRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fRealFracRatio_entry() //  [R2]
         { info_tbl: [(c1rhf,
                       label: GHC.Real.$fRealFracRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rhf: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c1rhj; else goto c1rhi;
       c1rhj: // global
           HpAlloc = 192;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1rhi: // global
           I64[Hp - 184] = sat_s1jxK_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s1jxJ_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1jxI_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s1jxH_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s1jxG_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s1jxF_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s1jxE_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 118;
           P64[Hp - 24] = Hp - 134;
           P64[Hp - 16] = Hp - 150;
           P64[Hp - 8] = Hp - 166;
           P64[Hp] = Hp - 182;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.126335029 UTC

[section ""data" . g_r1j3N_closure" {
     g_r1j3N_closure:
         const g_r1j3N_info;
         const 0;
 },
 section ""relreadonly" . u1riW_srtd" {
     u1riW_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 g_r1j3N_entry() //  [R2, R3, R4]
         { info_tbl: [(c1rhZ,
                       label: g_r1j3N_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rhZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ri0; else goto u1riQ;
       c1ri0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = g_r1j3N_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u1riQ: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c1rhU() args: 0, res: 0, upd: 0;
     }
 },
 _c1rhU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rhU: // global
           I64[Sp - 8] = block_c1rhX_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1riX_srtd" {
     u1riX_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1rhX() //  [R1]
         { info_tbl: [(c1rhX,
                       label: block_c1rhX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rhX: // global
           I64[Sp] = block_c1ri4_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1riY_srtd" {
     u1riY_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1ri4() //  [R1]
         { info_tbl: [(c1ri4,
                       label: block_c1ri4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ri4: // global
           _s1jxM::P64 = P64[Sp + 16];
           if (R1 == 1) goto c1riK; else goto c1ric;
       c1riK: // global
           I64[Sp] = block_c1riE_info;
           R3 = GHC.Real.even2_closure;
           R2 = _s1jxM::P64;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       c1ric: // global
           I64[Sp] = block_c1ri9_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _s1jxM::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1riZ_srtd" {
     u1riZ_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1riE() //  [R1]
         { info_tbl: [(c1riE,
                       label: block_c1riE_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1riE: // global
           _s1jxL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1riI_info;
           R3 = _s1jxL::P64;
           R2 = _s1jxL::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rj0_srtd" {
     u1rj0_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1riI() //  [R1]
         { info_tbl: [(c1riI,
                       label: block_c1riI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1riI: // global
           P64[Sp] = R1;
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           call _c1rhU() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1rj1_srtd" {
     u1rj1_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1ri9() //  [R1]
         { info_tbl: [(c1ri9,
                       label: block_c1ri9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ri9: // global
           _s1jxL::P64 = P64[Sp + 8];
           _s1jxN::P64 = P64[Sp + 24];
           if (R1 == 1) goto c1riB; else goto c1rir;
       c1riB: // global
           R3 = _s1jxN::P64;
           R2 = _s1jxL::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
       c1rir: // global
           I64[Sp] = block_c1rig_info;
           R3 = _s1jxN::P64;
           R2 = _s1jxL::P64;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rj2_srtd" {
     u1rj2_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1rig() //  [R1]
         { info_tbl: [(c1rig,
                       label: block_c1rig_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rig: // global
           I64[Sp] = block_c1rik_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 16];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rj3_srtd" {
     u1rj3_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1rik() //  [R1]
         { info_tbl: [(c1rik,
                       label: block_c1rik_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rik: // global
           _s1jxL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1rio_info;
           R3 = _s1jxL::P64;
           R2 = _s1jxL::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rj4_srtd" {
     u1rj4_srtd:
         const S1jKw_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1rio() //  [R1]
         { info_tbl: [(c1rio,
                       label: block_c1rio_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rio: // global
           P64[Sp] = R1;
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           call _c1rhU() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.151230334 UTC

[section ""data" . GHC.Real.^_f_closure" {
     GHC.Real.^_f_closure:
         const GHC.Real.^_f_info;
         const 0;
 },
 section ""relreadonly" . u1rkJ_srtd" {
     u1rkJ_srtd:
         const S1jKw_srt;
         const 158;
         const 1;
         const 4611686018427388416;
         const 838860800;
 },
 GHC.Real.^_f_entry() //  [R2, R3]
         { info_tbl: [(c1rjT,
                       label: GHC.Real.^_f_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rjT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rjU; else goto u1rkF;
       c1rjU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_f_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1rkF: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1rjO() args: 0, res: 0, upd: 0;
     }
 },
 _c1rjO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rjO: // global
           I64[Sp - 8] = block_c1rjR_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rkK_srtd" {
     u1rkK_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1rjR() //  [R1]
         { info_tbl: [(c1rjR,
                       label: block_c1rjR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rjR: // global
           I64[Sp] = block_c1rjY_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rkL_srtd" {
     u1rkL_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1rjY() //  [R1]
         { info_tbl: [(c1rjY,
                       label: block_c1rjY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rjY: // global
           _s1jxX::P64 = P64[Sp + 16];
           if (R1 == 1) goto c1rkz; else goto c1rk6;
       c1rkz: // global
           I64[Sp] = block_c1rkt_info;
           R3 = GHC.Real.even2_closure;
           R2 = _s1jxX::P64;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       c1rk6: // global
           I64[Sp] = block_c1rk3_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _s1jxX::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rkM_srtd" {
     u1rkM_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1rkt() //  [R1]
         { info_tbl: [(c1rkt,
                       label: block_c1rkt_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rkt: // global
           _s1jxW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1rkx_info;
           R3 = _s1jxW::P64;
           R2 = _s1jxW::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rkN_srtd" {
     u1rkN_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1rkx() //  [R1]
         { info_tbl: [(c1rkx,
                       label: block_c1rkx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rkx: // global
           P64[Sp] = R1;
           P64[Sp + 8] = P64[Sp + 8];
           call _c1rjO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1rkO_srtd" {
     u1rkO_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 512;
         const 268435456;
 },
 _c1rk3() //  [R1]
         { info_tbl: [(c1rk3,
                       label: block_c1rk3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rk3: // global
           if (R1 == 1) goto c1rkq; else goto c1rkh;
       c1rkq: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1rkh: // global
           I64[Sp] = block_c1rka_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rkP_srtd" {
     u1rkP_srtd:
         const S1jKw_srt;
         const 157;
         const 1;
         const 0;
         const 268435456;
 },
 _c1rka() //  [R1]
         { info_tbl: [(c1rka,
                       label: block_c1rka_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rka: // global
           I64[Sp] = block_c1rke_info;
           _s1jxW::P64 = P64[Sp + 8];
           R3 = _s1jxW::P64;
           R2 = _s1jxW::P64;
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rke() //  [R1]
         { info_tbl: [(c1rke,
                       label: block_c1rke_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rke: // global
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = R1;
           Sp = Sp + 24;
           call g_r1j3N_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.172215163 UTC

[section ""cstring" . lvl5_r1j3O_bytes" {
     lvl5_r1j3O_bytes:
         I8[] [78,101,103,97,116,105,118,101,32,101,120,112,111,110,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.175260215 UTC

[section ""data" . GHC.Real.^1_closure" {
     GHC.Real.^1_closure:
         const GHC.Real.^1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.^1_entry() //  [R1]
         { info_tbl: [(c1rlB,
                       label: GHC.Real.^1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rlB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rlC; else goto c1rlD;
       c1rlC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rlD: // global
           (_c1rlw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1rlw::I64 == 0) goto c1rly; else goto c1rlx;
       c1rly: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1rlx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1rlw::I64;
           I64[Sp - 24] = block_c1rlz_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1rlz() //  [R1]
         { info_tbl: [(c1rlz,
                       label: block_c1rlz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rlz: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.181378635 UTC

[section ""data" . GHC.Real.^_$s^_closure" {
     GHC.Real.^_$s^_closure:
         const GHC.Real.^_$s^_info;
         const 0;
 },
 section ""relreadonly" . u1rmk_srtd" {
     u1rmk_srtd:
         const S1jKw_srt+1008;
         const 35;
         const 28051505153;
 },
 GHC.Real.^_$s^_entry() //  [R2, R3]
         { info_tbl: [(c1rm0,
                       label: GHC.Real.^_$s^_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rm0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rm1; else goto c1rm2;
       c1rm1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_$s^_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rm2: // global
           I64[Sp - 24] = block_c1rlV_info;
           _s1jy7::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jy6::P64 = R2;
           R2 = _s1jy7::P64;
           P64[Sp - 16] = _s1jy6::P64;
           P64[Sp - 8] = _s1jy7::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rml_srtd" {
     u1rml_srtd:
         const S1jKw_srt+1008;
         const 35;
         const 19461570561;
 },
 _c1rlV() //  [R1]
         { info_tbl: [(c1rlV,
                       label: block_c1rlV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rlV: // global
           if (R1 == 1) goto c1rlZ; else goto c1rlY;
       c1rlZ: // global
           R1 = GHC.Real.^1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1rlY: // global
           I64[Sp] = block_c1rm5_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rm5() //  [R1]
         { info_tbl: [(c1rm5,
                       label: block_c1rm5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rm5: // global
           if (R1 == 1) goto c1rmg; else goto c1rmc;
       c1rmg: // global
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1rmc: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.^_f_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.190569706 UTC

[section ""data" . GHC.Real.$w$s$cfromEnum_closure" {
     GHC.Real.$w$s$cfromEnum_closure:
         const GHC.Real.$w$s$cfromEnum_info;
         const 0;
 },
 GHC.Real.$w$s$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c1rmK,
                       label: GHC.Real.$w$s$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rmK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rmL; else goto c1rmM;
       c1rmL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rmM: // global
           I64[Sp - 24] = block_c1rmF_info;
           _s1jyb::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1jya::P64 = R2;
           R2 = _s1jyb::P64;
           P64[Sp - 16] = _s1jya::P64;
           P64[Sp - 8] = _s1jyb::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rmF() //  [R1]
         { info_tbl: [(c1rmF,
                       label: block_c1rmF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rmF: // global
           if (R1 == 1) goto c1rmJ; else goto c1rmI;
       c1rmJ: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1rmI: // global
           _s1jyb::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1rmP_info;
           R3 = _s1jyb::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rmP() //  [R1]
         { info_tbl: [(c1rmP,
                       label: block_c1rmP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rmP: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.199157815 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$cfromEnum_closure" {
     GHC.Real.$fEnumRatio_$s$cfromEnum_closure:
         const GHC.Real.$fEnumRatio_$s$cfromEnum_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$cfromEnum_entry() //  [R2]
         { info_tbl: [(c1rne,
                       label: GHC.Real.$fEnumRatio_$s$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rne: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1rnm; else goto c1rnn;
       c1rnm: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1rnn: // global
           I64[Sp - 8] = block_c1rnb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1rns; else goto c1rnc;
       u1rns: // global
           call _c1rnb(R1) args: 0, res: 0, upd: 0;
       c1rnc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rnb() //  [R1]
         { info_tbl: [(c1rnb,
                       label: block_c1rnb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rnb: // global
           I64[Sp] = block_c1rnh_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$cfromEnum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rnh() //  [R1]
         { info_tbl: [(c1rnh,
                       label: block_c1rnh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rnh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1rnr; else goto c1rnq;
       c1rnr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1rnq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.20693447 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cfromEnum_closure" {
     GHC.Real.$fEnumRatio_$cfromEnum_closure:
         const GHC.Real.$fEnumRatio_$cfromEnum_info;
 },
 sat_s1jyu_entry() //  [R1]
         { info_tbl: [(c1rnV,
                       label: sat_s1jyu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rnV: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1rnW; else goto c1rnX;
       c1rnW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rnX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1rnT_info;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_pp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1rnT() //  [R1]
         { info_tbl: [(c1rnT,
                       label: block_c1rnT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rnT: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fEnumRatio_$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c1ro1,
                       label: GHC.Real.$fEnumRatio_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ro1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rob; else goto c1roc;
       c1rob: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1roc: // global
           I64[Sp - 16] = block_c1rnK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1rok; else goto c1rnL;
       u1rok: // global
           call _c1rnK(R1) args: 0, res: 0, upd: 0;
       c1rnL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rnK() //  [R1]
         { info_tbl: [(c1rnK,
                       label: block_c1rnK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rnK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1rof; else goto c1roe;
       c1rof: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1roe: // global
           _s1jyp::P64 = P64[R1 + 7];
           _s1jyq::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s1jyu_info;
           _s1jym::P64 = P64[Sp + 8];
           P64[Hp - 16] = _s1jym::P64;
           P64[Hp - 8] = _s1jyp::P64;
           P64[Hp] = _s1jyq::P64;
           I64[Sp + 8] = block_c1ro2_info;
           R2 = _s1jym::P64;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Hp - 32;
           Sp = Sp - 8;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1ro2() //  [R1]
         { info_tbl: [(c1ro2,
                       label: block_c1ro2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ro2: // global
           I64[Sp] = block_c1ro6_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ro6() //  [R1]
         { info_tbl: [(c1ro6,
                       label: block_c1ro6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ro6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1roj; else goto c1roi;
       c1roj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1roi: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.220577175 UTC

[section ""data" . GHC.Real.ratioPrec1_closure" {
     GHC.Real.ratioPrec1_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.222851711 UTC

[section ""cstring" . GHC.Real.$fShowRatio2_bytes" {
     GHC.Real.$fShowRatio2_bytes:
         I8[] [32,37,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.226224202 UTC

[section ""data" . GHC.Real.$w$s$cshowsPrec_closure" {
     GHC.Real.$w$s$cshowsPrec_closure:
         const GHC.Real.$w$s$cshowsPrec_info;
         const 0;
 },
 GHC.Real.$w$s$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1roO: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Real.$w$s$cshowsPrec_entry(R5,
                                               R4,
                                               R3,
                                               R2,
                                               R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jyF_entry() //  [R1]
         { info_tbl: [(c1rp6,
                       label: sat_s1jyF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rp6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rp7; else goto c1rp8;
       c1rp7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rp8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1rp3_info;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1rp3() //  [R1, R2]
         { info_tbl: [(c1rp3,
                       label: block_c1rp3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rp3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rpb; else goto c1rpa;
       c1rpb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1rpa: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jyG_entry() //  [R1]
         { info_tbl: [(c1rpc,
                       label: sat_s1jyG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rpc: // global
           _s1jyG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1rpd; else goto c1rpe;
       c1rpe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1rpg; else goto c1rpf;
       c1rpg: // global
           HpAlloc = 32;
           goto c1rpd;
       c1rpd: // global
           R1 = _s1jyG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rpf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jyG::P64;
           _s1jyz::P64 = P64[_s1jyG::P64 + 16];
           _s1jyA::P64 = P64[_s1jyG::P64 + 24];
           I64[Hp - 24] = sat_s1jyF_info;
           P64[Hp - 8] = _s1jyz::P64;
           P64[Hp] = _s1jyA::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jyL_entry() //  [R1]
         { info_tbl: [(c1rpy,
                       label: sat_s1jyL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rpy: // global
           _s1jyL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1rpz; else goto c1rpA;
       c1rpA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rpC; else goto c1rpB;
       c1rpC: // global
           HpAlloc = 24;
           goto c1rpz;
       c1rpz: // global
           R1 = _s1jyL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rpB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jyL::P64;
           _s1jyz::P64 = P64[_s1jyL::P64 + 16];
           _s1jyA::P64 = P64[_s1jyL::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s1jyA::P64;
           I64[Sp - 24] = block_c1rpv_info;
           R4 = Hp - 14;
           R3 = _s1jyz::P64;
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1rpv() //  [R1, R2]
         { info_tbl: [(c1rpv,
                       label: block_c1rpv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rpv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rpF; else goto c1rpE;
       c1rpF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1rpE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jyM_entry() //  [R1]
         { info_tbl: [(c1rpG,
                       label: sat_s1jyM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rpG: // global
           _s1jyM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1rpH; else goto c1rpI;
       c1rpI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1rpK; else goto c1rpJ;
       c1rpK: // global
           HpAlloc = 32;
           goto c1rpH;
       c1rpH: // global
           R1 = _s1jyM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rpJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jyM::P64;
           _s1jyz::P64 = P64[_s1jyM::P64 + 16];
           _s1jyA::P64 = P64[_s1jyM::P64 + 24];
           I64[Hp - 24] = sat_s1jyL_info;
           P64[Hp - 8] = _s1jyz::P64;
           P64[Hp] = _s1jyA::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jyQ_entry() //  [R1]
         { info_tbl: [(c1rpO,
                       label: sat_s1jyQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rpO: // global
           _s1jyQ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1rpP; else goto c1rpQ;
       c1rpQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1rpS; else goto c1rpR;
       c1rpS: // global
           HpAlloc = 32;
           goto c1rpP;
       c1rpP: // global
           R1 = _s1jyQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rpR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jyQ::P64;
           _s1jyy::P64 = P64[_s1jyQ::P64 + 16];
           _s1jyz::P64 = P64[_s1jyQ::P64 + 24];
           _s1jyA::P64 = P64[_s1jyQ::P64 + 32];
           I64[Hp - 24] = sat_s1jyM_info;
           P64[Hp - 8] = _s1jyz::P64;
           P64[Hp] = _s1jyA::P64;
           I64[Sp - 24] = block_c1rpL_info;
           R4 = Hp - 24;
           R3 = _s1jyy::P64;
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1rpL() //  [R1, R2]
         { info_tbl: [(c1rpL,
                       label: block_c1rpL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rpL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rpV; else goto c1rpU;
       c1rpV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1rpU: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$s$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1rpZ,
                       label: GHC.Real.$w$s$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rpZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1rq3; else goto c1rq2;
       c1rq3: // global
           HpAlloc = 40;
           R1 = GHC.Real.$w$s$cshowsPrec_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c1rq2: // global
           if (%MO_S_Le_W64(R2, 7)) goto c1rpX; else goto c1rpY;
       c1rpX: // global
           I64[Hp - 32] = sat_s1jyG_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           _c1roV::P64 = Hp - 32;
           Hp = Hp - 8;
           R4 = _c1roV::P64;
           R3 = R3;
           R2 = 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
       c1rpY: // global
           I64[Hp - 32] = sat_s1jyQ_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 32;
           R1 = GHC.Show.$fShow(,)4_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.249677393 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$cshowsPrec_closure" {
     GHC.Real.$fShowRatio_$s$cshowsPrec_closure:
         const GHC.Real.$fShowRatio_$s$cshowsPrec_info;
         const 0;
 },
 GHC.Real.$fShowRatio_$s$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c1rqO,
                       label: GHC.Real.$fShowRatio_$s$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rqO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rqZ; else goto c1rr0;
       c1rqZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$s$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rr0: // global
           I64[Sp - 24] = block_c1rqL_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1rr7; else goto c1rqM;
       u1rr7: // global
           call _c1rqL(R1) args: 0, res: 0, upd: 0;
       c1rqM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rqL() //  [R1]
         { info_tbl: [(c1rqL,
                       label: block_c1rqL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rqL: // global
           I64[Sp] = block_c1rqR_info;
           _s1jyV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jyV::I64;
           if (R1 & 7 != 0) goto u1rr6; else goto c1rqS;
       u1rr6: // global
           call _c1rqR(R1) args: 0, res: 0, upd: 0;
       c1rqS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rqR() //  [R1]
         { info_tbl: [(c1rqR,
                       label: block_c1rqR_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rqR: // global
           _s1jyT::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1rqW_info;
           R5 = _s1jyT::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cshowsPrec_entry(R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rqW() //  [R1, R2]
         { info_tbl: [(c1rqW,
                       label: block_c1rqW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rqW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rr5; else goto c1rr4;
       c1rr5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1rr4: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.260426491 UTC

[section ""data" . GHC.Real.$w$cshowsPrec_closure" {
     GHC.Real.$w$cshowsPrec_closure:
         const GHC.Real.$w$cshowsPrec_info;
 },
 GHC.Real.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rrq: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Real.$w$cshowsPrec_entry(R5,
                                             R4,
                                             R3,
                                             R2,
                                             R1) args: 8, res: 0, upd: 8;
     }
 },
 f_s1jz6_entry() //  [R1]
         { info_tbl: [(c1rry,
                       label: f_s1jz6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rry: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1rrz; else goto c1rrA;
       c1rrz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rrA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 g1_s1jz7_entry() //  [R1]
         { info_tbl: [(c1rrF,
                       label: g1_s1jz7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rrF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1rrG; else goto c1rrH;
       c1rrG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rrH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jzb_entry() //  [R1]
         { info_tbl: [(c1rrV,
                       label: sat_s1jzb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rrV: // global
           _s1jzb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1rrW; else goto c1rrX;
       c1rrX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1rrZ; else goto c1rrY;
       c1rrZ: // global
           HpAlloc = 32;
           goto c1rrW;
       c1rrW: // global
           R1 = _s1jzb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rrY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzb::P64;
           _s1jz7::P64 = P64[_s1jzb::P64 + 16];
           _s1jz9::P64 = P64[_s1jzb::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s1jz7::P64;
           P64[Hp] = _s1jz9::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzc_entry() //  [R1, R2]
         { info_tbl: [(c1rs0,
                       label: sat_s1jzc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rs0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1rs4; else goto c1rs3;
       c1rs4: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1rs3: // global
           _s1jz6::P64 = P64[R1 + 7];
           _s1jz7::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s1jzb_info;
           P64[Hp - 8] = _s1jz7::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _s1jz6::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jzf_entry() //  [R1]
         { info_tbl: [(c1rso,
                       label: sat_s1jzf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rso: // global
           _s1jzf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1rsp; else goto c1rsq;
       c1rsq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rss; else goto c1rsr;
       c1rss: // global
           HpAlloc = 24;
           goto c1rsp;
       c1rsp: // global
           R1 = _s1jzf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rsr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzf::P64;
           _s1jz7::P64 = P64[_s1jzf::P64 + 16];
           _s1jzd::P64 = P64[_s1jzf::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s1jzd::P64;
           R2 = Hp - 14;
           R1 = _s1jz7::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzg_entry() //  [R1]
         { info_tbl: [(c1rst,
                       label: sat_s1jzg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rst: // global
           _s1jzg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1rsu; else goto c1rsv;
       c1rsv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1rsx; else goto c1rsw;
       c1rsx: // global
           HpAlloc = 32;
           goto c1rsu;
       c1rsu: // global
           R1 = _s1jzg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rsw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzg::P64;
           _s1jz7::P64 = P64[_s1jzg::P64 + 16];
           _s1jzd::P64 = P64[_s1jzg::P64 + 24];
           I64[Hp - 24] = sat_s1jzf_info;
           P64[Hp - 8] = _s1jz7::P64;
           P64[Hp] = _s1jzd::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzh_entry() //  [R1]
         { info_tbl: [(c1rsy,
                       label: sat_s1jzh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rsy: // global
           _s1jzh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1rsz; else goto c1rsA;
       c1rsA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1rsC; else goto c1rsB;
       c1rsC: // global
           HpAlloc = 32;
           goto c1rsz;
       c1rsz: // global
           R1 = _s1jzh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rsB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzh::P64;
           _s1jz6::P64 = P64[_s1jzh::P64 + 16];
           _s1jz7::P64 = P64[_s1jzh::P64 + 24];
           _s1jzd::P64 = P64[_s1jzh::P64 + 32];
           I64[Hp - 24] = sat_s1jzg_info;
           P64[Hp - 8] = _s1jz7::P64;
           P64[Hp] = _s1jzd::P64;
           R2 = Hp - 24;
           R1 = _s1jz6::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzi_entry() //  [R1, R2]
         { info_tbl: [(c1rsE,
                       label: sat_s1jzi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rsE: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1rsI; else goto c1rsH;
       c1rsI: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1rsH: // global
           _s1jz6::P64 = P64[R1 + 7];
           _s1jz7::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s1jzh_info;
           P64[Hp - 40] = _s1jz6::P64;
           P64[Hp - 32] = _s1jz7::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$w$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1rsM,
                       label: GHC.Real.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rsM: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1rsQ; else goto c1rsP;
       c1rsQ: // global
           HpAlloc = 88;
           R1 = GHC.Real.$w$cshowsPrec_closure;
           P64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c1rsP: // global
           I64[Hp - 80] = f_s1jz6_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = g1_s1jz7_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R5;
           _c1rru::P64 = Hp - 80;
           _c1rrB::P64 = Hp - 48;
           if (%MO_S_Le_W64(R3, 7)) goto c1rsK; else goto c1rsL;
       c1rsK: // global
           I64[Hp - 16] = sat_s1jzc_info;
           P64[Hp - 8] = _c1rru::P64;
           P64[Hp] = _c1rrB::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1rsL: // global
           I64[Hp - 16] = sat_s1jzi_info;
           P64[Hp - 8] = _c1rru::P64;
           P64[Hp] = _c1rrB::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.28350582 UTC

[section ""data" . GHC.Real.$fShowRatio_$cshowsPrec_closure" {
     GHC.Real.$fShowRatio_$cshowsPrec_closure:
         const GHC.Real.$fShowRatio_$cshowsPrec_info;
 },
 GHC.Real.$fShowRatio_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c1rtE,
                       label: GHC.Real.$fShowRatio_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rtE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rtI; else goto c1rtJ;
       c1rtI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rtJ: // global
           I64[Sp - 24] = block_c1rtB_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1rtR; else goto c1rtC;
       u1rtR: // global
           call _c1rtB(R1) args: 0, res: 0, upd: 0;
       c1rtC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rtB() //  [R1]
         { info_tbl: [(c1rtB,
                       label: block_c1rtB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rtB: // global
           I64[Sp] = block_c1rtH_info;
           _s1jzn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s1jzn::I64;
           if (R1 & 7 != 0) goto u1rtQ; else goto c1rtL;
       u1rtQ: // global
           call _c1rtH(R1) args: 0, res: 0, upd: 0;
       c1rtL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rtH() //  [R1]
         { info_tbl: [(c1rtH,
                       label: block_c1rtH_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rtH: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cshowsPrec_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.291082635 UTC

[section ""data" . GHC.Real.$fShowRatio1_closure" {
     GHC.Real.$fShowRatio1_closure:
         const GHC.Real.$fShowRatio1_info;
         const 0;
 },
 GHC.Real.$fShowRatio1_entry() //  [R2, R3]
         { info_tbl: [(c1ruc,
                       label: GHC.Real.$fShowRatio1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ruc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rui; else goto c1ruj;
       c1rui: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ruj: // global
           I64[Sp - 16] = block_c1ru9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1ruo; else goto c1rua;
       u1ruo: // global
           call _c1ru9(R1) args: 0, res: 0, upd: 0;
       c1rua: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ru9() //  [R1]
         { info_tbl: [(c1ru9,
                       label: block_c1ru9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ru9: // global
           _s1jzs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1ruf_info;
           R5 = _s1jzs::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cshowsPrec_entry(R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ruf() //  [R1, R2]
         { info_tbl: [(c1ruf,
                       label: block_c1ruf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ruf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1run; else goto c1rum;
       c1run: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1rum: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.299086613 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$cshowList_closure" {
     GHC.Real.$fShowRatio_$s$cshowList_closure:
         const GHC.Real.$fShowRatio_$s$cshowList_info;
         const 0;
 },
 GHC.Real.$fShowRatio_$s$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c1ruG,
                       label: GHC.Real.$fShowRatio_$s$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ruG: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Real.$fShowRatio1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.303491599 UTC

[section ""data" . GHC.Real.$fShowRatio_$cshowList_closure" {
     GHC.Real.$fShowRatio_$cshowList_closure:
         const GHC.Real.$fShowRatio_$cshowList_info;
 },
 sat_s1jzI_entry() //  [R1, R2]
         { info_tbl: [(c1ruZ,
                       label: sat_s1jzI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ruZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rv0; else goto c1rv1;
       c1rv0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1rv1: // global
           I64[Sp - 16] = block_c1ruW_info;
           _s1jzB::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s1jzB::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1rv5; else goto c1ruX;
       u1rv5: // global
           call _c1ruW(R1) args: 0, res: 0, upd: 0;
       c1ruX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ruW() //  [R1]
         { info_tbl: [(c1ruW,
                       label: block_c1ruW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ruW: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = 0;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cshowsPrec_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fShowRatio_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c1rv6,
                       label: GHC.Real.$fShowRatio_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rv6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1rva; else goto c1rv9;
       c1rva: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rv9: // global
           I64[Hp - 8] = sat_s1jzI_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.311380069 UTC

[section ""data" . GHC.Real.$w$s$cshow_closure" {
     GHC.Real.$w$s$cshow_closure:
         const GHC.Real.$w$s$cshow_info;
         const 0;
 },
 sat_s1jzO_entry() //  [R1]
         { info_tbl: [(c1rvC,
                       label: sat_s1jzO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rvC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rvD; else goto c1rvE;
       c1rvD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rvE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1rvz_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[R1 + 16];
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1rvz() //  [R1, R2]
         { info_tbl: [(c1rvz,
                       label: block_c1rvz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rvz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rvH; else goto c1rvG;
       c1rvH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1rvG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jzP_entry() //  [R1]
         { info_tbl: [(c1rvI,
                       label: sat_s1jzP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rvI: // global
           _s1jzP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1rvJ; else goto c1rvK;
       c1rvK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rvM; else goto c1rvL;
       c1rvM: // global
           HpAlloc = 24;
           goto c1rvJ;
       c1rvJ: // global
           R1 = _s1jzP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rvL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jzP::P64;
           _s1jzK::P64 = P64[_s1jzP::P64 + 16];
           I64[Hp - 16] = sat_s1jzO_info;
           P64[Hp] = _s1jzK::P64;
           R3 = Hp - 16;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$s$cshow_entry() //  [R2, R3]
         { info_tbl: [(c1rvN,
                       label: GHC.Real.$w$s$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rvN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rvR; else goto c1rvQ;
       c1rvR: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rvQ: // global
           I64[Hp - 16] = sat_s1jzP_info;
           P64[Hp] = R3;
           R4 = Hp - 16;
           R3 = R2;
           R2 = 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.321143345 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$cshow_closure" {
     GHC.Real.$fShowRatio_$s$cshow_closure:
         const GHC.Real.$fShowRatio_$s$cshow_info;
         const 0;
 },
 GHC.Real.$fShowRatio_$s$cshow_entry() //  [R2]
         { info_tbl: [(c1rwf,
                       label: GHC.Real.$fShowRatio_$s$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rwf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1rwl; else goto c1rwm;
       c1rwl: // global
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$s$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1rwm: // global
           I64[Sp - 8] = block_c1rwc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1rwr; else goto c1rwd;
       u1rwr: // global
           call _c1rwc(R1) args: 0, res: 0, upd: 0;
       c1rwd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rwc() //  [R1]
         { info_tbl: [(c1rwc,
                       label: block_c1rwc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rwc: // global
           I64[Sp] = block_c1rwi_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$cshow_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rwi() //  [R1, R2]
         { info_tbl: [(c1rwi,
                       label: block_c1rwi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rwi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rwq; else goto c1rwp;
       c1rwq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1rwp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.329487043 UTC

[section ""data" . GHC.Real.$w$cshow_closure" {
     GHC.Real.$w$cshow_closure:
         const GHC.Real.$w$cshow_info;
 },
 sat_s1jA0_entry() //  [R1]
         { info_tbl: [(c1rwR,
                       label: sat_s1jA0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rwR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1rwS; else goto c1rwT;
       c1rwS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rwT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s1jA1_entry() //  [R1]
         { info_tbl: [(c1rwU,
                       label: sat_s1jA1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rwU: // global
           _s1jA1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1rwV; else goto c1rwW;
       c1rwW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1rwY; else goto c1rwX;
       c1rwY: // global
           HpAlloc = 32;
           goto c1rwV;
       c1rwV: // global
           R1 = _s1jA1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rwX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jA1::P64;
           _s1jzX::P64 = P64[_s1jA1::P64 + 16];
           _s1jzZ::P64 = P64[_s1jA1::P64 + 24];
           I64[Hp - 24] = sat_s1jA0_info;
           P64[Hp - 8] = _s1jzX::P64;
           P64[Hp] = _s1jzZ::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$cshow_entry() //  [R2, R3, R4]
         { info_tbl: [(c1rwZ,
                       label: GHC.Real.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rwZ: // global
           _s1jzZ::P64 = R4;
           _s1jzY::P64 = R3;
           _s1jzX::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto c1rx0; else goto c1rx1;
       c1rx1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1rx3; else goto c1rx2;
       c1rx3: // global
           HpAlloc = 32;
           goto c1rx0;
       c1rx0: // global
           R4 = _s1jzZ::P64;
           R3 = _s1jzY::P64;
           R2 = _s1jzX::P64;
           R1 = GHC.Real.$w$cshow_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rx2: // global
           I64[Hp - 24] = sat_s1jA1_info;
           P64[Hp - 8] = _s1jzX::P64;
           P64[Hp] = _s1jzZ::P64;
           R2 = _s1jzX::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 16] = _s1jzY::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.337940217 UTC

[section ""data" . GHC.Real.$fShowRatio_$cshow_closure" {
     GHC.Real.$fShowRatio_$cshow_closure:
         const GHC.Real.$fShowRatio_$cshow_info;
 },
 GHC.Real.$fShowRatio_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c1rxq,
                       label: GHC.Real.$fShowRatio_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rxq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rxr; else goto c1rxs;
       c1rxr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rxs: // global
           I64[Sp - 16] = block_c1rxn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1rxw; else goto c1rxo;
       u1rxw: // global
           call _c1rxn(R1) args: 0, res: 0, upd: 0;
       c1rxo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rxn() //  [R1]
         { info_tbl: [(c1rxn,
                       label: block_c1rxn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rxn: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cshow_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.343148371 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$fShowRatio_closure" {
     GHC.Real.$fShowRatio_$s$fShowRatio_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Real.$fShowRatio_$s$cshowsPrec_closure+3;
         const GHC.Real.$fShowRatio_$s$cshow_closure+1;
         const GHC.Real.$fShowRatio_$s$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.345992273 UTC

[section ""data" . GHC.Real.$fShowRatio_closure" {
     GHC.Real.$fShowRatio_closure:
         const GHC.Real.$fShowRatio_info;
 },
 sat_s1jAa_entry() //  [R1, R2, R3]
         { info_tbl: [(c1rxQ,
                       label: sat_s1jAa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rxQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fShowRatio_$cshowList_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jA9_entry() //  [R1, R2]
         { info_tbl: [(c1rxY,
                       label: sat_s1jA9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rxY: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fShowRatio_$cshow_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jA8_entry() //  [R1, R2, R3]
         { info_tbl: [(c1ry6,
                       label: sat_s1jA8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ry6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fShowRatio_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fShowRatio_entry() //  [R2]
         { info_tbl: [(c1rya,
                       label: GHC.Real.$fShowRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rya: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1rye; else goto c1ryd;
       c1rye: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1ryd: // global
           I64[Hp - 72] = sat_s1jAa_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1jA9_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s1jA8_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.355290272 UTC

[section ""data" . GHC.Real.$w$slcm_closure" {
     GHC.Real.$w$slcm_closure:
         const GHC.Real.$w$slcm_info;
         const 0;
 },
 section ""relreadonly" . u1rzb_srtd" {
     u1rzb_srtd:
         const S1jKw_srt+856;
         const 64;
         const 13835093239654252545;
 },
 GHC.Real.$w$slcm_entry() //  [R2, R3]
         { info_tbl: [(c1ryE,
                       label: GHC.Real.$w$slcm_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ryE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1ryF; else goto c1ryG;
       c1ryF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$slcm_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ryG: // global
           if (R3 == 0) goto c1ryD; else goto c1ryC;
       c1ryD: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1ryC: // global
           I64[Sp - 16] = block_c1ryI_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1rza; else goto c1ryJ;
       u1rza: // global
           call _c1ryI(R1) args: 0, res: 0, upd: 0;
       c1ryJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rzc_srtd" {
     u1rzc_srtd:
         const S1jKw_srt+856;
         const 63;
         const 4611721202799476737;
 },
 _c1ryI() //  [R1]
         { info_tbl: [(c1ryI,
                       label: block_c1ryI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ryI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1ryP; else goto c1ryO;
       c1ryP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ryO: // global
           _s1jAg::I64 = I64[R1 + 7];
           if (_s1jAg::I64 == 0) goto c1rz9; else goto c1ryV;
       c1rz9: // global
           Hp = Hp - 16;
           R1 = 0;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1ryV: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp - 8] = block_c1ryT_info;
           R4 = Hp - 7;
           R3 = R1;
           R2 = GHC.Real.$fIntegralWord_closure+1;
           I64[Sp] = _s1jAg::I64;
           Sp = Sp - 8;
           call GHC.Real.gcd_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ryT() //  [R1]
         { info_tbl: [(c1ryT,
                       label: block_c1ryT_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ryT: // global
           _s1jAk::I64 = I64[R1 + 7];
           if (_s1jAk::I64 != 0) goto c1rz7; else goto c1rz8;
       c1rz7: // global
           R1 = I64[Sp + 8] / _s1jAk::I64 * I64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1rz8: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.365878933 UTC

[section ""data" . GHC.Real.lcm_$slcm_closure" {
     GHC.Real.lcm_$slcm_closure:
         const GHC.Real.lcm_$slcm_info;
         const 0;
 },
 GHC.Real.lcm_$slcm_entry() //  [R2, R3]
         { info_tbl: [(c1rzD,
                       label: GHC.Real.lcm_$slcm_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rzD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rzL; else goto c1rzM;
       c1rzL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.lcm_$slcm_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rzM: // global
           I64[Sp - 16] = block_c1rzA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1rzR; else goto c1rzB;
       u1rzR: // global
           call _c1rzA(R1) args: 0, res: 0, upd: 0;
       c1rzB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rzA() //  [R1]
         { info_tbl: [(c1rzA,
                       label: block_c1rzA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rzA: // global
           _s1jAn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1rzG_info;
           R3 = I64[R1 + 7];
           R2 = _s1jAn::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$slcm_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rzG() //  [R1]
         { info_tbl: [(c1rzG,
                       label: block_c1rzG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rzG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1rzQ; else goto c1rzP;
       c1rzQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1rzP: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.375344732 UTC

[section ""data" . GHC.Real.$w$slcm1_closure" {
     GHC.Real.$w$slcm1_closure:
         const GHC.Real.$w$slcm1_info;
         const 0;
 },
 sat_s1jAC_entry() //  [R1]
         { info_tbl: [(c1rAw,
                       label: sat_s1jAC_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rAw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1rAA; else goto c1rAz;
       c1rAA: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rAz: // global
           _s1jAx::I64 = I64[R1 + 24];
           if (%MO_S_Lt_W64(_s1jAx::I64, 0)) goto c1rAu; else goto c1rAv;
       c1rAu: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_s1jAx::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1rAv: // global
           _s1jAv::P64 = P64[R1 + 16];
           Hp = Hp - 16;
           R1 = _s1jAv::P64 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1rBS_srtd" {
     u1rBS_srtd:
         const S1jKw_srt+344;
         const 130;
         const 17;
         const 35184372088832;
         const 2;
 },
 GHC.Real.$w$slcm1_entry() //  [R2, R3]
         { info_tbl: [(c1rAJ,
                       label: GHC.Real.$w$slcm1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rAJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1rAK; else goto c1rAL;
       c1rAK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$slcm1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rAL: // global
           if (R3 == 0) goto u1rBR; else goto c1rAH;
       u1rBR: // global
           call _c1rAI() args: 0, res: 0, upd: 0;
       c1rAH: // global
           I64[Sp - 16] = block_c1rAb_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1rBQ; else goto c1rAc;
       u1rBQ: // global
           call _c1rAb(R1) args: 0, res: 0, upd: 0;
       c1rAc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rBT_srtd" {
     u1rBT_srtd:
         const S1jKw_srt+344;
         const 110;
         const 17;
         const 35184372088832;
 },
 _c1rAb() //  [R1]
         { info_tbl: [(c1rAb,
                       label: block_c1rAb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rAb: // global
           _s1jAx::I64 = I64[R1 + 7];
           if (_s1jAx::I64 == 0) goto u1rBI; else goto c1rBD;
       u1rBI: // global
           Sp = Sp + 16;
           call _c1rAI() args: 0, res: 0, upd: 0;
       c1rBD: // global
           _s1jAu::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s1jAu::I64, 0)) goto c1rBA; else goto c1rBB;
       c1rBA: // global
           I64[Sp - 16] = _s1jAx::I64;
           I64[Sp - 8] = -_s1jAu::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           goto u1rBO;
       c1rBB: // global
           P64[Sp] = R1;
           I64[Sp - 16] = _s1jAx::I64;
           I64[Sp - 8] = _s1jAu::I64;
           Sp = Sp - 16;
           goto u1rBO;
       u1rBO: // global
           call _c1rAl() args: 0, res: 0, upd: 0;
     }
 },
 _c1rAI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rAI: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1rAl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rAl: // global
           Hp = Hp + 32;
           _s1jAz::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c1rAQ; else goto c1rAP;
       c1rAQ: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_c1rAk_info;
           R1 = _s1jAz::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1rAP: // global
           I64[Hp - 24] = sat_s1jAC_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp];
           I64[Sp - 8] = block_c1rAN_info;
           R3 = _s1jAz::I64;
           R2 = Hp - 24;
           Sp = Sp - 8;
           call GHC.Real.$wgcd'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rBU_srtd" {
     u1rBU_srtd:
         const S1jKw_srt+344;
         const 110;
         const 17;
         const 35184372088832;
 },
 _c1rAk() //  [R1]
         { info_tbl: [(c1rAk,
                       label: block_c1rAk_info
                       rep:StackRep [True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rAk: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c1rAl() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1rBV_srtd" {
     u1rBV_srtd:
         const S1jKw_srt+344;
         const 110;
         const 1;
         const 35184372088832;
 },
 _c1rAN() //  [R1]
         { info_tbl: [(c1rAN,
                       label: block_c1rAN_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rAN: // global
           _s1jAu::I64 = I64[Sp + 32];
           _s1jAx::I64 = I64[Sp + 8];
           _s1jAF::I64 = I64[R1 + 7];
           if (_s1jAF::I64 != (-1)) goto u1rBH; else goto c1rBv;
       u1rBH: // global
           if (_s1jAF::I64 != 0) goto c1rBb; else goto c1rBw;
       c1rBb: // global
           _s1jAH::I64 = %MO_S_Quot_W64(_s1jAx::I64,
                                        _s1jAF::I64) * _s1jAu::I64;
           if (%MO_S_Lt_W64(_s1jAH::I64, 0)) goto c1rB8; else goto c1rB9;
       c1rB8: // global
           R1 = -_s1jAH::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1rB9: // global
           R1 = _s1jAH::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1rBw: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1rBv: // global
           if (_s1jAx::I64 == (-9223372036854775808)) goto c1rBu; else goto c1rBt;
       c1rBu: // global
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1rBt: // global
           _s1jAK::I64 = %MO_S_Quot_W64(_s1jAx::I64, (-1)) * _s1jAu::I64;
           if (%MO_S_Lt_W64(_s1jAK::I64, 0)) goto c1rBq; else goto c1rBr;
       c1rBq: // global
           R1 = -_s1jAK::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1rBr: // global
           R1 = _s1jAK::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.393788991 UTC

[section ""data" . GHC.Real.lcm_$slcm1_closure" {
     GHC.Real.lcm_$slcm1_closure:
         const GHC.Real.lcm_$slcm1_info;
         const 0;
 },
 GHC.Real.lcm_$slcm1_entry() //  [R2, R3]
         { info_tbl: [(c1rCJ,
                       label: GHC.Real.lcm_$slcm1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rCJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rCR; else goto c1rCS;
       c1rCR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.lcm_$slcm1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rCS: // global
           I64[Sp - 16] = block_c1rCG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1rCX; else goto c1rCH;
       u1rCX: // global
           call _c1rCG(R1) args: 0, res: 0, upd: 0;
       c1rCH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rCG() //  [R1]
         { info_tbl: [(c1rCG,
                       label: block_c1rCG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rCG: // global
           _s1jAR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1rCM_info;
           R3 = I64[R1 + 7];
           R2 = _s1jAR::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$slcm1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rCM() //  [R1]
         { info_tbl: [(c1rCM,
                       label: block_c1rCM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rCM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1rCW; else goto c1rCV;
       c1rCW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1rCV: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.402836689 UTC

[section ""data" . GHC.Real.lcm_closure" {
     GHC.Real.lcm_closure:
         const GHC.Real.lcm_info;
         const 0;
 },
 sat_s1jB3_entry() //  [R1]
         { info_tbl: [(c1rDz,
                       label: sat_s1jB3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rDz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1rDA; else goto c1rDB;
       c1rDA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rDB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jB5_entry() //  [R1]
         { info_tbl: [(c1rDK,
                       label: sat_s1jB5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rDK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1rDL; else goto c1rDM;
       c1rDL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rDM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jB7_entry() //  [R1]
         { info_tbl: [(c1rE3,
                       label: sat_s1jB7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rE3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rE4; else goto c1rE5;
       c1rE4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rE5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.gcd_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jB8_entry() //  [R1]
         { info_tbl: [(c1rE6,
                       label: sat_s1jB8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rE6: // global
           _s1jB8::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1rE7; else goto c1rE8;
       c1rE8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1rEa; else goto c1rE9;
       c1rEa: // global
           HpAlloc = 40;
           goto c1rE7;
       c1rE7: // global
           R1 = _s1jB8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rE9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jB8::P64;
           _s1jAW::P64 = P64[_s1jB8::P64 + 16];
           _s1jAX::P64 = P64[_s1jB8::P64 + 24];
           _s1jAY::P64 = P64[_s1jB8::P64 + 32];
           I64[Hp - 32] = sat_s1jB7_info;
           P64[Hp - 16] = _s1jAW::P64;
           P64[Hp - 8] = _s1jAX::P64;
           P64[Hp] = _s1jAY::P64;
           R2 = _s1jAW::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1jAX::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jB9_entry() //  [R1]
         { info_tbl: [(c1rEb,
                       label: sat_s1jB9_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rEb: // global
           _s1jB9::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1rEc; else goto c1rEd;
       c1rEd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1rEf; else goto c1rEe;
       c1rEf: // global
           HpAlloc = 40;
           goto c1rEc;
       c1rEc: // global
           R1 = _s1jB9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rEe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jB9::P64;
           _s1jAW::P64 = P64[_s1jB9::P64 + 16];
           _s1jAX::P64 = P64[_s1jB9::P64 + 24];
           _s1jAY::P64 = P64[_s1jB9::P64 + 32];
           _s1jB0::P64 = P64[_s1jB9::P64 + 40];
           I64[Hp - 32] = sat_s1jB8_info;
           P64[Hp - 16] = _s1jAW::P64;
           P64[Hp - 8] = _s1jAX::P64;
           P64[Hp] = _s1jAY::P64;
           R2 = _s1jB0::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _s1jAY::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.lcm_entry() //  [R2, R3, R4]
         { info_tbl: [(c1rEg,
                       label: GHC.Real.lcm_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rEg: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1rEh; else goto c1rEi;
       c1rEh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.lcm_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rEi: // global
           I64[Sp - 32] = block_c1rDf_info;
           _s1jAW::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1jAW::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rDf() //  [R1]
         { info_tbl: [(c1rDf,
                       label: block_c1rDf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rDf: // global
           I64[Sp - 8] = block_c1rDj_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rDj() //  [R1]
         { info_tbl: [(c1rDj,
                       label: block_c1rDj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rDj: // global
           I64[Sp] = block_c1rDn_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rDn() //  [R1]
         { info_tbl: [(c1rDn,
                       label: block_c1rDn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rDn: // global
           I64[Sp] = block_c1rDr_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rDr() //  [R1]
         { info_tbl: [(c1rDr,
                       label: block_c1rDr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rDr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rEo; else goto c1rEn;
       c1rEo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rEn: // global
           I64[Hp - 16] = sat_s1jB3_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1rDC_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1rDC() //  [R1]
         { info_tbl: [(c1rDC,
                       label: block_c1rDC_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rDC: // global
           if (R1 & 7 == 1) goto c1rEq; else goto u1rEJ;
       c1rEq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rEt; else goto c1rEs;
       c1rEt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rEs: // global
           I64[Hp - 16] = sat_s1jB5_info;
           P64[Hp] = P64[Sp + 16];
           _s1jB2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1rDN_info;
           R2 = _s1jB2::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       u1rEJ: // global
           Sp = Sp + 16;
           call _c1rEG() args: 0, res: 0, upd: 0;
     }
 },
 _c1rDN() //  [R1]
         { info_tbl: [(c1rDN,
                       label: block_c1rDN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rDN: // global
           if (R1 & 7 == 1) goto c1rEv; else goto u1rEK;
       c1rEv: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1rEy; else goto c1rEx;
       c1rEy: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rEx: // global
           I64[Hp - 40] = sat_s1jB9_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           _s1jB0::P64 = P64[Sp + 8];
           P64[Hp] = _s1jB0::P64;
           R2 = _s1jB0::P64;
           I64[Sp + 24] = stg_ap_p_info;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 8;
       u1rEK: // global
           Sp = Sp + 8;
           call _c1rEG() args: 0, res: 0, upd: 0;
     }
 },
 _c1rEG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rEG: // global
           R2 = P64[Sp];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = GHC.Real.even1_closure;
           Sp = Sp + 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.430549416 UTC

[section ""data" . GHC.Real.$w$ctoEnum_closure" {
     GHC.Real.$w$ctoEnum_closure:
         const GHC.Real.$w$ctoEnum_info;
         const 0;
 },
 sat_s1jBg_entry() //  [R1]
         { info_tbl: [(c1rG5,
                       label: sat_s1jBg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rG5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rG6; else goto c1rG7;
       c1rG6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rG7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1rG2_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1rGb; else goto c1rG3;
       u1rGb: // global
           call _c1rG2(R1) args: 0, res: 0, upd: 0;
       c1rG3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1rG2() //  [R1]
         { info_tbl: [(c1rG2,
                       label: block_c1rG2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rG2: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c1rGc,
                       label: GHC.Real.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rGc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1rGg; else goto c1rGh;
       c1rGg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rGh: // global
           I64[Sp - 16] = block_c1rFQ_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rFQ() //  [R1]
         { info_tbl: [(c1rFQ,
                       label: block_c1rFQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rFQ: // global
           I64[Sp] = block_c1rFU_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rFU() //  [R1]
         { info_tbl: [(c1rFU,
                       label: block_c1rFU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rFU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rGl; else goto c1rGk;
       c1rGl: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rGk: // global
           I64[Hp - 16] = sat_s1jBg_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c1rGd_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1rGd() //  [R1]
         { info_tbl: [(c1rGd,
                       label: block_c1rGd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rGd: // global
           I64[Sp] = block_c1rGf_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Real.$fEnumRatio1_closure;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1rGf() //  [R1]
         { info_tbl: [(c1rGf,
                       label: block_c1rGf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rGf: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.444962228 UTC

[section ""data" . GHC.Real.$fEnumRatio_$ctoEnum_closure" {
     GHC.Real.$fEnumRatio_$ctoEnum_closure:
         const GHC.Real.$fEnumRatio_$ctoEnum_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c1rGY,
                       label: GHC.Real.$fEnumRatio_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rGY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1rGZ; else goto c1rH0;
       c1rGZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rH0: // global
           I64[Sp - 8] = block_c1rGV_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$ctoEnum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rGV() //  [R1, R2]
         { info_tbl: [(c1rGV,
                       label: block_c1rGV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rGV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rH3; else goto c1rH2;
       c1rH3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1rH2: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.450570203 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$fEnumRatio_closure" {
     GHC.Real.$fEnumRatio_$s$fEnumRatio_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Real.$fEnumRatio_$s$csucc_closure+1;
         const GHC.Real.$fEnumRatio_$s$cpred_closure+1;
         const GHC.Real.$fEnumRatio_$ctoRational_closure+1;
         const GHC.Real.$fEnumRatio_$s$cfromEnum_closure+1;
         const GHC.Real.$fEnumRatio_$snumericEnumFrom_closure+1;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure+2;
         const GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure+2;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.453829742 UTC

[section ""data" . GHC.Real.$fEnumRatio_closure" {
     GHC.Real.$fEnumRatio_closure:
         const GHC.Real.$fEnumRatio_info;
         const 0;
 },
 sat_s1jBw_entry() //  [R1]
         { info_tbl: [(c1rHm,
                       label: sat_s1jBw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rHm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rHn; else goto c1rHo;
       c1rHn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rHo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jBv_entry() //  [R1]
         { info_tbl: [(c1rHt,
                       label: sat_s1jBv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rHt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rHu; else goto c1rHv;
       c1rHu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rHv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jBu_entry() //  [R1]
         { info_tbl: [(c1rHA,
                       label: sat_s1jBu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rHA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rHB; else goto c1rHC;
       c1rHB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rHC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jBt_entry() //  [R1]
         { info_tbl: [(c1rHH,
                       label: sat_s1jBt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rHH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rHI; else goto c1rHJ;
       c1rHI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rHJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jBs_entry() //  [R1, R2]
         { info_tbl: [(c1rHP,
                       label: sat_s1jBs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rHP: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$cfromEnum_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jBr_entry() //  [R1, R2]
         { info_tbl: [(c1rHX,
                       label: sat_s1jBr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rHX: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$ctoEnum_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jBq_entry() //  [R1, R2]
         { info_tbl: [(c1rI5,
                       label: sat_s1jBq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rI5: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$cpred_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1jBp_entry() //  [R1, R2]
         { info_tbl: [(c1rId,
                       label: sat_s1jBp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rId: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$csucc_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEnumRatio_entry() //  [R2]
         { info_tbl: [(c1rIh,
                       label: GHC.Real.$fEnumRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rIh: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c1rIl; else goto c1rIk;
       c1rIl: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1rIk: // global
           I64[Hp - 224] = sat_s1jBw_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s1jBv_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s1jBu_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1jBt_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s1jBs_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s1jBr_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s1jBq_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s1jBp_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = Hp - 95;
           P64[Hp - 40] = Hp - 111;
           P64[Hp - 32] = Hp - 127;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.474306357 UTC

[section ""data" . $wg_r1j3P_closure" {
     $wg_r1j3P_closure:
         const $wg_r1j3P_info;
 },
 $wg_r1j3P_entry() //  [R2, R3, R4]
         { info_tbl: [(c1rJa,
                       label: $wg_r1j3P_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rJa: // global
           _s1jBz::I64 = R4;
           _s1jBy::I64 = R3;
           _s1jBx::I64 = R2;
           goto c1rJ2;
       c1rJ2: // global
           if (_s1jBy::I64 - (_s1jBy::I64 + (_s1jBy::I64 >> 63)) & (-2) == 0) goto c1rJ9; else goto c1rJ8;
       c1rJ9: // global
           _s1jBy::I64 = %MO_S_Shr_W64(_s1jBy::I64 + (_s1jBy::I64 >> 63), 1);
           _s1jBx::I64 = _s1jBx::I64 * _s1jBx::I64;
           goto c1rJ2;
       c1rJ8: // global
           if (_s1jBy::I64 == 1) goto c1rJo; else goto c1rJk;
       c1rJo: // global
           R1 = _s1jBx::I64 * _s1jBz::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1rJk: // global
           _s1jBz::I64 = _s1jBx::I64 * _s1jBz::I64;
           _s1jBy::I64 = %MO_S_Shr_W64(_s1jBy::I64 + (_s1jBy::I64 >> 63), 1);
           _s1jBx::I64 = _s1jBx::I64 * _s1jBx::I64;
           goto c1rJ2;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.478944903 UTC

[section ""data" . GHC.Real.$wf1_closure" {
     GHC.Real.$wf1_closure:
         const GHC.Real.$wf1_info;
 },
 GHC.Real.$wf1_entry() //  [R2, R3]
         { info_tbl: [(c1rK8,
                       label: GHC.Real.$wf1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rK8: // global
           _s1jBI::I64 = R3;
           _s1jBH::I64 = R2;
           goto c1rK0;
       c1rK0: // global
           if (_s1jBI::I64 - (_s1jBI::I64 + (_s1jBI::I64 >> 63)) & (-2) == 0) goto c1rK7; else goto c1rK6;
       c1rK7: // global
           _s1jBI::I64 = %MO_S_Shr_W64(_s1jBI::I64 + (_s1jBI::I64 >> 63), 1);
           _s1jBH::I64 = _s1jBH::I64 * _s1jBH::I64;
           goto c1rK0;
       c1rK6: // global
           if (_s1jBI::I64 == 1) goto c1rKj; else goto c1rKi;
       c1rKj: // global
           R1 = _s1jBH::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1rKi: // global
           R4 = _s1jBH::I64;
           R3 = %MO_S_Shr_W64(_s1jBI::I64 + (_s1jBI::I64 >> 63), 1);
           R2 = _s1jBH::I64 * _s1jBH::I64;
           call $wg_r1j3P_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.48342258 UTC

[section ""data" . GHC.Real.^_f2_closure" {
     GHC.Real.^_f2_closure:
         const GHC.Real.^_f2_info;
 },
 GHC.Real.^_f2_entry() //  [R2, R3]
         { info_tbl: [(c1rKW,
                       label: GHC.Real.^_f2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rKW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rL9; else goto c1rLa;
       c1rL9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_f2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rLa: // global
           I64[Sp - 16] = block_c1rKT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1rLh; else goto c1rKU;
       u1rLh: // global
           call _c1rKT(R1) args: 0, res: 0, upd: 0;
       c1rKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rKT() //  [R1]
         { info_tbl: [(c1rKT,
                       label: block_c1rKT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rKT: // global
           I64[Sp] = block_c1rKZ_info;
           _s1jBS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jBS::I64;
           if (R1 & 7 != 0) goto u1rLg; else goto c1rL0;
       u1rLg: // global
           call _c1rKZ(R1) args: 0, res: 0, upd: 0;
       c1rL0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rKZ() //  [R1]
         { info_tbl: [(c1rKZ,
                       label: block_c1rKZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rKZ: // global
           _s1jBS::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1rL4_info;
           R3 = I64[R1 + 7];
           R2 = _s1jBS::I64;
           Sp = Sp + 8;
           call GHC.Real.$wf1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rL4() //  [R1]
         { info_tbl: [(c1rL4,
                       label: block_c1rL4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rL4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1rLf; else goto c1rLe;
       c1rLf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1rLe: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.492766841 UTC

[section ""data" . GHC.Real.^3_closure" {
     GHC.Real.^3_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.494852815 UTC

[section ""data" . GHC.Real.^2_closure" {
     GHC.Real.^2_closure:
         const GHC.Real.^2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.^2_entry() //  [R1]
         { info_tbl: [(c1rLI,
                       label: GHC.Real.^2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rLI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rLJ; else goto c1rLK;
       c1rLJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rLK: // global
           (_c1rLD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1rLD::I64 == 0) goto c1rLF; else goto c1rLE;
       c1rLF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1rLE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1rLD::I64;
           I64[Sp - 24] = block_c1rLG_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1rLG() //  [R1]
         { info_tbl: [(c1rLG,
                       label: block_c1rLG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rLG: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.500620051 UTC

[section ""data" . GHC.Real.^_$s^2_closure" {
     GHC.Real.^_$s^2_closure:
         const GHC.Real.^_$s^2_info;
         const 0;
 },
 GHC.Real.^_$s^2_entry() //  [R2, R3]
         { info_tbl: [(c1rM5,
                       label: GHC.Real.^_$s^2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rM5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rM6; else goto c1rM7;
       c1rM6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_$s^2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rM7: // global
           I64[Sp - 16] = block_c1rM2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1rMB; else goto c1rM3;
       u1rMB: // global
           call _c1rM2(R1) args: 0, res: 0, upd: 0;
       c1rM3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rM2() //  [R1]
         { info_tbl: [(c1rM2,
                       label: block_c1rM2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rM2: // global
           _s1jC0::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1jC0::I64, 0)) goto c1rMy; else goto c1rMz;
       c1rMy: // global
           if (_s1jC0::I64 == 0) goto c1rMw; else goto c1rMr;
       c1rMw: // global
           R1 = GHC.Real.^3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1rMr: // global
           I64[Sp] = block_c1rMg_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1jC0::I64;
           if (R1 & 7 != 0) goto u1rMA; else goto c1rMh;
       u1rMA: // global
           call _c1rMg(R1) args: 0, res: 0, upd: 0;
       c1rMh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1rMz: // global
           R1 = GHC.Real.^2_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1rMg() //  [R1]
         { info_tbl: [(c1rMg,
                       label: block_c1rMg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rMg: // global
           _s1jC2::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1rMl_info;
           R3 = _s1jC2::I64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Real.$wf1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rMl() //  [R1]
         { info_tbl: [(c1rMl,
                       label: block_c1rMl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rMl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1rMv; else goto c1rMu;
       c1rMv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1rMu: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.510661119 UTC

[section ""data" . $wg1_r1j3Q_closure" {
     $wg1_r1j3Q_closure:
         const $wg1_r1j3Q_info;
         const 0;
 },
 $wg1_r1j3Q_entry() //  [R2, R3, R4]
         { info_tbl: [(c1rN4,
                       label: $wg1_r1j3Q_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rN4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1rN5; else goto u1rNH;
       c1rN5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wg1_r1j3Q_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u1rNH: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c1rMW() args: 0, res: 0, upd: 0;
     }
 },
 _c1rMW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rMW: // global
           _s1jC6::P64 = P64[Sp];
           _s1jC7::I64 = I64[Sp + 8];
           if (_s1jC7::I64 - (_s1jC7::I64 + (_s1jC7::I64 >> 63)) & (-2) == 0) goto c1rN3; else goto c1rN2;
       c1rN3: // global
           I64[Sp] = block_c1rNB_info;
           R3 = _s1jC6::P64;
           R2 = _s1jC6::P64;
           I64[Sp + 8] = %MO_S_Shr_W64(_s1jC7::I64 + (_s1jC7::I64 >> 63), 1);
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       c1rN2: // global
           _s1jC8::P64 = P64[Sp + 16];
           if (_s1jC7::I64 == 1) goto c1rNt; else goto c1rNn;
       c1rNt: // global
           R3 = _s1jC8::P64;
           R2 = _s1jC6::P64;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
       c1rNn: // global
           I64[Sp - 8] = block_c1rNe_info;
           R3 = _s1jC8::P64;
           R2 = _s1jC6::P64;
           I64[Sp + 16] = _s1jC7::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rNB() //  [R1]
         { info_tbl: [(c1rNB,
                       label: block_c1rNB_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rNB: // global
           P64[Sp] = R1;
           I64[Sp + 8] = I64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           call _c1rMW() args: 0, res: 0, upd: 0;
     }
 },
 _c1rNe() //  [R1]
         { info_tbl: [(c1rNe,
                       label: block_c1rNe_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rNe: // global
           _s1jC6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1rNl_info;
           R3 = _s1jC6::P64;
           R2 = _s1jC6::P64;
           P64[Sp + 16] = R1;
           _s1jCa::I64 = I64[Sp + 24];
           I64[Sp + 24] = %MO_S_Shr_W64(_s1jCa::I64 + (_s1jCa::I64 >> 63), 1);
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rNl() //  [R1]
         { info_tbl: [(c1rNl,
                       label: block_c1rNl_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rNl: // global
           P64[Sp] = R1;
           _s1jC8::P64 = P64[Sp + 8];
           I64[Sp + 8] = I64[Sp + 16];
           P64[Sp + 16] = _s1jC8::P64;
           call _c1rMW() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.522329626 UTC

[section ""data" . GHC.Real.$wf_closure" {
     GHC.Real.$wf_closure:
         const GHC.Real.$wf_info;
         const 0;
 },
 GHC.Real.$wf_entry() //  [R2, R3]
         { info_tbl: [(c1rOr,
                       label: GHC.Real.$wf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rOr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rOs; else goto u1rOZ;
       c1rOs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wf_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1rOZ: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1rOj() args: 0, res: 0, upd: 0;
     }
 },
 _c1rOj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rOj: // global
           _s1jCg::P64 = P64[Sp];
           _s1jCh::I64 = I64[Sp + 8];
           if (_s1jCh::I64 - (_s1jCh::I64 + (_s1jCh::I64 >> 63)) & (-2) == 0) goto c1rOq; else goto c1rOp;
       c1rOq: // global
           I64[Sp] = block_c1rOT_info;
           R3 = _s1jCg::P64;
           R2 = _s1jCg::P64;
           I64[Sp + 8] = %MO_S_Shr_W64(_s1jCh::I64 + (_s1jCh::I64 >> 63), 1);
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       c1rOp: // global
           if (_s1jCh::I64 == 1) goto c1rOL; else goto c1rOG;
       c1rOL: // global
           R1 = _s1jCg::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1rOG: // global
           I64[Sp - 8] = block_c1rOE_info;
           R3 = _s1jCg::P64;
           R2 = _s1jCg::P64;
           I64[Sp + 8] = %MO_S_Shr_W64(_s1jCh::I64 + (_s1jCh::I64 >> 63), 1);
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rOT() //  [R1]
         { info_tbl: [(c1rOT,
                       label: block_c1rOT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rOT: // global
           P64[Sp] = R1;
           I64[Sp + 8] = I64[Sp + 8];
           call _c1rOj() args: 0, res: 0, upd: 0;
     }
 },
 _c1rOE() //  [R1]
         { info_tbl: [(c1rOE,
                       label: block_c1rOE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rOE: // global
           R4 = P64[Sp + 8];
           R3 = I64[Sp + 16];
           R2 = R1;
           Sp = Sp + 24;
           call $wg1_r1j3Q_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.531074068 UTC

[section ""data" . GHC.Real.^_f1_closure" {
     GHC.Real.^_f1_closure:
         const GHC.Real.^_f1_info;
         const 0;
 },
 GHC.Real.^_f1_entry() //  [R2, R3]
         { info_tbl: [(c1rPC,
                       label: GHC.Real.^_f1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rPC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rPD; else goto c1rPE;
       c1rPD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_f1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rPE: // global
           I64[Sp - 16] = block_c1rPz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1rPI; else goto c1rPA;
       u1rPI: // global
           call _c1rPz(R1) args: 0, res: 0, upd: 0;
       c1rPA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rPz() //  [R1]
         { info_tbl: [(c1rPz,
                       label: block_c1rPz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rPz: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$wf_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.536847576 UTC

[section ""data" . GHC.Real.^_$s^1_closure" {
     GHC.Real.^_$s^1_closure:
         const GHC.Real.^_$s^1_info;
         const 0;
 },
 section ""relreadonly" . u1rQg_srtd" {
     u1rQg_srtd:
         const S1jKw_srt+1280;
         const 33;
         const 5368840193;
 },
 GHC.Real.^_$s^1_entry() //  [R2, R3]
         { info_tbl: [(c1rPZ,
                       label: GHC.Real.^_$s^1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rPZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rQ0; else goto c1rQ1;
       c1rQ0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_$s^1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rQ1: // global
           I64[Sp - 16] = block_c1rPW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1rQf; else goto c1rPX;
       u1rQf: // global
           call _c1rPW(R1) args: 0, res: 0, upd: 0;
       c1rPX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rPW() //  [R1]
         { info_tbl: [(c1rPW,
                       label: block_c1rPW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rPW: // global
           _s1jCv::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1jCv::I64, 0)) goto c1rQd; else goto c1rQe;
       c1rQd: // global
           if (_s1jCv::I64 == 0) goto c1rQb; else goto c1rQa;
       c1rQb: // global
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1rQa: // global
           R3 = _s1jCv::I64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$wf_entry(R3, R2) args: 8, res: 0, upd: 8;
       c1rQe: // global
           R1 = GHC.Real.^1_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.544010577 UTC

[section ""data" . lvl6_r1j3R_closure" {
     lvl6_r1j3R_closure:
         const lvl6_r1j3R_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r1j3R_entry() //  [R1]
         { info_tbl: [(c1rQB,
                       label: lvl6_r1j3R_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rQB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rQC; else goto c1rQD;
       c1rQC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rQD: // global
           (_c1rQw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1rQw::I64 == 0) goto c1rQy; else goto c1rQx;
       c1rQy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1rQx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1rQw::I64;
           I64[Sp - 24] = block_c1rQz_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1rQz() //  [R1]
         { info_tbl: [(c1rQz,
                       label: block_c1rQz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rQz: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.55041424 UTC

[section ""data" . lvl7_r1j3S_closure" {
     lvl7_r1j3S_closure:
         const lvl7_r1j3S_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r1j3S_entry() //  [R1]
         { info_tbl: [(c1rQZ,
                       label: lvl7_r1j3S_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rQZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rR0; else goto c1rR1;
       c1rR0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rR1: // global
           (_c1rQU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1rQU::I64 == 0) goto c1rQW; else goto c1rQV;
       c1rQW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1rQV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1rQU::I64;
           I64[Sp - 24] = block_c1rQX_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1rQX() //  [R1]
         { info_tbl: [(c1rQX,
                       label: block_c1rQX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rQX: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.561119811 UTC

[section ""data" . GHC.Real.^_closure" {
     GHC.Real.^_closure:
         const GHC.Real.^_info;
         const 0;
 },
 $dNum1_s1jCF_entry() //  [R1]
         { info_tbl: [(c1rSI,
                       label: $dNum1_s1jCF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rSI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rSJ; else goto c1rSK;
       c1rSJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rSK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jCH_entry() //  [R1]
         { info_tbl: [(c1rSN,
                       label: sat_s1jCH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rSN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1rSO; else goto c1rSP;
       c1rSO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rSP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jCK_entry() //  [R1]
         { info_tbl: [(c1rSS,
                       label: sat_s1jCK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rSS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1rST; else goto c1rSU;
       c1rST: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rSU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl8_s1jCM_entry() //  [R1]
         { info_tbl: [(c1rSX,
                       label: lvl8_s1jCM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rSX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1rSY; else goto c1rSZ;
       c1rSY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rSZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl9_s1jCR_entry() //  [R1]
         { info_tbl: [(c1rT2,
                       label: lvl9_s1jCR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rT2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1rT3; else goto c1rT4;
       c1rT3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rT4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jD8_entry() //  [R1]
         { info_tbl: [(c1rT7,
                       label: sat_s1jD8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rT7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1rT8; else goto c1rT9;
       c1rT8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rT9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD7_entry() //  [R1]
         { info_tbl: [(c1rTc,
                       label: sat_s1jD7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rTc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1rTd; else goto c1rTe;
       c1rTd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rTe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jCO::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1jCO::P64;
           P64[Sp - 24] = _s1jCO::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD4_entry() //  [R1]
         { info_tbl: [(c1rTh,
                       label: sat_s1jD4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rTh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1rTi; else goto c1rTj;
       c1rTi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rTj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD3_entry() //  [R1]
         { info_tbl: [(c1rTm,
                       label: sat_s1jD3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rTm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1rTn; else goto c1rTo;
       c1rTn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rTo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD2_entry() //  [R1]
         { info_tbl: [(c1rTs,
                       label: sat_s1jD2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rTs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1rTt; else goto c1rTu;
       c1rTt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rTu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jCX::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1jCX::P64;
           P64[Sp - 24] = _s1jCX::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD6_entry() //  [R1]
         { info_tbl: [(c1rTx,
                       label: sat_s1jD6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rTx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1rTy; else goto c1rTz;
       c1rTy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rTz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jD5_entry() //  [R1]
         { info_tbl: [(c1rTD,
                       label: sat_s1jD5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rTD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1rTE; else goto c1rTF;
       c1rTE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rTF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jCX::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1jCX::P64;
           P64[Sp - 24] = _s1jCX::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jDe_entry() //  [R1]
         { info_tbl: [(c1rTI,
                       label: sat_s1jDe_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rTI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1rTJ; else goto c1rTK;
       c1rTJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rTK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1jDd_entry() //  [R1]
         { info_tbl: [(c1rTO,
                       label: sat_s1jDd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rTO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1rTP; else goto c1rTQ;
       c1rTP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rTQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1jDa::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1jDa::P64;
           P64[Sp - 24] = _s1jDa::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1rWV_srtd" {
     u1rWV_srtd:
         const S1jKw_srt+696;
         const 111;
         const 1;
         const 131941462441984;
 },
 GHC.Real.^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1rTR,
                       label: GHC.Real.^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rTR: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c1rTS; else goto c1rTT;
       c1rTS: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rTT: // global
           I64[Sp - 40] = block_c1rRj_info;
           _s1jCA::P64 = R2;
           R2 = R3;
           P64[Sp - 32] = _s1jCA::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rWW_srtd" {
     u1rWW_srtd:
         const S1jKw_srt+696;
         const 111;
         const 1;
         const 96757090353152;
 },
 _c1rRj() //  [R1]
         { info_tbl: [(c1rRj,
                       label: block_c1rRj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rRj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rTW; else goto c1rTV;
       c1rTW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rTV: // global
           I64[Hp - 16] = $dNum1_s1jCF_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1rRp_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rWX_srtd" {
     u1rWX_srtd:
         const S1jKw_srt+696;
         const 111;
         const 1;
         const 96757090353152;
 },
 _c1rRp() //  [R1]
         { info_tbl: [(c1rRp,
                       label: block_c1rRp_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rRp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rTZ; else goto c1rTY;
       c1rTZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rTY: // global
           I64[Hp - 16] = sat_s1jCH_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1rRv_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 40];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rWY_srtd" {
     u1rWY_srtd:
         const S1jKw_srt+696;
         const 111;
         const 1;
         const 96757090353152;
 },
 _c1rRv() //  [R1]
         { info_tbl: [(c1rRv,
                       label: block_c1rRv_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rRv: // global
           if (R1 & 7 == 1) goto c1rU1; else goto c1rUZ;
       c1rU1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rU4; else goto c1rU3;
       c1rU4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rU3: // global
           I64[Hp - 16] = sat_s1jCK_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 8] = block_c1rRB_info;
           R2 = P64[Sp + 8];
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1rUZ: // global
           R1 = lvl7_r1j3S_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1rWZ_srtd" {
     u1rWZ_srtd:
         const S1jKw_srt+696;
         const 109;
         const 1;
         const 17592253153280;
 },
 _c1rRB() //  [R1]
         { info_tbl: [(c1rRB,
                       label: block_c1rRB_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rRB: // global
           _c1rRz::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1rRF_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 56];
           P64[Sp] = _c1rRz::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rX0_srtd" {
     u1rX0_srtd:
         const S1jKw_srt+696;
         const 109;
         const 1;
         const 17592253153280;
 },
 _c1rRF() //  [R1]
         { info_tbl: [(c1rRF,
                       label: block_c1rRF_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rRF: // global
           if (R1 & 7 == 1) goto c1rU7; else goto c1rUV;
       c1rU7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rUa; else goto c1rU9;
       c1rUa: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rU9: // global
           I64[Hp - 16] = lvl8_s1jCM_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp] = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = Hp - 16;
           call _c1rSw() args: 0, res: 0, upd: 0;
       c1rUV: // global
           R2 = P64[Sp + 24];
           I64[Sp + 40] = stg_ap_p_info;
           P64[Sp + 48] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 40;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 _c1rSw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rSw: // global
           I64[Sp - 8] = block_c1rSy_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1rX1_srtd" {
     u1rX1_srtd:
         const S1jKw_srt+696;
         const 91;
         const 1;
         const 67108864;
 },
 _c1rSy() //  [R1]
         { info_tbl: [(c1rSy,
                       label: block_c1rSy_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rSy: // global
           _s1jDa::P64 = P64[Sp + 48];
           _s1jDb::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c1rUN; else goto c1rUO;
       c1rUN: // global
           I64[Sp + 8] = block_c1rRQ_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = _s1jDb::P64;
           P64[Sp + 48] = _s1jDa::P64;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1rUO: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1rUR; else goto c1rUQ;
       c1rUR: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rUQ: // global
           I64[Hp - 64] = sat_s1jDe_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = _s1jDb::P64;
           I64[Hp - 24] = sat_s1jDd_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _s1jDa::P64;
           P64[Sp + 48] = Hp - 24;
           P64[Sp + 8] = Hp - 64;
           Sp = Sp + 8;
           call _c1rSw() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1rX2_srtd" {
     u1rX2_srtd:
         const S1jKw_srt+696;
         const 91;
         const 1;
         const 67108864;
 },
 _c1rRQ() //  [R1]
         { info_tbl: [(c1rRQ,
                       label: block_c1rRQ_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rRQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rUe; else goto c1rUd;
       c1rUe: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rUd: // global
           I64[Hp - 16] = lvl9_s1jCR_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 8] = block_c1rRW_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 8];
           _c1rRU::P64 = Hp - 16;
           P64[Sp - 16] = _c1rRU::P64;
           P64[Sp] = R1;
           P64[Sp + 16] = _c1rRU::P64;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1rRW() //  [R1]
         { info_tbl: [(c1rRW,
                       label: block_c1rRW_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rRW: // global
           _s1jCO::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto c1rUg; else goto c1rUI;
       c1rUg: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1rUj; else goto c1rUi;
       c1rUj: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rUi: // global
           I64[Hp - 64] = sat_s1jD8_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = sat_s1jD7_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _s1jCO::P64;
           P64[Sp] = _s1jCO::P64;
           P64[Sp + 16] = Hp - 64;
           P64[Sp + 48] = Hp - 24;
           call _c1rS9() args: 0, res: 0, upd: 0;
       c1rUI: // global
           R1 = _s1jCO::P64;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1rS9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rS9: // global
           I64[Sp - 8] = block_c1rSb_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 40];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rSb() //  [R1]
         { info_tbl: [(c1rSb,
                       label: block_c1rSb_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rSb: // global
           _s1jCY::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c1rUr; else goto c1rUB;
       c1rUr: // global
           I64[Sp] = block_c1rSf_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1jCY::P64;
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c1rUB: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1rUE; else goto c1rUD;
       c1rUE: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rUD: // global
           I64[Hp - 64] = sat_s1jD6_info;
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = _s1jCY::P64;
           I64[Hp - 24] = sat_s1jD5_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 56];
           P64[Sp + 56] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c1rS9() args: 0, res: 0, upd: 0;
     }
 },
 _c1rSf() //  [R1]
         { info_tbl: [(c1rSf,
                       label: block_c1rSf_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rSf: // global
           _s1jCA::P64 = P64[Sp + 40];
           _s1jCX::P64 = P64[Sp + 56];
           _s1jCZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c1rUt; else goto c1rUA;
       c1rUt: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1rUw; else goto c1rUv;
       c1rUw: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rUv: // global
           I64[Hp - 104] = sat_s1jD4_info;
           P64[Hp - 88] = _s1jCA::P64;
           P64[Hp - 80] = _s1jCX::P64;
           P64[Hp - 72] = _s1jCZ::P64;
           I64[Hp - 64] = sat_s1jD3_info;
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_s1jD2_info;
           P64[Hp - 8] = _s1jCA::P64;
           P64[Hp] = _s1jCX::P64;
           P64[Sp + 56] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = Hp - 104;
           Sp = Sp + 8;
           call _c1rS9() args: 0, res: 0, upd: 0;
       c1rUA: // global
           R2 = _s1jCA::P64;
           I64[Sp + 48] = stg_ap_pp_info;
           P64[Sp + 56] = _s1jCX::P64;
           P64[Sp + 64] = _s1jCZ::P64;
           Sp = Sp + 48;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Real.^%^_closure" {
     GHC.Real.^%^_closure:
         const GHC.Real.^%^_info;
         const 0;
 },
 GHC.Real.^%^_entry() //  [R2, R3, R4]
         { info_tbl: [(c1rVn,
                       label: GHC.Real.^%^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rVn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1rVt; else goto c1rVu;
       c1rVt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^%^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rVu: // global
           I64[Sp - 24] = block_c1rVk_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1rVz; else goto c1rVl;
       u1rVz: // global
           call _c1rVk(R1) args: 0, res: 0, upd: 0;
       c1rVl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1rVk() //  [R1]
         { info_tbl: [(c1rVk,
                       label: block_c1rVk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rVk: // global
           _s1jDh::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1rVq_info;
           R5 = _s1jDh::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w^%^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rVq() //  [R1, R2]
         { info_tbl: [(c1rVq,
                       label: block_c1rVq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rVq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rVy; else goto c1rVx;
       c1rVy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1rVx: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Real.$w^%^_closure" {
     GHC.Real.$w^%^_closure:
         const GHC.Real.$w^%^_info;
         const 0;
 },
 $dNum_s1jDt_entry() //  [R1]
         { info_tbl: [(c1rVM,
                       label: $dNum_s1jDt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rVM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1rVN; else goto c1rVO;
       c1rVN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rVO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jDv_entry() //  [R1]
         { info_tbl: [(c1rVX,
                       label: sat_s1jDv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rVX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1rVY; else goto c1rVZ;
       c1rVY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rVZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jDy_entry() //  [R1]
         { info_tbl: [(c1rW8,
                       label: sat_s1jDy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rW8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1rW9; else goto c1rWa;
       c1rW9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1rWa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w^%^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1rWb,
                       label: GHC.Real.$w^%^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rWb: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c1rWc; else goto c1rWd;
       c1rWc: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w^%^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1rWd: // global
           I64[Sp - 40] = block_c1rVE_info;
           _s1jDo::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s1jDo::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rVE() //  [R1]
         { info_tbl: [(c1rVE,
                       label: block_c1rVE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rVE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rWg; else goto c1rWf;
       c1rWg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rWf: // global
           I64[Hp - 16] = $dNum_s1jDt_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1rVP_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rVP() //  [R1]
         { info_tbl: [(c1rVP,
                       label: block_c1rVP_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rVP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rWj; else goto c1rWi;
       c1rWj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rWi: // global
           I64[Hp - 16] = sat_s1jDv_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1rW0_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 40];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1rW0() //  [R1]
         { info_tbl: [(c1rW0,
                       label: block_c1rW0_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rW0: // global
           if (R1 & 7 == 1) goto c1rWm; else goto c1rWS;
       c1rWm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1rWp; else goto c1rWo;
       c1rWp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1rWo: // global
           I64[Hp - 16] = sat_s1jDy_info;
           P64[Hp] = P64[Sp + 16];
           _s1jDu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1rWk_info;
           R2 = _s1jDu::P64;
           P64[Sp + 16] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1rWS: // global
           R1 = lvl6_r1j3R_closure;
           Sp = Sp + 56;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1rWk() //  [R1]
         { info_tbl: [(c1rWk,
                       label: block_c1rWk_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rWk: // global
           _c1rW4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1rWt_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = _c1rW4::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1rWt() //  [R1]
         { info_tbl: [(c1rWt,
                       label: block_c1rWt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rWt: // global
           if (R1 & 7 == 1) goto c1rWF; else goto c1rWO;
       c1rWF: // global
           I64[Sp] = block_c1rWy_info;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = GHC.Num.$fNumInteger_closure;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
       c1rWO: // global
           R2 = GHC.Real.$fEnumRatio1_closure;
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1rWy() //  [R1]
         { info_tbl: [(c1rWy,
                       label: block_c1rWy_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rWy: // global
           _s1jDq::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1rWC_info;
           R5 = P64[Sp + 32];
           R4 = _s1jDq::P64;
           R3 = P64[Sp + 8];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1rWC() //  [R1]
         { info_tbl: [(c1rWC,
                       label: block_c1rWC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1rWC: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.655135221 UTC

[section ""data" . GHC.Real.$w^^%^^_closure" {
     GHC.Real.$w^^%^^_closure:
         const GHC.Real.$w^^%^^_info;
         const 0;
 },
 $dNum_s1jDI_entry() //  [R1]
         { info_tbl: [(c1s0V,
                       label: $dNum_s1jDI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s0V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1s0W; else goto c1s0X;
       c1s0W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s0X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jDK_entry() //  [R1]
         { info_tbl: [(c1s16,
                       label: sat_s1jDK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s16: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1s17; else goto c1s18;
       c1s17: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s18: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jDN_entry() //  [R1]
         { info_tbl: [(c1s1h,
                       label: sat_s1jDN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s1h: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1s1i; else goto c1s1j;
       c1s1i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s1j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jDT_entry() //  [R1]
         { info_tbl: [(c1s1E,
                       label: sat_s1jDT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s1E: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1s1F; else goto c1s1G;
       c1s1F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s1G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jDS_entry() //  [R1]
         { info_tbl: [(c1s1L,
                       label: sat_s1jDS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s1L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1s1M; else goto c1s1N;
       c1s1M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s1N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jDV_entry() //  [R1]
         { info_tbl: [(c1s1W,
                       label: sat_s1jDV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s1W: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1s1X; else goto c1s1Y;
       c1s1X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s1Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jE2_entry() //  [R1]
         { info_tbl: [(c1s25,
                       label: sat_s1jE2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s25: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1s26; else goto c1s27;
       c1s26: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s27: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jE4_entry() //  [R1]
         { info_tbl: [(c1s2g,
                       label: sat_s1jE4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s2g: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1s2h; else goto c1s2i;
       c1s2h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s2i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1s43_srtd" {
     u1s43_srtd:
         const S1jKw_srt+296;
         const 167;
         const 1;
         const 0;
         const 354871676928;
 },
 GHC.Real.$w^^%^^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1s2j,
                       label: GHC.Real.$w^^%^^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s2j: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c1s2k; else goto c1s2l;
       c1s2k: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w^^%^^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1s2l: // global
           I64[Sp - 40] = block_c1s0N_info;
           _s1jDD::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s1jDD::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1s44_srtd" {
     u1s44_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1s0N() //  [R1]
         { info_tbl: [(c1s0N,
                       label: block_c1s0N_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s0N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1s2o; else goto c1s2n;
       c1s2o: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1s2n: // global
           I64[Hp - 16] = $dNum_s1jDI_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1s0Y_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1s45_srtd" {
     u1s45_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1s0Y() //  [R1]
         { info_tbl: [(c1s0Y,
                       label: block_c1s0Y_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s0Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1s2r; else goto c1s2q;
       c1s2r: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1s2q: // global
           I64[Hp - 16] = sat_s1jDK_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1s19_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 40];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.>_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1s46_srtd" {
     u1s46_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1s19() //  [R1]
         { info_tbl: [(c1s19,
                       label: block_c1s19_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s19: // global
           if (R1 & 7 == 1) goto c1s2t; else goto c1s3R;
       c1s2t: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1s2w; else goto c1s2v;
       c1s2w: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1s2v: // global
           I64[Hp - 16] = sat_s1jDN_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp] = block_c1s1k_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1s3R: // global
           I64[Sp + 16] = block_c1s3L_info;
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = GHC.Num.$fNumInteger_closure;
           Sp = Sp + 16;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1s47_srtd" {
     u1s47_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1s1k() //  [R1]
         { info_tbl: [(c1s1k,
                       label: block_c1s1k_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s1k: // global
           _c1s1d::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1s1o_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 48];
           P64[Sp] = _c1s1d::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1s48_srtd" {
     u1s48_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1s1o() //  [R1]
         { info_tbl: [(c1s1o,
                       label: block_c1s1o_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s1o: // global
           if (R1 & 7 == 1) goto c1s2A; else goto c1s3I;
       c1s2A: // global
           I64[Sp] = block_c1s1s_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       c1s3I: // global
           R2 = GHC.Real.$fEnumRatio1_closure;
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1s49_srtd" {
     u1s49_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993765888;
 },
 _c1s1s() //  [R1]
         { info_tbl: [(c1s1s,
                       label: block_c1s1s_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s1s: // global
           if (R1 == 1) goto c1s3u; else goto c1s2D;
       c1s3u: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1s3x; else goto c1s3w;
       c1s3x: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1s3w: // global
           I64[Hp - 24] = sat_s1jE2_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c1s28_info;
           R5 = Hp - 24;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
       c1s2D: // global
           I64[Sp] = block_c1s1w_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1s28() //  [R1]
         { info_tbl: [(c1s28,
                       label: block_c1s28_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s28: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1s3A; else goto c1s3z;
       c1s3A: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1s3z: // global
           I64[Hp - 24] = sat_s1jE4_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 32] = block_c1s3t_info;
           R5 = Hp - 24;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 40] = R1;
           Sp = Sp + 32;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1s3t() //  [R1]
         { info_tbl: [(c1s3t,
                       label: block_c1s3t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s3t: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1s4a_srtd" {
     u1s4a_srtd:
         const S1jKw_srt+296;
         const 165;
         const 1;
         const 0;
         const 79456894976;
 },
 _c1s1w() //  [R1]
         { info_tbl: [(c1s1w,
                       label: block_c1s1w_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s1w: // global
           if (R1 == 1) goto c1s3s; else goto c1s2G;
       c1s3s: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1s2G: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1s2J; else goto c1s2I;
       c1s2J: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1s2I: // global
           I64[Hp - 48] = sat_s1jDT_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = sat_s1jDS_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_c1s1O_info;
           R5 = Hp - 48;
           R4 = Hp - 16;
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1s1O() //  [R1]
         { info_tbl: [(c1s1O,
                       label: block_c1s1O_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s1O: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1s2M; else goto c1s2L;
       c1s2M: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1s2L: // global
           I64[Hp - 24] = sat_s1jDV_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c1s2E_info;
           R5 = Hp - 24;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1s2E() //  [R1]
         { info_tbl: [(c1s2E,
                       label: block_c1s2E_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s2E: // global
           I64[Sp + 16] = block_c1s2Q_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1s2Q() //  [R1]
         { info_tbl: [(c1s2Q,
                       label: block_c1s2Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s2Q: // global
           _s1jDU::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1s32; else goto c1s3i;
       c1s32: // global
           I64[Sp] = block_c1s2V_info;
           R2 = _s1jDU::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       c1s3i: // global
           I64[Sp] = block_c1s3b_info;
           R1 = _s1jDU::P64;
           if (R1 & 7 != 0) goto u1s40; else goto c1s3c;
       u1s40: // global
           call _c1s3b(R1) args: 0, res: 0, upd: 0;
       c1s3c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1s2V() //  [R1]
         { info_tbl: [(c1s2V,
                       label: block_c1s2V_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s2V: // global
           _s1jDR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1s2Z_info;
           _s1jDX::P64 = R1;
           R1 = _s1jDR::P64;
           P64[Sp + 16] = _s1jDX::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1s41; else goto c1s34;
       u1s41: // global
           call _c1s2Z(R1) args: 0, res: 0, upd: 0;
       c1s34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1s2Z() //  [R1]
         { info_tbl: [(c1s2Z,
                       label: block_c1s2Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s2Z: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1s3b() //  [R1]
         { info_tbl: [(c1s3b,
                       label: block_c1s3b_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s3b: // global
           _s1jDR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1s3g_info;
           _s1jDZ::P64 = R1;
           R1 = _s1jDR::P64;
           P64[Sp + 16] = _s1jDZ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1s42; else goto c1s3k;
       u1s42: // global
           call _c1s3g(R1) args: 0, res: 0, upd: 0;
       c1s3k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1s3g() //  [R1]
         { info_tbl: [(c1s3g,
                       label: block_c1s3g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s3g: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1s3L() //  [R1]
         { info_tbl: [(c1s3L,
                       label: block_c1s3L_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s3L: // global
           _s1jDF::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1s3P_info;
           R5 = P64[Sp + 32];
           R4 = _s1jDF::P64;
           R3 = P64[Sp + 8];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1s3P() //  [R1]
         { info_tbl: [(c1s3P,
                       label: block_c1s3P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s3P: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.712921394 UTC

[section ""data" . GHC.Real.^^%^^_closure" {
     GHC.Real.^^%^^_closure:
         const GHC.Real.^^%^^_info;
         const 0;
 },
 GHC.Real.^^%^^_entry() //  [R2, R3, R4]
         { info_tbl: [(c1s6r,
                       label: GHC.Real.^^%^^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s6r: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1s6x; else goto c1s6y;
       c1s6x: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^^%^^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1s6y: // global
           I64[Sp - 24] = block_c1s6o_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1s6D; else goto c1s6p;
       u1s6D: // global
           call _c1s6o(R1) args: 0, res: 0, upd: 0;
       c1s6p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1s6o() //  [R1]
         { info_tbl: [(c1s6o,
                       label: block_c1s6o_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s6o: // global
           _s1jEa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1s6u_info;
           R5 = _s1jEa::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w^^%^^_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1s6u() //  [R1, R2]
         { info_tbl: [(c1s6u,
                       label: block_c1s6u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s6u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1s6C; else goto c1s6B;
       c1s6C: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1s6B: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.721785329 UTC

[section ""data" . GHC.Real.^^_closure" {
     GHC.Real.^^_closure:
         const GHC.Real.^^_info;
         const 0;
 },
 $dNum_s1jEm_entry() //  [R1]
         { info_tbl: [(c1s73,
                       label: $dNum_s1jEm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s73: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1s74; else goto c1s75;
       c1s74: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s75: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jEo_entry() //  [R1]
         { info_tbl: [(c1s7a,
                       label: sat_s1jEo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s7a: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1s7b; else goto c1s7c;
       c1s7b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s7c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jEr_entry() //  [R1]
         { info_tbl: [(c1s7t,
                       label: sat_s1jEr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s7t: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1s7u; else goto c1s7v;
       c1s7u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s7v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1jEq_entry() //  [R1]
         { info_tbl: [(c1s7A,
                       label: sat_s1jEq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s7A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1s7B; else goto c1s7C;
       c1s7B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s7C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jEs_entry() //  [R1]
         { info_tbl: [(c1s7D,
                       label: sat_s1jEs_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s7D: // global
           _s1jEs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1s7E; else goto c1s7F;
       c1s7F: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1s7H; else goto c1s7G;
       c1s7H: // global
           HpAlloc = 56;
           goto c1s7E;
       c1s7E: // global
           R1 = _s1jEs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s7G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1jEs::P64;
           _s1jEh::P64 = P64[_s1jEs::P64 + 16];
           _s1jEi::P64 = P64[_s1jEs::P64 + 24];
           _s1jEj::P64 = P64[_s1jEs::P64 + 32];
           _s1jEk::P64 = P64[_s1jEs::P64 + 40];
           _s1jEm::P64 = P64[_s1jEs::P64 + 48];
           I64[Hp - 48] = sat_s1jEr_info;
           P64[Hp - 32] = _s1jEk::P64;
           P64[Hp - 24] = _s1jEm::P64;
           I64[Hp - 16] = sat_s1jEq_info;
           P64[Hp] = _s1jEh::P64;
           R5 = Hp - 48;
           R4 = _s1jEj::P64;
           R3 = _s1jEi::P64;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1jEt_entry() //  [R1]
         { info_tbl: [(c1s7O,
                       label: sat_s1jEt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s7O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1s7P; else goto c1s7Q;
       c1s7P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1s7Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.^^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1s7R,
                       label: GHC.Real.^^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s7R: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1s7S; else goto c1s7T;
       c1s7S: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1s7T: // global
           I64[Sp - 40] = block_c1s6V_info;
           _s1jEh::P64 = R2;
           R2 = R3;
           P64[Sp - 32] = _s1jEh::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1s6V() //  [R1]
         { info_tbl: [(c1s6V,
                       label: block_c1s6V_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s6V: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1s7W; else goto c1s7V;
       c1s7W: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1s7V: // global
           I64[Hp - 40] = $dNum_s1jEm_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_s1jEo_info;
           _c1s6Z::P64 = Hp - 40;
           P64[Hp] = _c1s6Z::P64;
           I64[Sp - 16] = block_c1s7d_info;
           R2 = R1;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = _c1s6Z::P64;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1s7d() //  [R1]
         { info_tbl: [(c1s7d,
                       label: block_c1s7d_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s7d: // global
           _c1s76::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1s7h_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 48];
           P64[Sp] = _c1s76::P64;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1s7h() //  [R1]
         { info_tbl: [(c1s7h,
                       label: block_c1s7h_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s7h: // global
           _s1jEh::P64 = P64[Sp + 16];
           _s1jEi::P64 = P64[Sp + 24];
           _s1jEj::P64 = P64[Sp + 32];
           _s1jEk::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c1s7Z; else goto c1s83;
       c1s7Z: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1s82; else goto c1s81;
       c1s82: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1s81: // global
           I64[Hp - 48] = sat_s1jEs_info;
           P64[Hp - 32] = _s1jEh::P64;
           P64[Hp - 24] = _s1jEi::P64;
           P64[Hp - 16] = _s1jEj::P64;
           P64[Hp - 8] = _s1jEk::P64;
           P64[Hp] = P64[Sp + 8];
           R2 = _s1jEh::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 48;
           Sp = Sp + 32;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 8;
       c1s83: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1s86; else goto c1s85;
       c1s86: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1s85: // global
           I64[Hp - 16] = sat_s1jEt_info;
           P64[Hp] = _s1jEh::P64;
           R5 = _s1jEk::P64;
           R4 = _s1jEj::P64;
           R3 = _s1jEi::P64;
           R2 = Hp - 16;
           Sp = Sp + 48;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.745863142 UTC

[section ""data" . GHC.Real.C:Fractional_closure" {
     GHC.Real.C:Fractional_closure:
         const GHC.Real.C:Fractional_info;
 },
 GHC.Real.C:Fractional_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1s8W,
                       label: GHC.Real.C:Fractional_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s8W: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1s90; else goto c1s8Z;
       c1s90: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.C:Fractional_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1s8Z: // global
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.750036384 UTC

[section ""data" . GHC.Real.C:Integral_closure" {
     GHC.Real.C:Integral_closure:
         const GHC.Real.C:Integral_info;
 },
 GHC.Real.C:Integral_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s97: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Real.C:Integral_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 GHC.Real.C:Integral_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1s9c,
                       label: GHC.Real.C:Integral_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s9c: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1s9g; else goto c1s9f;
       c1s9g: // global
           HpAlloc = 80;
           R1 = GHC.Real.C:Integral_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       c1s9f: // global
           I64[Hp - 72] = GHC.Real.C:Integral_con_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = R6;
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 71;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.755370388 UTC

[section ""data" . GHC.Real.C:Real_closure" {
     GHC.Real.C:Real_closure:
         const GHC.Real.C:Real_info;
 },
 GHC.Real.C:Real_entry() //  [R2, R3, R4]
         { info_tbl: [(c1s9x,
                       label: GHC.Real.C:Real_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s9x: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1s9B; else goto c1s9A;
       c1s9B: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.C:Real_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1s9A: // global
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.760135548 UTC

[section ""data" . GHC.Real.C:RealFrac_closure" {
     GHC.Real.C:RealFrac_closure:
         const GHC.Real.C:RealFrac_info;
 },
 GHC.Real.C:RealFrac_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s9I: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Real.C:RealFrac_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Real.C:RealFrac_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1s9N,
                       label: GHC.Real.C:RealFrac_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1s9N: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1s9R; else goto c1s9Q;
       c1s9R: // global
           HpAlloc = 64;
           R1 = GHC.Real.C:RealFrac_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       c1s9Q: // global
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.765577557 UTC

[section ""data" . GHC.Real.:%_closure" {
     GHC.Real.:%_closure:
         const GHC.Real.:%_info;
 },
 GHC.Real.:%_entry() //  [R2, R3]
         { info_tbl: [(c1sa6,
                       label: GHC.Real.:%_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sa6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1saa; else goto c1sa9;
       c1saa: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.:%_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1sa9: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.769158179 UTC

[GHC.Real.C:Fractional_con_entry() //  [R1]
         { info_tbl: [(c1sag,
                       label: GHC.Real.C:Fractional_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,70,114,97,99,116,105,111,110,97,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sag: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.77244449 UTC

[GHC.Real.C:Integral_con_entry() //  [R1]
         { info_tbl: [(c1sam,
                       label: GHC.Real.C:Integral_con_info
                       rep:HeapRep 9 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,73,110,116,101,103,114,97,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sam: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.775557343 UTC

[GHC.Real.C:Real_con_entry() //  [R1]
         { info_tbl: [(c1sas,
                       label: GHC.Real.C:Real_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,82,101,97,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sas: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.779737692 UTC

[GHC.Real.C:RealFrac_con_entry() //  [R1]
         { info_tbl: [(c1say,
                       label: GHC.Real.C:RealFrac_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,82,101,97,108,70,114,97,99]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1say: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.783165589 UTC

[GHC.Real.:%_con_entry() //  [R1]
         { info_tbl: [(c1saE,
                       label: GHC.Real.:%_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,58,37]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1saE: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:06.787122526 UTC

[section ""relreadonly" . S1jKw_srt" {
     S1jKw_srt:
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$fOrdRatio_$s$c<_closure;
         const GHC.Real.$fEnumRatio_$s$c<=_closure;
         const GHC.Real.$w$s$ccompare_closure;
         const GHC.Real.$fEnumRatio_$s$ccompare_closure;
         const GHC.Real.$fEnumRatio_$s$c>=_closure;
         const GHC.Real.$fOrdRatio_$s$c>_closure;
         const GHC.Real.$fOrdRatio_$s$cmin_closure;
         const GHC.Real.$fOrdRatio_$s$cmax_closure;
         const sat_s1j8H_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$fFractionalRatio_$s$csignum_closure;
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure;
         const GHC.Real.$fEnumRatio_$ctoRational_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.$dmfloor_closure;
         const GHC.Real.$dmceiling_closure;
         const GHC.Real.$dmrecip_closure;
         const GHC.Real.$dmdivMod_closure;
         const GHC.Exception.divZeroException_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.$fIntegralInt_$cmod_closure;
         const GHC.Real.$fIntegralInt_$crem_closure;
         const GHC.Real.$fIntegralInteger_$cquot_closure;
         const GHC.Real.$fIntegralInteger_$crem_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Real.$fIntegralInteger_$cdiv_closure;
         const GHC.Integer.Type.modInteger_closure;
         const GHC.Real.$fIntegralInteger_$cmod_closure;
         const GHC.Real.$fIntegralInteger_$cquotRem_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Real.$fIntegralInteger_$cdivMod_closure;
         const GHC.Real.$fIntegralWord_$cquot_closure;
         const GHC.Real.$fIntegralWord_$crem_closure;
         const GHC.Real.$fIntegralWord_$cquotRem_closure;
         const GHC.Real.$fIntegralWord_$cdivMod_closure;
         const GHC.Exception.ratioZeroDenomException_closure;
         const GHC.Real.ratioZeroDenominatorError_closure;
         const GHC.Real.$fFractionalRatio_$s$crecip_closure;
         const GHC.Exception.overflowException_closure;
         const GHC.Real.$fIntegralInt_$cdivMod_closure;
         const lvl_r1j38_closure;
         const GHC.Real.$fIntegralInt_$cquotRem_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Real.$fIntegralInt_$cdiv_closure;
         const GHC.Real.$w$cdiv_closure;
         const GHC.Real.$fIntegralInt_$cquot_closure;
         const GHC.Real.$wgcd'_closure;
         const lvl2_r1j3a_closure;
         const GHC.Real.$fEnumRatio_gcd'_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.gcd_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.reduce_$sreduce_closure;
         const GHC.Real.$fRealWord_$ctoRational_closure;
         const GHC.Real.$fFractionalRatio_$s$c*_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Real.$w$s$c-_closure;
         const GHC.Real.$fEnumRatio_$s$c-_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$fEnumRatio_$s$c+_closure;
         const GHC.Real.$w$s$cfromRational_closure;
         const GHC.Real.$fFractionalRatio_$s$cfromRational_closure;
         const GHC.Real.$w$s$c/_closure;
         const GHC.Real.$fFractionalRatio_$s$c/_closure;
         const GHC.Real.$w$snumericEnumFrom_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFrom_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$wnumericEnumFrom_closure;
         const GHC.Real.numericEnumFrom_closure;
         const sat_s1jhS_closure;
         const GHC.Real.even2_closure;
         const GHC.Real.$fEnumRatio2_closure;
         const GHC.Real.$fEnumRatio_$s$c<=_closure;
         const GHC.Real.$w$snumericEnumFromTo_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure;
         const GHC.Real.numericEnumFromTo_closure;
         const GHC.Real.$w$snumericEnumFromThen_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure;
         const GHC.Real.$fEnumRatio_$s$c>=_closure;
         const GHC.Real.$w$snumericEnumFromThenTo_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure;
         const GHC.Real.numericEnumFromThenTo_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.showSigned_closure;
         const GHC.Real.even_closure;
         const GHC.Real.odd_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const lvl3_r1j3b_closure;
         const GHC.Real.$dmround_closure;
         const GHC.Real.$fRealFracRatio1_closure;
         const GHC.Real.integralEnumFrom_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Real.integralEnumFromThen_closure;
         const GHC.Real.integralEnumFromTo_closure;
         const GHC.Real.integralEnumFromThenTo_closure;
         const GHC.Real.$w$csignum_closure;
         const GHC.Real.$fNumRatio_$csignum_closure;
         const GHC.Real.$w$cfromInteger_closure;
         const GHC.Real.$fNumRatio_$cfromInteger_closure;
         const GHC.Real.$w$crecip_closure;
         const GHC.Real.$fFractionalRatio_$crecip_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.$w$s$cproperFraction_closure;
         const GHC.Real.$fEnumRatio_$s$cproperFraction_closure;
         const GHC.Real.gcd_closure;
         const GHC.Real.$wreduce_closure;
         const GHC.Real.reduce_closure;
         const GHC.Real.%_$s%_closure;
         const GHC.Real.$w$s$cfromRational_closure;
         const GHC.Real.$w%_closure;
         const GHC.Real.%_closure;
         const GHC.Real.$w$c/_closure;
         const GHC.Real.$fFractionalRatio_$c/_closure;
         const GHC.Real.$w$cfromRational_closure;
         const GHC.Real.$fFractionalRatio_$cfromRational_closure;
         const GHC.Real.$w$c+_closure;
         const GHC.Real.$fNumRatio_$c+_closure;
         const GHC.Real.$w$c-_closure;
         const GHC.Real.$fNumRatio_$c-_closure;
         const GHC.Real.$w$c*_closure;
         const GHC.Real.$fNumRatio_$c*_closure;
         const GHC.Real.$fNumRatio_closure;
         const GHC.Real.$fEnumRatio_$s$csucc_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$fEnumRatio_$csucc_closure;
         const GHC.Real.$fEnumRatio_$s$cpred_closure;
         const GHC.Real.$fEnumRatio_$cpred_closure;
         const GHC.Real.$fFractionalRatio_closure;
         const GHC.Real.$wnumericEnumFrom_closure;
         const GHC.Real.$fEnumRatio_$cenumFrom_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThen_closure;
         const GHC.Real.$fEnumRatio_$cenumFromTo_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThenTo_closure;
         const GHC.Real.$fRealRatio_closure;
         const GHC.Real.$w$s$cceiling_closure;
         const GHC.Real.$fRealFracRatio_$s$cceiling_closure;
         const GHC.Real.$w$cceiling_closure;
         const GHC.Real.$fRealFracRatio_$cceiling_closure;
         const GHC.Real.$w$s$cfloor_closure;
         const GHC.Real.$fRealFracRatio_$s$cfloor_closure;
         const GHC.Real.$w$cfloor_closure;
         const GHC.Real.$fRealFracRatio_$cfloor_closure;
         const sat_s1jvS_closure;
         const GHC.Real.$w$s$cround_closure;
         const GHC.Real.$fRealFracRatio2_closure;
         const GHC.Real.$fRealFracRatio_$s$cround_closure;
         const GHC.Real.$w$cround_closure;
         const GHC.Real.$fRealFracRatio_$cround_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.$fRealFracRatio_$s$ctruncate_closure;
         const GHC.Real.$fRealFracRatio_closure;
         const g_r1j3N_closure;
         const GHC.Real.^_f_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Real.^_$s^_closure;
         const GHC.Real.^1_closure;
         const GHC.Real.$w$s$cfromEnum_closure;
         const GHC.Real.$fEnumRatio_$s$cfromEnum_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Real.$w$s$cshowsPrec_closure;
         const GHC.Real.$fShowRatio_$s$cshowsPrec_closure;
         const GHC.Real.$fShowRatio1_closure;
         const GHC.Real.$w$s$cshow_closure;
         const GHC.Real.$fShowRatio_$s$cshow_closure;
         const GHC.Real.$fIntegralWord_closure;
         const GHC.Real.$w$slcm_closure;
         const GHC.Real.lcm_$slcm_closure;
         const GHC.Real.$w$slcm1_closure;
         const GHC.Real.lcm_$slcm1_closure;
         const GHC.Real.gcd_closure;
         const GHC.Real.lcm_closure;
         const GHC.Real.$w$ctoEnum_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$fEnumRatio_$ctoEnum_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThenTo_closure;
         const GHC.Real.$fEnumRatio_$cenumFromTo_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThen_closure;
         const GHC.Real.$fEnumRatio_$cenumFrom_closure;
         const GHC.Real.$fEnumRatio_$cpred_closure;
         const GHC.Real.$fEnumRatio_$csucc_closure;
         const GHC.Real.$fEnumRatio_closure;
         const GHC.Real.^_$s^2_closure;
         const GHC.Real.^2_closure;
         const $wg1_r1j3Q_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$wf_closure;
         const GHC.Real.^_f1_closure;
         const GHC.Real.^_$s^1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.even2_closure;
         const GHC.Real.^_closure;
         const lvl7_r1j3S_closure;
         const GHC.Real.even_closure;
         const GHC.Real.^%^_closure;
         const GHC.Real.$w^%^_closure;
         const GHC.Num.$fNumInteger_closure;
         const lvl6_r1j3R_closure;
         const GHC.Real.$w^^%^^_closure;
         const GHC.Real.^^%^^_closure;
         const GHC.Real.^^_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:15.998421332 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:56:15.999845154 UTC

[section ""data" . GHC.Real.$p1Fractional_closure" {
     GHC.Real.$p1Fractional_closure:
         const GHC.Real.$p1Fractional_info;
 },
 GHC.Real.$p1Fractional_entry() //  [R2]
         { info_tbl: [(c1sLs,
                       label: GHC.Real.$p1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sLs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sLt; else goto c1sLu;
       c1sLt: // global
           R2 = R2;
           R1 = GHC.Real.$p1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sLu: // global
           I64[Sp - 8] = block_c1sLp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sLy; else goto c1sLq;
       u1sLy: // global
           call _c1sLp(R1) args: 0, res: 0, upd: 0;
       c1sLq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sLp() //  [R1]
         { info_tbl: [(c1sLp,
                       label: block_c1sLp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sLp: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.034571173 UTC

[section ""data" . GHC.Real./_closure" {
     GHC.Real./_closure:
         const GHC.Real./_info;
 },
 GHC.Real./_entry() //  [R2]
         { info_tbl: [(c1sLS,
                       label: GHC.Real./_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sLS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sLT; else goto c1sLU;
       c1sLT: // global
           R2 = R2;
           R1 = GHC.Real./_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sLU: // global
           I64[Sp - 8] = block_c1sLP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sLY; else goto c1sLQ;
       u1sLY: // global
           call _c1sLP(R1) args: 0, res: 0, upd: 0;
       c1sLQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sLP() //  [R1]
         { info_tbl: [(c1sLP,
                       label: block_c1sLP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sLP: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.039833035 UTC

[section ""data" . GHC.Real.recip_closure" {
     GHC.Real.recip_closure:
         const GHC.Real.recip_info;
 },
 GHC.Real.recip_entry() //  [R2]
         { info_tbl: [(c1sMg,
                       label: GHC.Real.recip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sMg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sMh; else goto c1sMi;
       c1sMh: // global
           R2 = R2;
           R1 = GHC.Real.recip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sMi: // global
           I64[Sp - 8] = block_c1sMd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sMm; else goto c1sMe;
       u1sMm: // global
           call _c1sMd(R1) args: 0, res: 0, upd: 0;
       c1sMe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sMd() //  [R1]
         { info_tbl: [(c1sMd,
                       label: block_c1sMd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sMd: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.045152724 UTC

[section ""data" . GHC.Real.fromRational_closure" {
     GHC.Real.fromRational_closure:
         const GHC.Real.fromRational_info;
 },
 GHC.Real.fromRational_entry() //  [R2]
         { info_tbl: [(c1sME,
                       label: GHC.Real.fromRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sME: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sMF; else goto c1sMG;
       c1sMF: // global
           R2 = R2;
           R1 = GHC.Real.fromRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sMG: // global
           I64[Sp - 8] = block_c1sMB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sMK; else goto c1sMC;
       u1sMK: // global
           call _c1sMB(R1) args: 0, res: 0, upd: 0;
       c1sMC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sMB() //  [R1]
         { info_tbl: [(c1sMB,
                       label: block_c1sMB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sMB: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.050575522 UTC

[section ""data" . GHC.Real.$p1Integral_closure" {
     GHC.Real.$p1Integral_closure:
         const GHC.Real.$p1Integral_info;
 },
 GHC.Real.$p1Integral_entry() //  [R2]
         { info_tbl: [(c1sN2,
                       label: GHC.Real.$p1Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sN2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sN3; else goto c1sN4;
       c1sN3: // global
           R2 = R2;
           R1 = GHC.Real.$p1Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sN4: // global
           I64[Sp - 8] = block_c1sMZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sN8; else goto c1sN0;
       u1sN8: // global
           call _c1sMZ(R1) args: 0, res: 0, upd: 0;
       c1sN0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sMZ() //  [R1]
         { info_tbl: [(c1sMZ,
                       label: block_c1sMZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sMZ: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.056445499 UTC

[section ""data" . GHC.Real.$p2Integral_closure" {
     GHC.Real.$p2Integral_closure:
         const GHC.Real.$p2Integral_info;
 },
 GHC.Real.$p2Integral_entry() //  [R2]
         { info_tbl: [(c1sNs,
                       label: GHC.Real.$p2Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sNs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sNt; else goto c1sNu;
       c1sNt: // global
           R2 = R2;
           R1 = GHC.Real.$p2Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sNu: // global
           I64[Sp - 8] = block_c1sNp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sNy; else goto c1sNq;
       u1sNy: // global
           call _c1sNp(R1) args: 0, res: 0, upd: 0;
       c1sNq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sNp() //  [R1]
         { info_tbl: [(c1sNp,
                       label: block_c1sNp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sNp: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.062440174 UTC

[section ""data" . GHC.Real.quot_closure" {
     GHC.Real.quot_closure:
         const GHC.Real.quot_info;
 },
 GHC.Real.quot_entry() //  [R2]
         { info_tbl: [(c1sNS,
                       label: GHC.Real.quot_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sNS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sNT; else goto c1sNU;
       c1sNT: // global
           R2 = R2;
           R1 = GHC.Real.quot_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sNU: // global
           I64[Sp - 8] = block_c1sNP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sNY; else goto c1sNQ;
       u1sNY: // global
           call _c1sNP(R1) args: 0, res: 0, upd: 0;
       c1sNQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sNP() //  [R1]
         { info_tbl: [(c1sNP,
                       label: block_c1sNP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sNP: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.067849508 UTC

[section ""data" . GHC.Real.rem_closure" {
     GHC.Real.rem_closure:
         const GHC.Real.rem_info;
 },
 GHC.Real.rem_entry() //  [R2]
         { info_tbl: [(c1sOg,
                       label: GHC.Real.rem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sOg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sOh; else goto c1sOi;
       c1sOh: // global
           R2 = R2;
           R1 = GHC.Real.rem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sOi: // global
           I64[Sp - 8] = block_c1sOd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sOm; else goto c1sOe;
       u1sOm: // global
           call _c1sOd(R1) args: 0, res: 0, upd: 0;
       c1sOe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sOd() //  [R1]
         { info_tbl: [(c1sOd,
                       label: block_c1sOd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sOd: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.07361501 UTC

[section ""data" . GHC.Real.div_closure" {
     GHC.Real.div_closure:
         const GHC.Real.div_info;
 },
 GHC.Real.div_entry() //  [R2]
         { info_tbl: [(c1sOE,
                       label: GHC.Real.div_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sOE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sOF; else goto c1sOG;
       c1sOF: // global
           R2 = R2;
           R1 = GHC.Real.div_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sOG: // global
           I64[Sp - 8] = block_c1sOB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sOK; else goto c1sOC;
       u1sOK: // global
           call _c1sOB(R1) args: 0, res: 0, upd: 0;
       c1sOC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sOB() //  [R1]
         { info_tbl: [(c1sOB,
                       label: block_c1sOB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sOB: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.078992361 UTC

[section ""data" . GHC.Real.mod_closure" {
     GHC.Real.mod_closure:
         const GHC.Real.mod_info;
 },
 GHC.Real.mod_entry() //  [R2]
         { info_tbl: [(c1sP2,
                       label: GHC.Real.mod_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sP2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sP3; else goto c1sP4;
       c1sP3: // global
           R2 = R2;
           R1 = GHC.Real.mod_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sP4: // global
           I64[Sp - 8] = block_c1sOZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sP8; else goto c1sP0;
       u1sP8: // global
           call _c1sOZ(R1) args: 0, res: 0, upd: 0;
       c1sP0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sOZ() //  [R1]
         { info_tbl: [(c1sOZ,
                       label: block_c1sOZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sOZ: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.08440337 UTC

[section ""data" . GHC.Real.quotRem_closure" {
     GHC.Real.quotRem_closure:
         const GHC.Real.quotRem_info;
 },
 GHC.Real.quotRem_entry() //  [R2]
         { info_tbl: [(c1sPq,
                       label: GHC.Real.quotRem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sPq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sPr; else goto c1sPs;
       c1sPr: // global
           R2 = R2;
           R1 = GHC.Real.quotRem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sPs: // global
           I64[Sp - 8] = block_c1sPn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sPw; else goto c1sPo;
       u1sPw: // global
           call _c1sPn(R1) args: 0, res: 0, upd: 0;
       c1sPo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sPn() //  [R1]
         { info_tbl: [(c1sPn,
                       label: block_c1sPn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sPn: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.090581108 UTC

[section ""data" . GHC.Real.divMod_closure" {
     GHC.Real.divMod_closure:
         const GHC.Real.divMod_info;
 },
 GHC.Real.divMod_entry() //  [R2]
         { info_tbl: [(c1sPO,
                       label: GHC.Real.divMod_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sPO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sPP; else goto c1sPQ;
       c1sPP: // global
           R2 = R2;
           R1 = GHC.Real.divMod_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sPQ: // global
           I64[Sp - 8] = block_c1sPL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sPU; else goto c1sPM;
       u1sPU: // global
           call _c1sPL(R1) args: 0, res: 0, upd: 0;
       c1sPM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sPL() //  [R1]
         { info_tbl: [(c1sPL,
                       label: block_c1sPL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sPL: // global
           R1 = P64[R1 + 63];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.09585941 UTC

[section ""data" . GHC.Real.toInteger_closure" {
     GHC.Real.toInteger_closure:
         const GHC.Real.toInteger_info;
 },
 GHC.Real.toInteger_entry() //  [R2]
         { info_tbl: [(c1sQc,
                       label: GHC.Real.toInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sQc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sQd; else goto c1sQe;
       c1sQd: // global
           R2 = R2;
           R1 = GHC.Real.toInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sQe: // global
           I64[Sp - 8] = block_c1sQ9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sQi; else goto c1sQa;
       u1sQi: // global
           call _c1sQ9(R1) args: 0, res: 0, upd: 0;
       c1sQa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sQ9() //  [R1]
         { info_tbl: [(c1sQ9,
                       label: block_c1sQ9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sQ9: // global
           R1 = P64[R1 + 71];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.10167157 UTC

[section ""data" . GHC.Real.$p1Real_closure" {
     GHC.Real.$p1Real_closure:
         const GHC.Real.$p1Real_info;
 },
 GHC.Real.$p1Real_entry() //  [R2]
         { info_tbl: [(c1sQA,
                       label: GHC.Real.$p1Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sQA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sQB; else goto c1sQC;
       c1sQB: // global
           R2 = R2;
           R1 = GHC.Real.$p1Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sQC: // global
           I64[Sp - 8] = block_c1sQx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sQG; else goto c1sQy;
       u1sQG: // global
           call _c1sQx(R1) args: 0, res: 0, upd: 0;
       c1sQy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sQx() //  [R1]
         { info_tbl: [(c1sQx,
                       label: block_c1sQx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sQx: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.107074937 UTC

[section ""data" . GHC.Real.$p2Real_closure" {
     GHC.Real.$p2Real_closure:
         const GHC.Real.$p2Real_info;
 },
 GHC.Real.$p2Real_entry() //  [R2]
         { info_tbl: [(c1sR0,
                       label: GHC.Real.$p2Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sR0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sR1; else goto c1sR2;
       c1sR1: // global
           R2 = R2;
           R1 = GHC.Real.$p2Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sR2: // global
           I64[Sp - 8] = block_c1sQX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sR6; else goto c1sQY;
       u1sR6: // global
           call _c1sQX(R1) args: 0, res: 0, upd: 0;
       c1sQY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sQX() //  [R1]
         { info_tbl: [(c1sQX,
                       label: block_c1sQX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sQX: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.112410876 UTC

[section ""data" . GHC.Real.toRational_closure" {
     GHC.Real.toRational_closure:
         const GHC.Real.toRational_info;
 },
 GHC.Real.toRational_entry() //  [R2]
         { info_tbl: [(c1sRq,
                       label: GHC.Real.toRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sRq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sRr; else goto c1sRs;
       c1sRr: // global
           R2 = R2;
           R1 = GHC.Real.toRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sRs: // global
           I64[Sp - 8] = block_c1sRn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sRw; else goto c1sRo;
       u1sRw: // global
           call _c1sRn(R1) args: 0, res: 0, upd: 0;
       c1sRo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sRn() //  [R1]
         { info_tbl: [(c1sRn,
                       label: block_c1sRn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sRn: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.118392289 UTC

[section ""data" . GHC.Real.$p1RealFrac_closure" {
     GHC.Real.$p1RealFrac_closure:
         const GHC.Real.$p1RealFrac_info;
 },
 GHC.Real.$p1RealFrac_entry() //  [R2]
         { info_tbl: [(c1sRO,
                       label: GHC.Real.$p1RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sRO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sRP; else goto c1sRQ;
       c1sRP: // global
           R2 = R2;
           R1 = GHC.Real.$p1RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sRQ: // global
           I64[Sp - 8] = block_c1sRL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sRU; else goto c1sRM;
       u1sRU: // global
           call _c1sRL(R1) args: 0, res: 0, upd: 0;
       c1sRM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sRL() //  [R1]
         { info_tbl: [(c1sRL,
                       label: block_c1sRL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sRL: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.124360457 UTC

[section ""data" . GHC.Real.$p2RealFrac_closure" {
     GHC.Real.$p2RealFrac_closure:
         const GHC.Real.$p2RealFrac_info;
 },
 GHC.Real.$p2RealFrac_entry() //  [R2]
         { info_tbl: [(c1sSe,
                       label: GHC.Real.$p2RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sSe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sSf; else goto c1sSg;
       c1sSf: // global
           R2 = R2;
           R1 = GHC.Real.$p2RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sSg: // global
           I64[Sp - 8] = block_c1sSb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sSk; else goto c1sSc;
       u1sSk: // global
           call _c1sSb(R1) args: 0, res: 0, upd: 0;
       c1sSc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sSb() //  [R1]
         { info_tbl: [(c1sSb,
                       label: block_c1sSb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sSb: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.129864728 UTC

[section ""data" . GHC.Real.properFraction_closure" {
     GHC.Real.properFraction_closure:
         const GHC.Real.properFraction_info;
 },
 GHC.Real.properFraction_entry() //  [R2]
         { info_tbl: [(c1sSE,
                       label: GHC.Real.properFraction_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sSE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sSF; else goto c1sSG;
       c1sSF: // global
           R2 = R2;
           R1 = GHC.Real.properFraction_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sSG: // global
           I64[Sp - 8] = block_c1sSB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sSK; else goto c1sSC;
       u1sSK: // global
           call _c1sSB(R1) args: 0, res: 0, upd: 0;
       c1sSC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sSB() //  [R1]
         { info_tbl: [(c1sSB,
                       label: block_c1sSB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sSB: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.135519269 UTC

[section ""data" . GHC.Real.truncate_closure" {
     GHC.Real.truncate_closure:
         const GHC.Real.truncate_info;
 },
 GHC.Real.truncate_entry() //  [R2]
         { info_tbl: [(c1sT2,
                       label: GHC.Real.truncate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sT2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sT3; else goto c1sT4;
       c1sT3: // global
           R2 = R2;
           R1 = GHC.Real.truncate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sT4: // global
           I64[Sp - 8] = block_c1sSZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sT8; else goto c1sT0;
       u1sT8: // global
           call _c1sSZ(R1) args: 0, res: 0, upd: 0;
       c1sT0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sSZ() //  [R1]
         { info_tbl: [(c1sSZ,
                       label: block_c1sSZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sSZ: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.14079435 UTC

[section ""data" . GHC.Real.round_closure" {
     GHC.Real.round_closure:
         const GHC.Real.round_info;
 },
 GHC.Real.round_entry() //  [R2]
         { info_tbl: [(c1sTq,
                       label: GHC.Real.round_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sTq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sTr; else goto c1sTs;
       c1sTr: // global
           R2 = R2;
           R1 = GHC.Real.round_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sTs: // global
           I64[Sp - 8] = block_c1sTn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sTw; else goto c1sTo;
       u1sTw: // global
           call _c1sTn(R1) args: 0, res: 0, upd: 0;
       c1sTo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sTn() //  [R1]
         { info_tbl: [(c1sTn,
                       label: block_c1sTn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sTn: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.146449469 UTC

[section ""data" . GHC.Real.ceiling_closure" {
     GHC.Real.ceiling_closure:
         const GHC.Real.ceiling_info;
 },
 GHC.Real.ceiling_entry() //  [R2]
         { info_tbl: [(c1sTO,
                       label: GHC.Real.ceiling_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sTO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sTP; else goto c1sTQ;
       c1sTP: // global
           R2 = R2;
           R1 = GHC.Real.ceiling_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sTQ: // global
           I64[Sp - 8] = block_c1sTL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sTU; else goto c1sTM;
       u1sTU: // global
           call _c1sTL(R1) args: 0, res: 0, upd: 0;
       c1sTM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sTL() //  [R1]
         { info_tbl: [(c1sTL,
                       label: block_c1sTL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sTL: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.151984147 UTC

[section ""data" . GHC.Real.floor_closure" {
     GHC.Real.floor_closure:
         const GHC.Real.floor_info;
 },
 GHC.Real.floor_entry() //  [R2]
         { info_tbl: [(c1sUc,
                       label: GHC.Real.floor_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sUc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1sUd; else goto c1sUe;
       c1sUd: // global
           R2 = R2;
           R1 = GHC.Real.floor_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1sUe: // global
           I64[Sp - 8] = block_c1sU9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sUi; else goto c1sUa;
       u1sUi: // global
           call _c1sU9(R1) args: 0, res: 0, upd: 0;
       c1sUa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sU9() //  [R1]
         { info_tbl: [(c1sU9,
                       label: block_c1sU9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sU9: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.158330344 UTC

[section ""data" . GHC.Real.$W:%_closure" {
     GHC.Real.$W:%_closure:
         const GHC.Real.$W:%_info;
 },
 GHC.Real.$W:%_entry() //  [R2, R3]
         { info_tbl: [(c1sUC,
                       label: GHC.Real.$W:%_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sUC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1sUD; else goto c1sUE;
       c1sUD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$W:%_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1sUE: // global
           I64[Sp - 16] = block_c1sUx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sUx() //  [R1]
         { info_tbl: [(c1sUx,
                       label: block_c1sUx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sUx: // global
           I64[Sp] = block_c1sUz_info;
           _s1se2::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1se2::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sUz() //  [R1]
         { info_tbl: [(c1sUz,
                       label: block_c1sUz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sUz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1sUI; else goto c1sUH;
       c1sUI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1sUH: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.16585361 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$c<_closure" {
     GHC.Real.$fOrdRatio_$s$c<_closure:
         const GHC.Real.$fOrdRatio_$s$c<_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$c<_entry() //  [R2, R3]
         { info_tbl: [(c1sV6,
                       label: GHC.Real.$fOrdRatio_$s$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sV6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1sVn; else goto c1sVo;
       c1sVn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1sVo: // global
           I64[Sp - 16] = block_c1sV3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1sVy; else goto c1sV4;
       u1sVy: // global
           call _c1sV3(R1) args: 0, res: 0, upd: 0;
       c1sV4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sV3() //  [R1]
         { info_tbl: [(c1sV3,
                       label: block_c1sV3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sV3: // global
           I64[Sp - 8] = block_c1sV9_info;
           _s1se7::P64 = P64[R1 + 7];
           _s1se8::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1se8::P64;
           P64[Sp + 8] = _s1se7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sVx; else goto c1sVa;
       u1sVx: // global
           call _c1sV9(R1) args: 0, res: 0, upd: 0;
       c1sVa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sV9() //  [R1]
         { info_tbl: [(c1sV9,
                       label: block_c1sV9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sV9: // global
           I64[Sp] = block_c1sVe_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp + 8] = P64[R1 + 15];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1sVe() //  [R1]
         { info_tbl: [(c1sVe,
                       label: block_c1sVe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sVe: // global
           _s1seb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1sVi_info;
           R3 = _s1seb::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1sVi() //  [R1]
         { info_tbl: [(c1sVi,
                       label: block_c1sVi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sVi: // global
           _s1sed::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1sVm_info;
           R3 = _s1sed::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1sVm() //  [R1]
         { info_tbl: [(c1sVm,
                       label: block_c1sVm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sVm: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.17871863 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c<=_closure" {
     GHC.Real.$fEnumRatio_$s$c<=_closure:
         const GHC.Real.$fEnumRatio_$s$c<=_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c<=_entry() //  [R2, R3]
         { info_tbl: [(c1sWc,
                       label: GHC.Real.$fEnumRatio_$s$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sWc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1sWt; else goto c1sWu;
       c1sWt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1sWu: // global
           I64[Sp - 16] = block_c1sW9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1sWE; else goto c1sWa;
       u1sWE: // global
           call _c1sW9(R1) args: 0, res: 0, upd: 0;
       c1sWa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sW9() //  [R1]
         { info_tbl: [(c1sW9,
                       label: block_c1sW9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sW9: // global
           I64[Sp - 8] = block_c1sWf_info;
           _s1sei::P64 = P64[R1 + 7];
           _s1sej::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1sej::P64;
           P64[Sp + 8] = _s1sei::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sWD; else goto c1sWg;
       u1sWD: // global
           call _c1sWf(R1) args: 0, res: 0, upd: 0;
       c1sWg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sWf() //  [R1]
         { info_tbl: [(c1sWf,
                       label: block_c1sWf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sWf: // global
           I64[Sp] = block_c1sWk_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp + 8] = P64[R1 + 15];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1sWk() //  [R1]
         { info_tbl: [(c1sWk,
                       label: block_c1sWk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sWk: // global
           _s1sem::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1sWo_info;
           R3 = _s1sem::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1sWo() //  [R1]
         { info_tbl: [(c1sWo,
                       label: block_c1sWo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sWo: // global
           _s1seo::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1sWs_info;
           R3 = _s1seo::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1sWs() //  [R1]
         { info_tbl: [(c1sWs,
                       label: block_c1sWs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sWs: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.192152825 UTC

[section ""data" . GHC.Real.$w$s$ccompare_closure" {
     GHC.Real.$w$s$ccompare_closure:
         const GHC.Real.$w$s$ccompare_info;
         const 0;
 },
 GHC.Real.$w$s$ccompare_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1sXg,
                       label: GHC.Real.$w$s$ccompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sXg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1sXh; else goto c1sXi;
       c1sXh: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$ccompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1sXi: // global
           I64[Sp - 40] = block_c1sXe_info;
           _s1ser::P64 = R3;
           R3 = R4;
           _s1seq::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s1seq::P64;
           P64[Sp - 24] = _s1ser::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1sXe() //  [R1]
         { info_tbl: [(c1sXe,
                       label: block_c1sXe_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sXe: // global
           if (R1 == 1) goto c1sXT; else goto u1sY4;
       c1sXT: // global
           I64[Sp] = block_c1sXS_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       u1sY4: // global
           Sp = Sp + 8;
           call _s1sev() args: 0, res: 0, upd: 0;
     }
 },
 _c1sXS() //  [R1]
         { info_tbl: [(c1sXS,
                       label: block_c1sXS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sXS: // global
           if (R1 == 1) goto c1sY3; else goto u1sY5;
       c1sY3: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1sY5: // global
           Sp = Sp + 8;
           call _s1sev() args: 0, res: 0, upd: 0;
     }
 },
 _s1sev() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1sev: // global
           I64[Sp - 8] = block_c1sXr_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1sXr() //  [R1]
         { info_tbl: [(c1sXr,
                       label: block_c1sXr_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sXr: // global
           I64[Sp + 24] = block_c1sXv_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1sXv() //  [R1]
         { info_tbl: [(c1sXv,
                       label: block_c1sXv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sXv: // global
           _s1sex::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1sXB_info;
           R3 = _s1sex::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1sXB() //  [R1]
         { info_tbl: [(c1sXB,
                       label: block_c1sXB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sXB: // global
           if (R1 == 1) goto c1sXM; else goto c1sXI;
       c1sXM: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1sXI: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.205970627 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$ccompare_closure" {
     GHC.Real.$fEnumRatio_$s$ccompare_closure:
         const GHC.Real.$fEnumRatio_$s$ccompare_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c1sYM,
                       label: GHC.Real.$fEnumRatio_$s$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sYM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1sYQ; else goto c1sYR;
       c1sYQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1sYR: // global
           I64[Sp - 16] = block_c1sYJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1sYZ; else goto c1sYK;
       u1sYZ: // global
           call _c1sYJ(R1) args: 0, res: 0, upd: 0;
       c1sYK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sYJ() //  [R1]
         { info_tbl: [(c1sYJ,
                       label: block_c1sYJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sYJ: // global
           I64[Sp - 8] = block_c1sYP_info;
           _s1seE::P64 = P64[R1 + 7];
           _s1seF::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1seF::P64;
           P64[Sp + 8] = _s1seE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sYY; else goto c1sYT;
       u1sYY: // global
           call _c1sYP(R1) args: 0, res: 0, upd: 0;
       c1sYT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sYP() //  [R1]
         { info_tbl: [(c1sYP,
                       label: block_c1sYP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sYP: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.214037562 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c>=_closure" {
     GHC.Real.$fEnumRatio_$s$c>=_closure:
         const GHC.Real.$fEnumRatio_$s$c>=_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c>=_entry() //  [R2, R3]
         { info_tbl: [(c1sZm,
                       label: GHC.Real.$fEnumRatio_$s$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sZm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1sZq; else goto c1sZr;
       c1sZq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1sZr: // global
           I64[Sp - 16] = block_c1sZj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1sZL; else goto c1sZk;
       u1sZL: // global
           call _c1sZj(R1) args: 0, res: 0, upd: 0;
       c1sZk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sZj() //  [R1]
         { info_tbl: [(c1sZj,
                       label: block_c1sZj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sZj: // global
           I64[Sp - 8] = block_c1sZp_info;
           _s1seM::P64 = P64[R1 + 7];
           _s1seN::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1seN::P64;
           P64[Sp + 8] = _s1seM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1sZK; else goto c1sZt;
       u1sZK: // global
           call _c1sZp(R1) args: 0, res: 0, upd: 0;
       c1sZt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1sZp() //  [R1]
         { info_tbl: [(c1sZp,
                       label: block_c1sZp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sZp: // global
           _s1seM::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1sZx_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1seM::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1sZx() //  [R1]
         { info_tbl: [(c1sZx,
                       label: block_c1sZx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1sZx: // global
           if (R1 & 7 == 1) goto c1sZI; else goto c1sZE;
       c1sZI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1sZE: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.224270888 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$c>_closure" {
     GHC.Real.$fOrdRatio_$s$c>_closure:
         const GHC.Real.$fOrdRatio_$s$c>_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$c>_entry() //  [R2, R3]
         { info_tbl: [(c1t0i,
                       label: GHC.Real.$fOrdRatio_$s$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t0i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1t0m; else goto c1t0n;
       c1t0m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1t0n: // global
           I64[Sp - 16] = block_c1t0f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1t0H; else goto c1t0g;
       u1t0H: // global
           call _c1t0f(R1) args: 0, res: 0, upd: 0;
       c1t0g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t0f() //  [R1]
         { info_tbl: [(c1t0f,
                       label: block_c1t0f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t0f: // global
           I64[Sp - 8] = block_c1t0l_info;
           _s1seV::P64 = P64[R1 + 7];
           _s1seW::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1seW::P64;
           P64[Sp + 8] = _s1seV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1t0G; else goto c1t0p;
       u1t0G: // global
           call _c1t0l(R1) args: 0, res: 0, upd: 0;
       c1t0p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t0l() //  [R1]
         { info_tbl: [(c1t0l,
                       label: block_c1t0l_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t0l: // global
           _s1seV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1t0t_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1seV::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1t0t() //  [R1]
         { info_tbl: [(c1t0t,
                       label: block_c1t0t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t0t: // global
           if (R1 & 7 == 3) goto c1t0E; else goto c1t0A;
       c1t0E: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1t0A: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.23426887 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$cmin_closure" {
     GHC.Real.$fOrdRatio_$s$cmin_closure:
         const GHC.Real.$fOrdRatio_$s$cmin_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$cmin_entry() //  [R2, R3]
         { info_tbl: [(c1t1e,
                       label: GHC.Real.$fOrdRatio_$s$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t1e: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1t1r; else goto c1t1s;
       c1t1r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1t1s: // global
           I64[Sp - 16] = block_c1t1b_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1t1M; else goto c1t1c;
       u1t1M: // global
           call _c1t1b(R1) args: 0, res: 0, upd: 0;
       c1t1c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t1b() //  [R1]
         { info_tbl: [(c1t1b,
                       label: block_c1t1b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t1b: // global
           I64[Sp - 16] = block_c1t1h_info;
           _s1sf3::P64 = R1;
           _s1sf4::P64 = P64[R1 + 7];
           _s1sf5::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s1sf5::P64;
           P64[Sp] = _s1sf4::P64;
           P64[Sp + 8] = _s1sf3::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1t1L; else goto c1t1i;
       u1t1L: // global
           call _c1t1h(R1) args: 0, res: 0, upd: 0;
       c1t1i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t1h() //  [R1]
         { info_tbl: [(c1t1h,
                       label: block_c1t1h_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t1h: // global
           I64[Sp - 8] = block_c1t1m_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1t1m() //  [R1]
         { info_tbl: [(c1t1m,
                       label: block_c1t1m_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t1m: // global
           _s1sf8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1t1q_info;
           R3 = _s1sf8::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1t1q() //  [R1]
         { info_tbl: [(c1t1q,
                       label: block_c1t1q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t1q: // global
           I64[Sp] = block_c1t1z_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1t1z() //  [R1]
         { info_tbl: [(c1t1z,
                       label: block_c1t1z_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t1z: // global
           if (R1 == 1) goto c1t1K; else goto c1t1G;
       c1t1K: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1t1G: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.247337915 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$cmax_closure" {
     GHC.Real.$fOrdRatio_$s$cmax_closure:
         const GHC.Real.$fOrdRatio_$s$cmax_info;
         const 0;
 },
 GHC.Real.$fOrdRatio_$s$cmax_entry() //  [R2, R3]
         { info_tbl: [(c1t2q,
                       label: GHC.Real.$fOrdRatio_$s$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t2q: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1t2D; else goto c1t2E;
       c1t2D: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1t2E: // global
           I64[Sp - 16] = block_c1t2n_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1t2Y; else goto c1t2o;
       u1t2Y: // global
           call _c1t2n(R1) args: 0, res: 0, upd: 0;
       c1t2o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t2n() //  [R1]
         { info_tbl: [(c1t2n,
                       label: block_c1t2n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t2n: // global
           I64[Sp - 16] = block_c1t2t_info;
           _s1sfe::P64 = R1;
           _s1sff::P64 = P64[R1 + 7];
           _s1sfg::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s1sfg::P64;
           P64[Sp] = _s1sff::P64;
           P64[Sp + 8] = _s1sfe::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1t2X; else goto c1t2u;
       u1t2X: // global
           call _c1t2t(R1) args: 0, res: 0, upd: 0;
       c1t2u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t2t() //  [R1]
         { info_tbl: [(c1t2t,
                       label: block_c1t2t_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t2t: // global
           I64[Sp - 8] = block_c1t2y_info;
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1t2y() //  [R1]
         { info_tbl: [(c1t2y,
                       label: block_c1t2y_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t2y: // global
           _s1sfj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1t2C_info;
           R3 = _s1sfj::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1t2C() //  [R1]
         { info_tbl: [(c1t2C,
                       label: block_c1t2C_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t2C: // global
           I64[Sp] = block_c1t2L_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1t2L() //  [R1]
         { info_tbl: [(c1t2L,
                       label: block_c1t2L_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t2L: // global
           if (R1 == 1) goto c1t2W; else goto c1t2S;
       c1t2W: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1t2S: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.260639396 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cnegate_closure" {
     GHC.Real.$fFractionalRatio_$s$cnegate_closure:
         const GHC.Real.$fFractionalRatio_$s$cnegate_info;
 },
 GHC.Real.$fFractionalRatio_$s$cnegate_entry() //  [R2]
         { info_tbl: [(c1t3C,
                       label: GHC.Real.$fFractionalRatio_$s$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t3C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1t3K; else goto c1t3L;
       c1t3K: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1t3L: // global
           I64[Sp - 8] = block_c1t3z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1t3Q; else goto c1t3A;
       u1t3Q: // global
           call _c1t3z(R1) args: 0, res: 0, upd: 0;
       c1t3A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t3z() //  [R1]
         { info_tbl: [(c1t3z,
                       label: block_c1t3z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t3z: // global
           I64[Sp - 8] = block_c1t3F_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1t3F() //  [R1]
         { info_tbl: [(c1t3F,
                       label: block_c1t3F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t3F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1t3P; else goto c1t3O;
       c1t3P: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1t3O: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.26831022 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cabs_closure" {
     GHC.Real.$fFractionalRatio_$s$cabs_closure:
         const GHC.Real.$fFractionalRatio_$s$cabs_info;
 },
 GHC.Real.$fFractionalRatio_$s$cabs_entry() //  [R2]
         { info_tbl: [(c1t4g,
                       label: GHC.Real.$fFractionalRatio_$s$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t4g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1t4o; else goto c1t4p;
       c1t4o: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1t4p: // global
           I64[Sp - 8] = block_c1t4d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1t4u; else goto c1t4e;
       u1t4u: // global
           call _c1t4d(R1) args: 0, res: 0, upd: 0;
       c1t4e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t4d() //  [R1]
         { info_tbl: [(c1t4d,
                       label: block_c1t4d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t4d: // global
           I64[Sp - 8] = block_c1t4j_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1t4j() //  [R1]
         { info_tbl: [(c1t4j,
                       label: block_c1t4j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t4j: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1t4t; else goto c1t4s;
       c1t4t: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1t4s: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.275534481 UTC

[section ""data" . sat_s1sfx_closure" {
     sat_s1sfx_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.277227341 UTC

[section ""data" . sat_s1sfy_closure" {
     sat_s1sfy_closure:
         const :_con_info;
         const sat_s1sfx_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.279298336 UTC

[section ""data" . GHC.Real.$fEnumRatio1_closure" {
     GHC.Real.$fEnumRatio1_closure:
         const GHC.Real.$fEnumRatio1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fEnumRatio1_entry() //  [R1]
         { info_tbl: [(c1t4V,
                       label: GHC.Real.$fEnumRatio1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t4V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1t4W; else goto c1t4X;
       c1t4W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1t4X: // global
           (_c1t4S::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1t4S::I64 == 0) goto c1t4U; else goto c1t4T;
       c1t4U: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1t4T: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1t4S::I64;
           R3 = sat_s1sfy_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.284440184 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$csignum_closure" {
     GHC.Real.$fFractionalRatio_$s$csignum_closure:
         const GHC.Real.$fFractionalRatio_$s$csignum_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$csignum_entry() //  [R2]
         { info_tbl: [(c1t5e,
                       label: GHC.Real.$fFractionalRatio_$s$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t5e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1t5m; else goto c1t5n;
       c1t5m: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1t5n: // global
           I64[Sp - 8] = block_c1t5b_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1t5s; else goto c1t5c;
       u1t5s: // global
           call _c1t5b(R1) args: 0, res: 0, upd: 0;
       c1t5c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t5b() //  [R1]
         { info_tbl: [(c1t5b,
                       label: block_c1t5b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t5b: // global
           I64[Sp] = block_c1t5h_info;
           R2 = P64[R1 + 7];
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1t5h() //  [R1]
         { info_tbl: [(c1t5h,
                       label: block_c1t5h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t5h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1t5r; else goto c1t5q;
       c1t5r: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1t5q: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Real.$fEnumRatio1_closure;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.291749369 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cfromInteger_closure" {
     GHC.Real.$fFractionalRatio_$s$cfromInteger_closure:
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$cfromInteger_entry() //  [R2]
         { info_tbl: [(c1t5R,
                       label: GHC.Real.$fFractionalRatio_$s$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t5R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1t5V; else goto c1t5W;
       c1t5V: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1t5W: // global
           I64[Sp - 8] = block_c1t5O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1t60; else goto c1t5P;
       u1t60: // global
           call _c1t5O(R1) args: 0, res: 0, upd: 0;
       c1t5P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t5O() //  [R1]
         { info_tbl: [(c1t5O,
                       label: block_c1t5O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t5O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1t5Z; else goto c1t5Y;
       c1t5Z: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1t5Y: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Real.$fEnumRatio1_closure;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.297947835 UTC

[section ""data" . GHC.Real.$fRealInteger_closure" {
     GHC.Real.$fRealInteger_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Num.$fNumInteger_closure;
         const GHC.Integer.Type.$fOrdInteger_closure;
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.299978185 UTC

[section ""data" . GHC.Real.$fIntegralInt_$ctoInteger_closure" {
     GHC.Real.$fIntegralInt_$ctoInteger_closure:
         const GHC.Real.$fIntegralInt_$ctoInteger_info;
 },
 GHC.Real.$fIntegralInt_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c1t6m,
                       label: GHC.Real.$fIntegralInt_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t6m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1t6n; else goto c1t6o;
       c1t6n: // global
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1t6o: // global
           I64[Sp - 8] = block_c1t6j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1t6s; else goto c1t6k;
       u1t6s: // global
           call _c1t6j(R1) args: 0, res: 0, upd: 0;
       c1t6k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t6j() //  [R1]
         { info_tbl: [(c1t6j,
                       label: block_c1t6j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t6j: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.305576852 UTC

[section ""data" . GHC.Real.$fEnumRatio_$ctoRational_closure" {
     GHC.Real.$fEnumRatio_$ctoRational_closure:
         const GHC.Real.$fEnumRatio_$ctoRational_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$ctoRational_entry() //  [R2]
         { info_tbl: [(c1t6K,
                       label: GHC.Real.$fEnumRatio_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t6K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1t6S; else goto c1t6T;
       c1t6S: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1t6T: // global
           I64[Sp - 8] = block_c1t6H_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1t6Y; else goto c1t6I;
       u1t6Y: // global
           call _c1t6H(R1) args: 0, res: 0, upd: 0;
       c1t6I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t6H() //  [R1]
         { info_tbl: [(c1t6H,
                       label: block_c1t6H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t6H: // global
           I64[Sp] = block_c1t6N_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1t6N() //  [R1]
         { info_tbl: [(c1t6N,
                       label: block_c1t6N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t6N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1t6X; else goto c1t6W;
       c1t6X: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1t6W: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Real.$fEnumRatio1_closure;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.312796311 UTC

[section ""data" . GHC.Real.$fRealInt_closure" {
     GHC.Real.$fRealInt_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Num.$fNumInt_closure;
         const GHC.Classes.$fOrdInt_closure;
         const GHC.Real.$fEnumRatio_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.31547046 UTC

[section ""data" . GHC.Real.$fIntegralWord_$ctoInteger_closure" {
     GHC.Real.$fIntegralWord_$ctoInteger_closure:
         const GHC.Real.$fIntegralWord_$ctoInteger_info;
 },
 GHC.Real.$fIntegralWord_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c1t7o,
                       label: GHC.Real.$fIntegralWord_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t7o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1t7p; else goto c1t7q;
       c1t7p: // global
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1t7q: // global
           I64[Sp - 8] = block_c1t7l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1t7u; else goto c1t7m;
       u1t7u: // global
           call _c1t7l(R1) args: 0, res: 0, upd: 0;
       c1t7m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t7l() //  [R1]
         { info_tbl: [(c1t7l,
                       label: block_c1t7l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t7l: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.321115462 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$ctoInteger_closure" {
     GHC.Real.$fIntegralInteger_$ctoInteger_closure:
         const GHC.Real.$fIntegralInteger_$ctoInteger_info;
 },
 GHC.Real.$fIntegralInteger_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c1t7J,
                       label: GHC.Real.$fIntegralInteger_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t7J: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.324953449 UTC

[section ""data" . GHC.Real.$fEqRatio_$s$c==_closure" {
     GHC.Real.$fEqRatio_$s$c==_closure:
         const GHC.Real.$fEqRatio_$s$c==_info;
 },
 GHC.Real.$fEqRatio_$s$c==_entry() //  [R2, R3]
         { info_tbl: [(c1t7Z,
                       label: GHC.Real.$fEqRatio_$s$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t7Z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1t83; else goto c1t84;
       c1t83: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_$s$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1t84: // global
           I64[Sp - 16] = block_c1t7W_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1t8s; else goto c1t7X;
       u1t8s: // global
           call _c1t7W(R1) args: 0, res: 0, upd: 0;
       c1t7X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t7W() //  [R1]
         { info_tbl: [(c1t7W,
                       label: block_c1t7W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t7W: // global
           I64[Sp - 8] = block_c1t82_info;
           _s1sfU::P64 = P64[R1 + 7];
           _s1sfV::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1sfV::P64;
           P64[Sp + 8] = _s1sfU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1t8r; else goto c1t86;
       u1t8r: // global
           call _c1t82(R1) args: 0, res: 0, upd: 0;
       c1t86: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t82() //  [R1]
         { info_tbl: [(c1t82,
                       label: block_c1t82_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t82: // global
           I64[Sp] = block_c1t8a_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 15];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1t8a() //  [R1]
         { info_tbl: [(c1t8a,
                       label: block_c1t8a_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t8a: // global
           if (R1 == 1) goto c1t8m; else goto c1t8h;
       c1t8m: // global
           _s1sfY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1t8k_info;
           R3 = _s1sfY::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       c1t8h: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1t8k() //  [R1]
         { info_tbl: [(c1t8k,
                       label: block_c1t8k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t8k: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.33591548 UTC

[section ""data" . GHC.Real.$fEqRatio_$c==_closure" {
     GHC.Real.$fEqRatio_$c==_closure:
         const GHC.Real.$fEqRatio_$c==_info;
 },
 GHC.Real.$fEqRatio_$c==_entry() //  [R2, R3, R4]
         { info_tbl: [(c1t93,
                       label: GHC.Real.$fEqRatio_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t93: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1t97; else goto c1t98;
       c1t97: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1t98: // global
           I64[Sp - 24] = block_c1t90_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1t9s; else goto c1t91;
       u1t9s: // global
           call _c1t90(R1) args: 0, res: 0, upd: 0;
       c1t91: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t90() //  [R1]
         { info_tbl: [(c1t90,
                       label: block_c1t90_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t90: // global
           I64[Sp - 8] = block_c1t96_info;
           _s1sg5::P64 = P64[R1 + 7];
           _s1sg6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1sg6::P64;
           P64[Sp + 16] = _s1sg5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1t9r; else goto c1t9a;
       u1t9r: // global
           call _c1t96(R1) args: 0, res: 0, upd: 0;
       c1t9a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t96() //  [R1]
         { info_tbl: [(c1t96,
                       label: block_c1t96_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t96: // global
           I64[Sp] = block_c1t9e_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1t9e() //  [R1]
         { info_tbl: [(c1t9e,
                       label: block_c1t9e_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t9e: // global
           if (R1 & 7 == 1) goto c1t9l; else goto c1t9p;
       c1t9l: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1t9p: // global
           R2 = P64[Sp + 16];
           _s1sg6::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1sg6::P64;
           Sp = Sp + 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.346584242 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$c/=_closure" {
     GHC.Real.$fOrdRatio_$s$c/=_closure:
         const GHC.Real.$fOrdRatio_$s$c/=_info;
 },
 GHC.Real.$fOrdRatio_$s$c/=_entry() //  [R2, R3]
         { info_tbl: [(c1ta2,
                       label: GHC.Real.$fOrdRatio_$s$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ta2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1ta6; else goto c1ta7;
       c1ta6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$s$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ta7: // global
           I64[Sp - 16] = block_c1t9Z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1taD; else goto c1ta0;
       u1taD: // global
           call _c1t9Z(R1) args: 0, res: 0, upd: 0;
       c1ta0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1t9Z() //  [R1]
         { info_tbl: [(c1t9Z,
                       label: block_c1t9Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1t9Z: // global
           I64[Sp - 8] = block_c1ta5_info;
           _s1sge::P64 = P64[R1 + 7];
           _s1sgf::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1sgf::P64;
           P64[Sp + 8] = _s1sge::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1taC; else goto c1ta9;
       u1taC: // global
           call _c1ta5(R1) args: 0, res: 0, upd: 0;
       c1ta9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ta5() //  [R1]
         { info_tbl: [(c1ta5,
                       label: block_c1ta5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ta5: // global
           I64[Sp] = block_c1tad_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 15];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tad() //  [R1]
         { info_tbl: [(c1tad,
                       label: block_c1tad_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tad: // global
           if (R1 == 1) goto c1tap; else goto u1taA;
       c1tap: // global
           _s1sgi::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1tan_info;
           R3 = _s1sgi::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       u1taA: // global
           Sp = Sp + 24;
           call _c1tav() args: 0, res: 0, upd: 0;
     }
 },
 _c1tan() //  [R1]
         { info_tbl: [(c1tan,
                       label: block_c1tan_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tan: // global
           if (R1 == 1) goto c1taz; else goto u1taB;
       c1taz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1taB: // global
           Sp = Sp + 8;
           call _c1tav() args: 0, res: 0, upd: 0;
     }
 },
 _c1tav() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tav: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.358611417 UTC

[section ""data" . GHC.Real.$fEqRatio_$c/=_closure" {
     GHC.Real.$fEqRatio_$c/=_closure:
         const GHC.Real.$fEqRatio_$c/=_info;
 },
 GHC.Real.$fEqRatio_$c/=_entry() //  [R2, R3, R4]
         { info_tbl: [(c1tbh,
                       label: GHC.Real.$fEqRatio_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tbh: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1tbl; else goto c1tbm;
       c1tbl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tbm: // global
           I64[Sp - 24] = block_c1tbe_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1tbU; else goto c1tbf;
       u1tbU: // global
           call _c1tbe(R1) args: 0, res: 0, upd: 0;
       c1tbf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tbe() //  [R1]
         { info_tbl: [(c1tbe,
                       label: block_c1tbe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tbe: // global
           I64[Sp - 8] = block_c1tbk_info;
           _s1sgp::P64 = P64[R1 + 7];
           _s1sgq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1sgq::P64;
           P64[Sp + 16] = _s1sgp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1tbT; else goto c1tbo;
       u1tbT: // global
           call _c1tbk(R1) args: 0, res: 0, upd: 0;
       c1tbo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tbk() //  [R1]
         { info_tbl: [(c1tbk,
                       label: block_c1tbk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tbk: // global
           I64[Sp] = block_c1tbs_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1tbs() //  [R1]
         { info_tbl: [(c1tbs,
                       label: block_c1tbs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tbs: // global
           if (R1 & 7 == 1) goto u1tbR; else goto c1tbE;
       u1tbR: // global
           Sp = Sp + 32;
           call _c1tbK() args: 0, res: 0, upd: 0;
       c1tbE: // global
           _s1sgt::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1tbC_info;
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = _s1sgt::P64;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1tbC() //  [R1]
         { info_tbl: [(c1tbC,
                       label: block_c1tbC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tbC: // global
           if (R1 & 7 == 1) goto u1tbS; else goto c1tbO;
       u1tbS: // global
           Sp = Sp + 8;
           call _c1tbK() args: 0, res: 0, upd: 0;
       c1tbO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1tbK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tbK: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.370664398 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$fEqRatio_closure" {
     GHC.Real.$fOrdRatio_$s$fEqRatio_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Real.$fEqRatio_$s$c==_closure+2;
         const GHC.Real.$fOrdRatio_$s$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.373015241 UTC

[section ""data" . GHC.Real.$fEqRatio_closure" {
     GHC.Real.$fEqRatio_closure:
         const GHC.Real.$fEqRatio_info;
 },
 sat_s1sgy_entry() //  [R1, R2, R3]
         { info_tbl: [(c1tcJ,
                       label: sat_s1sgy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tcJ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fEqRatio_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sgx_entry() //  [R1, R2, R3]
         { info_tbl: [(c1tcR,
                       label: sat_s1sgx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tcR: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fEqRatio_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEqRatio_entry() //  [R2]
         { info_tbl: [(c1tcV,
                       label: GHC.Real.$fEqRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tcV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1tcZ; else goto c1tcY;
       c1tcZ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Real.$fEqRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1tcY: // global
           I64[Hp - 48] = sat_s1sgy_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s1sgx_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.381064157 UTC

[section ""data" . GHC.Real.$fOrdRatio_$s$fOrdRatio_closure" {
     GHC.Real.$fOrdRatio_$s$fOrdRatio_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Real.$fOrdRatio_$s$fEqRatio_closure+1;
         const GHC.Real.$fEnumRatio_$s$ccompare_closure+2;
         const GHC.Real.$fOrdRatio_$s$c<_closure+2;
         const GHC.Real.$fEnumRatio_$s$c<=_closure+2;
         const GHC.Real.$fOrdRatio_$s$c>_closure+2;
         const GHC.Real.$fEnumRatio_$s$c>=_closure+2;
         const GHC.Real.$fOrdRatio_$s$cmax_closure+2;
         const GHC.Real.$fOrdRatio_$s$cmin_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.383516913 UTC

[section ""data" . GHC.Real.$fOrdRatio_$cp1Ord_closure" {
     GHC.Real.$fOrdRatio_$cp1Ord_closure:
         const GHC.Real.$fOrdRatio_$cp1Ord_info;
 },
 sat_s1sgC_entry() //  [R1]
         { info_tbl: [(c1tdr,
                       label: sat_s1sgC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tdr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tdv; else goto c1tdw;
       c1tdv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tdw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1tdp_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1tdp() //  [R1]
         { info_tbl: [(c1tdp,
                       label: block_c1tdp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tdp: // global
           I64[Sp] = block_c1tdu_info;
           R2 = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1tdu() //  [R1]
         { info_tbl: [(c1tdu,
                       label: block_c1tdu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tdu: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fOrdRatio_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c1tdC,
                       label: GHC.Real.$fOrdRatio_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tdC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tdG; else goto c1tdF;
       c1tdG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1tdF: // global
           I64[Hp - 16] = sat_s1sgC_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Real.$fEqRatio_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.392308628 UTC

[section ""data" . GHC.Real.even1_closure" {
     GHC.Real.even1_closure:
         const GHC.Real.even1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.even1_entry() //  [R1]
         { info_tbl: [(c1te5,
                       label: GHC.Real.even1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1te5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1te6; else goto c1te7;
       c1te6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1te7: // global
           (_c1te2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1te2::I64 == 0) goto c1te4; else goto c1te3;
       c1te4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1te3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1te2::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.397534565 UTC

[section ""data" . GHC.Real.$dmfloor_closure" {
     GHC.Real.$dmfloor_closure:
         const GHC.Real.$dmfloor_info;
         const 0;
 },
 ds_s1sgG_entry() //  [R1]
         { info_tbl: [(c1teq,
                       label: ds_s1sgG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1teq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ter; else goto c1tes;
       c1ter: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tes: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.properFraction_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sgO_entry() //  [R1]
         { info_tbl: [(c1teD,
                       label: sat_s1sgO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1teD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1teE; else goto c1teF;
       c1teE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1teF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1teB_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1teB() //  [R1]
         { info_tbl: [(c1teB,
                       label: block_c1teB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1teB: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sgZ_entry() //  [R1]
         { info_tbl: [(c1tf5,
                       label: sat_s1sgZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tf5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tf6; else goto c1tf7;
       c1tf6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tf7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(c1tf8,
                       label: GHC.Real.$dmfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tf8: // global
           _s1sgF::P64 = R4;
           _s1sgE::P64 = R3;
           _s1sgD::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1tf9; else goto c1tfa;
       c1tfa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1tfc; else goto c1tfb;
       c1tfc: // global
           HpAlloc = 40;
           goto c1tf9;
       c1tf9: // global
           R4 = _s1sgF::P64;
           R3 = _s1sgE::P64;
           R2 = _s1sgD::P64;
           R1 = GHC.Real.$dmfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tfb: // global
           I64[Hp - 32] = ds_s1sgG_info;
           P64[Hp - 16] = _s1sgD::P64;
           P64[Hp - 8] = _s1sgE::P64;
           P64[Hp] = _s1sgF::P64;
           I64[Sp - 24] = block_c1tet_info;
           R2 = _s1sgD::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s1sgE::P64;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tet() //  [R1]
         { info_tbl: [(c1tet,
                       label: block_c1tet_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tet: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1tff; else goto c1tfe;
       c1tff: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tfe: // global
           I64[Hp - 40] = sat_s1sgO_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = block_c1teK_info;
           R2 = R1;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1teK() //  [R1]
         { info_tbl: [(c1teK,
                       label: block_c1teK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1teK: // global
           _c1tex::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1teO_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _c1tex::P64;
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1teO() //  [R1]
         { info_tbl: [(c1teO,
                       label: block_c1teO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1teO: // global
           if (R1 & 7 == 1) goto c1tfl; else goto c1tfs;
       c1tfl: // global
           I64[Sp + 16] = block_c1tfi_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u1tfz; else goto c1tfm;
       u1tfz: // global
           call _c1tfi(R1) args: 0, res: 0, upd: 0;
       c1tfm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1tfs: // global
           I64[Sp] = block_c1teT_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tfi() //  [R1]
         { info_tbl: [(c1tfi,
                       label: block_c1tfi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tfi: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1teT() //  [R1]
         { info_tbl: [(c1teT,
                       label: block_c1teT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1teT: // global
           I64[Sp] = block_c1teX_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1teX() //  [R1]
         { info_tbl: [(c1teX,
                       label: block_c1teX_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1teX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1tfw; else goto c1tfv;
       c1tfw: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tfv: // global
           I64[Hp - 40] = sat_s1sgZ_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = Hp - 40;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.422171947 UTC

[section ""data" . GHC.Real.$dmceiling_closure" {
     GHC.Real.$dmceiling_closure:
         const GHC.Real.$dmceiling_info;
         const 0;
 },
 ds_s1sh3_entry() //  [R1]
         { info_tbl: [(c1tgT,
                       label: ds_s1sh3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tgT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1tgU; else goto c1tgV;
       c1tgU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tgV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.properFraction_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1shb_entry() //  [R1]
         { info_tbl: [(c1th6,
                       label: sat_s1shb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1th6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1th7; else goto c1th8;
       c1th7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1th8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1th4_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1th4() //  [R1]
         { info_tbl: [(c1th4,
                       label: block_c1th4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1th4: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1shm_entry() //  [R1]
         { info_tbl: [(c1thy,
                       label: sat_s1shm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1thy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1thz; else goto c1thA;
       c1thz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1thA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(c1thB,
                       label: GHC.Real.$dmceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1thB: // global
           _s1sh2::P64 = R4;
           _s1sh1::P64 = R3;
           _s1sh0::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1thC; else goto c1thD;
       c1thD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1thF; else goto c1thE;
       c1thF: // global
           HpAlloc = 40;
           goto c1thC;
       c1thC: // global
           R4 = _s1sh2::P64;
           R3 = _s1sh1::P64;
           R2 = _s1sh0::P64;
           R1 = GHC.Real.$dmceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1thE: // global
           I64[Hp - 32] = ds_s1sh3_info;
           P64[Hp - 16] = _s1sh0::P64;
           P64[Hp - 8] = _s1sh1::P64;
           P64[Hp] = _s1sh2::P64;
           I64[Sp - 24] = block_c1tgW_info;
           R2 = _s1sh0::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s1sh1::P64;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tgW() //  [R1]
         { info_tbl: [(c1tgW,
                       label: block_c1tgW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tgW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1thI; else goto c1thH;
       c1thI: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1thH: // global
           I64[Hp - 40] = sat_s1shb_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = block_c1thd_info;
           R2 = R1;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1thd() //  [R1]
         { info_tbl: [(c1thd,
                       label: block_c1thd_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1thd: // global
           _c1th0::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1thh_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _c1th0::P64;
           Sp = Sp - 8;
           call GHC.Classes.>_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1thh() //  [R1]
         { info_tbl: [(c1thh,
                       label: block_c1thh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1thh: // global
           if (R1 & 7 == 1) goto c1thO; else goto c1thV;
       c1thO: // global
           I64[Sp + 16] = block_c1thL_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u1ti2; else goto c1thP;
       u1ti2: // global
           call _c1thL(R1) args: 0, res: 0, upd: 0;
       c1thP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1thV: // global
           I64[Sp] = block_c1thm_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1thL() //  [R1]
         { info_tbl: [(c1thL,
                       label: block_c1thL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1thL: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1thm() //  [R1]
         { info_tbl: [(c1thm,
                       label: block_c1thm_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1thm: // global
           I64[Sp] = block_c1thq_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1thq() //  [R1]
         { info_tbl: [(c1thq,
                       label: block_c1thq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1thq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1thZ; else goto c1thY;
       c1thZ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1thY: // global
           I64[Hp - 40] = sat_s1shm_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = Hp - 40;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.445167682 UTC

[section ""data" . GHC.Real.$dmtruncate_closure" {
     GHC.Real.$dmtruncate_closure:
         const GHC.Real.$dmtruncate_info;
 },
 GHC.Real.$dmtruncate_entry() //  [R2, R3, R4]
         { info_tbl: [(c1tjk,
                       label: GHC.Real.$dmtruncate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tjk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tjl; else goto c1tjm;
       c1tjl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmtruncate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tjm: // global
           I64[Sp - 8] = block_c1tji_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.properFraction_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1tji() //  [R1]
         { info_tbl: [(c1tji,
                       label: block_c1tji_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tji: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.450678604 UTC

[section ""data" . GHC.Real.$dmrecip_closure" {
     GHC.Real.$dmrecip_closure:
         const GHC.Real.$dmrecip_info;
         const 0;
 },
 sat_s1shw_entry() //  [R1]
         { info_tbl: [(c1tjK,
                       label: sat_s1shw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tjK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tjL; else goto c1tjM;
       c1tjL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tjM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1tjI_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1tjI() //  [R1]
         { info_tbl: [(c1tjI,
                       label: block_c1tjI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tjI: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmrecip_entry() //  [R2, R3]
         { info_tbl: [(c1tjQ,
                       label: GHC.Real.$dmrecip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tjQ: // global
           _s1shu::P64 = R3;
           _s1sht::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1tjR; else goto c1tjS;
       c1tjS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tjU; else goto c1tjT;
       c1tjU: // global
           HpAlloc = 24;
           goto c1tjR;
       c1tjR: // global
           R3 = _s1shu::P64;
           R2 = _s1sht::P64;
           R1 = GHC.Real.$dmrecip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tjT: // global
           I64[Hp - 16] = sat_s1shw_info;
           P64[Hp] = _s1sht::P64;
           R2 = _s1sht::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s1shu::P64;
           Sp = Sp - 24;
           call GHC.Real./_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.45868963 UTC

[section ""data" . GHC.Real.$dm/_closure" {
     GHC.Real.$dm/_closure:
         const GHC.Real.$dm/_info;
 },
 sat_s1shB_entry() //  [R1]
         { info_tbl: [(c1tkm,
                       label: sat_s1shB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tkm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tkn; else goto c1tko;
       c1tkn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tko: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.recip_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dm/_entry() //  [R2, R3, R4]
         { info_tbl: [(c1tkr,
                       label: GHC.Real.$dm/_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tkr: // global
           _s1shz::P64 = R4;
           _s1shy::P64 = R3;
           _s1shx::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1tks; else goto c1tkt;
       c1tkt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1tkv; else goto c1tku;
       c1tkv: // global
           HpAlloc = 32;
           goto c1tks;
       c1tks: // global
           R4 = _s1shz::P64;
           R3 = _s1shy::P64;
           R2 = _s1shx::P64;
           R1 = GHC.Real.$dm/_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tku: // global
           I64[Hp - 24] = sat_s1shB_info;
           P64[Hp - 8] = _s1shx::P64;
           P64[Hp] = _s1shz::P64;
           I64[Sp - 24] = block_c1tkp_info;
           R2 = _s1shx::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s1shy::P64;
           Sp = Sp - 24;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tkp() //  [R1]
         { info_tbl: [(c1tkp,
                       label: block_c1tkp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tkp: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _c1tki::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _c1tki::P64;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.468309464 UTC

[section ""data" . GHC.Real.$dmdivMod_closure" {
     GHC.Real.$dmdivMod_closure:
         const GHC.Real.$dmdivMod_info;
         const 0;
 },
 $dNum_s1shG_entry() //  [R1]
         { info_tbl: [(c1tl5,
                       label: $dNum_s1shG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tl5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tl6; else goto c1tl7;
       c1tl6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tl7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_s1shH_entry() //  [R1]
         { info_tbl: [(c1tle,
                       label: ds_s1shH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tle: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1tli; else goto c1tlj;
       c1tli: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tlj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1tlc_info;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_pp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1tlc() //  [R1]
         { info_tbl: [(c1tlc,
                       label: block_c1tlc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tlc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1tlm; else goto c1tll;
       c1tlm: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1tll: // global
           _s1shJ::P64 = P64[R1 + 7];
           _s1shK::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = _s1shJ::P64;
           P64[Hp] = _s1shK::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1shT_entry() //  [R1]
         { info_tbl: [(c1tlw,
                       label: sat_s1shT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tlw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tlx; else goto c1tly;
       c1tlx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tly: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1shU_entry() //  [R1]
         { info_tbl: [(c1tlz,
                       label: sat_s1shU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tlz: // global
           _s1shU::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1tlA; else goto c1tlB;
       c1tlB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1tlD; else goto c1tlC;
       c1tlD: // global
           HpAlloc = 32;
           goto c1tlA;
       c1tlA: // global
           R1 = _s1shU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tlC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1shU::P64;
           _s1shE::P64 = P64[_s1shU::P64 + 16];
           _s1shG::P64 = P64[_s1shU::P64 + 24];
           I64[Hp - 24] = sat_s1shT_info;
           P64[Hp - 8] = _s1shE::P64;
           P64[Hp] = _s1shG::P64;
           R2 = _s1shG::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1shS_entry() //  [R1]
         { info_tbl: [(c1tlI,
                       label: sat_s1shS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tlI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tlJ; else goto c1tlK;
       c1tlJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tlK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1si7_entry() //  [R1]
         { info_tbl: [(c1tm2,
                       label: sat_s1si7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tm2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1tm3; else goto c1tm4;
       c1tm3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tm4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1si5_entry() //  [R1]
         { info_tbl: [(c1tmd,
                       label: sat_s1si5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tmd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tme; else goto c1tmf;
       c1tme: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tmf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1si6_entry() //  [R1]
         { info_tbl: [(c1tmh,
                       label: sat_s1si6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tmh: // global
           _s1si6::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1tmi; else goto c1tmj;
       c1tmj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1tml; else goto c1tmk;
       c1tml: // global
           HpAlloc = 48;
           goto c1tmi;
       c1tmi: // global
           R1 = _s1si6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tmk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1si6::P64;
           _s1shG::P64 = P64[_s1si6::P64 + 16];
           _s1shH::P64 = P64[_s1si6::P64 + 24];
           I64[Hp - 40] = sat_s1si5_info;
           P64[Hp - 24] = _s1shG::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1shH::P64;
           R2 = _s1shG::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmdivMod_entry() //  [R2, R3, R4]
         { info_tbl: [(c1tmm,
                       label: GHC.Real.$dmdivMod_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tmm: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1tmn; else goto c1tmo;
       c1tmn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmdivMod_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tmo: // global
           I64[Sp - 32] = block_c1tkX_info;
           _s1shC::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1shC::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tkX() //  [R1]
         { info_tbl: [(c1tkX,
                       label: block_c1tkX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tkX: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c1tmr; else goto c1tmq;
       c1tmr: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tmq: // global
           I64[Hp - 144] = $dNum_s1shG_info;
           P64[Hp - 128] = R1;
           I64[Hp - 120] = ds_s1shH_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = P64[Sp + 16];
           _s1shE::P64 = P64[Sp + 24];
           P64[Hp - 88] = _s1shE::P64;
           I64[Hp - 80] = stg_sel_2_upd_info;
           _c1tl8::P64 = Hp - 120;
           P64[Hp - 64] = _c1tl8::P64;
           I64[Hp - 56] = sat_s1shU_info;
           P64[Hp - 40] = _s1shE::P64;
           _c1tl1::P64 = Hp - 144;
           P64[Hp - 32] = _c1tl1::P64;
           I64[Hp - 24] = sat_s1shS_info;
           P64[Hp - 8] = _c1tl1::P64;
           _c1tln::P64 = Hp - 80;
           P64[Hp] = _c1tln::P64;
           I64[Sp - 24] = block_c1tlL_info;
           R2 = R1;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 24;
           P64[Sp] = _c1tln::P64;
           P64[Sp + 8] = _c1tl8::P64;
           P64[Sp + 16] = _c1tl1::P64;
           Sp = Sp - 24;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tlL() //  [R1]
         { info_tbl: [(c1tlL,
                       label: block_c1tlL_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tlL: // global
           I64[Sp] = block_c1tlP_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tlP() //  [R1]
         { info_tbl: [(c1tlP,
                       label: block_c1tlP_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tlP: // global
           _c1tlE::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1tlT_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _c1tlE::P64;
           Sp = Sp - 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1tlT() //  [R1]
         { info_tbl: [(c1tlT,
                       label: block_c1tlT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tlT: // global
           _c1tl8::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1tmy; else goto c1tmF;
       c1tmy: // global
           I64[Sp + 32] = block_c1tmv_info;
           R1 = _c1tl8::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u1tmK; else goto c1tmz;
       u1tmK: // global
           call _c1tmv(R1) args: 0, res: 0, upd: 0;
       c1tmz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1tmF: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1tmI; else goto c1tmH;
       c1tmI: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tmH: // global
           I64[Hp - 88] = sat_s1si7_info;
           P64[Hp - 72] = P64[Sp + 32];
           _c1tl1::P64 = P64[Sp + 24];
           P64[Hp - 64] = _c1tl1::P64;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = sat_s1si6_info;
           P64[Hp - 32] = _c1tl1::P64;
           P64[Hp - 24] = _c1tl8::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1tmv() //  [R1]
         { info_tbl: [(c1tmv,
                       label: block_c1tmv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tmv: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.500930756 UTC

[section ""data" . GHC.Real.$dmmod_closure" {
     GHC.Real.$dmmod_closure:
         const GHC.Real.$dmmod_info;
 },
 GHC.Real.$dmmod_entry() //  [R2, R3, R4]
         { info_tbl: [(c1toH,
                       label: GHC.Real.$dmmod_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1toH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1toI; else goto c1toJ;
       c1toI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmmod_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1toJ: // global
           I64[Sp - 8] = block_c1toF_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.divMod_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1toF() //  [R1]
         { info_tbl: [(c1toF,
                       label: block_c1toF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1toF: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.507166304 UTC

[section ""data" . GHC.Real.$dmdiv_closure" {
     GHC.Real.$dmdiv_closure:
         const GHC.Real.$dmdiv_info;
 },
 GHC.Real.$dmdiv_entry() //  [R2, R3, R4]
         { info_tbl: [(c1tp3,
                       label: GHC.Real.$dmdiv_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tp3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tp4; else goto c1tp5;
       c1tp4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmdiv_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tp5: // global
           I64[Sp - 8] = block_c1tp1_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.divMod_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1tp1() //  [R1]
         { info_tbl: [(c1tp1,
                       label: block_c1tp1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tp1: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.512636245 UTC

[section ""data" . GHC.Real.$dmrem_closure" {
     GHC.Real.$dmrem_closure:
         const GHC.Real.$dmrem_info;
 },
 GHC.Real.$dmrem_entry() //  [R2, R3, R4]
         { info_tbl: [(c1tpp,
                       label: GHC.Real.$dmrem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tpp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tpq; else goto c1tpr;
       c1tpq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmrem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tpr: // global
           I64[Sp - 8] = block_c1tpn_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1tpn() //  [R1]
         { info_tbl: [(c1tpn,
                       label: block_c1tpn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tpn: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.51819393 UTC

[section ""data" . GHC.Real.$dmquot_closure" {
     GHC.Real.$dmquot_closure:
         const GHC.Real.$dmquot_info;
 },
 GHC.Real.$dmquot_entry() //  [R2, R3, R4]
         { info_tbl: [(c1tpL,
                       label: GHC.Real.$dmquot_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tpL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tpM; else goto c1tpN;
       c1tpM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$dmquot_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tpN: // global
           I64[Sp - 8] = block_c1tpJ_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           Sp = Sp - 32;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1tpJ() //  [R1]
         { info_tbl: [(c1tpJ,
                       label: block_c1tpJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tpJ: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.523670076 UTC

[section ""data" . GHC.Real.divZeroError_closure" {
     GHC.Real.divZeroError_closure:
         const GHC.Real.divZeroError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.divZeroError_entry() //  [R1]
         { info_tbl: [(c1tq7,
                       label: GHC.Real.divZeroError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tq7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tq8; else goto c1tq9;
       c1tq8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tq9: // global
           (_c1tq4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1tq4::I64 == 0) goto c1tq6; else goto c1tq5;
       c1tq6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1tq5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1tq4::I64;
           R1 = GHC.Exception.divZeroException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.528735648 UTC

[section ""data" . GHC.Real.$fIntegralInt1_closure" {
     GHC.Real.$fIntegralInt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.531042659 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cmod_closure" {
     GHC.Real.$fIntegralInt_$cmod_closure:
         const GHC.Real.$fIntegralInt_$cmod_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c1tqq,
                       label: GHC.Real.$fIntegralInt_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tqq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tqr; else goto c1tqs;
       c1tqr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tqs: // global
           I64[Sp - 16] = block_c1tqn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1tqS; else goto c1tqo;
       u1tqS: // global
           call _c1tqn(R1) args: 0, res: 0, upd: 0;
       c1tqo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tqn() //  [R1]
         { info_tbl: [(c1tqn,
                       label: block_c1tqn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tqn: // global
           _s1siA::I64 = I64[R1 + 7];
           if (_s1siA::I64 != (-1)) goto u1tqQ; else goto c1tqO;
       u1tqQ: // global
           if (_s1siA::I64 != 0) goto c1tqJ; else goto c1tqP;
       c1tqJ: // global
           I64[Sp] = block_c1tqy_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1siA::I64;
           if (R1 & 7 != 0) goto u1tqR; else goto c1tqz;
       u1tqR: // global
           call _c1tqy(R1) args: 0, res: 0, upd: 0;
       c1tqz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1tqP: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tqO: // global
           R1 = GHC.Real.$fIntegralInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1tqy() //  [R1]
         { info_tbl: [(c1tqy,
                       label: block_c1tqy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tqy: // global
           _s1siA::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1tqD_info;
           R3 = _s1siA::I64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tqD() //  [R1]
         { info_tbl: [(c1tqD,
                       label: block_c1tqD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tqD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1tqN; else goto c1tqM;
       c1tqN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1tqM: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.542830791 UTC

[section ""data" . GHC.Real.$fIntegralInt_$crem_closure" {
     GHC.Real.$fIntegralInt_$crem_closure:
         const GHC.Real.$fIntegralInt_$crem_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$crem_entry() //  [R2, R3]
         { info_tbl: [(c1trm,
                       label: GHC.Real.$fIntegralInt_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1trm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1trn; else goto c1tro;
       c1trn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tro: // global
           I64[Sp - 16] = block_c1trj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1trM; else goto c1trk;
       u1trM: // global
           call _c1trj(R1) args: 0, res: 0, upd: 0;
       c1trk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1trj() //  [R1]
         { info_tbl: [(c1trj,
                       label: block_c1trj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1trj: // global
           _s1siJ::I64 = I64[R1 + 7];
           if (_s1siJ::I64 != (-1)) goto u1trK; else goto c1trI;
       u1trK: // global
           if (_s1siJ::I64 != 0) goto c1trE; else goto c1trJ;
       c1trE: // global
           I64[Sp] = block_c1tru_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1siJ::I64;
           if (R1 & 7 != 0) goto u1trL; else goto c1trv;
       u1trL: // global
           call _c1tru(R1) args: 0, res: 0, upd: 0;
       c1trv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1trJ: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1trI: // global
           R1 = GHC.Real.$fIntegralInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1tru() //  [R1]
         { info_tbl: [(c1tru,
                       label: block_c1tru_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tru: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1trH; else goto c1trG;
       c1trH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1trG: // global
           _s1siM::I64 = %MO_S_Rem_W64(I64[R1 + 7], I64[Sp + 8]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1siM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.551174068 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cquot_closure" {
     GHC.Real.$fIntegralInteger_$cquot_closure:
         const GHC.Real.$fIntegralInteger_$cquot_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c1tse,
                       label: GHC.Real.$fIntegralInteger_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tse: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tsf; else goto c1tsg;
       c1tsf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tsg: // global
           I64[Sp - 24] = block_c1ts9_info;
           _s1siO::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1siN::P64 = R2;
           R2 = _s1siO::P64;
           P64[Sp - 16] = _s1siN::P64;
           P64[Sp - 8] = _s1siO::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ts9() //  [R1]
         { info_tbl: [(c1ts9,
                       label: block_c1ts9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ts9: // global
           if (R1 == 1) goto c1tsd; else goto c1tsc;
       c1tsd: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tsc: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.557144615 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$crem_closure" {
     GHC.Real.$fIntegralInteger_$crem_closure:
         const GHC.Real.$fIntegralInteger_$crem_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$crem_entry() //  [R2, R3]
         { info_tbl: [(c1tsF,
                       label: GHC.Real.$fIntegralInteger_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tsF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tsG; else goto c1tsH;
       c1tsG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tsH: // global
           I64[Sp - 24] = block_c1tsA_info;
           _s1siR::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1siQ::P64 = R2;
           R2 = _s1siR::P64;
           P64[Sp - 16] = _s1siQ::P64;
           P64[Sp - 8] = _s1siR::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tsA() //  [R1]
         { info_tbl: [(c1tsA,
                       label: block_c1tsA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tsA: // global
           if (R1 == 1) goto c1tsE; else goto c1tsD;
       c1tsE: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tsD: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.563358925 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cdiv_closure" {
     GHC.Real.$fIntegralInteger_$cdiv_closure:
         const GHC.Real.$fIntegralInteger_$cdiv_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c1tt6,
                       label: GHC.Real.$fIntegralInteger_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tt6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tt7; else goto c1tt8;
       c1tt7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tt8: // global
           I64[Sp - 24] = block_c1tt1_info;
           _s1siU::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1siT::P64 = R2;
           R2 = _s1siU::P64;
           P64[Sp - 16] = _s1siT::P64;
           P64[Sp - 8] = _s1siU::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tt1() //  [R1]
         { info_tbl: [(c1tt1,
                       label: block_c1tt1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tt1: // global
           if (R1 == 1) goto c1tt5; else goto c1tt4;
       c1tt5: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tt4: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.569459431 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cmod_closure" {
     GHC.Real.$fIntegralInteger_$cmod_closure:
         const GHC.Real.$fIntegralInteger_$cmod_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c1ttx,
                       label: GHC.Real.$fIntegralInteger_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ttx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tty; else goto c1ttz;
       c1tty: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ttz: // global
           I64[Sp - 24] = block_c1tts_info;
           _s1siX::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1siW::P64 = R2;
           R2 = _s1siX::P64;
           P64[Sp - 16] = _s1siW::P64;
           P64[Sp - 8] = _s1siX::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tts() //  [R1]
         { info_tbl: [(c1tts,
                       label: block_c1tts_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tts: // global
           if (R1 == 1) goto c1ttw; else goto c1ttv;
       c1ttw: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1ttv: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.578333472 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cquotRem_closure" {
     GHC.Real.$fIntegralInteger_$cquotRem_closure:
         const GHC.Real.$fIntegralInteger_$cquotRem_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c1ttY,
                       label: GHC.Real.$fIntegralInteger_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ttY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1ttZ; else goto c1tu0;
       c1ttZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tu0: // global
           I64[Sp - 24] = block_c1ttT_info;
           _s1sj0::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1siZ::P64 = R2;
           R2 = _s1sj0::P64;
           P64[Sp - 16] = _s1siZ::P64;
           P64[Sp - 8] = _s1sj0::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ttT() //  [R1]
         { info_tbl: [(c1ttT,
                       label: block_c1ttT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ttT: // global
           if (R1 == 1) goto c1ttX; else goto c1ttW;
       c1ttX: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1ttW: // global
           _s1sj0::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1tu3_info;
           R3 = _s1sj0::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tu3() //  [R1, R2]
         { info_tbl: [(c1tu3,
                       label: block_c1tu3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tu3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tu9; else goto c1tu8;
       c1tu9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1tu8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.587109071 UTC

[section ""data" . GHC.Real.$fIntegralInteger_$cdivMod_closure" {
     GHC.Real.$fIntegralInteger_$cdivMod_closure:
         const GHC.Real.$fIntegralInteger_$cdivMod_info;
         const 0;
 },
 GHC.Real.$fIntegralInteger_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c1tuB,
                       label: GHC.Real.$fIntegralInteger_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tuB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tuC; else goto c1tuD;
       c1tuC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInteger_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tuD: // global
           I64[Sp - 24] = block_c1tuw_info;
           _s1sj6::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1sj5::P64 = R2;
           R2 = _s1sj6::P64;
           P64[Sp - 16] = _s1sj5::P64;
           P64[Sp - 8] = _s1sj6::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tuw() //  [R1]
         { info_tbl: [(c1tuw,
                       label: block_c1tuw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tuw: // global
           if (R1 == 1) goto c1tuA; else goto c1tuz;
       c1tuA: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tuz: // global
           _s1sj6::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1tuG_info;
           R3 = _s1sj6::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tuG() //  [R1, R2]
         { info_tbl: [(c1tuG,
                       label: block_c1tuG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tuG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tuM; else goto c1tuL;
       c1tuM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1tuL: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.595522743 UTC

[section ""data" . GHC.Real.$fIntegralInteger_closure" {
     GHC.Real.$fIntegralInteger_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Real.$fRealInteger_closure+1;
         const GHC.Enum.$fEnumInteger_closure;
         const GHC.Real.$fIntegralInteger_$cquot_closure+2;
         const GHC.Real.$fIntegralInteger_$crem_closure+2;
         const GHC.Real.$fIntegralInteger_$cdiv_closure+2;
         const GHC.Real.$fIntegralInteger_$cmod_closure+2;
         const GHC.Real.$fIntegralInteger_$cquotRem_closure+2;
         const GHC.Real.$fIntegralInteger_$cdivMod_closure+2;
         const GHC.Real.$fIntegralInteger_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.598227798 UTC

[section ""data" . GHC.Real.$fIntegralWord_$cquot_closure" {
     GHC.Real.$fIntegralWord_$cquot_closure:
         const GHC.Real.$fIntegralWord_$cquot_info;
         const 0;
 },
 GHC.Real.$fIntegralWord_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c1tvd,
                       label: GHC.Real.$fIntegralWord_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tvd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tvh; else goto c1tvi;
       c1tvh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tvi: // global
           I64[Sp - 16] = block_c1tva_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1tvB; else goto c1tvb;
       u1tvB: // global
           call _c1tva(R1) args: 0, res: 0, upd: 0;
       c1tvb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tva() //  [R1]
         { info_tbl: [(c1tva,
                       label: block_c1tva_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tva: // global
           I64[Sp] = block_c1tvg_info;
           _s1sje::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1sje::I64;
           if (R1 & 7 != 0) goto u1tvA; else goto c1tvk;
       u1tvA: // global
           call _c1tvg(R1) args: 0, res: 0, upd: 0;
       c1tvk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tvg() //  [R1]
         { info_tbl: [(c1tvg,
                       label: block_c1tvg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tvg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1tvq; else goto c1tvp;
       c1tvq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tvp: // global
           _s1sjh::I64 = I64[R1 + 7];
           if (_s1sjh::I64 != 0) goto c1tvy; else goto c1tvz;
       c1tvy: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] / _s1sjh::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tvz: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.608308657 UTC

[section ""data" . GHC.Real.$fIntegralWord_$crem_closure" {
     GHC.Real.$fIntegralWord_$crem_closure:
         const GHC.Real.$fIntegralWord_$crem_info;
         const 0;
 },
 GHC.Real.$fIntegralWord_$crem_entry() //  [R2, R3]
         { info_tbl: [(c1tw1,
                       label: GHC.Real.$fIntegralWord_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tw1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tw5; else goto c1tw6;
       c1tw5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tw6: // global
           I64[Sp - 16] = block_c1tvY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1twp; else goto c1tvZ;
       u1twp: // global
           call _c1tvY(R1) args: 0, res: 0, upd: 0;
       c1tvZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tvY() //  [R1]
         { info_tbl: [(c1tvY,
                       label: block_c1tvY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tvY: // global
           I64[Sp] = block_c1tw4_info;
           _s1sjm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1sjm::I64;
           if (R1 & 7 != 0) goto u1two; else goto c1tw8;
       u1two: // global
           call _c1tw4(R1) args: 0, res: 0, upd: 0;
       c1tw8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tw4() //  [R1]
         { info_tbl: [(c1tw4,
                       label: block_c1tw4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tw4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1twe; else goto c1twd;
       c1twe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1twd: // global
           _s1sjp::I64 = I64[R1 + 7];
           if (_s1sjp::I64 != 0) goto c1twm; else goto c1twn;
       c1twm: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] % _s1sjp::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1twn: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.616709839 UTC

[section ""data" . GHC.Real.$fIntegralWord_$cquotRem_closure" {
     GHC.Real.$fIntegralWord_$cquotRem_closure:
         const GHC.Real.$fIntegralWord_$cquotRem_info;
         const 0;
 },
 GHC.Real.$fIntegralWord_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c1twP,
                       label: GHC.Real.$fIntegralWord_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1twP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1twT; else goto c1twU;
       c1twT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1twU: // global
           I64[Sp - 16] = block_c1twM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1txc; else goto c1twN;
       u1txc: // global
           call _c1twM(R1) args: 0, res: 0, upd: 0;
       c1twN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1twM() //  [R1]
         { info_tbl: [(c1twM,
                       label: block_c1twM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1twM: // global
           I64[Sp] = block_c1twS_info;
           _s1sju::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1sju::I64;
           if (R1 & 7 != 0) goto u1txb; else goto c1twW;
       u1txb: // global
           call _c1twS(R1) args: 0, res: 0, upd: 0;
       c1twW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1twS() //  [R1]
         { info_tbl: [(c1twS,
                       label: block_c1twS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1twS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1tx2; else goto c1tx1;
       c1tx2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tx1: // global
           _s1sjx::I64 = I64[R1 + 7];
           if (_s1sjx::I64 != 0) goto c1tx9; else goto c1txa;
       c1tx9: // global
           (_s1sjz::I64, _s1sjA::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s1sjx::I64);
           I64[Hp - 48] = GHC.Types.W#_con_info;
           I64[Hp - 40] = _s1sjA::I64;
           I64[Hp - 32] = GHC.Types.W#_con_info;
           I64[Hp - 24] = _s1sjz::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1txa: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.626792957 UTC

[section ""data" . GHC.Real.$fIntegralWord_$cdivMod_closure" {
     GHC.Real.$fIntegralWord_$cdivMod_closure:
         const GHC.Real.$fIntegralWord_$cdivMod_info;
         const 0;
 },
 sat_s1sjN_entry() //  [R1]
         { info_tbl: [(c1txU,
                       label: sat_s1sjN_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1txU: // global
           _s1sjN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1txX; else goto c1txY;
       c1txY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1ty0; else goto c1txZ;
       c1ty0: // global
           HpAlloc = 16;
           goto c1txX;
       c1txX: // global
           R1 = _s1sjN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1txZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sjN::P64;
           _s1sjM::I64 = I64[_s1sjN::P64 + 16] % I64[_s1sjN::P64 + 24];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1sjM::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sjL_entry() //  [R1]
         { info_tbl: [(c1ty7,
                       label: sat_s1sjL_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ty7: // global
           _s1sjL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1tya; else goto c1tyb;
       c1tyb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1tyd; else goto c1tyc;
       c1tyd: // global
           HpAlloc = 16;
           goto c1tya;
       c1tya: // global
           R1 = _s1sjL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tyc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sjL::P64;
           _s1sjK::I64 = I64[_s1sjL::P64 + 16] / I64[_s1sjL::P64 + 24];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1sjK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fIntegralWord_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c1tye,
                       label: GHC.Real.$fIntegralWord_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tye: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tyf; else goto c1tyg;
       c1tyf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralWord_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tyg: // global
           I64[Sp - 16] = block_c1txC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1tyq; else goto c1txD;
       u1tyq: // global
           call _c1txC(R1) args: 0, res: 0, upd: 0;
       c1txD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1txC() //  [R1]
         { info_tbl: [(c1txC,
                       label: block_c1txC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1txC: // global
           I64[Sp] = block_c1txH_info;
           _s1sjG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1sjG::I64;
           if (R1 & 7 != 0) goto u1typ; else goto c1txI;
       u1typ: // global
           call _c1txH(R1) args: 0, res: 0, upd: 0;
       c1txI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1txH() //  [R1]
         { info_tbl: [(c1txH,
                       label: block_c1txH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1txH: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1tyk; else goto c1tyj;
       c1tyk: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tyj: // global
           _s1sjJ::I64 = I64[R1 + 7];
           if (_s1sjJ::I64 != 0) goto c1tyn; else goto c1tyo;
       c1tyn: // global
           I64[Hp - 80] = sat_s1sjN_info;
           _s1sjG::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s1sjG::I64;
           I64[Hp - 56] = _s1sjJ::I64;
           I64[Hp - 48] = sat_s1sjL_info;
           I64[Hp - 32] = _s1sjG::I64;
           I64[Hp - 24] = _s1sjJ::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tyo: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.640359681 UTC

[section ""data" . GHC.Real.ratioZeroDenominatorError_closure" {
     GHC.Real.ratioZeroDenominatorError_closure:
         const GHC.Real.ratioZeroDenominatorError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.ratioZeroDenominatorError_entry() //  [R1]
         { info_tbl: [(c1tz6,
                       label: GHC.Real.ratioZeroDenominatorError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tz6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tz7; else goto c1tz8;
       c1tz7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tz8: // global
           (_c1tz3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1tz3::I64 == 0) goto c1tz5; else goto c1tz4;
       c1tz5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1tz4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1tz3::I64;
           R1 = GHC.Exception.ratioZeroDenomException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.645026327 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$crecip_closure" {
     GHC.Real.$fFractionalRatio_$s$crecip_closure:
         const GHC.Real.$fFractionalRatio_$s$crecip_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$crecip_entry() //  [R2]
         { info_tbl: [(c1tzo,
                       label: GHC.Real.$fFractionalRatio_$s$crecip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tzo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tzp; else goto c1tzq;
       c1tzp: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$crecip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1tzq: // global
           I64[Sp - 8] = block_c1tzl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1tA6; else goto c1tzm;
       u1tA6: // global
           call _c1tzl(R1) args: 0, res: 0, upd: 0;
       c1tzm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tzl() //  [R1]
         { info_tbl: [(c1tzl,
                       label: block_c1tzl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tzl: // global
           I64[Sp - 16] = block_c1tzt_info;
           R3 = GHC.Real.even1_closure;
           _s1sjQ::P64 = P64[R1 + 7];
           R2 = _s1sjQ::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _s1sjQ::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tzt() //  [R1]
         { info_tbl: [(c1tzt,
                       label: block_c1tzt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tzt: // global
           if (R1 == 1) goto c1tA5; else goto c1tzB;
       c1tA5: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tzB: // global
           I64[Sp] = block_c1tzy_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tzy() //  [R1]
         { info_tbl: [(c1tzy,
                       label: block_c1tzy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tzy: // global
           _s1sjR::P64 = P64[Sp + 8];
           if (R1 == 1) goto c1tzX; else goto c1tzH;
       c1tzX: // global
           I64[Sp + 8] = block_c1tzN_info;
           R2 = _s1sjR::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       c1tzH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tzK; else goto c1tzJ;
       c1tzK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1tzJ: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = _s1sjR::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1tzN() //  [R1]
         { info_tbl: [(c1tzN,
                       label: block_c1tzN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tzN: // global
           I64[Sp] = block_c1tzR_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tzR() //  [R1]
         { info_tbl: [(c1tzR,
                       label: block_c1tzR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tzR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tA1; else goto c1tA0;
       c1tA1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tA0: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.658496886 UTC

[section ""data" . GHC.Real.overflowError_closure" {
     GHC.Real.overflowError_closure:
         const GHC.Real.overflowError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.overflowError_entry() //  [R1]
         { info_tbl: [(c1tAK,
                       label: GHC.Real.overflowError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tAK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tAL; else goto c1tAM;
       c1tAL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tAM: // global
           (_c1tAH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1tAH::I64 == 0) goto c1tAJ; else goto c1tAI;
       c1tAJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1tAI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1tAH::I64;
           R1 = GHC.Exception.overflowException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.662679113 UTC

[section ""data" . lvl_r1j38_closure" {
     lvl_r1j38_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Real.$fIntegralInt1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.665964751 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cdivMod_closure" {
     GHC.Real.$fIntegralInt_$cdivMod_closure:
         const GHC.Real.$fIntegralInt_$cdivMod_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c1tB3,
                       label: GHC.Real.$fIntegralInt_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tB3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tB7; else goto c1tB8;
       c1tB7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tB8: // global
           I64[Sp - 16] = block_c1tB0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1tDv; else goto c1tB1;
       u1tDv: // global
           call _c1tB0(R1) args: 0, res: 0, upd: 0;
       c1tB1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tB0() //  [R1]
         { info_tbl: [(c1tB0,
                       label: block_c1tB0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tB0: // global
           I64[Sp] = block_c1tB6_info;
           _s1sk0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1sk0::I64;
           if (R1 & 7 != 0) goto u1tDu; else goto c1tBa;
       u1tDu: // global
           call _c1tB6(R1) args: 0, res: 0, upd: 0;
       c1tBa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tB6() //  [R1]
         { info_tbl: [(c1tB6,
                       label: block_c1tB6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tB6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1tBg; else goto c1tBf;
       c1tBg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tBf: // global
           _s1sk0::I64 = I64[Sp + 8];
           _s1sk3::I64 = I64[R1 + 7];
           if (_s1sk3::I64 != (-1)) goto u1tDt; else goto c1tDr;
       u1tDt: // global
           if (_s1sk3::I64 != 0) goto c1tCV; else goto c1tDs;
       c1tCV: // global
           if (%MO_S_Le_W64(_s1sk0::I64, 0)) goto c1tBW; else goto c1tCT;
       c1tBW: // global
           if (%MO_S_Ge_W64(_s1sk0::I64, 0)) goto c1tBt; else goto c1tBU;
       c1tBt: // global
           (_s1sk7::I64, _s1sk8::I64) = call MO_S_QuotRem W64(_s1sk0::I64, _s1sk3::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1sk8::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1sk7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tBU: // global
           if (%MO_S_Le_W64(_s1sk3::I64, 0)) goto c1tBC; else goto c1tBT;
       c1tBC: // global
           (_s1skd::I64, _s1ske::I64) = call MO_S_QuotRem W64(_s1sk0::I64, _s1sk3::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1ske::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1skd::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tBT: // global
           (_s1skj::I64, _s1skk::I64) = call MO_S_QuotRem W64(_s1sk0::I64 + 1, _s1sk3::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1skk::I64 + _s1sk3::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1skj::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tCT: // global
           if (%MO_S_Ge_W64(_s1sk3::I64, 0)) goto c1tCB; else goto c1tCS;
       c1tCB: // global
           if (%MO_S_Ge_W64(_s1sk0::I64, 0)) goto c1tC8; else goto c1tCz;
       c1tC8: // global
           (_s1skt::I64, _s1sku::I64) = call MO_S_QuotRem W64(_s1sk0::I64, _s1sk3::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1sku::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1skt::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tCz: // global
           if (%MO_S_Le_W64(_s1sk3::I64, 0)) goto c1tCh; else goto c1tCy;
       c1tCh: // global
           (_s1skz::I64, _s1skA::I64) = call MO_S_QuotRem W64(_s1sk0::I64, _s1sk3::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1skA::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1skz::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tCy: // global
           (_s1skF::I64, _s1skG::I64) = call MO_S_QuotRem W64(_s1sk0::I64 + 1, _s1sk3::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1skG::I64 + _s1sk3::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1skF::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tCS: // global
           (_s1skO::I64, _s1skP::I64) = call MO_S_QuotRem W64(_s1sk0::I64 - 1, _s1sk3::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1skP::I64 + _s1sk3::I64 + 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1skO::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tDs: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tDr: // global
           if (_s1sk0::I64 == (-9223372036854775808)) goto c1tDq; else goto c1tDp;
       c1tDq: // global
           Hp = Hp - 56;
           R1 = lvl_r1j38_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tDp: // global
           if (%MO_S_Le_W64(_s1sk0::I64, 0)) goto c1tD6; else goto c1tDn;
       c1tD6: // global
           (_s1skY::I64, _s1skZ::I64) = call MO_S_QuotRem W64(_s1sk0::I64, (-1));
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1skZ::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1skY::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tDn: // global
           (_s1sl4::I64, _s1sl5::I64) = call MO_S_QuotRem W64(_s1sk0::I64 - 1, (-1));
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1sl5::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1sl4::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.680763697 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cquotRem_closure" {
     GHC.Real.$fIntegralInt_$cquotRem_closure:
         const GHC.Real.$fIntegralInt_$cquotRem_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c1tF1,
                       label: GHC.Real.$fIntegralInt_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tF1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tF5; else goto c1tF6;
       c1tF5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tF6: // global
           I64[Sp - 16] = block_c1tEY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1tFz; else goto c1tEZ;
       u1tFz: // global
           call _c1tEY(R1) args: 0, res: 0, upd: 0;
       c1tEZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tEY() //  [R1]
         { info_tbl: [(c1tEY,
                       label: block_c1tEY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tEY: // global
           I64[Sp] = block_c1tF4_info;
           _s1slf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1slf::I64;
           if (R1 & 7 != 0) goto u1tFy; else goto c1tF8;
       u1tFy: // global
           call _c1tF4(R1) args: 0, res: 0, upd: 0;
       c1tF8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tF4() //  [R1]
         { info_tbl: [(c1tF4,
                       label: block_c1tF4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tF4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1tFe; else goto c1tFd;
       c1tFe: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tFd: // global
           _s1slf::I64 = I64[Sp + 8];
           _s1sli::I64 = I64[R1 + 7];
           if (_s1sli::I64 != (-1)) goto u1tFx; else goto c1tFv;
       u1tFx: // global
           if (_s1sli::I64 != 0) goto c1tFl; else goto c1tFw;
       c1tFl: // global
           (_s1slk::I64, _s1sll::I64) = call MO_S_QuotRem W64(_s1slf::I64, _s1sli::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1sll::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1slk::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tFw: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tFv: // global
           if (_s1slf::I64 == (-9223372036854775808)) goto c1tFu; else goto c1tFt;
       c1tFu: // global
           Hp = Hp - 56;
           R1 = lvl_r1j38_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tFt: // global
           (_s1slq::I64, _s1slr::I64) = call MO_S_QuotRem W64(_s1slf::I64, (-1));
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s1slr::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s1slq::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.690065294 UTC

[section ""data" . GHC.Real.$w$cdiv_closure" {
     GHC.Real.$w$cdiv_closure:
         const GHC.Real.$w$cdiv_info;
         const 0;
 },
 GHC.Real.$w$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c1tGd,
                       label: GHC.Real.$w$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tGd: // global
           if (R3 == (-1)) goto c1tGb; else goto u1tGm;
       c1tGb: // global
           if (R2 == (-9223372036854775808)) goto c1tGl; else goto c1tGk;
       c1tGl: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tGk: // global
           R3 = (-1);
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
       u1tGm: // global
           if (R3 == 0) goto c1tGc; else goto c1tGa;
       c1tGc: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tGa: // global
           R3 = R3;
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.694745948 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cdiv_closure" {
     GHC.Real.$fIntegralInt_$cdiv_closure:
         const GHC.Real.$fIntegralInt_$cdiv_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c1tGz,
                       label: GHC.Real.$fIntegralInt_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tGz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tGM; else goto c1tGN;
       c1tGM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tGN: // global
           I64[Sp - 16] = block_c1tGw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1tGU; else goto c1tGx;
       u1tGU: // global
           call _c1tGw(R1) args: 0, res: 0, upd: 0;
       c1tGx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tGw() //  [R1]
         { info_tbl: [(c1tGw,
                       label: block_c1tGw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tGw: // global
           I64[Sp] = block_c1tGC_info;
           _s1slE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1slE::I64;
           if (R1 & 7 != 0) goto u1tGT; else goto c1tGD;
       u1tGT: // global
           call _c1tGC(R1) args: 0, res: 0, upd: 0;
       c1tGD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tGC() //  [R1]
         { info_tbl: [(c1tGC,
                       label: block_c1tGC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tGC: // global
           _s1slE::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1tGH_info;
           R3 = I64[R1 + 7];
           R2 = _s1slE::I64;
           Sp = Sp + 8;
           call GHC.Real.$w$cdiv_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tGH() //  [R1]
         { info_tbl: [(c1tGH,
                       label: block_c1tGH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tGH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1tGS; else goto c1tGR;
       c1tGS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1tGR: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.705012378 UTC

[section ""data" . GHC.Real.$fIntegralInt_$cquot_closure" {
     GHC.Real.$fIntegralInt_$cquot_closure:
         const GHC.Real.$fIntegralInt_$cquot_info;
         const 0;
 },
 GHC.Real.$fIntegralInt_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c1tHn,
                       label: GHC.Real.$fIntegralInt_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tHn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tHr; else goto c1tHs;
       c1tHr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fIntegralInt_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tHs: // global
           I64[Sp - 16] = block_c1tHk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1tHX; else goto c1tHl;
       u1tHX: // global
           call _c1tHk(R1) args: 0, res: 0, upd: 0;
       c1tHl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tHk() //  [R1]
         { info_tbl: [(c1tHk,
                       label: block_c1tHk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tHk: // global
           I64[Sp] = block_c1tHq_info;
           _s1slL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1slL::I64;
           if (R1 & 7 != 0) goto u1tHW; else goto c1tHu;
       u1tHW: // global
           call _c1tHq(R1) args: 0, res: 0, upd: 0;
       c1tHu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tHq() //  [R1]
         { info_tbl: [(c1tHq,
                       label: block_c1tHq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tHq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1tHA; else goto c1tHz;
       c1tHA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tHz: // global
           _s1slL::I64 = I64[Sp + 8];
           _s1slO::I64 = I64[R1 + 7];
           if (_s1slO::I64 != (-1)) goto u1tHV; else goto c1tHT;
       u1tHV: // global
           if (_s1slO::I64 != 0) goto c1tHI; else goto c1tHU;
       c1tHI: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s1slL::I64, _s1slO::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1tHU: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tHT: // global
           if (_s1slL::I64 == (-9223372036854775808)) goto c1tHS; else goto c1tHR;
       c1tHS: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tHR: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s1slL::I64, (-1));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.713518658 UTC

[section ""data" . GHC.Real.$fIntegralInt_closure" {
     GHC.Real.$fIntegralInt_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Real.$fRealInt_closure+1;
         const GHC.Enum.$fEnumInt_closure;
         const GHC.Real.$fIntegralInt_$cquot_closure+2;
         const GHC.Real.$fIntegralInt_$crem_closure+2;
         const GHC.Real.$fIntegralInt_$cdiv_closure+2;
         const GHC.Real.$fIntegralInt_$cmod_closure+2;
         const GHC.Real.$fIntegralInt_$cquotRem_closure+2;
         const GHC.Real.$fIntegralInt_$cdivMod_closure+2;
         const GHC.Real.$fIntegralInt_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.715432705 UTC

[section ""data" . lvl1_r1j39_closure" {
     lvl1_r1j39_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.717968156 UTC

[section ""data" . lvl2_r1j3a_closure" {
     lvl2_r1j3a_closure:
         const lvl2_r1j3a_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r1j3a_entry() //  [R1]
         { info_tbl: [(c1tII,
                       label: lvl2_r1j3a_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tII: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tIJ; else goto c1tIK;
       c1tIJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tIK: // global
           (_c1tIF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1tIF::I64 == 0) goto c1tIH; else goto c1tIG;
       c1tIH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1tIG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1tIF::I64;
           R3 = 0;
           R2 = lvl1_r1j39_closure+1;
           Sp = Sp - 16;
           call GHC.Real.$wgcd'_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""data" . GHC.Real.$wgcd'_closure" {
     GHC.Real.$wgcd'_closure:
         const GHC.Real.$wgcd'_info;
         const 0;
 },
 GHC.Real.$wgcd'_entry() //  [R2, R3]
         { info_tbl: [(c1tIP,
                       label: GHC.Real.$wgcd'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tIP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tIQ; else goto u1tIW;
       c1tIQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wgcd'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1tIW: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1tIp() args: 0, res: 0, upd: 0;
     }
 },
 _c1tIp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tIp: // global
           _s1slW::I64 = I64[Sp + 8];
           if (_s1slW::I64 != (-1)) goto u1tIV; else goto c1tIN;
       u1tIV: // global
           _s1slU::P64 = P64[Sp];
           if (_s1slW::I64 != 0) goto c1tIM; else goto c1tIO;
       c1tIM: // global
           I64[Sp] = block_c1tIu_info;
           R1 = _s1slU::P64;
           I64[Sp + 8] = _s1slW::I64;
           if (R1 & 7 != 0) goto u1tIY; else goto c1tIv;
       u1tIY: // global
           call _c1tIu(R1) args: 0, res: 0, upd: 0;
       c1tIv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1tIO: // global
           R1 = _s1slU::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1tIN: // global
           R1 = lvl2_r1j3a_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1tIu() //  [R1]
         { info_tbl: [(c1tIu,
                       label: block_c1tIu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tIu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1tIU; else goto c1tIT;
       c1tIU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tIT: // global
           _s1slW::I64 = I64[Sp + 8];
           _s1slZ::I64 = %MO_S_Rem_W64(I64[R1 + 7], _s1slW::I64);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1slW::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s1slZ::I64;
           call _c1tIp() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.728691175 UTC

[section ""data" . GHC.Real.$fEnumRatio_gcd'_closure" {
     GHC.Real.$fEnumRatio_gcd'_closure:
         const GHC.Real.$fEnumRatio_gcd'_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_gcd'_entry() //  [R2, R3]
         { info_tbl: [(c1tJz,
                       label: GHC.Real.$fEnumRatio_gcd'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tJz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tJA; else goto u1tJN;
       c1tJA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_gcd'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1tJN: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1tJr() args: 0, res: 0, upd: 0;
     }
 },
 _c1tJr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tJr: // global
           I64[Sp - 8] = block_c1tJu_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tJu() //  [R1]
         { info_tbl: [(c1tJu,
                       label: block_c1tJu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tJu: // global
           _s1sm1::P64 = P64[Sp + 8];
           if (R1 == 1) goto c1tJy; else goto c1tJx;
       c1tJy: // global
           R1 = _s1sm1::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1tJx: // global
           I64[Sp + 8] = block_c1tJE_info;
           R3 = P64[Sp + 16];
           R2 = _s1sm1::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tJE() //  [R1]
         { info_tbl: [(c1tJE,
                       label: block_c1tJE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tJE: // global
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call _c1tJr() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.738945316 UTC

[section ""data" . GHC.Real.gcd_closure" {
     GHC.Real.gcd_closure:
         const GHC.Real.gcd_info;
         const 0;
 },
 lvl8_s1sm9_entry() //  [R1]
         { info_tbl: [(c1tKL,
                       label: lvl8_s1sm9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tKL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tKM; else goto c1tKN;
       c1tKM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tKN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1tKJ_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1tKJ() //  [R1]
         { info_tbl: [(c1tKJ,
                       label: block_c1tKJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tKJ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dNum_s1smd_entry() //  [R1]
         { info_tbl: [(c1tKT,
                       label: $dNum_s1smd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tKT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1tKU; else goto c1tKV;
       c1tKU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tKV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1smk_entry() //  [R1]
         { info_tbl: [(c1tKY,
                       label: sat_s1smk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tKY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tKZ; else goto c1tL0;
       c1tKZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tL0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1smj_entry() //  [R1]
         { info_tbl: [(c1tL3,
                       label: sat_s1smj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tL3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tL4; else goto c1tL5;
       c1tL4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tL5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1smi_entry() //  [R1]
         { info_tbl: [(c1tL9,
                       label: sat_s1smi_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tL9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1tLa; else goto c1tLb;
       c1tLa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tLb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.rem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.gcd_entry() //  [R2, R3, R4]
         { info_tbl: [(c1tLc,
                       label: GHC.Real.gcd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tLc: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1tLd; else goto c1tLe;
       c1tLd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.gcd_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tLe: // global
           I64[Sp - 32] = block_c1tKd_info;
           _s1sm5::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1sm5::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tKd() //  [R1]
         { info_tbl: [(c1tKd,
                       label: block_c1tKd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tKd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tLh; else goto c1tLg;
       c1tLh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tLg: // global
           I64[Hp - 16] = lvl8_s1sm9_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c1tKj_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tKj() //  [R1]
         { info_tbl: [(c1tKj,
                       label: block_c1tKj_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tKj: // global
           I64[Sp] = block_c1tKn_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tKn() //  [R1]
         { info_tbl: [(c1tKn,
                       label: block_c1tKn_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tKn: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1tLl; else goto c1tLk;
       c1tLl: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tLk: // global
           I64[Hp - 80] = $dNum_s1smd_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s1smk_info;
           P64[Hp - 40] = P64[Sp + 40];
           _c1tKr::P64 = Hp - 80;
           P64[Hp - 32] = _c1tKr::P64;
           I64[Hp - 24] = sat_s1smj_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _c1tKr::P64;
           P64[Sp + 8] = Hp - 56;
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _c1tKA() args: 0, res: 0, upd: 0;
     }
 },
 _c1tKA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tKA: // global
           I64[Sp - 8] = block_c1tKC_info;
           R2 = P64[Sp + 32];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp];
           P64[Sp - 16] = P64[Sp + 8];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1tKC() //  [R1]
         { info_tbl: [(c1tKC,
                       label: block_c1tKC_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tKC: // global
           _s1smf::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c1tLo; else goto c1tLv;
       c1tLo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1tLr; else goto c1tLq;
       c1tLr: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1tLq: // global
           I64[Hp - 32] = sat_s1smi_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _s1smf::P64;
           _s1smg::P64 = P64[Sp + 8];
           P64[Hp] = _s1smg::P64;
           _s1smf::P64 = _s1smg::P64;
           P64[Sp + 32] = _s1smf::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _c1tKA() args: 0, res: 0, upd: 0;
       c1tLv: // global
           R1 = _s1smf::P64;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.763800026 UTC

[section ""data" . GHC.Real.$w$sreduce_closure" {
     GHC.Real.$w$sreduce_closure:
         const GHC.Real.$w$sreduce_info;
         const 0;
 },
 section ""relreadonly" . u1tNK_srtd" {
     u1tNK_srtd:
         const S1sVz_srt+160;
         const 33;
         const 5905711105;
 },
 GHC.Real.$w$sreduce_entry() //  [R2, R3]
         { info_tbl: [(c1tN1,
                       label: GHC.Real.$w$sreduce_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tN1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tN2; else goto c1tN3;
       c1tN2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$sreduce_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tN3: // global
           I64[Sp - 24] = block_c1tMW_info;
           _s1smm::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1sml::P64 = R2;
           R2 = _s1smm::P64;
           P64[Sp - 16] = _s1sml::P64;
           P64[Sp - 8] = _s1smm::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tMW() //  [R1]
         { info_tbl: [(c1tMW,
                       label: block_c1tMW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tMW: // global
           if (R1 == 1) goto c1tN0; else goto c1tMZ;
       c1tN0: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tMZ: // global
           I64[Sp] = block_c1tN6_info;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tN6() //  [R1]
         { info_tbl: [(c1tN6,
                       label: block_c1tN6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tN6: // global
           I64[Sp - 8] = block_c1tNa_info;
           R2 = P64[Sp + 8];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tNa() //  [R1]
         { info_tbl: [(c1tNa,
                       label: block_c1tNa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tNa: // global
           _s1smq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1tNe_info;
           R3 = _s1smq::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$fEnumRatio_gcd'_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tNe() //  [R1]
         { info_tbl: [(c1tNe,
                       label: block_c1tNe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tNe: // global
           I64[Sp - 8] = block_c1tNl_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tNl() //  [R1]
         { info_tbl: [(c1tNl,
                       label: block_c1tNl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tNl: // global
           if (R1 == 1) goto c1tNG; else goto c1tNx;
       c1tNG: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1tNx: // global
           I64[Sp] = block_c1tNq_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tNq() //  [R1]
         { info_tbl: [(c1tNq,
                       label: block_c1tNq_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tNq: // global
           I64[Sp + 16] = block_c1tNu_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tNu() //  [R1]
         { info_tbl: [(c1tNu,
                       label: block_c1tNu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tNu: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.782088573 UTC

[section ""data" . GHC.Real.reduce_$sreduce_closure" {
     GHC.Real.reduce_$sreduce_closure:
         const GHC.Real.reduce_$sreduce_info;
         const 0;
 },
 GHC.Real.reduce_$sreduce_entry() //  [R2, R3]
         { info_tbl: [(c1tOr,
                       label: GHC.Real.reduce_$sreduce_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tOr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1tOs; else goto c1tOt;
       c1tOs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.reduce_$sreduce_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tOt: // global
           I64[Sp - 8] = block_c1tOo_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tOo() //  [R1, R2]
         { info_tbl: [(c1tOo,
                       label: block_c1tOo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tOo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tOw; else goto c1tOv;
       c1tOw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1tOv: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.788149765 UTC

[section ""data" . GHC.Real.$fRealWord_$ctoRational_closure" {
     GHC.Real.$fRealWord_$ctoRational_closure:
         const GHC.Real.$fRealWord_$ctoRational_info;
         const 0;
 },
 section ""relreadonly" . u1tPc_srtd" {
     u1tPc_srtd:
         const S1sVz_srt;
         const 56;
         const 40532396646335489;
 },
 GHC.Real.$fRealWord_$ctoRational_entry() //  [R2]
         { info_tbl: [(c1tOP,
                       label: GHC.Real.$fRealWord_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tOP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1tP3; else goto c1tP4;
       c1tP3: // global
           R2 = R2;
           R1 = GHC.Real.$fRealWord_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1tP4: // global
           I64[Sp - 8] = block_c1tOM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1tPb; else goto c1tON;
       u1tPb: // global
           call _c1tOM(R1) args: 0, res: 0, upd: 0;
       c1tON: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tPd_srtd" {
     u1tPd_srtd:
         const S1sVz_srt;
         const 53;
         const 4503599627371521;
 },
 _c1tOM() //  [R1]
         { info_tbl: [(c1tOM,
                       label: block_c1tOM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tOM: // global
           I64[Sp] = block_c1tOS_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tPe_srtd" {
     u1tPe_srtd:
         const S1sVz_srt;
         const 53;
         const 4503599627371521;
 },
 _c1tOS() //  [R1]
         { info_tbl: [(c1tOS,
                       label: block_c1tOS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tOS: // global
           I64[Sp] = block_c1tOW_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tPf_srtd" {
     u1tPf_srtd:
         const S1sVz_srt+80;
         const 43;
         const 4398046511105;
 },
 _c1tOW() //  [R1]
         { info_tbl: [(c1tOW,
                       label: block_c1tOW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tOW: // global
           I64[Sp] = block_c1tP0_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tP0() //  [R1, R2]
         { info_tbl: [(c1tP0,
                       label: block_c1tP0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tP0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tPa; else goto c1tP9;
       c1tPa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1tP9: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.801801897 UTC

[section ""data" . GHC.Real.$fRealWord_closure" {
     GHC.Real.$fRealWord_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Num.$fNumWord_closure;
         const GHC.Classes.$fOrdWord_closure;
         const GHC.Real.$fRealWord_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.803491352 UTC

[section ""data" . GHC.Real.$fIntegralWord_closure" {
     GHC.Real.$fIntegralWord_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Real.$fRealWord_closure+1;
         const GHC.Enum.$fEnumWord_closure;
         const GHC.Real.$fIntegralWord_$cquot_closure+2;
         const GHC.Real.$fIntegralWord_$crem_closure+2;
         const GHC.Real.$fIntegralWord_$cquot_closure+2;
         const GHC.Real.$fIntegralWord_$crem_closure+2;
         const GHC.Real.$fIntegralWord_$cquotRem_closure+2;
         const GHC.Real.$fIntegralWord_$cdivMod_closure+2;
         const GHC.Real.$fIntegralWord_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.806002387 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$c*_closure" {
     GHC.Real.$fFractionalRatio_$s$c*_closure:
         const GHC.Real.$fFractionalRatio_$s$c*_info;
         const 0;
 },
 section ""relreadonly" . u1tQl_srtd" {
     u1tQl_srtd:
         const S1sVz_srt;
         const 57;
         const 76561193665298433;
 },
 GHC.Real.$fFractionalRatio_$s$c*_entry() //  [R2, R3]
         { info_tbl: [(c1tPR,
                       label: GHC.Real.$fFractionalRatio_$s$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tPR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tQa; else goto c1tQb;
       c1tQa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tQb: // global
           I64[Sp - 16] = block_c1tPO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1tQk; else goto c1tPP;
       u1tQk: // global
           call _c1tPO(R1) args: 0, res: 0, upd: 0;
       c1tPP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tQm_srtd" {
     u1tQm_srtd:
         const S1sVz_srt;
         const 53;
         const 4503599627370497;
 },
 _c1tPO() //  [R1]
         { info_tbl: [(c1tPO,
                       label: block_c1tPO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tPO: // global
           I64[Sp - 8] = block_c1tPU_info;
           _s1smM::P64 = P64[R1 + 7];
           _s1smN::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1smN::P64;
           P64[Sp + 8] = _s1smM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1tQj; else goto c1tPV;
       u1tQj: // global
           call _c1tPU(R1) args: 0, res: 0, upd: 0;
       c1tPV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tQn_srtd" {
     u1tQn_srtd:
         const S1sVz_srt;
         const 53;
         const 4503599627370497;
 },
 _c1tPU() //  [R1]
         { info_tbl: [(c1tPU,
                       label: block_c1tPU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tPU: // global
           I64[Sp] = block_c1tPZ_info;
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tQo_srtd" {
     u1tQo_srtd:
         const S1sVz_srt;
         const 53;
         const 4503599627370497;
 },
 _c1tPZ() //  [R1]
         { info_tbl: [(c1tPZ,
                       label: block_c1tPZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tPZ: // global
           _s1smP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1tQ3_info;
           R3 = _s1smP::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tQ3() //  [R1]
         { info_tbl: [(c1tQ3,
                       label: block_c1tQ3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tQ3: // global
           _s1smS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1tQ7_info;
           R3 = _s1smS::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tQ7() //  [R1, R2]
         { info_tbl: [(c1tQ7,
                       label: block_c1tQ7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tQ7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tQi; else goto c1tQh;
       c1tQi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1tQh: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.822135143 UTC

[section ""data" . GHC.Real.$w$s$c-_closure" {
     GHC.Real.$w$s$c-_closure:
         const GHC.Real.$w$s$c-_info;
         const 0;
 },
 section ""relreadonly" . u1tRo_srtd" {
     u1tRo_srtd:
         const S1sVz_srt;
         const 59;
         const 436849163854938113;
 },
 GHC.Real.$w$s$c-_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1tR3,
                       label: GHC.Real.$w$s$c-_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tR3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1tRf; else goto c1tRg;
       c1tRf: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$c-_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tRg: // global
           I64[Sp - 40] = block_c1tR1_info;
           _s1smX::P64 = R3;
           R3 = R5;
           _s1smW::P64 = R2;
           R2 = _s1smX::P64;
           P64[Sp - 32] = _s1smW::P64;
           P64[Sp - 24] = _s1smX::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tRp_srtd" {
     u1tRp_srtd:
         const S1sVz_srt;
         const 58;
         const 148618787703226369;
 },
 _c1tR1() //  [R1]
         { info_tbl: [(c1tR1,
                       label: block_c1tR1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tR1: // global
           I64[Sp] = block_c1tR6_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tRq_srtd" {
     u1tRq_srtd:
         const S1sVz_srt;
         const 58;
         const 148618787703226369;
 },
 _c1tR6() //  [R1]
         { info_tbl: [(c1tR6,
                       label: block_c1tR6_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tR6: // global
           I64[Sp + 16] = block_c1tRa_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tRa() //  [R1]
         { info_tbl: [(c1tRa,
                       label: block_c1tRa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tRa: // global
           I64[Sp] = block_c1tRe_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tRe() //  [R1]
         { info_tbl: [(c1tRe,
                       label: block_c1tRe_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tRe: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.835658468 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c-_closure" {
     GHC.Real.$fEnumRatio_$s$c-_closure:
         const GHC.Real.$fEnumRatio_$s$c-_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c-_entry() //  [R2, R3]
         { info_tbl: [(c1tRW,
                       label: GHC.Real.$fEnumRatio_$s$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tRW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tS7; else goto c1tS8;
       c1tS7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tS8: // global
           I64[Sp - 16] = block_c1tRT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1tSf; else goto c1tRU;
       u1tSf: // global
           call _c1tRT(R1) args: 0, res: 0, upd: 0;
       c1tRU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tRT() //  [R1]
         { info_tbl: [(c1tRT,
                       label: block_c1tRT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tRT: // global
           I64[Sp - 8] = block_c1tRZ_info;
           _s1sn7::P64 = P64[R1 + 7];
           _s1sn8::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1sn8::P64;
           P64[Sp + 8] = _s1sn7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1tSe; else goto c1tS0;
       u1tSe: // global
           call _c1tRZ(R1) args: 0, res: 0, upd: 0;
       c1tS0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tRZ() //  [R1]
         { info_tbl: [(c1tRZ,
                       label: block_c1tRZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tRZ: // global
           _s1sn7::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1tS4_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1sn7::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tS4() //  [R1, R2]
         { info_tbl: [(c1tS4,
                       label: block_c1tS4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tS4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tSd; else goto c1tSc;
       c1tSd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1tSc: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.845227436 UTC

[section ""data" . GHC.Real.$w$s$c+_closure" {
     GHC.Real.$w$s$c+_closure:
         const GHC.Real.$w$s$c+_info;
         const 0;
 },
 section ""relreadonly" . u1tT2_srtd" {
     u1tT2_srtd:
         const S1sVz_srt;
         const 62;
         const 3463268113447911425;
 },
 GHC.Real.$w$s$c+_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1tSH,
                       label: GHC.Real.$w$s$c+_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tSH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1tST; else goto c1tSU;
       c1tST: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$c+_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tSU: // global
           I64[Sp - 40] = block_c1tSF_info;
           _s1sng::P64 = R3;
           R3 = R5;
           _s1snf::P64 = R2;
           R2 = _s1sng::P64;
           P64[Sp - 32] = _s1snf::P64;
           P64[Sp - 24] = _s1sng::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tT3_srtd" {
     u1tT3_srtd:
         const S1sVz_srt;
         const 61;
         const 1157425104234217473;
 },
 _c1tSF() //  [R1]
         { info_tbl: [(c1tSF,
                       label: block_c1tSF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tSF: // global
           I64[Sp] = block_c1tSK_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tT4_srtd" {
     u1tT4_srtd:
         const S1sVz_srt;
         const 61;
         const 1157425104234217473;
 },
 _c1tSK() //  [R1]
         { info_tbl: [(c1tSK,
                       label: block_c1tSK_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tSK: // global
           I64[Sp + 16] = block_c1tSO_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tSO() //  [R1]
         { info_tbl: [(c1tSO,
                       label: block_c1tSO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tSO: // global
           I64[Sp] = block_c1tSS_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tSS() //  [R1]
         { info_tbl: [(c1tSS,
                       label: block_c1tSS_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tSS: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.858869037 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$c+_closure" {
     GHC.Real.$fEnumRatio_$s$c+_closure:
         const GHC.Real.$fEnumRatio_$s$c+_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$c+_entry() //  [R2, R3]
         { info_tbl: [(c1tTA,
                       label: GHC.Real.$fEnumRatio_$s$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tTA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tTL; else goto c1tTM;
       c1tTL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tTM: // global
           I64[Sp - 16] = block_c1tTx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1tTT; else goto c1tTy;
       u1tTT: // global
           call _c1tTx(R1) args: 0, res: 0, upd: 0;
       c1tTy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tTx() //  [R1]
         { info_tbl: [(c1tTx,
                       label: block_c1tTx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tTx: // global
           I64[Sp - 8] = block_c1tTD_info;
           _s1snq::P64 = P64[R1 + 7];
           _s1snr::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1snr::P64;
           P64[Sp + 8] = _s1snq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1tTS; else goto c1tTE;
       u1tTS: // global
           call _c1tTD(R1) args: 0, res: 0, upd: 0;
       c1tTE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tTD() //  [R1]
         { info_tbl: [(c1tTD,
                       label: block_c1tTD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tTD: // global
           _s1snq::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1tTI_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1snq::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tTI() //  [R1, R2]
         { info_tbl: [(c1tTI,
                       label: block_c1tTI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tTI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tTR; else goto c1tTQ;
       c1tTR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1tTQ: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.868608809 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$fNumRatio_closure" {
     GHC.Real.$fFractionalRatio_$s$fNumRatio_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Real.$fEnumRatio_$s$c+_closure+2;
         const GHC.Real.$fEnumRatio_$s$c-_closure+2;
         const GHC.Real.$fFractionalRatio_$s$c*_closure+2;
         const GHC.Real.$fFractionalRatio_$s$cnegate_closure+1;
         const GHC.Real.$fFractionalRatio_$s$cabs_closure+1;
         const GHC.Real.$fFractionalRatio_$s$csignum_closure+1;
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.870876582 UTC

[section ""data" . GHC.Real.$w$s$cfromRational_closure" {
     GHC.Real.$w$s$cfromRational_closure:
         const GHC.Real.$w$s$cfromRational_info;
         const 0;
 },
 section ""relreadonly" . u1tUC_srtd" {
     u1tUC_srtd:
         const S1sVz_srt;
         const 64;
         const 9227875636482146305;
 },
 GHC.Real.$w$s$cfromRational_entry() //  [R2, R3]
         { info_tbl: [(c1tUm,
                       label: GHC.Real.$w$s$cfromRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tUm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tUu; else goto c1tUv;
       c1tUu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cfromRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tUv: // global
           I64[Sp - 24] = block_c1tUk_info;
           _s1sny::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _s1sny::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tUD_srtd" {
     u1tUD_srtd:
         const S1sVz_srt;
         const 53;
         const 4503599627370497;
 },
 _c1tUk() //  [R1]
         { info_tbl: [(c1tUk,
                       label: block_c1tUk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tUk: // global
           I64[Sp] = block_c1tUp_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tUE_srtd" {
     u1tUE_srtd:
         const S1sVz_srt;
         const 53;
         const 4503599627370497;
 },
 _c1tUp() //  [R1]
         { info_tbl: [(c1tUp,
                       label: block_c1tUp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tUp: // global
           _s1sny::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1tUt_info;
           R3 = R1;
           R2 = _s1sny::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tUt() //  [R1]
         { info_tbl: [(c1tUt,
                       label: block_c1tUt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tUt: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.881773219 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$cfromRational_closure" {
     GHC.Real.$fFractionalRatio_$s$cfromRational_closure:
         const GHC.Real.$fFractionalRatio_$s$cfromRational_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$cfromRational_entry() //  [R2]
         { info_tbl: [(c1tV6,
                       label: GHC.Real.$fFractionalRatio_$s$cfromRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tV6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1tVc; else goto c1tVd;
       c1tVc: // global
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$cfromRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1tVd: // global
           I64[Sp - 8] = block_c1tV3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1tVi; else goto c1tV4;
       u1tVi: // global
           call _c1tV3(R1) args: 0, res: 0, upd: 0;
       c1tV4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tV3() //  [R1]
         { info_tbl: [(c1tV3,
                       label: block_c1tV3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tV3: // global
           I64[Sp] = block_c1tV9_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$cfromRational_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tV9() //  [R1, R2]
         { info_tbl: [(c1tV9,
                       label: block_c1tV9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tV9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tVh; else goto c1tVg;
       c1tVh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1tVg: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.889751333 UTC

[section ""data" . GHC.Real.$w$s$c/_closure" {
     GHC.Real.$w$s$c/_closure:
         const GHC.Real.$w$s$c/_info;
         const 0;
 },
 section ""relreadonly" . u1tW5_srtd" {
     u1tW5_srtd:
         const S1sVz_srt;
         const 66;
         const 4503599627370497;
         const 2;
 },
 GHC.Real.$w$s$c/_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1tVF,
                       label: GHC.Real.$w$s$c/_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tVF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tVV; else goto c1tVW;
       c1tVV: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$c/_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tVW: // global
           I64[Sp - 24] = block_c1tVD_info;
           _s1snL::P64 = R3;
           R3 = R4;
           _s1snK::P64 = R2;
           R2 = _s1snL::P64;
           P64[Sp - 16] = _s1snK::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tW6_srtd" {
     u1tW6_srtd:
         const S1sVz_srt;
         const 53;
         const 4503599627370497;
 },
 _c1tVD() //  [R1]
         { info_tbl: [(c1tVD,
                       label: block_c1tVD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tVD: // global
           I64[Sp - 8] = block_c1tVI_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tW7_srtd" {
     u1tW7_srtd:
         const S1sVz_srt;
         const 53;
         const 4503599627370497;
 },
 _c1tVI() //  [R1]
         { info_tbl: [(c1tVI,
                       label: block_c1tVI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tVI: // global
           I64[Sp] = block_c1tVM_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tW8_srtd" {
     u1tW8_srtd:
         const S1sVz_srt;
         const 53;
         const 4503599627370497;
 },
 _c1tVM() //  [R1]
         { info_tbl: [(c1tVM,
                       label: block_c1tVM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tVM: // global
           I64[Sp] = block_c1tVQ_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1tW9_srtd" {
     u1tW9_srtd:
         const S1sVz_srt;
         const 53;
         const 4503599627370497;
 },
 _c1tVQ() //  [R1]
         { info_tbl: [(c1tVQ,
                       label: block_c1tVQ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tVQ: // global
           I64[Sp] = block_c1tVU_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tVU() //  [R1]
         { info_tbl: [(c1tVU,
                       label: block_c1tVU_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tVU: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.905822408 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$c/_closure" {
     GHC.Real.$fFractionalRatio_$s$c/_closure:
         const GHC.Real.$fFractionalRatio_$s$c/_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$s$c/_entry() //  [R2, R3]
         { info_tbl: [(c1tWL,
                       label: GHC.Real.$fFractionalRatio_$s$c/_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tWL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tWW; else goto c1tWX;
       c1tWW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$s$c/_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tWX: // global
           I64[Sp - 16] = block_c1tWI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1tX4; else goto c1tWJ;
       u1tX4: // global
           call _c1tWI(R1) args: 0, res: 0, upd: 0;
       c1tWJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tWI() //  [R1]
         { info_tbl: [(c1tWI,
                       label: block_c1tWI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tWI: // global
           I64[Sp - 8] = block_c1tWO_info;
           _s1snW::P64 = P64[R1 + 7];
           _s1snX::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1snX::P64;
           P64[Sp + 8] = _s1snW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1tX3; else goto c1tWP;
       u1tX3: // global
           call _c1tWO(R1) args: 0, res: 0, upd: 0;
       c1tWP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tWO() //  [R1]
         { info_tbl: [(c1tWO,
                       label: block_c1tWO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tWO: // global
           _s1snW::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1tWT_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1snW::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tWT() //  [R1, R2]
         { info_tbl: [(c1tWT,
                       label: block_c1tWT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tWT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tX2; else goto c1tX1;
       c1tX2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1tX1: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.914981732 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$s$fFractionalRatio_closure" {
     GHC.Real.$fFractionalRatio_$s$fFractionalRatio_closure:
         const GHC.Real.C:Fractional_con_info;
         const GHC.Real.$fFractionalRatio_$s$fNumRatio_closure+1;
         const GHC.Real.$fFractionalRatio_$s$c/_closure+2;
         const GHC.Real.$fFractionalRatio_$s$crecip_closure+1;
         const GHC.Real.$fFractionalRatio_$s$cfromRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.916728572 UTC

[section ""data" . GHC.Real.ratioPrec_closure" {
     GHC.Real.ratioPrec_closure:
         const GHC.Types.I#_con_info;
         const 7;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.918479259 UTC

[section ""data" . GHC.Real.infinity_closure" {
     GHC.Real.infinity_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.even1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.920185821 UTC

[section ""data" . GHC.Real.notANumber_closure" {
     GHC.Real.notANumber_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.even1_closure;
         const GHC.Real.even1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.922730559 UTC

[section ""data" . GHC.Real.numerator_closure" {
     GHC.Real.numerator_closure:
         const GHC.Real.numerator_info;
 },
 GHC.Real.numerator_entry() //  [R2]
         { info_tbl: [(c1tXB,
                       label: GHC.Real.numerator_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tXB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1tXC; else goto c1tXD;
       c1tXC: // global
           R2 = R2;
           R1 = GHC.Real.numerator_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1tXD: // global
           I64[Sp - 8] = block_c1tXy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1tXH; else goto c1tXz;
       u1tXH: // global
           call _c1tXy(R1) args: 0, res: 0, upd: 0;
       c1tXz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tXy() //  [R1]
         { info_tbl: [(c1tXy,
                       label: block_c1tXy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tXy: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.928884277 UTC

[section ""data" . GHC.Real.denominator_closure" {
     GHC.Real.denominator_closure:
         const GHC.Real.denominator_info;
 },
 GHC.Real.denominator_entry() //  [R2]
         { info_tbl: [(c1tXZ,
                       label: GHC.Real.denominator_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tXZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1tY0; else goto c1tY1;
       c1tY0: // global
           R2 = R2;
           R1 = GHC.Real.denominator_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1tY1: // global
           I64[Sp - 8] = block_c1tXW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1tY5; else goto c1tXX;
       u1tY5: // global
           call _c1tXW(R1) args: 0, res: 0, upd: 0;
       c1tXX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tXW() //  [R1]
         { info_tbl: [(c1tXW,
                       label: block_c1tXW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tXW: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.934823017 UTC

[section ""data" . GHC.Real.$w$snumericEnumFrom_closure" {
     GHC.Real.$w$snumericEnumFrom_closure:
         const GHC.Real.$w$snumericEnumFrom_info;
         const 0;
 },
 section ""relreadonly" . u1tYG_srtd" {
     u1tYG_srtd:
         const S1sVz_srt+80;
         const 58;
         const 146366987889541121;
 },
 sat_s1sol_entry() //  [R1]
         { info_tbl: [(c1tYt,
                       label: sat_s1sol_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tYt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1tYu; else goto c1tYv;
       c1tYu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tYv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1tYo_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1tYo() //  [R1, R2]
         { info_tbl: [(c1tYo,
                       label: block_c1tYo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tYo: // global
           I64[Sp] = block_c1tYq_info;
           R3 = R2;
           R2 = R1;
           call GHC.Real.$w$snumericEnumFrom_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1tYq() //  [R1, R2]
         { info_tbl: [(c1tYq,
                       label: block_c1tYq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tYq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tYz; else goto c1tYy;
       c1tYz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1tYy: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1tYH_srtd" {
     u1tYH_srtd:
         const S1sVz_srt+80;
         const 58;
         const 146366987889541121;
 },
 GHC.Real.$w$snumericEnumFrom_entry() //  [R2, R3]
         { info_tbl: [(c1tYB,
                       label: GHC.Real.$w$snumericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tYB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1tYF; else goto c1tYE;
       c1tYF: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1tYE: // global
           I64[Hp - 48] = sat_s1sol_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.946445613 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFrom_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFrom_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFrom_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFrom_entry() //  [R2]
         { info_tbl: [(c1tZd,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tZd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1tZj; else goto c1tZk;
       c1tZj: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1tZk: // global
           I64[Sp - 8] = block_c1tZa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1tZp; else goto c1tZb;
       u1tZp: // global
           call _c1tZa(R1) args: 0, res: 0, upd: 0;
       c1tZb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tZa() //  [R1]
         { info_tbl: [(c1tZa,
                       label: block_c1tZa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tZa: // global
           I64[Sp] = block_c1tZg_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$snumericEnumFrom_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1tZg() //  [R1, R2]
         { info_tbl: [(c1tZg,
                       label: block_c1tZg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tZg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1tZo; else goto c1tZn;
       c1tZo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1tZn: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.954807519 UTC

[section ""data" . GHC.Real.$wnumericEnumFrom_closure" {
     GHC.Real.$wnumericEnumFrom_closure:
         const GHC.Real.$wnumericEnumFrom_info;
         const 0;
 },
 sat_s1sox_entry() //  [R1]
         { info_tbl: [(c1tZY,
                       label: sat_s1sox_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tZY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1tZZ; else goto c1u00;
       c1tZZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u00: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1soC_entry() //  [R1]
         { info_tbl: [(c1u01,
                       label: sat_s1soC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u01: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1u07; else goto c1u08;
       c1u07: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u08: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c1tZQ_info;
           _s1sot::P64 = P64[R1 + 16];
           R2 = _s1sot::P64;
           P64[Sp - 32] = _s1sot::P64;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1tZQ() //  [R1]
         { info_tbl: [(c1tZQ,
                       label: block_c1tZQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tZQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1u0b; else goto c1u0a;
       c1u0b: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1u0a: // global
           I64[Hp - 16] = sat_s1sox_info;
           P64[Hp] = R1;
           I64[Sp] = block_c1u02_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call GHC.Num.+_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1u02() //  [R1]
         { info_tbl: [(c1u02,
                       label: block_c1u02_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u02: // global
           I64[Sp + 16] = block_c1u04_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1u04() //  [R1, R2]
         { info_tbl: [(c1u04,
                       label: block_c1u04_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u04: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1u0f; else goto c1u0e;
       c1u0f: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1u0e: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$wnumericEnumFrom_entry() //  [R2, R3]
         { info_tbl: [(c1u0g,
                       label: GHC.Real.$wnumericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u0g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1u0h; else goto c1u0i;
       c1u0h: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wnumericEnumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1u0i: // global
           I64[Sp - 16] = block_c1tZK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1tZK() //  [R1]
         { info_tbl: [(c1tZK,
                       label: block_c1tZK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tZK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1u0l; else goto c1u0k;
       c1u0l: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1u0k: // global
           I64[Hp - 24] = sat_s1soC_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = Hp - 24;
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.970694828 UTC

[section ""data" . GHC.Real.numericEnumFrom_closure" {
     GHC.Real.numericEnumFrom_closure:
         const GHC.Real.numericEnumFrom_info;
         const 0;
 },
 GHC.Real.numericEnumFrom_entry() //  [R2, R3]
         { info_tbl: [(c1u1a,
                       label: GHC.Real.numericEnumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u1a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1u1b; else goto c1u1c;
       c1u1b: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1u1c: // global
           I64[Sp - 8] = block_c1u17_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1u17() //  [R1, R2]
         { info_tbl: [(c1u17,
                       label: block_c1u17_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u17: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1u1f; else goto c1u1e;
       c1u1f: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1u1e: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.976155967 UTC

[section ""data" . sat_s1soI_closure" {
     sat_s1soI_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.978203576 UTC

[section ""data" . sat_s1soJ_closure" {
     sat_s1soJ_closure:
         const :_con_info;
         const sat_s1soI_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.980107135 UTC

[section ""data" . GHC.Real.even2_closure" {
     GHC.Real.even2_closure:
         const GHC.Real.even2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.even2_entry() //  [R1]
         { info_tbl: [(c1u1z,
                       label: GHC.Real.even2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u1z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1u1A; else goto c1u1B;
       c1u1A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u1B: // global
           (_c1u1w::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1u1w::I64 == 0) goto c1u1y; else goto c1u1x;
       c1u1y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1u1x: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1u1w::I64;
           R3 = sat_s1soJ_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.984632948 UTC

[section ""data" . GHC.Real.$fEnumRatio2_closure" {
     GHC.Real.$fEnumRatio2_closure:
         const GHC.Real.$fEnumRatio2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fEnumRatio2_entry() //  [R1]
         { info_tbl: [(c1u1U,
                       label: GHC.Real.$fEnumRatio2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u1U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1u1V; else goto c1u1W;
       c1u1V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u1W: // global
           (_c1u1O::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1u1O::I64 == 0) goto c1u1Q; else goto c1u1P;
       c1u1Q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1u1P: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1u1O::I64;
           I64[Sp - 24] = block_c1u1R_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even2_closure;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 24;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1u1R() //  [R1, R2]
         { info_tbl: [(c1u1R,
                       label: block_c1u1R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u1R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1u1Z; else goto c1u1Y;
       c1u1Z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1u1Y: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:16.991737662 UTC

[section ""data" . GHC.Real.$w$snumericEnumFromTo_closure" {
     GHC.Real.$w$snumericEnumFromTo_closure:
         const GHC.Real.$w$snumericEnumFromTo_info;
         const 0;
 },
 ds_s1soT_entry() //  [R1]
         { info_tbl: [(c1u2s,
                       label: ds_s1soT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u2s: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1u2D; else goto c1u2E;
       c1u2D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u2E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1u2p_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1u2L; else goto c1u2q;
       u1u2L: // global
           call _c1u2p(R1) args: 0, res: 0, upd: 0;
       c1u2q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1u2p() //  [R1]
         { info_tbl: [(c1u2p,
                       label: block_c1u2p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u2p: // global
           I64[Sp - 16] = block_c1u2v_info;
           _s1soV::P64 = P64[R1 + 7];
           _s1soW::P64 = P64[R1 + 15];
           R1 = GHC.Real.$fEnumRatio2_closure;
           P64[Sp - 8] = _s1soW::P64;
           P64[Sp] = _s1soV::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1u2K; else goto c1u2w;
       u1u2K: // global
           call _c1u2v(R1) args: 0, res: 0, upd: 0;
       c1u2w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1u2v() //  [R1]
         { info_tbl: [(c1u2v,
                       label: block_c1u2v_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u2v: // global
           _s1soV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1u2A_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1soV::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1u2A() //  [R1, R2]
         { info_tbl: [(c1u2A,
                       label: block_c1u2A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u2A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1u2J; else goto c1u2I;
       c1u2J: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1u2I: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sp4_entry() //  [R1, R2]
         { info_tbl: [(c1u2R,
                       label: sat_s1sp4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u2R: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call GHC.Real.$fEnumRatio_$s$c<=_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$w$snumericEnumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c1u2U,
                       label: GHC.Real.$w$snumericEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u2U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1u2V; else goto c1u2W;
       c1u2V: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1u2W: // global
           I64[Sp - 16] = block_c1u2i_info;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Real.$w$snumericEnumFrom_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1u2i() //  [R1, R2]
         { info_tbl: [(c1u2i,
                       label: block_c1u2i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u2i: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1u2Z; else goto c1u2Y;
       c1u2Z: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1u2Y: // global
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = R1;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = ds_s1soT_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_s1sp4_info;
           P64[Hp] = Hp - 32;
           R3 = Hp - 54;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.007388034 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFromTo_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c1u3J,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u3J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1u3K; else goto c1u3L;
       c1u3K: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1u3L: // global
           I64[Sp - 16] = block_c1u3G_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1u3P; else goto c1u3H;
       u1u3P: // global
           call _c1u3G(R1) args: 0, res: 0, upd: 0;
       c1u3H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1u3G() //  [R1]
         { info_tbl: [(c1u3G,
                       label: block_c1u3G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u3G: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Real.$w$snumericEnumFromTo_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.014716247 UTC

[section ""data" . GHC.Real.numericEnumFromTo_closure" {
     GHC.Real.numericEnumFromTo_closure:
         const GHC.Real.numericEnumFromTo_info;
         const 0;
 },
 $dNum_s1spi_entry() //  [R1]
         { info_tbl: [(c1u4a,
                       label: $dNum_s1spi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u4a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1u4b; else goto c1u4c;
       c1u4b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u4c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1spl_entry() //  [R1]
         { info_tbl: [(c1u4q,
                       label: sat_s1spl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u4q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1u4r; else goto c1u4s;
       c1u4r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u4s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1spk_entry() //  [R1]
         { info_tbl: [(c1u4x,
                       label: sat_s1spk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u4x: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1u4y; else goto c1u4z;
       c1u4y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u4z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1spm_entry() //  [R1]
         { info_tbl: [(c1u4A,
                       label: sat_s1spm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u4A: // global
           _s1spm::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1u4B; else goto c1u4C;
       c1u4C: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1u4E; else goto c1u4D;
       c1u4E: // global
           HpAlloc = 48;
           goto c1u4B;
       c1u4B: // global
           R1 = _s1spm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u4D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1spm::P64;
           _s1spc::P64 = P64[_s1spm::P64 + 16];
           _s1spi::P64 = P64[_s1spm::P64 + 24];
           I64[Hp - 40] = sat_s1spl_info;
           P64[Hp - 24] = _s1spi::P64;
           I64[Hp - 16] = sat_s1spk_info;
           P64[Hp] = _s1spi::P64;
           R2 = _s1spc::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           Sp = Sp - 40;
           call GHC.Real./_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds_s1spj_entry() //  [R1]
         { info_tbl: [(c1u4F,
                       label: ds_s1spj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u4F: // global
           _s1spj::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1u4G; else goto c1u4H;
       c1u4H: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1u4J; else goto c1u4I;
       c1u4J: // global
           HpAlloc = 32;
           goto c1u4G;
       c1u4G: // global
           R1 = _s1spj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u4I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1spj::P64;
           _s1spc::P64 = P64[_s1spj::P64 + 16];
           _s1spe::P64 = P64[_s1spj::P64 + 24];
           _s1spi::P64 = P64[_s1spj::P64 + 32];
           I64[Hp - 24] = sat_s1spm_info;
           P64[Hp - 8] = _s1spc::P64;
           P64[Hp] = _s1spi::P64;
           R2 = _s1spi::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1spe::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1spo_entry() //  [R1, R2]
         { info_tbl: [(c1u4P,
                       label: sat_s1spo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u4P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1u4Q; else goto c1u4R;
       c1u4Q: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1u4R: // global
           _s1spn::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1spn::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Real.numericEnumFromTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1u4S,
                       label: GHC.Real.numericEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u4S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1u4T; else goto c1u4U;
       c1u4T: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFromTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1u4U: // global
           I64[Sp - 32] = block_c1u44_info;
           _s1spc::P64 = R3;
           R3 = R4;
           _s1spb::P64 = R2;
           R2 = _s1spc::P64;
           P64[Sp - 24] = _s1spb::P64;
           P64[Sp - 16] = _s1spc::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1u44() //  [R1, R2]
         { info_tbl: [(c1u44,
                       label: block_c1u44_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u44: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1u4X; else goto c1u4W;
       c1u4X: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1u4W: // global
           I64[Hp - 104] = $dNum_s1spi_info;
           _s1spc::P64 = P64[Sp + 16];
           P64[Hp - 88] = _s1spc::P64;
           I64[Hp - 80] = :_con_info;
           P64[Hp - 72] = R1;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = ds_s1spj_info;
           P64[Hp - 40] = _s1spc::P64;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = sat_s1spo_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 56;
           R3 = Hp - 78;
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.034824723 UTC

[section ""data" . GHC.Real.$w$snumericEnumFromThen_closure" {
     GHC.Real.$w$snumericEnumFromThen_closure:
         const GHC.Real.$w$snumericEnumFromThen_info;
         const 0;
 },
 sat_s1spE_entry() //  [R1]
         { info_tbl: [(c1u6b,
                       label: sat_s1spE_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u6b: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1u6c; else goto c1u6d;
       c1u6c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u6d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_c1u64_info;
           _s1spt::P64 = P64[R1 + 40];
           R5 = _s1spt::P64;
           _s1sps::P64 = P64[R1 + 32];
           R4 = _s1sps::P64;
           R3 = _s1spt::P64;
           R2 = _s1sps::P64;
           P64[Sp - 48] = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = _s1sps::P64;
           P64[Sp - 24] = _s1spt::P64;
           Sp = Sp - 56;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1u64() //  [R1, R2]
         { info_tbl: [(c1u64,
                       label: block_c1u64_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u64: // global
           _s1spr::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1u66_info;
           R5 = _s1spr::P64;
           R4 = P64[Sp + 8];
           R3 = R2;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1u66() //  [R1, R2]
         { info_tbl: [(c1u66,
                       label: block_c1u66_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u66: // global
           _s1spt::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1u68_info;
           R5 = R2;
           R4 = R1;
           R3 = _s1spt::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$snumericEnumFromThen_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1u68() //  [R1, R2]
         { info_tbl: [(c1u68,
                       label: block_c1u68_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u68: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1u6i; else goto c1u6h;
       c1u6i: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1u6h: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$snumericEnumFromThen_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1u6k,
                       label: GHC.Real.$w$snumericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u6k: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1u6o; else goto c1u6n;
       c1u6o: // global
           HpAlloc = 72;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFromThen_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1u6n: // global
           I64[Hp - 64] = sat_s1spE_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.047000967 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFromThen_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c1u6Y,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u6Y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1u79; else goto c1u7a;
       c1u79: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1u7a: // global
           I64[Sp - 16] = block_c1u6V_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1u7h; else goto c1u6W;
       u1u7h: // global
           call _c1u6V(R1) args: 0, res: 0, upd: 0;
       c1u6W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1u6V() //  [R1]
         { info_tbl: [(c1u6V,
                       label: block_c1u6V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u6V: // global
           I64[Sp - 8] = block_c1u71_info;
           _s1spI::P64 = P64[R1 + 7];
           _s1spJ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1spJ::P64;
           P64[Sp + 8] = _s1spI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1u7g; else goto c1u72;
       u1u7g: // global
           call _c1u71(R1) args: 0, res: 0, upd: 0;
       c1u72: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1u71() //  [R1]
         { info_tbl: [(c1u71,
                       label: block_c1u71_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u71: // global
           _s1spI::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1u76_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _s1spI::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$snumericEnumFromThen_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1u76() //  [R1, R2]
         { info_tbl: [(c1u76,
                       label: block_c1u76_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u76: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1u7f; else goto c1u7e;
       c1u7f: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1u7e: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.057397774 UTC

[section ""data" . GHC.Real.$wnumericEnumFromThen_closure" {
     GHC.Real.$wnumericEnumFromThen_closure:
         const GHC.Real.$wnumericEnumFromThen_info;
 },
 sat_s1spW_entry() //  [R1]
         { info_tbl: [(c1u7X,
                       label: sat_s1spW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u7X: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1u7Y; else goto c1u7Z;
       c1u7Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u7Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1spU::P64 = P64[R1 + 16];
           P64[Sp - 32] = _s1spU::P64;
           P64[Sp - 24] = _s1spU::P64;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sq1_entry() //  [R1]
         { info_tbl: [(c1u80,
                       label: sat_s1sq1_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u80: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1u86; else goto c1u87;
       c1u86: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u87: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_c1u7P_info;
           _s1spQ::P64 = P64[R1 + 16];
           R2 = _s1spQ::P64;
           P64[Sp - 40] = _s1spQ::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Real.$p1Fractional_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1u7P() //  [R1]
         { info_tbl: [(c1u7P,
                       label: block_c1u7P_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u7P: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1u8a; else goto c1u89;
       c1u8a: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1u89: // global
           I64[Hp - 24] = sat_s1spW_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           I64[Sp] = block_c1u81_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1u81() //  [R1]
         { info_tbl: [(c1u81,
                       label: block_c1u81_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u81: // global
           _s1spU::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1u83_info;
           R4 = R1;
           R3 = _s1spU::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1u83() //  [R1, R2]
         { info_tbl: [(c1u83,
                       label: block_c1u83_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u83: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1u8e; else goto c1u8d;
       c1u8e: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1u8d: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$wnumericEnumFromThen_entry() //  [R2, R3, R4]
         { info_tbl: [(c1u8f,
                       label: GHC.Real.$wnumericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u8f: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1u8g; else goto c1u8h;
       c1u8g: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wnumericEnumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1u8h: // global
           I64[Sp - 24] = block_c1u7H_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1u7H() //  [R1]
         { info_tbl: [(c1u7H,
                       label: block_c1u7H_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u7H: // global
           I64[Sp] = block_c1u7J_info;
           _s1spT::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s1spT::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1u7J() //  [R1]
         { info_tbl: [(c1u7J,
                       label: block_c1u7J_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u7J: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1u8l; else goto c1u8k;
       c1u8l: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1u8k: // global
           I64[Hp - 32] = sat_s1sq1_info;
           P64[Hp - 16] = P64[Sp + 8];
           _s1spT::P64 = P64[Sp + 16];
           P64[Hp - 8] = _s1spT::P64;
           P64[Hp] = R1;
           R2 = Hp - 32;
           R1 = _s1spT::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.074756731 UTC

[section ""data" . GHC.Real.numericEnumFromThen_closure" {
     GHC.Real.numericEnumFromThen_closure:
         const GHC.Real.numericEnumFromThen_info;
 },
 GHC.Real.numericEnumFromThen_entry() //  [R2, R3, R4]
         { info_tbl: [(c1u9f,
                       label: GHC.Real.numericEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u9f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1u9g; else goto c1u9h;
       c1u9g: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1u9h: // global
           I64[Sp - 8] = block_c1u9c_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1u9c() //  [R1, R2]
         { info_tbl: [(c1u9c,
                       label: block_c1u9c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u9c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1u9k; else goto c1u9j;
       c1u9k: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1u9j: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.0823265 UTC

[section ""data" . GHC.Real.$w$snumericEnumFromThenTo_closure" {
     GHC.Real.$w$snumericEnumFromThenTo_closure:
         const GHC.Real.$w$snumericEnumFromThenTo_info;
         const 0;
 },
 ds_s1sqh_entry() //  [R1]
         { info_tbl: [(c1u9S,
                       label: ds_s1sqh_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u9S: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1ua2; else goto c1ua3;
       c1ua2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ua3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_c1u9P_info;
           _s1sq8::P64 = P64[R1 + 16];
           _s1sq9::P64 = P64[R1 + 24];
           _s1sqa::P64 = P64[R1 + 32];
           _s1sqb::P64 = P64[R1 + 40];
           R1 = P64[R1 + 48];
           P64[Sp - 48] = _s1sq8::P64;
           P64[Sp - 40] = _s1sq9::P64;
           P64[Sp - 32] = _s1sqa::P64;
           P64[Sp - 24] = _s1sqb::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u1uaa; else goto c1u9Q;
       u1uaa: // global
           call _c1u9P(R1) args: 0, res: 0, upd: 0;
       c1u9Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1u9P() //  [R1]
         { info_tbl: [(c1u9P,
                       label: block_c1u9P_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u9P: // global
           _s1sq9::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1u9V_info;
           R5 = _s1sq9::P64;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 15];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1u9V() //  [R1, R2]
         { info_tbl: [(c1u9V,
                       label: block_c1u9V_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u9V: // global
           I64[Sp] = block_c1u9X_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even2_closure;
           R3 = R2;
           R2 = R1;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1u9X() //  [R1, R2]
         { info_tbl: [(c1u9X,
                       label: block_c1u9X_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u9X: // global
           _s1sqj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1u9Z_info;
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = _s1sqj::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1u9Z() //  [R1, R2]
         { info_tbl: [(c1u9Z,
                       label: block_c1u9Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u9Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ua9; else goto c1ua8;
       c1ua9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1ua8: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sqv_entry() //  [R1, R2]
         { info_tbl: [(c1uag,
                       label: sat_s1sqv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uag: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call GHC.Real.$fEnumRatio_$s$c<=_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_s1sqw_entry() //  [R1]
         { info_tbl: [(c1uas,
                       label: ds_s1sqw_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uas: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1uaC; else goto c1uaD;
       c1uaC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uaD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_c1uap_info;
           _s1sq8::P64 = P64[R1 + 16];
           _s1sq9::P64 = P64[R1 + 24];
           _s1sqa::P64 = P64[R1 + 32];
           _s1sqb::P64 = P64[R1 + 40];
           R1 = P64[R1 + 48];
           P64[Sp - 48] = _s1sq8::P64;
           P64[Sp - 40] = _s1sq9::P64;
           P64[Sp - 32] = _s1sqa::P64;
           P64[Sp - 24] = _s1sqb::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto u1uaK; else goto c1uaq;
       u1uaK: // global
           call _c1uap(R1) args: 0, res: 0, upd: 0;
       c1uaq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1uap() //  [R1]
         { info_tbl: [(c1uap,
                       label: block_c1uap_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uap: // global
           _s1sq9::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1uav_info;
           R5 = _s1sq9::P64;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 15];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1uav() //  [R1, R2]
         { info_tbl: [(c1uav,
                       label: block_c1uav_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uav: // global
           I64[Sp] = block_c1uax_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even2_closure;
           R3 = R2;
           R2 = R1;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1uax() //  [R1, R2]
         { info_tbl: [(c1uax,
                       label: block_c1uax_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uax: // global
           _s1sqy::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1uaz_info;
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = _s1sqy::P64;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1uaz() //  [R1, R2]
         { info_tbl: [(c1uaz,
                       label: block_c1uaz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uaz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1uaJ; else goto c1uaI;
       c1uaJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1uaI: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sqK_entry() //  [R1, R2]
         { info_tbl: [(c1uaQ,
                       label: sat_s1sqK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uaQ: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call GHC.Real.$fEnumRatio_$s$c>=_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1ubc_srtd" {
     u1ubc_srtd:
         const S1sVz_srt+24;
         const 79;
         const 4935945191598063617;
         const 16708;
 },
 sat_s1sqL_entry() //  [R1]
         { info_tbl: [(c1uaX,
                       label: sat_s1sqL_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uaX: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1uaY; else goto c1uaZ;
       c1uaY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uaZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_c1u9H_info;
           _s1sq9::P64 = P64[R1 + 24];
           R5 = _s1sq9::P64;
           _s1sq8::P64 = P64[R1 + 16];
           R4 = _s1sq8::P64;
           _s1sqb::P64 = P64[R1 + 40];
           R3 = _s1sqb::P64;
           _s1sqa::P64 = P64[R1 + 32];
           R2 = _s1sqa::P64;
           P64[Sp - 56] = _s1sq8::P64;
           P64[Sp - 48] = _s1sq9::P64;
           P64[Sp - 40] = _s1sqa::P64;
           P64[Sp - 32] = _s1sqb::P64;
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 64;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1u9H() //  [R1]
         { info_tbl: [(c1u9H,
                       label: block_c1u9H_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u9H: // global
           _s1sq8::P64 = P64[Sp + 8];
           _s1sq9::P64 = P64[Sp + 16];
           _s1sqa::P64 = P64[Sp + 24];
           _s1sqb::P64 = P64[Sp + 32];
           _s1sqc::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c1uaV; else goto c1uaU;
       c1uaV: // global
           Hp = Hp + 72;
           _s1sqg::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1ub5; else goto c1ub4;
       c1ub4: // global
           I64[Hp - 64] = ds_s1sqw_info;
           P64[Hp - 48] = _s1sq8::P64;
           P64[Hp - 40] = _s1sq9::P64;
           P64[Hp - 32] = _s1sqa::P64;
           P64[Hp - 24] = _s1sqb::P64;
           P64[Hp - 16] = _s1sqc::P64;
           I64[Hp - 8] = sat_s1sqK_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c1uaU: // global
           Hp = Hp + 72;
           _s1sqg::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1ub5; else goto c1ub1;
       c1ub5: // global
           HpAlloc = 72;
           R1 = _s1sqg::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1ub1: // global
           I64[Hp - 64] = ds_s1sqh_info;
           P64[Hp - 48] = _s1sq8::P64;
           P64[Hp - 40] = _s1sq9::P64;
           P64[Hp - 32] = _s1sqa::P64;
           P64[Hp - 24] = _s1sqb::P64;
           P64[Hp - 16] = _s1sqc::P64;
           I64[Hp - 8] = sat_s1sqv_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1ubd_srtd" {
     u1ubd_srtd:
         const S1sVz_srt+24;
         const 80;
         const 4935945191598063617;
         const 53572;
 },
 GHC.Real.$w$snumericEnumFromThenTo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1ub6,
                       label: GHC.Real.$w$snumericEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ub6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1ub7; else goto c1ub8;
       c1ub7: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$snumericEnumFromThenTo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ub8: // global
           I64[Sp - 48] = block_c1u9A_info;
           _s1sqb::P64 = R5;
           R5 = R5;
           _s1sqa::P64 = R4;
           R4 = R4;
           _s1sq9::P64 = R3;
           R3 = R3;
           _s1sq8::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = _s1sq8::P64;
           P64[Sp - 32] = _s1sq9::P64;
           P64[Sp - 24] = _s1sqa::P64;
           P64[Sp - 16] = _s1sqb::P64;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$w$snumericEnumFromThen_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1ube_srtd" {
     u1ube_srtd:
         const S1sVz_srt+24;
         const 79;
         const 4935945191598063617;
         const 16708;
 },
 _c1u9A() //  [R1, R2]
         { info_tbl: [(c1u9A,
                       label: block_c1u9A_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u9A: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1ubb; else goto c1uba;
       c1ubb: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1uba: // global
           I64[Hp - 72] = :_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s1sqL_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R3 = Hp - 70;
           R2 = Hp - 48;
           Sp = Sp + 48;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.118592934 UTC

[section ""data" . GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure" {
     GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure:
         const GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c1ucV,
                       label: GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ucV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ucZ; else goto c1ud0;
       c1ucZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ud0: // global
           I64[Sp - 24] = block_c1ucS_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1ud8; else goto c1ucT;
       u1ud8: // global
           call _c1ucS(R1) args: 0, res: 0, upd: 0;
       c1ucT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ucS() //  [R1]
         { info_tbl: [(c1ucS,
                       label: block_c1ucS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ucS: // global
           I64[Sp - 8] = block_c1ucY_info;
           _s1sqR::P64 = P64[R1 + 7];
           _s1sqS::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s1sqS::P64;
           P64[Sp + 8] = _s1sqR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ud7; else goto c1ud2;
       u1ud7: // global
           call _c1ucY(R1) args: 0, res: 0, upd: 0;
       c1ud2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ucY() //  [R1]
         { info_tbl: [(c1ucY,
                       label: block_c1ucY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ucY: // global
           R6 = P64[Sp + 24];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$snumericEnumFromThenTo_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.128823453 UTC

[section ""data" . GHC.Real.numericEnumFromThenTo_closure" {
     GHC.Real.numericEnumFromThenTo_closure:
         const GHC.Real.numericEnumFromThenTo_info;
         const 0;
 },
 $dNum_s1sr4_entry() //  [R1]
         { info_tbl: [(c1udD,
                       label: $dNum_s1sr4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1udD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1udE; else goto c1udF;
       c1udE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1udF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sr7_entry() //  [R1]
         { info_tbl: [(c1udO,
                       label: sat_s1sr7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1udO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1udP; else goto c1udQ;
       c1udP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1udQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sr6_entry() //  [R1]
         { info_tbl: [(c1udV,
                       label: sat_s1sr6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1udV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1udW; else goto c1udX;
       c1udW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1udX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 mid_s1sr5_entry() //  [R1]
         { info_tbl: [(c1udY,
                       label: mid_s1sr5_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1udY: // global
           _s1sr5::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1udZ; else goto c1ue0;
       c1ue0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1ue2; else goto c1ue1;
       c1ue2: // global
           HpAlloc = 64;
           goto c1udZ;
       c1udZ: // global
           R1 = _s1sr5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ue1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sr5::P64;
           _s1sqX::P64 = P64[_s1sr5::P64 + 16];
           _s1sqY::P64 = P64[_s1sr5::P64 + 24];
           _s1sqZ::P64 = P64[_s1sr5::P64 + 32];
           _s1sr4::P64 = P64[_s1sr5::P64 + 40];
           I64[Hp - 56] = sat_s1sr7_info;
           P64[Hp - 40] = _s1sr4::P64;
           I64[Hp - 32] = sat_s1sr6_info;
           P64[Hp - 16] = _s1sqY::P64;
           P64[Hp - 8] = _s1sqZ::P64;
           P64[Hp] = _s1sr4::P64;
           R2 = _s1sqX::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Real./_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds_s1sr9_entry() //  [R1]
         { info_tbl: [(c1ueb,
                       label: ds_s1sr9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ueb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uec; else goto c1ued;
       c1uec: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ued: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1srb_entry() //  [R1, R2]
         { info_tbl: [(c1uej,
                       label: sat_s1srb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uej: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1uek; else goto c1uel;
       c1uek: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1uel: // global
           _s1sra::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1sra::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 ds_s1src_entry() //  [R1]
         { info_tbl: [(c1ues,
                       label: ds_s1src_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ues: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uet; else goto c1ueu;
       c1uet: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ueu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sre_entry() //  [R1, R2]
         { info_tbl: [(c1ueA,
                       label: sat_s1sre_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ueA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1ueB; else goto c1ueC;
       c1ueB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1ueC: // global
           _s1srd::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1srd::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s1srf_entry() //  [R1]
         { info_tbl: [(c1ueH,
                       label: sat_s1srf_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ueH: // global
           _s1srf::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto c1ueI; else goto c1ueJ;
       c1ueJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1ueL; else goto c1ueK;
       c1ueL: // global
           HpAlloc = 72;
           goto c1ueI;
       c1ueI: // global
           R1 = _s1srf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ueK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1srf::P64;
           _s1sqW::P64 = P64[_s1srf::P64 + 16];
           _s1sqX::P64 = P64[_s1srf::P64 + 24];
           _s1sqY::P64 = P64[_s1srf::P64 + 32];
           _s1sqZ::P64 = P64[_s1srf::P64 + 40];
           _s1sr0::P64 = P64[_s1srf::P64 + 48];
           I64[Hp - 64] = $dNum_s1sr4_info;
           P64[Hp - 48] = _s1sqX::P64;
           I64[Hp - 40] = mid_s1sr5_info;
           P64[Hp - 24] = _s1sqX::P64;
           P64[Hp - 16] = _s1sqY::P64;
           P64[Hp - 8] = _s1sqZ::P64;
           _c1udz::P64 = Hp - 64;
           P64[Hp] = _c1udz::P64;
           I64[Sp - 56] = block_c1ue3_info;
           R2 = _s1sqW::P64;
           I64[Sp - 80] = stg_ap_pp_info;
           P64[Sp - 72] = _s1sqZ::P64;
           P64[Sp - 64] = _s1sqY::P64;
           P64[Sp - 48] = _c1udz::P64;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = _s1sqW::P64;
           P64[Sp - 24] = _s1sr0::P64;
           Sp = Sp - 80;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1ue3() //  [R1]
         { info_tbl: [(c1ue3,
                       label: block_c1ue3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ue3: // global
           _c1udz::P64 = P64[Sp + 8];
           _c1udG::P64 = P64[Sp + 16];
           _s1sqW::P64 = P64[Sp + 24];
           _s1sr0::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c1ueE; else goto c1ueF;
       c1ueE: // global
           Hp = Hp + 64;
           _s1sr8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1ueR; else goto c1ueN;
       c1ueN: // global
           I64[Hp - 56] = ds_s1sr9_info;
           P64[Hp - 40] = _s1sr0::P64;
           P64[Hp - 32] = _c1udz::P64;
           P64[Hp - 24] = _c1udG::P64;
           I64[Hp - 16] = sat_s1srb_info;
           P64[Hp - 8] = _s1sqW::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c1ueF: // global
           Hp = Hp + 64;
           _s1sr8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1ueR; else goto c1ueQ;
       c1ueR: // global
           HpAlloc = 64;
           R1 = _s1sr8::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1ueQ: // global
           I64[Hp - 56] = ds_s1src_info;
           P64[Hp - 40] = _s1sr0::P64;
           P64[Hp - 32] = _c1udz::P64;
           P64[Hp - 24] = _c1udG::P64;
           I64[Hp - 16] = sat_s1sre_info;
           P64[Hp - 8] = _s1sqW::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.numericEnumFromThenTo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1ueS,
                       label: GHC.Real.numericEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ueS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1ueT; else goto c1ueU;
       c1ueT: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.numericEnumFromThenTo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ueU: // global
           I64[Sp - 48] = block_c1uds_info;
           _s1sqY::P64 = R4;
           R4 = R5;
           _s1sqX::P64 = R3;
           R3 = _s1sqY::P64;
           _s1sqW::P64 = R2;
           R2 = _s1sqX::P64;
           P64[Sp - 40] = _s1sqW::P64;
           P64[Sp - 32] = _s1sqX::P64;
           P64[Sp - 24] = _s1sqY::P64;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uds() //  [R1, R2]
         { info_tbl: [(c1uds,
                       label: block_c1uds_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uds: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1ueX; else goto c1ueW;
       c1ueX: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1ueW: // global
           I64[Hp - 72] = :_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s1srf_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R3 = Hp - 70;
           R2 = Hp - 48;
           Sp = Sp + 48;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.15700817 UTC

[section ""data" . GHC.Real.fromIntegral_closure" {
     GHC.Real.fromIntegral_closure:
         const GHC.Real.fromIntegral_info;
 },
 sat_s1srk_entry() //  [R1]
         { info_tbl: [(c1ugF,
                       label: sat_s1srk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ugF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ugG; else goto c1ugH;
       c1ugG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ugH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.fromIntegral_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ugI,
                       label: GHC.Real.fromIntegral_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ugI: // global
           _s1srj::P64 = R4;
           _s1sri::P64 = R3;
           _s1srh::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c1ugJ; else goto c1ugK;
       c1ugK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1ugM; else goto c1ugL;
       c1ugM: // global
           HpAlloc = 32;
           goto c1ugJ;
       c1ugJ: // global
           R4 = _s1srj::P64;
           R3 = _s1sri::P64;
           R2 = _s1srh::P64;
           R1 = GHC.Real.fromIntegral_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ugL: // global
           I64[Hp - 24] = sat_s1srk_info;
           P64[Hp - 8] = _s1srh::P64;
           P64[Hp] = _s1srj::P64;
           R2 = _s1sri::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.163244936 UTC

[section ""data" . GHC.Real.realToFrac_closure" {
     GHC.Real.realToFrac_closure:
         const GHC.Real.realToFrac_info;
 },
 sat_s1sro_entry() //  [R1]
         { info_tbl: [(c1uha,
                       label: sat_s1sro_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uha: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uhb; else goto c1uhc;
       c1uhb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uhc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.realToFrac_entry() //  [R2, R3, R4]
         { info_tbl: [(c1uhd,
                       label: GHC.Real.realToFrac_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uhd: // global
           _s1srn::P64 = R4;
           _s1srm::P64 = R3;
           _s1srl::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c1uhe; else goto c1uhf;
       c1uhf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1uhh; else goto c1uhg;
       c1uhh: // global
           HpAlloc = 32;
           goto c1uhe;
       c1uhe: // global
           R4 = _s1srn::P64;
           R3 = _s1srm::P64;
           R2 = _s1srl::P64;
           R1 = GHC.Real.realToFrac_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uhg: // global
           I64[Hp - 24] = sat_s1sro_info;
           P64[Hp - 8] = _s1srl::P64;
           P64[Hp] = _s1srn::P64;
           R2 = _s1srm::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Real.fromRational_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.168826401 UTC

[section ""data" . GHC.Real.showSigned1_closure" {
     GHC.Real.showSigned1_closure:
         const GHC.Types.C#_con_info;
         const 45;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.172313273 UTC

[section ""data" . GHC.Real.showSigned_closure" {
     GHC.Real.showSigned_closure:
         const GHC.Real.showSigned_info;
         const 0;
 },
 $dNum_s1srt_entry() //  [R1]
         { info_tbl: [(c1uhG,
                       label: $dNum_s1srt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uhG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1uhH; else goto c1uhI;
       c1uhH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uhI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1srv_entry() //  [R1]
         { info_tbl: [(c1uhN,
                       label: sat_s1srv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uhN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uhO; else goto c1uhP;
       c1uhO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uhP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1srA_entry() //  [R1]
         { info_tbl: [(c1uic,
                       label: sat_s1srA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uic: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uid; else goto c1uie;
       c1uid: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uie: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 g1_s1srz_entry() //  [R1]
         { info_tbl: [(c1uif,
                       label: g1_s1srz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uif: // global
           _s1srz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1uig; else goto c1uih;
       c1uih: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1uij; else goto c1uii;
       c1uij: // global
           HpAlloc = 32;
           goto c1uig;
       c1uig: // global
           R1 = _s1srz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uii: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1srz::P64;
           _s1srq::P64 = P64[_s1srz::P64 + 16];
           _s1srs::P64 = P64[_s1srz::P64 + 24];
           _s1srt::P64 = P64[_s1srz::P64 + 32];
           I64[Hp - 24] = sat_s1srA_info;
           P64[Hp - 8] = _s1srs::P64;
           P64[Hp] = _s1srt::P64;
           R2 = Hp - 24;
           R1 = _s1srq::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1srE_entry() //  [R1, R2]
         { info_tbl: [(c1uiu,
                       label: sat_s1srE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uiu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1uiy; else goto c1uix;
       c1uiy: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1uix: // global
           _s1srz::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _s1srz::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Real.showSigned1_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1srH_entry() //  [R1]
         { info_tbl: [(c1uiK,
                       label: sat_s1srH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uiK: // global
           _s1srH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1uiL; else goto c1uiM;
       c1uiM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1uiO; else goto c1uiN;
       c1uiO: // global
           HpAlloc = 24;
           goto c1uiL;
       c1uiL: // global
           R1 = _s1srH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uiN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1srH::P64;
           _s1srz::P64 = P64[_s1srH::P64 + 16];
           _s1srF::P64 = P64[_s1srH::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s1srF::P64;
           R2 = Hp - 14;
           R1 = _s1srz::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1srJ_entry() //  [R1, R2]
         { info_tbl: [(c1uiR,
                       label: sat_s1srJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uiR: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1uiV; else goto c1uiU;
       c1uiV: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1uiU: // global
           _s1srz::P64 = P64[R1 + 7];
           I64[Hp - 72] = sat_s1srH_info;
           P64[Hp - 56] = _s1srz::P64;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = GHC.Real.showSigned1_closure+1;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.showSigned_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1uiW,
                       label: GHC.Real.showSigned_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uiW: // global
           _s1srs::P64 = R5;
           _s1srr::P64 = R4;
           _s1srq::P64 = R3;
           _s1srp::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto c1uiX; else goto c1uiY;
       c1uiY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1uj0; else goto c1uiZ;
       c1uj0: // global
           HpAlloc = 48;
           goto c1uiX;
       c1uiX: // global
           R5 = _s1srs::P64;
           R4 = _s1srr::P64;
           R3 = _s1srq::P64;
           R2 = _s1srp::P64;
           R1 = GHC.Real.showSigned_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uiZ: // global
           I64[Hp - 40] = $dNum_s1srt_info;
           P64[Hp - 24] = _s1srp::P64;
           I64[Hp - 16] = sat_s1srv_info;
           _c1uhC::P64 = Hp - 40;
           P64[Hp] = _c1uhC::P64;
           I64[Sp - 48] = block_c1uhQ_info;
           R2 = _s1srp::P64;
           P64[Sp - 40] = _c1uhC::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _s1srq::P64;
           P64[Sp - 16] = _s1srr::P64;
           P64[Sp - 8] = _s1srs::P64;
           Sp = Sp - 48;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uhQ() //  [R1]
         { info_tbl: [(c1uhQ,
                       label: block_c1uhQ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uhQ: // global
           I64[Sp] = block_c1uhU_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1uhU() //  [R1]
         { info_tbl: [(c1uhU,
                       label: block_c1uhU_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uhU: // global
           if (R1 & 7 == 1) goto c1uj5; else goto c1uj7;
       c1uj5: // global
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 24];
           Sp = Sp + 48;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       c1uj7: // global
           I64[Sp] = block_c1uhZ_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1ujf; else goto c1ui0;
       u1ujf: // global
           call _c1uhZ(R1) args: 0, res: 0, upd: 0;
       c1ui0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uhZ() //  [R1]
         { info_tbl: [(c1uhZ,
                       label: block_c1uhZ_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uhZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1uja; else goto c1uj9;
       c1uja: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uj9: // global
           _s1sry::I64 = I64[R1 + 7];
           I64[Hp - 48] = g1_s1srz_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = P64[Sp + 8];
           _c1ui4::P64 = Hp - 48;
           if (%MO_S_Le_W64(_s1sry::I64, 6)) goto c1ujc; else goto c1ujd;
       c1ujc: // global
           I64[Hp - 8] = sat_s1srE_info;
           P64[Hp] = _c1ui4::P64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1ujd: // global
           I64[Hp - 8] = sat_s1srJ_info;
           P64[Hp] = _c1ui4::P64;
           R1 = Hp - 7;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.198793259 UTC

[section ""data" . GHC.Real.even_closure" {
     GHC.Real.even_closure:
         const GHC.Real.even_info;
         const 0;
 },
 $dNum_s1srN_entry() //  [R1]
         { info_tbl: [(c1ukP,
                       label: $dNum_s1srN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ukP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ukQ; else goto c1ukR;
       c1ukQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ukR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1srS_entry() //  [R1]
         { info_tbl: [(c1ukW,
                       label: sat_s1srS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ukW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ukX; else goto c1ukY;
       c1ukX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ukY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1srQ_entry() //  [R1]
         { info_tbl: [(c1ul7,
                       label: sat_s1srQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ul7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ul8; else goto c1ul9;
       c1ul8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ul9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1srR_entry() //  [R1]
         { info_tbl: [(c1ula,
                       label: sat_s1srR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ula: // global
           _s1srR::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1ulb; else goto c1ulc;
       c1ulc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ule; else goto c1uld;
       c1ule: // global
           HpAlloc = 24;
           goto c1ulb;
       c1ulb: // global
           R1 = _s1srR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uld: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1srR::P64;
           _s1srK::P64 = P64[_s1srR::P64 + 16];
           _s1srL::P64 = P64[_s1srR::P64 + 24];
           _s1srN::P64 = P64[_s1srR::P64 + 32];
           I64[Hp - 16] = sat_s1srQ_info;
           P64[Hp] = _s1srN::P64;
           R2 = _s1srK::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1srL::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Real.rem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.even_entry() //  [R2, R3]
         { info_tbl: [(c1ulf,
                       label: GHC.Real.even_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ulf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1ull; else goto c1ulm;
       c1ull: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.even_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ulm: // global
           I64[Sp - 24] = block_c1ukH_info;
           _s1srK::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1srK::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ukH() //  [R1]
         { info_tbl: [(c1ukH,
                       label: block_c1ukH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ukH: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1ulp; else goto c1ulo;
       c1ulp: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ulo: // global
           I64[Hp - 80] = $dNum_s1srN_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_s1srS_info;
           _c1ukL::P64 = Hp - 80;
           P64[Hp - 40] = _c1ukL::P64;
           I64[Hp - 32] = sat_s1srR_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _c1ukL::P64;
           I64[Sp] = block_c1ulg_info;
           R2 = R1;
           P64[Sp + 8] = Hp - 32;
           P64[Sp + 16] = Hp - 56;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ulg() //  [R1]
         { info_tbl: [(c1ulg,
                       label: block_c1ulg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ulg: // global
           I64[Sp] = block_c1ulk_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ulk() //  [R1]
         { info_tbl: [(c1ulk,
                       label: block_c1ulk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ulk: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.216229678 UTC

[section ""data" . GHC.Real.odd_closure" {
     GHC.Real.odd_closure:
         const GHC.Real.odd_info;
         const 0;
 },
 GHC.Real.odd_entry() //  [R2, R3]
         { info_tbl: [(c1umv,
                       label: GHC.Real.odd_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1umv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1umw; else goto c1umx;
       c1umw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.odd_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1umx: // global
           I64[Sp - 8] = block_c1ump_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ump() //  [R1]
         { info_tbl: [(c1ump,
                       label: block_c1ump_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ump: // global
           if (R1 & 7 == 1) goto c1ums; else goto c1umt;
       c1ums: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1umt: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.222336044 UTC

[section ""data" . lvl3_r1j3b_closure" {
     lvl3_r1j3b_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.even2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.223912892 UTC

[section ""cstring" . lvl4_r1j3c_bytes" {
     lvl4_r1j3c_bytes:
         I8[] [114,111,117,110,100,32,100,101,102,97,117,108,116,32,100,101,102,110,58,32,66,97,100,32,118,97,108,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.226085477 UTC

[section ""data" . GHC.Real.$fRealFracRatio1_closure" {
     GHC.Real.$fRealFracRatio1_closure:
         const GHC.Real.$fRealFracRatio1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fRealFracRatio1_entry() //  [R1]
         { info_tbl: [(c1un3,
                       label: GHC.Real.$fRealFracRatio1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1un3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1un4; else goto c1un5;
       c1un4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1un5: // global
           (_c1umY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1umY::I64 == 0) goto c1un0; else goto c1umZ;
       c1un0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1umZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1umY::I64;
           I64[Sp - 24] = block_c1un1_info;
           R2 = lvl4_r1j3c_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1un1() //  [R1]
         { info_tbl: [(c1un1,
                       label: block_c1un1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1un1: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.235100733 UTC

[section ""data" . GHC.Real.$dmround_closure" {
     GHC.Real.$dmround_closure:
         const GHC.Real.$dmround_info;
         const 0;
 },
 ds_s1ss0_entry() //  [R1]
         { info_tbl: [(c1unt,
                       label: ds_s1ss0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1unt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1unu; else goto c1unv;
       c1unu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1unv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.properFraction_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $dNum_s1ss4_entry() //  [R1]
         { info_tbl: [(c1unM,
                       label: $dNum_s1ss4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1unM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1unN; else goto c1unO;
       c1unN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1unO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1ssc_entry() //  [R1]
         { info_tbl: [(c1uo4,
                       label: sat_s1ssc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uo4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uo5; else goto c1uo6;
       c1uo5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uo6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1uo2_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p2RealFrac_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1uo2() //  [R1]
         { info_tbl: [(c1uo2,
                       label: block_c1uo2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uo2: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = lvl3_r1j3b_closure+1;
           Sp = Sp - 8;
           call GHC.Real.fromRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1ssa_entry() //  [R1]
         { info_tbl: [(c1uoe,
                       label: sat_s1ssa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uoe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uof; else goto c1uog;
       c1uof: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uog: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1ssd_entry() //  [R1]
         { info_tbl: [(c1uoh,
                       label: sat_s1ssd_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uoh: // global
           _s1ssd::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1uoi; else goto c1uoj;
       c1uoj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1uol; else goto c1uok;
       c1uol: // global
           HpAlloc = 56;
           goto c1uoi;
       c1uoi: // global
           R1 = _s1ssd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uok: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ssd::P64;
           _s1srX::P64 = P64[_s1ssd::P64 + 16];
           _s1ss4::P64 = P64[_s1ssd::P64 + 24];
           _s1ss5::P64 = P64[_s1ssd::P64 + 32];
           I64[Hp - 48] = sat_s1ssc_info;
           P64[Hp - 32] = _s1srX::P64;
           I64[Hp - 24] = sat_s1ssa_info;
           P64[Hp - 8] = _s1ss4::P64;
           P64[Hp] = _s1ss5::P64;
           R2 = _s1ss4::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds1_s1ss9_entry() //  [R1]
         { info_tbl: [(c1uom,
                       label: ds1_s1ss9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uom: // global
           _s1ss9::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1uon; else goto c1uoo;
       c1uoo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1uoq; else goto c1uop;
       c1uoq: // global
           HpAlloc = 40;
           goto c1uon;
       c1uon: // global
           R1 = _s1ss9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uop: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ss9::P64;
           _s1srX::P64 = P64[_s1ss9::P64 + 16];
           _s1ss4::P64 = P64[_s1ss9::P64 + 24];
           _s1ss5::P64 = P64[_s1ss9::P64 + 32];
           I64[Hp - 32] = sat_s1ssd_info;
           P64[Hp - 16] = _s1srX::P64;
           P64[Hp - 8] = _s1ss4::P64;
           P64[Hp] = _s1ss5::P64;
           R2 = _s1ss4::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1ssi_entry() //  [R1]
         { info_tbl: [(c1uoA,
                       label: sat_s1ssi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uoA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uoB; else goto c1uoC;
       c1uoB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uoC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1ssj_entry() //  [R1]
         { info_tbl: [(c1uoD,
                       label: sat_s1ssj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uoD: // global
           _s1ssj::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1uoE; else goto c1uoF;
       c1uoF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1uoH; else goto c1uoG;
       c1uoH: // global
           HpAlloc = 24;
           goto c1uoE;
       c1uoE: // global
           R1 = _s1ssj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uoG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ssj::P64;
           _s1ss4::P64 = P64[_s1ssj::P64 + 16];
           I64[Hp - 16] = sat_s1ssi_info;
           P64[Hp] = _s1ss4::P64;
           R2 = _s1ss4::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sss_entry() //  [R1]
         { info_tbl: [(c1uoQ,
                       label: sat_s1sss_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uoQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uoR; else goto c1uoS;
       c1uoR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uoS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sso_entry() //  [R1]
         { info_tbl: [(c1upa,
                       label: sat_s1sso_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1upa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1upb; else goto c1upc;
       c1upb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1upc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1ssq_entry() //  [R1]
         { info_tbl: [(c1upl,
                       label: sat_s1ssq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1upl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1upm; else goto c1upn;
       c1upm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1upn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1ssr_entry() //  [R1]
         { info_tbl: [(c1upu,
                       label: sat_s1ssr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1upu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1upv; else goto c1upw;
       c1upv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1upw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1ssu_entry() //  [R1]
         { info_tbl: [(c1upF,
                       label: sat_s1ssu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1upF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1upG; else goto c1upH;
       c1upG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1upH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$dmround_entry() //  [R2, R3, R4]
         { info_tbl: [(c1upI,
                       label: GHC.Real.$dmround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1upI: // global
           _s1srZ::P64 = R4;
           _s1srY::P64 = R3;
           _s1srX::P64 = R2;
           if ((Sp + -88) < SpLim) (likely: False) goto c1upJ; else goto c1upK;
       c1upK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1upM; else goto c1upL;
       c1upM: // global
           HpAlloc = 40;
           goto c1upJ;
       c1upJ: // global
           R4 = _s1srZ::P64;
           R3 = _s1srY::P64;
           R2 = _s1srX::P64;
           R1 = GHC.Real.$dmround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1upL: // global
           I64[Hp - 32] = ds_s1ss0_info;
           P64[Hp - 16] = _s1srX::P64;
           P64[Hp - 8] = _s1srY::P64;
           P64[Hp] = _s1srZ::P64;
           I64[Sp - 32] = block_c1unw_info;
           R2 = _s1srX::P64;
           P64[Sp - 24] = Hp - 32;
           P64[Sp - 16] = _s1srX::P64;
           P64[Sp - 8] = _s1srY::P64;
           Sp = Sp - 32;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1unw() //  [R1]
         { info_tbl: [(c1unw,
                       label: block_c1unw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1unw: // global
           I64[Sp - 8] = block_c1unA_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1unA() //  [R1]
         { info_tbl: [(c1unA,
                       label: block_c1unA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1unA: // global
           I64[Sp - 8] = block_c1unE_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1unE() //  [R1]
         { info_tbl: [(c1unE,
                       label: block_c1unE_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1unE: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c1upR; else goto c1upQ;
       c1upR: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1upQ: // global
           I64[Hp - 128] = $dNum_s1ss4_info;
           P64[Hp - 112] = P64[Sp + 16];
           I64[Hp - 104] = stg_sel_1_upd_info;
           _c1unp::P64 = P64[Sp + 24];
           P64[Hp - 88] = _c1unp::P64;
           I64[Hp - 80] = ds1_s1ss9_info;
           P64[Hp - 64] = P64[Sp + 32];
           _c1unI::P64 = Hp - 128;
           P64[Hp - 56] = _c1unI::P64;
           _c1unP::P64 = Hp - 104;
           P64[Hp - 48] = _c1unP::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1unp::P64;
           I64[Hp - 16] = sat_s1ssj_info;
           P64[Hp] = _c1unI::P64;
           I64[Sp - 16] = block_c1uoI_info;
           R2 = R1;
           I64[Sp - 40] = stg_ap_pp_info;
           _c1unQ::P64 = Hp - 80;
           P64[Sp - 32] = _c1unQ::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 40;
           P64[Sp + 16] = _c1unQ::P64;
           P64[Sp + 24] = _c1unP::P64;
           P64[Sp + 32] = _c1unI::P64;
           Sp = Sp - 40;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1uoI() //  [R1]
         { info_tbl: [(c1uoI,
                       label: block_c1uoI_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uoI: // global
           if (R1 & 7 == 1) goto c1upT; else goto u1uqP;
       c1upT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1upW; else goto c1upV;
       c1upW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1upV: // global
           I64[Hp - 16] = sat_s1sss_info;
           P64[Hp] = P64[Sp + 48];
           I64[Sp] = block_c1upx_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       u1uqP: // global
           Sp = Sp + 16;
           call _c1uqJ() args: 0, res: 0, upd: 0;
     }
 },
 _c1upx() //  [R1]
         { info_tbl: [(c1upx,
                       label: block_c1upx_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1upx: // global
           if (R1 & 7 == 1) goto c1uqd; else goto c1uqv;
       c1uqd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1uqg; else goto c1uqf;
       c1uqg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uqf: // global
           I64[Hp - 16] = sat_s1ssu_info;
           P64[Hp] = P64[Sp + 48];
           _s1ss3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1uqb_info;
           R2 = _s1ss3::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c1uqv: // global
           I64[Sp + 8] = block_c1uqt_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 56];
           Sp = Sp + 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uqb() //  [R1]
         { info_tbl: [(c1uqb,
                       label: block_c1uqb_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uqb: // global
           if (R1 & 7 == 1) goto c1uqm; else goto u1uqS;
       c1uqm: // global
           R1 = GHC.Real.$fRealFracRatio1_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       u1uqS: // global
           Sp = Sp + 8;
           call _s1ssl() args: 0, res: 0, upd: 0;
     }
 },
 _c1uqt() //  [R1]
         { info_tbl: [(c1uqt,
                       label: block_c1uqt_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uqt: // global
           if (R1 & 7 == 1) goto u1uqQ; else goto u1uqR;
       u1uqQ: // global
           Sp = Sp + 8;
           call _s1ssl() args: 0, res: 0, upd: 0;
       u1uqR: // global
           Sp = Sp + 8;
           call _c1uqJ() args: 0, res: 0, upd: 0;
     }
 },
 _s1ssl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1ssl: // global
           I64[Sp - 8] = block_c1uoY_info;
           R2 = P64[Sp + 40];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uoY() //  [R1]
         { info_tbl: [(c1uoY,
                       label: block_c1uoY_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uoY: // global
           I64[Sp] = block_c1up2_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1up2() //  [R1]
         { info_tbl: [(c1up2,
                       label: block_c1up2_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1up2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1uq1; else goto c1uq0;
       c1uq1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uq0: // global
           I64[Hp - 16] = sat_s1sso_info;
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_c1upd_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 48] = R1;
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1upd() //  [R1]
         { info_tbl: [(c1upd,
                       label: block_c1upd_info
                       rep:StackRep [False, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1upd: // global
           _c1uor::P64 = P64[Sp + 8];
           _s1ssn::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto c1uq3; else goto c1uq7;
       c1uq3: // global
           Hp = Hp + 24;
           _s1ssp::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1uqa; else goto c1uq5;
       c1uq5: // global
           I64[Hp - 16] = sat_s1ssq_info;
           P64[Hp] = _s1ssn::P64;
           R2 = _s1ssn::P64;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = _c1uor::P64;
           P64[Sp + 48] = Hp - 16;
           Sp = Sp + 32;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
       c1uq7: // global
           Hp = Hp + 24;
           _s1ssp::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1uqa; else goto c1uq9;
       c1uqa: // global
           HpAlloc = 24;
           R1 = _s1ssp::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uq9: // global
           I64[Hp - 16] = sat_s1ssr_info;
           P64[Hp] = _s1ssn::P64;
           R2 = _s1ssn::P64;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = _c1uor::P64;
           P64[Sp + 48] = Hp - 16;
           Sp = Sp + 32;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _c1uqJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uqJ: // global
           R1 = P64[Sp];
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.291031751 UTC

[section ""data" . GHC.Real.integralEnumFrom_closure" {
     GHC.Real.integralEnumFrom_closure:
         const GHC.Real.integralEnumFrom_info;
         const 0;
 },
 f_s1ssA_entry() //  [R1]
         { info_tbl: [(c1uua,
                       label: f_s1ssA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uua: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1ssB_entry() //  [R1]
         { info_tbl: [(c1uuh,
                       label: f1_s1ssB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uuh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1uui; else goto c1uuj;
       c1uui: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uuj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1ssD_entry() //  [R1]
         { info_tbl: [(c1uuo,
                       label: sat_s1ssD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uuo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1uup; else goto c1uuq;
       c1uup: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uuq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1ssJ_entry() //  [R1]
         { info_tbl: [(c1uuK,
                       label: sat_s1ssJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uuK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uuL; else goto c1uuM;
       c1uuL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uuM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1uuI_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1uuI() //  [R1]
         { info_tbl: [(c1uuI,
                       label: block_c1uuI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uuI: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1ssE_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1ssH_entry() //  [R1]
         { info_tbl: [(c1uuU,
                       label: sat_s1ssH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uuU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uuV; else goto c1uuW;
       c1uuV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uuW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1ssE_entry() //  [R1, R2]
         { info_tbl: [(c1uv0,
                       label: go_s1ssE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uv0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uv1; else goto c1uv2;
       c1uv1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1uv2: // global
           I64[Sp - 32] = block_c1uuA_info;
           R3 = P64[R1 + 15];
           _s1ssF::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1ssF::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uuA() //  [R1]
         { info_tbl: [(c1uuA,
                       label: block_c1uuA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uuA: // global
           if (R1 == 1) goto c1uuZ; else goto c1uuY;
       c1uuZ: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1uuY: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1uv6; else goto c1uv5;
       c1uv6: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1uv5: // global
           I64[Hp - 80] = sat_s1ssJ_info;
           P64[Hp - 64] = P64[Sp + 16];
           _s1ssF::P64 = P64[Sp + 24];
           P64[Hp - 56] = _s1ssF::P64;
           I64[Hp - 48] = sat_s1ssH_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s1ssF::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1uvn_srtd" {
     u1uvn_srtd:
         const S1sVz_srt+480;
         const 34;
         const 8589935105;
 },
 GHC.Real.integralEnumFrom_entry() //  [R2, R3, R4]
         { info_tbl: [(c1uva,
                       label: GHC.Real.integralEnumFrom_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uva: // global
           _s1ssz::P64 = R4;
           _s1ssy::P64 = R3;
           _s1ssx::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1uvc; else goto c1uvd;
       c1uvd: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1uvf; else goto c1uve;
       c1uvf: // global
           HpAlloc = 72;
           goto c1uvc;
       c1uvc: // global
           R4 = _s1ssz::P64;
           R3 = _s1ssy::P64;
           R2 = _s1ssx::P64;
           R1 = GHC.Real.integralEnumFrom_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uve: // global
           I64[Hp - 64] = f_s1ssA_info;
           P64[Hp - 48] = _s1ssx::P64;
           I64[Hp - 40] = f1_s1ssB_info;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = sat_s1ssD_info;
           P64[Hp] = _s1ssy::P64;
           I64[Sp - 32] = block_c1uur_info;
           R2 = _s1ssx::P64;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = _s1ssx::P64;
           P64[Sp - 8] = _s1ssz::P64;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1uur() //  [R1]
         { info_tbl: [(c1uur,
                       label: block_c1uur_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uur: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1uvi; else goto c1uvh;
       c1uvi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uvh: // global
           I64[Hp - 16] = go_s1ssE_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           _s1ssx::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1uvb_info;
           R2 = _s1ssx::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 15;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1uvb() //  [R1]
         { info_tbl: [(c1uvb,
                       label: block_c1uvb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uvb: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1ssE_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.319616984 UTC

[section ""data" . GHC.Real.integralEnumFromThen_closure" {
     GHC.Real.integralEnumFromThen_closure:
         const GHC.Real.integralEnumFromThen_info;
         const 0;
 },
 f_s1ssT_entry() //  [R1]
         { info_tbl: [(c1uwZ,
                       label: f_s1ssT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uwZ: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1ssU_entry() //  [R1]
         { info_tbl: [(c1ux6,
                       label: f1_s1ssU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ux6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ux7; else goto c1ux8;
       c1ux7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ux8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1ssX_entry() //  [R1]
         { info_tbl: [(c1uxh,
                       label: sat_s1ssX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uxh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1uxi; else goto c1uxj;
       c1uxi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uxj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1st3_entry() //  [R1]
         { info_tbl: [(c1uxD,
                       label: sat_s1st3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uxD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uxE; else goto c1uxF;
       c1uxE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uxF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1uxB_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1uxB() //  [R1]
         { info_tbl: [(c1uxB,
                       label: block_c1uxB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uxB: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1ssY_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1st1_entry() //  [R1]
         { info_tbl: [(c1uxN,
                       label: sat_s1st1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uxN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uxO; else goto c1uxP;
       c1uxO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uxP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1ssY_entry() //  [R1, R2]
         { info_tbl: [(c1uxT,
                       label: go_s1ssY_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uxT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uxU; else goto c1uxV;
       c1uxU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1uxV: // global
           I64[Sp - 40] = block_c1uxt_info;
           R3 = P64[R1 + 23];
           _s1ssZ::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1ssZ::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uxt() //  [R1]
         { info_tbl: [(c1uxt,
                       label: block_c1uxt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uxt: // global
           if (R1 == 1) goto c1uxS; else goto c1uxR;
       c1uxS: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1uxR: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1uxZ; else goto c1uxY;
       c1uxZ: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1uxY: // global
           I64[Hp - 88] = sat_s1st3_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1ssZ::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1ssZ::P64;
           I64[Hp - 48] = sat_s1st1_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1ssZ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1st5_entry() //  [R1]
         { info_tbl: [(c1uy9,
                       label: sat_s1st5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uy9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1uya; else goto c1uyb;
       c1uya: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uyb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1stb_entry() //  [R1]
         { info_tbl: [(c1uyv,
                       label: sat_s1stb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uyv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uyw; else goto c1uyx;
       c1uyw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uyx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1uyt_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1uyt() //  [R1]
         { info_tbl: [(c1uyt,
                       label: block_c1uyt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uyt: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1st6_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1st9_entry() //  [R1]
         { info_tbl: [(c1uyF,
                       label: sat_s1st9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uyF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uyG; else goto c1uyH;
       c1uyG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uyH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1st6_entry() //  [R1, R2]
         { info_tbl: [(c1uyL,
                       label: go_s1st6_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uyL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uyM; else goto c1uyN;
       c1uyM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1uyN: // global
           I64[Sp - 40] = block_c1uyl_info;
           R3 = P64[R1 + 23];
           _s1st7::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1st7::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uyl() //  [R1]
         { info_tbl: [(c1uyl,
                       label: block_c1uyl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uyl: // global
           if (R1 == 1) goto c1uyK; else goto c1uyJ;
       c1uyK: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1uyJ: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1uyR; else goto c1uyQ;
       c1uyR: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1uyQ: // global
           I64[Hp - 88] = sat_s1stb_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1st7::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1st7::P64;
           I64[Hp - 48] = sat_s1st9_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1st7::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 f_s1std_entry() //  [R1]
         { info_tbl: [(c1uz5,
                       label: f_s1std_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uz5: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1ste_entry() //  [R1]
         { info_tbl: [(c1uzc,
                       label: f1_s1ste_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uzc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1uzd; else goto c1uze;
       c1uzd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uze: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sth_entry() //  [R1]
         { info_tbl: [(c1uzn,
                       label: sat_s1sth_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uzn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1uzo; else goto c1uzp;
       c1uzo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uzp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1stn_entry() //  [R1]
         { info_tbl: [(c1uzJ,
                       label: sat_s1stn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uzJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uzK; else goto c1uzL;
       c1uzK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uzL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1uzH_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1uzH() //  [R1]
         { info_tbl: [(c1uzH,
                       label: block_c1uzH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uzH: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1sti_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1stl_entry() //  [R1]
         { info_tbl: [(c1uzT,
                       label: sat_s1stl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uzT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uzU; else goto c1uzV;
       c1uzU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uzV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1sti_entry() //  [R1, R2]
         { info_tbl: [(c1uzZ,
                       label: go_s1sti_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uzZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uA0; else goto c1uA1;
       c1uA0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1uA1: // global
           I64[Sp - 40] = block_c1uzz_info;
           R3 = P64[R1 + 23];
           _s1stj::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1stj::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uzz() //  [R1]
         { info_tbl: [(c1uzz,
                       label: block_c1uzz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uzz: // global
           if (R1 == 1) goto c1uzY; else goto c1uzX;
       c1uzY: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1uzX: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1uA5; else goto c1uA4;
       c1uA5: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1uA4: // global
           I64[Hp - 88] = sat_s1stn_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1stj::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1stj::P64;
           I64[Hp - 48] = sat_s1stl_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1stj::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1stp_entry() //  [R1]
         { info_tbl: [(c1uAf,
                       label: sat_s1stp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uAf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1uAg; else goto c1uAh;
       c1uAg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uAh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1stv_entry() //  [R1]
         { info_tbl: [(c1uAB,
                       label: sat_s1stv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uAB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uAC; else goto c1uAD;
       c1uAC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uAD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1uAz_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1uAz() //  [R1]
         { info_tbl: [(c1uAz,
                       label: block_c1uAz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uAz: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1stq_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1stt_entry() //  [R1]
         { info_tbl: [(c1uAL,
                       label: sat_s1stt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uAL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uAM; else goto c1uAN;
       c1uAM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uAN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1stq_entry() //  [R1, R2]
         { info_tbl: [(c1uAR,
                       label: go_s1stq_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uAR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uAS; else goto c1uAT;
       c1uAS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1uAT: // global
           I64[Sp - 40] = block_c1uAr_info;
           R3 = P64[R1 + 23];
           _s1str::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1str::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uAr() //  [R1]
         { info_tbl: [(c1uAr,
                       label: block_c1uAr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uAr: // global
           if (R1 == 1) goto c1uAQ; else goto c1uAP;
       c1uAQ: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1uAP: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1uAX; else goto c1uAW;
       c1uAX: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1uAW: // global
           I64[Hp - 88] = sat_s1stv_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1str::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1str::P64;
           I64[Hp - 48] = sat_s1stt_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1str::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1uBL_srtd" {
     u1uBL_srtd:
         const S1sVz_srt+456;
         const 39;
         const 412585295873;
 },
 GHC.Real.integralEnumFromThen_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1uB1,
                       label: GHC.Real.integralEnumFromThen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uB1: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1uB2; else goto c1uB3;
       c1uB2: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.integralEnumFromThen_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uB3: // global
           I64[Sp - 32] = block_c1uwF_info;
           _s1ssL::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s1ssL::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1uBM_srtd" {
     u1uBM_srtd:
         const S1sVz_srt+456;
         const 38;
         const 137707388929;
 },
 _c1uwF() //  [R1]
         { info_tbl: [(c1uwF,
                       label: block_c1uwF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uwF: // global
           I64[Sp] = block_c1uwJ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1uBN_srtd" {
     u1uBN_srtd:
         const S1sVz_srt+456;
         const 38;
         const 137707388929;
 },
 _c1uwJ() //  [R1]
         { info_tbl: [(c1uwJ,
                       label: block_c1uwJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uwJ: // global
           I64[Sp - 8] = block_c1uwN_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1uBO_srtd" {
     u1uBO_srtd:
         const S1sVz_srt+456;
         const 38;
         const 137707388929;
 },
 _c1uwN() //  [R1]
         { info_tbl: [(c1uwN,
                       label: block_c1uwN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uwN: // global
           _s1ssP::P64 = P64[Sp + 32];
           _s1ssQ::P64 = P64[Sp + 8];
           if (R1 == 1) goto c1uBs; else goto c1uB8;
       c1uBs: // global
           I64[Sp] = block_c1uyX_info;
           R3 = _s1ssQ::P64;
           R2 = _s1ssP::P64;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       c1uB8: // global
           I64[Sp] = block_c1uwR_info;
           R3 = _s1ssQ::P64;
           R2 = _s1ssP::P64;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uyX() //  [R1]
         { info_tbl: [(c1uyX,
                       label: block_c1uyX_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uyX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1uBv; else goto c1uBu;
       c1uBv: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uBu: // global
           I64[Hp - 40] = f_s1std_info;
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = f1_s1ste_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_c1uzf_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp] = R1;
           P64[Sp + 32] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uzf() //  [R1]
         { info_tbl: [(c1uzf,
                       label: block_c1uzf_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uzf: // global
           _s1ssL::P64 = P64[Sp + 24];
           _s1ssM::P64 = P64[Sp + 32];
           if (R1 == 1) goto c1uBE; else goto c1uBx;
       c1uBE: // global
           Hp = Hp + 24;
           _s1stf::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1uBH; else goto c1uBG;
       c1uBG: // global
           I64[Hp - 16] = sat_s1stp_info;
           P64[Hp] = _s1ssM::P64;
           I64[Sp] = block_c1uAi_info;
           R2 = _s1ssL::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c1uBx: // global
           Hp = Hp + 24;
           _s1stf::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1uBH; else goto c1uBz;
       c1uBH: // global
           HpAlloc = 24;
           R1 = _s1stf::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1uBz: // global
           I64[Hp - 16] = sat_s1sth_info;
           P64[Hp] = _s1ssM::P64;
           I64[Sp] = block_c1uzq_info;
           R2 = _s1ssL::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1uAi() //  [R1]
         { info_tbl: [(c1uAi,
                       label: block_c1uAi_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uAi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1uBK; else goto c1uBJ;
       c1uBK: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uBJ: // global
           I64[Hp - 24] = go_s1stq_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1stq_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1uzq() //  [R1]
         { info_tbl: [(c1uzq,
                       label: block_c1uzq_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uzq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1uBD; else goto c1uBC;
       c1uBD: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uBC: // global
           I64[Hp - 24] = go_s1sti_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1sti_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1uwR() //  [R1]
         { info_tbl: [(c1uwR,
                       label: block_c1uwR_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uwR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1uBb; else goto c1uBa;
       c1uBb: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uBa: // global
           I64[Hp - 40] = f_s1ssT_info;
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = f1_s1ssU_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_c1ux9_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp] = R1;
           P64[Sp + 32] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ux9() //  [R1]
         { info_tbl: [(c1ux9,
                       label: block_c1ux9_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ux9: // global
           _s1ssL::P64 = P64[Sp + 24];
           _s1ssM::P64 = P64[Sp + 32];
           if (R1 == 1) goto c1uBk; else goto c1uBd;
       c1uBk: // global
           Hp = Hp + 24;
           _s1ssV::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1uBn; else goto c1uBm;
       c1uBm: // global
           I64[Hp - 16] = sat_s1st5_info;
           P64[Hp] = _s1ssM::P64;
           I64[Sp] = block_c1uyc_info;
           R2 = _s1ssL::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c1uBd: // global
           Hp = Hp + 24;
           _s1ssV::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1uBn; else goto c1uBf;
       c1uBn: // global
           HpAlloc = 24;
           R1 = _s1ssV::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1uBf: // global
           I64[Hp - 16] = sat_s1ssX_info;
           P64[Hp] = _s1ssM::P64;
           I64[Sp] = block_c1uxk_info;
           R2 = _s1ssL::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1uyc() //  [R1]
         { info_tbl: [(c1uyc,
                       label: block_c1uyc_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uyc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1uBq; else goto c1uBp;
       c1uBq: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uBp: // global
           I64[Hp - 24] = go_s1st6_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1st6_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1uxk() //  [R1]
         { info_tbl: [(c1uxk,
                       label: block_c1uxk_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uxk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1uBj; else goto c1uBi;
       c1uBj: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uBi: // global
           I64[Hp - 24] = go_s1ssY_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1ssY_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.40499547 UTC

[section ""data" . GHC.Real.integralEnumFromTo_closure" {
     GHC.Real.integralEnumFromTo_closure:
         const GHC.Real.integralEnumFromTo_info;
         const 0;
 },
 f_s1stz_entry() //  [R1]
         { info_tbl: [(c1uGr,
                       label: f_s1stz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uGr: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1stA_entry() //  [R1]
         { info_tbl: [(c1uGy,
                       label: f1_s1stA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uGy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1uGz; else goto c1uGA;
       c1uGz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uGA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1stH_entry() //  [R1]
         { info_tbl: [(c1uGU,
                       label: sat_s1stH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uGU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uGV; else goto c1uGW;
       c1uGV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uGW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1uGS_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1uGS() //  [R1]
         { info_tbl: [(c1uGS,
                       label: block_c1uGS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uGS: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1stC_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1stF_entry() //  [R1]
         { info_tbl: [(c1uH4,
                       label: sat_s1stF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uH4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uH5; else goto c1uH6;
       c1uH5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uH6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1stC_entry() //  [R1, R2]
         { info_tbl: [(c1uHa,
                       label: go_s1stC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uHa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uHb; else goto c1uHc;
       c1uHb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1uHc: // global
           I64[Sp - 32] = block_c1uGK_info;
           R3 = P64[R1 + 15];
           _s1stD::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1stD::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uGK() //  [R1]
         { info_tbl: [(c1uGK,
                       label: block_c1uGK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uGK: // global
           if (R1 == 1) goto c1uH9; else goto c1uH8;
       c1uH9: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1uH8: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1uHg; else goto c1uHf;
       c1uHg: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1uHf: // global
           I64[Hp - 80] = sat_s1stH_info;
           P64[Hp - 64] = P64[Sp + 16];
           _s1stD::P64 = P64[Sp + 24];
           P64[Hp - 56] = _s1stD::P64;
           I64[Hp - 48] = sat_s1stF_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s1stD::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.integralEnumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c1uHk,
                       label: GHC.Real.integralEnumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uHk: // global
           _s1sty::P64 = R4;
           _s1stx::P64 = R3;
           _s1stw::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c1uHm; else goto c1uHn;
       c1uHn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1uHp; else goto c1uHo;
       c1uHp: // global
           HpAlloc = 48;
           goto c1uHm;
       c1uHm: // global
           R4 = _s1sty::P64;
           R3 = _s1stx::P64;
           R2 = _s1stw::P64;
           R1 = GHC.Real.integralEnumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uHo: // global
           I64[Hp - 40] = f_s1stz_info;
           P64[Hp - 24] = _s1stw::P64;
           I64[Hp - 16] = f1_s1stA_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 32] = block_c1uGB_info;
           R2 = _s1stw::P64;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = _s1sty::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _s1stw::P64;
           P64[Sp - 8] = _s1stx::P64;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1uGB() //  [R1]
         { info_tbl: [(c1uGB,
                       label: block_c1uGB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uGB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1uHs; else goto c1uHr;
       c1uHs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uHr: // global
           I64[Hp - 16] = go_s1stC_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           _s1stw::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1uHl_info;
           R2 = _s1stw::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 15;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1uHl() //  [R1]
         { info_tbl: [(c1uHl,
                       label: block_c1uHl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uHl: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1stC_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.433565362 UTC

[section ""data" . GHC.Real.integralEnumFromThenTo_closure" {
     GHC.Real.integralEnumFromThenTo_closure:
         const GHC.Real.integralEnumFromThenTo_info;
         const 0;
 },
 f_s1stQ_entry() //  [R1]
         { info_tbl: [(c1uIW,
                       label: f_s1stQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uIW: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_s1stR_entry() //  [R1]
         { info_tbl: [(c1uJ3,
                       label: f1_s1stR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uJ3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1uJ4; else goto c1uJ5;
       c1uJ4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uJ5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1stZ_entry() //  [R1]
         { info_tbl: [(c1uJt,
                       label: sat_s1stZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uJt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uJu; else goto c1uJv;
       c1uJu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uJv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1uJr_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1uJr() //  [R1]
         { info_tbl: [(c1uJr,
                       label: block_c1uJr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uJr: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1stU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1stX_entry() //  [R1]
         { info_tbl: [(c1uJD,
                       label: sat_s1stX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uJD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uJE; else goto c1uJF;
       c1uJE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uJF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1stU_entry() //  [R1, R2]
         { info_tbl: [(c1uJJ,
                       label: go_s1stU_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uJJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uJK; else goto c1uJL;
       c1uJK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1uJL: // global
           I64[Sp - 40] = block_c1uJj_info;
           R3 = P64[R1 + 23];
           _s1stV::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1stV::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uJj() //  [R1]
         { info_tbl: [(c1uJj,
                       label: block_c1uJj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uJj: // global
           if (R1 == 1) goto c1uJI; else goto c1uJH;
       c1uJI: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1uJH: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1uJP; else goto c1uJO;
       c1uJP: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1uJO: // global
           I64[Hp - 88] = sat_s1stZ_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1stV::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1stV::P64;
           I64[Hp - 48] = sat_s1stX_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1stV::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1su6_entry() //  [R1]
         { info_tbl: [(c1uKe,
                       label: sat_s1su6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uKe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uKf; else goto c1uKg;
       c1uKf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uKg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1uKc_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1uKc() //  [R1]
         { info_tbl: [(c1uKc,
                       label: block_c1uKc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uKc: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s1su1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1su4_entry() //  [R1]
         { info_tbl: [(c1uKo,
                       label: sat_s1su4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uKo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uKp; else goto c1uKq;
       c1uKp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uKq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s1su1_entry() //  [R1, R2]
         { info_tbl: [(c1uKu,
                       label: go_s1su1_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uKu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uKv; else goto c1uKw;
       c1uKv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1uKw: // global
           I64[Sp - 40] = block_c1uK4_info;
           R3 = P64[R1 + 23];
           _s1su2::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s1su2::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uK4() //  [R1]
         { info_tbl: [(c1uK4,
                       label: block_c1uK4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uK4: // global
           if (R1 == 1) goto c1uKt; else goto c1uKs;
       c1uKt: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1uKs: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1uKA; else goto c1uKz;
       c1uKA: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1uKz: // global
           I64[Hp - 88] = sat_s1su6_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 24];
           _s1su2::P64 = P64[Sp + 32];
           P64[Hp - 56] = _s1su2::P64;
           I64[Hp - 48] = sat_s1su4_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s1su2::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1uKX_srtd" {
     u1uKX_srtd:
         const S1sVz_srt+456;
         const 41;
         const 1237219016705;
 },
 GHC.Real.integralEnumFromThenTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1uKE,
                       label: GHC.Real.integralEnumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uKE: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1uKF; else goto c1uKG;
       c1uKF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.integralEnumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uKG: // global
           I64[Sp - 32] = block_c1uIG_info;
           _s1stJ::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = R3;
           P64[Sp - 24] = _s1stJ::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1uKY_srtd" {
     u1uKY_srtd:
         const S1sVz_srt+456;
         const 38;
         const 137707388929;
 },
 _c1uIG() //  [R1]
         { info_tbl: [(c1uIG,
                       label: block_c1uIG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uIG: // global
           I64[Sp] = block_c1uIK_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1uKZ_srtd" {
     u1uKZ_srtd:
         const S1sVz_srt+456;
         const 38;
         const 137707388929;
 },
 _c1uIK() //  [R1]
         { info_tbl: [(c1uIK,
                       label: block_c1uIK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uIK: // global
           I64[Sp] = block_c1uIO_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uIO() //  [R1]
         { info_tbl: [(c1uIO,
                       label: block_c1uIO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uIO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1uKL; else goto c1uKK;
       c1uKL: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uKK: // global
           I64[Hp - 40] = f_s1stQ_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = f1_s1stR_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 16] = block_c1uJ6_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uJ6() //  [R1]
         { info_tbl: [(c1uJ6,
                       label: block_c1uJ6_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uJ6: // global
           _s1stJ::P64 = P64[Sp + 24];
           _s1stM::P64 = P64[Sp + 40];
           if (R1 == 1) goto c1uKT; else goto c1uKO;
       c1uKT: // global
           I64[Sp] = block_c1uJV_info;
           R2 = _s1stJ::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s1stM::P64;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c1uKO: // global
           I64[Sp] = block_c1uJa_info;
           R2 = _s1stJ::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s1stM::P64;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1uJV() //  [R1]
         { info_tbl: [(c1uJV,
                       label: block_c1uJV_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uJV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1uKW; else goto c1uKV;
       c1uKW: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uKV: // global
           I64[Hp - 24] = go_s1su1_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = P64[Sp + 32];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1su1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1uJa() //  [R1]
         { info_tbl: [(c1uJa,
                       label: block_c1uJa_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uJa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1uKR; else goto c1uKQ;
       c1uKR: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uKQ: // global
           I64[Hp - 24] = go_s1stU_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = P64[Sp + 32];
           R1 = Hp - 23;
           Sp = Sp + 48;
           call go_s1stU_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.487318062 UTC

[section ""cstring" . GHC.Real.$trModule4_bytes" {
     GHC.Real.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.489030513 UTC

[section ""data" . GHC.Real.$trModule3_closure" {
     GHC.Real.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.490814431 UTC

[section ""cstring" . GHC.Real.$trModule2_bytes" {
     GHC.Real.$trModule2_bytes:
         I8[] [71,72,67,46,82,101,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.492966469 UTC

[section ""data" . GHC.Real.$trModule1_closure" {
     GHC.Real.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.495069508 UTC

[section ""data" . GHC.Real.$trModule_closure" {
     GHC.Real.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Real.$trModule3_closure+1;
         const GHC.Real.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.496726657 UTC

[section ""data" . $krep_r1j3d_closure" {
     $krep_r1j3d_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.498417304 UTC

[section ""data" . $krep1_r1j3e_closure" {
     $krep1_r1j3e_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.499998814 UTC

[section ""data" . GHC.Real.$tcFractional1_closure" {
     GHC.Real.$tcFractional1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep1_r1j3e_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.501621281 UTC

[section ""data" . $krep2_r1j3f_closure" {
     $krep2_r1j3f_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.503283986 UTC

[section ""data" . $krep3_r1j3g_closure" {
     $krep3_r1j3g_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep2_r1j3f_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.504916896 UTC

[section ""data" . $krep4_r1j3h_closure" {
     $krep4_r1j3h_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep3_r1j3g_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.506627847 UTC

[section ""data" . $krep5_r1j3i_closure" {
     $krep5_r1j3i_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep_r1j3d_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.508323276 UTC

[section ""data" . $krep6_r1j3j_closure" {
     $krep6_r1j3j_closure:
         const :_con_info;
         const $krep2_r1j3f_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.510276978 UTC

[section ""data" . $krep7_r1j3k_closure" {
     $krep7_r1j3k_closure:
         const :_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.511923593 UTC

[section ""data" . $krep8_r1j3l_closure" {
     $krep8_r1j3l_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep7_r1j3k_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.51370724 UTC

[section ""data" . $krep9_r1j3m_closure" {
     $krep9_r1j3m_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep8_r1j3l_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.515449542 UTC

[section ""data" . $krep10_r1j3n_closure" {
     $krep10_r1j3n_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep9_r1j3m_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.517231609 UTC

[section ""data" . $krep11_r1j3o_closure" {
     $krep11_r1j3o_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Num.$tcNum_closure;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.519477394 UTC

[section ""data" . $krep12_r1j3p_closure" {
     $krep12_r1j3p_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Enum.$tcEnum_closure;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.521223454 UTC

[section ""data" . $krep13_r1j3q_closure" {
     $krep13_r1j3q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Classes.$tcOrd_closure;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.523258911 UTC

[section ""cstring" . GHC.Real.$tcRatio2_bytes" {
     GHC.Real.$tcRatio2_bytes:
         I8[] [82,97,116,105,111]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.524869912 UTC

[section ""data" . GHC.Real.$tcRatio1_closure" {
     GHC.Real.$tcRatio1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcRatio2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.526648918 UTC

[section ""data" . GHC.Real.$tcRatio_closure" {
     GHC.Real.$tcRatio_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcRatio1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 17658523810845794968;
         const 1271393732863050253;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.528452532 UTC

[section ""data" . $krep14_r1j3r_closure" {
     $krep14_r1j3r_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcRatio_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.530208623 UTC

[section ""data" . $krep15_r1j3s_closure" {
     $krep15_r1j3s_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep14_r1j3r_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.531933512 UTC

[section ""data" . GHC.Real.$tc':%1_closure" {
     GHC.Real.$tc':%1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep15_r1j3s_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.533657623 UTC

[section ""cstring" . GHC.Real.$tc':%3_bytes" {
     GHC.Real.$tc':%3_bytes:
         I8[] [39,58,37]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.535353054 UTC

[section ""data" . GHC.Real.$tc':%2_closure" {
     GHC.Real.$tc':%2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc':%3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.537008409 UTC

[section ""data" . GHC.Real.$tc':%_closure" {
     GHC.Real.$tc':%_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc':%2_closure+1;
         const GHC.Real.$tc':%1_closure+4;
         const 11952989868638128372;
         const 6861245286732044789;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.539257792 UTC

[section ""data" . $krep16_r1j3t_closure" {
     $krep16_r1j3t_closure:
         const :_con_info;
         const $krep_r1j3d_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.5410093 UTC

[section ""data" . $krep17_r1j3u_closure" {
     $krep17_r1j3u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcRatio_closure+1;
         const $krep16_r1j3t_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.542797366 UTC

[section ""data" . $krep18_r1j3v_closure" {
     $krep18_r1j3v_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r1j3f_closure+2;
         const $krep17_r1j3u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.545149716 UTC

[section ""data" . $krep19_r1j3w_closure" {
     $krep19_r1j3w_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep17_r1j3u_closure+1;
         const $krep2_r1j3f_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.54698576 UTC

[section ""cstring" . GHC.Real.$tcReal2_bytes" {
     GHC.Real.$tcReal2_bytes:
         I8[] [82,101,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.548584619 UTC

[section ""data" . GHC.Real.$tcReal1_closure" {
     GHC.Real.$tcReal1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcReal2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.550714904 UTC

[section ""data" . GHC.Real.$tcReal_closure" {
     GHC.Real.$tcReal_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcReal1_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 1826502536394630182;
         const 14487785779892251413;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.552568561 UTC

[section ""data" . $krep20_r1j3x_closure" {
     $krep20_r1j3x_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcReal_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.554371515 UTC

[section ""data" . $krep21_r1j3y_closure" {
     $krep21_r1j3y_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep18_r1j3v_closure+4;
         const $krep20_r1j3x_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.556018106 UTC

[section ""data" . $krep22_r1j3z_closure" {
     $krep22_r1j3z_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_r1j3q_closure+1;
         const $krep21_r1j3y_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.557846931 UTC

[section ""data" . GHC.Real.$tc'C:Real1_closure" {
     GHC.Real.$tc'C:Real1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1j3o_closure+1;
         const $krep22_r1j3z_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.559565139 UTC

[section ""cstring" . GHC.Real.$tc'C:Real3_bytes" {
     GHC.Real.$tc'C:Real3_bytes:
         I8[] [39,67,58,82,101,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.561835853 UTC

[section ""data" . GHC.Real.$tc'C:Real2_closure" {
     GHC.Real.$tc'C:Real2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc'C:Real3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.563557621 UTC

[section ""data" . GHC.Real.$tc'C:Real_closure" {
     GHC.Real.$tc'C:Real_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc'C:Real2_closure+1;
         const GHC.Real.$tc'C:Real1_closure+4;
         const 5938283050841830427;
         const 8926187074226767634;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.56541798 UTC

[section ""cstring" . GHC.Real.$tcIntegral2_bytes" {
     GHC.Real.$tcIntegral2_bytes:
         I8[] [73,110,116,101,103,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.567143379 UTC

[section ""data" . GHC.Real.$tcIntegral1_closure" {
     GHC.Real.$tcIntegral1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcIntegral2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.568853841 UTC

[section ""data" . GHC.Real.$tcIntegral_closure" {
     GHC.Real.$tcIntegral_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcIntegral1_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 16601157811546713973;
         const 3304955164956033666;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.571269305 UTC

[section ""data" . $krep23_r1j3A_closure" {
     $krep23_r1j3A_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcIntegral_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.5730324 UTC

[section ""data" . $krep24_r1j3B_closure" {
     $krep24_r1j3B_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r1j3i_closure+4;
         const $krep23_r1j3A_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.574760027 UTC

[section ""data" . $krep25_r1j3C_closure" {
     $krep25_r1j3C_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_r1j3n_closure+4;
         const $krep24_r1j3B_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.57643979 UTC

[section ""data" . $krep26_r1j3D_closure" {
     $krep26_r1j3D_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_r1j3n_closure+4;
         const $krep25_r1j3C_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.578230884 UTC

[section ""data" . $krep27_r1j3E_closure" {
     $krep27_r1j3E_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep26_r1j3D_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.579941588 UTC

[section ""data" . $krep28_r1j3F_closure" {
     $krep28_r1j3F_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep27_r1j3E_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.581742156 UTC

[section ""data" . $krep29_r1j3G_closure" {
     $krep29_r1j3G_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep28_r1j3F_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.583545985 UTC

[section ""data" . $krep30_r1j3H_closure" {
     $krep30_r1j3H_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep29_r1j3G_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.585206743 UTC

[section ""data" . $krep31_r1j3I_closure" {
     $krep31_r1j3I_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_r1j3p_closure+1;
         const $krep30_r1j3H_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.587380123 UTC

[section ""data" . GHC.Real.$tc'C:Integral1_closure" {
     GHC.Real.$tc'C:Integral1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep20_r1j3x_closure+1;
         const $krep31_r1j3I_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.589072459 UTC

[section ""cstring" . GHC.Real.$tc'C:Integral3_bytes" {
     GHC.Real.$tc'C:Integral3_bytes:
         I8[] [39,67,58,73,110,116,101,103,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.590793133 UTC

[section ""data" . GHC.Real.$tc'C:Integral2_closure" {
     GHC.Real.$tc'C:Integral2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc'C:Integral3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.592501416 UTC

[section ""data" . GHC.Real.$tc'C:Integral_closure" {
     GHC.Real.$tc'C:Integral_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc'C:Integral2_closure+1;
         const GHC.Real.$tc'C:Integral1_closure+4;
         const 12141017740256829283;
         const 17564033539811245778;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.594369374 UTC

[section ""cstring" . GHC.Real.$tcFractional3_bytes" {
     GHC.Real.$tcFractional3_bytes:
         I8[] [70,114,97,99,116,105,111,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.59652465 UTC

[section ""data" . GHC.Real.$tcFractional2_closure" {
     GHC.Real.$tcFractional2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcFractional3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.598263243 UTC

[section ""data" . GHC.Real.$tcFractional_closure" {
     GHC.Real.$tcFractional_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcFractional2_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 14968870971062750857;
         const 13774835939651899219;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.600102869 UTC

[section ""data" . $krep32_r1j3J_closure" {
     $krep32_r1j3J_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Real.$tcFractional_closure+1;
         const $krep6_r1j3j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.602174511 UTC

[section ""data" . $krep33_r1j3K_closure" {
     $krep33_r1j3K_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep19_r1j3w_closure+4;
         const $krep32_r1j3J_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.603831722 UTC

[section ""data" . $krep34_r1j3L_closure" {
     $krep34_r1j3L_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r1j3g_closure+4;
         const $krep33_r1j3K_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.605621471 UTC

[section ""data" . $krep35_r1j3M_closure" {
     $krep35_r1j3M_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r1j3h_closure+4;
         const $krep34_r1j3L_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.607391841 UTC

[section ""data" . GHC.Real.$tc'C:Fractional1_closure" {
     GHC.Real.$tc'C:Fractional1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1j3o_closure+1;
         const $krep35_r1j3M_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.609178795 UTC

[section ""cstring" . GHC.Real.$tc'C:Fractional3_bytes" {
     GHC.Real.$tc'C:Fractional3_bytes:
         I8[] [39,67,58,70,114,97,99,116,105,111,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.611601532 UTC

[section ""data" . GHC.Real.$tc'C:Fractional2_closure" {
     GHC.Real.$tc'C:Fractional2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tc'C:Fractional3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.613324065 UTC

[section ""data" . GHC.Real.$tc'C:Fractional_closure" {
     GHC.Real.$tc'C:Fractional_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tc'C:Fractional2_closure+1;
         const GHC.Real.$tc'C:Fractional1_closure+4;
         const 15706435530565718930;
         const 11021884564355505453;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.615194334 UTC

[section ""cstring" . GHC.Real.$tcRealFrac2_bytes" {
     GHC.Real.$tcRealFrac2_bytes:
         I8[] [82,101,97,108,70,114,97,99]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.616840221 UTC

[section ""data" . GHC.Real.$tcRealFrac1_closure" {
     GHC.Real.$tcRealFrac1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Real.$tcRealFrac2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.618638135 UTC

[section ""data" . GHC.Real.$tcRealFrac_closure" {
     GHC.Real.$tcRealFrac_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Real.$trModule_closure+1;
         const GHC.Real.$tcRealFrac1_closure+1;
         const GHC.Real.$tcFractional1_closure+4;
         const 2318913099678420819;
         const 6373121509494083706;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.621510631 UTC

[section ""data" . GHC.Real.$w$c<_closure" {
     GHC.Real.$w$c<_closure:
         const GHC.Real.$w$c<_info;
 },
 $dNum_s1sud_entry() //  [R1]
         { info_tbl: [(c1uOv,
                       label: $dNum_s1sud_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uOv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1uOw; else goto c1uOx;
       c1uOw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uOx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sug_entry() //  [R1]
         { info_tbl: [(c1uOC,
                       label: sat_s1sug_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uOC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uOD; else goto c1uOE;
       c1uOD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uOE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1suf_entry() //  [R1]
         { info_tbl: [(c1uOJ,
                       label: sat_s1suf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uOJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uOK; else goto c1uOL;
       c1uOK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uOL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1uOM,
                       label: GHC.Real.$w$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uOM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uOO; else goto c1uOP;
       c1uOO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uOP: // global
           I64[Sp - 40] = block_c1uOn_info;
           R2 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uOn() //  [R1]
         { info_tbl: [(c1uOn,
                       label: block_c1uOn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uOn: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c1uOS; else goto c1uOR;
       c1uOS: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uOR: // global
           I64[Hp - 96] = $dNum_s1sud_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s1sug_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           _c1uOr::P64 = Hp - 96;
           P64[Hp - 40] = _c1uOr::P64;
           I64[Hp - 32] = sat_s1suf_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _c1uOr::P64;
           I64[Sp + 16] = block_c1uON_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uON() //  [R1]
         { info_tbl: [(c1uON,
                       label: block_c1uON_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uON: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.<_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.636519124 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c<_closure" {
     GHC.Real.$fOrdRatio_$c<_closure:
         const GHC.Real.$fOrdRatio_$c<_info;
 },
 GHC.Real.$fOrdRatio_$c<_entry() //  [R2, R3, R4]
         { info_tbl: [(c1uPM,
                       label: GHC.Real.$fOrdRatio_$c<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uPM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uPQ; else goto c1uPR;
       c1uPQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uPR: // global
           I64[Sp - 24] = block_c1uPJ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1uPZ; else goto c1uPK;
       u1uPZ: // global
           call _c1uPJ(R1) args: 0, res: 0, upd: 0;
       c1uPK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uPJ() //  [R1]
         { info_tbl: [(c1uPJ,
                       label: block_c1uPJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uPJ: // global
           I64[Sp - 8] = block_c1uPP_info;
           _s1sul::P64 = P64[R1 + 7];
           _s1sum::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1sum::P64;
           P64[Sp + 16] = _s1sul::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1uPY; else goto c1uPT;
       u1uPY: // global
           call _c1uPP(R1) args: 0, res: 0, upd: 0;
       c1uPT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uPP() //  [R1]
         { info_tbl: [(c1uPP,
                       label: block_c1uPP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uPP: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.644907037 UTC

[section ""data" . GHC.Real.$w$c<=_closure" {
     GHC.Real.$w$c<=_closure:
         const GHC.Real.$w$c<=_info;
 },
 $dNum_s1suw_entry() //  [R1]
         { info_tbl: [(c1uQr,
                       label: $dNum_s1suw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uQr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1uQs; else goto c1uQt;
       c1uQs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uQt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1suz_entry() //  [R1]
         { info_tbl: [(c1uQy,
                       label: sat_s1suz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uQy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uQz; else goto c1uQA;
       c1uQz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uQA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1suy_entry() //  [R1]
         { info_tbl: [(c1uQF,
                       label: sat_s1suy_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uQF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uQG; else goto c1uQH;
       c1uQG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uQH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1uQI,
                       label: GHC.Real.$w$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uQI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uQK; else goto c1uQL;
       c1uQK: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uQL: // global
           I64[Sp - 40] = block_c1uQj_info;
           R2 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uQj() //  [R1]
         { info_tbl: [(c1uQj,
                       label: block_c1uQj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uQj: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c1uQO; else goto c1uQN;
       c1uQO: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1uQN: // global
           I64[Hp - 96] = $dNum_s1suw_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s1suz_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           _c1uQn::P64 = Hp - 96;
           P64[Hp - 40] = _c1uQn::P64;
           I64[Hp - 32] = sat_s1suy_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _c1uQn::P64;
           I64[Sp + 16] = block_c1uQJ_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uQJ() //  [R1]
         { info_tbl: [(c1uQJ,
                       label: block_c1uQJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uQJ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.<=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.659442193 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c<=_closure" {
     GHC.Real.$fOrdRatio_$c<=_closure:
         const GHC.Real.$fOrdRatio_$c<=_info;
 },
 GHC.Real.$fOrdRatio_$c<=_entry() //  [R2, R3, R4]
         { info_tbl: [(c1uRI,
                       label: GHC.Real.$fOrdRatio_$c<=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uRI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uRM; else goto c1uRN;
       c1uRM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uRN: // global
           I64[Sp - 24] = block_c1uRF_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1uRV; else goto c1uRG;
       u1uRV: // global
           call _c1uRF(R1) args: 0, res: 0, upd: 0;
       c1uRG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uRF() //  [R1]
         { info_tbl: [(c1uRF,
                       label: block_c1uRF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uRF: // global
           I64[Sp - 8] = block_c1uRL_info;
           _s1suE::P64 = P64[R1 + 7];
           _s1suF::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1suF::P64;
           P64[Sp + 16] = _s1suE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1uRU; else goto c1uRP;
       u1uRU: // global
           call _c1uRL(R1) args: 0, res: 0, upd: 0;
       c1uRP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uRL() //  [R1]
         { info_tbl: [(c1uRL,
                       label: block_c1uRL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uRL: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.667408794 UTC

[section ""data" . GHC.Real.$fOrdRatio_$cmax_closure" {
     GHC.Real.$fOrdRatio_$cmax_closure:
         const GHC.Real.$fOrdRatio_$cmax_info;
 },
 GHC.Real.$fOrdRatio_$cmax_entry() //  [R2, R3, R4]
         { info_tbl: [(c1uSi,
                       label: GHC.Real.$fOrdRatio_$cmax_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uSi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uSm; else goto c1uSn;
       c1uSm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uSn: // global
           I64[Sp - 24] = block_c1uSf_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1uSH; else goto c1uSg;
       u1uSH: // global
           call _c1uSf(R1) args: 0, res: 0, upd: 0;
       c1uSg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uSf() //  [R1]
         { info_tbl: [(c1uSf,
                       label: block_c1uSf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uSf: // global
           I64[Sp - 16] = block_c1uSl_info;
           _s1suM::P64 = R1;
           _s1suN::P64 = P64[R1 + 7];
           _s1suO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s1suO::P64;
           P64[Sp] = _s1suN::P64;
           P64[Sp + 16] = _s1suM::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1uSG; else goto c1uSp;
       u1uSG: // global
           call _c1uSl(R1) args: 0, res: 0, upd: 0;
       c1uSp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uSl() //  [R1]
         { info_tbl: [(c1uSl,
                       label: block_c1uSl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uSl: // global
           _s1suN::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1uSt_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1suN::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uSt() //  [R1]
         { info_tbl: [(c1uSt,
                       label: block_c1uSt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uSt: // global
           if (R1 & 7 == 1) goto c1uSA; else goto c1uSE;
       c1uSA: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1uSE: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.677028342 UTC

[section ""data" . GHC.Real.$fOrdRatio_$cmin_closure" {
     GHC.Real.$fOrdRatio_$cmin_closure:
         const GHC.Real.$fOrdRatio_$cmin_info;
 },
 GHC.Real.$fOrdRatio_$cmin_entry() //  [R2, R3, R4]
         { info_tbl: [(c1uTe,
                       label: GHC.Real.$fOrdRatio_$cmin_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uTe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1uTi; else goto c1uTj;
       c1uTi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uTj: // global
           I64[Sp - 24] = block_c1uTb_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1uTD; else goto c1uTc;
       u1uTD: // global
           call _c1uTb(R1) args: 0, res: 0, upd: 0;
       c1uTc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uTb() //  [R1]
         { info_tbl: [(c1uTb,
                       label: block_c1uTb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uTb: // global
           I64[Sp - 16] = block_c1uTh_info;
           _s1suW::P64 = R1;
           _s1suX::P64 = P64[R1 + 7];
           _s1suY::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s1suY::P64;
           P64[Sp] = _s1suX::P64;
           P64[Sp + 16] = _s1suW::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1uTC; else goto c1uTl;
       u1uTC: // global
           call _c1uTh(R1) args: 0, res: 0, upd: 0;
       c1uTl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uTh() //  [R1]
         { info_tbl: [(c1uTh,
                       label: block_c1uTh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uTh: // global
           _s1suX::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1uTp_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1suX::P64;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uTp() //  [R1]
         { info_tbl: [(c1uTp,
                       label: block_c1uTp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uTp: // global
           if (R1 & 7 == 1) goto c1uTw; else goto c1uTA;
       c1uTw: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1uTA: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.687583969 UTC

[section ""data" . GHC.Real.$w$ccompare_closure" {
     GHC.Real.$w$ccompare_closure:
         const GHC.Real.$w$ccompare_info;
 },
 GHC.Real.$w$ccompare_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1uU9,
                       label: GHC.Real.$w$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uU9: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c1uUh; else goto c1uUi;
       c1uUh: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uUi: // global
           I64[Sp - 48] = block_c1uU7_info;
           _s1sv3::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = _s1sv3::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uU7() //  [R1]
         { info_tbl: [(c1uU7,
                       label: block_c1uU7_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uU7: // global
           I64[Sp] = block_c1uUc_info;
           R2 = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uUc() //  [R1]
         { info_tbl: [(c1uUc,
                       label: block_c1uUc_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uUc: // global
           I64[Sp] = block_c1uUg_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uUg() //  [R1]
         { info_tbl: [(c1uUg,
                       label: block_c1uUg_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uUg: // global
           I64[Sp - 8] = block_c1uUo_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1uUo() //  [R1]
         { info_tbl: [(c1uUo,
                       label: block_c1uUo_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uUo: // global
           _s1sv5::P64 = P64[Sp + 32];
           _s1sv7::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto c1uUw; else goto c1uUL;
       c1uUw: // global
           I64[Sp + 48] = block_c1uUt_info;
           R6 = _s1sv7::P64;
           R5 = P64[Sp + 40];
           R4 = _s1sv5::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 48;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
       c1uUL: // global
           _s1sva::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1uUJ_info;
           R2 = _s1sva::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s1sv5::P64;
           P64[Sp] = _s1sv7::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1uUt() //  [R1]
         { info_tbl: [(c1uUt,
                       label: block_c1uUt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uUt: // global
           if (R1 & 7 == 1) goto u1uVd; else goto u1uVe;
       u1uVd: // global
           Sp = Sp + 8;
           call _c1uUY() args: 0, res: 0, upd: 0;
       u1uVe: // global
           Sp = Sp + 8;
           call _c1uV2() args: 0, res: 0, upd: 0;
     }
 },
 _c1uUJ() //  [R1]
         { info_tbl: [(c1uUJ,
                       label: block_c1uUJ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uUJ: // global
           if (R1 & 7 == 1) goto c1uUS; else goto c1uV6;
       c1uUS: // global
           _s1sv7::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_c1uUP_info;
           R6 = _s1sv7::P64;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call GHC.Real.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 8, upd: 8;
       c1uV6: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1uUP() //  [R1]
         { info_tbl: [(c1uUP,
                       label: block_c1uUP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uUP: // global
           if (R1 & 7 == 1) goto u1uVb; else goto u1uVc;
       u1uVb: // global
           Sp = Sp + 8;
           call _c1uUY() args: 0, res: 0, upd: 0;
       u1uVc: // global
           Sp = Sp + 8;
           call _c1uV2() args: 0, res: 0, upd: 0;
     }
 },
 _c1uUY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uUY: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1uV2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uV2: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.707364493 UTC

[section ""data" . GHC.Real.$fOrdRatio_$ccompare_closure" {
     GHC.Real.$fOrdRatio_$ccompare_closure:
         const GHC.Real.$fOrdRatio_$ccompare_info;
 },
 GHC.Real.$fOrdRatio_$ccompare_entry() //  [R2, R3, R4]
         { info_tbl: [(c1uWj,
                       label: GHC.Real.$fOrdRatio_$ccompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uWj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uWn; else goto c1uWo;
       c1uWn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uWo: // global
           I64[Sp - 24] = block_c1uWg_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1uWw; else goto c1uWh;
       u1uWw: // global
           call _c1uWg(R1) args: 0, res: 0, upd: 0;
       c1uWh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uWg() //  [R1]
         { info_tbl: [(c1uWg,
                       label: block_c1uWg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uWg: // global
           I64[Sp - 8] = block_c1uWm_info;
           _s1svj::P64 = P64[R1 + 7];
           _s1svk::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1svk::P64;
           P64[Sp + 16] = _s1svj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1uWv; else goto c1uWq;
       u1uWv: // global
           call _c1uWm(R1) args: 0, res: 0, upd: 0;
       c1uWq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uWm() //  [R1]
         { info_tbl: [(c1uWm,
                       label: block_c1uWm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uWm: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.715958445 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c>_closure" {
     GHC.Real.$fOrdRatio_$c>_closure:
         const GHC.Real.$fOrdRatio_$c>_info;
 },
 GHC.Real.$fOrdRatio_$c>_entry() //  [R2, R3, R4]
         { info_tbl: [(c1uWT,
                       label: GHC.Real.$fOrdRatio_$c>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uWT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uWX; else goto c1uWY;
       c1uWX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uWY: // global
           I64[Sp - 24] = block_c1uWQ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1uXi; else goto c1uWR;
       u1uXi: // global
           call _c1uWQ(R1) args: 0, res: 0, upd: 0;
       c1uWR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uWQ() //  [R1]
         { info_tbl: [(c1uWQ,
                       label: block_c1uWQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uWQ: // global
           I64[Sp - 8] = block_c1uWW_info;
           _s1svs::P64 = P64[R1 + 7];
           _s1svt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1svt::P64;
           P64[Sp + 16] = _s1svs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1uXh; else goto c1uX0;
       u1uXh: // global
           call _c1uWW(R1) args: 0, res: 0, upd: 0;
       c1uX0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uWW() //  [R1]
         { info_tbl: [(c1uWW,
                       label: block_c1uWW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uWW: // global
           _s1svs::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1uX4_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1svs::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uX4() //  [R1]
         { info_tbl: [(c1uX4,
                       label: block_c1uX4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uX4: // global
           if (R1 & 7 == 3) goto c1uXf; else goto c1uXb;
       c1uXf: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1uXb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.726802968 UTC

[section ""data" . GHC.Real.$fOrdRatio_$c>=_closure" {
     GHC.Real.$fOrdRatio_$c>=_closure:
         const GHC.Real.$fOrdRatio_$c>=_info;
 },
 GHC.Real.$fOrdRatio_$c>=_entry() //  [R2, R3, R4]
         { info_tbl: [(c1uXP,
                       label: GHC.Real.$fOrdRatio_$c>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uXP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1uXT; else goto c1uXU;
       c1uXT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1uXU: // global
           I64[Sp - 24] = block_c1uXM_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1uYe; else goto c1uXN;
       u1uYe: // global
           call _c1uXM(R1) args: 0, res: 0, upd: 0;
       c1uXN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uXM() //  [R1]
         { info_tbl: [(c1uXM,
                       label: block_c1uXM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uXM: // global
           I64[Sp - 8] = block_c1uXS_info;
           _s1svC::P64 = P64[R1 + 7];
           _s1svD::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1svD::P64;
           P64[Sp + 16] = _s1svC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1uYd; else goto c1uXW;
       u1uYd: // global
           call _c1uXS(R1) args: 0, res: 0, upd: 0;
       c1uXW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1uXS() //  [R1]
         { info_tbl: [(c1uXS,
                       label: block_c1uXS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uXS: // global
           _s1svC::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1uY0_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1svC::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1uY0() //  [R1]
         { info_tbl: [(c1uY0,
                       label: block_c1uY0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uY0: // global
           if (R1 & 7 == 1) goto c1uYb; else goto c1uY7;
       c1uYb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1uY7: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.737649088 UTC

[section ""data" . GHC.Real.$fOrdRatio_closure" {
     GHC.Real.$fOrdRatio_closure:
         const GHC.Real.$fOrdRatio_info;
 },
 sat_s1svQ_entry() //  [R1, R2, R3]
         { info_tbl: [(c1uYN,
                       label: sat_s1svQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uYN: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1svP_entry() //  [R1, R2, R3]
         { info_tbl: [(c1uYV,
                       label: sat_s1svP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uYV: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1svO_entry() //  [R1, R2, R3]
         { info_tbl: [(c1uZ3,
                       label: sat_s1svO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uZ3: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1svN_entry() //  [R1, R2, R3]
         { info_tbl: [(c1uZb,
                       label: sat_s1svN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uZb: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c>_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1svM_entry() //  [R1, R2, R3]
         { info_tbl: [(c1uZj,
                       label: sat_s1svM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uZj: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1svL_entry() //  [R1, R2, R3]
         { info_tbl: [(c1uZr,
                       label: sat_s1svL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uZr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1svK_entry() //  [R1, R2, R3]
         { info_tbl: [(c1uZz,
                       label: sat_s1svK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uZz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fOrdRatio_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1svJ_entry() //  [R1]
         { info_tbl: [(c1uZG,
                       label: sat_s1svJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uZG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1uZH; else goto c1uZI;
       c1uZH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1uZI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fOrdRatio_entry() //  [R2]
         { info_tbl: [(c1uZK,
                       label: GHC.Real.$fOrdRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1uZK: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c1uZO; else goto c1uZN;
       c1uZO: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Real.$fOrdRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1uZN: // global
           I64[Hp - 200] = sat_s1svQ_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s1svP_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s1svO_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1svN_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s1svM_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s1svL_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s1svK_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s1svJ_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.757233161 UTC

[section ""data" . GHC.Real.$fNumRatio_$cnegate_closure" {
     GHC.Real.$fNumRatio_$cnegate_closure:
         const GHC.Real.$fNumRatio_$cnegate_info;
 },
 GHC.Real.$fNumRatio_$cnegate_entry() //  [R2, R3]
         { info_tbl: [(c1v0I,
                       label: GHC.Real.$fNumRatio_$cnegate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v0I: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1v0W; else goto c1v0X;
       c1v0W: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$cnegate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1v0X: // global
           I64[Sp - 16] = block_c1v0F_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1v14; else goto c1v0G;
       u1v14: // global
           call _c1v0F(R1) args: 0, res: 0, upd: 0;
       c1v0G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1v0F() //  [R1]
         { info_tbl: [(c1v0F,
                       label: block_c1v0F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v0F: // global
           I64[Sp - 8] = block_c1v0L_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1v0L() //  [R1]
         { info_tbl: [(c1v0L,
                       label: block_c1v0L_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v0L: // global
           I64[Sp] = block_c1v0P_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1v0P() //  [R1]
         { info_tbl: [(c1v0P,
                       label: block_c1v0P_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v0P: // global
           I64[Sp] = block_c1v0T_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1v0T() //  [R1]
         { info_tbl: [(c1v0T,
                       label: block_c1v0T_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v0T: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1v13; else goto c1v12;
       c1v13: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1v12: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.768461636 UTC

[section ""data" . GHC.Real.$fNumRatio_$cabs_closure" {
     GHC.Real.$fNumRatio_$cabs_closure:
         const GHC.Real.$fNumRatio_$cabs_info;
 },
 GHC.Real.$fNumRatio_$cabs_entry() //  [R2, R3]
         { info_tbl: [(c1v1F,
                       label: GHC.Real.$fNumRatio_$cabs_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v1F: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1v1T; else goto c1v1U;
       c1v1T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$cabs_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1v1U: // global
           I64[Sp - 16] = block_c1v1C_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1v21; else goto c1v1D;
       u1v21: // global
           call _c1v1C(R1) args: 0, res: 0, upd: 0;
       c1v1D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1v1C() //  [R1]
         { info_tbl: [(c1v1C,
                       label: block_c1v1C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v1C: // global
           I64[Sp - 8] = block_c1v1I_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1v1I() //  [R1]
         { info_tbl: [(c1v1I,
                       label: block_c1v1I_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v1I: // global
           I64[Sp] = block_c1v1M_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1v1M() //  [R1]
         { info_tbl: [(c1v1M,
                       label: block_c1v1M_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v1M: // global
           I64[Sp] = block_c1v1Q_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1v1Q() //  [R1]
         { info_tbl: [(c1v1Q,
                       label: block_c1v1Q_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v1Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1v20; else goto c1v1Z;
       c1v20: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1v1Z: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.779683862 UTC

[section ""data" . GHC.Real.$w$csignum_closure" {
     GHC.Real.$w$csignum_closure:
         const GHC.Real.$w$csignum_info;
         const 0;
 },
 GHC.Real.$w$csignum_entry() //  [R2, R3]
         { info_tbl: [(c1v2B,
                       label: GHC.Real.$w$csignum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v2B: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1v2L; else goto c1v2M;
       c1v2L: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$csignum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1v2M: // global
           I64[Sp - 16] = block_c1v2z_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1v2z() //  [R1]
         { info_tbl: [(c1v2z,
                       label: block_c1v2z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v2z: // global
           I64[Sp] = block_c1v2E_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1v2E() //  [R1]
         { info_tbl: [(c1v2E,
                       label: block_c1v2E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v2E: // global
           I64[Sp] = block_c1v2I_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1v2I() //  [R1]
         { info_tbl: [(c1v2I,
                       label: block_c1v2I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v2I: // global
           I64[Sp] = block_c1v2K_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Real.$fEnumRatio1_closure;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1v2K() //  [R1]
         { info_tbl: [(c1v2K,
                       label: block_c1v2K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v2K: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.791339402 UTC

[section ""data" . GHC.Real.$fNumRatio_$csignum_closure" {
     GHC.Real.$fNumRatio_$csignum_closure:
         const GHC.Real.$fNumRatio_$csignum_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$csignum_entry() //  [R2, R3]
         { info_tbl: [(c1v3p,
                       label: GHC.Real.$fNumRatio_$csignum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v3p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1v3v; else goto c1v3w;
       c1v3v: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$csignum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1v3w: // global
           I64[Sp - 16] = block_c1v3m_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1v3B; else goto c1v3n;
       u1v3B: // global
           call _c1v3m(R1) args: 0, res: 0, upd: 0;
       c1v3n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1v3m() //  [R1]
         { info_tbl: [(c1v3m,
                       label: block_c1v3m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v3m: // global
           _s1swd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1v3s_info;
           R3 = P64[R1 + 7];
           R2 = _s1swd::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$csignum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1v3s() //  [R1, R2]
         { info_tbl: [(c1v3s,
                       label: block_c1v3s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v3s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1v3A; else goto c1v3z;
       c1v3A: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1v3z: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.799532671 UTC

[section ""data" . GHC.Real.$w$cfromInteger_closure" {
     GHC.Real.$w$cfromInteger_closure:
         const GHC.Real.$w$cfromInteger_info;
         const 0;
 },
 GHC.Real.$w$cfromInteger_entry() //  [R2, R3]
         { info_tbl: [(c1v3Y,
                       label: GHC.Real.$w$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v3Y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1v48; else goto c1v49;
       c1v48: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cfromInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1v49: // global
           I64[Sp - 16] = block_c1v3W_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1v3W() //  [R1]
         { info_tbl: [(c1v3W,
                       label: block_c1v3W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v3W: // global
           I64[Sp] = block_c1v41_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1v41() //  [R1]
         { info_tbl: [(c1v41,
                       label: block_c1v41_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v41: // global
           I64[Sp] = block_c1v45_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1v45() //  [R1]
         { info_tbl: [(c1v45,
                       label: block_c1v45_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v45: // global
           I64[Sp] = block_c1v47_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Real.$fEnumRatio1_closure;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1v47() //  [R1]
         { info_tbl: [(c1v47,
                       label: block_c1v47_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v47: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.810370719 UTC

[section ""data" . GHC.Real.$fNumRatio_$cfromInteger_closure" {
     GHC.Real.$fNumRatio_$cfromInteger_closure:
         const GHC.Real.$fNumRatio_$cfromInteger_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$cfromInteger_entry() //  [R2, R3]
         { info_tbl: [(c1v4M,
                       label: GHC.Real.$fNumRatio_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v4M: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1v4N; else goto c1v4O;
       c1v4N: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$cfromInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1v4O: // global
           I64[Sp - 8] = block_c1v4J_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1v4J() //  [R1, R2]
         { info_tbl: [(c1v4J,
                       label: block_c1v4J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v4J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1v4R; else goto c1v4Q;
       c1v4R: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1v4Q: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.816339304 UTC

[section ""data" . GHC.Real.$fRealRatio_$s$ctoRational_closure" {
     GHC.Real.$fRealRatio_$s$ctoRational_closure:
         const GHC.Real.$fRealRatio_$s$ctoRational_info;
 },
 GHC.Real.$fRealRatio_$s$ctoRational_entry() //  [R2]
         { info_tbl: [(c1v57,
                       label: GHC.Real.$fRealRatio_$s$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v57: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.820842501 UTC

[section ""data" . GHC.Real.$fRealRatio_$ctoRational_closure" {
     GHC.Real.$fRealRatio_$ctoRational_closure:
         const GHC.Real.$fRealRatio_$ctoRational_info;
 },
 GHC.Real.$fRealRatio_$ctoRational_entry() //  [R2, R3]
         { info_tbl: [(c1v5n,
                       label: GHC.Real.$fRealRatio_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v5n: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1v5z; else goto c1v5A;
       c1v5z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealRatio_$ctoRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1v5A: // global
           I64[Sp - 16] = block_c1v5k_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1v5G; else goto c1v5l;
       u1v5G: // global
           call _c1v5k(R1) args: 0, res: 0, upd: 0;
       c1v5l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1v5k() //  [R1]
         { info_tbl: [(c1v5k,
                       label: block_c1v5k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v5k: // global
           I64[Sp - 8] = block_c1v5q_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1v5q() //  [R1]
         { info_tbl: [(c1v5q,
                       label: block_c1v5q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v5q: // global
           _s1swB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1v5u_info;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = _s1swB::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 8;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1v5u() //  [R1]
         { info_tbl: [(c1v5u,
                       label: block_c1v5u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v5u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1v5F; else goto c1v5E;
       c1v5F: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1v5E: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.831512133 UTC

[section ""data" . GHC.Real.$w$crecip_closure" {
     GHC.Real.$w$crecip_closure:
         const GHC.Real.$w$crecip_info;
         const 0;
 },
 $dNum_s1swI_entry() //  [R1]
         { info_tbl: [(c1v6i,
                       label: $dNum_s1swI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v6i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1v6j; else goto c1v6k;
       c1v6j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1v6k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1swL_entry() //  [R1]
         { info_tbl: [(c1v6t,
                       label: sat_s1swL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v6t: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1v6u; else goto c1v6v;
       c1v6u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1v6v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1swN_entry() //  [R1]
         { info_tbl: [(c1v6I,
                       label: sat_s1swN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v6I: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1v6J; else goto c1v6K;
       c1v6J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1v6K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1v7n_srtd" {
     u1v7n_srtd:
         const S1sVz_srt+296;
         const 66;
         const 281474976710657;
         const 2;
 },
 GHC.Real.$w$crecip_entry() //  [R2, R3, R4]
         { info_tbl: [(c1v6L,
                       label: GHC.Real.$w$crecip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v6L: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1v6M; else goto c1v6N;
       c1v6M: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$crecip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1v6N: // global
           I64[Sp - 24] = block_c1v6a_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1v7o_srtd" {
     u1v7o_srtd:
         const S1sVz_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1v6a() //  [R1]
         { info_tbl: [(c1v6a,
                       label: block_c1v6a_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v6a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1v6Q; else goto c1v6P;
       c1v6Q: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1v6P: // global
           I64[Hp - 16] = $dNum_s1swI_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1v6l_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1v7p_srtd" {
     u1v7p_srtd:
         const S1sVz_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1v6l() //  [R1]
         { info_tbl: [(c1v6l,
                       label: block_c1v6l_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v6l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1v6T; else goto c1v6S;
       c1v6T: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1v6S: // global
           I64[Hp - 16] = sat_s1swL_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = block_c1v6w_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1v7q_srtd" {
     u1v7q_srtd:
         const S1sVz_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1v6w() //  [R1]
         { info_tbl: [(c1v6w,
                       label: block_c1v6w_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v6w: // global
           I64[Sp] = block_c1v6A_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1v7r_srtd" {
     u1v7r_srtd:
         const S1sVz_srt+296;
         const 49;
         const 281474976710657;
 },
 _c1v6A() //  [R1]
         { info_tbl: [(c1v6A,
                       label: block_c1v6A_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v6A: // global
           if (R1 & 7 == 1) goto c1v6X; else goto c1v7k;
       c1v6X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1v70; else goto c1v6Z;
       c1v70: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1v6Z: // global
           I64[Hp - 16] = sat_s1swN_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 16] = block_c1v6V_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 32];
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
       c1v7k: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1v6V() //  [R1]
         { info_tbl: [(c1v6V,
                       label: block_c1v6V_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v6V: // global
           _s1swG::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c1v76; else goto c1v7d;
       c1v76: // global
           R2 = P64[Sp + 16];
           R1 = _s1swG::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c1v7d: // global
           I64[Sp] = block_c1v79_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s1swG::P64;
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1v79() //  [R1]
         { info_tbl: [(c1v79,
                       label: block_c1v79_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v79: // global
           _s1swF::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1v7b_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = _s1swF::P64;
           P64[Sp + 24] = R1;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1v7b() //  [R1]
         { info_tbl: [(c1v7b,
                       label: block_c1v7b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v7b: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.859319117 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$crecip_closure" {
     GHC.Real.$fFractionalRatio_$crecip_closure:
         const GHC.Real.$fFractionalRatio_$crecip_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$crecip_entry() //  [R2, R3]
         { info_tbl: [(c1v8P,
                       label: GHC.Real.$fFractionalRatio_$crecip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v8P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1v8V; else goto c1v8W;
       c1v8V: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$crecip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1v8W: // global
           I64[Sp - 16] = block_c1v8M_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1v91; else goto c1v8N;
       u1v91: // global
           call _c1v8M(R1) args: 0, res: 0, upd: 0;
       c1v8N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1v8M() //  [R1]
         { info_tbl: [(c1v8M,
                       label: block_c1v8M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v8M: // global
           _s1swS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1v8S_info;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = _s1swS::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$crecip_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1v8S() //  [R1, R2]
         { info_tbl: [(c1v8S,
                       label: block_c1v8S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v8S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1v90; else goto c1v8Z;
       c1v90: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1v8Z: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.868094198 UTC

[section ""data" . GHC.Real.$w$s$cproperFraction_closure" {
     GHC.Real.$w$s$cproperFraction_closure:
         const GHC.Real.$w$s$cproperFraction_info;
         const 0;
 },
 section ""relreadonly" . u1vax_srtd" {
     u1vax_srtd:
         const S1sVz_srt+424;
         const 33;
         const 4294967297;
 },
 ds_s1sx3_entry() //  [R1]
         { info_tbl: [(c1v9v,
                       label: ds_s1sx3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v9v: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1v9w; else goto c1v9x;
       c1v9w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1v9x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c1v9q_info;
           R3 = GHC.Real.even1_closure;
           _s1sx2::P64 = P64[R1 + 24];
           R2 = _s1sx2::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s1sx2::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1v9q() //  [R1]
         { info_tbl: [(c1v9q,
                       label: block_c1v9q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v9q: // global
           if (R1 == 1) goto c1v9u; else goto c1v9t;
       c1v9u: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c1v9t: // global
           _s1sx2::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1v9A_info;
           R3 = _s1sx2::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1v9A() //  [R1, R2]
         { info_tbl: [(c1v9A,
                       label: block_c1v9A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v9A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1v9G; else goto c1v9F;
       c1v9G: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1v9F: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sxj_entry() //  [R1]
         { info_tbl: [(c1v9R,
                       label: sat_s1sxj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v9R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1va0; else goto c1va1;
       c1va0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1va1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1v9O_info;
           _s1sx2::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s1sx2::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1va7; else goto c1v9P;
       u1va7: // global
           call _c1v9O(R1) args: 0, res: 0, upd: 0;
       c1v9P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1v9O() //  [R1]
         { info_tbl: [(c1v9O,
                       label: block_c1v9O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v9O: // global
           I64[Sp] = block_c1v9U_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto u1va6; else goto c1v9V;
       u1va6: // global
           call _c1v9U(R1) args: 0, res: 0, upd: 0;
       c1v9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1v9U() //  [R1]
         { info_tbl: [(c1v9U,
                       label: block_c1v9U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1v9U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1va5; else goto c1va4;
       c1va5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1va4: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sxe_entry() //  [R1]
         { info_tbl: [(c1vaf,
                       label: sat_s1sxe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vaf: // global
           _s1sxe::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1vaj; else goto c1vak;
       c1vak: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vam; else goto c1val;
       c1vam: // global
           HpAlloc = 24;
           goto c1vaj;
       c1vaj: // global
           R1 = _s1sxe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1val: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sxe::P64;
           _s1sx0::P64 = P64[_s1sxe::P64 + 16];
           _s1sx3::P64 = P64[_s1sxe::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1sx3::P64;
           I64[Sp - 32] = block_c1vad_info;
           R2 = _s1sx0::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1vad() //  [R1]
         { info_tbl: [(c1vad,
                       label: block_c1vad_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vad: // global
           I64[Sp] = block_c1vai_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1vai() //  [R1]
         { info_tbl: [(c1vai,
                       label: block_c1vai_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vai: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$s$cproperFraction_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vas,
                       label: GHC.Real.$w$s$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vas: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1vaw; else goto c1vav;
       c1vaw: // global
           HpAlloc = 96;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vav: // global
           I64[Hp - 88] = ds_s1sx3_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_s1sxj_info;
           P64[Hp - 40] = R4;
           _c1v9m::P64 = Hp - 88;
           P64[Hp - 32] = _c1v9m::P64;
           I64[Hp - 24] = sat_s1sxe_info;
           P64[Hp - 8] = R2;
           P64[Hp] = _c1v9m::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.89140851 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$cproperFraction_closure" {
     GHC.Real.$fEnumRatio_$s$cproperFraction_closure:
         const GHC.Real.$fEnumRatio_$s$cproperFraction_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$cproperFraction_entry() //  [R2, R3]
         { info_tbl: [(c1vbC,
                       label: GHC.Real.$fEnumRatio_$s$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vbC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vbI; else goto c1vbJ;
       c1vbI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$cproperFraction_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vbJ: // global
           I64[Sp - 16] = block_c1vbz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1vbO; else goto c1vbA;
       u1vbO: // global
           call _c1vbz(R1) args: 0, res: 0, upd: 0;
       c1vbA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vbz() //  [R1]
         { info_tbl: [(c1vbz,
                       label: block_c1vbz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vbz: // global
           _s1sxk::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1vbF_info;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = _s1sxk::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vbF() //  [R1, R2]
         { info_tbl: [(c1vbF,
                       label: block_c1vbF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vbF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vbN; else goto c1vbM;
       c1vbN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vbM: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.900128977 UTC

[section ""data" . GHC.Real.$w$cproperFraction_closure" {
     GHC.Real.$w$cproperFraction_closure:
         const GHC.Real.$w$cproperFraction_info;
 },
 ds_s1sxw_entry() //  [R1]
         { info_tbl: [(c1vcd,
                       label: ds_s1sxw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vcd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1vce; else goto c1vcf;
       c1vce: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vcf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Real.quotRem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sxJ_entry() //  [R1]
         { info_tbl: [(c1vcn,
                       label: sat_s1sxJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vcn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vct; else goto c1vcu;
       c1vct: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vcu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1vck_info;
           _s1sxv::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s1sxv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1vcz; else goto c1vcl;
       u1vcz: // global
           call _c1vck(R1) args: 0, res: 0, upd: 0;
       c1vcl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1vck() //  [R1]
         { info_tbl: [(c1vck,
                       label: block_c1vck_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vck: // global
           I64[Sp] = block_c1vcq_info;
           R1 = P64[R1 + 15];
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1vcq() //  [R1]
         { info_tbl: [(c1vcq,
                       label: block_c1vcq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vcq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vcy; else goto c1vcx;
       c1vcy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1vcx: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sxD_entry() //  [R1]
         { info_tbl: [(c1vcJ,
                       label: sat_s1sxD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vcJ: // global
           _s1sxD::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1vcK; else goto c1vcL;
       c1vcL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vcN; else goto c1vcM;
       c1vcN: // global
           HpAlloc = 24;
           goto c1vcK;
       c1vcK: // global
           R1 = _s1sxD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vcM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sxD::P64;
           _s1sxs::P64 = P64[_s1sxD::P64 + 16];
           _s1sxw::P64 = P64[_s1sxD::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1sxw::P64;
           R2 = _s1sxs::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sxE_entry() //  [R1]
         { info_tbl: [(c1vcQ,
                       label: sat_s1sxE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vcQ: // global
           _s1sxE::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1vcU; else goto c1vcV;
       c1vcV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1vcX; else goto c1vcW;
       c1vcX: // global
           HpAlloc = 32;
           goto c1vcU;
       c1vcU: // global
           R1 = _s1sxE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vcW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sxE::P64;
           _s1sxs::P64 = P64[_s1sxE::P64 + 16];
           _s1sxt::P64 = P64[_s1sxE::P64 + 24];
           _s1sxw::P64 = P64[_s1sxE::P64 + 32];
           I64[Hp - 24] = sat_s1sxD_info;
           P64[Hp - 8] = _s1sxs::P64;
           P64[Hp] = _s1sxw::P64;
           I64[Sp - 32] = block_c1vcO_info;
           R2 = _s1sxt::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1vcO() //  [R1]
         { info_tbl: [(c1vcO,
                       label: block_c1vcO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vcO: // global
           I64[Sp] = block_c1vcT_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1vcT() //  [R1]
         { info_tbl: [(c1vcT,
                       label: block_c1vcT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vcT: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$cproperFraction_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1vd3,
                       label: GHC.Real.$w$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vd3: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1vd7; else goto c1vd6;
       c1vd7: // global
           HpAlloc = 112;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cproperFraction_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vd6: // global
           I64[Hp - 104] = ds_s1sxw_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R5;
           I64[Hp - 64] = sat_s1sxJ_info;
           P64[Hp - 48] = R5;
           _c1vc9::P64 = Hp - 104;
           P64[Hp - 40] = _c1vc9::P64;
           I64[Hp - 32] = sat_s1sxE_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = _c1vc9::P64;
           R2 = Hp - 64;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.921852557 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cproperFraction_closure" {
     GHC.Real.$fEnumRatio_$cproperFraction_closure:
         const GHC.Real.$fEnumRatio_$cproperFraction_info;
 },
 GHC.Real.$fEnumRatio_$cproperFraction_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vea,
                       label: GHC.Real.$fEnumRatio_$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vea: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1veg; else goto c1veh;
       c1veg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1veh: // global
           I64[Sp - 24] = block_c1ve7_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1vem; else goto c1ve8;
       u1vem: // global
           call _c1ve7(R1) args: 0, res: 0, upd: 0;
       c1ve8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ve7() //  [R1]
         { info_tbl: [(c1ve7,
                       label: block_c1ve7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ve7: // global
           _s1sxL::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1ved_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _s1sxL::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ved() //  [R1, R2]
         { info_tbl: [(c1ved,
                       label: block_c1ved_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ved: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vel; else goto c1vek;
       c1vel: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vek: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.930716604 UTC

[section ""data" . GHC.Real.$wreduce_closure" {
     GHC.Real.$wreduce_closure:
         const GHC.Real.$wreduce_info;
         const 0;
 },
 sat_s1sy0_entry() //  [R1]
         { info_tbl: [(c1veR,
                       label: sat_s1sy0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1veR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1veS; else goto c1veT;
       c1veS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1veT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1veP_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1veP() //  [R1]
         { info_tbl: [(c1veP,
                       label: block_c1veP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1veP: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Real.even1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 d_s1sy2_entry() //  [R1]
         { info_tbl: [(c1vfd,
                       label: d_s1sy2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vfd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vfe; else goto c1vff;
       c1vfe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vff: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.gcd_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1vfE_srtd" {
     u1vfE_srtd:
         const S1sVz_srt+296;
         const 72;
         const 281474976710657;
         const 192;
 },
 GHC.Real.$wreduce_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vfg,
                       label: GHC.Real.$wreduce_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vfg: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c1vfh; else goto c1vfi;
       c1vfh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wreduce_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vfi: // global
           I64[Sp - 32] = block_c1veH_info;
           _s1sxT::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1sxT::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vfF_srtd" {
     u1vfF_srtd:
         const S1sVz_srt+296;
         const 71;
         const 281474976710657;
         const 64;
 },
 _c1veH() //  [R1]
         { info_tbl: [(c1veH,
                       label: block_c1veH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1veH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vfl; else goto c1vfk;
       c1vfl: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1vfk: // global
           I64[Hp - 16] = sat_s1sy0_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1veX_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vfG_srtd" {
     u1vfG_srtd:
         const S1sVz_srt+296;
         const 71;
         const 1;
         const 64;
 },
 _c1veX() //  [R1]
         { info_tbl: [(c1veX,
                       label: block_c1veX_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1veX: // global
           I64[Sp] = block_c1vf1_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vfH_srtd" {
     u1vfH_srtd:
         const S1sVz_srt+296;
         const 71;
         const 1;
         const 64;
 },
 _c1vf1() //  [R1]
         { info_tbl: [(c1vf1,
                       label: block_c1vf1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vf1: // global
           _c1veL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1vf5_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = _c1veL::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vfI_srtd" {
     u1vfI_srtd:
         const S1sVz_srt+296;
         const 71;
         const 1;
         const 64;
 },
 _c1vf5() //  [R1]
         { info_tbl: [(c1vf5,
                       label: block_c1vf5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vf5: // global
           if (R1 & 7 == 1) goto c1vfs; else goto c1vfC;
       c1vfs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1vfv; else goto c1vfu;
       c1vfv: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1vfu: // global
           I64[Hp - 32] = d_s1sy2_info;
           _s1sxT::P64 = P64[Sp + 8];
           P64[Hp - 16] = _s1sxT::P64;
           _s1sxU::P64 = P64[Sp + 16];
           P64[Hp - 8] = _s1sxU::P64;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_c1vfo_info;
           R2 = _s1sxT::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1sxU::P64;
           _c1vf9::P64 = Hp - 32;
           P64[Sp - 8] = _c1vf9::P64;
           P64[Sp + 16] = _c1vf9::P64;
           Sp = Sp - 24;
           call GHC.Real.quot_entry(R2) args: 32, res: 8, upd: 8;
       c1vfC: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1vfo() //  [R1]
         { info_tbl: [(c1vfo,
                       label: block_c1vfo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vfo: // global
           _c1vf9::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1vfq_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = P64[Sp + 24];
           P64[Sp + 8] = _c1vf9::P64;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call GHC.Real.quot_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1vfq() //  [R1]
         { info_tbl: [(c1vfq,
                       label: block_c1vfq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vfq: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.95508217 UTC

[section ""data" . GHC.Real.reduce_closure" {
     GHC.Real.reduce_closure:
         const GHC.Real.reduce_info;
         const 0;
 },
 GHC.Real.reduce_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vgQ,
                       label: GHC.Real.reduce_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vgQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1vgR; else goto c1vgS;
       c1vgR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.reduce_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vgS: // global
           I64[Sp - 8] = block_c1vgN_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vgN() //  [R1, R2]
         { info_tbl: [(c1vgN,
                       label: block_c1vgN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vgN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vgV; else goto c1vgU;
       c1vgV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vgU: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.961434558 UTC

[section ""data" . GHC.Real.%_$s%_closure" {
     GHC.Real.%_$s%_closure:
         const GHC.Real.%_$s%_info;
         const 0;
 },
 GHC.Real.%_$s%_entry() //  [R2, R3]
         { info_tbl: [(c1vhe,
                       label: GHC.Real.%_$s%_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vhe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1vhf; else goto c1vhg;
       c1vhf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.%_$s%_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vhg: // global
           I64[Sp - 8] = block_c1vhb_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$s$cfromRational_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vhb() //  [R1, R2]
         { info_tbl: [(c1vhb,
                       label: block_c1vhb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vhb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vhj; else goto c1vhi;
       c1vhj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vhi: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.967894405 UTC

[section ""data" . GHC.Real.$w%_closure" {
     GHC.Real.$w%_closure:
         const GHC.Real.$w%_info;
         const 0;
 },
 $dReal_s1syk_entry() //  [R1]
         { info_tbl: [(c1vhD,
                       label: $dReal_s1syk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vhD: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1syl_entry() //  [R1]
         { info_tbl: [(c1vhK,
                       label: $dNum_s1syl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vhK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vhL; else goto c1vhM;
       c1vhL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vhM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1syo_entry() //  [R1]
         { info_tbl: [(c1vhR,
                       label: sat_s1syo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vhR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vhS; else goto c1vhT;
       c1vhS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vhT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.abs_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sym_entry() //  [R1]
         { info_tbl: [(c1vi2,
                       label: sat_s1sym_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vi2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vi3; else goto c1vi4;
       c1vi3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vi4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.signum_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1syn_entry() //  [R1]
         { info_tbl: [(c1vi5,
                       label: sat_s1syn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vi5: // global
           _s1syn::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1vi6; else goto c1vi7;
       c1vi7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1vi9; else goto c1vi8;
       c1vi9: // global
           HpAlloc = 32;
           goto c1vi6;
       c1vi6: // global
           R1 = _s1syn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vi8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1syn::P64;
           _s1syi::P64 = P64[_s1syn::P64 + 16];
           _s1syj::P64 = P64[_s1syn::P64 + 24];
           _s1syl::P64 = P64[_s1syn::P64 + 32];
           I64[Hp - 24] = sat_s1sym_info;
           P64[Hp - 8] = _s1syj::P64;
           P64[Hp] = _s1syl::P64;
           R2 = _s1syl::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1syi::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w%_entry() //  [R2, R3, R4]
         { info_tbl: [(c1via,
                       label: GHC.Real.$w%_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1via: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c1vie; else goto c1vid;
       c1vie: // global
           HpAlloc = 120;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w%_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vid: // global
           I64[Hp - 112] = $dReal_s1syk_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = $dNum_s1syl_info;
           P64[Hp - 72] = Hp - 112;
           I64[Hp - 64] = sat_s1syo_info;
           P64[Hp - 48] = R4;
           _c1vhG::P64 = Hp - 88;
           P64[Hp - 40] = _c1vhG::P64;
           I64[Hp - 32] = sat_s1syn_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = _c1vhG::P64;
           R4 = Hp - 64;
           R3 = Hp - 32;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.982292344 UTC

[section ""data" . GHC.Real.%_closure" {
     GHC.Real.%_closure:
         const GHC.Real.%_info;
         const 0;
 },
 GHC.Real.%_entry() //  [R2, R3, R4]
         { info_tbl: [(c1viZ,
                       label: GHC.Real.%_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1viZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1vj0; else goto c1vj1;
       c1vj0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.%_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vj1: // global
           I64[Sp - 8] = block_c1viW_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w%_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1viW() //  [R1, R2]
         { info_tbl: [(c1viW,
                       label: block_c1viW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1viW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vj4; else goto c1vj3;
       c1vj4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vj3: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:17.98937675 UTC

[section ""data" . GHC.Real.$w$c/_closure" {
     GHC.Real.$w$c/_closure:
         const GHC.Real.$w$c/_info;
         const 0;
 },
 $dReal_s1syA_entry() //  [R1]
         { info_tbl: [(c1vjo,
                       label: $dReal_s1syA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vjo: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1syB_entry() //  [R1]
         { info_tbl: [(c1vjv,
                       label: $dNum_s1syB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vjv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vjw; else goto c1vjx;
       c1vjw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vjx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1syD_entry() //  [R1]
         { info_tbl: [(c1vjC,
                       label: sat_s1syD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vjC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1vjD; else goto c1vjE;
       c1vjD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vjE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1syC_entry() //  [R1]
         { info_tbl: [(c1vjJ,
                       label: sat_s1syC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vjJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1vjK; else goto c1vjL;
       c1vjK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vjL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c/_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1vjM,
                       label: GHC.Real.$w$c/_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vjM: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto c1vjQ; else goto c1vjP;
       c1vjQ: // global
           HpAlloc = 128;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c/_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vjP: // global
           I64[Hp - 120] = $dReal_s1syA_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = $dNum_s1syB_info;
           P64[Hp - 80] = Hp - 120;
           I64[Hp - 72] = sat_s1syD_info;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           _c1vjr::P64 = Hp - 96;
           P64[Hp - 40] = _c1vjr::P64;
           I64[Hp - 32] = sat_s1syC_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R6;
           P64[Hp] = _c1vjr::P64;
           R4 = Hp - 72;
           R3 = Hp - 32;
           R2 = R2;
           call GHC.Real.$w%_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.000926448 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$c/_closure" {
     GHC.Real.$fFractionalRatio_$c/_closure:
         const GHC.Real.$fFractionalRatio_$c/_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$c/_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vkv,
                       label: GHC.Real.$fFractionalRatio_$c/_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vkv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vkG; else goto c1vkH;
       c1vkG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$c/_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vkH: // global
           I64[Sp - 24] = block_c1vks_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1vkO; else goto c1vkt;
       u1vkO: // global
           call _c1vks(R1) args: 0, res: 0, upd: 0;
       c1vkt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vks() //  [R1]
         { info_tbl: [(c1vks,
                       label: block_c1vks_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vks: // global
           I64[Sp - 8] = block_c1vky_info;
           _s1syI::P64 = P64[R1 + 7];
           _s1syJ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1syJ::P64;
           P64[Sp + 16] = _s1syI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1vkN; else goto c1vkz;
       u1vkN: // global
           call _c1vky(R1) args: 0, res: 0, upd: 0;
       c1vkz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vky() //  [R1]
         { info_tbl: [(c1vky,
                       label: block_c1vky_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vky: // global
           _s1syI::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1vkD_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1syI::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c/_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vkD() //  [R1, R2]
         { info_tbl: [(c1vkD,
                       label: block_c1vkD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vkD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vkM; else goto c1vkL;
       c1vkM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vkL: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.011357006 UTC

[section ""data" . GHC.Real.$w$cfromRational_closure" {
     GHC.Real.$w$cfromRational_closure:
         const GHC.Real.$w$cfromRational_info;
         const 0;
 },
 $dReal_s1syT_entry() //  [R1]
         { info_tbl: [(c1vli,
                       label: $dReal_s1syT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vli: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1syU_entry() //  [R1]
         { info_tbl: [(c1vlp,
                       label: $dNum_s1syU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vlp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vlq; else goto c1vlr;
       c1vlq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vlr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1syW_entry() //  [R1]
         { info_tbl: [(c1vlw,
                       label: sat_s1syW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vlw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vlx; else goto c1vly;
       c1vlx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vly: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1syV_entry() //  [R1]
         { info_tbl: [(c1vlD,
                       label: sat_s1syV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vlD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vlE; else goto c1vlF;
       c1vlE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vlF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$cfromRational_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vlG,
                       label: GHC.Real.$w$cfromRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vlG: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1vlK; else goto c1vlJ;
       c1vlK: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cfromRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vlJ: // global
           I64[Hp - 104] = $dReal_s1syT_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_s1syU_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = sat_s1syW_info;
           P64[Hp - 40] = R4;
           _c1vll::P64 = Hp - 80;
           P64[Hp - 32] = _c1vll::P64;
           I64[Hp - 24] = sat_s1syV_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _c1vll::P64;
           R4 = Hp - 56;
           R3 = Hp - 24;
           R2 = R2;
           call GHC.Real.$w%_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.023504564 UTC

[section ""data" . GHC.Real.$fFractionalRatio_$cfromRational_closure" {
     GHC.Real.$fFractionalRatio_$cfromRational_closure:
         const GHC.Real.$fFractionalRatio_$cfromRational_info;
         const 0;
 },
 GHC.Real.$fFractionalRatio_$cfromRational_entry() //  [R2, R3]
         { info_tbl: [(c1vmn,
                       label: GHC.Real.$fFractionalRatio_$cfromRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vmn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vmt; else goto c1vmu;
       c1vmt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_$cfromRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vmu: // global
           I64[Sp - 16] = block_c1vmk_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1vmz; else goto c1vml;
       u1vmz: // global
           call _c1vmk(R1) args: 0, res: 0, upd: 0;
       c1vml: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vmk() //  [R1]
         { info_tbl: [(c1vmk,
                       label: block_c1vmk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vmk: // global
           _s1syX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1vmq_info;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = _s1syX::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$cfromRational_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vmq() //  [R1, R2]
         { info_tbl: [(c1vmq,
                       label: block_c1vmq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vmq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vmy; else goto c1vmx;
       c1vmy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vmx: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.035019046 UTC

[section ""data" . GHC.Real.$w$c+_closure" {
     GHC.Real.$w$c+_closure:
         const GHC.Real.$w$c+_info;
         const 0;
 },
 $dReal_s1sza_entry() //  [R1]
         { info_tbl: [(c1vmY,
                       label: $dReal_s1sza_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vmY: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1szb_entry() //  [R1]
         { info_tbl: [(c1vn5,
                       label: $dNum_s1szb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vn5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vn6; else goto c1vn7;
       c1vn6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vn7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1szf_entry() //  [R1]
         { info_tbl: [(c1vnc,
                       label: sat_s1szf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vnc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1vnd; else goto c1vne;
       c1vnd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vne: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1szd_entry() //  [R1]
         { info_tbl: [(c1vnn,
                       label: sat_s1szd_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vnn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1vno; else goto c1vnp;
       c1vno: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vnp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1szc_entry() //  [R1]
         { info_tbl: [(c1vnu,
                       label: sat_s1szc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vnu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1vnv; else goto c1vnw;
       c1vnv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vnw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sze_entry() //  [R1]
         { info_tbl: [(c1vnx,
                       label: sat_s1sze_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vnx: // global
           _s1sze::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1vny; else goto c1vnz;
       c1vnz: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1vnB; else goto c1vnA;
       c1vnB: // global
           HpAlloc = 80;
           goto c1vny;
       c1vny: // global
           R1 = _s1sze::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vnA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sze::P64;
           _s1sz6::P64 = P64[_s1sze::P64 + 16];
           _s1sz7::P64 = P64[_s1sze::P64 + 24];
           _s1sz8::P64 = P64[_s1sze::P64 + 32];
           _s1sz9::P64 = P64[_s1sze::P64 + 40];
           _s1szb::P64 = P64[_s1sze::P64 + 48];
           I64[Hp - 72] = sat_s1szd_info;
           P64[Hp - 56] = _s1sz7::P64;
           P64[Hp - 48] = _s1sz8::P64;
           P64[Hp - 40] = _s1szb::P64;
           I64[Hp - 32] = sat_s1szc_info;
           P64[Hp - 16] = _s1sz6::P64;
           P64[Hp - 8] = _s1sz9::P64;
           P64[Hp] = _s1szb::P64;
           R2 = _s1szb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c+_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1vnC,
                       label: GHC.Real.$w$c+_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vnC: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1vnG; else goto c1vnF;
       c1vnG: // global
           HpAlloc = 144;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c+_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vnF: // global
           I64[Hp - 136] = $dReal_s1sza_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = $dNum_s1szb_info;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = sat_s1szf_info;
           P64[Hp - 72] = R4;
           P64[Hp - 64] = R6;
           _c1vn1::P64 = Hp - 112;
           P64[Hp - 56] = _c1vn1::P64;
           I64[Hp - 48] = sat_s1sze_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _c1vn1::P64;
           R4 = Hp - 88;
           R3 = Hp - 48;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.057138606 UTC

[section ""data" . GHC.Real.$fNumRatio_$c+_closure" {
     GHC.Real.$fNumRatio_$c+_closure:
         const GHC.Real.$fNumRatio_$c+_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$c+_entry() //  [R2, R3, R4]
         { info_tbl: [(c1voD,
                       label: GHC.Real.$fNumRatio_$c+_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1voD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1voO; else goto c1voP;
       c1voO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$c+_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1voP: // global
           I64[Sp - 24] = block_c1voA_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1voW; else goto c1voB;
       u1voW: // global
           call _c1voA(R1) args: 0, res: 0, upd: 0;
       c1voB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1voA() //  [R1]
         { info_tbl: [(c1voA,
                       label: block_c1voA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1voA: // global
           I64[Sp - 8] = block_c1voG_info;
           _s1szk::P64 = P64[R1 + 7];
           _s1szl::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1szl::P64;
           P64[Sp + 16] = _s1szk::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1voV; else goto c1voH;
       u1voV: // global
           call _c1voG(R1) args: 0, res: 0, upd: 0;
       c1voH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1voG() //  [R1]
         { info_tbl: [(c1voG,
                       label: block_c1voG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1voG: // global
           _s1szk::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1voL_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1szk::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c+_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1voL() //  [R1, R2]
         { info_tbl: [(c1voL,
                       label: block_c1voL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1voL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1voU; else goto c1voT;
       c1voU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1voT: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.068491581 UTC

[section ""data" . GHC.Real.$w$c-_closure" {
     GHC.Real.$w$c-_closure:
         const GHC.Real.$w$c-_info;
         const 0;
 },
 $dReal_s1szx_entry() //  [R1]
         { info_tbl: [(c1vpq,
                       label: $dReal_s1szx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vpq: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1szy_entry() //  [R1]
         { info_tbl: [(c1vpx,
                       label: $dNum_s1szy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vpx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vpy; else goto c1vpz;
       c1vpy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vpz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1szC_entry() //  [R1]
         { info_tbl: [(c1vpE,
                       label: sat_s1szC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vpE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1vpF; else goto c1vpG;
       c1vpF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vpG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1szA_entry() //  [R1]
         { info_tbl: [(c1vpP,
                       label: sat_s1szA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vpP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1vpQ; else goto c1vpR;
       c1vpQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vpR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1szz_entry() //  [R1]
         { info_tbl: [(c1vpW,
                       label: sat_s1szz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vpW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1vpX; else goto c1vpY;
       c1vpX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vpY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1szB_entry() //  [R1]
         { info_tbl: [(c1vpZ,
                       label: sat_s1szB_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vpZ: // global
           _s1szB::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1vq0; else goto c1vq1;
       c1vq1: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1vq3; else goto c1vq2;
       c1vq3: // global
           HpAlloc = 80;
           goto c1vq0;
       c1vq0: // global
           R1 = _s1szB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vq2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1szB::P64;
           _s1szt::P64 = P64[_s1szB::P64 + 16];
           _s1szu::P64 = P64[_s1szB::P64 + 24];
           _s1szv::P64 = P64[_s1szB::P64 + 32];
           _s1szw::P64 = P64[_s1szB::P64 + 40];
           _s1szy::P64 = P64[_s1szB::P64 + 48];
           I64[Hp - 72] = sat_s1szA_info;
           P64[Hp - 56] = _s1szu::P64;
           P64[Hp - 48] = _s1szv::P64;
           P64[Hp - 40] = _s1szy::P64;
           I64[Hp - 32] = sat_s1szz_info;
           P64[Hp - 16] = _s1szt::P64;
           P64[Hp - 8] = _s1szw::P64;
           P64[Hp] = _s1szy::P64;
           R2 = _s1szy::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c-_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1vq4,
                       label: GHC.Real.$w$c-_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vq4: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1vq8; else goto c1vq7;
       c1vq8: // global
           HpAlloc = 144;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c-_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vq7: // global
           I64[Hp - 136] = $dReal_s1szx_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = $dNum_s1szy_info;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = sat_s1szC_info;
           P64[Hp - 72] = R4;
           P64[Hp - 64] = R6;
           _c1vpt::P64 = Hp - 112;
           P64[Hp - 56] = _c1vpt::P64;
           I64[Hp - 48] = sat_s1szB_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _c1vpt::P64;
           R4 = Hp - 88;
           R3 = Hp - 48;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.085170269 UTC

[section ""data" . GHC.Real.$fNumRatio_$c-_closure" {
     GHC.Real.$fNumRatio_$c-_closure:
         const GHC.Real.$fNumRatio_$c-_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$c-_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vr5,
                       label: GHC.Real.$fNumRatio_$c-_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vr5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vrg; else goto c1vrh;
       c1vrg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$c-_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vrh: // global
           I64[Sp - 24] = block_c1vr2_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1vro; else goto c1vr3;
       u1vro: // global
           call _c1vr2(R1) args: 0, res: 0, upd: 0;
       c1vr3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vr2() //  [R1]
         { info_tbl: [(c1vr2,
                       label: block_c1vr2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vr2: // global
           I64[Sp - 8] = block_c1vr8_info;
           _s1szH::P64 = P64[R1 + 7];
           _s1szI::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1szI::P64;
           P64[Sp + 16] = _s1szH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1vrn; else goto c1vr9;
       u1vrn: // global
           call _c1vr8(R1) args: 0, res: 0, upd: 0;
       c1vr9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vr8() //  [R1]
         { info_tbl: [(c1vr8,
                       label: block_c1vr8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vr8: // global
           _s1szH::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1vrd_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1szH::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c-_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vrd() //  [R1, R2]
         { info_tbl: [(c1vrd,
                       label: block_c1vrd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vrd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vrm; else goto c1vrl;
       c1vrm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vrl: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.09613307 UTC

[section ""data" . GHC.Real.$w$c*_closure" {
     GHC.Real.$w$c*_closure:
         const GHC.Real.$w$c*_info;
         const 0;
 },
 $dReal_s1szU_entry() //  [R1]
         { info_tbl: [(c1vrS,
                       label: $dReal_s1szU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vrS: // global
           R2 = P64[R1 + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_s1szV_entry() //  [R1]
         { info_tbl: [(c1vrZ,
                       label: $dNum_s1szV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vrZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vs0; else goto c1vs1;
       c1vs0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vs1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1szX_entry() //  [R1]
         { info_tbl: [(c1vs6,
                       label: sat_s1szX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vs6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1vs7; else goto c1vs8;
       c1vs7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vs8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1szW_entry() //  [R1]
         { info_tbl: [(c1vsd,
                       label: sat_s1szW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vsd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1vse; else goto c1vsf;
       c1vse: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vsf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$c*_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1vsg,
                       label: GHC.Real.$w$c*_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vsg: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto c1vsk; else goto c1vsj;
       c1vsk: // global
           HpAlloc = 128;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$c*_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vsj: // global
           I64[Hp - 120] = $dReal_s1szU_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = $dNum_s1szV_info;
           P64[Hp - 80] = Hp - 120;
           I64[Hp - 72] = sat_s1szX_info;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R6;
           _c1vrV::P64 = Hp - 96;
           P64[Hp - 40] = _c1vrV::P64;
           I64[Hp - 32] = sat_s1szW_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R5;
           P64[Hp] = _c1vrV::P64;
           R4 = Hp - 72;
           R3 = Hp - 32;
           R2 = R2;
           call GHC.Real.$wreduce_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.108427492 UTC

[section ""data" . GHC.Real.$fNumRatio_$c*_closure" {
     GHC.Real.$fNumRatio_$c*_closure:
         const GHC.Real.$fNumRatio_$c*_info;
         const 0;
 },
 GHC.Real.$fNumRatio_$c*_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vsZ,
                       label: GHC.Real.$fNumRatio_$c*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vsZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vta; else goto c1vtb;
       c1vta: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_$c*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vtb: // global
           I64[Sp - 24] = block_c1vsW_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1vti; else goto c1vsX;
       u1vti: // global
           call _c1vsW(R1) args: 0, res: 0, upd: 0;
       c1vsX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vsW() //  [R1]
         { info_tbl: [(c1vsW,
                       label: block_c1vsW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vsW: // global
           I64[Sp - 8] = block_c1vt2_info;
           _s1sA2::P64 = P64[R1 + 7];
           _s1sA3::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1sA3::P64;
           P64[Sp + 16] = _s1sA2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1vth; else goto c1vt3;
       u1vth: // global
           call _c1vt2(R1) args: 0, res: 0, upd: 0;
       c1vt3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vt2() //  [R1]
         { info_tbl: [(c1vt2,
                       label: block_c1vt2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vt2: // global
           _s1sA2::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1vt7_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = _s1sA2::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Real.$w$c*_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vt7() //  [R1, R2]
         { info_tbl: [(c1vt7,
                       label: block_c1vt7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vt7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vtg; else goto c1vtf;
       c1vtg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vtf: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.11878428 UTC

[section ""data" . GHC.Real.$fNumRatio_closure" {
     GHC.Real.$fNumRatio_closure:
         const GHC.Real.$fNumRatio_info;
         const 0;
 },
 sat_s1sAh_entry() //  [R1, R2]
         { info_tbl: [(c1vtN,
                       label: sat_s1sAh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vtN: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$cfromInteger_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sAg_entry() //  [R1, R2]
         { info_tbl: [(c1vtV,
                       label: sat_s1sAg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vtV: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$csignum_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sAf_entry() //  [R1, R2]
         { info_tbl: [(c1vu3,
                       label: sat_s1sAf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vu3: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$cabs_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sAe_entry() //  [R1, R2]
         { info_tbl: [(c1vub,
                       label: sat_s1sAe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vub: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fNumRatio_$cnegate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sAd_entry() //  [R1, R2, R3]
         { info_tbl: [(c1vuj,
                       label: sat_s1sAd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vuj: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fNumRatio_$c*_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sAc_entry() //  [R1, R2, R3]
         { info_tbl: [(c1vur,
                       label: sat_s1sAc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vur: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fNumRatio_$c-_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sAb_entry() //  [R1, R2, R3]
         { info_tbl: [(c1vuz,
                       label: sat_s1sAb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vuz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fNumRatio_$c+_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fNumRatio_entry() //  [R2]
         { info_tbl: [(c1vuD,
                       label: GHC.Real.$fNumRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vuD: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c1vuH; else goto c1vuG;
       c1vuH: // global
           HpAlloc = 176;
           R2 = R2;
           R1 = GHC.Real.$fNumRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1vuG: // global
           I64[Hp - 168] = sat_s1sAh_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1sAg_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s1sAf_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s1sAe_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s1sAd_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s1sAc_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1sAb_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 70;
           P64[Hp - 40] = Hp - 86;
           P64[Hp - 32] = Hp - 102;
           P64[Hp - 24] = Hp - 119;
           P64[Hp - 16] = Hp - 135;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 167;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.134939875 UTC

[section ""data" . GHC.Real.$fEnumRatio3_closure" {
     GHC.Real.$fEnumRatio3_closure:
         const GHC.Real.:%_con_info;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.137102528 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$csucc_closure" {
     GHC.Real.$fEnumRatio_$s$csucc_closure:
         const GHC.Real.$fEnumRatio_$s$csucc_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$csucc_entry() //  [R2]
         { info_tbl: [(c1vvv,
                       label: GHC.Real.$fEnumRatio_$s$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vvv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1vvB; else goto c1vvC;
       c1vvB: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1vvC: // global
           I64[Sp - 8] = block_c1vvs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1vvH; else goto c1vvt;
       u1vvH: // global
           call _c1vvs(R1) args: 0, res: 0, upd: 0;
       c1vvt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vvs() //  [R1]
         { info_tbl: [(c1vvs,
                       label: block_c1vvs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vvs: // global
           I64[Sp] = block_c1vvy_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vvy() //  [R1, R2]
         { info_tbl: [(c1vvy,
                       label: block_c1vvy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vvy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vvG; else goto c1vvF;
       c1vvG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vvF: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.145221241 UTC

[section ""data" . GHC.Real.$fEnumRatio_$csucc_closure" {
     GHC.Real.$fEnumRatio_$csucc_closure:
         const GHC.Real.$fEnumRatio_$csucc_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$csucc_entry() //  [R2, R3]
         { info_tbl: [(c1vw5,
                       label: GHC.Real.$fEnumRatio_$csucc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vw5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vwd; else goto c1vwe;
       c1vwd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$csucc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vwe: // global
           I64[Sp - 16] = block_c1vw2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1vwk; else goto c1vw3;
       u1vwk: // global
           call _c1vw2(R1) args: 0, res: 0, upd: 0;
       c1vw3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vw2() //  [R1]
         { info_tbl: [(c1vw2,
                       label: block_c1vw2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vw2: // global
           I64[Sp - 16] = block_c1vw8_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vw8() //  [R1, R2]
         { info_tbl: [(c1vw8,
                       label: block_c1vw8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vw8: // global
           _s1sAp::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1vwa_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = _s1sAp::P64;
           Sp = Sp + 24;
           call GHC.Real.$w$c+_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vwa() //  [R1, R2]
         { info_tbl: [(c1vwa,
                       label: block_c1vwa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vwa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vwj; else goto c1vwi;
       c1vwj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vwi: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.155034312 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$cpred_closure" {
     GHC.Real.$fEnumRatio_$s$cpred_closure:
         const GHC.Real.$fEnumRatio_$s$cpred_info;
         const 0;
 },
 section ""relreadonly" . u1vx1_srtd" {
     u1vx1_srtd:
         const S1sVz_srt+464;
         const 72;
         const 1;
         const 144;
 },
 GHC.Real.$fEnumRatio_$s$cpred_entry() //  [R2]
         { info_tbl: [(c1vwO,
                       label: GHC.Real.$fEnumRatio_$s$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vwO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1vwU; else goto c1vwV;
       c1vwU: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1vwV: // global
           I64[Sp - 8] = block_c1vwL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1vx0; else goto c1vwM;
       u1vx0: // global
           call _c1vwL(R1) args: 0, res: 0, upd: 0;
       c1vwM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vx2_srtd" {
     u1vx2_srtd:
         const S1sVz_srt+464;
         const 69;
         const 1;
         const 16;
 },
 _c1vwL() //  [R1]
         { info_tbl: [(c1vwL,
                       label: block_c1vwL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vwL: // global
           I64[Sp] = block_c1vwR_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vwR() //  [R1, R2]
         { info_tbl: [(c1vwR,
                       label: block_c1vwR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vwR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vwZ; else goto c1vwY;
       c1vwZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vwY: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.165212461 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cpred_closure" {
     GHC.Real.$fEnumRatio_$cpred_closure:
         const GHC.Real.$fEnumRatio_$cpred_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$cpred_entry() //  [R2, R3]
         { info_tbl: [(c1vxs,
                       label: GHC.Real.$fEnumRatio_$cpred_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vxs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vxA; else goto c1vxB;
       c1vxA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cpred_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vxB: // global
           I64[Sp - 16] = block_c1vxp_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1vxH; else goto c1vxq;
       u1vxH: // global
           call _c1vxp(R1) args: 0, res: 0, upd: 0;
       c1vxq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vxp() //  [R1]
         { info_tbl: [(c1vxp,
                       label: block_c1vxp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vxp: // global
           I64[Sp - 16] = block_c1vxv_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vxv() //  [R1, R2]
         { info_tbl: [(c1vxv,
                       label: block_c1vxv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vxv: // global
           _s1sAH::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1vxx_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = _s1sAH::P64;
           Sp = Sp + 24;
           call GHC.Real.$w$c-_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vxx() //  [R1, R2]
         { info_tbl: [(c1vxx,
                       label: block_c1vxx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vxx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vxG; else goto c1vxF;
       c1vxG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vxF: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.175178718 UTC

[section ""data" . GHC.Real.$fFractionalRatio_closure" {
     GHC.Real.$fFractionalRatio_closure:
         const GHC.Real.$fFractionalRatio_info;
         const 0;
 },
 sat_s1sAW_entry() //  [R1, R2]
         { info_tbl: [(c1vyd,
                       label: sat_s1sAW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vyd: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fFractionalRatio_$cfromRational_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sAV_entry() //  [R1, R2]
         { info_tbl: [(c1vyl,
                       label: sat_s1sAV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vyl: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fFractionalRatio_$crecip_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sAU_entry() //  [R1, R2, R3]
         { info_tbl: [(c1vyt,
                       label: sat_s1sAU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vyt: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fFractionalRatio_$c/_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sAT_entry() //  [R1]
         { info_tbl: [(c1vyA,
                       label: sat_s1sAT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vyA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vyB; else goto c1vyC;
       c1vyB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vyC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fNumRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fFractionalRatio_entry() //  [R2]
         { info_tbl: [(c1vyE,
                       label: GHC.Real.$fFractionalRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vyE: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1vyI; else goto c1vyH;
       c1vyI: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = GHC.Real.$fFractionalRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1vyH: // global
           I64[Hp - 104] = sat_s1sAW_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s1sAV_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1sAU_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1sAT_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.186805394 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFrom_closure" {
     GHC.Real.$fEnumRatio_$cenumFrom_closure:
         const GHC.Real.$fEnumRatio_$cenumFrom_info;
         const 0;
 },
 w_s1sAY_entry() //  [R1]
         { info_tbl: [(c1vzj,
                       label: w_s1sAY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vzj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vzk; else goto c1vzl;
       c1vzk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vzl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sB3_entry() //  [R1, R2]
         { info_tbl: [(c1vzu,
                       label: sat_s1sB3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vzu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1vzv; else goto c1vzw;
       c1vzv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1vzw: // global
           I64[Sp - 8] = block_c1vzr_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFrom_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vzr() //  [R1, R2]
         { info_tbl: [(c1vzr,
                       label: block_c1vzr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vzr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vzz; else goto c1vzy;
       c1vzz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vzy: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEnumRatio_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c1vzA,
                       label: GHC.Real.$fEnumRatio_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vzA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1vzE; else goto c1vzD;
       c1vzE: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1vzD: // global
           I64[Hp - 32] = w_s1sAY_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s1sB3_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.197701894 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFromThen_closure" {
     GHC.Real.$fEnumRatio_$cenumFromThen_closure:
         const GHC.Real.$fEnumRatio_$cenumFromThen_info;
         const 0;
 },
 w_s1sB5_entry() //  [R1]
         { info_tbl: [(c1vAa,
                       label: w_s1sB5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vAa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vAb; else goto c1vAc;
       c1vAb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vAc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sBb_entry() //  [R1, R2, R3]
         { info_tbl: [(c1vAl,
                       label: sat_s1sBb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vAl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1vAm; else goto c1vAn;
       c1vAm: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vAn: // global
           I64[Sp - 8] = block_c1vAi_info;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Real.$wnumericEnumFromThen_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vAi() //  [R1, R2]
         { info_tbl: [(c1vAi,
                       label: block_c1vAi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vAi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vAq; else goto c1vAp;
       c1vAq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1vAp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEnumRatio_$cenumFromThen_entry() //  [R2]
         { info_tbl: [(c1vAr,
                       label: GHC.Real.$fEnumRatio_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vAr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1vAv; else goto c1vAu;
       c1vAv: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFromThen_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1vAu: // global
           I64[Hp - 32] = w_s1sB5_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s1sBb_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.207802493 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFromTo_closure" {
     GHC.Real.$fEnumRatio_$cenumFromTo_closure:
         const GHC.Real.$fEnumRatio_$cenumFromTo_info;
         const 0;
 },
 sat_s1sBe_entry() //  [R1]
         { info_tbl: [(c1vB1,
                       label: sat_s1sBe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vB1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vB2; else goto c1vB3;
       c1vB2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vB3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sBd_entry() //  [R1]
         { info_tbl: [(c1vB8,
                       label: sat_s1sBd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vB8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vB9; else goto c1vBa;
       c1vB9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vBa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1vBg_srtd" {
     u1vBg_srtd:
         const S1sVz_srt+624;
         const 58;
         const 153122387330596865;
 },
 GHC.Real.$fEnumRatio_$cenumFromTo_entry() //  [R2]
         { info_tbl: [(c1vBb,
                       label: GHC.Real.$fEnumRatio_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vBb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1vBf; else goto c1vBe;
       c1vBf: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFromTo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1vBe: // global
           I64[Hp - 40] = sat_s1sBe_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s1sBd_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.Real.numericEnumFromTo_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.216581694 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cenumFromThenTo_closure" {
     GHC.Real.$fEnumRatio_$cenumFromThenTo_closure:
         const GHC.Real.$fEnumRatio_$cenumFromThenTo_info;
         const 0;
 },
 sat_s1sBh_entry() //  [R1]
         { info_tbl: [(c1vBG,
                       label: sat_s1sBh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vBG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vBH; else goto c1vBI;
       c1vBH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vBI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sBg_entry() //  [R1]
         { info_tbl: [(c1vBN,
                       label: sat_s1sBg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vBN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vBO; else goto c1vBP;
       c1vBO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vBP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1vBV_srtd" {
     u1vBV_srtd:
         const S1sVz_srt+672;
         const 53;
         const 4644337115725825;
 },
 GHC.Real.$fEnumRatio_$cenumFromThenTo_entry() //  [R2]
         { info_tbl: [(c1vBQ,
                       label: GHC.Real.$fEnumRatio_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vBQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1vBU; else goto c1vBT;
       c1vBU: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1vBT: // global
           I64[Hp - 40] = sat_s1sBh_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s1sBg_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.Real.numericEnumFromThenTo_closure+5;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.225636482 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$fRealRatio_closure" {
     GHC.Real.$fRealFracRatio_$s$fRealRatio_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Real.$fFractionalRatio_$s$fNumRatio_closure+1;
         const GHC.Real.$fOrdRatio_$s$fOrdRatio_closure+1;
         const GHC.Real.$fRealRatio_$s$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.228032794 UTC

[section ""data" . GHC.Real.$fRealRatio_closure" {
     GHC.Real.$fRealRatio_closure:
         const GHC.Real.$fRealRatio_info;
         const 0;
 },
 sat_s1sBl_entry() //  [R1, R2]
         { info_tbl: [(c1vCn,
                       label: sat_s1sBl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vCn: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fRealRatio_$ctoRational_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sBk_entry() //  [R1]
         { info_tbl: [(c1vCu,
                       label: sat_s1sBk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vCu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vCv; else goto c1vCw;
       c1vCv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vCw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fOrdRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sBj_entry() //  [R1]
         { info_tbl: [(c1vCB,
                       label: sat_s1sBj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vCB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vCC; else goto c1vCD;
       c1vCC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vCD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fNumRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fRealRatio_entry() //  [R2]
         { info_tbl: [(c1vCF,
                       label: GHC.Real.$fRealRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vCF: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1vCJ; else goto c1vCI;
       c1vCJ: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = GHC.Real.$fRealRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1vCI: // global
           I64[Hp - 88] = sat_s1sBl_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1sBk_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s1sBj_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 87;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.238006989 UTC

[section ""data" . GHC.Real.$w$s$cceiling_closure" {
     GHC.Real.$w$s$cceiling_closure:
         const GHC.Real.$w$s$cceiling_info;
         const 0;
 },
 sat_s1sBy_entry() //  [R1]
         { info_tbl: [(c1vDB,
                       label: sat_s1sBy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vDB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vDC; else goto c1vDD;
       c1vDC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vDD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1vDV_srtd" {
     u1vDV_srtd:
         const S1sVz_srt+24;
         const 136;
         const 1;
         const 576461027181592576;
         const 128;
 },
 GHC.Real.$w$s$cceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vDE,
                       label: GHC.Real.$w$s$cceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vDE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1vDF; else goto c1vDG;
       c1vDF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vDG: // global
           I64[Sp - 16] = block_c1vDd_info;
           R4 = R4;
           R3 = R3;
           _s1sBm::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s1sBm::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vDW_srtd" {
     u1vDW_srtd:
         const S1sVz_srt+24;
         const 124;
         const 1;
         const 576460752303685632;
 },
 _c1vDd() //  [R1, R2]
         { info_tbl: [(c1vDd,
                       label: block_c1vDd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vDd: // global
           I64[Sp - 8] = block_c1vDf_info;
           _s1sBq::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1sBq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1vDU; else goto c1vDg;
       u1vDU: // global
           call _c1vDf(R1) args: 0, res: 0, upd: 0;
       c1vDg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vDX_srtd" {
     u1vDX_srtd:
         const S1sVz_srt+24;
         const 124;
         const 1;
         const 576460752303685632;
 },
 _c1vDf() //  [R1]
         { info_tbl: [(c1vDf,
                       label: block_c1vDf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vDf: // global
           I64[Sp] = block_c1vDk_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = GHC.Real.even1_closure;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vDk() //  [R1]
         { info_tbl: [(c1vDk,
                       label: block_c1vDk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vDk: // global
           if (R1 & 7 == 3) goto c1vDO; else goto c1vDM;
       c1vDO: // global
           I64[Sp] = block_c1vDp_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
       c1vDM: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1vDp() //  [R1]
         { info_tbl: [(c1vDp,
                       label: block_c1vDp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vDp: // global
           I64[Sp] = block_c1vDt_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vDt() //  [R1]
         { info_tbl: [(c1vDt,
                       label: block_c1vDt_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vDt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vDS; else goto c1vDR;
       c1vDS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1vDR: // global
           I64[Hp - 16] = sat_s1sBy_info;
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.254393324 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$cceiling_closure" {
     GHC.Real.$fRealFracRatio_$s$cceiling_closure:
         const GHC.Real.$fRealFracRatio_$s$cceiling_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$s$cceiling_entry() //  [R2, R3]
         { info_tbl: [(c1vEK,
                       label: GHC.Real.$fRealFracRatio_$s$cceiling_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vEK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vEL; else goto c1vEM;
       c1vEL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$cceiling_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vEM: // global
           I64[Sp - 16] = block_c1vEH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1vEQ; else goto c1vEI;
       u1vEQ: // global
           call _c1vEH(R1) args: 0, res: 0, upd: 0;
       c1vEI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vEH() //  [R1]
         { info_tbl: [(c1vEH,
                       label: block_c1vEH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vEH: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cceiling_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.261227193 UTC

[section ""data" . GHC.Real.$w$cceiling_closure" {
     GHC.Real.$w$cceiling_closure:
         const GHC.Real.$w$cceiling_info;
         const 0;
 },
 sat_s1sBU_entry() //  [R1]
         { info_tbl: [(c1vFv,
                       label: sat_s1sBU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vFv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vFw; else goto c1vFx;
       c1vFw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vFx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1vFQ_srtd" {
     u1vFQ_srtd:
         const S1sVz_srt+680;
         const 56;
         const 36030996042252289;
 },
 GHC.Real.$w$cceiling_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1vFy,
                       label: GHC.Real.$w$cceiling_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vFy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1vFz; else goto c1vFA;
       c1vFz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cceiling_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vFA: // global
           I64[Sp - 24] = block_c1vF5_info;
           R5 = R5;
           R4 = R4;
           _s1sBF::P64 = R3;
           R3 = R3;
           _s1sBE::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1sBE::P64;
           P64[Sp - 8] = _s1sBF::P64;
           Sp = Sp - 24;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vFR_srtd" {
     u1vFR_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1vF5() //  [R1, R2]
         { info_tbl: [(c1vF5,
                       label: block_c1vF5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vF5: // global
           I64[Sp - 8] = block_c1vF7_info;
           _s1sBJ::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1sBJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1vFP; else goto c1vF8;
       u1vFP: // global
           call _c1vF7(R1) args: 0, res: 0, upd: 0;
       c1vF8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vFS_srtd" {
     u1vFS_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1vF7() //  [R1]
         { info_tbl: [(c1vF7,
                       label: block_c1vF7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vF7: // global
           I64[Sp - 16] = block_c1vFc_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vFc() //  [R1, R2]
         { info_tbl: [(c1vFc,
                       label: block_c1vFc_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vFc: // global
           _s1sBM::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1vFe_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = _s1sBM::P64;
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Real.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vFe() //  [R1]
         { info_tbl: [(c1vFe,
                       label: block_c1vFe_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vFe: // global
           if (R1 & 7 == 3) goto c1vFJ; else goto c1vFH;
       c1vFJ: // global
           I64[Sp] = block_c1vFj_info;
           R2 = P64[Sp + 24];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
       c1vFH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1vFj() //  [R1]
         { info_tbl: [(c1vFj,
                       label: block_c1vFj_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vFj: // global
           I64[Sp] = block_c1vFn_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vFn() //  [R1]
         { info_tbl: [(c1vFn,
                       label: block_c1vFn_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vFn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vFN; else goto c1vFM;
       c1vFN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1vFM: // global
           I64[Hp - 16] = sat_s1sBU_info;
           P64[Hp] = R1;
           R2 = R1;
           _s1sBJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1sBJ::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.279871546 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$cceiling_closure" {
     GHC.Real.$fRealFracRatio_$cceiling_closure:
         const GHC.Real.$fRealFracRatio_$cceiling_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$cceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vGL,
                       label: GHC.Real.$fRealFracRatio_$cceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vGL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1vGM; else goto c1vGN;
       c1vGM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$cceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vGN: // global
           I64[Sp - 24] = block_c1vGI_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1vGR; else goto c1vGJ;
       u1vGR: // global
           call _c1vGI(R1) args: 0, res: 0, upd: 0;
       c1vGJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vGI() //  [R1]
         { info_tbl: [(c1vGI,
                       label: block_c1vGI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vGI: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cceiling_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.286663549 UTC

[section ""data" . GHC.Real.$w$s$cfloor_closure" {
     GHC.Real.$w$s$cfloor_closure:
         const GHC.Real.$w$s$cfloor_info;
         const 0;
 },
 sat_s1sCf_entry() //  [R1]
         { info_tbl: [(c1vHC,
                       label: sat_s1sCf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vHC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vHD; else goto c1vHE;
       c1vHD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vHE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1vHX_srtd" {
     u1vHX_srtd:
         const S1sVz_srt;
         const 143;
         const 1;
         const 4611688217452740608;
         const 16384;
 },
 GHC.Real.$w$s$cfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vHF,
                       label: GHC.Real.$w$s$cfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vHF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vHG; else goto c1vHH;
       c1vHG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vHH: // global
           I64[Sp - 16] = block_c1vH6_info;
           R4 = R4;
           R3 = R3;
           _s1sC1::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s1sC1::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vHY_srtd" {
     u1vHY_srtd:
         const S1sVz_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1vH6() //  [R1, R2]
         { info_tbl: [(c1vH6,
                       label: block_c1vH6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vH6: // global
           I64[Sp - 8] = block_c1vH8_info;
           _s1sC5::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1sC5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1vHW; else goto c1vH9;
       u1vHW: // global
           call _c1vH8(R1) args: 0, res: 0, upd: 0;
       c1vH9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vHZ_srtd" {
     u1vHZ_srtd:
         const S1sVz_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1vH8() //  [R1]
         { info_tbl: [(c1vH8,
                       label: block_c1vH8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vH8: // global
           I64[Sp - 8] = block_c1vHd_info;
           R3 = P64[R1 + 15];
           R2 = GHC.Real.even1_closure;
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vI0_srtd" {
     u1vI0_srtd:
         const S1sVz_srt;
         const 127;
         const 1;
         const 4611686018427387904;
 },
 _c1vHd() //  [R1]
         { info_tbl: [(c1vHd,
                       label: block_c1vHd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vHd: // global
           I64[Sp] = block_c1vHh_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vHh() //  [R1]
         { info_tbl: [(c1vHh,
                       label: block_c1vHh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vHh: // global
           _s1sCb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1vHl_info;
           R3 = _s1sCb::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vHl() //  [R1]
         { info_tbl: [(c1vHl,
                       label: block_c1vHl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vHl: // global
           if (R1 == 1) goto c1vHR; else goto c1vHP;
       c1vHR: // global
           I64[Sp] = block_c1vHq_info;
           R2 = P64[Sp + 16];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
       c1vHP: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1vHq() //  [R1]
         { info_tbl: [(c1vHq,
                       label: block_c1vHq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vHq: // global
           I64[Sp] = block_c1vHu_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vHu() //  [R1]
         { info_tbl: [(c1vHu,
                       label: block_c1vHu_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vHu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vHV; else goto c1vHU;
       c1vHV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1vHU: // global
           I64[Hp - 16] = sat_s1sCf_info;
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.310312409 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$cfloor_closure" {
     GHC.Real.$fRealFracRatio_$s$cfloor_closure:
         const GHC.Real.$fRealFracRatio_$s$cfloor_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$s$cfloor_entry() //  [R2, R3]
         { info_tbl: [(c1vIV,
                       label: GHC.Real.$fRealFracRatio_$s$cfloor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vIV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vIW; else goto c1vIX;
       c1vIW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$cfloor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vIX: // global
           I64[Sp - 16] = block_c1vIS_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1vJ1; else goto c1vIT;
       u1vJ1: // global
           call _c1vIS(R1) args: 0, res: 0, upd: 0;
       c1vIT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vIS() //  [R1]
         { info_tbl: [(c1vIS,
                       label: block_c1vIS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vIS: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.316789472 UTC

[section ""data" . GHC.Real.$w$cfloor_closure" {
     GHC.Real.$w$cfloor_closure:
         const GHC.Real.$w$cfloor_info;
         const 0;
 },
 sat_s1sCB_entry() //  [R1]
         { info_tbl: [(c1vJG,
                       label: sat_s1sCB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vJG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vJH; else goto c1vJI;
       c1vJH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vJI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1vK1_srtd" {
     u1vK1_srtd:
         const S1sVz_srt+680;
         const 60;
         const 576462951326711809;
 },
 GHC.Real.$w$cfloor_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1vJJ,
                       label: GHC.Real.$w$cfloor_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vJJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1vJK; else goto c1vJL;
       c1vJK: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cfloor_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vJL: // global
           I64[Sp - 24] = block_c1vJg_info;
           R5 = R5;
           R4 = R4;
           _s1sCm::P64 = R3;
           R3 = R3;
           _s1sCl::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1sCl::P64;
           P64[Sp - 8] = _s1sCm::P64;
           Sp = Sp - 24;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vK2_srtd" {
     u1vK2_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1vJg() //  [R1, R2]
         { info_tbl: [(c1vJg,
                       label: block_c1vJg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vJg: // global
           I64[Sp - 8] = block_c1vJi_info;
           _s1sCq::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1sCq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1vK0; else goto c1vJj;
       u1vK0: // global
           call _c1vJi(R1) args: 0, res: 0, upd: 0;
       c1vJj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vK3_srtd" {
     u1vK3_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288321;
 },
 _c1vJi() //  [R1]
         { info_tbl: [(c1vJi,
                       label: block_c1vJi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vJi: // global
           I64[Sp - 16] = block_c1vJn_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vJn() //  [R1, R2]
         { info_tbl: [(c1vJn,
                       label: block_c1vJn_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vJn: // global
           _s1sCt::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1vJp_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = _s1sCt::P64;
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Real.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vJp() //  [R1]
         { info_tbl: [(c1vJp,
                       label: block_c1vJp_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vJp: // global
           if (R1 & 7 == 1) goto c1vJS; else goto c1vJU;
       c1vJS: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1vJU: // global
           I64[Sp] = block_c1vJu_info;
           R2 = P64[Sp + 24];
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vJu() //  [R1]
         { info_tbl: [(c1vJu,
                       label: block_c1vJu_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vJu: // global
           I64[Sp] = block_c1vJy_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vJy() //  [R1]
         { info_tbl: [(c1vJy,
                       label: block_c1vJy_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vJy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1vJY; else goto c1vJX;
       c1vJY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1vJX: // global
           I64[Hp - 16] = sat_s1sCB_info;
           P64[Hp] = R1;
           R2 = R1;
           _s1sCq::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1sCq::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.336374644 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$cfloor_closure" {
     GHC.Real.$fRealFracRatio_$cfloor_closure:
         const GHC.Real.$fRealFracRatio_$cfloor_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$cfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vKW,
                       label: GHC.Real.$fRealFracRatio_$cfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vKW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1vKX; else goto c1vKY;
       c1vKX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$cfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vKY: // global
           I64[Sp - 24] = block_c1vKT_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1vL2; else goto c1vKU;
       u1vL2: // global
           call _c1vKT(R1) args: 0, res: 0, upd: 0;
       c1vKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vKT() //  [R1]
         { info_tbl: [(c1vKT,
                       label: block_c1vKT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vKT: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cfloor_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.342278375 UTC

[section ""data" . sat_s1sCI_closure" {
     sat_s1sCI_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.343934268 UTC

[section ""data" . sat_s1sCJ_closure" {
     sat_s1sCJ_closure:
         const :_con_info;
         const sat_s1sCI_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.346019469 UTC

[section ""data" . GHC.Real.$fRealFracRatio2_closure" {
     GHC.Real.$fRealFracRatio2_closure:
         const GHC.Real.$fRealFracRatio2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.$fRealFracRatio2_entry() //  [R1]
         { info_tbl: [(c1vLl,
                       label: GHC.Real.$fRealFracRatio2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vLl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vLm; else goto c1vLn;
       c1vLm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vLn: // global
           (_c1vLi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1vLi::I64 == 0) goto c1vLk; else goto c1vLj;
       c1vLk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1vLj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1vLi::I64;
           R3 = sat_s1sCJ_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.351999055 UTC

[section ""data" . GHC.Real.$w$s$cround_closure" {
     GHC.Real.$w$s$cround_closure:
         const GHC.Real.$w$s$cround_info;
         const 0;
 },
 sat_s1sD5_entry() //  [R1]
         { info_tbl: [(c1vMp,
                       label: sat_s1sD5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vMp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vMq; else goto c1vMr;
       c1vMq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vMr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sD6_entry() //  [R1]
         { info_tbl: [(c1vMy,
                       label: sat_s1sD6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vMy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vMz; else goto c1vMA;
       c1vMz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vMA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1vNL_srtd" {
     u1vNL_srtd:
         const S1sVz_srt;
         const 149;
         const 288230376151711745;
         const 4611688217729565184;
         const 1572864;
 },
 GHC.Real.$w$s$cround_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vMB,
                       label: GHC.Real.$w$s$cround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vMB: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1vMC; else goto c1vMD;
       c1vMC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vMD: // global
           I64[Sp - 16] = block_c1vLB_info;
           R4 = R4;
           R3 = R3;
           _s1sCK::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s1sCK::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vNM_srtd" {
     u1vNM_srtd:
         const S1sVz_srt;
         const 149;
         const 288230376151711745;
         const 4611686018706309632;
         const 1048576;
 },
 _c1vLB() //  [R1, R2]
         { info_tbl: [(c1vLB,
                       label: block_c1vLB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vLB: // global
           I64[Sp - 8] = block_c1vLD_info;
           _s1sCO::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1sCO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1vNG; else goto c1vLE;
       u1vNG: // global
           call _c1vLD(R1) args: 0, res: 0, upd: 0;
       c1vLE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vNN_srtd" {
     u1vNN_srtd:
         const S1sVz_srt;
         const 149;
         const 288230376151711745;
         const 4611686018706309632;
         const 1048576;
 },
 _c1vLD() //  [R1]
         { info_tbl: [(c1vLD,
                       label: block_c1vLD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vLD: // global
           I64[Sp - 16] = block_c1vLI_info;
           _s1sCR::P64 = P64[R1 + 7];
           R2 = _s1sCR::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _s1sCR::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.absInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vNO_srtd" {
     u1vNO_srtd:
         const S1sVz_srt;
         const 149;
         const 288230376151711745;
         const 4611686018706309632;
         const 1048576;
 },
 _c1vLI() //  [R1]
         { info_tbl: [(c1vLI,
                       label: block_c1vLI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vLI: // global
           I64[Sp] = block_c1vLM_info;
           R5 = GHC.Real.even2_closure;
           R4 = GHC.Real.$fEnumRatio1_closure;
           R3 = P64[Sp + 8];
           R2 = R1;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vNP_srtd" {
     u1vNP_srtd:
         const S1sVz_srt;
         const 149;
         const 1;
         const 4611686018706309120;
         const 1048576;
 },
 _c1vLM() //  [R1]
         { info_tbl: [(c1vLM,
                       label: block_c1vLM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vLM: // global
           I64[Sp] = block_c1vLO_info;
           R2 = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vNQ_srtd" {
     u1vNQ_srtd:
         const S1sVz_srt;
         const 149;
         const 1;
         const 4611686018706309120;
         const 1048576;
 },
 _c1vLO() //  [R1]
         { info_tbl: [(c1vLO,
                       label: block_c1vLO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vLO: // global
           I64[Sp - 8] = block_c1vLS_info;
           R3 = GHC.Real.$fRealFracRatio2_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vNR_srtd" {
     u1vNR_srtd:
         const S1sVz_srt;
         const 127;
         const 1;
         const 4611686018706309120;
 },
 _c1vLS() //  [R1]
         { info_tbl: [(c1vLS,
                       label: block_c1vLS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vLS: // global
           if (R1 == 1) goto u1vNC; else goto c1vN0;
       u1vNC: // global
           Sp = Sp + 32;
           call _c1vNA() args: 0, res: 0, upd: 0;
       c1vN0: // global
           I64[Sp] = block_c1vMJ_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vNS_srtd" {
     u1vNS_srtd:
         const S1sVz_srt;
         const 127;
         const 1;
         const 4611686018706309120;
 },
 _c1vMJ() //  [R1]
         { info_tbl: [(c1vMJ,
                       label: block_c1vMJ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vMJ: // global
           if (R1 == 1) goto c1vNm; else goto c1vN7;
       c1vNm: // global
           I64[Sp + 8] = block_c1vNk_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
       c1vN7: // global
           _s1sCX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1vN4_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _s1sCX::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vNT_srtd" {
     u1vNT_srtd:
         const S1sVz_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1vNk() //  [R1]
         { info_tbl: [(c1vNk,
                       label: block_c1vNk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vNk: // global
           if (R1 & 7 == 1) goto u1vNE; else goto u1vNF;
       u1vNE: // global
           Sp = Sp + 8;
           call _s1sCZ() args: 0, res: 0, upd: 0;
       u1vNF: // global
           Sp = Sp + 24;
           call _c1vNA() args: 0, res: 0, upd: 0;
     }
 },
 _c1vNA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vNA: // global
           R1 = P64[Sp];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1vNU_srtd" {
     u1vNU_srtd:
         const S1sVz_srt;
         const 127;
         const 1;
         const 4611686018697920512;
 },
 _c1vN4() //  [R1]
         { info_tbl: [(c1vN4,
                       label: block_c1vN4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vN4: // global
           if (R1 == 1) goto u1vND; else goto c1vNd;
       u1vND: // global
           Sp = Sp + 8;
           call _s1sCZ() args: 0, res: 0, upd: 0;
       c1vNd: // global
           R1 = GHC.Real.$fRealFracRatio1_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s1sCZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1sCZ: // global
           I64[Sp - 8] = block_c1vM1_info;
           R2 = P64[Sp + 24];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vNV_srtd" {
     u1vNV_srtd:
         const S1sVz_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1vM1() //  [R1]
         { info_tbl: [(c1vM1,
                       label: block_c1vM1_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vM1: // global
           I64[Sp] = block_c1vM5_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vNW_srtd" {
     u1vNW_srtd:
         const S1sVz_srt;
         const 127;
         const 1;
         const 4611686018429485056;
 },
 _c1vM5() //  [R1]
         { info_tbl: [(c1vM5,
                       label: block_c1vM5_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vM5: // global
           _s1sCS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1vM9_info;
           R3 = _s1sCS::P64;
           R2 = GHC.Real.even1_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vNX_srtd" {
     u1vNX_srtd:
         const S1sVz_srt;
         const 127;
         const 1;
         const 4611686018427387904;
 },
 _c1vM9() //  [R1]
         { info_tbl: [(c1vM9,
                       label: block_c1vM9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vM9: // global
           I64[Sp] = block_c1vMd_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vMd() //  [R1]
         { info_tbl: [(c1vMd,
                       label: block_c1vMd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vMd: // global
           _s1sD3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1vMh_info;
           R3 = _s1sD3::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vMh() //  [R1]
         { info_tbl: [(c1vMh,
                       label: block_c1vMh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vMh: // global
           _s1sD1::P64 = P64[Sp + 16];
           if (R1 == 1) goto c1vMV; else goto c1vMR;
       c1vMV: // global
           Hp = Hp + 24;
           _s1sD4::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1vMY; else goto c1vMX;
       c1vMX: // global
           I64[Hp - 16] = sat_s1sD6_info;
           P64[Hp] = _s1sD1::P64;
           R2 = _s1sD1::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
       c1vMR: // global
           Hp = Hp + 24;
           _s1sD4::I64 = R1;
           if (Hp > HpLim) (likely: False) goto c1vMY; else goto c1vMT;
       c1vMY: // global
           HpAlloc = 24;
           R1 = _s1sD4::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1vMT: // global
           I64[Hp - 16] = sat_s1sD5_info;
           P64[Hp] = _s1sD1::P64;
           R2 = _s1sD1::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.396647433 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$cround_closure" {
     GHC.Real.$fRealFracRatio_$s$cround_closure:
         const GHC.Real.$fRealFracRatio_$s$cround_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$s$cround_entry() //  [R2, R3]
         { info_tbl: [(c1vPJ,
                       label: GHC.Real.$fRealFracRatio_$s$cround_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vPJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vPK; else goto c1vPL;
       c1vPK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$cround_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vPL: // global
           I64[Sp - 16] = block_c1vPG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1vPP; else goto c1vPH;
       u1vPP: // global
           call _c1vPG(R1) args: 0, res: 0, upd: 0;
       c1vPH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vPG() //  [R1]
         { info_tbl: [(c1vPG,
                       label: block_c1vPG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vPG: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cround_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.404836438 UTC

[section ""data" . GHC.Real.$w$cround_closure" {
     GHC.Real.$w$cround_closure:
         const GHC.Real.$w$cround_info;
         const 0;
 },
 sat_s1sDS_entry() //  [R1]
         { info_tbl: [(c1vRh,
                       label: sat_s1sDS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vRh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vRi; else goto c1vRj;
       c1vRi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vRj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sDT_entry() //  [R1]
         { info_tbl: [(c1vRq,
                       label: sat_s1sDT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vRq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1vRr; else goto c1vRs;
       c1vRr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vRs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1vTN_srtd" {
     u1vTN_srtd:
         const S1sVz_srt+584;
         const 78;
         const 9156733004435457;
         const 8192;
 },
 GHC.Real.$w$cround_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1vRt,
                       label: GHC.Real.$w$cround_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vRt: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c1vRu; else goto c1vRv;
       c1vRu: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$cround_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vRv: // global
           I64[Sp - 24] = block_c1vQ4_info;
           R5 = R5;
           R4 = R4;
           _s1sDg::P64 = R3;
           R3 = R3;
           _s1sDf::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s1sDf::P64;
           P64[Sp - 8] = _s1sDg::P64;
           Sp = Sp - 24;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vTO_srtd" {
     u1vTO_srtd:
         const S1sVz_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1vQ4() //  [R1, R2]
         { info_tbl: [(c1vQ4,
                       label: block_c1vQ4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQ4: // global
           I64[Sp - 8] = block_c1vQ6_info;
           _s1sDk::P64 = R1;
           R1 = R2;
           P64[Sp] = _s1sDk::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1vTC; else goto c1vQ7;
       u1vTC: // global
           call _c1vQ6(R1) args: 0, res: 0, upd: 0;
       c1vQ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vTP_srtd" {
     u1vTP_srtd:
         const S1sVz_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1vQ6() //  [R1]
         { info_tbl: [(c1vQ6,
                       label: block_c1vQ6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQ6: // global
           I64[Sp - 16] = block_c1vQb_info;
           R2 = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vTQ_srtd" {
     u1vTQ_srtd:
         const S1sVz_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1vQb() //  [R1]
         { info_tbl: [(c1vQb,
                       label: block_c1vQb_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQb: // global
           I64[Sp] = block_c1vQf_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vTR_srtd" {
     u1vTR_srtd:
         const S1sVz_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1vQf() //  [R1]
         { info_tbl: [(c1vQf,
                       label: block_c1vQf_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQf: // global
           I64[Sp] = block_c1vQj_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vTS_srtd" {
     u1vTS_srtd:
         const S1sVz_srt+584;
         const 54;
         const 9156733004435457;
 },
 _c1vQj() //  [R1]
         { info_tbl: [(c1vQj,
                       label: block_c1vQj_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQj: // global
           I64[Sp - 8] = block_c1vQl_info;
           R4 = GHC.Real.even2_closure;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 32];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$w$cfromRational_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vTT_srtd" {
     u1vTT_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2233383035013;
 },
 _c1vQl() //  [R1, R2]
         { info_tbl: [(c1vQl,
                       label: block_c1vQl_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQl: // global
           _s1sDr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1vQn_info;
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 16];
           R3 = _s1sDr::P64;
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call GHC.Real.$w$c-_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vTU_srtd" {
     u1vTU_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023296645;
 },
 _c1vQn() //  [R1]
         { info_tbl: [(c1vQn,
                       label: block_c1vQn_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQn: // global
           I64[Sp] = block_c1vQp_info;
           R3 = R1;
           R2 = P64[Sp + 32];
           call GHC.Real.$w$csignum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vTV_srtd" {
     u1vTV_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1vQp() //  [R1, R2]
         { info_tbl: [(c1vQp,
                       label: block_c1vQp_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQp: // global
           I64[Sp - 16] = block_c1vQr_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           _s1sDA::P64 = R2;
           R2 = P64[Sp + 32];
           P64[Sp - 8] = _s1sDA::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vTW_srtd" {
     u1vTW_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1vQr() //  [R1, R2]
         { info_tbl: [(c1vQr,
                       label: block_c1vQr_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQr: // global
           I64[Sp - 16] = block_c1vQt_info;
           _s1sDD::P64 = R2;
           R2 = P64[Sp + 48];
           P64[Sp - 8] = _s1sDD::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vTX_srtd" {
     u1vTX_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1vQt() //  [R1]
         { info_tbl: [(c1vQt,
                       label: block_c1vQt_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQt: // global
           I64[Sp] = block_c1vQx_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vTY_srtd" {
     u1vTY_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1vQx() //  [R1]
         { info_tbl: [(c1vQx,
                       label: block_c1vQx_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQx: // global
           I64[Sp] = block_c1vQB_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vTZ_srtd" {
     u1vTZ_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1vQB() //  [R1]
         { info_tbl: [(c1vQB,
                       label: block_c1vQB_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQB: // global
           I64[Sp - 8] = block_c1vQD_info;
           R2 = P64[Sp + 64];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vU0_srtd" {
     u1vU0_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1vQD() //  [R1]
         { info_tbl: [(c1vQD,
                       label: block_c1vQD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQD: // global
           I64[Sp] = block_c1vQH_info;
           R2 = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vU1_srtd" {
     u1vU1_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1vQH() //  [R1]
         { info_tbl: [(c1vQH,
                       label: block_c1vQH_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQH: // global
           I64[Sp] = block_c1vQL_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vU2_srtd" {
     u1vU2_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1vQL() //  [R1]
         { info_tbl: [(c1vQL,
                       label: block_c1vQL_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQL: // global
           I64[Sp] = block_c1vRK_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vU3_srtd" {
     u1vU3_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1vRK() //  [R1]
         { info_tbl: [(c1vRK,
                       label: block_c1vRK_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vRK: // global
           if (R1 & 7 == 1) goto u1vTs; else goto c1vT9;
       u1vTs: // global
           Sp = Sp + 8;
           call _s1sDK() args: 0, res: 0, upd: 0;
       c1vT9: // global
           I64[Sp] = block_c1vT7_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vU4_srtd" {
     u1vU4_srtd:
         const S1sVz_srt+680;
         const 42;
         const 2199023288453;
 },
 _c1vT7() //  [R1]
         { info_tbl: [(c1vT7,
                       label: block_c1vT7_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vT7: // global
           if (R1 & 7 == 1) goto u1vTt; else goto u1vTu;
       u1vTt: // global
           Sp = Sp + 8;
           call _s1sDK() args: 0, res: 0, upd: 0;
       u1vTu: // global
           Sp = Sp + 64;
           call _c1vTj() args: 0, res: 0, upd: 0;
     }
 },
 _s1sDK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1sDK: // global
           I64[Sp - 8] = block_c1vQU_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 64];
           Sp = Sp - 8;
           call GHC.Real.$w$cfromInteger_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vU5_srtd" {
     u1vU5_srtd:
         const S1sVz_srt+696;
         const 40;
         const 549755813921;
 },
 _c1vQU() //  [R1, R2]
         { info_tbl: [(c1vQU,
                       label: block_c1vQU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vQU: // global
           I64[Sp - 16] = block_c1vRO_info;
           _s1sDN::P64 = R2;
           R2 = P64[Sp + 8];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[Sp + 40];
           P64[Sp - 24] = R1;
           P64[Sp - 8] = _s1sDN::P64;
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vU6_srtd" {
     u1vU6_srtd:
         const S1sVz_srt+696;
         const 40;
         const 549755813921;
 },
 _c1vRO() //  [R1]
         { info_tbl: [(c1vRO,
                       label: block_c1vRO_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vRO: // global
           if (R1 & 7 == 1) goto u1vTv; else goto c1vSD;
       u1vTv: // global
           Sp = Sp + 8;
           call _s1sDU() args: 0, res: 0, upd: 0;
       c1vSD: // global
           I64[Sp] = block_c1vSB_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 48];
           P64[Sp - 8] = P64[Sp + 8];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vU7_srtd" {
     u1vU7_srtd:
         const S1sVz_srt+696;
         const 40;
         const 549755813921;
 },
 _c1vSB() //  [R1]
         { info_tbl: [(c1vSB,
                       label: block_c1vSB_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vSB: // global
           if (R1 & 7 == 1) goto u1vTw; else goto c1vSO;
       u1vTw: // global
           Sp = Sp + 8;
           call _s1sDU() args: 0, res: 0, upd: 0;
       c1vSO: // global
           I64[Sp] = block_c1vSM_info;
           R3 = P64[Sp + 80];
           R2 = P64[Sp + 96];
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _s1sDU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1sDU: // global
           I64[Sp - 8] = block_c1vS6_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 48];
           P64[Sp - 16] = P64[Sp + 32];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vU8_srtd" {
     u1vU8_srtd:
         const S1sVz_srt+736;
         const 35;
         const 17179869185;
 },
 _c1vS6() //  [R1]
         { info_tbl: [(c1vS6,
                       label: block_c1vS6_info
                       rep:StackRep [False, False, False, False, True, False, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vS6: // global
           if (R1 & 7 == 1) goto u1vTz; else goto c1vSi;
       u1vTz: // global
           Sp = Sp + 104;
           call _c1vSo() args: 0, res: 0, upd: 0;
       c1vSi: // global
           I64[Sp] = block_c1vSg_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 48];
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1vU9_srtd" {
     u1vU9_srtd:
         const S1sVz_srt+736;
         const 35;
         const 17179869185;
 },
 _c1vSg() //  [R1]
         { info_tbl: [(c1vSg,
                       label: block_c1vSg_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vSg: // global
           if (R1 & 7 == 1) goto u1vTA; else goto u1vTB;
       u1vTA: // global
           Sp = Sp + 104;
           call _c1vSo() args: 0, res: 0, upd: 0;
       u1vTB: // global
           Sp = Sp + 8;
           call _s1sDO() args: 0, res: 0, upd: 0;
     }
 },
 _c1vSo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vSo: // global
           R1 = GHC.Real.$fRealFracRatio1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1vSM() //  [R1]
         { info_tbl: [(c1vSM,
                       label: block_c1vSM_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vSM: // global
           if (R1 & 7 == 1) goto u1vTx; else goto u1vTy;
       u1vTx: // global
           Sp = Sp + 8;
           call _s1sDO() args: 0, res: 0, upd: 0;
       u1vTy: // global
           Sp = Sp + 80;
           call _c1vTj() args: 0, res: 0, upd: 0;
     }
 },
 _s1sDO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1sDO: // global
           I64[Sp - 8] = block_c1vR1_info;
           R2 = P64[Sp + 88];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vR1() //  [R1]
         { info_tbl: [(c1vR1,
                       label: block_c1vR1_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vR1: // global
           I64[Sp] = block_c1vR5_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vR5() //  [R1]
         { info_tbl: [(c1vR5,
                       label: block_c1vR5_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vR5: // global
           _s1sDn::P64 = P64[Sp + 72];
           I64[Sp + 72] = block_c1vR9_info;
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 64];
           R3 = _s1sDn::P64;
           R2 = P64[Sp + 88];
           P64[Sp + 96] = R1;
           Sp = Sp + 72;
           call GHC.Real.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vR9() //  [R1]
         { info_tbl: [(c1vR9,
                       label: block_c1vR9_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vR9: // global
           _s1sDk::P64 = P64[Sp + 8];
           _s1sDQ::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c1vRV; else goto c1vRZ;
       c1vRV: // global
           Hp = Hp + 24;
           _s1sDR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1vS2; else goto c1vRX;
       c1vRX: // global
           I64[Hp - 16] = sat_s1sDS_info;
           P64[Hp] = _s1sDQ::P64;
           R2 = _s1sDQ::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1sDk::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
       c1vRZ: // global
           Hp = Hp + 24;
           _s1sDR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1vS2; else goto c1vS1;
       c1vS2: // global
           HpAlloc = 24;
           R1 = _s1sDR::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1vS1: // global
           I64[Hp - 16] = sat_s1sDT_info;
           P64[Hp] = _s1sDQ::P64;
           R2 = _s1sDQ::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s1sDk::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _c1vTj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vTj: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.479030525 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$cround_closure" {
     GHC.Real.$fRealFracRatio_$cround_closure:
         const GHC.Real.$fRealFracRatio_$cround_info;
         const 0;
 },
 GHC.Real.$fRealFracRatio_$cround_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vXx,
                       label: GHC.Real.$fRealFracRatio_$cround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vXx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1vXy; else goto c1vXz;
       c1vXy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$cround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vXz: // global
           I64[Sp - 24] = block_c1vXu_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1vXD; else goto c1vXv;
       u1vXD: // global
           call _c1vXu(R1) args: 0, res: 0, upd: 0;
       c1vXv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vXu() //  [R1]
         { info_tbl: [(c1vXu,
                       label: block_c1vXu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vXu: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cround_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.48591485 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$ctruncate_closure" {
     GHC.Real.$fRealFracRatio_$s$ctruncate_closure:
         const GHC.Real.$fRealFracRatio_$s$ctruncate_info;
         const 0;
 },
 sat_s1sEk_entry() //  [R1]
         { info_tbl: [(c1vY6,
                       label: sat_s1sEk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vY6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1vY7; else goto c1vY8;
       c1vY7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1vY8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c1vY1_info;
           R3 = GHC.Real.even1_closure;
           _s1sEc::P64 = P64[R1 + 24];
           R2 = _s1sEc::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s1sEc::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1vY1() //  [R1]
         { info_tbl: [(c1vY1,
                       label: block_c1vY1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vY1: // global
           if (R1 == 1) goto c1vY5; else goto c1vY4;
       c1vY5: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c1vY4: // global
           _s1sEc::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1vYb_info;
           R3 = _s1sEc::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1vYb() //  [R1]
         { info_tbl: [(c1vYb,
                       label: block_c1vYb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vYb: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fRealFracRatio_$s$ctruncate_entry() //  [R2, R3]
         { info_tbl: [(c1vYi,
                       label: GHC.Real.$fRealFracRatio_$s$ctruncate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vYi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1vYo; else goto c1vYp;
       c1vYo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$s$ctruncate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vYp: // global
           I64[Sp - 16] = block_c1vXS_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1vYy; else goto c1vXT;
       u1vYy: // global
           call _c1vXS(R1) args: 0, res: 0, upd: 0;
       c1vXT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vXS() //  [R1]
         { info_tbl: [(c1vXS,
                       label: block_c1vXS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vXS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1vYs; else goto c1vYr;
       c1vYs: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1vYr: // global
           _s1sEb::P64 = P64[R1 + 7];
           _s1sEc::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s1sEk_info;
           P64[Hp - 8] = _s1sEb::P64;
           P64[Hp] = _s1sEc::P64;
           I64[Sp] = block_c1vYj_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vYj() //  [R1]
         { info_tbl: [(c1vYj,
                       label: block_c1vYj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vYj: // global
           I64[Sp] = block_c1vYn_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vYn() //  [R1]
         { info_tbl: [(c1vYn,
                       label: block_c1vYn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vYn: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.500001518 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$ctruncate_closure" {
     GHC.Real.$fRealFracRatio_$ctruncate_closure:
         const GHC.Real.$fRealFracRatio_$ctruncate_info;
 },
 GHC.Real.$fRealFracRatio_$ctruncate_entry() //  [R2, R3, R4]
         { info_tbl: [(c1vZh,
                       label: GHC.Real.$fRealFracRatio_$ctruncate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vZh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1vZl; else goto c1vZm;
       c1vZl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_$ctruncate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1vZm: // global
           I64[Sp - 24] = block_c1vZe_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1vZq; else goto c1vZf;
       u1vZq: // global
           call _c1vZe(R1) args: 0, res: 0, upd: 0;
       c1vZf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1vZe() //  [R1]
         { info_tbl: [(c1vZe,
                       label: block_c1vZe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vZe: // global
           _s1sEm::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1vZk_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _s1sEm::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cproperFraction_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1vZk() //  [R1]
         { info_tbl: [(c1vZk,
                       label: block_c1vZk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vZk: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.507462383 UTC

[section ""data" . GHC.Real.$fRealFracRatio_$s$fRealFracRatio_closure" {
     GHC.Real.$fRealFracRatio_$s$fRealFracRatio_closure:
         const GHC.Real.C:RealFrac_con_info;
         const GHC.Real.$fRealFracRatio_$s$fRealRatio_closure+1;
         const GHC.Real.$fFractionalRatio_$s$fFractionalRatio_closure+1;
         const GHC.Real.$fEnumRatio_$s$cproperFraction_closure+2;
         const GHC.Real.$fRealFracRatio_$s$ctruncate_closure+2;
         const GHC.Real.$fRealFracRatio_$s$cround_closure+2;
         const GHC.Real.$fRealFracRatio_$s$cceiling_closure+2;
         const GHC.Real.$fRealFracRatio_$s$cfloor_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.511205587 UTC

[section ""data" . GHC.Real.$fRealFracRatio_closure" {
     GHC.Real.$fRealFracRatio_closure:
         const GHC.Real.$fRealFracRatio_info;
         const 0;
 },
 sat_s1sEB_entry() //  [R1, R2, R3]
         { info_tbl: [(c1vZP,
                       label: sat_s1sEB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vZP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$cfloor_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sEA_entry() //  [R1, R2, R3]
         { info_tbl: [(c1vZX,
                       label: sat_s1sEA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1vZX: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$cceiling_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sEz_entry() //  [R1, R2, R3]
         { info_tbl: [(c1w05,
                       label: sat_s1sEz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w05: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$cround_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sEy_entry() //  [R1, R2, R3]
         { info_tbl: [(c1w0d,
                       label: sat_s1sEy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w0d: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fRealFracRatio_$ctruncate_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sEx_entry() //  [R1, R2, R3]
         { info_tbl: [(c1w0l,
                       label: sat_s1sEx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w0l: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fEnumRatio_$cproperFraction_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sEw_entry() //  [R1]
         { info_tbl: [(c1w0s,
                       label: sat_s1sEw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w0s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1w0t; else goto c1w0u;
       c1w0t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1w0u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fFractionalRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sEv_entry() //  [R1]
         { info_tbl: [(c1w0z,
                       label: sat_s1sEv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w0z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1w0A; else goto c1w0B;
       c1w0A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1w0B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fRealRatio_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fRealFracRatio_entry() //  [R2]
         { info_tbl: [(c1w0D,
                       label: GHC.Real.$fRealFracRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w0D: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c1w0H; else goto c1w0G;
       c1w0H: // global
           HpAlloc = 192;
           R2 = R2;
           R1 = GHC.Real.$fRealFracRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1w0G: // global
           I64[Hp - 184] = sat_s1sEB_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s1sEA_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1sEz_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s1sEy_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s1sEx_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s1sEw_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s1sEv_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 118;
           P64[Hp - 24] = Hp - 134;
           P64[Hp - 16] = Hp - 150;
           P64[Hp - 8] = Hp - 166;
           P64[Hp] = Hp - 182;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.528023524 UTC

[section ""data" . g_r1j3N_closure" {
     g_r1j3N_closure:
         const g_r1j3N_info;
         const 0;
 },
 section ""relreadonly" . u1w2u_srtd" {
     u1w2u_srtd:
         const S1sVz_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 g_r1j3N_entry() //  [R2, R3, R4]
         { info_tbl: [(c1w1x,
                       label: g_r1j3N_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w1x: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1w1y; else goto u1w2o;
       c1w1y: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = g_r1j3N_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u1w2o: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c1w1s() args: 0, res: 0, upd: 0;
     }
 },
 _c1w1s() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w1s: // global
           I64[Sp - 8] = block_c1w1v_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1w2v_srtd" {
     u1w2v_srtd:
         const S1sVz_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1w1v() //  [R1]
         { info_tbl: [(c1w1v,
                       label: block_c1w1v_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w1v: // global
           I64[Sp] = block_c1w1C_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1w2w_srtd" {
     u1w2w_srtd:
         const S1sVz_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1w1C() //  [R1]
         { info_tbl: [(c1w1C,
                       label: block_c1w1C_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w1C: // global
           _s1sED::P64 = P64[Sp + 16];
           if (R1 == 1) goto c1w2i; else goto c1w1K;
       c1w2i: // global
           I64[Sp] = block_c1w2c_info;
           R3 = GHC.Real.even2_closure;
           R2 = _s1sED::P64;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       c1w1K: // global
           I64[Sp] = block_c1w1H_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _s1sED::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1w2x_srtd" {
     u1w2x_srtd:
         const S1sVz_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1w2c() //  [R1]
         { info_tbl: [(c1w2c,
                       label: block_c1w2c_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w2c: // global
           _s1sEC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1w2g_info;
           R3 = _s1sEC::P64;
           R2 = _s1sEC::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1w2y_srtd" {
     u1w2y_srtd:
         const S1sVz_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1w2g() //  [R1]
         { info_tbl: [(c1w2g,
                       label: block_c1w2g_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w2g: // global
           P64[Sp] = R1;
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           call _c1w1s() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1w2z_srtd" {
     u1w2z_srtd:
         const S1sVz_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1w1H() //  [R1]
         { info_tbl: [(c1w1H,
                       label: block_c1w1H_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w1H: // global
           _s1sEC::P64 = P64[Sp + 8];
           _s1sEE::P64 = P64[Sp + 24];
           if (R1 == 1) goto c1w29; else goto c1w1Z;
       c1w29: // global
           R3 = _s1sEE::P64;
           R2 = _s1sEC::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
       c1w1Z: // global
           I64[Sp] = block_c1w1O_info;
           R3 = _s1sEE::P64;
           R2 = _s1sEC::P64;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1w2A_srtd" {
     u1w2A_srtd:
         const S1sVz_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1w1O() //  [R1]
         { info_tbl: [(c1w1O,
                       label: block_c1w1O_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w1O: // global
           I64[Sp] = block_c1w1S_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 16];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1w2B_srtd" {
     u1w2B_srtd:
         const S1sVz_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1w1S() //  [R1]
         { info_tbl: [(c1w1S,
                       label: block_c1w1S_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w1S: // global
           _s1sEC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1w1W_info;
           R3 = _s1sEC::P64;
           R2 = _s1sEC::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1w2C_srtd" {
     u1w2C_srtd:
         const S1sVz_srt;
         const 154;
         const 1;
         const 4611686018427388416;
         const 33554432;
 },
 _c1w1W() //  [R1]
         { info_tbl: [(c1w1W,
                       label: block_c1w1W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w1W: // global
           P64[Sp] = R1;
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           call _c1w1s() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.553661927 UTC

[section ""data" . GHC.Real.^_f_closure" {
     GHC.Real.^_f_closure:
         const GHC.Real.^_f_info;
         const 0;
 },
 section ""relreadonly" . u1w4p_srtd" {
     u1w4p_srtd:
         const S1sVz_srt;
         const 158;
         const 1;
         const 4611686018427388416;
         const 838860800;
 },
 GHC.Real.^_f_entry() //  [R2, R3]
         { info_tbl: [(c1w3z,
                       label: GHC.Real.^_f_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w3z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1w3A; else goto u1w4l;
       c1w3A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_f_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1w4l: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1w3u() args: 0, res: 0, upd: 0;
     }
 },
 _c1w3u() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w3u: // global
           I64[Sp - 8] = block_c1w3x_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1w4q_srtd" {
     u1w4q_srtd:
         const S1sVz_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1w3x() //  [R1]
         { info_tbl: [(c1w3x,
                       label: block_c1w3x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w3x: // global
           I64[Sp] = block_c1w3E_info;
           R3 = GHC.Real.even1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1w4r_srtd" {
     u1w4r_srtd:
         const S1sVz_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1w3E() //  [R1]
         { info_tbl: [(c1w3E,
                       label: block_c1w3E_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w3E: // global
           _s1sEO::P64 = P64[Sp + 16];
           if (R1 == 1) goto c1w4f; else goto c1w3M;
       c1w4f: // global
           I64[Sp] = block_c1w49_info;
           R3 = GHC.Real.even2_closure;
           R2 = _s1sEO::P64;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       c1w3M: // global
           I64[Sp] = block_c1w3J_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _s1sEO::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1w4s_srtd" {
     u1w4s_srtd:
         const S1sVz_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1w49() //  [R1]
         { info_tbl: [(c1w49,
                       label: block_c1w49_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w49: // global
           _s1sEN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1w4d_info;
           R3 = _s1sEN::P64;
           R2 = _s1sEN::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1w4t_srtd" {
     u1w4t_srtd:
         const S1sVz_srt;
         const 157;
         const 1;
         const 4611686018427388416;
         const 301989888;
 },
 _c1w4d() //  [R1]
         { info_tbl: [(c1w4d,
                       label: block_c1w4d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w4d: // global
           P64[Sp] = R1;
           P64[Sp + 8] = P64[Sp + 8];
           call _c1w3u() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1w4u_srtd" {
     u1w4u_srtd:
         const S1sVz_srt;
         const 157;
         const 1;
         const 512;
         const 268435456;
 },
 _c1w3J() //  [R1]
         { info_tbl: [(c1w3J,
                       label: block_c1w3J_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w3J: // global
           if (R1 == 1) goto c1w46; else goto c1w3X;
       c1w46: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1w3X: // global
           I64[Sp] = block_c1w3Q_info;
           R3 = GHC.Real.even2_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1w4v_srtd" {
     u1w4v_srtd:
         const S1sVz_srt;
         const 157;
         const 1;
         const 0;
         const 268435456;
 },
 _c1w3Q() //  [R1]
         { info_tbl: [(c1w3Q,
                       label: block_c1w3Q_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w3Q: // global
           I64[Sp] = block_c1w3U_info;
           _s1sEN::P64 = P64[Sp + 8];
           R3 = _s1sEN::P64;
           R2 = _s1sEN::P64;
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1w3U() //  [R1]
         { info_tbl: [(c1w3U,
                       label: block_c1w3U_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w3U: // global
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = R1;
           Sp = Sp + 24;
           call g_r1j3N_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.575713486 UTC

[section ""cstring" . lvl5_r1j3O_bytes" {
     lvl5_r1j3O_bytes:
         I8[] [78,101,103,97,116,105,118,101,32,101,120,112,111,110,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.577749465 UTC

[section ""data" . GHC.Real.^1_closure" {
     GHC.Real.^1_closure:
         const GHC.Real.^1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.^1_entry() //  [R1]
         { info_tbl: [(c1w5o,
                       label: GHC.Real.^1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w5o: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1w5p; else goto c1w5q;
       c1w5p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1w5q: // global
           (_c1w5j::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1w5j::I64 == 0) goto c1w5l; else goto c1w5k;
       c1w5l: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1w5k: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1w5j::I64;
           I64[Sp - 24] = block_c1w5m_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1w5m() //  [R1]
         { info_tbl: [(c1w5m,
                       label: block_c1w5m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w5m: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.583877468 UTC

[section ""data" . GHC.Real.^_$s^_closure" {
     GHC.Real.^_$s^_closure:
         const GHC.Real.^_$s^_info;
         const 0;
 },
 section ""relreadonly" . u1w69_srtd" {
     u1w69_srtd:
         const S1sVz_srt+1008;
         const 35;
         const 28051505153;
 },
 GHC.Real.^_$s^_entry() //  [R2, R3]
         { info_tbl: [(c1w5P,
                       label: GHC.Real.^_$s^_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w5P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1w5Q; else goto c1w5R;
       c1w5Q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_$s^_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1w5R: // global
           I64[Sp - 24] = block_c1w5K_info;
           _s1sEY::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1sEX::P64 = R2;
           R2 = _s1sEY::P64;
           P64[Sp - 16] = _s1sEX::P64;
           P64[Sp - 8] = _s1sEY::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1w6a_srtd" {
     u1w6a_srtd:
         const S1sVz_srt+1008;
         const 35;
         const 19461570561;
 },
 _c1w5K() //  [R1]
         { info_tbl: [(c1w5K,
                       label: block_c1w5K_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w5K: // global
           if (R1 == 1) goto c1w5O; else goto c1w5N;
       c1w5O: // global
           R1 = GHC.Real.^1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1w5N: // global
           I64[Sp] = block_c1w5U_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1w5U() //  [R1]
         { info_tbl: [(c1w5U,
                       label: block_c1w5U_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w5U: // global
           if (R1 == 1) goto c1w65; else goto c1w61;
       c1w65: // global
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1w61: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.^_f_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.593138719 UTC

[section ""data" . GHC.Real.$w$s$cfromEnum_closure" {
     GHC.Real.$w$s$cfromEnum_closure:
         const GHC.Real.$w$s$cfromEnum_info;
         const 0;
 },
 GHC.Real.$w$s$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c1w6B,
                       label: GHC.Real.$w$s$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w6B: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1w6C; else goto c1w6D;
       c1w6C: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1w6D: // global
           I64[Sp - 24] = block_c1w6w_info;
           _s1sF2::P64 = R3;
           R3 = GHC.Real.even1_closure;
           _s1sF1::P64 = R2;
           R2 = _s1sF2::P64;
           P64[Sp - 16] = _s1sF1::P64;
           P64[Sp - 8] = _s1sF2::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1w6w() //  [R1]
         { info_tbl: [(c1w6w,
                       label: block_c1w6w_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w6w: // global
           if (R1 == 1) goto c1w6A; else goto c1w6z;
       c1w6A: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1w6z: // global
           _s1sF2::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1w6G_info;
           R3 = _s1sF2::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1w6G() //  [R1]
         { info_tbl: [(c1w6G,
                       label: block_c1w6G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w6G: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.600905661 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$cfromEnum_closure" {
     GHC.Real.$fEnumRatio_$s$cfromEnum_closure:
         const GHC.Real.$fEnumRatio_$s$cfromEnum_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$s$cfromEnum_entry() //  [R2]
         { info_tbl: [(c1w77,
                       label: GHC.Real.$fEnumRatio_$s$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w77: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1w7f; else goto c1w7g;
       c1w7f: // global
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$s$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1w7g: // global
           I64[Sp - 8] = block_c1w74_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1w7l; else goto c1w75;
       u1w7l: // global
           call _c1w74(R1) args: 0, res: 0, upd: 0;
       c1w75: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1w74() //  [R1]
         { info_tbl: [(c1w74,
                       label: block_c1w74_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w74: // global
           I64[Sp] = block_c1w7a_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$cfromEnum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1w7a() //  [R1]
         { info_tbl: [(c1w7a,
                       label: block_c1w7a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w7a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1w7k; else goto c1w7j;
       c1w7k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1w7j: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.610024909 UTC

[section ""data" . GHC.Real.$fEnumRatio_$cfromEnum_closure" {
     GHC.Real.$fEnumRatio_$cfromEnum_closure:
         const GHC.Real.$fEnumRatio_$cfromEnum_info;
 },
 sat_s1sFl_entry() //  [R1]
         { info_tbl: [(c1w7R,
                       label: sat_s1sFl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w7R: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1w7S; else goto c1w7T;
       c1w7S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1w7T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1w7P_info;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_pp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c1w7P() //  [R1]
         { info_tbl: [(c1w7P,
                       label: block_c1w7P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w7P: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$fEnumRatio_$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c1w7X,
                       label: GHC.Real.$fEnumRatio_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w7X: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1w87; else goto c1w88;
       c1w87: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1w88: // global
           I64[Sp - 16] = block_c1w7G_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1w8g; else goto c1w7H;
       u1w8g: // global
           call _c1w7G(R1) args: 0, res: 0, upd: 0;
       c1w7H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1w7G() //  [R1]
         { info_tbl: [(c1w7G,
                       label: block_c1w7G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w7G: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1w8b; else goto c1w8a;
       c1w8b: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1w8a: // global
           _s1sFg::P64 = P64[R1 + 7];
           _s1sFh::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s1sFl_info;
           _s1sFd::P64 = P64[Sp + 8];
           P64[Hp - 16] = _s1sFd::P64;
           P64[Hp - 8] = _s1sFg::P64;
           P64[Hp] = _s1sFh::P64;
           I64[Sp + 8] = block_c1w7Y_info;
           R2 = _s1sFd::P64;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Hp - 32;
           Sp = Sp - 8;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1w7Y() //  [R1]
         { info_tbl: [(c1w7Y,
                       label: block_c1w7Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w7Y: // global
           I64[Sp] = block_c1w82_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1w82() //  [R1]
         { info_tbl: [(c1w82,
                       label: block_c1w82_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w82: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1w8f; else goto c1w8e;
       c1w8f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1w8e: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.62264415 UTC

[section ""data" . GHC.Real.ratioPrec1_closure" {
     GHC.Real.ratioPrec1_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.624303863 UTC

[section ""cstring" . GHC.Real.$fShowRatio2_bytes" {
     GHC.Real.$fShowRatio2_bytes:
         I8[] [32,37,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.627681551 UTC

[section ""data" . GHC.Real.$w$s$cshowsPrec_closure" {
     GHC.Real.$w$s$cshowsPrec_closure:
         const GHC.Real.$w$s$cshowsPrec_info;
         const 0;
 },
 GHC.Real.$w$s$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w8T: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Real.$w$s$cshowsPrec_entry(R5,
                                               R4,
                                               R3,
                                               R2,
                                               R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sFw_entry() //  [R1]
         { info_tbl: [(c1w9b,
                       label: sat_s1sFw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w9b: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1w9c; else goto c1w9d;
       c1w9c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1w9d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1w98_info;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1w98() //  [R1, R2]
         { info_tbl: [(c1w98,
                       label: block_c1w98_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w98: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1w9g; else goto c1w9f;
       c1w9g: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1w9f: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sFx_entry() //  [R1]
         { info_tbl: [(c1w9h,
                       label: sat_s1sFx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w9h: // global
           _s1sFx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1w9i; else goto c1w9j;
       c1w9j: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1w9l; else goto c1w9k;
       c1w9l: // global
           HpAlloc = 32;
           goto c1w9i;
       c1w9i: // global
           R1 = _s1sFx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1w9k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sFx::P64;
           _s1sFq::P64 = P64[_s1sFx::P64 + 16];
           _s1sFr::P64 = P64[_s1sFx::P64 + 24];
           I64[Hp - 24] = sat_s1sFw_info;
           P64[Hp - 8] = _s1sFq::P64;
           P64[Hp] = _s1sFr::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sFC_entry() //  [R1]
         { info_tbl: [(c1w9D,
                       label: sat_s1sFC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w9D: // global
           _s1sFC::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1w9E; else goto c1w9F;
       c1w9F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1w9H; else goto c1w9G;
       c1w9H: // global
           HpAlloc = 24;
           goto c1w9E;
       c1w9E: // global
           R1 = _s1sFC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1w9G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sFC::P64;
           _s1sFq::P64 = P64[_s1sFC::P64 + 16];
           _s1sFr::P64 = P64[_s1sFC::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s1sFr::P64;
           I64[Sp - 24] = block_c1w9A_info;
           R4 = Hp - 14;
           R3 = _s1sFq::P64;
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1w9A() //  [R1, R2]
         { info_tbl: [(c1w9A,
                       label: block_c1w9A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w9A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1w9K; else goto c1w9J;
       c1w9K: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1w9J: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sFD_entry() //  [R1]
         { info_tbl: [(c1w9L,
                       label: sat_s1sFD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w9L: // global
           _s1sFD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1w9M; else goto c1w9N;
       c1w9N: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1w9P; else goto c1w9O;
       c1w9P: // global
           HpAlloc = 32;
           goto c1w9M;
       c1w9M: // global
           R1 = _s1sFD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1w9O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sFD::P64;
           _s1sFq::P64 = P64[_s1sFD::P64 + 16];
           _s1sFr::P64 = P64[_s1sFD::P64 + 24];
           I64[Hp - 24] = sat_s1sFC_info;
           P64[Hp - 8] = _s1sFq::P64;
           P64[Hp] = _s1sFr::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sFH_entry() //  [R1]
         { info_tbl: [(c1w9T,
                       label: sat_s1sFH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w9T: // global
           _s1sFH::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1w9U; else goto c1w9V;
       c1w9V: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1w9X; else goto c1w9W;
       c1w9X: // global
           HpAlloc = 32;
           goto c1w9U;
       c1w9U: // global
           R1 = _s1sFH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1w9W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sFH::P64;
           _s1sFp::P64 = P64[_s1sFH::P64 + 16];
           _s1sFq::P64 = P64[_s1sFH::P64 + 24];
           _s1sFr::P64 = P64[_s1sFH::P64 + 32];
           I64[Hp - 24] = sat_s1sFD_info;
           P64[Hp - 8] = _s1sFq::P64;
           P64[Hp] = _s1sFr::P64;
           I64[Sp - 24] = block_c1w9Q_info;
           R4 = Hp - 24;
           R3 = _s1sFp::P64;
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1w9Q() //  [R1, R2]
         { info_tbl: [(c1w9Q,
                       label: block_c1w9Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1w9Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wa0; else goto c1w9Z;
       c1wa0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1w9Z: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$s$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1wa4,
                       label: GHC.Real.$w$s$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wa4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1wa8; else goto c1wa7;
       c1wa8: // global
           HpAlloc = 40;
           R1 = GHC.Real.$w$s$cshowsPrec_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c1wa7: // global
           if (%MO_S_Le_W64(R2, 7)) goto c1wa2; else goto c1wa3;
       c1wa2: // global
           I64[Hp - 32] = sat_s1sFx_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           _c1w90::P64 = Hp - 32;
           Hp = Hp - 8;
           R4 = _c1w90::P64;
           R3 = R3;
           R2 = 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
       c1wa3: // global
           I64[Hp - 32] = sat_s1sFH_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 32;
           R1 = GHC.Show.$fShow(,)4_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.65200578 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$cshowsPrec_closure" {
     GHC.Real.$fShowRatio_$s$cshowsPrec_closure:
         const GHC.Real.$fShowRatio_$s$cshowsPrec_info;
         const 0;
 },
 GHC.Real.$fShowRatio_$s$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c1wbb,
                       label: GHC.Real.$fShowRatio_$s$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wbb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1wbm; else goto c1wbn;
       c1wbm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$s$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wbn: // global
           I64[Sp - 24] = block_c1wb8_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1wbu; else goto c1wb9;
       u1wbu: // global
           call _c1wb8(R1) args: 0, res: 0, upd: 0;
       c1wb9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wb8() //  [R1]
         { info_tbl: [(c1wb8,
                       label: block_c1wb8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wb8: // global
           I64[Sp] = block_c1wbe_info;
           _s1sFM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1sFM::I64;
           if (R1 & 7 != 0) goto u1wbt; else goto c1wbf;
       u1wbt: // global
           call _c1wbe(R1) args: 0, res: 0, upd: 0;
       c1wbf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wbe() //  [R1]
         { info_tbl: [(c1wbe,
                       label: block_c1wbe_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wbe: // global
           _s1sFK::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1wbj_info;
           R5 = _s1sFK::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$s$cshowsPrec_entry(R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wbj() //  [R1, R2]
         { info_tbl: [(c1wbj,
                       label: block_c1wbj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wbj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wbs; else goto c1wbr;
       c1wbs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1wbr: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.663284311 UTC

[section ""data" . GHC.Real.$w$cshowsPrec_closure" {
     GHC.Real.$w$cshowsPrec_closure:
         const GHC.Real.$w$cshowsPrec_info;
 },
 GHC.Real.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wbR: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Real.$w$cshowsPrec_entry(R5,
                                             R4,
                                             R3,
                                             R2,
                                             R1) args: 8, res: 0, upd: 8;
     }
 },
 f_s1sFX_entry() //  [R1]
         { info_tbl: [(c1wbZ,
                       label: f_s1sFX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wbZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1wc0; else goto c1wc1;
       c1wc0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wc1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 g1_s1sFY_entry() //  [R1]
         { info_tbl: [(c1wc6,
                       label: g1_s1sFY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wc6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1wc7; else goto c1wc8;
       c1wc7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wc8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sG2_entry() //  [R1]
         { info_tbl: [(c1wcm,
                       label: sat_s1sG2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wcm: // global
           _s1sG2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1wcn; else goto c1wco;
       c1wco: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1wcq; else goto c1wcp;
       c1wcq: // global
           HpAlloc = 32;
           goto c1wcn;
       c1wcn: // global
           R1 = _s1sG2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wcp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sG2::P64;
           _s1sFY::P64 = P64[_s1sG2::P64 + 16];
           _s1sG0::P64 = P64[_s1sG2::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s1sFY::P64;
           P64[Hp] = _s1sG0::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sG3_entry() //  [R1, R2]
         { info_tbl: [(c1wcr,
                       label: sat_s1sG3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wcr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1wcv; else goto c1wcu;
       c1wcv: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1wcu: // global
           _s1sFX::P64 = P64[R1 + 7];
           _s1sFY::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s1sG2_info;
           P64[Hp - 8] = _s1sFY::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _s1sFX::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sG6_entry() //  [R1]
         { info_tbl: [(c1wcP,
                       label: sat_s1sG6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wcP: // global
           _s1sG6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1wcQ; else goto c1wcR;
       c1wcR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wcT; else goto c1wcS;
       c1wcT: // global
           HpAlloc = 24;
           goto c1wcQ;
       c1wcQ: // global
           R1 = _s1sG6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wcS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sG6::P64;
           _s1sFY::P64 = P64[_s1sG6::P64 + 16];
           _s1sG4::P64 = P64[_s1sG6::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s1sG4::P64;
           R2 = Hp - 14;
           R1 = _s1sFY::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sG7_entry() //  [R1]
         { info_tbl: [(c1wcU,
                       label: sat_s1sG7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wcU: // global
           _s1sG7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1wcV; else goto c1wcW;
       c1wcW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1wcY; else goto c1wcX;
       c1wcY: // global
           HpAlloc = 32;
           goto c1wcV;
       c1wcV: // global
           R1 = _s1sG7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wcX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sG7::P64;
           _s1sFY::P64 = P64[_s1sG7::P64 + 16];
           _s1sG4::P64 = P64[_s1sG7::P64 + 24];
           I64[Hp - 24] = sat_s1sG6_info;
           P64[Hp - 8] = _s1sFY::P64;
           P64[Hp] = _s1sG4::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sG8_entry() //  [R1]
         { info_tbl: [(c1wcZ,
                       label: sat_s1sG8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wcZ: // global
           _s1sG8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1wd0; else goto c1wd1;
       c1wd1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1wd3; else goto c1wd2;
       c1wd3: // global
           HpAlloc = 32;
           goto c1wd0;
       c1wd0: // global
           R1 = _s1sG8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wd2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sG8::P64;
           _s1sFX::P64 = P64[_s1sG8::P64 + 16];
           _s1sFY::P64 = P64[_s1sG8::P64 + 24];
           _s1sG4::P64 = P64[_s1sG8::P64 + 32];
           I64[Hp - 24] = sat_s1sG7_info;
           P64[Hp - 8] = _s1sFY::P64;
           P64[Hp] = _s1sG4::P64;
           R2 = Hp - 24;
           R1 = _s1sFX::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sG9_entry() //  [R1, R2]
         { info_tbl: [(c1wd5,
                       label: sat_s1sG9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wd5: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1wd9; else goto c1wd8;
       c1wd9: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1wd8: // global
           _s1sFX::P64 = P64[R1 + 7];
           _s1sFY::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s1sG8_info;
           P64[Hp - 40] = _s1sFX::P64;
           P64[Hp - 32] = _s1sFY::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$w$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1wdd,
                       label: GHC.Real.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wdd: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c1wdh; else goto c1wdg;
       c1wdh: // global
           HpAlloc = 88;
           R1 = GHC.Real.$w$cshowsPrec_closure;
           P64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c1wdg: // global
           I64[Hp - 80] = f_s1sFX_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = g1_s1sFY_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R5;
           _c1wbV::P64 = Hp - 80;
           _c1wc2::P64 = Hp - 48;
           if (%MO_S_Le_W64(R3, 7)) goto c1wdb; else goto c1wdc;
       c1wdb: // global
           I64[Hp - 16] = sat_s1sG3_info;
           P64[Hp - 8] = _c1wbV::P64;
           P64[Hp] = _c1wc2::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1wdc: // global
           I64[Hp - 16] = sat_s1sG9_info;
           P64[Hp - 8] = _c1wbV::P64;
           P64[Hp] = _c1wc2::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.686993649 UTC

[section ""data" . GHC.Real.$fShowRatio_$cshowsPrec_closure" {
     GHC.Real.$fShowRatio_$cshowsPrec_closure:
         const GHC.Real.$fShowRatio_$cshowsPrec_info;
 },
 GHC.Real.$fShowRatio_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c1wes,
                       label: GHC.Real.$fShowRatio_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wes: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1wew; else goto c1wex;
       c1wew: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wex: // global
           I64[Sp - 24] = block_c1wep_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1weF; else goto c1weq;
       u1weF: // global
           call _c1wep(R1) args: 0, res: 0, upd: 0;
       c1weq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wep() //  [R1]
         { info_tbl: [(c1wep,
                       label: block_c1wep_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wep: // global
           I64[Sp] = block_c1wev_info;
           _s1sGe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s1sGe::I64;
           if (R1 & 7 != 0) goto u1weE; else goto c1wez;
       u1weE: // global
           call _c1wev(R1) args: 0, res: 0, upd: 0;
       c1wez: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wev() //  [R1]
         { info_tbl: [(c1wev,
                       label: block_c1wev_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wev: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$cshowsPrec_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.69493936 UTC

[section ""data" . GHC.Real.$fShowRatio1_closure" {
     GHC.Real.$fShowRatio1_closure:
         const GHC.Real.$fShowRatio1_info;
         const 0;
 },
 GHC.Real.$fShowRatio1_entry() //  [R2, R3]
         { info_tbl: [(c1wf2,
                       label: GHC.Real.$fShowRatio1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wf2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wf8; else goto c1wf9;
       c1wf8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wf9: // global
           I64[Sp - 16] = block_c1weZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1wfe; else goto c1wf0;
       u1wfe: // global
           call _c1weZ(R1) args: 0, res: 0, upd: 0;
       c1wf0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1weZ() //  [R1]
         { info_tbl: [(c1weZ,
                       label: block_c1weZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1weZ: // global
           _s1sGj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1wf5_info;
           R5 = _s1sGj::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cshowsPrec_entry(R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wf5() //  [R1, R2]
         { info_tbl: [(c1wf5,
                       label: block_c1wf5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wf5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wfd; else goto c1wfc;
       c1wfd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1wfc: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.70341937 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$cshowList_closure" {
     GHC.Real.$fShowRatio_$s$cshowList_closure:
         const GHC.Real.$fShowRatio_$s$cshowList_info;
         const 0;
 },
 GHC.Real.$fShowRatio_$s$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c1wfz,
                       label: GHC.Real.$fShowRatio_$s$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wfz: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Real.$fShowRatio1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.707308517 UTC

[section ""data" . GHC.Real.$fShowRatio_$cshowList_closure" {
     GHC.Real.$fShowRatio_$cshowList_closure:
         const GHC.Real.$fShowRatio_$cshowList_info;
 },
 sat_s1sGz_entry() //  [R1, R2]
         { info_tbl: [(c1wfS,
                       label: sat_s1sGz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wfS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wfT; else goto c1wfU;
       c1wfT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1wfU: // global
           I64[Sp - 16] = block_c1wfP_info;
           _s1sGs::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s1sGs::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1wfY; else goto c1wfQ;
       u1wfY: // global
           call _c1wfP(R1) args: 0, res: 0, upd: 0;
       c1wfQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wfP() //  [R1]
         { info_tbl: [(c1wfP,
                       label: block_c1wfP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wfP: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = 0;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cshowsPrec_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fShowRatio_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c1wfZ,
                       label: GHC.Real.$fShowRatio_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wfZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1wg3; else goto c1wg2;
       c1wg3: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wg2: // global
           I64[Hp - 8] = sat_s1sGz_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.715671517 UTC

[section ""data" . GHC.Real.$w$s$cshow_closure" {
     GHC.Real.$w$s$cshow_closure:
         const GHC.Real.$w$s$cshow_info;
         const 0;
 },
 sat_s1sGF_entry() //  [R1]
         { info_tbl: [(c1wgx,
                       label: sat_s1sGF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wgx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1wgy; else goto c1wgz;
       c1wgy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wgz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1wgu_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[R1 + 16];
           R2 = 8;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1wgu() //  [R1, R2]
         { info_tbl: [(c1wgu,
                       label: block_c1wgu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wgu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wgC; else goto c1wgB;
       c1wgC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c1wgB: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sGG_entry() //  [R1]
         { info_tbl: [(c1wgD,
                       label: sat_s1sGG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wgD: // global
           _s1sGG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1wgE; else goto c1wgF;
       c1wgF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wgH; else goto c1wgG;
       c1wgH: // global
           HpAlloc = 24;
           goto c1wgE;
       c1wgE: // global
           R1 = _s1sGG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wgG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sGG::P64;
           _s1sGB::P64 = P64[_s1sGG::P64 + 16];
           I64[Hp - 16] = sat_s1sGF_info;
           P64[Hp] = _s1sGB::P64;
           R3 = Hp - 16;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$s$cshow_entry() //  [R2, R3]
         { info_tbl: [(c1wgI,
                       label: GHC.Real.$w$s$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wgI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wgM; else goto c1wgL;
       c1wgM: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$s$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wgL: // global
           I64[Hp - 16] = sat_s1sGG_info;
           P64[Hp] = R3;
           R4 = Hp - 16;
           R3 = R2;
           R2 = 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.72649105 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$cshow_closure" {
     GHC.Real.$fShowRatio_$s$cshow_closure:
         const GHC.Real.$fShowRatio_$s$cshow_info;
         const 0;
 },
 GHC.Real.$fShowRatio_$s$cshow_entry() //  [R2]
         { info_tbl: [(c1whh,
                       label: GHC.Real.$fShowRatio_$s$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1whh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1whn; else goto c1who;
       c1whn: // global
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$s$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1who: // global
           I64[Sp - 8] = block_c1whe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1wht; else goto c1whf;
       u1wht: // global
           call _c1whe(R1) args: 0, res: 0, upd: 0;
       c1whf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1whe() //  [R1]
         { info_tbl: [(c1whe,
                       label: block_c1whe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1whe: // global
           I64[Sp] = block_c1whk_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Real.$w$s$cshow_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1whk() //  [R1, R2]
         { info_tbl: [(c1whk,
                       label: block_c1whk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1whk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1whs; else goto c1whr;
       c1whs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1whr: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.735387139 UTC

[section ""data" . GHC.Real.$w$cshow_closure" {
     GHC.Real.$w$cshow_closure:
         const GHC.Real.$w$cshow_info;
 },
 sat_s1sGR_entry() //  [R1]
         { info_tbl: [(c1whW,
                       label: sat_s1sGR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1whW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1whX; else goto c1whY;
       c1whX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1whY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s1sGS_entry() //  [R1]
         { info_tbl: [(c1whZ,
                       label: sat_s1sGS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1whZ: // global
           _s1sGS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1wi0; else goto c1wi1;
       c1wi1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1wi3; else goto c1wi2;
       c1wi3: // global
           HpAlloc = 32;
           goto c1wi0;
       c1wi0: // global
           R1 = _s1sGS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wi2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sGS::P64;
           _s1sGO::P64 = P64[_s1sGS::P64 + 16];
           _s1sGQ::P64 = P64[_s1sGS::P64 + 24];
           I64[Hp - 24] = sat_s1sGR_info;
           P64[Hp - 8] = _s1sGO::P64;
           P64[Hp] = _s1sGQ::P64;
           R3 = Hp - 24;
           R2 = GHC.Real.$fShowRatio2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$cshow_entry() //  [R2, R3, R4]
         { info_tbl: [(c1wi4,
                       label: GHC.Real.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wi4: // global
           _s1sGQ::P64 = R4;
           _s1sGP::P64 = R3;
           _s1sGO::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto c1wi5; else goto c1wi6;
       c1wi6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1wi8; else goto c1wi7;
       c1wi8: // global
           HpAlloc = 32;
           goto c1wi5;
       c1wi5: // global
           R4 = _s1sGQ::P64;
           R3 = _s1sGP::P64;
           R2 = _s1sGO::P64;
           R1 = GHC.Real.$w$cshow_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wi7: // global
           I64[Hp - 24] = sat_s1sGS_info;
           P64[Hp - 8] = _s1sGO::P64;
           P64[Hp] = _s1sGQ::P64;
           R2 = _s1sGO::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Real.ratioPrec1_closure+1;
           P64[Sp - 16] = _s1sGP::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.744440329 UTC

[section ""data" . GHC.Real.$fShowRatio_$cshow_closure" {
     GHC.Real.$fShowRatio_$cshow_closure:
         const GHC.Real.$fShowRatio_$cshow_info;
 },
 GHC.Real.$fShowRatio_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c1wiF,
                       label: GHC.Real.$fShowRatio_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wiF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wiG; else goto c1wiH;
       c1wiG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wiH: // global
           I64[Sp - 16] = block_c1wiC_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1wiL; else goto c1wiD;
       u1wiL: // global
           call _c1wiC(R1) args: 0, res: 0, upd: 0;
       c1wiD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wiC() //  [R1]
         { info_tbl: [(c1wiC,
                       label: block_c1wiC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wiC: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w$cshow_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.749624642 UTC

[section ""data" . GHC.Real.$fShowRatio_$s$fShowRatio_closure" {
     GHC.Real.$fShowRatio_$s$fShowRatio_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Real.$fShowRatio_$s$cshowsPrec_closure+3;
         const GHC.Real.$fShowRatio_$s$cshow_closure+1;
         const GHC.Real.$fShowRatio_$s$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.751923466 UTC

[section ""data" . GHC.Real.$fShowRatio_closure" {
     GHC.Real.$fShowRatio_closure:
         const GHC.Real.$fShowRatio_info;
 },
 sat_s1sH1_entry() //  [R1, R2, R3]
         { info_tbl: [(c1wj6,
                       label: sat_s1sH1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wj6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fShowRatio_$cshowList_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sH0_entry() //  [R1, R2]
         { info_tbl: [(c1wje,
                       label: sat_s1sH0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wje: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fShowRatio_$cshow_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sGZ_entry() //  [R1, R2, R3]
         { info_tbl: [(c1wjm,
                       label: sat_s1sGZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wjm: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Real.$fShowRatio_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fShowRatio_entry() //  [R2]
         { info_tbl: [(c1wjq,
                       label: GHC.Real.$fShowRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wjq: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1wju; else goto c1wjt;
       c1wju: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Real.$fShowRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1wjt: // global
           I64[Hp - 72] = sat_s1sH1_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1sH0_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s1sGZ_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.761535785 UTC

[section ""data" . GHC.Real.$w$slcm_closure" {
     GHC.Real.$w$slcm_closure:
         const GHC.Real.$w$slcm_info;
         const 0;
 },
 section ""relreadonly" . u1wkv_srtd" {
     u1wkv_srtd:
         const S1sVz_srt+856;
         const 64;
         const 13835093239654252545;
 },
 GHC.Real.$w$slcm_entry() //  [R2, R3]
         { info_tbl: [(c1wjY,
                       label: GHC.Real.$w$slcm_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wjY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1wjZ; else goto c1wk0;
       c1wjZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$slcm_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wk0: // global
           if (R3 == 0) goto c1wjX; else goto c1wjW;
       c1wjX: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1wjW: // global
           I64[Sp - 16] = block_c1wk2_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1wku; else goto c1wk3;
       u1wku: // global
           call _c1wk2(R1) args: 0, res: 0, upd: 0;
       c1wk3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1wkw_srtd" {
     u1wkw_srtd:
         const S1sVz_srt+856;
         const 63;
         const 4611721202799476737;
 },
 _c1wk2() //  [R1]
         { info_tbl: [(c1wk2,
                       label: block_c1wk2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wk2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1wk9; else goto c1wk8;
       c1wk9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wk8: // global
           _s1sH7::I64 = I64[R1 + 7];
           if (_s1sH7::I64 == 0) goto c1wkt; else goto c1wkf;
       c1wkt: // global
           Hp = Hp - 16;
           R1 = 0;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1wkf: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp - 8] = block_c1wkd_info;
           R4 = Hp - 7;
           R3 = R1;
           R2 = GHC.Real.$fIntegralWord_closure+1;
           I64[Sp] = _s1sH7::I64;
           Sp = Sp - 8;
           call GHC.Real.gcd_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wkd() //  [R1]
         { info_tbl: [(c1wkd,
                       label: block_c1wkd_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wkd: // global
           _s1sHb::I64 = I64[R1 + 7];
           if (_s1sHb::I64 != 0) goto c1wkr; else goto c1wks;
       c1wkr: // global
           R1 = I64[Sp + 8] / _s1sHb::I64 * I64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1wks: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.772125206 UTC

[section ""data" . GHC.Real.lcm_$slcm_closure" {
     GHC.Real.lcm_$slcm_closure:
         const GHC.Real.lcm_$slcm_info;
         const 0;
 },
 GHC.Real.lcm_$slcm_entry() //  [R2, R3]
         { info_tbl: [(c1wl0,
                       label: GHC.Real.lcm_$slcm_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wl0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wl8; else goto c1wl9;
       c1wl8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.lcm_$slcm_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wl9: // global
           I64[Sp - 16] = block_c1wkX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1wle; else goto c1wkY;
       u1wle: // global
           call _c1wkX(R1) args: 0, res: 0, upd: 0;
       c1wkY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wkX() //  [R1]
         { info_tbl: [(c1wkX,
                       label: block_c1wkX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wkX: // global
           _s1sHe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1wl3_info;
           R3 = I64[R1 + 7];
           R2 = _s1sHe::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$slcm_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wl3() //  [R1]
         { info_tbl: [(c1wl3,
                       label: block_c1wl3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wl3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1wld; else goto c1wlc;
       c1wld: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1wlc: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.780928695 UTC

[section ""data" . GHC.Real.$w$slcm1_closure" {
     GHC.Real.$w$slcm1_closure:
         const GHC.Real.$w$slcm1_info;
         const 0;
 },
 sat_s1sHt_entry() //  [R1]
         { info_tbl: [(c1wlW,
                       label: sat_s1sHt_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wlW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1wm0; else goto c1wlZ;
       c1wm0: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wlZ: // global
           _s1sHo::I64 = I64[R1 + 24];
           if (%MO_S_Lt_W64(_s1sHo::I64, 0)) goto c1wlU; else goto c1wlV;
       c1wlU: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_s1sHo::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1wlV: // global
           _s1sHm::P64 = P64[R1 + 16];
           Hp = Hp - 16;
           R1 = _s1sHm::P64 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1wni_srtd" {
     u1wni_srtd:
         const S1sVz_srt+344;
         const 130;
         const 17;
         const 35184372088832;
         const 2;
 },
 GHC.Real.$w$slcm1_entry() //  [R2, R3]
         { info_tbl: [(c1wm9,
                       label: GHC.Real.$w$slcm1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wm9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1wma; else goto c1wmb;
       c1wma: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$slcm1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wmb: // global
           if (R3 == 0) goto u1wnh; else goto c1wm7;
       u1wnh: // global
           call _c1wm8() args: 0, res: 0, upd: 0;
       c1wm7: // global
           I64[Sp - 16] = block_c1wlB_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1wng; else goto c1wlC;
       u1wng: // global
           call _c1wlB(R1) args: 0, res: 0, upd: 0;
       c1wlC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1wnj_srtd" {
     u1wnj_srtd:
         const S1sVz_srt+344;
         const 110;
         const 17;
         const 35184372088832;
 },
 _c1wlB() //  [R1]
         { info_tbl: [(c1wlB,
                       label: block_c1wlB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wlB: // global
           _s1sHo::I64 = I64[R1 + 7];
           if (_s1sHo::I64 == 0) goto u1wn8; else goto c1wn3;
       u1wn8: // global
           Sp = Sp + 16;
           call _c1wm8() args: 0, res: 0, upd: 0;
       c1wn3: // global
           _s1sHl::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s1sHl::I64, 0)) goto c1wn0; else goto c1wn1;
       c1wn0: // global
           I64[Sp - 16] = _s1sHo::I64;
           I64[Sp - 8] = -_s1sHl::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           goto u1wne;
       c1wn1: // global
           P64[Sp] = R1;
           I64[Sp - 16] = _s1sHo::I64;
           I64[Sp - 8] = _s1sHl::I64;
           Sp = Sp - 16;
           goto u1wne;
       u1wne: // global
           call _c1wlL() args: 0, res: 0, upd: 0;
     }
 },
 _c1wm8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wm8: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1wlL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wlL: // global
           Hp = Hp + 32;
           _s1sHq::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c1wmg; else goto c1wmf;
       c1wmg: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_c1wlK_info;
           R1 = _s1sHq::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1wmf: // global
           I64[Hp - 24] = sat_s1sHt_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp];
           I64[Sp - 8] = block_c1wmd_info;
           R3 = _s1sHq::I64;
           R2 = Hp - 24;
           Sp = Sp - 8;
           call GHC.Real.$wgcd'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1wnk_srtd" {
     u1wnk_srtd:
         const S1sVz_srt+344;
         const 110;
         const 17;
         const 35184372088832;
 },
 _c1wlK() //  [R1]
         { info_tbl: [(c1wlK,
                       label: block_c1wlK_info
                       rep:StackRep [True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wlK: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c1wlL() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1wnl_srtd" {
     u1wnl_srtd:
         const S1sVz_srt+344;
         const 110;
         const 1;
         const 35184372088832;
 },
 _c1wmd() //  [R1]
         { info_tbl: [(c1wmd,
                       label: block_c1wmd_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wmd: // global
           _s1sHl::I64 = I64[Sp + 32];
           _s1sHo::I64 = I64[Sp + 8];
           _s1sHw::I64 = I64[R1 + 7];
           if (_s1sHw::I64 != (-1)) goto u1wn7; else goto c1wmV;
       u1wn7: // global
           if (_s1sHw::I64 != 0) goto c1wmB; else goto c1wmW;
       c1wmB: // global
           _s1sHy::I64 = %MO_S_Quot_W64(_s1sHo::I64,
                                        _s1sHw::I64) * _s1sHl::I64;
           if (%MO_S_Lt_W64(_s1sHy::I64, 0)) goto c1wmy; else goto c1wmz;
       c1wmy: // global
           R1 = -_s1sHy::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1wmz: // global
           R1 = _s1sHy::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1wmW: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1wmV: // global
           if (_s1sHo::I64 == (-9223372036854775808)) goto c1wmU; else goto c1wmT;
       c1wmU: // global
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1wmT: // global
           _s1sHB::I64 = %MO_S_Quot_W64(_s1sHo::I64, (-1)) * _s1sHl::I64;
           if (%MO_S_Lt_W64(_s1sHB::I64, 0)) goto c1wmQ; else goto c1wmR;
       c1wmQ: // global
           R1 = -_s1sHB::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1wmR: // global
           R1 = _s1sHB::I64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.800162992 UTC

[section ""data" . GHC.Real.lcm_$slcm1_closure" {
     GHC.Real.lcm_$slcm1_closure:
         const GHC.Real.lcm_$slcm1_info;
         const 0;
 },
 GHC.Real.lcm_$slcm1_entry() //  [R2, R3]
         { info_tbl: [(c1woe,
                       label: GHC.Real.lcm_$slcm1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1woe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wom; else goto c1won;
       c1wom: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.lcm_$slcm1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1won: // global
           I64[Sp - 16] = block_c1wob_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1wos; else goto c1woc;
       u1wos: // global
           call _c1wob(R1) args: 0, res: 0, upd: 0;
       c1woc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wob() //  [R1]
         { info_tbl: [(c1wob,
                       label: block_c1wob_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wob: // global
           _s1sHI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1woh_info;
           R3 = I64[R1 + 7];
           R2 = _s1sHI::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$slcm1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1woh() //  [R1]
         { info_tbl: [(c1woh,
                       label: block_c1woh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1woh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1wor; else goto c1woq;
       c1wor: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1woq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.809564298 UTC

[section ""data" . GHC.Real.lcm_closure" {
     GHC.Real.lcm_closure:
         const GHC.Real.lcm_info;
         const 0;
 },
 sat_s1sHU_entry() //  [R1]
         { info_tbl: [(c1wp7,
                       label: sat_s1sHU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wp7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wp8; else goto c1wp9;
       c1wp8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wp9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sHW_entry() //  [R1]
         { info_tbl: [(c1wpi,
                       label: sat_s1sHW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wpi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wpj; else goto c1wpk;
       c1wpj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wpk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sHY_entry() //  [R1]
         { info_tbl: [(c1wpB,
                       label: sat_s1sHY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wpB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wpC; else goto c1wpD;
       c1wpC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wpD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.gcd_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sHZ_entry() //  [R1]
         { info_tbl: [(c1wpE,
                       label: sat_s1sHZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wpE: // global
           _s1sHZ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1wpF; else goto c1wpG;
       c1wpG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1wpI; else goto c1wpH;
       c1wpI: // global
           HpAlloc = 40;
           goto c1wpF;
       c1wpF: // global
           R1 = _s1sHZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wpH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sHZ::P64;
           _s1sHN::P64 = P64[_s1sHZ::P64 + 16];
           _s1sHO::P64 = P64[_s1sHZ::P64 + 24];
           _s1sHP::P64 = P64[_s1sHZ::P64 + 32];
           I64[Hp - 32] = sat_s1sHY_info;
           P64[Hp - 16] = _s1sHN::P64;
           P64[Hp - 8] = _s1sHO::P64;
           P64[Hp] = _s1sHP::P64;
           R2 = _s1sHN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1sHO::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sI0_entry() //  [R1]
         { info_tbl: [(c1wpJ,
                       label: sat_s1sI0_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wpJ: // global
           _s1sI0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1wpK; else goto c1wpL;
       c1wpL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1wpN; else goto c1wpM;
       c1wpN: // global
           HpAlloc = 40;
           goto c1wpK;
       c1wpK: // global
           R1 = _s1sI0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wpM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sI0::P64;
           _s1sHN::P64 = P64[_s1sI0::P64 + 16];
           _s1sHO::P64 = P64[_s1sI0::P64 + 24];
           _s1sHP::P64 = P64[_s1sI0::P64 + 32];
           _s1sHR::P64 = P64[_s1sI0::P64 + 40];
           I64[Hp - 32] = sat_s1sHZ_info;
           P64[Hp - 16] = _s1sHN::P64;
           P64[Hp - 8] = _s1sHO::P64;
           P64[Hp] = _s1sHP::P64;
           R2 = _s1sHR::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _s1sHP::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Real.lcm_entry() //  [R2, R3, R4]
         { info_tbl: [(c1wpO,
                       label: GHC.Real.lcm_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wpO: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1wpP; else goto c1wpQ;
       c1wpP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.lcm_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wpQ: // global
           I64[Sp - 32] = block_c1woN_info;
           _s1sHN::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s1sHN::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1woN() //  [R1]
         { info_tbl: [(c1woN,
                       label: block_c1woN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1woN: // global
           I64[Sp - 8] = block_c1woR_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1woR() //  [R1]
         { info_tbl: [(c1woR,
                       label: block_c1woR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1woR: // global
           I64[Sp] = block_c1woV_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1woV() //  [R1]
         { info_tbl: [(c1woV,
                       label: block_c1woV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1woV: // global
           I64[Sp] = block_c1woZ_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1woZ() //  [R1]
         { info_tbl: [(c1woZ,
                       label: block_c1woZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1woZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wpW; else goto c1wpV;
       c1wpW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wpV: // global
           I64[Hp - 16] = sat_s1sHU_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1wpa_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1wpa() //  [R1]
         { info_tbl: [(c1wpa,
                       label: block_c1wpa_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wpa: // global
           if (R1 & 7 == 1) goto c1wpY; else goto u1wqh;
       c1wpY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wq1; else goto c1wq0;
       c1wq1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wq0: // global
           I64[Hp - 16] = sat_s1sHW_info;
           P64[Hp] = P64[Sp + 16];
           _s1sHT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1wpl_info;
           R2 = _s1sHT::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       u1wqh: // global
           Sp = Sp + 16;
           call _c1wqe() args: 0, res: 0, upd: 0;
     }
 },
 _c1wpl() //  [R1]
         { info_tbl: [(c1wpl,
                       label: block_c1wpl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wpl: // global
           if (R1 & 7 == 1) goto c1wq3; else goto u1wqi;
       c1wq3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1wq6; else goto c1wq5;
       c1wq6: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wq5: // global
           I64[Hp - 40] = sat_s1sI0_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           _s1sHR::P64 = P64[Sp + 8];
           P64[Hp] = _s1sHR::P64;
           R2 = _s1sHR::P64;
           I64[Sp + 24] = stg_ap_p_info;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 8;
       u1wqi: // global
           Sp = Sp + 8;
           call _c1wqe() args: 0, res: 0, upd: 0;
     }
 },
 _c1wqe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wqe: // global
           R2 = P64[Sp];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = GHC.Real.even1_closure;
           Sp = Sp + 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.837431621 UTC

[section ""data" . GHC.Real.$w$ctoEnum_closure" {
     GHC.Real.$w$ctoEnum_closure:
         const GHC.Real.$w$ctoEnum_info;
         const 0;
 },
 sat_s1sI7_entry() //  [R1]
         { info_tbl: [(c1ws4,
                       label: sat_s1sI7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ws4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1ws5; else goto c1ws6;
       c1ws5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ws6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1ws1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1wsa; else goto c1ws2;
       u1wsa: // global
           call _c1ws1(R1) args: 0, res: 0, upd: 0;
       c1ws2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1ws1() //  [R1]
         { info_tbl: [(c1ws1,
                       label: block_c1ws1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ws1: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.$w$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c1wsb,
                       label: GHC.Real.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wsb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wsf; else goto c1wsg;
       c1wsf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wsg: // global
           I64[Sp - 16] = block_c1wrP_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wrP() //  [R1]
         { info_tbl: [(c1wrP,
                       label: block_c1wrP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wrP: // global
           I64[Sp] = block_c1wrT_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wrT() //  [R1]
         { info_tbl: [(c1wrT,
                       label: block_c1wrT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wrT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wsk; else goto c1wsj;
       c1wsk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wsj: // global
           I64[Hp - 16] = sat_s1sI7_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c1wsc_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1wsc() //  [R1]
         { info_tbl: [(c1wsc,
                       label: block_c1wsc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wsc: // global
           I64[Sp] = block_c1wse_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Real.$fEnumRatio1_closure;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1wse() //  [R1]
         { info_tbl: [(c1wse,
                       label: block_c1wse_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wse: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.851555505 UTC

[section ""data" . GHC.Real.$fEnumRatio_$ctoEnum_closure" {
     GHC.Real.$fEnumRatio_$ctoEnum_closure:
         const GHC.Real.$fEnumRatio_$ctoEnum_info;
         const 0;
 },
 GHC.Real.$fEnumRatio_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c1wt7,
                       label: GHC.Real.$fEnumRatio_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wt7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1wt8; else goto c1wt9;
       c1wt8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wt9: // global
           I64[Sp - 8] = block_c1wt4_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Real.$w$ctoEnum_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wt4() //  [R1, R2]
         { info_tbl: [(c1wt4,
                       label: block_c1wt4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wt4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wtc; else goto c1wtb;
       c1wtc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1wtb: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.857486968 UTC

[section ""data" . GHC.Real.$fEnumRatio_$s$fEnumRatio_closure" {
     GHC.Real.$fEnumRatio_$s$fEnumRatio_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Real.$fEnumRatio_$s$csucc_closure+1;
         const GHC.Real.$fEnumRatio_$s$cpred_closure+1;
         const GHC.Real.$fEnumRatio_$ctoRational_closure+1;
         const GHC.Real.$fEnumRatio_$s$cfromEnum_closure+1;
         const GHC.Real.$fEnumRatio_$snumericEnumFrom_closure+1;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure+2;
         const GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure+2;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.860460538 UTC

[section ""data" . GHC.Real.$fEnumRatio_closure" {
     GHC.Real.$fEnumRatio_closure:
         const GHC.Real.$fEnumRatio_info;
         const 0;
 },
 sat_s1sIn_entry() //  [R1]
         { info_tbl: [(c1wtx,
                       label: sat_s1sIn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wtx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wty; else goto c1wtz;
       c1wty: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wtz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sIm_entry() //  [R1]
         { info_tbl: [(c1wtE,
                       label: sat_s1sIm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wtE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wtF; else goto c1wtG;
       c1wtF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wtG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sIl_entry() //  [R1]
         { info_tbl: [(c1wtL,
                       label: sat_s1sIl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wtL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wtM; else goto c1wtN;
       c1wtM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wtN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sIk_entry() //  [R1]
         { info_tbl: [(c1wtS,
                       label: sat_s1sIk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wtS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wtT; else goto c1wtU;
       c1wtT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wtU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fEnumRatio_$cenumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sIj_entry() //  [R1, R2]
         { info_tbl: [(c1wu0,
                       label: sat_s1sIj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wu0: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$cfromEnum_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sIi_entry() //  [R1, R2]
         { info_tbl: [(c1wu8,
                       label: sat_s1sIi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wu8: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$ctoEnum_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sIh_entry() //  [R1, R2]
         { info_tbl: [(c1wug,
                       label: sat_s1sIh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wug: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$cpred_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1sIg_entry() //  [R1, R2]
         { info_tbl: [(c1wuo,
                       label: sat_s1sIg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wuo: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Real.$fEnumRatio_$csucc_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Real.$fEnumRatio_entry() //  [R2]
         { info_tbl: [(c1wus,
                       label: GHC.Real.$fEnumRatio_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wus: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c1wuw; else goto c1wuv;
       c1wuw: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = GHC.Real.$fEnumRatio_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1wuv: // global
           I64[Hp - 224] = sat_s1sIn_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s1sIm_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s1sIl_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s1sIk_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s1sIj_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s1sIi_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s1sIh_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s1sIg_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = Hp - 95;
           P64[Hp - 40] = Hp - 111;
           P64[Hp - 32] = Hp - 127;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.879903213 UTC

[section ""data" . $wg_r1j3P_closure" {
     $wg_r1j3P_closure:
         const $wg_r1j3P_info;
 },
 $wg_r1j3P_entry() //  [R2, R3, R4]
         { info_tbl: [(c1wvy,
                       label: $wg_r1j3P_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wvy: // global
           _s1sIq::I64 = R4;
           _s1sIp::I64 = R3;
           _s1sIo::I64 = R2;
           goto c1wvq;
       c1wvq: // global
           if (_s1sIp::I64 - (_s1sIp::I64 + (_s1sIp::I64 >> 63)) & (-2) == 0) goto c1wvx; else goto c1wvw;
       c1wvx: // global
           _s1sIp::I64 = %MO_S_Shr_W64(_s1sIp::I64 + (_s1sIp::I64 >> 63), 1);
           _s1sIo::I64 = _s1sIo::I64 * _s1sIo::I64;
           goto c1wvq;
       c1wvw: // global
           if (_s1sIp::I64 == 1) goto c1wvM; else goto c1wvI;
       c1wvM: // global
           R1 = _s1sIo::I64 * _s1sIq::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1wvI: // global
           _s1sIq::I64 = _s1sIo::I64 * _s1sIq::I64;
           _s1sIp::I64 = %MO_S_Shr_W64(_s1sIp::I64 + (_s1sIp::I64 >> 63), 1);
           _s1sIo::I64 = _s1sIo::I64 * _s1sIo::I64;
           goto c1wvq;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.884593065 UTC

[section ""data" . GHC.Real.$wf1_closure" {
     GHC.Real.$wf1_closure:
         const GHC.Real.$wf1_info;
 },
 GHC.Real.$wf1_entry() //  [R2, R3]
         { info_tbl: [(c1www,
                       label: GHC.Real.$wf1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1www: // global
           _s1sIz::I64 = R3;
           _s1sIy::I64 = R2;
           goto c1wwo;
       c1wwo: // global
           if (_s1sIz::I64 - (_s1sIz::I64 + (_s1sIz::I64 >> 63)) & (-2) == 0) goto c1wwv; else goto c1wwu;
       c1wwv: // global
           _s1sIz::I64 = %MO_S_Shr_W64(_s1sIz::I64 + (_s1sIz::I64 >> 63), 1);
           _s1sIy::I64 = _s1sIy::I64 * _s1sIy::I64;
           goto c1wwo;
       c1wwu: // global
           if (_s1sIz::I64 == 1) goto c1wwH; else goto c1wwG;
       c1wwH: // global
           R1 = _s1sIy::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1wwG: // global
           R4 = _s1sIy::I64;
           R3 = %MO_S_Shr_W64(_s1sIz::I64 + (_s1sIz::I64 >> 63), 1);
           R2 = _s1sIy::I64 * _s1sIy::I64;
           call $wg_r1j3P_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.889216966 UTC

[section ""data" . GHC.Real.^_f2_closure" {
     GHC.Real.^_f2_closure:
         const GHC.Real.^_f2_info;
 },
 GHC.Real.^_f2_entry() //  [R2, R3]
         { info_tbl: [(c1wxk,
                       label: GHC.Real.^_f2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wxk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wxx; else goto c1wxy;
       c1wxx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_f2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wxy: // global
           I64[Sp - 16] = block_c1wxh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1wxF; else goto c1wxi;
       u1wxF: // global
           call _c1wxh(R1) args: 0, res: 0, upd: 0;
       c1wxi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wxh() //  [R1]
         { info_tbl: [(c1wxh,
                       label: block_c1wxh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wxh: // global
           I64[Sp] = block_c1wxn_info;
           _s1sIJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1sIJ::I64;
           if (R1 & 7 != 0) goto u1wxE; else goto c1wxo;
       u1wxE: // global
           call _c1wxn(R1) args: 0, res: 0, upd: 0;
       c1wxo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wxn() //  [R1]
         { info_tbl: [(c1wxn,
                       label: block_c1wxn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wxn: // global
           _s1sIJ::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1wxs_info;
           R3 = I64[R1 + 7];
           R2 = _s1sIJ::I64;
           Sp = Sp + 8;
           call GHC.Real.$wf1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wxs() //  [R1]
         { info_tbl: [(c1wxs,
                       label: block_c1wxs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wxs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1wxD; else goto c1wxC;
       c1wxD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1wxC: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.899074738 UTC

[section ""data" . GHC.Real.^3_closure" {
     GHC.Real.^3_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.901119098 UTC

[section ""data" . GHC.Real.^2_closure" {
     GHC.Real.^2_closure:
         const GHC.Real.^2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Real.^2_entry() //  [R1]
         { info_tbl: [(c1wya,
                       label: GHC.Real.^2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wya: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1wyb; else goto c1wyc;
       c1wyb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wyc: // global
           (_c1wy5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1wy5::I64 == 0) goto c1wy7; else goto c1wy6;
       c1wy7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1wy6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1wy5::I64;
           I64[Sp - 24] = block_c1wy8_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1wy8() //  [R1]
         { info_tbl: [(c1wy8,
                       label: block_c1wy8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wy8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.907399085 UTC

[section ""data" . GHC.Real.^_$s^2_closure" {
     GHC.Real.^_$s^2_closure:
         const GHC.Real.^_$s^2_info;
         const 0;
 },
 GHC.Real.^_$s^2_entry() //  [R2, R3]
         { info_tbl: [(c1wyz,
                       label: GHC.Real.^_$s^2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wyz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wyA; else goto c1wyB;
       c1wyA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_$s^2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wyB: // global
           I64[Sp - 16] = block_c1wyw_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1wz5; else goto c1wyx;
       u1wz5: // global
           call _c1wyw(R1) args: 0, res: 0, upd: 0;
       c1wyx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wyw() //  [R1]
         { info_tbl: [(c1wyw,
                       label: block_c1wyw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wyw: // global
           _s1sIR::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1sIR::I64, 0)) goto c1wz2; else goto c1wz3;
       c1wz2: // global
           if (_s1sIR::I64 == 0) goto c1wz0; else goto c1wyV;
       c1wz0: // global
           R1 = GHC.Real.^3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1wyV: // global
           I64[Sp] = block_c1wyK_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1sIR::I64;
           if (R1 & 7 != 0) goto u1wz4; else goto c1wyL;
       u1wz4: // global
           call _c1wyK(R1) args: 0, res: 0, upd: 0;
       c1wyL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1wz3: // global
           R1 = GHC.Real.^2_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1wyK() //  [R1]
         { info_tbl: [(c1wyK,
                       label: block_c1wyK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wyK: // global
           _s1sIT::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c1wyP_info;
           R3 = _s1sIT::I64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Real.$wf1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wyP() //  [R1]
         { info_tbl: [(c1wyP,
                       label: block_c1wyP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wyP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1wyZ; else goto c1wyY;
       c1wyZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1wyY: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.918147012 UTC

[section ""data" . $wg1_r1j3Q_closure" {
     $wg1_r1j3Q_closure:
         const $wg1_r1j3Q_info;
         const 0;
 },
 $wg1_r1j3Q_entry() //  [R2, R3, R4]
         { info_tbl: [(c1wzC,
                       label: $wg1_r1j3Q_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wzC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wzD; else goto u1wAf;
       c1wzD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wg1_r1j3Q_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u1wAf: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c1wzu() args: 0, res: 0, upd: 0;
     }
 },
 _c1wzu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wzu: // global
           _s1sIX::P64 = P64[Sp];
           _s1sIY::I64 = I64[Sp + 8];
           if (_s1sIY::I64 - (_s1sIY::I64 + (_s1sIY::I64 >> 63)) & (-2) == 0) goto c1wzB; else goto c1wzA;
       c1wzB: // global
           I64[Sp] = block_c1wA9_info;
           R3 = _s1sIX::P64;
           R2 = _s1sIX::P64;
           I64[Sp + 8] = %MO_S_Shr_W64(_s1sIY::I64 + (_s1sIY::I64 >> 63), 1);
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       c1wzA: // global
           _s1sIZ::P64 = P64[Sp + 16];
           if (_s1sIY::I64 == 1) goto c1wA1; else goto c1wzV;
       c1wA1: // global
           R3 = _s1sIZ::P64;
           R2 = _s1sIX::P64;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
       c1wzV: // global
           I64[Sp - 8] = block_c1wzM_info;
           R3 = _s1sIZ::P64;
           R2 = _s1sIX::P64;
           I64[Sp + 16] = _s1sIY::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wA9() //  [R1]
         { info_tbl: [(c1wA9,
                       label: block_c1wA9_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wA9: // global
           P64[Sp] = R1;
           I64[Sp + 8] = I64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           call _c1wzu() args: 0, res: 0, upd: 0;
     }
 },
 _c1wzM() //  [R1]
         { info_tbl: [(c1wzM,
                       label: block_c1wzM_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wzM: // global
           _s1sIX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1wzT_info;
           R3 = _s1sIX::P64;
           R2 = _s1sIX::P64;
           P64[Sp + 16] = R1;
           _s1sJ1::I64 = I64[Sp + 24];
           I64[Sp + 24] = %MO_S_Shr_W64(_s1sJ1::I64 + (_s1sJ1::I64 >> 63), 1);
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wzT() //  [R1]
         { info_tbl: [(c1wzT,
                       label: block_c1wzT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wzT: // global
           P64[Sp] = R1;
           _s1sIZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = I64[Sp + 16];
           P64[Sp + 16] = _s1sIZ::P64;
           call _c1wzu() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.930416349 UTC

[section ""data" . GHC.Real.$wf_closure" {
     GHC.Real.$wf_closure:
         const GHC.Real.$wf_info;
         const 0;
 },
 GHC.Real.$wf_entry() //  [R2, R3]
         { info_tbl: [(c1wB2,
                       label: GHC.Real.$wf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wB2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1wB3; else goto u1wBA;
       c1wB3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$wf_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u1wBA: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c1wAU() args: 0, res: 0, upd: 0;
     }
 },
 _c1wAU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wAU: // global
           _s1sJ7::P64 = P64[Sp];
           _s1sJ8::I64 = I64[Sp + 8];
           if (_s1sJ8::I64 - (_s1sJ8::I64 + (_s1sJ8::I64 >> 63)) & (-2) == 0) goto c1wB1; else goto c1wB0;
       c1wB1: // global
           I64[Sp] = block_c1wBu_info;
           R3 = _s1sJ7::P64;
           R2 = _s1sJ7::P64;
           I64[Sp + 8] = %MO_S_Shr_W64(_s1sJ8::I64 + (_s1sJ8::I64 >> 63), 1);
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       c1wB0: // global
           if (_s1sJ8::I64 == 1) goto c1wBm; else goto c1wBh;
       c1wBm: // global
           R1 = _s1sJ7::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1wBh: // global
           I64[Sp - 8] = block_c1wBf_info;
           R3 = _s1sJ7::P64;
           R2 = _s1sJ7::P64;
           I64[Sp + 8] = %MO_S_Shr_W64(_s1sJ8::I64 + (_s1sJ8::I64 >> 63), 1);
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wBu() //  [R1]
         { info_tbl: [(c1wBu,
                       label: block_c1wBu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wBu: // global
           P64[Sp] = R1;
           I64[Sp + 8] = I64[Sp + 8];
           call _c1wAU() args: 0, res: 0, upd: 0;
     }
 },
 _c1wBf() //  [R1]
         { info_tbl: [(c1wBf,
                       label: block_c1wBf_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wBf: // global
           R4 = P64[Sp + 8];
           R3 = I64[Sp + 16];
           R2 = R1;
           Sp = Sp + 24;
           call $wg1_r1j3Q_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.938988176 UTC

[section ""data" . GHC.Real.^_f1_closure" {
     GHC.Real.^_f1_closure:
         const GHC.Real.^_f1_info;
         const 0;
 },
 GHC.Real.^_f1_entry() //  [R2, R3]
         { info_tbl: [(c1wCf,
                       label: GHC.Real.^_f1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wCf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wCg; else goto c1wCh;
       c1wCg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_f1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wCh: // global
           I64[Sp - 16] = block_c1wCc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1wCl; else goto c1wCd;
       u1wCl: // global
           call _c1wCc(R1) args: 0, res: 0, upd: 0;
       c1wCd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wCc() //  [R1]
         { info_tbl: [(c1wCc,
                       label: block_c1wCc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wCc: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$wf_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.944613905 UTC

[section ""data" . GHC.Real.^_$s^1_closure" {
     GHC.Real.^_$s^1_closure:
         const GHC.Real.^_$s^1_info;
         const 0;
 },
 section ""relreadonly" . u1wCU_srtd" {
     u1wCU_srtd:
         const S1sVz_srt+1280;
         const 33;
         const 5368840193;
 },
 GHC.Real.^_$s^1_entry() //  [R2, R3]
         { info_tbl: [(c1wCD,
                       label: GHC.Real.^_$s^1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wCD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wCE; else goto c1wCF;
       c1wCE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_$s^1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wCF: // global
           I64[Sp - 16] = block_c1wCA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1wCT; else goto c1wCB;
       u1wCT: // global
           call _c1wCA(R1) args: 0, res: 0, upd: 0;
       c1wCB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wCA() //  [R1]
         { info_tbl: [(c1wCA,
                       label: block_c1wCA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wCA: // global
           _s1sJm::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1sJm::I64, 0)) goto c1wCR; else goto c1wCS;
       c1wCR: // global
           if (_s1sJm::I64 == 0) goto c1wCP; else goto c1wCO;
       c1wCP: // global
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1wCO: // global
           R3 = _s1sJm::I64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$wf_entry(R3, R2) args: 8, res: 0, upd: 8;
       c1wCS: // global
           R1 = GHC.Real.^1_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.951353846 UTC

[section ""data" . lvl6_r1j3R_closure" {
     lvl6_r1j3R_closure:
         const lvl6_r1j3R_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r1j3R_entry() //  [R1]
         { info_tbl: [(c1wDg,
                       label: lvl6_r1j3R_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wDg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1wDh; else goto c1wDi;
       c1wDh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wDi: // global
           (_c1wDb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1wDb::I64 == 0) goto c1wDd; else goto c1wDc;
       c1wDd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1wDc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1wDb::I64;
           I64[Sp - 24] = block_c1wDe_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1wDe() //  [R1]
         { info_tbl: [(c1wDe,
                       label: block_c1wDe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wDe: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.957013644 UTC

[section ""data" . lvl7_r1j3S_closure" {
     lvl7_r1j3S_closure:
         const lvl7_r1j3S_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r1j3S_entry() //  [R1]
         { info_tbl: [(c1wDG,
                       label: lvl7_r1j3S_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wDG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1wDH; else goto c1wDI;
       c1wDH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wDI: // global
           (_c1wDB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1wDB::I64 == 0) goto c1wDD; else goto c1wDC;
       c1wDD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1wDC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1wDB::I64;
           I64[Sp - 24] = block_c1wDE_info;
           R2 = lvl5_r1j3O_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1wDE() //  [R1]
         { info_tbl: [(c1wDE,
                       label: block_c1wDE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wDE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:18.968751012 UTC

[section ""data" . GHC.Real.^_closure" {
     GHC.Real.^_closure:
         const GHC.Real.^_info;
         const 0;
 },
 $dNum1_s1sJw_entry() //  [R1]
         { info_tbl: [(c1wFr,
                       label: $dNum1_s1sJw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wFr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wFs; else goto c1wFt;
       c1wFs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wFt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sJy_entry() //  [R1]
         { info_tbl: [(c1wFw,
                       label: sat_s1sJy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wFw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wFx; else goto c1wFy;
       c1wFx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wFy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sJB_entry() //  [R1]
         { info_tbl: [(c1wFB,
                       label: sat_s1sJB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wFB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wFC; else goto c1wFD;
       c1wFC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wFD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl8_s1sJD_entry() //  [R1]
         { info_tbl: [(c1wFG,
                       label: lvl8_s1sJD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wFG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wFH; else goto c1wFI;
       c1wFH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wFI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl9_s1sJI_entry() //  [R1]
         { info_tbl: [(c1wFL,
                       label: lvl9_s1sJI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wFL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wFM; else goto c1wFN;
       c1wFM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wFN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sJZ_entry() //  [R1]
         { info_tbl: [(c1wFQ,
                       label: sat_s1sJZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wFQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1wFR; else goto c1wFS;
       c1wFR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wFS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sJY_entry() //  [R1]
         { info_tbl: [(c1wFV,
                       label: sat_s1sJY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wFV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1wFW; else goto c1wFX;
       c1wFW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wFX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1sJF::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1sJF::P64;
           P64[Sp - 24] = _s1sJF::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sJV_entry() //  [R1]
         { info_tbl: [(c1wG0,
                       label: sat_s1sJV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wG0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1wG1; else goto c1wG2;
       c1wG1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wG2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sJU_entry() //  [R1]
         { info_tbl: [(c1wG5,
                       label: sat_s1sJU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wG5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1wG6; else goto c1wG7;
       c1wG6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wG7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sJT_entry() //  [R1]
         { info_tbl: [(c1wGb,
                       label: sat_s1sJT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wGb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1wGc; else goto c1wGd;
       c1wGc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wGd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1sJO::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1sJO::P64;
           P64[Sp - 24] = _s1sJO::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sJX_entry() //  [R1]
         { info_tbl: [(c1wGg,
                       label: sat_s1sJX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wGg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1wGh; else goto c1wGi;
       c1wGh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wGi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sJW_entry() //  [R1]
         { info_tbl: [(c1wGm,
                       label: sat_s1sJW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wGm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1wGn; else goto c1wGo;
       c1wGn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wGo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1sJO::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1sJO::P64;
           P64[Sp - 24] = _s1sJO::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sK5_entry() //  [R1]
         { info_tbl: [(c1wGr,
                       label: sat_s1sK5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wGr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1wGs; else goto c1wGt;
       c1wGs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wGt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1sK4_entry() //  [R1]
         { info_tbl: [(c1wGx,
                       label: sat_s1sK4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wGx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1wGy; else goto c1wGz;
       c1wGy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wGz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s1sK1::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s1sK1::P64;
           P64[Sp - 24] = _s1sK1::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1wJE_srtd" {
     u1wJE_srtd:
         const S1sVz_srt+696;
         const 111;
         const 1;
         const 131941462441984;
 },
 GHC.Real.^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1wGA,
                       label: GHC.Real.^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wGA: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c1wGB; else goto c1wGC;
       c1wGB: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wGC: // global
           I64[Sp - 40] = block_c1wE2_info;
           _s1sJr::P64 = R2;
           R2 = R3;
           P64[Sp - 32] = _s1sJr::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1wJF_srtd" {
     u1wJF_srtd:
         const S1sVz_srt+696;
         const 111;
         const 1;
         const 96757090353152;
 },
 _c1wE2() //  [R1]
         { info_tbl: [(c1wE2,
                       label: block_c1wE2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wE2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wGF; else goto c1wGE;
       c1wGF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wGE: // global
           I64[Hp - 16] = $dNum1_s1sJw_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1wE8_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1wJG_srtd" {
     u1wJG_srtd:
         const S1sVz_srt+696;
         const 111;
         const 1;
         const 96757090353152;
 },
 _c1wE8() //  [R1]
         { info_tbl: [(c1wE8,
                       label: block_c1wE8_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wE8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wGI; else goto c1wGH;
       c1wGI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wGH: // global
           I64[Hp - 16] = sat_s1sJy_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1wEe_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 40];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1wJH_srtd" {
     u1wJH_srtd:
         const S1sVz_srt+696;
         const 111;
         const 1;
         const 96757090353152;
 },
 _c1wEe() //  [R1]
         { info_tbl: [(c1wEe,
                       label: block_c1wEe_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wEe: // global
           if (R1 & 7 == 1) goto c1wGK; else goto c1wHI;
       c1wGK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wGN; else goto c1wGM;
       c1wGN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wGM: // global
           I64[Hp - 16] = sat_s1sJB_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 8] = block_c1wEk_info;
           R2 = P64[Sp + 8];
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1wHI: // global
           R1 = lvl7_r1j3S_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1wJI_srtd" {
     u1wJI_srtd:
         const S1sVz_srt+696;
         const 109;
         const 1;
         const 17592253153280;
 },
 _c1wEk() //  [R1]
         { info_tbl: [(c1wEk,
                       label: block_c1wEk_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wEk: // global
           _c1wEi::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1wEo_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 56];
           P64[Sp] = _c1wEi::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1wJJ_srtd" {
     u1wJJ_srtd:
         const S1sVz_srt+696;
         const 109;
         const 1;
         const 17592253153280;
 },
 _c1wEo() //  [R1]
         { info_tbl: [(c1wEo,
                       label: block_c1wEo_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wEo: // global
           if (R1 & 7 == 1) goto c1wGQ; else goto c1wHE;
       c1wGQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wGT; else goto c1wGS;
       c1wGT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wGS: // global
           I64[Hp - 16] = lvl8_s1sJD_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp] = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = Hp - 16;
           call _c1wFf() args: 0, res: 0, upd: 0;
       c1wHE: // global
           R2 = P64[Sp + 24];
           I64[Sp + 40] = stg_ap_p_info;
           P64[Sp + 48] = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 40;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 _c1wFf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wFf: // global
           I64[Sp - 8] = block_c1wFh_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1wJK_srtd" {
     u1wJK_srtd:
         const S1sVz_srt+696;
         const 91;
         const 1;
         const 67108864;
 },
 _c1wFh() //  [R1]
         { info_tbl: [(c1wFh,
                       label: block_c1wFh_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wFh: // global
           _s1sK1::P64 = P64[Sp + 48];
           _s1sK2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c1wHw; else goto c1wHx;
       c1wHw: // global
           I64[Sp + 8] = block_c1wEz_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = _s1sK2::P64;
           P64[Sp + 48] = _s1sK1::P64;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1wHx: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1wHA; else goto c1wHz;
       c1wHA: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wHz: // global
           I64[Hp - 64] = sat_s1sK5_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = _s1sK2::P64;
           I64[Hp - 24] = sat_s1sK4_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _s1sK1::P64;
           P64[Sp + 48] = Hp - 24;
           P64[Sp + 8] = Hp - 64;
           Sp = Sp + 8;
           call _c1wFf() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u1wJL_srtd" {
     u1wJL_srtd:
         const S1sVz_srt+696;
         const 91;
         const 1;
         const 67108864;
 },
 _c1wEz() //  [R1]
         { info_tbl: [(c1wEz,
                       label: block_c1wEz_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wEz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wGX; else goto c1wGW;
       c1wGX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wGW: // global
           I64[Hp - 16] = lvl9_s1sJI_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 8] = block_c1wEF_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 8];
           _c1wED::P64 = Hp - 16;
           P64[Sp - 16] = _c1wED::P64;
           P64[Sp] = R1;
           P64[Sp + 16] = _c1wED::P64;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1wEF() //  [R1]
         { info_tbl: [(c1wEF,
                       label: block_c1wEF_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wEF: // global
           _s1sJF::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto c1wGZ; else goto c1wHr;
       c1wGZ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1wH2; else goto c1wH1;
       c1wH2: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wH1: // global
           I64[Hp - 64] = sat_s1sJZ_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = sat_s1sJY_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _s1sJF::P64;
           P64[Sp] = _s1sJF::P64;
           P64[Sp + 16] = Hp - 64;
           P64[Sp + 48] = Hp - 24;
           call _c1wES() args: 0, res: 0, upd: 0;
       c1wHr: // global
           R1 = _s1sJF::P64;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1wES() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wES: // global
           I64[Sp - 8] = block_c1wEU_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 40];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wEU() //  [R1]
         { info_tbl: [(c1wEU,
                       label: block_c1wEU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wEU: // global
           _s1sJP::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c1wHa; else goto c1wHk;
       c1wHa: // global
           I64[Sp] = block_c1wEY_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1sJP::P64;
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c1wHk: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c1wHn; else goto c1wHm;
       c1wHn: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wHm: // global
           I64[Hp - 64] = sat_s1sJX_info;
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = _s1sJP::P64;
           I64[Hp - 24] = sat_s1sJW_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 56];
           P64[Sp + 56] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c1wES() args: 0, res: 0, upd: 0;
     }
 },
 _c1wEY() //  [R1]
         { info_tbl: [(c1wEY,
                       label: block_c1wEY_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wEY: // global
           _s1sJr::P64 = P64[Sp + 40];
           _s1sJO::P64 = P64[Sp + 56];
           _s1sJQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c1wHc; else goto c1wHj;
       c1wHc: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1wHf; else goto c1wHe;
       c1wHf: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wHe: // global
           I64[Hp - 104] = sat_s1sJV_info;
           P64[Hp - 88] = _s1sJr::P64;
           P64[Hp - 80] = _s1sJO::P64;
           P64[Hp - 72] = _s1sJQ::P64;
           I64[Hp - 64] = sat_s1sJU_info;
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_s1sJT_info;
           P64[Hp - 8] = _s1sJr::P64;
           P64[Hp] = _s1sJO::P64;
           P64[Sp + 56] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = Hp - 104;
           Sp = Sp + 8;
           call _c1wES() args: 0, res: 0, upd: 0;
       c1wHj: // global
           R2 = _s1sJr::P64;
           I64[Sp + 48] = stg_ap_pp_info;
           P64[Sp + 56] = _s1sJO::P64;
           P64[Sp + 64] = _s1sJQ::P64;
           Sp = Sp + 48;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Real.^%^_closure" {
     GHC.Real.^%^_closure:
         const GHC.Real.^%^_info;
         const 0;
 },
 GHC.Real.^%^_entry() //  [R2, R3, R4]
         { info_tbl: [(c1wI6,
                       label: GHC.Real.^%^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wI6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1wIc; else goto c1wId;
       c1wIc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^%^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wId: // global
           I64[Sp - 24] = block_c1wI3_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1wIi; else goto c1wI4;
       u1wIi: // global
           call _c1wI3(R1) args: 0, res: 0, upd: 0;
       c1wI4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wI3() //  [R1]
         { info_tbl: [(c1wI3,
                       label: block_c1wI3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wI3: // global
           _s1sK8::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1wI9_info;
           R5 = _s1sK8::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w^%^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wI9() //  [R1, R2]
         { info_tbl: [(c1wI9,
                       label: block_c1wI9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wI9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wIh; else goto c1wIg;
       c1wIh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1wIg: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Real.$w^%^_closure" {
     GHC.Real.$w^%^_closure:
         const GHC.Real.$w^%^_info;
         const 0;
 },
 $dNum_s1sKk_entry() //  [R1]
         { info_tbl: [(c1wIv,
                       label: $dNum_s1sKk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wIv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wIw; else goto c1wIx;
       c1wIw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wIx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sKm_entry() //  [R1]
         { info_tbl: [(c1wIG,
                       label: sat_s1sKm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wIG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wIH; else goto c1wII;
       c1wIH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wII: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sKp_entry() //  [R1]
         { info_tbl: [(c1wIR,
                       label: sat_s1sKp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wIR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wIS; else goto c1wIT;
       c1wIS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wIT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Real.$w^%^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1wIU,
                       label: GHC.Real.$w^%^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wIU: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c1wIV; else goto c1wIW;
       c1wIV: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w^%^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wIW: // global
           I64[Sp - 40] = block_c1wIn_info;
           _s1sKf::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s1sKf::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wIn() //  [R1]
         { info_tbl: [(c1wIn,
                       label: block_c1wIn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wIn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wIZ; else goto c1wIY;
       c1wIZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wIY: // global
           I64[Hp - 16] = $dNum_s1sKk_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1wIy_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wIy() //  [R1]
         { info_tbl: [(c1wIy,
                       label: block_c1wIy_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wIy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wJ2; else goto c1wJ1;
       c1wJ2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wJ1: // global
           I64[Hp - 16] = sat_s1sKm_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1wIJ_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 40];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1wIJ() //  [R1]
         { info_tbl: [(c1wIJ,
                       label: block_c1wIJ_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wIJ: // global
           if (R1 & 7 == 1) goto c1wJ5; else goto c1wJB;
       c1wJ5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wJ8; else goto c1wJ7;
       c1wJ8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wJ7: // global
           I64[Hp - 16] = sat_s1sKp_info;
           P64[Hp] = P64[Sp + 16];
           _s1sKl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1wJ3_info;
           R2 = _s1sKl::P64;
           P64[Sp + 16] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1wJB: // global
           R1 = lvl6_r1j3R_closure;
           Sp = Sp + 56;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1wJ3() //  [R1]
         { info_tbl: [(c1wJ3,
                       label: block_c1wJ3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wJ3: // global
           _c1wIN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1wJc_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = _c1wIN::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1wJc() //  [R1]
         { info_tbl: [(c1wJc,
                       label: block_c1wJc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wJc: // global
           if (R1 & 7 == 1) goto c1wJo; else goto c1wJx;
       c1wJo: // global
           I64[Sp] = block_c1wJh_info;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = GHC.Num.$fNumInteger_closure;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
       c1wJx: // global
           R2 = GHC.Real.$fEnumRatio1_closure;
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1wJh() //  [R1]
         { info_tbl: [(c1wJh,
                       label: block_c1wJh_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wJh: // global
           _s1sKh::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1wJl_info;
           R5 = P64[Sp + 32];
           R4 = _s1sKh::P64;
           R3 = P64[Sp + 8];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wJl() //  [R1]
         { info_tbl: [(c1wJl,
                       label: block_c1wJl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wJl: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.060167595 UTC

[section ""data" . GHC.Real.$w^^%^^_closure" {
     GHC.Real.$w^^%^^_closure:
         const GHC.Real.$w^^%^^_info;
         const 0;
 },
 $dNum_s1sKz_entry() //  [R1]
         { info_tbl: [(c1wP0,
                       label: $dNum_s1sKz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wP0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wP1; else goto c1wP2;
       c1wP1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wP2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sKB_entry() //  [R1]
         { info_tbl: [(c1wPb,
                       label: sat_s1sKB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wPb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wPc; else goto c1wPd;
       c1wPc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wPd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sKE_entry() //  [R1]
         { info_tbl: [(c1wPm,
                       label: sat_s1sKE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wPm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wPn; else goto c1wPo;
       c1wPn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wPo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sKK_entry() //  [R1]
         { info_tbl: [(c1wPJ,
                       label: sat_s1sKK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wPJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wPK; else goto c1wPL;
       c1wPK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wPL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sKJ_entry() //  [R1]
         { info_tbl: [(c1wPQ,
                       label: sat_s1sKJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wPQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wPR; else goto c1wPS;
       c1wPR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wPS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sKM_entry() //  [R1]
         { info_tbl: [(c1wQ1,
                       label: sat_s1sKM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wQ1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wQ2; else goto c1wQ3;
       c1wQ2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wQ3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sKT_entry() //  [R1]
         { info_tbl: [(c1wQa,
                       label: sat_s1sKT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wQa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wQb; else goto c1wQc;
       c1wQb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wQc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sKV_entry() //  [R1]
         { info_tbl: [(c1wQl,
                       label: sat_s1sKV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wQl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wQm; else goto c1wQn;
       c1wQm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wQn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u1wS8_srtd" {
     u1wS8_srtd:
         const S1sVz_srt+296;
         const 167;
         const 1;
         const 0;
         const 354871676928;
 },
 GHC.Real.$w^^%^^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1wQo,
                       label: GHC.Real.$w^^%^^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wQo: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c1wQp; else goto c1wQq;
       c1wQp: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.$w^^%^^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wQq: // global
           I64[Sp - 40] = block_c1wOS_info;
           _s1sKu::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s1sKu::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1wS9_srtd" {
     u1wS9_srtd:
         const S1sVz_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1wOS() //  [R1]
         { info_tbl: [(c1wOS,
                       label: block_c1wOS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wOS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wQt; else goto c1wQs;
       c1wQt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wQs: // global
           I64[Hp - 16] = $dNum_s1sKz_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c1wP3_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1wSa_srtd" {
     u1wSa_srtd:
         const S1sVz_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1wP3() //  [R1]
         { info_tbl: [(c1wP3,
                       label: block_c1wP3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wP3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wQw; else goto c1wQv;
       c1wQw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wQv: // global
           I64[Hp - 16] = sat_s1sKB_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c1wPe_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 40];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.>_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1wSb_srtd" {
     u1wSb_srtd:
         const S1sVz_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1wPe() //  [R1]
         { info_tbl: [(c1wPe,
                       label: block_c1wPe_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wPe: // global
           if (R1 & 7 == 1) goto c1wQy; else goto c1wRW;
       c1wQy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wQB; else goto c1wQA;
       c1wQB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wQA: // global
           I64[Hp - 16] = sat_s1sKE_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp] = block_c1wPp_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c1wRW: // global
           I64[Sp + 16] = block_c1wRQ_info;
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = GHC.Num.$fNumInteger_closure;
           Sp = Sp + 16;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1wSc_srtd" {
     u1wSc_srtd:
         const S1sVz_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1wPp() //  [R1]
         { info_tbl: [(c1wPp,
                       label: block_c1wPp_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wPp: // global
           _c1wPi::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1wPt_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 48];
           P64[Sp] = _c1wPi::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u1wSd_srtd" {
     u1wSd_srtd:
         const S1sVz_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993769984;
 },
 _c1wPt() //  [R1]
         { info_tbl: [(c1wPt,
                       label: block_c1wPt_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wPt: // global
           if (R1 & 7 == 1) goto c1wQF; else goto c1wRN;
       c1wQF: // global
           I64[Sp] = block_c1wPx_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       c1wRN: // global
           R2 = GHC.Real.$fEnumRatio1_closure;
           R1 = GHC.Real.$fEnumRatio1_closure;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1wSe_srtd" {
     u1wSe_srtd:
         const S1sVz_srt+296;
         const 165;
         const 1;
         const 0;
         const 79993765888;
 },
 _c1wPx() //  [R1]
         { info_tbl: [(c1wPx,
                       label: block_c1wPx_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wPx: // global
           if (R1 == 1) goto c1wRz; else goto c1wQI;
       c1wRz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1wRC; else goto c1wRB;
       c1wRC: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1wRB: // global
           I64[Hp - 24] = sat_s1sKT_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c1wQd_info;
           R5 = Hp - 24;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
       c1wQI: // global
           I64[Sp] = block_c1wPB_info;
           R3 = GHC.Real.even1_closure;
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wQd() //  [R1]
         { info_tbl: [(c1wQd,
                       label: block_c1wQd_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wQd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1wRF; else goto c1wRE;
       c1wRF: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wRE: // global
           I64[Hp - 24] = sat_s1sKV_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 32] = block_c1wRy_info;
           R5 = Hp - 24;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 40] = R1;
           Sp = Sp + 32;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wRy() //  [R1]
         { info_tbl: [(c1wRy,
                       label: block_c1wRy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wRy: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u1wSf_srtd" {
     u1wSf_srtd:
         const S1sVz_srt+296;
         const 165;
         const 1;
         const 0;
         const 79456894976;
 },
 _c1wPB() //  [R1]
         { info_tbl: [(c1wPB,
                       label: block_c1wPB_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wPB: // global
           if (R1 == 1) goto c1wRx; else goto c1wQL;
       c1wRx: // global
           R1 = GHC.Real.ratioZeroDenominatorError_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1wQL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1wQO; else goto c1wQN;
       c1wQO: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1wQN: // global
           I64[Hp - 48] = sat_s1sKK_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = sat_s1sKJ_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_c1wPT_info;
           R5 = Hp - 48;
           R4 = Hp - 16;
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wPT() //  [R1]
         { info_tbl: [(c1wPT,
                       label: block_c1wPT_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wPT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1wQR; else goto c1wQQ;
       c1wQR: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wQQ: // global
           I64[Hp - 24] = sat_s1sKM_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c1wQJ_info;
           R5 = Hp - 24;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wQJ() //  [R1]
         { info_tbl: [(c1wQJ,
                       label: block_c1wQJ_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wQJ: // global
           I64[Sp + 16] = block_c1wQV_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wQV() //  [R1]
         { info_tbl: [(c1wQV,
                       label: block_c1wQV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wQV: // global
           _s1sKL::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1wR7; else goto c1wRn;
       c1wR7: // global
           I64[Sp] = block_c1wR0_info;
           R2 = _s1sKL::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       c1wRn: // global
           I64[Sp] = block_c1wRg_info;
           R1 = _s1sKL::P64;
           if (R1 & 7 != 0) goto u1wS5; else goto c1wRh;
       u1wS5: // global
           call _c1wRg(R1) args: 0, res: 0, upd: 0;
       c1wRh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wR0() //  [R1]
         { info_tbl: [(c1wR0,
                       label: block_c1wR0_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wR0: // global
           _s1sKI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1wR4_info;
           _s1sKO::P64 = R1;
           R1 = _s1sKI::P64;
           P64[Sp + 16] = _s1sKO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1wS6; else goto c1wR9;
       u1wS6: // global
           call _c1wR4(R1) args: 0, res: 0, upd: 0;
       c1wR9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wR4() //  [R1]
         { info_tbl: [(c1wR4,
                       label: block_c1wR4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wR4: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1wRg() //  [R1]
         { info_tbl: [(c1wRg,
                       label: block_c1wRg_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wRg: // global
           _s1sKI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1wRl_info;
           _s1sKQ::P64 = R1;
           R1 = _s1sKI::P64;
           P64[Sp + 16] = _s1sKQ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1wS7; else goto c1wRp;
       u1wS7: // global
           call _c1wRl(R1) args: 0, res: 0, upd: 0;
       c1wRp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wRl() //  [R1]
         { info_tbl: [(c1wRl,
                       label: block_c1wRl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wRl: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1wRQ() //  [R1]
         { info_tbl: [(c1wRQ,
                       label: block_c1wRQ_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wRQ: // global
           _s1sKw::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c1wRU_info;
           R5 = P64[Sp + 32];
           R4 = _s1sKw::P64;
           R3 = P64[Sp + 8];
           R2 = GHC.Num.$fNumInteger_closure;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wRU() //  [R1]
         { info_tbl: [(c1wRU,
                       label: block_c1wRU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wRU: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.11945276 UTC

[section ""data" . GHC.Real.^^%^^_closure" {
     GHC.Real.^^%^^_closure:
         const GHC.Real.^^%^^_info;
         const 0;
 },
 GHC.Real.^^%^^_entry() //  [R2, R3, R4]
         { info_tbl: [(c1wVe,
                       label: GHC.Real.^^%^^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wVe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1wVk; else goto c1wVl;
       c1wVk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^^%^^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wVl: // global
           I64[Sp - 24] = block_c1wVb_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1wVq; else goto c1wVc;
       u1wVq: // global
           call _c1wVb(R1) args: 0, res: 0, upd: 0;
       c1wVc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1wVb() //  [R1]
         { info_tbl: [(c1wVb,
                       label: block_c1wVb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wVb: // global
           _s1sL1::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c1wVh_info;
           R5 = _s1sL1::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.$w^^%^^_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wVh() //  [R1, R2]
         { info_tbl: [(c1wVh,
                       label: block_c1wVh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wVh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wVp; else goto c1wVo;
       c1wVp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c1wVo: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.128328667 UTC

[section ""data" . GHC.Real.^^_closure" {
     GHC.Real.^^_closure:
         const GHC.Real.^^_info;
         const 0;
 },
 $dNum_s1sLd_entry() //  [R1]
         { info_tbl: [(c1wVT,
                       label: $dNum_s1sLd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wVT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wVU; else goto c1wVV;
       c1wVU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wVV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sLf_entry() //  [R1]
         { info_tbl: [(c1wW0,
                       label: sat_s1sLf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wW0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wW1; else goto c1wW2;
       c1wW1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wW2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Real.even1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sLi_entry() //  [R1]
         { info_tbl: [(c1wWj,
                       label: sat_s1sLi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wWj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1wWk; else goto c1wWl;
       c1wWk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wWl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1sLh_entry() //  [R1]
         { info_tbl: [(c1wWq,
                       label: sat_s1sLh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wWq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wWr; else goto c1wWs;
       c1wWr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wWs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sLj_entry() //  [R1]
         { info_tbl: [(c1wWt,
                       label: sat_s1sLj_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wWt: // global
           _s1sLj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1wWu; else goto c1wWv;
       c1wWv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1wWx; else goto c1wWw;
       c1wWx: // global
           HpAlloc = 56;
           goto c1wWu;
       c1wWu: // global
           R1 = _s1sLj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wWw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1sLj::P64;
           _s1sL8::P64 = P64[_s1sLj::P64 + 16];
           _s1sL9::P64 = P64[_s1sLj::P64 + 24];
           _s1sLa::P64 = P64[_s1sLj::P64 + 32];
           _s1sLb::P64 = P64[_s1sLj::P64 + 40];
           _s1sLd::P64 = P64[_s1sLj::P64 + 48];
           I64[Hp - 48] = sat_s1sLi_info;
           P64[Hp - 32] = _s1sLb::P64;
           P64[Hp - 24] = _s1sLd::P64;
           I64[Hp - 16] = sat_s1sLh_info;
           P64[Hp] = _s1sL8::P64;
           R5 = Hp - 48;
           R4 = _s1sLa::P64;
           R3 = _s1sL9::P64;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1sLk_entry() //  [R1]
         { info_tbl: [(c1wWE,
                       label: sat_s1sLk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wWE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1wWF; else goto c1wWG;
       c1wWF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1wWG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Real.^^_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1wWH,
                       label: GHC.Real.^^_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wWH: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1wWI; else goto c1wWJ;
       c1wWI: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.^^_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wWJ: // global
           I64[Sp - 40] = block_c1wVL_info;
           _s1sL8::P64 = R2;
           R2 = R3;
           P64[Sp - 32] = _s1sL8::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wVL() //  [R1]
         { info_tbl: [(c1wVL,
                       label: block_c1wVL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wVL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1wWM; else goto c1wWL;
       c1wWM: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wWL: // global
           I64[Hp - 40] = $dNum_s1sLd_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_s1sLf_info;
           _c1wVP::P64 = Hp - 40;
           P64[Hp] = _c1wVP::P64;
           I64[Sp - 16] = block_c1wW3_info;
           R2 = R1;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = _c1wVP::P64;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1wW3() //  [R1]
         { info_tbl: [(c1wW3,
                       label: block_c1wW3_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wW3: // global
           _c1wVW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1wW7_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 48];
           P64[Sp] = _c1wVW::P64;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1wW7() //  [R1]
         { info_tbl: [(c1wW7,
                       label: block_c1wW7_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wW7: // global
           _s1sL8::P64 = P64[Sp + 16];
           _s1sL9::P64 = P64[Sp + 24];
           _s1sLa::P64 = P64[Sp + 32];
           _s1sLb::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c1wWP; else goto c1wWT;
       c1wWP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1wWS; else goto c1wWR;
       c1wWS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wWR: // global
           I64[Hp - 48] = sat_s1sLj_info;
           P64[Hp - 32] = _s1sL8::P64;
           P64[Hp - 24] = _s1sL9::P64;
           P64[Hp - 16] = _s1sLa::P64;
           P64[Hp - 8] = _s1sLb::P64;
           P64[Hp] = P64[Sp + 8];
           R2 = _s1sL8::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 48;
           Sp = Sp + 32;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 8;
       c1wWT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wWW; else goto c1wWV;
       c1wWW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1wWV: // global
           I64[Hp - 16] = sat_s1sLk_info;
           P64[Hp] = _s1sL8::P64;
           R5 = _s1sLb::P64;
           R4 = _s1sLa::P64;
           R3 = _s1sL9::P64;
           R2 = Hp - 16;
           Sp = Sp + 48;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.153596808 UTC

[section ""data" . GHC.Real.C:Fractional_closure" {
     GHC.Real.C:Fractional_closure:
         const GHC.Real.C:Fractional_info;
 },
 GHC.Real.C:Fractional_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1wY6,
                       label: GHC.Real.C:Fractional_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wY6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1wYa; else goto c1wY9;
       c1wYa: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.C:Fractional_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wY9: // global
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.158028885 UTC

[section ""data" . GHC.Real.C:Integral_closure" {
     GHC.Real.C:Integral_closure:
         const GHC.Real.C:Integral_info;
 },
 GHC.Real.C:Integral_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wYi: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Real.C:Integral_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 GHC.Real.C:Integral_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1wYn,
                       label: GHC.Real.C:Integral_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wYn: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1wYr; else goto c1wYq;
       c1wYr: // global
           HpAlloc = 80;
           R1 = GHC.Real.C:Integral_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       c1wYq: // global
           I64[Hp - 72] = GHC.Real.C:Integral_con_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = R6;
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 71;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.163971505 UTC

[section ""data" . GHC.Real.C:Real_closure" {
     GHC.Real.C:Real_closure:
         const GHC.Real.C:Real_info;
 },
 GHC.Real.C:Real_entry() //  [R2, R3, R4]
         { info_tbl: [(c1wYJ,
                       label: GHC.Real.C:Real_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wYJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1wYN; else goto c1wYM;
       c1wYN: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.C:Real_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wYM: // global
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.168258124 UTC

[section ""data" . GHC.Real.C:RealFrac_closure" {
     GHC.Real.C:RealFrac_closure:
         const GHC.Real.C:RealFrac_info;
 },
 GHC.Real.C:RealFrac_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wYV: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Real.C:RealFrac_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Real.C:RealFrac_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1wZ0,
                       label: GHC.Real.C:RealFrac_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wZ0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1wZ4; else goto c1wZ3;
       c1wZ4: // global
           HpAlloc = 64;
           R1 = GHC.Real.C:RealFrac_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       c1wZ3: // global
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.173916035 UTC

[section ""data" . GHC.Real.:%_closure" {
     GHC.Real.:%_closure:
         const GHC.Real.:%_info;
 },
 GHC.Real.:%_entry() //  [R2, R3]
         { info_tbl: [(c1wZk,
                       label: GHC.Real.:%_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wZk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1wZo; else goto c1wZn;
       c1wZo: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Real.:%_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1wZn: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.178198359 UTC

[GHC.Real.C:Fractional_con_entry() //  [R1]
         { info_tbl: [(c1wZv,
                       label: GHC.Real.C:Fractional_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,70,114,97,99,116,105,111,110,97,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wZv: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.18155598 UTC

[GHC.Real.C:Integral_con_entry() //  [R1]
         { info_tbl: [(c1wZC,
                       label: GHC.Real.C:Integral_con_info
                       rep:HeapRep 9 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,73,110,116,101,103,114,97,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wZC: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.185841498 UTC

[GHC.Real.C:Real_con_entry() //  [R1]
         { info_tbl: [(c1wZJ,
                       label: GHC.Real.C:Real_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,82,101,97,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wZJ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.188960329 UTC

[GHC.Real.C:RealFrac_con_entry() //  [R1]
         { info_tbl: [(c1wZQ,
                       label: GHC.Real.C:RealFrac_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,67,58,82,101,97,108,70,114,97,99]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wZQ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.1922704 UTC

[GHC.Real.:%_con_entry() //  [R1]
         { info_tbl: [(c1wZX,
                       label: GHC.Real.:%_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,82,101,97,108,46,58,37]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1wZX: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:19.195366382 UTC

[section ""relreadonly" . S1sVz_srt" {
     S1sVz_srt:
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$fOrdRatio_$s$c<_closure;
         const GHC.Real.$fEnumRatio_$s$c<=_closure;
         const GHC.Real.$w$s$ccompare_closure;
         const GHC.Real.$fEnumRatio_$s$ccompare_closure;
         const GHC.Real.$fEnumRatio_$s$c>=_closure;
         const GHC.Real.$fOrdRatio_$s$c>_closure;
         const GHC.Real.$fOrdRatio_$s$cmin_closure;
         const GHC.Real.$fOrdRatio_$s$cmax_closure;
         const sat_s1sfy_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$fFractionalRatio_$s$csignum_closure;
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure;
         const GHC.Real.$fEnumRatio_$ctoRational_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.$dmfloor_closure;
         const GHC.Real.$dmceiling_closure;
         const GHC.Real.$dmrecip_closure;
         const GHC.Real.$dmdivMod_closure;
         const GHC.Exception.divZeroException_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.$fIntegralInt_$cmod_closure;
         const GHC.Real.$fIntegralInt_$crem_closure;
         const GHC.Real.$fIntegralInteger_$cquot_closure;
         const GHC.Real.$fIntegralInteger_$crem_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Real.$fIntegralInteger_$cdiv_closure;
         const GHC.Integer.Type.modInteger_closure;
         const GHC.Real.$fIntegralInteger_$cmod_closure;
         const GHC.Real.$fIntegralInteger_$cquotRem_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Real.$fIntegralInteger_$cdivMod_closure;
         const GHC.Real.$fIntegralWord_$cquot_closure;
         const GHC.Real.$fIntegralWord_$crem_closure;
         const GHC.Real.$fIntegralWord_$cquotRem_closure;
         const GHC.Real.$fIntegralWord_$cdivMod_closure;
         const GHC.Exception.ratioZeroDenomException_closure;
         const GHC.Real.ratioZeroDenominatorError_closure;
         const GHC.Real.$fFractionalRatio_$s$crecip_closure;
         const GHC.Exception.overflowException_closure;
         const GHC.Real.$fIntegralInt_$cdivMod_closure;
         const lvl_r1j38_closure;
         const GHC.Real.$fIntegralInt_$cquotRem_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Real.$fIntegralInt_$cdiv_closure;
         const GHC.Real.$w$cdiv_closure;
         const GHC.Real.$fIntegralInt_$cquot_closure;
         const GHC.Real.$wgcd'_closure;
         const lvl2_r1j3a_closure;
         const GHC.Real.$fEnumRatio_gcd'_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.gcd_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.reduce_$sreduce_closure;
         const GHC.Real.$fRealWord_$ctoRational_closure;
         const GHC.Real.$fFractionalRatio_$s$c*_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Real.$w$s$c-_closure;
         const GHC.Real.$fEnumRatio_$s$c-_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$fEnumRatio_$s$c+_closure;
         const GHC.Real.$w$s$cfromRational_closure;
         const GHC.Real.$fFractionalRatio_$s$cfromRational_closure;
         const GHC.Real.$w$s$c/_closure;
         const GHC.Real.$fFractionalRatio_$s$c/_closure;
         const GHC.Real.$w$snumericEnumFrom_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFrom_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$wnumericEnumFrom_closure;
         const GHC.Real.numericEnumFrom_closure;
         const sat_s1soJ_closure;
         const GHC.Real.even2_closure;
         const GHC.Real.$fEnumRatio2_closure;
         const GHC.Real.$fEnumRatio_$s$c<=_closure;
         const GHC.Real.$w$snumericEnumFromTo_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFromTo_closure;
         const GHC.Real.numericEnumFromTo_closure;
         const GHC.Real.$w$snumericEnumFromThen_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThen_closure;
         const GHC.Real.$fEnumRatio_$s$c>=_closure;
         const GHC.Real.$w$snumericEnumFromThenTo_closure;
         const GHC.Real.$fEnumRatio_$snumericEnumFromThenTo_closure;
         const GHC.Real.numericEnumFromThenTo_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.showSigned_closure;
         const GHC.Real.even_closure;
         const GHC.Real.odd_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const lvl3_r1j3b_closure;
         const GHC.Real.$dmround_closure;
         const GHC.Real.$fRealFracRatio1_closure;
         const GHC.Real.integralEnumFrom_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Real.integralEnumFromThen_closure;
         const GHC.Real.integralEnumFromTo_closure;
         const GHC.Real.integralEnumFromThenTo_closure;
         const GHC.Real.$w$csignum_closure;
         const GHC.Real.$fNumRatio_$csignum_closure;
         const GHC.Real.$w$cfromInteger_closure;
         const GHC.Real.$fNumRatio_$cfromInteger_closure;
         const GHC.Real.$w$crecip_closure;
         const GHC.Real.$fFractionalRatio_$crecip_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.$w$s$cproperFraction_closure;
         const GHC.Real.$fEnumRatio_$s$cproperFraction_closure;
         const GHC.Real.gcd_closure;
         const GHC.Real.$wreduce_closure;
         const GHC.Real.reduce_closure;
         const GHC.Real.%_$s%_closure;
         const GHC.Real.$w$s$cfromRational_closure;
         const GHC.Real.$w%_closure;
         const GHC.Real.%_closure;
         const GHC.Real.$w$c/_closure;
         const GHC.Real.$fFractionalRatio_$c/_closure;
         const GHC.Real.$w$cfromRational_closure;
         const GHC.Real.$fFractionalRatio_$cfromRational_closure;
         const GHC.Real.$w$c+_closure;
         const GHC.Real.$fNumRatio_$c+_closure;
         const GHC.Real.$w$c-_closure;
         const GHC.Real.$fNumRatio_$c-_closure;
         const GHC.Real.$w$c*_closure;
         const GHC.Real.$fNumRatio_$c*_closure;
         const GHC.Real.$fNumRatio_closure;
         const GHC.Real.$fEnumRatio_$s$csucc_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$fEnumRatio_$csucc_closure;
         const GHC.Real.$fEnumRatio_$s$cpred_closure;
         const GHC.Real.$fEnumRatio_$cpred_closure;
         const GHC.Real.$fFractionalRatio_closure;
         const GHC.Real.$wnumericEnumFrom_closure;
         const GHC.Real.$fEnumRatio_$cenumFrom_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThen_closure;
         const GHC.Real.$fEnumRatio_$cenumFromTo_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThenTo_closure;
         const GHC.Real.$fRealRatio_closure;
         const GHC.Real.$w$s$cceiling_closure;
         const GHC.Real.$fRealFracRatio_$s$cceiling_closure;
         const GHC.Real.$w$cceiling_closure;
         const GHC.Real.$fRealFracRatio_$cceiling_closure;
         const GHC.Real.$w$s$cfloor_closure;
         const GHC.Real.$fRealFracRatio_$s$cfloor_closure;
         const GHC.Real.$w$cfloor_closure;
         const GHC.Real.$fRealFracRatio_$cfloor_closure;
         const sat_s1sCJ_closure;
         const GHC.Real.$w$s$cround_closure;
         const GHC.Real.$fRealFracRatio2_closure;
         const GHC.Real.$fRealFracRatio_$s$cround_closure;
         const GHC.Real.$w$cround_closure;
         const GHC.Real.$fRealFracRatio_$cround_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.$fRealFracRatio_$s$ctruncate_closure;
         const GHC.Real.$fRealFracRatio_closure;
         const g_r1j3N_closure;
         const GHC.Real.^_f_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Real.^_$s^_closure;
         const GHC.Real.^1_closure;
         const GHC.Real.$w$s$cfromEnum_closure;
         const GHC.Real.$fEnumRatio_$s$cfromEnum_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Real.$w$s$cshowsPrec_closure;
         const GHC.Real.$fShowRatio_$s$cshowsPrec_closure;
         const GHC.Real.$fShowRatio1_closure;
         const GHC.Real.$w$s$cshow_closure;
         const GHC.Real.$fShowRatio_$s$cshow_closure;
         const GHC.Real.$fIntegralWord_closure;
         const GHC.Real.$w$slcm_closure;
         const GHC.Real.lcm_$slcm_closure;
         const GHC.Real.$w$slcm1_closure;
         const GHC.Real.lcm_$slcm1_closure;
         const GHC.Real.gcd_closure;
         const GHC.Real.lcm_closure;
         const GHC.Real.$w$ctoEnum_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$fEnumRatio_$ctoEnum_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThenTo_closure;
         const GHC.Real.$fEnumRatio_$cenumFromTo_closure;
         const GHC.Real.$fEnumRatio_$cenumFromThen_closure;
         const GHC.Real.$fEnumRatio_$cenumFrom_closure;
         const GHC.Real.$fEnumRatio_$cpred_closure;
         const GHC.Real.$fEnumRatio_$csucc_closure;
         const GHC.Real.$fEnumRatio_closure;
         const GHC.Real.^_$s^2_closure;
         const GHC.Real.^2_closure;
         const $wg1_r1j3Q_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$wf_closure;
         const GHC.Real.^_f1_closure;
         const GHC.Real.^_$s^1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Real.even1_closure;
         const GHC.Real.even2_closure;
         const GHC.Real.^_closure;
         const lvl7_r1j3S_closure;
         const GHC.Real.even_closure;
         const GHC.Real.^%^_closure;
         const GHC.Real.$w^%^_closure;
         const GHC.Num.$fNumInteger_closure;
         const lvl6_r1j3R_closure;
         const GHC.Real.$w^^%^^_closure;
         const GHC.Real.^^%^^_closure;
         const GHC.Real.^^_closure;
 }]

