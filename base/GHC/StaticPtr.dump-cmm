
==================== Output Cmm ====================
2018-03-16 16:11:12.939438911 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:12.940279887 UTC

[section ""data" . GHC.StaticPtr.fromStaticPtr_closure" {
     GHC.StaticPtr.fromStaticPtr_closure:
         const GHC.StaticPtr.fromStaticPtr_info;
 },
 GHC.StaticPtr.fromStaticPtr_entry() //  [R2]
         { info_tbl: [(cfvpx,
                       label: GHC.StaticPtr.fromStaticPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvpx: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.941153687 UTC

[section ""data" . GHC.StaticPtr.$fIsStaticStaticPtr_closure" {
     GHC.StaticPtr.$fIsStaticStaticPtr_closure:
         const GHC.StaticPtr.$fIsStaticStaticPtr_info;
 },
 GHC.StaticPtr.$fIsStaticStaticPtr_entry() //  [R2]
         { info_tbl: [(cfvpE,
                       label: GHC.StaticPtr.$fIsStaticStaticPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvpE: // global
           R2 = R2;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.941884887 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo6_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo6_bytes:
         I8[] [83,116,97,116,105,99,80,116,114,73,110,102,111,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.942461661 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo5_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo5_bytes:
         I8[] [115,112,73,110,102,111,85,110,105,116,73,100,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.943061666 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo4_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo4_bytes:
         I8[] [115,112,73,110,102,111,77,111,100,117,108,101,78,97,109,101,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.943643347 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo3_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo3_bytes:
         I8[] [115,112,73,110,102,111,83,114,99,76,111,99,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.944232341 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo2_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo2_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.94797322 UTC

[section ""data" . GHC.StaticPtr.$w$cshowsPrec_closure" {
     GHC.StaticPtr.$w$cshowsPrec_closure:
         const GHC.StaticPtr.$w$cshowsPrec_info;
         const 0;
 },
 GHC.StaticPtr.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvpI: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvma_entry() //  [R1]
         { info_tbl: [(cfvqA,
                       label: sat_sfvma_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvqA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvqB; else goto cfvqC;
       cfvqB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvqC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvm7_entry() //  [R1, R2]
         { info_tbl: [(cfvqM,
                       label: sat_sfvm7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvqM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvqS; else goto cfvqT;
       cfvqS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvqT: // global
           I64[Sp - 16] = block_cfvqJ_info;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufvqY; else goto cfvqK;
       ufvqY: // global
           call _cfvqJ(R1) args: 0, res: 0, upd: 0;
       cfvqK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvqJ() //  [R1]
         { info_tbl: [(cfvqJ,
                       label: block_cfvqJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvqJ: // global
           _sfvm1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cfvqP_info;
           R4 = _sfvm1::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfvqP() //  [R1, R2]
         { info_tbl: [(cfvqP,
                       label: block_cfvqP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvqP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvqX; else goto cfvqW;
       cfvqX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cfvqW: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvm0_entry() //  [R1, R2]
         { info_tbl: [(cfvr8,
                       label: sat_sfvm0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvr8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvre; else goto cfvrf;
       cfvre: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvrf: // global
           I64[Sp - 16] = block_cfvr5_info;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufvrk; else goto cfvr6;
       ufvrk: // global
           call _cfvr5(R1) args: 0, res: 0, upd: 0;
       cfvr6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvr5() //  [R1]
         { info_tbl: [(cfvr5,
                       label: block_cfvr5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvr5: // global
           _sfvlU::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cfvrb_info;
           R4 = _sfvlU::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfvrb() //  [R1, R2]
         { info_tbl: [(cfvrb,
                       label: block_cfvrb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvrb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvrj; else goto cfvri;
       cfvrj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cfvri: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvmc_entry() //  [R1]
         { info_tbl: [(cfvrm,
                       label: sat_sfvmc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvrm: // global
           _sfvmc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvrn; else goto cfvro;
       cfvro: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cfvrq; else goto cfvrp;
       cfvrq: // global
           HpAlloc = 128;
           goto cfvrn;
       cfvrn: // global
           R1 = _sfvmc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvrp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmc::P64;
           _sfvlQ::P64 = P64[_sfvmc::P64 + 16];
           _sfvlS::P64 = P64[_sfvmc::P64 + 24];
           _sfvlT::P64 = P64[_sfvmc::P64 + 32];
           I64[Hp - 120] = sat_sfvma_info;
           P64[Hp - 104] = _sfvlQ::P64;
           I64[Hp - 96] = :_con_info;
           P64[Hp - 88] = GHC.Show.$fShow(,)2_closure;
           P64[Hp - 80] = Hp - 120;
           I64[Hp - 72] = sat_sfvm7_info;
           P64[Hp - 64] = _sfvlT::P64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           I64[Hp - 32] = sat_sfvm0_info;
           P64[Hp - 24] = _sfvlS::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 54;
           R3 = Hp - 94;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Show.$fShow(,)_go1_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmd_entry() //  [R1]
         { info_tbl: [(cfvrr,
                       label: sat_sfvmd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvrr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfvrt; else goto cfvru;
       cfvrt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvru: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cfvqn_info;
           _sfvlQ::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sfvlQ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufvry; else goto cfvqo;
       ufvry: // global
           call _cfvqn(R1) args: 0, res: 0, upd: 0;
       cfvqo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfvqn() //  [R1]
         { info_tbl: [(cfvqn,
                       label: block_cfvqn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvqn: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfvrx; else goto cfvrw;
       cfvrx: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cfvrw: // global
           _sfvlS::P64 = P64[R1 + 7];
           _sfvlT::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sfvmc_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sfvlS::P64;
           P64[Hp - 24] = _sfvlT::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvme_entry() //  [R1]
         { info_tbl: [(cfvrz,
                       label: sat_sfvme_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvrz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfvrD; else goto cfvrC;
       cfvrD: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvrC: // global
           _sfvlN::P64 = P64[R1 + 16];
           _sfvlQ::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sfvmd_info;
           P64[Hp - 8] = _sfvlN::P64;
           P64[Hp] = _sfvlQ::P64;
           R3 = Hp - 24;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvmf_entry() //  [R1]
         { info_tbl: [(cfvrE,
                       label: sat_sfvmf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvrE: // global
           _sfvmf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvrF; else goto cfvrG;
       cfvrG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfvrI; else goto cfvrH;
       cfvrI: // global
           HpAlloc = 32;
           goto cfvrF;
       cfvrF: // global
           R1 = _sfvmf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvrH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmf::P64;
           _sfvlN::P64 = P64[_sfvmf::P64 + 16];
           _sfvlQ::P64 = P64[_sfvmf::P64 + 24];
           I64[Hp - 24] = sat_sfvme_info;
           P64[Hp - 8] = _sfvlN::P64;
           P64[Hp] = _sfvlQ::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmh_entry() //  [R1]
         { info_tbl: [(cfvrK,
                       label: sat_sfvmh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvrK: // global
           _sfvmh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvrL; else goto cfvrM;
       cfvrM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfvrO; else goto cfvrN;
       cfvrO: // global
           HpAlloc = 56;
           goto cfvrL;
       cfvrL: // global
           R1 = _sfvmh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvrN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmh::P64;
           _sfvlM::P64 = P64[_sfvmh::P64 + 16];
           _sfvlN::P64 = P64[_sfvmh::P64 + 24];
           _sfvlQ::P64 = P64[_sfvmh::P64 + 32];
           I64[Hp - 48] = sat_sfvmf_info;
           P64[Hp - 32] = _sfvlN::P64;
           P64[Hp - 24] = _sfvlQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sfvlM::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmj_entry() //  [R1]
         { info_tbl: [(cfvrQ,
                       label: sat_sfvmj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvrQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfvrU; else goto cfvrT;
       cfvrU: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvrT: // global
           _sfvlM::P64 = P64[R1 + 16];
           _sfvlN::P64 = P64[R1 + 24];
           _sfvlQ::P64 = P64[R1 + 32];
           I64[Hp - 56] = sat_sfvmh_info;
           P64[Hp - 40] = _sfvlM::P64;
           P64[Hp - 32] = _sfvlN::P64;
           P64[Hp - 24] = _sfvlQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvmk_entry() //  [R1]
         { info_tbl: [(cfvrV,
                       label: sat_sfvmk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvrV: // global
           _sfvmk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvrW; else goto cfvrX;
       cfvrX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfvrZ; else goto cfvrY;
       cfvrZ: // global
           HpAlloc = 40;
           goto cfvrW;
       cfvrW: // global
           R1 = _sfvmk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvrY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmk::P64;
           _sfvlM::P64 = P64[_sfvmk::P64 + 16];
           _sfvlN::P64 = P64[_sfvmk::P64 + 24];
           _sfvlQ::P64 = P64[_sfvmk::P64 + 32];
           I64[Hp - 32] = sat_sfvmj_info;
           P64[Hp - 16] = _sfvlM::P64;
           P64[Hp - 8] = _sfvlN::P64;
           P64[Hp] = _sfvlQ::P64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmm_entry() //  [R1]
         { info_tbl: [(cfvs1,
                       label: sat_sfvmm_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvs1: // global
           _sfvmm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvs2; else goto cfvs3;
       cfvs3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfvs5; else goto cfvs4;
       cfvs5: // global
           HpAlloc = 64;
           goto cfvs2;
       cfvs2: // global
           R1 = _sfvmm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvs4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmm::P64;
           _sfvlL::P64 = P64[_sfvmm::P64 + 16];
           _sfvlM::P64 = P64[_sfvmm::P64 + 24];
           _sfvlN::P64 = P64[_sfvmm::P64 + 32];
           _sfvlQ::P64 = P64[_sfvmm::P64 + 40];
           I64[Hp - 56] = sat_sfvmk_info;
           P64[Hp - 40] = _sfvlM::P64;
           P64[Hp - 32] = _sfvlN::P64;
           P64[Hp - 24] = _sfvlQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sfvlL::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmo_entry() //  [R1]
         { info_tbl: [(cfvs7,
                       label: sat_sfvmo_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvs7: // global
           _sfvmo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvs8; else goto cfvs9;
       cfvs9: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfvsb; else goto cfvsa;
       cfvsb: // global
           HpAlloc = 72;
           goto cfvs8;
       cfvs8: // global
           R1 = _sfvmo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvsa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmo::P64;
           _sfvlL::P64 = P64[_sfvmo::P64 + 16];
           _sfvlM::P64 = P64[_sfvmo::P64 + 24];
           _sfvlN::P64 = P64[_sfvmo::P64 + 32];
           _sfvlQ::P64 = P64[_sfvmo::P64 + 40];
           I64[Hp - 64] = sat_sfvmm_info;
           P64[Hp - 48] = _sfvlL::P64;
           P64[Hp - 40] = _sfvlM::P64;
           P64[Hp - 32] = _sfvlN::P64;
           P64[Hp - 24] = _sfvlQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_sfvlP_entry() //  [R1, R2]
         { info_tbl: [(cfvsc,
                       label: p_sfvlP_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvsc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfvsg; else goto cfvsf;
       cfvsg: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvsf: // global
           _sfvlL::P64 = P64[R1 + 7];
           _sfvlM::P64 = P64[R1 + 15];
           _sfvlN::P64 = P64[R1 + 23];
           I64[Hp - 40] = sat_sfvmo_info;
           P64[Hp - 24] = _sfvlL::P64;
           P64[Hp - 16] = _sfvlM::P64;
           P64[Hp - 8] = _sfvlN::P64;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo6_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvmr_entry() //  [R1]
         { info_tbl: [(cfvsq,
                       label: sat_sfvmr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvsq: // global
           _sfvmr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvsr; else goto cfvss;
       cfvss: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvsu; else goto cfvst;
       cfvsu: // global
           HpAlloc = 24;
           goto cfvsr;
       cfvsr: // global
           R1 = _sfvmr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvst: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmr::P64;
           _sfvlO::P64 = P64[_sfvmr::P64 + 16];
           _sfvlP::P64 = P64[_sfvmr::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sfvlO::P64;
           R2 = Hp - 14;
           R1 = _sfvlP::P64;
           Sp = Sp - 16;
           call p_sfvlP_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.StaticPtr.$w$cshowsPrec_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfvsy,
                       label: GHC.StaticPtr.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [True, False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvsy: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cfvsC; else goto cfvsB;
       cfvsC: // global
           HpAlloc = 88;
           R1 = GHC.StaticPtr.$w$cshowsPrec_closure;
           I64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cfvsB: // global
           I64[Hp - 80] = p_sfvlP_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           _cfvpM::P64 = Hp - 79;
           if (%MO_S_Lt_W64(R2, 11)) goto cfvsw; else goto cfvsx;
       cfvsw: // global
           Hp = Hp - 56;
           R2 = R6;
           R1 = _cfvpM::P64;
           call p_sfvlP_entry(R2, R1) args: 8, res: 0, upd: 8;
       cfvsx: // global
           I64[Hp - 48] = sat_sfvmr_info;
           P64[Hp - 32] = R6;
           P64[Hp - 24] = _cfvpM::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.95578611 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cfvsM,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvsM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfvsQ; else goto cfvsR;
       cfvsQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfvsR: // global
           I64[Sp - 24] = block_cfvsJ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufvsZ; else goto cfvsK;
       ufvsZ: // global
           call _cfvsJ(R1) args: 0, res: 0, upd: 0;
       cfvsK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvsJ() //  [R1]
         { info_tbl: [(cfvsJ,
                       label: block_cfvsJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvsJ: // global
           I64[Sp] = block_cfvsP_info;
           _sfvmw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sfvmw::I64;
           if (R1 & 7 != 0) goto ufvsY; else goto cfvsT;
       ufvsY: // global
           call _cfvsP(R1) args: 0, res: 0, upd: 0;
       cfvsT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvsP() //  [R1]
         { info_tbl: [(cfvsP,
                       label: block_cfvsP_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvsP: // global
           R6 = P64[Sp + 16];
           R5 = P64[R1 + 23];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.957121138 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo7_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo7_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.9579888 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_entry() //  [R2]
         { info_tbl: [(cfvt7,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvt7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvt8; else goto cfvt9;
       cfvt8: // global
           R2 = R2;
           R1 = GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvt9: // global
           I64[Sp - 8] = block_cfvt4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvtd; else goto cfvt5;
       ufvtd: // global
           call _cfvt4(R1) args: 0, res: 0, upd: 0;
       cfvt5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvt4() //  [R1]
         { info_tbl: [(cfvt4,
                       label: block_cfvt4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvt4: // global
           R6 = GHC.Types.[]_closure+1;
           R5 = P64[R1 + 23];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.959284547 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo1_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo1_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo1_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo1_entry() //  [R2, R3]
         { info_tbl: [(cfvtl,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvtl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvtm; else goto cfvtn;
       cfvtm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.$fShowStaticPtrInfo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfvtn: // global
           I64[Sp - 16] = block_cfvti_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufvtr; else goto cfvtj;
       ufvtr: // global
           call _cfvti(R1) args: 0, res: 0, upd: 0;
       cfvtj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvti() //  [R1]
         { info_tbl: [(cfvti,
                       label: block_cfvti_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvti: // global
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 23];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.96053337 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cfvtw,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvtw: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.961353939 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure+3;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure+1;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.962170047 UTC

[section ""data" . GHC.StaticPtr.spInfoSrcLoc_closure" {
     GHC.StaticPtr.spInfoSrcLoc_closure:
         const GHC.StaticPtr.spInfoSrcLoc_info;
 },
 GHC.StaticPtr.spInfoSrcLoc_entry() //  [R2]
         { info_tbl: [(cfvtG,
                       label: GHC.StaticPtr.spInfoSrcLoc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvtG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvtH; else goto cfvtI;
       cfvtH: // global
           R2 = R2;
           R1 = GHC.StaticPtr.spInfoSrcLoc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvtI: // global
           I64[Sp - 8] = block_cfvtD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvtM; else goto cfvtE;
       ufvtM: // global
           call _cfvtD(R1) args: 0, res: 0, upd: 0;
       cfvtE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvtD() //  [R1]
         { info_tbl: [(cfvtD,
                       label: block_cfvtD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvtD: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.963438421 UTC

[section ""data" . GHC.StaticPtr.spInfoModuleName_closure" {
     GHC.StaticPtr.spInfoModuleName_closure:
         const GHC.StaticPtr.spInfoModuleName_info;
 },
 GHC.StaticPtr.spInfoModuleName_entry() //  [R2]
         { info_tbl: [(cfvtU,
                       label: GHC.StaticPtr.spInfoModuleName_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvtU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvtV; else goto cfvtW;
       cfvtV: // global
           R2 = R2;
           R1 = GHC.StaticPtr.spInfoModuleName_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvtW: // global
           I64[Sp - 8] = block_cfvtR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvu0; else goto cfvtS;
       ufvu0: // global
           call _cfvtR(R1) args: 0, res: 0, upd: 0;
       cfvtS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvtR() //  [R1]
         { info_tbl: [(cfvtR,
                       label: block_cfvtR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvtR: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.964722556 UTC

[section ""data" . GHC.StaticPtr.spInfoUnitId_closure" {
     GHC.StaticPtr.spInfoUnitId_closure:
         const GHC.StaticPtr.spInfoUnitId_info;
 },
 GHC.StaticPtr.spInfoUnitId_entry() //  [R2]
         { info_tbl: [(cfvu8,
                       label: GHC.StaticPtr.spInfoUnitId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvu8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvu9; else goto cfvua;
       cfvu9: // global
           R2 = R2;
           R1 = GHC.StaticPtr.spInfoUnitId_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvua: // global
           I64[Sp - 8] = block_cfvu5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvue; else goto cfvu6;
       ufvue: // global
           call _cfvu5(R1) args: 0, res: 0, upd: 0;
       cfvu6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvu5() //  [R1]
         { info_tbl: [(cfvu5,
                       label: block_cfvu5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvu5: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.96598239 UTC

[section ""data" . GHC.StaticPtr.deRefStaticPtr_closure" {
     GHC.StaticPtr.deRefStaticPtr_closure:
         const GHC.StaticPtr.deRefStaticPtr_info;
 },
 GHC.StaticPtr.deRefStaticPtr_entry() //  [R2]
         { info_tbl: [(cfvum,
                       label: GHC.StaticPtr.deRefStaticPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvum: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvun; else goto cfvuo;
       cfvun: // global
           R2 = R2;
           R1 = GHC.StaticPtr.deRefStaticPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvuo: // global
           I64[Sp - 8] = block_cfvuj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvus; else goto cfvuk;
       ufvus: // global
           call _cfvuj(R1) args: 0, res: 0, upd: 0;
       cfvuk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvuj() //  [R1]
         { info_tbl: [(cfvuj,
                       label: block_cfvuj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvuj: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.967254856 UTC

[section ""data" . GHC.StaticPtr.staticKey_closure" {
     GHC.StaticPtr.staticKey_closure:
         const GHC.StaticPtr.staticKey_info;
 },
 GHC.StaticPtr.staticKey_entry() //  [R2]
         { info_tbl: [(cfvuA,
                       label: GHC.StaticPtr.staticKey_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvuA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvuE; else goto cfvuF;
       cfvuE: // global
           R2 = R2;
           R1 = GHC.StaticPtr.staticKey_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvuF: // global
           I64[Sp - 8] = block_cfvux_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvuJ; else goto cfvuy;
       ufvuJ: // global
           call _cfvux(R1) args: 0, res: 0, upd: 0;
       cfvuy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvux() //  [R1]
         { info_tbl: [(cfvux,
                       label: block_cfvux_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvux: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvuI; else goto cfvuH;
       cfvuI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfvuH: // global
           _sfvnb::I64 = I64[R1 + 23];
           _sfvnc::I64 = I64[R1 + 31];
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = _sfvnb::I64;
           I64[Hp] = _sfvnc::I64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.970173079 UTC

[section ""data" . GHC.StaticPtr.staticPtrInfo_closure" {
     GHC.StaticPtr.staticPtrInfo_closure:
         const GHC.StaticPtr.staticPtrInfo_info;
 },
 GHC.StaticPtr.staticPtrInfo_entry() //  [R2]
         { info_tbl: [(cfvuR,
                       label: GHC.StaticPtr.staticPtrInfo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvuR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvuS; else goto cfvuT;
       cfvuS: // global
           R2 = R2;
           R1 = GHC.StaticPtr.staticPtrInfo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvuT: // global
           I64[Sp - 8] = block_cfvuO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvuX; else goto cfvuP;
       ufvuX: // global
           call _cfvuO(R1) args: 0, res: 0, upd: 0;
       cfvuP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvuO() //  [R1]
         { info_tbl: [(cfvuO,
                       label: block_cfvuO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvuO: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.971126487 UTC

[section ""cstring" . GHC.StaticPtr.$trModule4_bytes" {
     GHC.StaticPtr.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.971661921 UTC

[section ""data" . GHC.StaticPtr.$trModule3_closure" {
     GHC.StaticPtr.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.972223737 UTC

[section ""cstring" . GHC.StaticPtr.$trModule2_bytes" {
     GHC.StaticPtr.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,116,105,99,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.972740509 UTC

[section ""data" . GHC.StaticPtr.$trModule1_closure" {
     GHC.StaticPtr.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.973367034 UTC

[section ""data" . GHC.StaticPtr.$trModule_closure" {
     GHC.StaticPtr.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.StaticPtr.$trModule3_closure+1;
         const GHC.StaticPtr.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.973938038 UTC

[section ""data" . $krep_rfvlo_closure" {
     $krep_rfvlo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.974568267 UTC

[section ""data" . $krep1_rfvlp_closure" {
     $krep1_rfvlp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.975168491 UTC

[section ""data" . $krep2_rfvlq_closure" {
     $krep2_rfvlq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.975762945 UTC

[section ""data" . $krep3_rfvlr_closure" {
     $krep3_rfvlr_closure:
         const :_con_info;
         const $krep1_rfvlp_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.97631061 UTC

[section ""data" . $krep4_rfvls_closure" {
     $krep4_rfvls_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_rfvlr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.976873524 UTC

[section ""data" . $krep5_rfvlt_closure" {
     $krep5_rfvlt_closure:
         const :_con_info;
         const $krep_rfvlo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.977520141 UTC

[section ""data" . $krep6_rfvlu_closure" {
     $krep6_rfvlu_closure:
         const :_con_info;
         const $krep_rfvlo_closure+1;
         const $krep5_rfvlt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.978069035 UTC

[section ""data" . $krep7_rfvlv_closure" {
     $krep7_rfvlv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep6_rfvlu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.978638811 UTC

[section ""data" . GHC.StaticPtr.$tcIsStatic1_closure" {
     GHC.StaticPtr.$tcIsStatic1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep2_rfvlq_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.97923119 UTC

[section ""data" . $krep8_rfvlw_closure" {
     $krep8_rfvlw_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.979831844 UTC

[section ""data" . $krep9_rfvlx_closure" {
     $krep9_rfvlx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.98035534 UTC

[section ""cstring" . GHC.StaticPtr.$tcStaticPtrInfo2_bytes" {
     GHC.StaticPtr.$tcStaticPtrInfo2_bytes:
         I8[] [83,116,97,116,105,99,80,116,114,73,110,102,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.980910687 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtrInfo1_closure" {
     GHC.StaticPtr.$tcStaticPtrInfo1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tcStaticPtrInfo2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.981552719 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtrInfo_closure" {
     GHC.StaticPtr.$tcStaticPtrInfo_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tcStaticPtrInfo1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9809180260958205610;
         const 5820027882667808380;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.982164611 UTC

[section ""data" . $krep10_rfvly_closure" {
     $krep10_rfvly_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.StaticPtr.$tcStaticPtrInfo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.982773088 UTC

[section ""data" . $krep11_rfvlz_closure" {
     $krep11_rfvlz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rfvlv_closure+1;
         const $krep10_rfvly_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.983338651 UTC

[section ""data" . $krep12_rfvlA_closure" {
     $krep12_rfvlA_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rfvls_closure+1;
         const $krep11_rfvlz_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.983931962 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtrInfo1_closure" {
     GHC.StaticPtr.$tc'StaticPtrInfo1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rfvls_closure+1;
         const $krep12_rfvlA_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.984521391 UTC

[section ""cstring" . GHC.StaticPtr.$tc'StaticPtrInfo3_bytes" {
     GHC.StaticPtr.$tc'StaticPtrInfo3_bytes:
         I8[] [39,83,116,97,116,105,99,80,116,114,73,110,102,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.985081638 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtrInfo2_closure" {
     GHC.StaticPtr.$tc'StaticPtrInfo2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tc'StaticPtrInfo3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.985908665 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtrInfo_closure" {
     GHC.StaticPtr.$tc'StaticPtrInfo_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tc'StaticPtrInfo2_closure+1;
         const GHC.StaticPtr.$tc'StaticPtrInfo1_closure+4;
         const 12332739532642204119;
         const 17636067641148941699;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.986514709 UTC

[section ""cstring" . GHC.StaticPtr.$tcStaticPtr2_bytes" {
     GHC.StaticPtr.$tcStaticPtr2_bytes:
         I8[] [83,116,97,116,105,99,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.987042359 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtr1_closure" {
     GHC.StaticPtr.$tcStaticPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tcStaticPtr2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.987636228 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtr_closure" {
     GHC.StaticPtr.$tcStaticPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tcStaticPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 6538784347774135987;
         const 451387415853290179;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.988237561 UTC

[section ""data" . $krep13_rfvlB_closure" {
     $krep13_rfvlB_closure:
         const :_con_info;
         const $krep8_rfvlw_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.988791447 UTC

[section ""data" . $krep14_rfvlC_closure" {
     $krep14_rfvlC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.StaticPtr.$tcStaticPtr_closure+1;
         const $krep13_rfvlB_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.989396124 UTC

[section ""data" . $krep15_rfvlD_closure" {
     $krep15_rfvlD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rfvlw_closure+2;
         const $krep14_rfvlC_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.989982959 UTC

[section ""data" . $krep16_rfvlE_closure" {
     $krep16_rfvlE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rfvly_closure+1;
         const $krep15_rfvlD_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.990542434 UTC

[section ""data" . $krep17_rfvlF_closure" {
     $krep17_rfvlF_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_rfvlx_closure+1;
         const $krep16_rfvlE_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.991148281 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtr1_closure" {
     GHC.StaticPtr.$tc'StaticPtr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_rfvlx_closure+1;
         const $krep17_rfvlF_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.991753029 UTC

[section ""cstring" . GHC.StaticPtr.$tc'StaticPtr3_bytes" {
     GHC.StaticPtr.$tc'StaticPtr3_bytes:
         I8[] [39,83,116,97,116,105,99,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.992308133 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtr2_closure" {
     GHC.StaticPtr.$tc'StaticPtr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tc'StaticPtr3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.99288671 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtr_closure" {
     GHC.StaticPtr.$tc'StaticPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tc'StaticPtr2_closure+1;
         const GHC.StaticPtr.$tc'StaticPtr1_closure+4;
         const 3211798574336347514;
         const 9816765169815661376;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.993539922 UTC

[section ""cstring" . GHC.StaticPtr.$tcIsStatic3_bytes" {
     GHC.StaticPtr.$tcIsStatic3_bytes:
         I8[] [73,115,83,116,97,116,105,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.994106644 UTC

[section ""data" . GHC.StaticPtr.$tcIsStatic2_closure" {
     GHC.StaticPtr.$tcIsStatic2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tcIsStatic3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.994695949 UTC

[section ""data" . GHC.StaticPtr.$tcIsStatic_closure" {
     GHC.StaticPtr.$tcIsStatic_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tcIsStatic2_closure+1;
         const GHC.StaticPtr.$tcIsStatic1_closure+4;
         const 12653381617957437053;
         const 3253287492145771790;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:12.997733939 UTC

[section ""data" . GHC.StaticPtr.$wunsafeLookupStaticPtr_closure" {
     GHC.StaticPtr.$wunsafeLookupStaticPtr_closure:
         const GHC.StaticPtr.$wunsafeLookupStaticPtr_info;
 },
 GHC.StaticPtr.$wunsafeLookupStaticPtr_entry() //  [R2, R3]
         { info_tbl: [(cfvv8,
                       label: GHC.StaticPtr.$wunsafeLookupStaticPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvv8: // global
           _sfvnm::I64 = R3;
           _sfvnl::I64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cfvv9; else goto cfvva;
       cfvva: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cfvvc; else goto cfvvb;
       cfvvc: // global
           HpAlloc = 80;
           goto cfvv9;
       cfvv9: // global
           R3 = _sfvnm::I64;
           R2 = _sfvnl::I64;
           R1 = GHC.StaticPtr.$wunsafeLookupStaticPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfvvb: // global
           I64[Hp - 72] = GHC.Word.W64#_con_info;
           I64[Hp - 64] = _sfvnl::I64;
           I64[Hp - 56] = GHC.Word.W64#_con_info;
           I64[Hp - 48] = _sfvnm::I64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 55;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 38;
           I64[Sp - 16] = block_cfvv6_info;
           R3 = 0;
           _cfvv5::P64 = Hp - 14;
           R2 = _cfvv5::P64;
           P64[Sp - 8] = _cfvv5::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfvv6() //  [R1]
         { info_tbl: [(cfvv6,
                       label: block_cfvv6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvv6: // global
           I64[Sp] = block_cfvvj_info;
           R2 = 8;
           R1 = R1 << 3;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvvj() //  [R1]
         { info_tbl: [(cfvvj,
                       label: block_cfvvj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvvj: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _cfvvJ() args: 0, res: 0, upd: 0;
     }
 },
 _cfvvJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvvJ: // global
           _sfvnN::P64 = P64[Sp];
           I64[Sp] = block_cfvvM_info;
           R1 = _sfvnN::P64;
           if (R1 & 7 != 0) goto ufvwb; else goto cfvvO;
       ufvwb: // global
           call _cfvvM(R1) args: 0, res: 0, upd: 0;
       cfvvO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvvM() //  [R1]
         { info_tbl: [(cfvvM,
                       label: block_cfvvM_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvvM: // global
           if (R1 & 7 == 1) goto ufvw8; else goto cfvvZ;
       ufvw8: // global
           Sp = Sp + 8;
           call _cfvvs() args: 0, res: 0, upd: 0;
       cfvvZ: // global
           I64[Sp - 8] = block_cfvvX_info;
           _sfvnS::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sfvnS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvwc; else goto cfvw0;
       ufvwc: // global
           call _cfvvX(R1) args: 0, res: 0, upd: 0;
       cfvw0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvvs() //  []
         { info_tbl: [(cfvvs,
                       label: block_cfvvs_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvvs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfvvw; else goto cfvvv;
       cfvvw: // global
           HpAlloc = 16;
           I64[Sp] = block_cfvvs_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfvvv: // global
           _sfvnz::P64 = P64[Sp + 16];
           (_sfvnG::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] hs_spt_lookup(I64[Sp + 8]);
           call MO_Touch(_sfvnz::P64);
           if (_sfvnG::I64 == 0) goto cfvvG; else goto cfvvF;
       cfvvG: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfvvF: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           I64[Hp] = _sfvnG::I64;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfvvX() //  [R1]
         { info_tbl: [(cfvvX,
                       label: block_cfvvX_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvvX: // global
           _sfvnO::I64 = I64[Sp + 16];
           _sfvnS::P64 = P64[Sp + 8];
           I64[I64[Sp + 24] + (_sfvnO::I64 << 3)] = I64[R1 + 7];
           P64[Sp + 8] = _sfvnS::P64;
           I64[Sp + 16] = _sfvnO::I64 + 1;
           Sp = Sp + 8;
           call _cfvvJ() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.000276258 UTC

[section ""data" . GHC.StaticPtr.unsafeLookupStaticPtr1_closure" {
     GHC.StaticPtr.unsafeLookupStaticPtr1_closure:
         const GHC.StaticPtr.unsafeLookupStaticPtr1_info;
 },
 GHC.StaticPtr.unsafeLookupStaticPtr1_entry() //  [R2]
         { info_tbl: [(cfvwm,
                       label: GHC.StaticPtr.unsafeLookupStaticPtr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvwm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvwn; else goto cfvwo;
       cfvwn: // global
           R2 = R2;
           R1 = GHC.StaticPtr.unsafeLookupStaticPtr1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvwo: // global
           I64[Sp - 8] = block_cfvwj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvws; else goto cfvwk;
       ufvws: // global
           call _cfvwj(R1) args: 0, res: 0, upd: 0;
       cfvwk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvwj() //  [R1]
         { info_tbl: [(cfvwj,
                       label: block_cfvwj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvwj: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.StaticPtr.$wunsafeLookupStaticPtr_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.001888014 UTC

[section ""data" . GHC.StaticPtr.unsafeLookupStaticPtr_closure" {
     GHC.StaticPtr.unsafeLookupStaticPtr_closure:
         const GHC.StaticPtr.unsafeLookupStaticPtr_info;
 },
 GHC.StaticPtr.unsafeLookupStaticPtr_entry() //  [R2]
         { info_tbl: [(cfvwx,
                       label: GHC.StaticPtr.unsafeLookupStaticPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvwx: // global
           R2 = R2;
           call GHC.StaticPtr.unsafeLookupStaticPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.002579204 UTC

[section ""cstring" . lvl_rfvlG_bytes" {
     lvl_rfvlG_bytes:
         I8[] [71,72,67,47,83,116,97,116,105,99,80,116,114,46,104,115,58,49,51,49,58,52,49,45,55,57,124,108,97,109,98,100,97]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.003318904 UTC

[section ""data" . lvl1_rfvlH_closure" {
     lvl1_rfvlH_closure:
         const lvl1_rfvlH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rfvlH_entry() //  [R1]
         { info_tbl: [(cfvwG,
                       label: lvl1_rfvlH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvwG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvwH; else goto cfvwI;
       cfvwH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvwI: // global
           (_cfvwD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfvwD::I64 == 0) goto cfvwF; else goto cfvwE;
       cfvwF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfvwE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfvwD::I64;
           R2 = lvl_rfvlG_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.005702399 UTC

[section ""data" . GHC.StaticPtr.staticPtrKeys2_closure" {
     GHC.StaticPtr.staticPtrKeys2_closure:
         const GHC.StaticPtr.staticPtrKeys2_info;
         const 0;
 },
 sat_sfvop_entry() //  [R1]
         { info_tbl: [(cfvxB,
                       label: sat_sfvop_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvxB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfvxF; else goto cfvxG;
       cfvxF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvxG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cfvxy_info;
           _sfvoe::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sfvoe::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufvxK; else goto cfvxz;
       ufvxK: // global
           call _cfvxy(R1) args: 0, res: 0, upd: 0;
       cfvxz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfvxy() //  [R1]
         { info_tbl: [(cfvxy,
                       label: block_cfvxy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvxy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvxJ; else goto cfvxI;
       cfvxJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cfvxI: // global
           _sfvoo::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _sfvoo::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.StaticPtr.staticPtrKeys2_entry() //  [R2]
         { info_tbl: [(cfvxP,
                       label: GHC.StaticPtr.staticPtrKeys2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvxP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfvxQ; else goto cfvxR;
       cfvxQ: // global
           R2 = R2;
           R1 = GHC.StaticPtr.staticPtrKeys2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvxR: // global
           I64[Sp - 8] = block_cfvwN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvyA; else goto cfvwO;
       ufvyA: // global
           call _cfvwN(R1) args: 0, res: 0, upd: 0;
       cfvwO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvwN() //  [R1]
         { info_tbl: [(cfvwN,
                       label: block_cfvwN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvwN: // global
           if (R1 & 7 == 1) goto cfvxM; else goto cfvxN;
       cfvxM: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfvxN: // global
           P64[Sp - 24] = P64[R1 + 14];
           I64[Sp - 16] = 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 24;
           call _cfvwX() args: 0, res: 0, upd: 0;
     }
 },
 _cfvwX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvwX: // global
           _sfvo5::P64 = P64[Sp + 24];
           _sfvoy::I64 = I64[Sp + 8];
           if (_sfvoy::I64 != 0) goto cfvyg; else goto cfvyk;
       cfvyg: // global
           I64[Sp - 8] = block_cfvx2_info;
           R1 = _sfvo5::P64;
           I64[Sp + 8] = _sfvoy::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvyt; else goto cfvx3;
       ufvyt: // global
           call _cfvx2(R1) args: 0, res: 0, upd: 0;
       cfvx3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfvyk: // global
           I64[Sp - 8] = block_cfvxc_info;
           R1 = _sfvo5::P64;
           P64[Sp + 24] = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvyu; else goto cfvxd;
       ufvyu: // global
           call _cfvxc(R1) args: 0, res: 0, upd: 0;
       cfvxd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvx2() //  [R1]
         { info_tbl: [(cfvx2,
                       label: block_cfvx2_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvx2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfvyj; else goto cfvyi;
       cfvyj: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfvyi: // global
           _sfvoy::I64 = I64[Sp + 16];
           _sfvoD::I64 = I64[I64[R1 + 7] + (_sfvoy::I64 << 3)];
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = _sfvoD::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 16] = _sfvoy::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           Sp = Sp + 8;
           call _cfvwX() args: 0, res: 0, upd: 0;
     }
 },
 _cfvxc() //  [R1]
         { info_tbl: [(cfvxc,
                       label: block_cfvxc_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvxc: // global
           _sfvoe::I64 = I64[I64[R1 + 7]];
           I64[Sp] = block_cfvxh_info;
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sfvoe::I64;
           if (R1 & 7 != 0) goto ufvyw; else goto cfvxi;
       ufvyw: // global
           call _cfvxh(R1) args: 0, res: 0, upd: 0;
       cfvxi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvxh() //  [R1]
         { info_tbl: [(cfvxh,
                       label: block_cfvxh_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvxh: // global
           if (R1 & 7 == 1) goto ufvyq; else goto cfvy2;
       ufvyq: // global
           Sp = Sp + 40;
           call _cfvyd() args: 0, res: 0, upd: 0;
       cfvy2: // global
           I64[Sp] = block_cfvxn_info;
           _sfvoh::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp + 24] = _sfvoh::P64;
           if (R1 & 7 != 0) goto ufvyx; else goto cfvxo;
       ufvyx: // global
           call _cfvxn(R1) args: 0, res: 0, upd: 0;
       cfvxo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvxn() //  [R1]
         { info_tbl: [(cfvxn,
                       label: block_cfvxn_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvxn: // global
           if (R1 & 7 == 1) goto cfvy6; else goto ufvyr;
       cfvy6: // global
           I64[Sp + 16] = block_cfvxs_info;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.StaticPtr.staticPtrKeys2_entry(R2) args: 8, res: 8, upd: 8;
       ufvyr: // global
           Sp = Sp + 40;
           call _cfvyd() args: 0, res: 0, upd: 0;
     }
 },
 _cfvxs() //  [R1]
         { info_tbl: [(cfvxs,
                       label: block_cfvxs_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvxs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfvy9; else goto cfvy8;
       cfvy9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfvy8: // global
           I64[Hp - 48] = sat_sfvop_info;
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfvyd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvyd: // global
           R1 = lvl1_rfvlH_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.010318772 UTC

[section ""data" . GHC.StaticPtr.staticPtrKeys1_closure" {
     GHC.StaticPtr.staticPtrKeys1_closure:
         const GHC.StaticPtr.staticPtrKeys1_info;
         const 0;
 },
 GHC.StaticPtr.staticPtrKeys1_entry() //  []
         { info_tbl: [(cfvze,
                       label: GHC.StaticPtr.staticPtrKeys1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvze: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfvzf; else goto cfvzg;
       cfvzf: // global
           R1 = GHC.StaticPtr.staticPtrKeys1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cfvzg: // global
           (_sfvoL::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] hs_spt_key_count();
           I64[Sp - 16] = block_cfvyM_info;
           R2 = 8;
           _sfvoM::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sfvoL::I64));
           R1 = _sfvoM::I64 << 3;
           I64[Sp - 8] = _sfvoM::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvyM() //  [R1]
         { info_tbl: [(cfvyM,
                       label: block_cfvyM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvyM: // global
           _sfvoU::I64 = R1 + 16;
           (_sfvoY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     ‘signed’]  result hints:  [‘signed’] hs_spt_keys(_sfvoU::I64, I64[Sp + 8]);
           _sfvoZ::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sfvoY::I64));
           if (%MO_S_Gt_W64(_sfvoZ::I64, 0)) goto cfvzA; else goto cfvzD;
       cfvzA: // global
           I64[Sp - 16] = _sfvoZ::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = _sfvoU::I64;
           P64[Sp + 8] = R1;
           Sp = Sp - 24;
           call _cfvz7() args: 0, res: 0, upd: 0;
       cfvzD: // global
           I64[Sp] = block_cfvzC_info;
           R2 = GHC.Types.[]_closure+1;
           P64[Sp + 8] = R1;
           call GHC.StaticPtr.staticPtrKeys2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfvz7() //  []
         { info_tbl: [(cfvz7,
                       label: block_cfvz7_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvz7: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfvzv; else goto cfvzu;
       cfvzv: // global
           HpAlloc = 40;
           I64[Sp] = block_cfvz7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfvzu: // global
           _sfvpf::P64 = P64[Sp + 16];
           _sfvph::I64 = I64[Sp + 8];
           if (_sfvph::I64 != 0) goto cfvzx; else goto cfvzy;
       cfvzx: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 24] + (_sfvph::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sfvpf::P64;
           I64[Sp + 8] = _sfvph::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _cfvz7() args: 0, res: 0, upd: 0;
       cfvzy: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _sfvpf::P64;
           Sp = Sp + 16;
           call _cfvzj() args: 0, res: 0, upd: 0;
     }
 },
 _cfvzj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvzj: // global
           Hp = Hp + 40;
           _sfvp2::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cfvzq; else goto cfvzp;
       cfvzq: // global
           HpAlloc = 40;
           I64[Sp] = block_cfvzi_info;
           R1 = _sfvp2::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfvzp: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 8]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sfvp2::P64;
           I64[Sp + 8] = block_cfvzn_info;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.StaticPtr.staticPtrKeys2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfvzi() //  [R1]
         { info_tbl: [(cfvzi,
                       label: block_cfvzi_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvzi: // global
           P64[Sp] = R1;
           call _cfvzj() args: 0, res: 0, upd: 0;
     }
 },
 _cfvzn() //  [R1]
         { info_tbl: [(cfvzn,
                       label: block_cfvzn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvzn: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfvzC() //  [R1]
         { info_tbl: [(cfvzC,
                       label: block_cfvzC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvzC: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.012608111 UTC

[section ""data" . GHC.StaticPtr.staticPtrKeys_closure" {
     GHC.StaticPtr.staticPtrKeys_closure:
         const GHC.StaticPtr.staticPtrKeys_info;
         const 0;
 },
 GHC.StaticPtr.staticPtrKeys_entry() //  []
         { info_tbl: [(cfvzV,
                       label: GHC.StaticPtr.staticPtrKeys_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvzV: // global
           call GHC.StaticPtr.staticPtrKeys1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.013661147 UTC

[section ""data" . GHC.StaticPtr.StaticPtr_closure" {
     GHC.StaticPtr.StaticPtr_closure:
         const GHC.StaticPtr.StaticPtr_info;
 },
 GHC.StaticPtr.StaticPtr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvzZ: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.StaticPtr.StaticPtr_entry(R5,
                                              R4,
                                              R3,
                                              R2,
                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.StaticPtr.StaticPtr_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfvA4,
                       label: GHC.StaticPtr.StaticPtr_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvA4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfvA8; else goto cfvA7;
       cfvA8: // global
           HpAlloc = 40;
           R1 = GHC.StaticPtr.StaticPtr_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cfvA7: // global
           I64[Hp - 32] = GHC.StaticPtr.StaticPtr_con_info;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.014886946 UTC

[section ""data" . GHC.StaticPtr.StaticPtrInfo_closure" {
     GHC.StaticPtr.StaticPtrInfo_closure:
         const GHC.StaticPtr.StaticPtrInfo_info;
 },
 GHC.StaticPtr.StaticPtrInfo_entry() //  [R2, R3, R4]
         { info_tbl: [(cfvAe,
                       label: GHC.StaticPtr.StaticPtrInfo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvAe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfvAi; else goto cfvAh;
       cfvAi: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.StaticPtrInfo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfvAh: // global
           I64[Hp - 24] = GHC.StaticPtr.StaticPtrInfo_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.015814724 UTC

[GHC.StaticPtr.StaticPtr_con_entry() //  [R1]
         { info_tbl: [(cfvAj,
                       label: GHC.StaticPtr.StaticPtr_con_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,105,99,80,116,114,46,83,116,97,116,105,99,80,116,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvAj: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.01653319 UTC

[GHC.StaticPtr.StaticPtrInfo_con_entry() //  [R1]
         { info_tbl: [(cfvAk,
                       label: GHC.StaticPtr.StaticPtrInfo_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,105,99,80,116,114,46,83,116,97,116,105,99,80,116,114,73,110,102,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvAk: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.017194204 UTC

[section ""relreadonly" . SfvsE_srt" {
     SfvsE_srt:
         const GHC.Show.$fShow(,)_go1_closure;
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Show.showLitString_closure;
         const GHC.StaticPtr.$w$cshowsPrec_closure;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure;
         const GHC.StaticPtr.$fShowStaticPtrInfo1_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.StaticPtr.staticPtrKeys2_closure;
         const lvl1_rfvlH_closure;
         const GHC.StaticPtr.staticPtrKeys1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.017840127 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:13.01852782 UTC

[section ""data" . GHC.StaticPtr.fromStaticPtr_closure" {
     GHC.StaticPtr.fromStaticPtr_closure:
         const GHC.StaticPtr.fromStaticPtr_info;
 },
 GHC.StaticPtr.fromStaticPtr_entry() //  [R2]
         { info_tbl: [(cfvAp,
                       label: GHC.StaticPtr.fromStaticPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvAp: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.019318423 UTC

[section ""data" . GHC.StaticPtr.$fIsStaticStaticPtr_closure" {
     GHC.StaticPtr.$fIsStaticStaticPtr_closure:
         const GHC.StaticPtr.$fIsStaticStaticPtr_info;
 },
 GHC.StaticPtr.$fIsStaticStaticPtr_entry() //  [R2]
         { info_tbl: [(cfvAw,
                       label: GHC.StaticPtr.$fIsStaticStaticPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvAw: // global
           R2 = R2;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.01999408 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo6_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo6_bytes:
         I8[] [83,116,97,116,105,99,80,116,114,73,110,102,111,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.020528127 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo5_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo5_bytes:
         I8[] [115,112,73,110,102,111,85,110,105,116,73,100,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.021062198 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo4_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo4_bytes:
         I8[] [115,112,73,110,102,111,77,111,100,117,108,101,78,97,109,101,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.021645324 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo3_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo3_bytes:
         I8[] [115,112,73,110,102,111,83,114,99,76,111,99,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.022186922 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo2_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo2_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.025833473 UTC

[section ""data" . GHC.StaticPtr.$w$cshowsPrec_closure" {
     GHC.StaticPtr.$w$cshowsPrec_closure:
         const GHC.StaticPtr.$w$cshowsPrec_info;
         const 0;
 },
 GHC.StaticPtr.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvAA: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvma_entry() //  [R1]
         { info_tbl: [(cfvBs,
                       label: sat_sfvma_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvBs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvBt; else goto cfvBu;
       cfvBt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvBu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvm7_entry() //  [R1, R2]
         { info_tbl: [(cfvBE,
                       label: sat_sfvm7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvBE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvBK; else goto cfvBL;
       cfvBK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvBL: // global
           I64[Sp - 16] = block_cfvBB_info;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufvBQ; else goto cfvBC;
       ufvBQ: // global
           call _cfvBB(R1) args: 0, res: 0, upd: 0;
       cfvBC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvBB() //  [R1]
         { info_tbl: [(cfvBB,
                       label: block_cfvBB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvBB: // global
           _sfvm1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cfvBH_info;
           R4 = _sfvm1::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfvBH() //  [R1, R2]
         { info_tbl: [(cfvBH,
                       label: block_cfvBH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvBH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvBP; else goto cfvBO;
       cfvBP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cfvBO: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvm0_entry() //  [R1, R2]
         { info_tbl: [(cfvC0,
                       label: sat_sfvm0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvC0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvC6; else goto cfvC7;
       cfvC6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvC7: // global
           I64[Sp - 16] = block_cfvBX_info;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufvCc; else goto cfvBY;
       ufvCc: // global
           call _cfvBX(R1) args: 0, res: 0, upd: 0;
       cfvBY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvBX() //  [R1]
         { info_tbl: [(cfvBX,
                       label: block_cfvBX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvBX: // global
           _sfvlU::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cfvC3_info;
           R4 = _sfvlU::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfvC3() //  [R1, R2]
         { info_tbl: [(cfvC3,
                       label: block_cfvC3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvC3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvCb; else goto cfvCa;
       cfvCb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cfvCa: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvmc_entry() //  [R1]
         { info_tbl: [(cfvCe,
                       label: sat_sfvmc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvCe: // global
           _sfvmc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvCf; else goto cfvCg;
       cfvCg: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cfvCi; else goto cfvCh;
       cfvCi: // global
           HpAlloc = 128;
           goto cfvCf;
       cfvCf: // global
           R1 = _sfvmc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvCh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmc::P64;
           _sfvlQ::P64 = P64[_sfvmc::P64 + 16];
           _sfvlS::P64 = P64[_sfvmc::P64 + 24];
           _sfvlT::P64 = P64[_sfvmc::P64 + 32];
           I64[Hp - 120] = sat_sfvma_info;
           P64[Hp - 104] = _sfvlQ::P64;
           I64[Hp - 96] = :_con_info;
           P64[Hp - 88] = GHC.Show.$fShow(,)2_closure;
           P64[Hp - 80] = Hp - 120;
           I64[Hp - 72] = sat_sfvm7_info;
           P64[Hp - 64] = _sfvlT::P64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           I64[Hp - 32] = sat_sfvm0_info;
           P64[Hp - 24] = _sfvlS::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 54;
           R3 = Hp - 94;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Show.$fShow(,)_go1_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmd_entry() //  [R1]
         { info_tbl: [(cfvCj,
                       label: sat_sfvmd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvCj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfvCl; else goto cfvCm;
       cfvCl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvCm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cfvBf_info;
           _sfvlQ::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sfvlQ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufvCq; else goto cfvBg;
       ufvCq: // global
           call _cfvBf(R1) args: 0, res: 0, upd: 0;
       cfvBg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfvBf() //  [R1]
         { info_tbl: [(cfvBf,
                       label: block_cfvBf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvBf: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfvCp; else goto cfvCo;
       cfvCp: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cfvCo: // global
           _sfvlS::P64 = P64[R1 + 7];
           _sfvlT::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sfvmc_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sfvlS::P64;
           P64[Hp - 24] = _sfvlT::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvme_entry() //  [R1]
         { info_tbl: [(cfvCr,
                       label: sat_sfvme_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvCr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfvCv; else goto cfvCu;
       cfvCv: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvCu: // global
           _sfvlN::P64 = P64[R1 + 16];
           _sfvlQ::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sfvmd_info;
           P64[Hp - 8] = _sfvlN::P64;
           P64[Hp] = _sfvlQ::P64;
           R3 = Hp - 24;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvmf_entry() //  [R1]
         { info_tbl: [(cfvCw,
                       label: sat_sfvmf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvCw: // global
           _sfvmf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvCx; else goto cfvCy;
       cfvCy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfvCA; else goto cfvCz;
       cfvCA: // global
           HpAlloc = 32;
           goto cfvCx;
       cfvCx: // global
           R1 = _sfvmf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvCz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmf::P64;
           _sfvlN::P64 = P64[_sfvmf::P64 + 16];
           _sfvlQ::P64 = P64[_sfvmf::P64 + 24];
           I64[Hp - 24] = sat_sfvme_info;
           P64[Hp - 8] = _sfvlN::P64;
           P64[Hp] = _sfvlQ::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmh_entry() //  [R1]
         { info_tbl: [(cfvCC,
                       label: sat_sfvmh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvCC: // global
           _sfvmh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvCD; else goto cfvCE;
       cfvCE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfvCG; else goto cfvCF;
       cfvCG: // global
           HpAlloc = 56;
           goto cfvCD;
       cfvCD: // global
           R1 = _sfvmh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvCF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmh::P64;
           _sfvlM::P64 = P64[_sfvmh::P64 + 16];
           _sfvlN::P64 = P64[_sfvmh::P64 + 24];
           _sfvlQ::P64 = P64[_sfvmh::P64 + 32];
           I64[Hp - 48] = sat_sfvmf_info;
           P64[Hp - 32] = _sfvlN::P64;
           P64[Hp - 24] = _sfvlQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sfvlM::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmj_entry() //  [R1]
         { info_tbl: [(cfvCI,
                       label: sat_sfvmj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvCI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfvCM; else goto cfvCL;
       cfvCM: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvCL: // global
           _sfvlM::P64 = P64[R1 + 16];
           _sfvlN::P64 = P64[R1 + 24];
           _sfvlQ::P64 = P64[R1 + 32];
           I64[Hp - 56] = sat_sfvmh_info;
           P64[Hp - 40] = _sfvlM::P64;
           P64[Hp - 32] = _sfvlN::P64;
           P64[Hp - 24] = _sfvlQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvmk_entry() //  [R1]
         { info_tbl: [(cfvCN,
                       label: sat_sfvmk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvCN: // global
           _sfvmk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvCO; else goto cfvCP;
       cfvCP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfvCR; else goto cfvCQ;
       cfvCR: // global
           HpAlloc = 40;
           goto cfvCO;
       cfvCO: // global
           R1 = _sfvmk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvCQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmk::P64;
           _sfvlM::P64 = P64[_sfvmk::P64 + 16];
           _sfvlN::P64 = P64[_sfvmk::P64 + 24];
           _sfvlQ::P64 = P64[_sfvmk::P64 + 32];
           I64[Hp - 32] = sat_sfvmj_info;
           P64[Hp - 16] = _sfvlM::P64;
           P64[Hp - 8] = _sfvlN::P64;
           P64[Hp] = _sfvlQ::P64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmm_entry() //  [R1]
         { info_tbl: [(cfvCT,
                       label: sat_sfvmm_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvCT: // global
           _sfvmm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvCU; else goto cfvCV;
       cfvCV: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfvCX; else goto cfvCW;
       cfvCX: // global
           HpAlloc = 64;
           goto cfvCU;
       cfvCU: // global
           R1 = _sfvmm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvCW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmm::P64;
           _sfvlL::P64 = P64[_sfvmm::P64 + 16];
           _sfvlM::P64 = P64[_sfvmm::P64 + 24];
           _sfvlN::P64 = P64[_sfvmm::P64 + 32];
           _sfvlQ::P64 = P64[_sfvmm::P64 + 40];
           I64[Hp - 56] = sat_sfvmk_info;
           P64[Hp - 40] = _sfvlM::P64;
           P64[Hp - 32] = _sfvlN::P64;
           P64[Hp - 24] = _sfvlQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sfvlL::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmo_entry() //  [R1]
         { info_tbl: [(cfvCZ,
                       label: sat_sfvmo_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvCZ: // global
           _sfvmo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvD0; else goto cfvD1;
       cfvD1: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfvD3; else goto cfvD2;
       cfvD3: // global
           HpAlloc = 72;
           goto cfvD0;
       cfvD0: // global
           R1 = _sfvmo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvD2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmo::P64;
           _sfvlL::P64 = P64[_sfvmo::P64 + 16];
           _sfvlM::P64 = P64[_sfvmo::P64 + 24];
           _sfvlN::P64 = P64[_sfvmo::P64 + 32];
           _sfvlQ::P64 = P64[_sfvmo::P64 + 40];
           I64[Hp - 64] = sat_sfvmm_info;
           P64[Hp - 48] = _sfvlL::P64;
           P64[Hp - 40] = _sfvlM::P64;
           P64[Hp - 32] = _sfvlN::P64;
           P64[Hp - 24] = _sfvlQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_sfvlP_entry() //  [R1, R2]
         { info_tbl: [(cfvD4,
                       label: p_sfvlP_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvD4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfvD8; else goto cfvD7;
       cfvD8: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvD7: // global
           _sfvlL::P64 = P64[R1 + 7];
           _sfvlM::P64 = P64[R1 + 15];
           _sfvlN::P64 = P64[R1 + 23];
           I64[Hp - 40] = sat_sfvmo_info;
           P64[Hp - 24] = _sfvlL::P64;
           P64[Hp - 16] = _sfvlM::P64;
           P64[Hp - 8] = _sfvlN::P64;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo6_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvmr_entry() //  [R1]
         { info_tbl: [(cfvDi,
                       label: sat_sfvmr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvDi: // global
           _sfvmr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvDj; else goto cfvDk;
       cfvDk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvDm; else goto cfvDl;
       cfvDm: // global
           HpAlloc = 24;
           goto cfvDj;
       cfvDj: // global
           R1 = _sfvmr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvDl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmr::P64;
           _sfvlO::P64 = P64[_sfvmr::P64 + 16];
           _sfvlP::P64 = P64[_sfvmr::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sfvlO::P64;
           R2 = Hp - 14;
           R1 = _sfvlP::P64;
           Sp = Sp - 16;
           call p_sfvlP_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.StaticPtr.$w$cshowsPrec_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfvDq,
                       label: GHC.StaticPtr.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [True, False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvDq: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cfvDu; else goto cfvDt;
       cfvDu: // global
           HpAlloc = 88;
           R1 = GHC.StaticPtr.$w$cshowsPrec_closure;
           I64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cfvDt: // global
           I64[Hp - 80] = p_sfvlP_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           _cfvAE::P64 = Hp - 79;
           if (%MO_S_Lt_W64(R2, 11)) goto cfvDo; else goto cfvDp;
       cfvDo: // global
           Hp = Hp - 56;
           R2 = R6;
           R1 = _cfvAE::P64;
           call p_sfvlP_entry(R2, R1) args: 8, res: 0, upd: 8;
       cfvDp: // global
           I64[Hp - 48] = sat_sfvmr_info;
           P64[Hp - 32] = R6;
           P64[Hp - 24] = _cfvAE::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.03604497 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cfvDD,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvDD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfvDH; else goto cfvDI;
       cfvDH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfvDI: // global
           I64[Sp - 24] = block_cfvDA_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufvDQ; else goto cfvDB;
       ufvDQ: // global
           call _cfvDA(R1) args: 0, res: 0, upd: 0;
       cfvDB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvDA() //  [R1]
         { info_tbl: [(cfvDA,
                       label: block_cfvDA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvDA: // global
           I64[Sp] = block_cfvDG_info;
           _sfvmw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sfvmw::I64;
           if (R1 & 7 != 0) goto ufvDP; else goto cfvDK;
       ufvDP: // global
           call _cfvDG(R1) args: 0, res: 0, upd: 0;
       cfvDK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvDG() //  [R1]
         { info_tbl: [(cfvDG,
                       label: block_cfvDG_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvDG: // global
           R6 = P64[Sp + 16];
           R5 = P64[R1 + 23];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.041111413 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo7_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo7_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.042638978 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_entry() //  [R2]
         { info_tbl: [(cfvDY,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvDY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvDZ; else goto cfvE0;
       cfvDZ: // global
           R2 = R2;
           R1 = GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvE0: // global
           I64[Sp - 8] = block_cfvDV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvE4; else goto cfvDW;
       ufvE4: // global
           call _cfvDV(R1) args: 0, res: 0, upd: 0;
       cfvDW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvDV() //  [R1]
         { info_tbl: [(cfvDV,
                       label: block_cfvDV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvDV: // global
           R6 = GHC.Types.[]_closure+1;
           R5 = P64[R1 + 23];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.045129925 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo1_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo1_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo1_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo1_entry() //  [R2, R3]
         { info_tbl: [(cfvEc,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvEc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvEd; else goto cfvEe;
       cfvEd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.$fShowStaticPtrInfo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfvEe: // global
           I64[Sp - 16] = block_cfvE9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufvEi; else goto cfvEa;
       ufvEi: // global
           call _cfvE9(R1) args: 0, res: 0, upd: 0;
       cfvEa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvE9() //  [R1]
         { info_tbl: [(cfvE9,
                       label: block_cfvE9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvE9: // global
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 23];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.047388785 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cfvEn,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvEn: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.048775192 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure+3;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure+1;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.050238254 UTC

[section ""data" . GHC.StaticPtr.spInfoSrcLoc_closure" {
     GHC.StaticPtr.spInfoSrcLoc_closure:
         const GHC.StaticPtr.spInfoSrcLoc_info;
 },
 GHC.StaticPtr.spInfoSrcLoc_entry() //  [R2]
         { info_tbl: [(cfvEx,
                       label: GHC.StaticPtr.spInfoSrcLoc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvEx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvEy; else goto cfvEz;
       cfvEy: // global
           R2 = R2;
           R1 = GHC.StaticPtr.spInfoSrcLoc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvEz: // global
           I64[Sp - 8] = block_cfvEu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvED; else goto cfvEv;
       ufvED: // global
           call _cfvEu(R1) args: 0, res: 0, upd: 0;
       cfvEv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvEu() //  [R1]
         { info_tbl: [(cfvEu,
                       label: block_cfvEu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvEu: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.052185198 UTC

[section ""data" . GHC.StaticPtr.spInfoModuleName_closure" {
     GHC.StaticPtr.spInfoModuleName_closure:
         const GHC.StaticPtr.spInfoModuleName_info;
 },
 GHC.StaticPtr.spInfoModuleName_entry() //  [R2]
         { info_tbl: [(cfvEL,
                       label: GHC.StaticPtr.spInfoModuleName_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvEL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvEM; else goto cfvEN;
       cfvEM: // global
           R2 = R2;
           R1 = GHC.StaticPtr.spInfoModuleName_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvEN: // global
           I64[Sp - 8] = block_cfvEI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvER; else goto cfvEJ;
       ufvER: // global
           call _cfvEI(R1) args: 0, res: 0, upd: 0;
       cfvEJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvEI() //  [R1]
         { info_tbl: [(cfvEI,
                       label: block_cfvEI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvEI: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.05478497 UTC

[section ""data" . GHC.StaticPtr.spInfoUnitId_closure" {
     GHC.StaticPtr.spInfoUnitId_closure:
         const GHC.StaticPtr.spInfoUnitId_info;
 },
 GHC.StaticPtr.spInfoUnitId_entry() //  [R2]
         { info_tbl: [(cfvEZ,
                       label: GHC.StaticPtr.spInfoUnitId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvEZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvF0; else goto cfvF1;
       cfvF0: // global
           R2 = R2;
           R1 = GHC.StaticPtr.spInfoUnitId_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvF1: // global
           I64[Sp - 8] = block_cfvEW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvF5; else goto cfvEX;
       ufvF5: // global
           call _cfvEW(R1) args: 0, res: 0, upd: 0;
       cfvEX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvEW() //  [R1]
         { info_tbl: [(cfvEW,
                       label: block_cfvEW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvEW: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.056602348 UTC

[section ""data" . GHC.StaticPtr.deRefStaticPtr_closure" {
     GHC.StaticPtr.deRefStaticPtr_closure:
         const GHC.StaticPtr.deRefStaticPtr_info;
 },
 GHC.StaticPtr.deRefStaticPtr_entry() //  [R2]
         { info_tbl: [(cfvFd,
                       label: GHC.StaticPtr.deRefStaticPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvFd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvFe; else goto cfvFf;
       cfvFe: // global
           R2 = R2;
           R1 = GHC.StaticPtr.deRefStaticPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvFf: // global
           I64[Sp - 8] = block_cfvFa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvFj; else goto cfvFb;
       ufvFj: // global
           call _cfvFa(R1) args: 0, res: 0, upd: 0;
       cfvFb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvFa() //  [R1]
         { info_tbl: [(cfvFa,
                       label: block_cfvFa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvFa: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.058190605 UTC

[section ""data" . GHC.StaticPtr.staticKey_closure" {
     GHC.StaticPtr.staticKey_closure:
         const GHC.StaticPtr.staticKey_info;
 },
 GHC.StaticPtr.staticKey_entry() //  [R2]
         { info_tbl: [(cfvFr,
                       label: GHC.StaticPtr.staticKey_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvFr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvFv; else goto cfvFw;
       cfvFv: // global
           R2 = R2;
           R1 = GHC.StaticPtr.staticKey_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvFw: // global
           I64[Sp - 8] = block_cfvFo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvFA; else goto cfvFp;
       ufvFA: // global
           call _cfvFo(R1) args: 0, res: 0, upd: 0;
       cfvFp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvFo() //  [R1]
         { info_tbl: [(cfvFo,
                       label: block_cfvFo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvFo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvFz; else goto cfvFy;
       cfvFz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfvFy: // global
           _sfvnb::I64 = I64[R1 + 23];
           _sfvnc::I64 = I64[R1 + 31];
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = _sfvnb::I64;
           I64[Hp] = _sfvnc::I64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.059822587 UTC

[section ""data" . GHC.StaticPtr.staticPtrInfo_closure" {
     GHC.StaticPtr.staticPtrInfo_closure:
         const GHC.StaticPtr.staticPtrInfo_info;
 },
 GHC.StaticPtr.staticPtrInfo_entry() //  [R2]
         { info_tbl: [(cfvFI,
                       label: GHC.StaticPtr.staticPtrInfo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvFI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvFJ; else goto cfvFK;
       cfvFJ: // global
           R2 = R2;
           R1 = GHC.StaticPtr.staticPtrInfo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvFK: // global
           I64[Sp - 8] = block_cfvFF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvFO; else goto cfvFG;
       ufvFO: // global
           call _cfvFF(R1) args: 0, res: 0, upd: 0;
       cfvFG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvFF() //  [R1]
         { info_tbl: [(cfvFF,
                       label: block_cfvFF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvFF: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.061103954 UTC

[section ""cstring" . GHC.StaticPtr.$trModule4_bytes" {
     GHC.StaticPtr.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.061905995 UTC

[section ""data" . GHC.StaticPtr.$trModule3_closure" {
     GHC.StaticPtr.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.062666365 UTC

[section ""cstring" . GHC.StaticPtr.$trModule2_bytes" {
     GHC.StaticPtr.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,116,105,99,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.063402102 UTC

[section ""data" . GHC.StaticPtr.$trModule1_closure" {
     GHC.StaticPtr.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.06418534 UTC

[section ""data" . GHC.StaticPtr.$trModule_closure" {
     GHC.StaticPtr.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.StaticPtr.$trModule3_closure+1;
         const GHC.StaticPtr.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.06493615 UTC

[section ""data" . $krep_rfvlo_closure" {
     $krep_rfvlo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.065881186 UTC

[section ""data" . $krep1_rfvlp_closure" {
     $krep1_rfvlp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.066724131 UTC

[section ""data" . $krep2_rfvlq_closure" {
     $krep2_rfvlq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.067560646 UTC

[section ""data" . $krep3_rfvlr_closure" {
     $krep3_rfvlr_closure:
         const :_con_info;
         const $krep1_rfvlp_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.070382576 UTC

[section ""data" . $krep4_rfvls_closure" {
     $krep4_rfvls_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_rfvlr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.071084117 UTC

[section ""data" . $krep5_rfvlt_closure" {
     $krep5_rfvlt_closure:
         const :_con_info;
         const $krep_rfvlo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.071757868 UTC

[section ""data" . $krep6_rfvlu_closure" {
     $krep6_rfvlu_closure:
         const :_con_info;
         const $krep_rfvlo_closure+1;
         const $krep5_rfvlt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.072397157 UTC

[section ""data" . $krep7_rfvlv_closure" {
     $krep7_rfvlv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep6_rfvlu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.073115408 UTC

[section ""data" . GHC.StaticPtr.$tcIsStatic1_closure" {
     GHC.StaticPtr.$tcIsStatic1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep2_rfvlq_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.073755751 UTC

[section ""data" . $krep8_rfvlw_closure" {
     $krep8_rfvlw_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.074394075 UTC

[section ""data" . $krep9_rfvlx_closure" {
     $krep9_rfvlx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.075043313 UTC

[section ""cstring" . GHC.StaticPtr.$tcStaticPtrInfo2_bytes" {
     GHC.StaticPtr.$tcStaticPtrInfo2_bytes:
         I8[] [83,116,97,116,105,99,80,116,114,73,110,102,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.07568443 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtrInfo1_closure" {
     GHC.StaticPtr.$tcStaticPtrInfo1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tcStaticPtrInfo2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.076321711 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtrInfo_closure" {
     GHC.StaticPtr.$tcStaticPtrInfo_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tcStaticPtrInfo1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9809180260958205610;
         const 5820027882667808380;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.076991504 UTC

[section ""data" . $krep10_rfvly_closure" {
     $krep10_rfvly_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.StaticPtr.$tcStaticPtrInfo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.077662658 UTC

[section ""data" . $krep11_rfvlz_closure" {
     $krep11_rfvlz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rfvlv_closure+1;
         const $krep10_rfvly_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.07841983 UTC

[section ""data" . $krep12_rfvlA_closure" {
     $krep12_rfvlA_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rfvls_closure+1;
         const $krep11_rfvlz_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.079078076 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtrInfo1_closure" {
     GHC.StaticPtr.$tc'StaticPtrInfo1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rfvls_closure+1;
         const $krep12_rfvlA_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.079770361 UTC

[section ""cstring" . GHC.StaticPtr.$tc'StaticPtrInfo3_bytes" {
     GHC.StaticPtr.$tc'StaticPtrInfo3_bytes:
         I8[] [39,83,116,97,116,105,99,80,116,114,73,110,102,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.08041104 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtrInfo2_closure" {
     GHC.StaticPtr.$tc'StaticPtrInfo2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tc'StaticPtrInfo3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.081053347 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtrInfo_closure" {
     GHC.StaticPtr.$tc'StaticPtrInfo_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tc'StaticPtrInfo2_closure+1;
         const GHC.StaticPtr.$tc'StaticPtrInfo1_closure+4;
         const 12332739532642204119;
         const 17636067641148941699;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.082081373 UTC

[section ""cstring" . GHC.StaticPtr.$tcStaticPtr2_bytes" {
     GHC.StaticPtr.$tcStaticPtr2_bytes:
         I8[] [83,116,97,116,105,99,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.082784496 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtr1_closure" {
     GHC.StaticPtr.$tcStaticPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tcStaticPtr2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.083479754 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtr_closure" {
     GHC.StaticPtr.$tcStaticPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tcStaticPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 6538784347774135987;
         const 451387415853290179;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.084267142 UTC

[section ""data" . $krep13_rfvlB_closure" {
     $krep13_rfvlB_closure:
         const :_con_info;
         const $krep8_rfvlw_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.084974752 UTC

[section ""data" . $krep14_rfvlC_closure" {
     $krep14_rfvlC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.StaticPtr.$tcStaticPtr_closure+1;
         const $krep13_rfvlB_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.085688787 UTC

[section ""data" . $krep15_rfvlD_closure" {
     $krep15_rfvlD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rfvlw_closure+2;
         const $krep14_rfvlC_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.086430833 UTC

[section ""data" . $krep16_rfvlE_closure" {
     $krep16_rfvlE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rfvly_closure+1;
         const $krep15_rfvlD_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.087101631 UTC

[section ""data" . $krep17_rfvlF_closure" {
     $krep17_rfvlF_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_rfvlx_closure+1;
         const $krep16_rfvlE_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.087872288 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtr1_closure" {
     GHC.StaticPtr.$tc'StaticPtr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_rfvlx_closure+1;
         const $krep17_rfvlF_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.088551171 UTC

[section ""cstring" . GHC.StaticPtr.$tc'StaticPtr3_bytes" {
     GHC.StaticPtr.$tc'StaticPtr3_bytes:
         I8[] [39,83,116,97,116,105,99,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.089259915 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtr2_closure" {
     GHC.StaticPtr.$tc'StaticPtr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tc'StaticPtr3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.08998921 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtr_closure" {
     GHC.StaticPtr.$tc'StaticPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tc'StaticPtr2_closure+1;
         const GHC.StaticPtr.$tc'StaticPtr1_closure+4;
         const 3211798574336347514;
         const 9816765169815661376;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.09072748 UTC

[section ""cstring" . GHC.StaticPtr.$tcIsStatic3_bytes" {
     GHC.StaticPtr.$tcIsStatic3_bytes:
         I8[] [73,115,83,116,97,116,105,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.09139397 UTC

[section ""data" . GHC.StaticPtr.$tcIsStatic2_closure" {
     GHC.StaticPtr.$tcIsStatic2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tcIsStatic3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.092076751 UTC

[section ""data" . GHC.StaticPtr.$tcIsStatic_closure" {
     GHC.StaticPtr.$tcIsStatic_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tcIsStatic2_closure+1;
         const GHC.StaticPtr.$tcIsStatic1_closure+4;
         const 12653381617957437053;
         const 3253287492145771790;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.094601517 UTC

[section ""data" . GHC.StaticPtr.$wunsafeLookupStaticPtr_closure" {
     GHC.StaticPtr.$wunsafeLookupStaticPtr_closure:
         const GHC.StaticPtr.$wunsafeLookupStaticPtr_info;
 },
 GHC.StaticPtr.$wunsafeLookupStaticPtr_entry() //  [R2, R3]
         { info_tbl: [(cfvFZ,
                       label: GHC.StaticPtr.$wunsafeLookupStaticPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvFZ: // global
           _sfvnm::I64 = R3;
           _sfvnl::I64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cfvG0; else goto cfvG1;
       cfvG1: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cfvG3; else goto cfvG2;
       cfvG3: // global
           HpAlloc = 80;
           goto cfvG0;
       cfvG0: // global
           R3 = _sfvnm::I64;
           R2 = _sfvnl::I64;
           R1 = GHC.StaticPtr.$wunsafeLookupStaticPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfvG2: // global
           I64[Hp - 72] = GHC.Word.W64#_con_info;
           I64[Hp - 64] = _sfvnl::I64;
           I64[Hp - 56] = GHC.Word.W64#_con_info;
           I64[Hp - 48] = _sfvnm::I64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 55;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 38;
           I64[Sp - 16] = block_cfvFX_info;
           R3 = 0;
           _cfvFW::P64 = Hp - 14;
           R2 = _cfvFW::P64;
           P64[Sp - 8] = _cfvFW::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfvFX() //  [R1]
         { info_tbl: [(cfvFX,
                       label: block_cfvFX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvFX: // global
           I64[Sp] = block_cfvGa_info;
           R2 = 8;
           R1 = R1 << 3;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvGa() //  [R1]
         { info_tbl: [(cfvGa,
                       label: block_cfvGa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvGa: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _cfvGA() args: 0, res: 0, upd: 0;
     }
 },
 _cfvGA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvGA: // global
           _sfvnN::P64 = P64[Sp];
           I64[Sp] = block_cfvGD_info;
           R1 = _sfvnN::P64;
           if (R1 & 7 != 0) goto ufvH2; else goto cfvGF;
       ufvH2: // global
           call _cfvGD(R1) args: 0, res: 0, upd: 0;
       cfvGF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvGD() //  [R1]
         { info_tbl: [(cfvGD,
                       label: block_cfvGD_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvGD: // global
           if (R1 & 7 == 1) goto ufvGZ; else goto cfvGQ;
       ufvGZ: // global
           Sp = Sp + 8;
           call _cfvGj() args: 0, res: 0, upd: 0;
       cfvGQ: // global
           I64[Sp - 8] = block_cfvGO_info;
           _sfvnS::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sfvnS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvH3; else goto cfvGR;
       ufvH3: // global
           call _cfvGO(R1) args: 0, res: 0, upd: 0;
       cfvGR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvGj() //  []
         { info_tbl: [(cfvGj,
                       label: block_cfvGj_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvGj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfvGn; else goto cfvGm;
       cfvGn: // global
           HpAlloc = 16;
           I64[Sp] = block_cfvGj_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfvGm: // global
           _sfvnz::P64 = P64[Sp + 16];
           (_sfvnG::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] hs_spt_lookup(I64[Sp + 8]);
           call MO_Touch(_sfvnz::P64);
           if (_sfvnG::I64 == 0) goto cfvGx; else goto cfvGw;
       cfvGx: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfvGw: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           I64[Hp] = _sfvnG::I64;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfvGO() //  [R1]
         { info_tbl: [(cfvGO,
                       label: block_cfvGO_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvGO: // global
           _sfvnO::I64 = I64[Sp + 16];
           _sfvnS::P64 = P64[Sp + 8];
           I64[I64[Sp + 24] + (_sfvnO::I64 << 3)] = I64[R1 + 7];
           P64[Sp + 8] = _sfvnS::P64;
           I64[Sp + 16] = _sfvnO::I64 + 1;
           Sp = Sp + 8;
           call _cfvGA() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.097960096 UTC

[section ""data" . GHC.StaticPtr.unsafeLookupStaticPtr1_closure" {
     GHC.StaticPtr.unsafeLookupStaticPtr1_closure:
         const GHC.StaticPtr.unsafeLookupStaticPtr1_info;
 },
 GHC.StaticPtr.unsafeLookupStaticPtr1_entry() //  [R2]
         { info_tbl: [(cfvHd,
                       label: GHC.StaticPtr.unsafeLookupStaticPtr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvHd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvHe; else goto cfvHf;
       cfvHe: // global
           R2 = R2;
           R1 = GHC.StaticPtr.unsafeLookupStaticPtr1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvHf: // global
           I64[Sp - 8] = block_cfvHa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvHj; else goto cfvHb;
       ufvHj: // global
           call _cfvHa(R1) args: 0, res: 0, upd: 0;
       cfvHb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvHa() //  [R1]
         { info_tbl: [(cfvHa,
                       label: block_cfvHa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvHa: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.StaticPtr.$wunsafeLookupStaticPtr_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.099612455 UTC

[section ""data" . GHC.StaticPtr.unsafeLookupStaticPtr_closure" {
     GHC.StaticPtr.unsafeLookupStaticPtr_closure:
         const GHC.StaticPtr.unsafeLookupStaticPtr_info;
 },
 GHC.StaticPtr.unsafeLookupStaticPtr_entry() //  [R2]
         { info_tbl: [(cfvHo,
                       label: GHC.StaticPtr.unsafeLookupStaticPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvHo: // global
           R2 = R2;
           call GHC.StaticPtr.unsafeLookupStaticPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.100815458 UTC

[section ""cstring" . lvl_rfvlG_bytes" {
     lvl_rfvlG_bytes:
         I8[] [71,72,67,47,83,116,97,116,105,99,80,116,114,46,104,115,58,49,51,49,58,52,49,45,55,57,124,108,97,109,98,100,97]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.102124864 UTC

[section ""data" . lvl1_rfvlH_closure" {
     lvl1_rfvlH_closure:
         const lvl1_rfvlH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rfvlH_entry() //  [R1]
         { info_tbl: [(cfvHx,
                       label: lvl1_rfvlH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvHx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvHy; else goto cfvHz;
       cfvHy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvHz: // global
           (_cfvHu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfvHu::I64 == 0) goto cfvHw; else goto cfvHv;
       cfvHw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfvHv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfvHu::I64;
           R2 = lvl_rfvlG_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.105955974 UTC

[section ""data" . GHC.StaticPtr.staticPtrKeys2_closure" {
     GHC.StaticPtr.staticPtrKeys2_closure:
         const GHC.StaticPtr.staticPtrKeys2_info;
         const 0;
 },
 sat_sfvop_entry() //  [R1]
         { info_tbl: [(cfvIs,
                       label: sat_sfvop_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvIs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfvIw; else goto cfvIx;
       cfvIw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvIx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cfvIp_info;
           _sfvoe::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sfvoe::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufvIB; else goto cfvIq;
       ufvIB: // global
           call _cfvIp(R1) args: 0, res: 0, upd: 0;
       cfvIq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfvIp() //  [R1]
         { info_tbl: [(cfvIp,
                       label: block_cfvIp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvIp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvIA; else goto cfvIz;
       cfvIA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cfvIz: // global
           _sfvoo::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _sfvoo::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.StaticPtr.staticPtrKeys2_entry() //  [R2]
         { info_tbl: [(cfvIG,
                       label: GHC.StaticPtr.staticPtrKeys2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvIG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfvIH; else goto cfvII;
       cfvIH: // global
           R2 = R2;
           R1 = GHC.StaticPtr.staticPtrKeys2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvII: // global
           I64[Sp - 8] = block_cfvHE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvJr; else goto cfvHF;
       ufvJr: // global
           call _cfvHE(R1) args: 0, res: 0, upd: 0;
       cfvHF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvHE() //  [R1]
         { info_tbl: [(cfvHE,
                       label: block_cfvHE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvHE: // global
           if (R1 & 7 == 1) goto cfvID; else goto cfvIE;
       cfvID: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfvIE: // global
           P64[Sp - 24] = P64[R1 + 14];
           I64[Sp - 16] = 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 24;
           call _cfvHO() args: 0, res: 0, upd: 0;
     }
 },
 _cfvHO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvHO: // global
           _sfvo5::P64 = P64[Sp + 24];
           _sfvoy::I64 = I64[Sp + 8];
           if (_sfvoy::I64 != 0) goto cfvJ7; else goto cfvJb;
       cfvJ7: // global
           I64[Sp - 8] = block_cfvHT_info;
           R1 = _sfvo5::P64;
           I64[Sp + 8] = _sfvoy::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvJk; else goto cfvHU;
       ufvJk: // global
           call _cfvHT(R1) args: 0, res: 0, upd: 0;
       cfvHU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfvJb: // global
           I64[Sp - 8] = block_cfvI3_info;
           R1 = _sfvo5::P64;
           P64[Sp + 24] = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvJl; else goto cfvI4;
       ufvJl: // global
           call _cfvI3(R1) args: 0, res: 0, upd: 0;
       cfvI4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvHT() //  [R1]
         { info_tbl: [(cfvHT,
                       label: block_cfvHT_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvHT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfvJa; else goto cfvJ9;
       cfvJa: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfvJ9: // global
           _sfvoy::I64 = I64[Sp + 16];
           _sfvoD::I64 = I64[I64[R1 + 7] + (_sfvoy::I64 << 3)];
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = _sfvoD::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 16] = _sfvoy::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           Sp = Sp + 8;
           call _cfvHO() args: 0, res: 0, upd: 0;
     }
 },
 _cfvI3() //  [R1]
         { info_tbl: [(cfvI3,
                       label: block_cfvI3_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvI3: // global
           _sfvoe::I64 = I64[I64[R1 + 7]];
           I64[Sp] = block_cfvI8_info;
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sfvoe::I64;
           if (R1 & 7 != 0) goto ufvJn; else goto cfvI9;
       ufvJn: // global
           call _cfvI8(R1) args: 0, res: 0, upd: 0;
       cfvI9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvI8() //  [R1]
         { info_tbl: [(cfvI8,
                       label: block_cfvI8_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvI8: // global
           if (R1 & 7 == 1) goto ufvJh; else goto cfvIT;
       ufvJh: // global
           Sp = Sp + 40;
           call _cfvJ4() args: 0, res: 0, upd: 0;
       cfvIT: // global
           I64[Sp] = block_cfvIe_info;
           _sfvoh::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp + 24] = _sfvoh::P64;
           if (R1 & 7 != 0) goto ufvJo; else goto cfvIf;
       ufvJo: // global
           call _cfvIe(R1) args: 0, res: 0, upd: 0;
       cfvIf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvIe() //  [R1]
         { info_tbl: [(cfvIe,
                       label: block_cfvIe_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvIe: // global
           if (R1 & 7 == 1) goto cfvIX; else goto ufvJi;
       cfvIX: // global
           I64[Sp + 16] = block_cfvIj_info;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.StaticPtr.staticPtrKeys2_entry(R2) args: 8, res: 8, upd: 8;
       ufvJi: // global
           Sp = Sp + 40;
           call _cfvJ4() args: 0, res: 0, upd: 0;
     }
 },
 _cfvIj() //  [R1]
         { info_tbl: [(cfvIj,
                       label: block_cfvIj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvIj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfvJ0; else goto cfvIZ;
       cfvJ0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfvIZ: // global
           I64[Hp - 48] = sat_sfvop_info;
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfvJ4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvJ4: // global
           R1 = lvl1_rfvlH_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.112949958 UTC

[section ""data" . GHC.StaticPtr.staticPtrKeys1_closure" {
     GHC.StaticPtr.staticPtrKeys1_closure:
         const GHC.StaticPtr.staticPtrKeys1_info;
         const 0;
 },
 GHC.StaticPtr.staticPtrKeys1_entry() //  []
         { info_tbl: [(cfvK5,
                       label: GHC.StaticPtr.staticPtrKeys1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvK5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfvK6; else goto cfvK7;
       cfvK6: // global
           R1 = GHC.StaticPtr.staticPtrKeys1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cfvK7: // global
           (_sfvoL::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] hs_spt_key_count();
           I64[Sp - 16] = block_cfvJD_info;
           R2 = 8;
           _sfvoM::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sfvoL::I64));
           R1 = _sfvoM::I64 << 3;
           I64[Sp - 8] = _sfvoM::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvJD() //  [R1]
         { info_tbl: [(cfvJD,
                       label: block_cfvJD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvJD: // global
           _sfvoU::I64 = R1 + 16;
           (_sfvoY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     ‘signed’]  result hints:  [‘signed’] hs_spt_keys(_sfvoU::I64, I64[Sp + 8]);
           _sfvoZ::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sfvoY::I64));
           if (%MO_S_Gt_W64(_sfvoZ::I64, 0)) goto cfvKr; else goto cfvKu;
       cfvKr: // global
           I64[Sp - 16] = _sfvoZ::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = _sfvoU::I64;
           P64[Sp + 8] = R1;
           Sp = Sp - 24;
           call _cfvJY() args: 0, res: 0, upd: 0;
       cfvKu: // global
           I64[Sp] = block_cfvKt_info;
           R2 = GHC.Types.[]_closure+1;
           P64[Sp + 8] = R1;
           call GHC.StaticPtr.staticPtrKeys2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfvJY() //  []
         { info_tbl: [(cfvJY,
                       label: block_cfvJY_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvJY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfvKm; else goto cfvKl;
       cfvKm: // global
           HpAlloc = 40;
           I64[Sp] = block_cfvJY_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfvKl: // global
           _sfvpf::P64 = P64[Sp + 16];
           _sfvph::I64 = I64[Sp + 8];
           if (_sfvph::I64 != 0) goto cfvKo; else goto cfvKp;
       cfvKo: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 24] + (_sfvph::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sfvpf::P64;
           I64[Sp + 8] = _sfvph::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _cfvJY() args: 0, res: 0, upd: 0;
       cfvKp: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _sfvpf::P64;
           Sp = Sp + 16;
           call _cfvKa() args: 0, res: 0, upd: 0;
     }
 },
 _cfvKa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvKa: // global
           Hp = Hp + 40;
           _sfvp2::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cfvKh; else goto cfvKg;
       cfvKh: // global
           HpAlloc = 40;
           I64[Sp] = block_cfvK9_info;
           R1 = _sfvp2::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfvKg: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 8]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sfvp2::P64;
           I64[Sp + 8] = block_cfvKe_info;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.StaticPtr.staticPtrKeys2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfvK9() //  [R1]
         { info_tbl: [(cfvK9,
                       label: block_cfvK9_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvK9: // global
           P64[Sp] = R1;
           call _cfvKa() args: 0, res: 0, upd: 0;
     }
 },
 _cfvKe() //  [R1]
         { info_tbl: [(cfvKe,
                       label: block_cfvKe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvKe: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfvKt() //  [R1]
         { info_tbl: [(cfvKt,
                       label: block_cfvKt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvKt: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.116970677 UTC

[section ""data" . GHC.StaticPtr.staticPtrKeys_closure" {
     GHC.StaticPtr.staticPtrKeys_closure:
         const GHC.StaticPtr.staticPtrKeys_info;
         const 0;
 },
 GHC.StaticPtr.staticPtrKeys_entry() //  []
         { info_tbl: [(cfvKM,
                       label: GHC.StaticPtr.staticPtrKeys_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvKM: // global
           call GHC.StaticPtr.staticPtrKeys1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.118380823 UTC

[section ""data" . GHC.StaticPtr.StaticPtr_closure" {
     GHC.StaticPtr.StaticPtr_closure:
         const GHC.StaticPtr.StaticPtr_info;
 },
 GHC.StaticPtr.StaticPtr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvKQ: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.StaticPtr.StaticPtr_entry(R5,
                                              R4,
                                              R3,
                                              R2,
                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.StaticPtr.StaticPtr_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfvKV,
                       label: GHC.StaticPtr.StaticPtr_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvKV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfvKZ; else goto cfvKY;
       cfvKZ: // global
           HpAlloc = 40;
           R1 = GHC.StaticPtr.StaticPtr_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cfvKY: // global
           I64[Hp - 32] = GHC.StaticPtr.StaticPtr_con_info;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.120038537 UTC

[section ""data" . GHC.StaticPtr.StaticPtrInfo_closure" {
     GHC.StaticPtr.StaticPtrInfo_closure:
         const GHC.StaticPtr.StaticPtrInfo_info;
 },
 GHC.StaticPtr.StaticPtrInfo_entry() //  [R2, R3, R4]
         { info_tbl: [(cfvL5,
                       label: GHC.StaticPtr.StaticPtrInfo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvL5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfvL9; else goto cfvL8;
       cfvL9: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.StaticPtrInfo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfvL8: // global
           I64[Hp - 24] = GHC.StaticPtr.StaticPtrInfo_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.12121734 UTC

[GHC.StaticPtr.StaticPtr_con_entry() //  [R1]
         { info_tbl: [(cfvLa,
                       label: GHC.StaticPtr.StaticPtr_con_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,105,99,80,116,114,46,83,116,97,116,105,99,80,116,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvLa: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.12384479 UTC

[GHC.StaticPtr.StaticPtrInfo_con_entry() //  [R1]
         { info_tbl: [(cfvLc,
                       label: GHC.StaticPtr.StaticPtrInfo_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,105,99,80,116,114,46,83,116,97,116,105,99,80,116,114,73,110,102,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvLc: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.124479288 UTC

[section ""relreadonly" . SfvsE_srt" {
     SfvsE_srt:
         const GHC.Show.$fShow(,)_go1_closure;
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Show.showLitString_closure;
         const GHC.StaticPtr.$w$cshowsPrec_closure;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure;
         const GHC.StaticPtr.$fShowStaticPtrInfo1_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.StaticPtr.staticPtrKeys2_closure;
         const lvl1_rfvlH_closure;
         const GHC.StaticPtr.staticPtrKeys1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.125371006 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:13.126605914 UTC

[section ""data" . GHC.StaticPtr.fromStaticPtr_closure" {
     GHC.StaticPtr.fromStaticPtr_closure:
         const GHC.StaticPtr.fromStaticPtr_info;
 },
 GHC.StaticPtr.fromStaticPtr_entry() //  [R2]
         { info_tbl: [(cfvLi,
                       label: GHC.StaticPtr.fromStaticPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvLi: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.130448566 UTC

[section ""data" . GHC.StaticPtr.$fIsStaticStaticPtr_closure" {
     GHC.StaticPtr.$fIsStaticStaticPtr_closure:
         const GHC.StaticPtr.$fIsStaticStaticPtr_info;
 },
 GHC.StaticPtr.$fIsStaticStaticPtr_entry() //  [R2]
         { info_tbl: [(cfvLt,
                       label: GHC.StaticPtr.$fIsStaticStaticPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvLt: // global
           R2 = R2;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.134747039 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo6_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo6_bytes:
         I8[] [83,116,97,116,105,99,80,116,114,73,110,102,111,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.136997039 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo5_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo5_bytes:
         I8[] [115,112,73,110,102,111,85,110,105,116,73,100,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.139272684 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo4_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo4_bytes:
         I8[] [115,112,73,110,102,111,77,111,100,117,108,101,78,97,109,101,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.141627153 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo3_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo3_bytes:
         I8[] [115,112,73,110,102,111,83,114,99,76,111,99,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.1438554 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo2_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo2_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.150216887 UTC

[section ""data" . GHC.StaticPtr.$w$cshowsPrec_closure" {
     GHC.StaticPtr.$w$cshowsPrec_closure:
         const GHC.StaticPtr.$w$cshowsPrec_info;
         const 0;
 },
 GHC.StaticPtr.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvLG: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvma_entry() //  [R1]
         { info_tbl: [(cfvMy,
                       label: sat_sfvma_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvMy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvMz; else goto cfvMA;
       cfvMz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvMA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvm7_entry() //  [R1, R2]
         { info_tbl: [(cfvMK,
                       label: sat_sfvm7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvMK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvMQ; else goto cfvMR;
       cfvMQ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvMR: // global
           I64[Sp - 16] = block_cfvMH_info;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufvMW; else goto cfvMI;
       ufvMW: // global
           call _cfvMH(R1) args: 0, res: 0, upd: 0;
       cfvMI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvMH() //  [R1]
         { info_tbl: [(cfvMH,
                       label: block_cfvMH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvMH: // global
           _sfvm1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cfvMN_info;
           R4 = _sfvm1::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfvMN() //  [R1, R2]
         { info_tbl: [(cfvMN,
                       label: block_cfvMN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvMN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvMV; else goto cfvMU;
       cfvMV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cfvMU: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvm0_entry() //  [R1, R2]
         { info_tbl: [(cfvN6,
                       label: sat_sfvm0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvN6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvNc; else goto cfvNd;
       cfvNc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvNd: // global
           I64[Sp - 16] = block_cfvN3_info;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufvNi; else goto cfvN4;
       ufvNi: // global
           call _cfvN3(R1) args: 0, res: 0, upd: 0;
       cfvN4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvN3() //  [R1]
         { info_tbl: [(cfvN3,
                       label: block_cfvN3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvN3: // global
           _sfvlU::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cfvN9_info;
           R4 = _sfvlU::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfvN9() //  [R1, R2]
         { info_tbl: [(cfvN9,
                       label: block_cfvN9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvN9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvNh; else goto cfvNg;
       cfvNh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cfvNg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvmc_entry() //  [R1]
         { info_tbl: [(cfvNk,
                       label: sat_sfvmc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvNk: // global
           _sfvmc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvNl; else goto cfvNm;
       cfvNm: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cfvNo; else goto cfvNn;
       cfvNo: // global
           HpAlloc = 128;
           goto cfvNl;
       cfvNl: // global
           R1 = _sfvmc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvNn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmc::P64;
           _sfvlQ::P64 = P64[_sfvmc::P64 + 16];
           _sfvlS::P64 = P64[_sfvmc::P64 + 24];
           _sfvlT::P64 = P64[_sfvmc::P64 + 32];
           I64[Hp - 120] = sat_sfvma_info;
           P64[Hp - 104] = _sfvlQ::P64;
           I64[Hp - 96] = :_con_info;
           P64[Hp - 88] = GHC.Show.$fShow(,)2_closure;
           P64[Hp - 80] = Hp - 120;
           I64[Hp - 72] = sat_sfvm7_info;
           P64[Hp - 64] = _sfvlT::P64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           I64[Hp - 32] = sat_sfvm0_info;
           P64[Hp - 24] = _sfvlS::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 54;
           R3 = Hp - 94;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Show.$fShow(,)_go1_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmd_entry() //  [R1]
         { info_tbl: [(cfvNp,
                       label: sat_sfvmd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvNp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfvNr; else goto cfvNs;
       cfvNr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvNs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cfvMl_info;
           _sfvlQ::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sfvlQ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufvNw; else goto cfvMm;
       ufvNw: // global
           call _cfvMl(R1) args: 0, res: 0, upd: 0;
       cfvMm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfvMl() //  [R1]
         { info_tbl: [(cfvMl,
                       label: block_cfvMl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvMl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfvNv; else goto cfvNu;
       cfvNv: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cfvNu: // global
           _sfvlS::P64 = P64[R1 + 7];
           _sfvlT::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sfvmc_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sfvlS::P64;
           P64[Hp - 24] = _sfvlT::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvme_entry() //  [R1]
         { info_tbl: [(cfvNx,
                       label: sat_sfvme_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvNx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfvNB; else goto cfvNA;
       cfvNB: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvNA: // global
           _sfvlN::P64 = P64[R1 + 16];
           _sfvlQ::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sfvmd_info;
           P64[Hp - 8] = _sfvlN::P64;
           P64[Hp] = _sfvlQ::P64;
           R3 = Hp - 24;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvmf_entry() //  [R1]
         { info_tbl: [(cfvNC,
                       label: sat_sfvmf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvNC: // global
           _sfvmf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvND; else goto cfvNE;
       cfvNE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfvNG; else goto cfvNF;
       cfvNG: // global
           HpAlloc = 32;
           goto cfvND;
       cfvND: // global
           R1 = _sfvmf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvNF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmf::P64;
           _sfvlN::P64 = P64[_sfvmf::P64 + 16];
           _sfvlQ::P64 = P64[_sfvmf::P64 + 24];
           I64[Hp - 24] = sat_sfvme_info;
           P64[Hp - 8] = _sfvlN::P64;
           P64[Hp] = _sfvlQ::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmh_entry() //  [R1]
         { info_tbl: [(cfvNI,
                       label: sat_sfvmh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvNI: // global
           _sfvmh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvNJ; else goto cfvNK;
       cfvNK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfvNM; else goto cfvNL;
       cfvNM: // global
           HpAlloc = 56;
           goto cfvNJ;
       cfvNJ: // global
           R1 = _sfvmh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvNL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmh::P64;
           _sfvlM::P64 = P64[_sfvmh::P64 + 16];
           _sfvlN::P64 = P64[_sfvmh::P64 + 24];
           _sfvlQ::P64 = P64[_sfvmh::P64 + 32];
           I64[Hp - 48] = sat_sfvmf_info;
           P64[Hp - 32] = _sfvlN::P64;
           P64[Hp - 24] = _sfvlQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sfvlM::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmj_entry() //  [R1]
         { info_tbl: [(cfvNO,
                       label: sat_sfvmj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvNO: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfvNS; else goto cfvNR;
       cfvNS: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvNR: // global
           _sfvlM::P64 = P64[R1 + 16];
           _sfvlN::P64 = P64[R1 + 24];
           _sfvlQ::P64 = P64[R1 + 32];
           I64[Hp - 56] = sat_sfvmh_info;
           P64[Hp - 40] = _sfvlM::P64;
           P64[Hp - 32] = _sfvlN::P64;
           P64[Hp - 24] = _sfvlQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvmk_entry() //  [R1]
         { info_tbl: [(cfvNT,
                       label: sat_sfvmk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvNT: // global
           _sfvmk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvNU; else goto cfvNV;
       cfvNV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfvNX; else goto cfvNW;
       cfvNX: // global
           HpAlloc = 40;
           goto cfvNU;
       cfvNU: // global
           R1 = _sfvmk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvNW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmk::P64;
           _sfvlM::P64 = P64[_sfvmk::P64 + 16];
           _sfvlN::P64 = P64[_sfvmk::P64 + 24];
           _sfvlQ::P64 = P64[_sfvmk::P64 + 32];
           I64[Hp - 32] = sat_sfvmj_info;
           P64[Hp - 16] = _sfvlM::P64;
           P64[Hp - 8] = _sfvlN::P64;
           P64[Hp] = _sfvlQ::P64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmm_entry() //  [R1]
         { info_tbl: [(cfvNZ,
                       label: sat_sfvmm_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvNZ: // global
           _sfvmm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvO0; else goto cfvO1;
       cfvO1: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfvO3; else goto cfvO2;
       cfvO3: // global
           HpAlloc = 64;
           goto cfvO0;
       cfvO0: // global
           R1 = _sfvmm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvO2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmm::P64;
           _sfvlL::P64 = P64[_sfvmm::P64 + 16];
           _sfvlM::P64 = P64[_sfvmm::P64 + 24];
           _sfvlN::P64 = P64[_sfvmm::P64 + 32];
           _sfvlQ::P64 = P64[_sfvmm::P64 + 40];
           I64[Hp - 56] = sat_sfvmk_info;
           P64[Hp - 40] = _sfvlM::P64;
           P64[Hp - 32] = _sfvlN::P64;
           P64[Hp - 24] = _sfvlQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sfvlL::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfvmo_entry() //  [R1]
         { info_tbl: [(cfvO5,
                       label: sat_sfvmo_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvO5: // global
           _sfvmo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvO6; else goto cfvO7;
       cfvO7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfvO9; else goto cfvO8;
       cfvO9: // global
           HpAlloc = 72;
           goto cfvO6;
       cfvO6: // global
           R1 = _sfvmo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvO8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmo::P64;
           _sfvlL::P64 = P64[_sfvmo::P64 + 16];
           _sfvlM::P64 = P64[_sfvmo::P64 + 24];
           _sfvlN::P64 = P64[_sfvmo::P64 + 32];
           _sfvlQ::P64 = P64[_sfvmo::P64 + 40];
           I64[Hp - 64] = sat_sfvmm_info;
           P64[Hp - 48] = _sfvlL::P64;
           P64[Hp - 40] = _sfvlM::P64;
           P64[Hp - 32] = _sfvlN::P64;
           P64[Hp - 24] = _sfvlQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_sfvlP_entry() //  [R1, R2]
         { info_tbl: [(cfvOa,
                       label: p_sfvlP_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvOa: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfvOe; else goto cfvOd;
       cfvOe: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvOd: // global
           _sfvlL::P64 = P64[R1 + 7];
           _sfvlM::P64 = P64[R1 + 15];
           _sfvlN::P64 = P64[R1 + 23];
           I64[Hp - 40] = sat_sfvmo_info;
           P64[Hp - 24] = _sfvlL::P64;
           P64[Hp - 16] = _sfvlM::P64;
           P64[Hp - 8] = _sfvlN::P64;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo6_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfvmr_entry() //  [R1]
         { info_tbl: [(cfvOo,
                       label: sat_sfvmr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvOo: // global
           _sfvmr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfvOp; else goto cfvOq;
       cfvOq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvOs; else goto cfvOr;
       cfvOs: // global
           HpAlloc = 24;
           goto cfvOp;
       cfvOp: // global
           R1 = _sfvmr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvOr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfvmr::P64;
           _sfvlO::P64 = P64[_sfvmr::P64 + 16];
           _sfvlP::P64 = P64[_sfvmr::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sfvlO::P64;
           R2 = Hp - 14;
           R1 = _sfvlP::P64;
           Sp = Sp - 16;
           call p_sfvlP_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.StaticPtr.$w$cshowsPrec_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfvOw,
                       label: GHC.StaticPtr.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [True, False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvOw: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cfvOA; else goto cfvOz;
       cfvOA: // global
           HpAlloc = 88;
           R1 = GHC.StaticPtr.$w$cshowsPrec_closure;
           I64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cfvOz: // global
           I64[Hp - 80] = p_sfvlP_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           _cfvLK::P64 = Hp - 79;
           if (%MO_S_Lt_W64(R2, 11)) goto cfvOu; else goto cfvOv;
       cfvOu: // global
           Hp = Hp - 56;
           R2 = R6;
           R1 = _cfvLK::P64;
           call p_sfvlP_entry(R2, R1) args: 8, res: 0, upd: 8;
       cfvOv: // global
           I64[Hp - 48] = sat_sfvmr_info;
           P64[Hp - 32] = R6;
           P64[Hp - 24] = _cfvLK::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.203917324 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cfvQd,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvQd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfvQh; else goto cfvQi;
       cfvQh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfvQi: // global
           I64[Sp - 24] = block_cfvQa_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufvQq; else goto cfvQb;
       ufvQq: // global
           call _cfvQa(R1) args: 0, res: 0, upd: 0;
       cfvQb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvQa() //  [R1]
         { info_tbl: [(cfvQa,
                       label: block_cfvQa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvQa: // global
           I64[Sp] = block_cfvQg_info;
           _sfvmw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sfvmw::I64;
           if (R1 & 7 != 0) goto ufvQp; else goto cfvQk;
       ufvQp: // global
           call _cfvQg(R1) args: 0, res: 0, upd: 0;
       cfvQk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvQg() //  [R1]
         { info_tbl: [(cfvQg,
                       label: block_cfvQg_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvQg: // global
           R6 = P64[Sp + 16];
           R5 = P64[R1 + 23];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.211371564 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo7_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo7_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.214087924 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_entry() //  [R2]
         { info_tbl: [(cfvQM,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvQM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvQN; else goto cfvQO;
       cfvQN: // global
           R2 = R2;
           R1 = GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvQO: // global
           I64[Sp - 8] = block_cfvQJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvQS; else goto cfvQK;
       ufvQS: // global
           call _cfvQJ(R1) args: 0, res: 0, upd: 0;
       cfvQK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvQJ() //  [R1]
         { info_tbl: [(cfvQJ,
                       label: block_cfvQJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvQJ: // global
           R6 = GHC.Types.[]_closure+1;
           R5 = P64[R1 + 23];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.219816512 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo1_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo1_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo1_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo1_entry() //  [R2, R3]
         { info_tbl: [(cfvR9,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvR9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvRa; else goto cfvRb;
       cfvRa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.$fShowStaticPtrInfo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfvRb: // global
           I64[Sp - 16] = block_cfvR6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufvRf; else goto cfvR7;
       ufvRf: // global
           call _cfvR6(R1) args: 0, res: 0, upd: 0;
       cfvR7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvR6() //  [R1]
         { info_tbl: [(cfvR6,
                       label: block_cfvR6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvR6: // global
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 23];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.225476235 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cfvRt,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvRt: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.22891939 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure+3;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure+1;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.231076745 UTC

[section ""data" . GHC.StaticPtr.spInfoSrcLoc_closure" {
     GHC.StaticPtr.spInfoSrcLoc_closure:
         const GHC.StaticPtr.spInfoSrcLoc_info;
 },
 GHC.StaticPtr.spInfoSrcLoc_entry() //  [R2]
         { info_tbl: [(cfvRI,
                       label: GHC.StaticPtr.spInfoSrcLoc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvRI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvRJ; else goto cfvRK;
       cfvRJ: // global
           R2 = R2;
           R1 = GHC.StaticPtr.spInfoSrcLoc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvRK: // global
           I64[Sp - 8] = block_cfvRF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvRO; else goto cfvRG;
       ufvRO: // global
           call _cfvRF(R1) args: 0, res: 0, upd: 0;
       cfvRG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvRF() //  [R1]
         { info_tbl: [(cfvRF,
                       label: block_cfvRF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvRF: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.236470175 UTC

[section ""data" . GHC.StaticPtr.spInfoModuleName_closure" {
     GHC.StaticPtr.spInfoModuleName_closure:
         const GHC.StaticPtr.spInfoModuleName_info;
 },
 GHC.StaticPtr.spInfoModuleName_entry() //  [R2]
         { info_tbl: [(cfvS7,
                       label: GHC.StaticPtr.spInfoModuleName_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvS7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvS8; else goto cfvS9;
       cfvS8: // global
           R2 = R2;
           R1 = GHC.StaticPtr.spInfoModuleName_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvS9: // global
           I64[Sp - 8] = block_cfvS4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvSd; else goto cfvS5;
       ufvSd: // global
           call _cfvS4(R1) args: 0, res: 0, upd: 0;
       cfvS5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvS4() //  [R1]
         { info_tbl: [(cfvS4,
                       label: block_cfvS4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvS4: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.241758418 UTC

[section ""data" . GHC.StaticPtr.spInfoUnitId_closure" {
     GHC.StaticPtr.spInfoUnitId_closure:
         const GHC.StaticPtr.spInfoUnitId_info;
 },
 GHC.StaticPtr.spInfoUnitId_entry() //  [R2]
         { info_tbl: [(cfvSw,
                       label: GHC.StaticPtr.spInfoUnitId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvSw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvSx; else goto cfvSy;
       cfvSx: // global
           R2 = R2;
           R1 = GHC.StaticPtr.spInfoUnitId_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvSy: // global
           I64[Sp - 8] = block_cfvSt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvSC; else goto cfvSu;
       ufvSC: // global
           call _cfvSt(R1) args: 0, res: 0, upd: 0;
       cfvSu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvSt() //  [R1]
         { info_tbl: [(cfvSt,
                       label: block_cfvSt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvSt: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.247633927 UTC

[section ""data" . GHC.StaticPtr.deRefStaticPtr_closure" {
     GHC.StaticPtr.deRefStaticPtr_closure:
         const GHC.StaticPtr.deRefStaticPtr_info;
 },
 GHC.StaticPtr.deRefStaticPtr_entry() //  [R2]
         { info_tbl: [(cfvSV,
                       label: GHC.StaticPtr.deRefStaticPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvSV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvSW; else goto cfvSX;
       cfvSW: // global
           R2 = R2;
           R1 = GHC.StaticPtr.deRefStaticPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvSX: // global
           I64[Sp - 8] = block_cfvSS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvT1; else goto cfvST;
       ufvT1: // global
           call _cfvSS(R1) args: 0, res: 0, upd: 0;
       cfvST: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvSS() //  [R1]
         { info_tbl: [(cfvSS,
                       label: block_cfvSS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvSS: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.2529752 UTC

[section ""data" . GHC.StaticPtr.staticKey_closure" {
     GHC.StaticPtr.staticKey_closure:
         const GHC.StaticPtr.staticKey_info;
 },
 GHC.StaticPtr.staticKey_entry() //  [R2]
         { info_tbl: [(cfvTi,
                       label: GHC.StaticPtr.staticKey_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvTi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvTm; else goto cfvTn;
       cfvTm: // global
           R2 = R2;
           R1 = GHC.StaticPtr.staticKey_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvTn: // global
           I64[Sp - 8] = block_cfvTf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvTr; else goto cfvTg;
       ufvTr: // global
           call _cfvTf(R1) args: 0, res: 0, upd: 0;
       cfvTg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvTf() //  [R1]
         { info_tbl: [(cfvTf,
                       label: block_cfvTf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvTf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvTq; else goto cfvTp;
       cfvTq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfvTp: // global
           _sfvnb::I64 = I64[R1 + 23];
           _sfvnc::I64 = I64[R1 + 31];
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = _sfvnb::I64;
           I64[Hp] = _sfvnc::I64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.258826394 UTC

[section ""data" . GHC.StaticPtr.staticPtrInfo_closure" {
     GHC.StaticPtr.staticPtrInfo_closure:
         const GHC.StaticPtr.staticPtrInfo_info;
 },
 GHC.StaticPtr.staticPtrInfo_entry() //  [R2]
         { info_tbl: [(cfvTJ,
                       label: GHC.StaticPtr.staticPtrInfo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvTJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvTK; else goto cfvTL;
       cfvTK: // global
           R2 = R2;
           R1 = GHC.StaticPtr.staticPtrInfo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvTL: // global
           I64[Sp - 8] = block_cfvTG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvTP; else goto cfvTH;
       ufvTP: // global
           call _cfvTG(R1) args: 0, res: 0, upd: 0;
       cfvTH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvTG() //  [R1]
         { info_tbl: [(cfvTG,
                       label: block_cfvTG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvTG: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.263901331 UTC

[section ""cstring" . GHC.StaticPtr.$trModule4_bytes" {
     GHC.StaticPtr.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.265823862 UTC

[section ""data" . GHC.StaticPtr.$trModule3_closure" {
     GHC.StaticPtr.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.267496689 UTC

[section ""cstring" . GHC.StaticPtr.$trModule2_bytes" {
     GHC.StaticPtr.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,116,105,99,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.269289212 UTC

[section ""data" . GHC.StaticPtr.$trModule1_closure" {
     GHC.StaticPtr.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.270954671 UTC

[section ""data" . GHC.StaticPtr.$trModule_closure" {
     GHC.StaticPtr.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.StaticPtr.$trModule3_closure+1;
         const GHC.StaticPtr.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.272699483 UTC

[section ""data" . $krep_rfvlo_closure" {
     $krep_rfvlo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.274447334 UTC

[section ""data" . $krep1_rfvlp_closure" {
     $krep1_rfvlp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.276711597 UTC

[section ""data" . $krep2_rfvlq_closure" {
     $krep2_rfvlq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.278591509 UTC

[section ""data" . $krep3_rfvlr_closure" {
     $krep3_rfvlr_closure:
         const :_con_info;
         const $krep1_rfvlp_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.280281984 UTC

[section ""data" . $krep4_rfvls_closure" {
     $krep4_rfvls_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_rfvlr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.282807936 UTC

[section ""data" . $krep5_rfvlt_closure" {
     $krep5_rfvlt_closure:
         const :_con_info;
         const $krep_rfvlo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.284453136 UTC

[section ""data" . $krep6_rfvlu_closure" {
     $krep6_rfvlu_closure:
         const :_con_info;
         const $krep_rfvlo_closure+1;
         const $krep5_rfvlt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.286211501 UTC

[section ""data" . $krep7_rfvlv_closure" {
     $krep7_rfvlv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep6_rfvlu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.287944699 UTC

[section ""data" . GHC.StaticPtr.$tcIsStatic1_closure" {
     GHC.StaticPtr.$tcIsStatic1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep2_rfvlq_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.289740538 UTC

[section ""data" . $krep8_rfvlw_closure" {
     $krep8_rfvlw_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.291395098 UTC

[section ""data" . $krep9_rfvlx_closure" {
     $krep9_rfvlx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.293150968 UTC

[section ""cstring" . GHC.StaticPtr.$tcStaticPtrInfo2_bytes" {
     GHC.StaticPtr.$tcStaticPtrInfo2_bytes:
         I8[] [83,116,97,116,105,99,80,116,114,73,110,102,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.295276233 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtrInfo1_closure" {
     GHC.StaticPtr.$tcStaticPtrInfo1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tcStaticPtrInfo2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.297025164 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtrInfo_closure" {
     GHC.StaticPtr.$tcStaticPtrInfo_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tcStaticPtrInfo1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9809180260958205610;
         const 5820027882667808380;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.298906251 UTC

[section ""data" . $krep10_rfvly_closure" {
     $krep10_rfvly_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.StaticPtr.$tcStaticPtrInfo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.300616939 UTC

[section ""data" . $krep11_rfvlz_closure" {
     $krep11_rfvlz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rfvlv_closure+1;
         const $krep10_rfvly_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.30281641 UTC

[section ""data" . $krep12_rfvlA_closure" {
     $krep12_rfvlA_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rfvls_closure+1;
         const $krep11_rfvlz_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.304587594 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtrInfo1_closure" {
     GHC.StaticPtr.$tc'StaticPtrInfo1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rfvls_closure+1;
         const $krep12_rfvlA_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.306345853 UTC

[section ""cstring" . GHC.StaticPtr.$tc'StaticPtrInfo3_bytes" {
     GHC.StaticPtr.$tc'StaticPtrInfo3_bytes:
         I8[] [39,83,116,97,116,105,99,80,116,114,73,110,102,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.307994773 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtrInfo2_closure" {
     GHC.StaticPtr.$tc'StaticPtrInfo2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tc'StaticPtrInfo3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.309934653 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtrInfo_closure" {
     GHC.StaticPtr.$tc'StaticPtrInfo_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tc'StaticPtrInfo2_closure+1;
         const GHC.StaticPtr.$tc'StaticPtrInfo1_closure+4;
         const 12332739532642204119;
         const 17636067641148941699;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.311734297 UTC

[section ""cstring" . GHC.StaticPtr.$tcStaticPtr2_bytes" {
     GHC.StaticPtr.$tcStaticPtr2_bytes:
         I8[] [83,116,97,116,105,99,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.313483594 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtr1_closure" {
     GHC.StaticPtr.$tcStaticPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tcStaticPtr2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.315197956 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtr_closure" {
     GHC.StaticPtr.$tcStaticPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tcStaticPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 6538784347774135987;
         const 451387415853290179;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.316968616 UTC

[section ""data" . $krep13_rfvlB_closure" {
     $krep13_rfvlB_closure:
         const :_con_info;
         const $krep8_rfvlw_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.318699322 UTC

[section ""data" . $krep14_rfvlC_closure" {
     $krep14_rfvlC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.StaticPtr.$tcStaticPtr_closure+1;
         const $krep13_rfvlB_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.320479138 UTC

[section ""data" . $krep15_rfvlD_closure" {
     $krep15_rfvlD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rfvlw_closure+2;
         const $krep14_rfvlC_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.322186163 UTC

[section ""data" . $krep16_rfvlE_closure" {
     $krep16_rfvlE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rfvly_closure+1;
         const $krep15_rfvlD_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.32389349 UTC

[section ""data" . $krep17_rfvlF_closure" {
     $krep17_rfvlF_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_rfvlx_closure+1;
         const $krep16_rfvlE_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.32609189 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtr1_closure" {
     GHC.StaticPtr.$tc'StaticPtr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_rfvlx_closure+1;
         const $krep17_rfvlF_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.327746857 UTC

[section ""cstring" . GHC.StaticPtr.$tc'StaticPtr3_bytes" {
     GHC.StaticPtr.$tc'StaticPtr3_bytes:
         I8[] [39,83,116,97,116,105,99,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.329907379 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtr2_closure" {
     GHC.StaticPtr.$tc'StaticPtr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tc'StaticPtr3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.331482907 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtr_closure" {
     GHC.StaticPtr.$tc'StaticPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tc'StaticPtr2_closure+1;
         const GHC.StaticPtr.$tc'StaticPtr1_closure+4;
         const 3211798574336347514;
         const 9816765169815661376;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.333275731 UTC

[section ""cstring" . GHC.StaticPtr.$tcIsStatic3_bytes" {
     GHC.StaticPtr.$tcIsStatic3_bytes:
         I8[] [73,115,83,116,97,116,105,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.334851461 UTC

[section ""data" . GHC.StaticPtr.$tcIsStatic2_closure" {
     GHC.StaticPtr.$tcIsStatic2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tcIsStatic3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.336518327 UTC

[section ""data" . GHC.StaticPtr.$tcIsStatic_closure" {
     GHC.StaticPtr.$tcIsStatic_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tcIsStatic2_closure+1;
         const GHC.StaticPtr.$tcIsStatic1_closure+4;
         const 12653381617957437053;
         const 3253287492145771790;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.339577014 UTC

[section ""data" . GHC.StaticPtr.$wunsafeLookupStaticPtr_closure" {
     GHC.StaticPtr.$wunsafeLookupStaticPtr_closure:
         const GHC.StaticPtr.$wunsafeLookupStaticPtr_info;
 },
 GHC.StaticPtr.$wunsafeLookupStaticPtr_entry() //  [R2, R3]
         { info_tbl: [(cfvUQ,
                       label: GHC.StaticPtr.$wunsafeLookupStaticPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvUQ: // global
           _sfvnm::I64 = R3;
           _sfvnl::I64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cfvUR; else goto cfvUS;
       cfvUS: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cfvUU; else goto cfvUT;
       cfvUU: // global
           HpAlloc = 80;
           goto cfvUR;
       cfvUR: // global
           R3 = _sfvnm::I64;
           R2 = _sfvnl::I64;
           R1 = GHC.StaticPtr.$wunsafeLookupStaticPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfvUT: // global
           I64[Hp - 72] = GHC.Word.W64#_con_info;
           I64[Hp - 64] = _sfvnl::I64;
           I64[Hp - 56] = GHC.Word.W64#_con_info;
           I64[Hp - 48] = _sfvnm::I64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 55;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 38;
           I64[Sp - 16] = block_cfvUO_info;
           R3 = 0;
           _cfvUN::P64 = Hp - 14;
           R2 = _cfvUN::P64;
           P64[Sp - 8] = _cfvUN::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfvUO() //  [R1]
         { info_tbl: [(cfvUO,
                       label: block_cfvUO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvUO: // global
           I64[Sp] = block_cfvV1_info;
           R2 = 8;
           R1 = R1 << 3;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvV1() //  [R1]
         { info_tbl: [(cfvV1,
                       label: block_cfvV1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvV1: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _cfvVr() args: 0, res: 0, upd: 0;
     }
 },
 _cfvVr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvVr: // global
           _sfvnN::P64 = P64[Sp];
           I64[Sp] = block_cfvVu_info;
           R1 = _sfvnN::P64;
           if (R1 & 7 != 0) goto ufvVT; else goto cfvVw;
       ufvVT: // global
           call _cfvVu(R1) args: 0, res: 0, upd: 0;
       cfvVw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvVu() //  [R1]
         { info_tbl: [(cfvVu,
                       label: block_cfvVu_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvVu: // global
           if (R1 & 7 == 1) goto ufvVQ; else goto cfvVH;
       ufvVQ: // global
           Sp = Sp + 8;
           call _cfvVa() args: 0, res: 0, upd: 0;
       cfvVH: // global
           I64[Sp - 8] = block_cfvVF_info;
           _sfvnS::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sfvnS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvVU; else goto cfvVI;
       ufvVU: // global
           call _cfvVF(R1) args: 0, res: 0, upd: 0;
       cfvVI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvVa() //  []
         { info_tbl: [(cfvVa,
                       label: block_cfvVa_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvVa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfvVe; else goto cfvVd;
       cfvVe: // global
           HpAlloc = 16;
           I64[Sp] = block_cfvVa_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfvVd: // global
           _sfvnz::P64 = P64[Sp + 16];
           (_sfvnG::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] hs_spt_lookup(I64[Sp + 8]);
           call MO_Touch(_sfvnz::P64);
           if (_sfvnG::I64 == 0) goto cfvVo; else goto cfvVn;
       cfvVo: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfvVn: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           I64[Hp] = _sfvnG::I64;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfvVF() //  [R1]
         { info_tbl: [(cfvVF,
                       label: block_cfvVF_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvVF: // global
           _sfvnO::I64 = I64[Sp + 16];
           _sfvnS::P64 = P64[Sp + 8];
           I64[I64[Sp + 24] + (_sfvnO::I64 << 3)] = I64[R1 + 7];
           P64[Sp + 8] = _sfvnS::P64;
           I64[Sp + 16] = _sfvnO::I64 + 1;
           Sp = Sp + 8;
           call _cfvVr() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.354780782 UTC

[section ""data" . GHC.StaticPtr.unsafeLookupStaticPtr1_closure" {
     GHC.StaticPtr.unsafeLookupStaticPtr1_closure:
         const GHC.StaticPtr.unsafeLookupStaticPtr1_info;
 },
 GHC.StaticPtr.unsafeLookupStaticPtr1_entry() //  [R2]
         { info_tbl: [(cfvWE,
                       label: GHC.StaticPtr.unsafeLookupStaticPtr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvWE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfvWF; else goto cfvWG;
       cfvWF: // global
           R2 = R2;
           R1 = GHC.StaticPtr.unsafeLookupStaticPtr1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvWG: // global
           I64[Sp - 8] = block_cfvWB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvWK; else goto cfvWC;
       ufvWK: // global
           call _cfvWB(R1) args: 0, res: 0, upd: 0;
       cfvWC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvWB() //  [R1]
         { info_tbl: [(cfvWB,
                       label: block_cfvWB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvWB: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.StaticPtr.$wunsafeLookupStaticPtr_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.359938847 UTC

[section ""data" . GHC.StaticPtr.unsafeLookupStaticPtr_closure" {
     GHC.StaticPtr.unsafeLookupStaticPtr_closure:
         const GHC.StaticPtr.unsafeLookupStaticPtr_info;
 },
 GHC.StaticPtr.unsafeLookupStaticPtr_entry() //  [R2]
         { info_tbl: [(cfvWY,
                       label: GHC.StaticPtr.unsafeLookupStaticPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvWY: // global
           R2 = R2;
           call GHC.StaticPtr.unsafeLookupStaticPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.363752376 UTC

[section ""cstring" . lvl_rfvlG_bytes" {
     lvl_rfvlG_bytes:
         I8[] [71,72,67,47,83,116,97,116,105,99,80,116,114,46,104,115,58,49,51,49,58,52,49,45,55,57,124,108,97,109,98,100,97]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.365835732 UTC

[section ""data" . lvl1_rfvlH_closure" {
     lvl1_rfvlH_closure:
         const lvl1_rfvlH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rfvlH_entry() //  [R1]
         { info_tbl: [(cfvXc,
                       label: lvl1_rfvlH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvXc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfvXd; else goto cfvXe;
       cfvXd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvXe: // global
           (_cfvX9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfvX9::I64 == 0) goto cfvXb; else goto cfvXa;
       cfvXb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfvXa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfvX9::I64;
           R2 = lvl_rfvlG_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.37117366 UTC

[section ""data" . GHC.StaticPtr.staticPtrKeys2_closure" {
     GHC.StaticPtr.staticPtrKeys2_closure:
         const GHC.StaticPtr.staticPtrKeys2_info;
         const 0;
 },
 sat_sfvop_entry() //  [R1]
         { info_tbl: [(cfvYe,
                       label: sat_sfvop_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvYe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfvYi; else goto cfvYj;
       cfvYi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvYj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cfvYb_info;
           _sfvoe::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sfvoe::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufvYn; else goto cfvYc;
       ufvYn: // global
           call _cfvYb(R1) args: 0, res: 0, upd: 0;
       cfvYc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfvYb() //  [R1]
         { info_tbl: [(cfvYb,
                       label: block_cfvYb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvYb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfvYm; else goto cfvYl;
       cfvYm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cfvYl: // global
           _sfvoo::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _sfvoo::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.StaticPtr.staticPtrKeys2_entry() //  [R2]
         { info_tbl: [(cfvYs,
                       label: GHC.StaticPtr.staticPtrKeys2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvYs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfvYt; else goto cfvYu;
       cfvYt: // global
           R2 = R2;
           R1 = GHC.StaticPtr.staticPtrKeys2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfvYu: // global
           I64[Sp - 8] = block_cfvXq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvZd; else goto cfvXr;
       ufvZd: // global
           call _cfvXq(R1) args: 0, res: 0, upd: 0;
       cfvXr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvXq() //  [R1]
         { info_tbl: [(cfvXq,
                       label: block_cfvXq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvXq: // global
           if (R1 & 7 == 1) goto cfvYp; else goto cfvYq;
       cfvYp: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfvYq: // global
           P64[Sp - 24] = P64[R1 + 14];
           I64[Sp - 16] = 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 24;
           call _cfvXA() args: 0, res: 0, upd: 0;
     }
 },
 _cfvXA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvXA: // global
           _sfvo5::P64 = P64[Sp + 24];
           _sfvoy::I64 = I64[Sp + 8];
           if (_sfvoy::I64 != 0) goto cfvYT; else goto cfvYX;
       cfvYT: // global
           I64[Sp - 8] = block_cfvXF_info;
           R1 = _sfvo5::P64;
           I64[Sp + 8] = _sfvoy::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvZ6; else goto cfvXG;
       ufvZ6: // global
           call _cfvXF(R1) args: 0, res: 0, upd: 0;
       cfvXG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfvYX: // global
           I64[Sp - 8] = block_cfvXP_info;
           R1 = _sfvo5::P64;
           P64[Sp + 24] = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufvZ7; else goto cfvXQ;
       ufvZ7: // global
           call _cfvXP(R1) args: 0, res: 0, upd: 0;
       cfvXQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvXF() //  [R1]
         { info_tbl: [(cfvXF,
                       label: block_cfvXF_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvXF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfvYW; else goto cfvYV;
       cfvYW: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfvYV: // global
           _sfvoy::I64 = I64[Sp + 16];
           _sfvoD::I64 = I64[I64[R1 + 7] + (_sfvoy::I64 << 3)];
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = _sfvoD::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 16] = _sfvoy::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           Sp = Sp + 8;
           call _cfvXA() args: 0, res: 0, upd: 0;
     }
 },
 _cfvXP() //  [R1]
         { info_tbl: [(cfvXP,
                       label: block_cfvXP_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvXP: // global
           _sfvoe::I64 = I64[I64[R1 + 7]];
           I64[Sp] = block_cfvXU_info;
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sfvoe::I64;
           if (R1 & 7 != 0) goto ufvZ9; else goto cfvXV;
       ufvZ9: // global
           call _cfvXU(R1) args: 0, res: 0, upd: 0;
       cfvXV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvXU() //  [R1]
         { info_tbl: [(cfvXU,
                       label: block_cfvXU_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvXU: // global
           if (R1 & 7 == 1) goto ufvZ3; else goto cfvYF;
       ufvZ3: // global
           Sp = Sp + 40;
           call _cfvYQ() args: 0, res: 0, upd: 0;
       cfvYF: // global
           I64[Sp] = block_cfvY0_info;
           _sfvoh::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp + 24] = _sfvoh::P64;
           if (R1 & 7 != 0) goto ufvZa; else goto cfvY1;
       ufvZa: // global
           call _cfvY0(R1) args: 0, res: 0, upd: 0;
       cfvY1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvY0() //  [R1]
         { info_tbl: [(cfvY0,
                       label: block_cfvY0_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvY0: // global
           if (R1 & 7 == 1) goto cfvYJ; else goto ufvZ4;
       cfvYJ: // global
           I64[Sp + 16] = block_cfvY5_info;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.StaticPtr.staticPtrKeys2_entry(R2) args: 8, res: 8, upd: 8;
       ufvZ4: // global
           Sp = Sp + 40;
           call _cfvYQ() args: 0, res: 0, upd: 0;
     }
 },
 _cfvY5() //  [R1]
         { info_tbl: [(cfvY5,
                       label: block_cfvY5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvY5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfvYM; else goto cfvYL;
       cfvYM: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfvYL: // global
           I64[Hp - 48] = sat_sfvop_info;
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfvYQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvYQ: // global
           R1 = lvl1_rfvlH_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.394106904 UTC

[section ""data" . GHC.StaticPtr.staticPtrKeys1_closure" {
     GHC.StaticPtr.staticPtrKeys1_closure:
         const GHC.StaticPtr.staticPtrKeys1_info;
         const 0;
 },
 GHC.StaticPtr.staticPtrKeys1_entry() //  []
         { info_tbl: [(cfw0R,
                       label: GHC.StaticPtr.staticPtrKeys1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw0R: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfw0S; else goto cfw0T;
       cfw0S: // global
           R1 = GHC.StaticPtr.staticPtrKeys1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cfw0T: // global
           (_sfvoL::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] hs_spt_key_count();
           I64[Sp - 16] = block_cfw0p_info;
           R2 = 8;
           _sfvoM::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sfvoL::I64));
           R1 = _sfvoM::I64 << 3;
           I64[Sp - 8] = _sfvoM::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfw0p() //  [R1]
         { info_tbl: [(cfw0p,
                       label: block_cfw0p_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw0p: // global
           _sfvoU::I64 = R1 + 16;
           (_sfvoY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     ‘signed’]  result hints:  [‘signed’] hs_spt_keys(_sfvoU::I64, I64[Sp + 8]);
           _sfvoZ::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sfvoY::I64));
           if (%MO_S_Gt_W64(_sfvoZ::I64, 0)) goto cfw1d; else goto cfw1g;
       cfw1d: // global
           I64[Sp - 16] = _sfvoZ::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = _sfvoU::I64;
           P64[Sp + 8] = R1;
           Sp = Sp - 24;
           call _cfw0K() args: 0, res: 0, upd: 0;
       cfw1g: // global
           I64[Sp] = block_cfw1f_info;
           R2 = GHC.Types.[]_closure+1;
           P64[Sp + 8] = R1;
           call GHC.StaticPtr.staticPtrKeys2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfw0K() //  []
         { info_tbl: [(cfw0K,
                       label: block_cfw0K_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw0K: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfw18; else goto cfw17;
       cfw18: // global
           HpAlloc = 40;
           I64[Sp] = block_cfw0K_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfw17: // global
           _sfvpf::P64 = P64[Sp + 16];
           _sfvph::I64 = I64[Sp + 8];
           if (_sfvph::I64 != 0) goto cfw1a; else goto cfw1b;
       cfw1a: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 24] + (_sfvph::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sfvpf::P64;
           I64[Sp + 8] = _sfvph::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _cfw0K() args: 0, res: 0, upd: 0;
       cfw1b: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _sfvpf::P64;
           Sp = Sp + 16;
           call _cfw0W() args: 0, res: 0, upd: 0;
     }
 },
 _cfw0W() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw0W: // global
           Hp = Hp + 40;
           _sfvp2::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cfw13; else goto cfw12;
       cfw13: // global
           HpAlloc = 40;
           I64[Sp] = block_cfw0V_info;
           R1 = _sfvp2::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfw12: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 8]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sfvp2::P64;
           I64[Sp + 8] = block_cfw10_info;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.StaticPtr.staticPtrKeys2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfw0V() //  [R1]
         { info_tbl: [(cfw0V,
                       label: block_cfw0V_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw0V: // global
           P64[Sp] = R1;
           call _cfw0W() args: 0, res: 0, upd: 0;
     }
 },
 _cfw10() //  [R1]
         { info_tbl: [(cfw10,
                       label: block_cfw10_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw10: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfw1f() //  [R1]
         { info_tbl: [(cfw1f,
                       label: block_cfw1f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw1f: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.408852706 UTC

[section ""data" . GHC.StaticPtr.staticPtrKeys_closure" {
     GHC.StaticPtr.staticPtrKeys_closure:
         const GHC.StaticPtr.staticPtrKeys_info;
         const 0;
 },
 GHC.StaticPtr.staticPtrKeys_entry() //  []
         { info_tbl: [(cfw25,
                       label: GHC.StaticPtr.staticPtrKeys_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw25: // global
           call GHC.StaticPtr.staticPtrKeys1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.412358677 UTC

[section ""data" . GHC.StaticPtr.StaticPtr_closure" {
     GHC.StaticPtr.StaticPtr_closure:
         const GHC.StaticPtr.StaticPtr_info;
 },
 GHC.StaticPtr.StaticPtr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw2d: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.StaticPtr.StaticPtr_entry(R5,
                                              R4,
                                              R3,
                                              R2,
                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.StaticPtr.StaticPtr_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfw2i,
                       label: GHC.StaticPtr.StaticPtr_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw2i: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfw2m; else goto cfw2l;
       cfw2m: // global
           HpAlloc = 40;
           R1 = GHC.StaticPtr.StaticPtr_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cfw2l: // global
           I64[Hp - 32] = GHC.StaticPtr.StaticPtr_con_info;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.417763017 UTC

[section ""data" . GHC.StaticPtr.StaticPtrInfo_closure" {
     GHC.StaticPtr.StaticPtrInfo_closure:
         const GHC.StaticPtr.StaticPtrInfo_info;
 },
 GHC.StaticPtr.StaticPtrInfo_entry() //  [R2, R3, R4]
         { info_tbl: [(cfw2z,
                       label: GHC.StaticPtr.StaticPtrInfo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw2z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfw2D; else goto cfw2C;
       cfw2D: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.StaticPtrInfo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfw2C: // global
           I64[Hp - 24] = GHC.StaticPtr.StaticPtrInfo_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.421508997 UTC

[GHC.StaticPtr.StaticPtr_con_entry() //  [R1]
         { info_tbl: [(cfw2J,
                       label: GHC.StaticPtr.StaticPtr_con_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,105,99,80,116,114,46,83,116,97,116,105,99,80,116,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw2J: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.42480967 UTC

[GHC.StaticPtr.StaticPtrInfo_con_entry() //  [R1]
         { info_tbl: [(cfw2P,
                       label: GHC.StaticPtr.StaticPtrInfo_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,105,99,80,116,114,46,83,116,97,116,105,99,80,116,114,73,110,102,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw2P: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.427979989 UTC

[section ""relreadonly" . SfvsE_srt" {
     SfvsE_srt:
         const GHC.Show.$fShow(,)_go1_closure;
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Show.showLitString_closure;
         const GHC.StaticPtr.$w$cshowsPrec_closure;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure;
         const GHC.StaticPtr.$fShowStaticPtrInfo1_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.StaticPtr.staticPtrKeys2_closure;
         const lvl1_rfvlH_closure;
         const GHC.StaticPtr.staticPtrKeys1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.983935316 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:13.985596378 UTC

[section ""data" . GHC.StaticPtr.fromStaticPtr_closure" {
     GHC.StaticPtr.fromStaticPtr_closure:
         const GHC.StaticPtr.fromStaticPtr_info;
 },
 GHC.StaticPtr.fromStaticPtr_entry() //  [R2]
         { info_tbl: [(cfw6K,
                       label: GHC.StaticPtr.fromStaticPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw6K: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.992264456 UTC

[section ""data" . GHC.StaticPtr.$fIsStaticStaticPtr_closure" {
     GHC.StaticPtr.$fIsStaticStaticPtr_closure:
         const GHC.StaticPtr.$fIsStaticStaticPtr_info;
 },
 GHC.StaticPtr.$fIsStaticStaticPtr_entry() //  [R2]
         { info_tbl: [(cfw6V,
                       label: GHC.StaticPtr.$fIsStaticStaticPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw6V: // global
           R2 = R2;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.99557555 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo6_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo6_bytes:
         I8[] [83,116,97,116,105,99,80,116,114,73,110,102,111,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.997320523 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo5_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo5_bytes:
         I8[] [115,112,73,110,102,111,85,110,105,116,73,100,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:13.999008223 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo4_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo4_bytes:
         I8[] [115,112,73,110,102,111,77,111,100,117,108,101,78,97,109,101,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.000680388 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo3_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo3_bytes:
         I8[] [115,112,73,110,102,111,83,114,99,76,111,99,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.002342319 UTC

[section ""cstring" . GHC.StaticPtr.$fShowStaticPtrInfo2_bytes" {
     GHC.StaticPtr.$fShowStaticPtrInfo2_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.007766581 UTC

[section ""data" . GHC.StaticPtr.$w$cshowsPrec_closure" {
     GHC.StaticPtr.$w$cshowsPrec_closure:
         const GHC.StaticPtr.$w$cshowsPrec_info;
         const 0;
 },
 GHC.StaticPtr.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw78: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfw3n_entry() //  [R1]
         { info_tbl: [(cfw80,
                       label: sat_sfw3n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw80: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfw81; else goto cfw82;
       cfw81: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfw82: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfw3k_entry() //  [R1, R2]
         { info_tbl: [(cfw8c,
                       label: sat_sfw3k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw8c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfw8i; else goto cfw8j;
       cfw8i: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfw8j: // global
           I64[Sp - 16] = block_cfw89_info;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufw8o; else goto cfw8a;
       ufw8o: // global
           call _cfw89(R1) args: 0, res: 0, upd: 0;
       cfw8a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfw89() //  [R1]
         { info_tbl: [(cfw89,
                       label: block_cfw89_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw89: // global
           _sfw3e::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cfw8f_info;
           R4 = _sfw3e::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfw8f() //  [R1, R2]
         { info_tbl: [(cfw8f,
                       label: block_cfw8f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw8f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfw8n; else goto cfw8m;
       cfw8n: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cfw8m: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfw3d_entry() //  [R1, R2]
         { info_tbl: [(cfw8y,
                       label: sat_sfw3d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw8y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfw8E; else goto cfw8F;
       cfw8E: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfw8F: // global
           I64[Sp - 16] = block_cfw8v_info;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufw8K; else goto cfw8w;
       ufw8K: // global
           call _cfw8v(R1) args: 0, res: 0, upd: 0;
       cfw8w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfw8v() //  [R1]
         { info_tbl: [(cfw8v,
                       label: block_cfw8v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw8v: // global
           _sfw37::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cfw8B_info;
           R4 = _sfw37::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfw8B() //  [R1, R2]
         { info_tbl: [(cfw8B,
                       label: block_cfw8B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw8B: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfw8J; else goto cfw8I;
       cfw8J: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cfw8I: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfw3p_entry() //  [R1]
         { info_tbl: [(cfw8M,
                       label: sat_sfw3p_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw8M: // global
           _sfw3p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfw8N; else goto cfw8O;
       cfw8O: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cfw8Q; else goto cfw8P;
       cfw8Q: // global
           HpAlloc = 128;
           goto cfw8N;
       cfw8N: // global
           R1 = _sfw3p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfw8P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfw3p::P64;
           _sfw33::P64 = P64[_sfw3p::P64 + 16];
           _sfw35::P64 = P64[_sfw3p::P64 + 24];
           _sfw36::P64 = P64[_sfw3p::P64 + 32];
           I64[Hp - 120] = sat_sfw3n_info;
           P64[Hp - 104] = _sfw33::P64;
           I64[Hp - 96] = :_con_info;
           P64[Hp - 88] = GHC.Show.$fShow(,)2_closure;
           P64[Hp - 80] = Hp - 120;
           I64[Hp - 72] = sat_sfw3k_info;
           P64[Hp - 64] = _sfw36::P64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           I64[Hp - 32] = sat_sfw3d_info;
           P64[Hp - 24] = _sfw35::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 54;
           R3 = Hp - 94;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Show.$fShow(,)_go1_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfw3q_entry() //  [R1]
         { info_tbl: [(cfw8R,
                       label: sat_sfw3q_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw8R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfw8T; else goto cfw8U;
       cfw8T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfw8U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cfw7N_info;
           _sfw33::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sfw33::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufw8Y; else goto cfw7O;
       ufw8Y: // global
           call _cfw7N(R1) args: 0, res: 0, upd: 0;
       cfw7O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfw7N() //  [R1]
         { info_tbl: [(cfw7N,
                       label: block_cfw7N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw7N: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfw8X; else goto cfw8W;
       cfw8X: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cfw8W: // global
           _sfw35::P64 = P64[R1 + 7];
           _sfw36::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sfw3p_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sfw35::P64;
           P64[Hp - 24] = _sfw36::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfw3r_entry() //  [R1]
         { info_tbl: [(cfw8Z,
                       label: sat_sfw3r_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw8Z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfw93; else goto cfw92;
       cfw93: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfw92: // global
           _sfw30::P64 = P64[R1 + 16];
           _sfw33::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sfw3q_info;
           P64[Hp - 8] = _sfw30::P64;
           P64[Hp] = _sfw33::P64;
           R3 = Hp - 24;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfw3s_entry() //  [R1]
         { info_tbl: [(cfw94,
                       label: sat_sfw3s_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw94: // global
           _sfw3s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfw95; else goto cfw96;
       cfw96: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfw98; else goto cfw97;
       cfw98: // global
           HpAlloc = 32;
           goto cfw95;
       cfw95: // global
           R1 = _sfw3s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfw97: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfw3s::P64;
           _sfw30::P64 = P64[_sfw3s::P64 + 16];
           _sfw33::P64 = P64[_sfw3s::P64 + 24];
           I64[Hp - 24] = sat_sfw3r_info;
           P64[Hp - 8] = _sfw30::P64;
           P64[Hp] = _sfw33::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfw3u_entry() //  [R1]
         { info_tbl: [(cfw9a,
                       label: sat_sfw3u_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw9a: // global
           _sfw3u::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfw9b; else goto cfw9c;
       cfw9c: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfw9e; else goto cfw9d;
       cfw9e: // global
           HpAlloc = 56;
           goto cfw9b;
       cfw9b: // global
           R1 = _sfw3u::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfw9d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfw3u::P64;
           _sfw2Z::P64 = P64[_sfw3u::P64 + 16];
           _sfw30::P64 = P64[_sfw3u::P64 + 24];
           _sfw33::P64 = P64[_sfw3u::P64 + 32];
           I64[Hp - 48] = sat_sfw3s_info;
           P64[Hp - 32] = _sfw30::P64;
           P64[Hp - 24] = _sfw33::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sfw2Z::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfw3w_entry() //  [R1]
         { info_tbl: [(cfw9g,
                       label: sat_sfw3w_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw9g: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfw9k; else goto cfw9j;
       cfw9k: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfw9j: // global
           _sfw2Z::P64 = P64[R1 + 16];
           _sfw30::P64 = P64[R1 + 24];
           _sfw33::P64 = P64[R1 + 32];
           I64[Hp - 56] = sat_sfw3u_info;
           P64[Hp - 40] = _sfw2Z::P64;
           P64[Hp - 32] = _sfw30::P64;
           P64[Hp - 24] = _sfw33::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfw3x_entry() //  [R1]
         { info_tbl: [(cfw9l,
                       label: sat_sfw3x_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw9l: // global
           _sfw3x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfw9m; else goto cfw9n;
       cfw9n: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfw9p; else goto cfw9o;
       cfw9p: // global
           HpAlloc = 40;
           goto cfw9m;
       cfw9m: // global
           R1 = _sfw3x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfw9o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfw3x::P64;
           _sfw2Z::P64 = P64[_sfw3x::P64 + 16];
           _sfw30::P64 = P64[_sfw3x::P64 + 24];
           _sfw33::P64 = P64[_sfw3x::P64 + 32];
           I64[Hp - 32] = sat_sfw3w_info;
           P64[Hp - 16] = _sfw2Z::P64;
           P64[Hp - 8] = _sfw30::P64;
           P64[Hp] = _sfw33::P64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfw3z_entry() //  [R1]
         { info_tbl: [(cfw9r,
                       label: sat_sfw3z_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw9r: // global
           _sfw3z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfw9s; else goto cfw9t;
       cfw9t: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfw9v; else goto cfw9u;
       cfw9v: // global
           HpAlloc = 64;
           goto cfw9s;
       cfw9s: // global
           R1 = _sfw3z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfw9u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfw3z::P64;
           _sfw2Y::P64 = P64[_sfw3z::P64 + 16];
           _sfw2Z::P64 = P64[_sfw3z::P64 + 24];
           _sfw30::P64 = P64[_sfw3z::P64 + 32];
           _sfw33::P64 = P64[_sfw3z::P64 + 40];
           I64[Hp - 56] = sat_sfw3x_info;
           P64[Hp - 40] = _sfw2Z::P64;
           P64[Hp - 32] = _sfw30::P64;
           P64[Hp - 24] = _sfw33::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sfw2Y::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfw3B_entry() //  [R1]
         { info_tbl: [(cfw9x,
                       label: sat_sfw3B_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw9x: // global
           _sfw3B::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfw9y; else goto cfw9z;
       cfw9z: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfw9B; else goto cfw9A;
       cfw9B: // global
           HpAlloc = 72;
           goto cfw9y;
       cfw9y: // global
           R1 = _sfw3B::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfw9A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfw3B::P64;
           _sfw2Y::P64 = P64[_sfw3B::P64 + 16];
           _sfw2Z::P64 = P64[_sfw3B::P64 + 24];
           _sfw30::P64 = P64[_sfw3B::P64 + 32];
           _sfw33::P64 = P64[_sfw3B::P64 + 40];
           I64[Hp - 64] = sat_sfw3z_info;
           P64[Hp - 48] = _sfw2Y::P64;
           P64[Hp - 40] = _sfw2Z::P64;
           P64[Hp - 32] = _sfw30::P64;
           P64[Hp - 24] = _sfw33::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_sfw32_entry() //  [R1, R2]
         { info_tbl: [(cfw9C,
                       label: p_sfw32_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw9C: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfw9G; else goto cfw9F;
       cfw9G: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfw9F: // global
           _sfw2Y::P64 = P64[R1 + 7];
           _sfw2Z::P64 = P64[R1 + 15];
           _sfw30::P64 = P64[R1 + 23];
           I64[Hp - 40] = sat_sfw3B_info;
           P64[Hp - 24] = _sfw2Y::P64;
           P64[Hp - 16] = _sfw2Z::P64;
           P64[Hp - 8] = _sfw30::P64;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo6_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfw3E_entry() //  [R1]
         { info_tbl: [(cfw9Q,
                       label: sat_sfw3E_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw9Q: // global
           _sfw3E::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfw9R; else goto cfw9S;
       cfw9S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfw9U; else goto cfw9T;
       cfw9U: // global
           HpAlloc = 24;
           goto cfw9R;
       cfw9R: // global
           R1 = _sfw3E::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfw9T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfw3E::P64;
           _sfw31::P64 = P64[_sfw3E::P64 + 16];
           _sfw32::P64 = P64[_sfw3E::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sfw31::P64;
           R2 = Hp - 14;
           R1 = _sfw32::P64;
           Sp = Sp - 16;
           call p_sfw32_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.StaticPtr.$w$cshowsPrec_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfw9Y,
                       label: GHC.StaticPtr.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [True, False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfw9Y: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cfwa2; else goto cfwa1;
       cfwa2: // global
           HpAlloc = 88;
           R1 = GHC.StaticPtr.$w$cshowsPrec_closure;
           I64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cfwa1: // global
           I64[Hp - 80] = p_sfw32_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           _cfw7c::P64 = Hp - 79;
           if (%MO_S_Lt_W64(R2, 11)) goto cfw9W; else goto cfw9X;
       cfw9W: // global
           Hp = Hp - 56;
           R2 = R6;
           R1 = _cfw7c::P64;
           call p_sfw32_entry(R2, R1) args: 8, res: 0, upd: 8;
       cfw9X: // global
           I64[Hp - 48] = sat_sfw3E_info;
           P64[Hp - 32] = R6;
           P64[Hp - 24] = _cfw7c::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.060980965 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cfwcu,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwcu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfwcy; else goto cfwcz;
       cfwcy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwcz: // global
           I64[Sp - 24] = block_cfwcr_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufwcH; else goto cfwcs;
       ufwcH: // global
           call _cfwcr(R1) args: 0, res: 0, upd: 0;
       cfwcs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwcr() //  [R1]
         { info_tbl: [(cfwcr,
                       label: block_cfwcr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwcr: // global
           I64[Sp] = block_cfwcx_info;
           _sfw3J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sfw3J::I64;
           if (R1 & 7 != 0) goto ufwcG; else goto cfwcB;
       ufwcG: // global
           call _cfwcx(R1) args: 0, res: 0, upd: 0;
       cfwcB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwcx() //  [R1]
         { info_tbl: [(cfwcx,
                       label: block_cfwcx_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwcx: // global
           R6 = P64[Sp + 16];
           R5 = P64[R1 + 23];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.069052549 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo7_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo7_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.071336595 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_entry() //  [R2]
         { info_tbl: [(cfwd5,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwd5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfwd6; else goto cfwd7;
       cfwd6: // global
           R2 = R2;
           R1 = GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfwd7: // global
           I64[Sp - 8] = block_cfwd2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwdb; else goto cfwd3;
       ufwdb: // global
           call _cfwd2(R1) args: 0, res: 0, upd: 0;
       cfwd3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwd2() //  [R1]
         { info_tbl: [(cfwd2,
                       label: block_cfwd2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwd2: // global
           R6 = GHC.Types.[]_closure+1;
           R5 = P64[R1 + 23];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.078721183 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo1_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo1_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo1_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo1_entry() //  [R2, R3]
         { info_tbl: [(cfwdu,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwdu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwdv; else goto cfwdw;
       cfwdv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.$fShowStaticPtrInfo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwdw: // global
           I64[Sp - 16] = block_cfwdr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufwdA; else goto cfwds;
       ufwdA: // global
           call _cfwdr(R1) args: 0, res: 0, upd: 0;
       cfwds: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwdr() //  [R1]
         { info_tbl: [(cfwdr,
                       label: block_cfwdr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwdr: // global
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 23];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.StaticPtr.$w$cshowsPrec_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.084967534 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_closure:
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_info;
         const 0;
 },
 GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cfwdP,
                       label: GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwdP: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.StaticPtr.$fShowStaticPtrInfo1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.088614975 UTC

[section ""data" . GHC.StaticPtr.$fShowStaticPtrInfo_closure" {
     GHC.StaticPtr.$fShowStaticPtrInfo_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure+3;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure+1;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.090773521 UTC

[section ""data" . GHC.StaticPtr.spInfoSrcLoc_closure" {
     GHC.StaticPtr.spInfoSrcLoc_closure:
         const GHC.StaticPtr.spInfoSrcLoc_info;
 },
 GHC.StaticPtr.spInfoSrcLoc_entry() //  [R2]
         { info_tbl: [(cfwe4,
                       label: GHC.StaticPtr.spInfoSrcLoc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwe4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfwe5; else goto cfwe6;
       cfwe5: // global
           R2 = R2;
           R1 = GHC.StaticPtr.spInfoSrcLoc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfwe6: // global
           I64[Sp - 8] = block_cfwe1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwea; else goto cfwe2;
       ufwea: // global
           call _cfwe1(R1) args: 0, res: 0, upd: 0;
       cfwe2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwe1() //  [R1]
         { info_tbl: [(cfwe1,
                       label: block_cfwe1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwe1: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.096569061 UTC

[section ""data" . GHC.StaticPtr.spInfoModuleName_closure" {
     GHC.StaticPtr.spInfoModuleName_closure:
         const GHC.StaticPtr.spInfoModuleName_info;
 },
 GHC.StaticPtr.spInfoModuleName_entry() //  [R2]
         { info_tbl: [(cfweu,
                       label: GHC.StaticPtr.spInfoModuleName_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfweu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfwev; else goto cfwew;
       cfwev: // global
           R2 = R2;
           R1 = GHC.StaticPtr.spInfoModuleName_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfwew: // global
           I64[Sp - 8] = block_cfwer_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufweA; else goto cfwes;
       ufweA: // global
           call _cfwer(R1) args: 0, res: 0, upd: 0;
       cfwes: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwer() //  [R1]
         { info_tbl: [(cfwer,
                       label: block_cfwer_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwer: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.102686631 UTC

[section ""data" . GHC.StaticPtr.spInfoUnitId_closure" {
     GHC.StaticPtr.spInfoUnitId_closure:
         const GHC.StaticPtr.spInfoUnitId_info;
 },
 GHC.StaticPtr.spInfoUnitId_entry() //  [R2]
         { info_tbl: [(cfweU,
                       label: GHC.StaticPtr.spInfoUnitId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfweU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfweV; else goto cfweW;
       cfweV: // global
           R2 = R2;
           R1 = GHC.StaticPtr.spInfoUnitId_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfweW: // global
           I64[Sp - 8] = block_cfweR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwf0; else goto cfweS;
       ufwf0: // global
           call _cfweR(R1) args: 0, res: 0, upd: 0;
       cfweS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfweR() //  [R1]
         { info_tbl: [(cfweR,
                       label: block_cfweR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfweR: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.108510576 UTC

[section ""data" . GHC.StaticPtr.deRefStaticPtr_closure" {
     GHC.StaticPtr.deRefStaticPtr_closure:
         const GHC.StaticPtr.deRefStaticPtr_info;
 },
 GHC.StaticPtr.deRefStaticPtr_entry() //  [R2]
         { info_tbl: [(cfwfk,
                       label: GHC.StaticPtr.deRefStaticPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwfk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfwfl; else goto cfwfm;
       cfwfl: // global
           R2 = R2;
           R1 = GHC.StaticPtr.deRefStaticPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfwfm: // global
           I64[Sp - 8] = block_cfwfh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwfq; else goto cfwfi;
       ufwfq: // global
           call _cfwfh(R1) args: 0, res: 0, upd: 0;
       cfwfi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwfh() //  [R1]
         { info_tbl: [(cfwfh,
                       label: block_cfwfh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwfh: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.115407838 UTC

[section ""data" . GHC.StaticPtr.staticKey_closure" {
     GHC.StaticPtr.staticKey_closure:
         const GHC.StaticPtr.staticKey_info;
 },
 GHC.StaticPtr.staticKey_entry() //  [R2]
         { info_tbl: [(cfwfI,
                       label: GHC.StaticPtr.staticKey_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwfI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfwfM; else goto cfwfN;
       cfwfM: // global
           R2 = R2;
           R1 = GHC.StaticPtr.staticKey_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfwfN: // global
           I64[Sp - 8] = block_cfwfF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwfR; else goto cfwfG;
       ufwfR: // global
           call _cfwfF(R1) args: 0, res: 0, upd: 0;
       cfwfG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwfF() //  [R1]
         { info_tbl: [(cfwfF,
                       label: block_cfwfF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwfF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfwfQ; else goto cfwfP;
       cfwfQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfwfP: // global
           _sfw4o::I64 = I64[R1 + 23];
           _sfw4p::I64 = I64[R1 + 31];
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = _sfw4o::I64;
           I64[Hp] = _sfw4p::I64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.121712838 UTC

[section ""data" . GHC.StaticPtr.staticPtrInfo_closure" {
     GHC.StaticPtr.staticPtrInfo_closure:
         const GHC.StaticPtr.staticPtrInfo_info;
 },
 GHC.StaticPtr.staticPtrInfo_entry() //  [R2]
         { info_tbl: [(cfwgb,
                       label: GHC.StaticPtr.staticPtrInfo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwgb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfwgc; else goto cfwgd;
       cfwgc: // global
           R2 = R2;
           R1 = GHC.StaticPtr.staticPtrInfo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfwgd: // global
           I64[Sp - 8] = block_cfwg8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwgh; else goto cfwg9;
       ufwgh: // global
           call _cfwg8(R1) args: 0, res: 0, upd: 0;
       cfwg9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwg8() //  [R1]
         { info_tbl: [(cfwg8,
                       label: block_cfwg8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwg8: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.127288381 UTC

[section ""cstring" . GHC.StaticPtr.$trModule4_bytes" {
     GHC.StaticPtr.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.129132849 UTC

[section ""data" . GHC.StaticPtr.$trModule3_closure" {
     GHC.StaticPtr.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.131048235 UTC

[section ""cstring" . GHC.StaticPtr.$trModule2_bytes" {
     GHC.StaticPtr.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,116,105,99,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.132921615 UTC

[section ""data" . GHC.StaticPtr.$trModule1_closure" {
     GHC.StaticPtr.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.135015499 UTC

[section ""data" . GHC.StaticPtr.$trModule_closure" {
     GHC.StaticPtr.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.StaticPtr.$trModule3_closure+1;
         const GHC.StaticPtr.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.136931451 UTC

[section ""data" . $krep_rfvlo_closure" {
     $krep_rfvlo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.13888694 UTC

[section ""data" . $krep1_rfvlp_closure" {
     $krep1_rfvlp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.140682475 UTC

[section ""data" . $krep2_rfvlq_closure" {
     $krep2_rfvlq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.143252139 UTC

[section ""data" . $krep3_rfvlr_closure" {
     $krep3_rfvlr_closure:
         const :_con_info;
         const $krep1_rfvlp_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.14510283 UTC

[section ""data" . $krep4_rfvls_closure" {
     $krep4_rfvls_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_rfvlr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.14736742 UTC

[section ""data" . $krep5_rfvlt_closure" {
     $krep5_rfvlt_closure:
         const :_con_info;
         const $krep_rfvlo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.149228118 UTC

[section ""data" . $krep6_rfvlu_closure" {
     $krep6_rfvlu_closure:
         const :_con_info;
         const $krep_rfvlo_closure+1;
         const $krep5_rfvlt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.151113006 UTC

[section ""data" . $krep7_rfvlv_closure" {
     $krep7_rfvlv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep6_rfvlu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.153057502 UTC

[section ""data" . GHC.StaticPtr.$tcIsStatic1_closure" {
     GHC.StaticPtr.$tcIsStatic1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep2_rfvlq_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.154934419 UTC

[section ""data" . $krep8_rfvlw_closure" {
     $krep8_rfvlw_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.156749711 UTC

[section ""data" . $krep9_rfvlx_closure" {
     $krep9_rfvlx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.158950463 UTC

[section ""cstring" . GHC.StaticPtr.$tcStaticPtrInfo2_bytes" {
     GHC.StaticPtr.$tcStaticPtrInfo2_bytes:
         I8[] [83,116,97,116,105,99,80,116,114,73,110,102,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.160777148 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtrInfo1_closure" {
     GHC.StaticPtr.$tcStaticPtrInfo1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tcStaticPtrInfo2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.162708229 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtrInfo_closure" {
     GHC.StaticPtr.$tcStaticPtrInfo_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tcStaticPtrInfo1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9809180260958205610;
         const 5820027882667808380;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.16479897 UTC

[section ""data" . $krep10_rfvly_closure" {
     $krep10_rfvly_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.StaticPtr.$tcStaticPtrInfo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.166736088 UTC

[section ""data" . $krep11_rfvlz_closure" {
     $krep11_rfvlz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rfvlv_closure+1;
         const $krep10_rfvly_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.16876577 UTC

[section ""data" . $krep12_rfvlA_closure" {
     $krep12_rfvlA_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rfvls_closure+1;
         const $krep11_rfvlz_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.171693117 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtrInfo1_closure" {
     GHC.StaticPtr.$tc'StaticPtrInfo1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rfvls_closure+1;
         const $krep12_rfvlA_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.17373086 UTC

[section ""cstring" . GHC.StaticPtr.$tc'StaticPtrInfo3_bytes" {
     GHC.StaticPtr.$tc'StaticPtrInfo3_bytes:
         I8[] [39,83,116,97,116,105,99,80,116,114,73,110,102,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.175460788 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtrInfo2_closure" {
     GHC.StaticPtr.$tc'StaticPtrInfo2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tc'StaticPtrInfo3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.177386021 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtrInfo_closure" {
     GHC.StaticPtr.$tc'StaticPtrInfo_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tc'StaticPtrInfo2_closure+1;
         const GHC.StaticPtr.$tc'StaticPtrInfo1_closure+4;
         const 12332739532642204119;
         const 17636067641148941699;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.179398604 UTC

[section ""cstring" . GHC.StaticPtr.$tcStaticPtr2_bytes" {
     GHC.StaticPtr.$tcStaticPtr2_bytes:
         I8[] [83,116,97,116,105,99,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.181657323 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtr1_closure" {
     GHC.StaticPtr.$tcStaticPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tcStaticPtr2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.183506119 UTC

[section ""data" . GHC.StaticPtr.$tcStaticPtr_closure" {
     GHC.StaticPtr.$tcStaticPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tcStaticPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 6538784347774135987;
         const 451387415853290179;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.185572664 UTC

[section ""data" . $krep13_rfvlB_closure" {
     $krep13_rfvlB_closure:
         const :_con_info;
         const $krep8_rfvlw_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.187519368 UTC

[section ""data" . $krep14_rfvlC_closure" {
     $krep14_rfvlC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.StaticPtr.$tcStaticPtr_closure+1;
         const $krep13_rfvlB_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.189424758 UTC

[section ""data" . $krep15_rfvlD_closure" {
     $krep15_rfvlD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rfvlw_closure+2;
         const $krep14_rfvlC_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.191253139 UTC

[section ""data" . $krep16_rfvlE_closure" {
     $krep16_rfvlE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rfvly_closure+1;
         const $krep15_rfvlD_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.193234725 UTC

[section ""data" . $krep17_rfvlF_closure" {
     $krep17_rfvlF_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_rfvlx_closure+1;
         const $krep16_rfvlE_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.195429106 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtr1_closure" {
     GHC.StaticPtr.$tc'StaticPtr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_rfvlx_closure+1;
         const $krep17_rfvlF_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.197358661 UTC

[section ""cstring" . GHC.StaticPtr.$tc'StaticPtr3_bytes" {
     GHC.StaticPtr.$tc'StaticPtr3_bytes:
         I8[] [39,83,116,97,116,105,99,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.199207674 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtr2_closure" {
     GHC.StaticPtr.$tc'StaticPtr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tc'StaticPtr3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.201773359 UTC

[section ""data" . GHC.StaticPtr.$tc'StaticPtr_closure" {
     GHC.StaticPtr.$tc'StaticPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tc'StaticPtr2_closure+1;
         const GHC.StaticPtr.$tc'StaticPtr1_closure+4;
         const 3211798574336347514;
         const 9816765169815661376;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.203751687 UTC

[section ""cstring" . GHC.StaticPtr.$tcIsStatic3_bytes" {
     GHC.StaticPtr.$tcIsStatic3_bytes:
         I8[] [73,115,83,116,97,116,105,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.205652704 UTC

[section ""data" . GHC.StaticPtr.$tcIsStatic2_closure" {
     GHC.StaticPtr.$tcIsStatic2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.StaticPtr.$tcIsStatic3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.207540926 UTC

[section ""data" . GHC.StaticPtr.$tcIsStatic_closure" {
     GHC.StaticPtr.$tcIsStatic_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.StaticPtr.$trModule_closure+1;
         const GHC.StaticPtr.$tcIsStatic2_closure+1;
         const GHC.StaticPtr.$tcIsStatic1_closure+4;
         const 12653381617957437053;
         const 3253287492145771790;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.21175622 UTC

[section ""data" . GHC.StaticPtr.$wunsafeLookupStaticPtr_closure" {
     GHC.StaticPtr.$wunsafeLookupStaticPtr_closure:
         const GHC.StaticPtr.$wunsafeLookupStaticPtr_info;
 },
 GHC.StaticPtr.$wunsafeLookupStaticPtr_entry() //  [R2, R3]
         { info_tbl: [(cfwhj,
                       label: GHC.StaticPtr.$wunsafeLookupStaticPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwhj: // global
           _sfw4z::I64 = R3;
           _sfw4y::I64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cfwhk; else goto cfwhl;
       cfwhl: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cfwhn; else goto cfwhm;
       cfwhn: // global
           HpAlloc = 80;
           goto cfwhk;
       cfwhk: // global
           R3 = _sfw4z::I64;
           R2 = _sfw4y::I64;
           R1 = GHC.StaticPtr.$wunsafeLookupStaticPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwhm: // global
           I64[Hp - 72] = GHC.Word.W64#_con_info;
           I64[Hp - 64] = _sfw4y::I64;
           I64[Hp - 56] = GHC.Word.W64#_con_info;
           I64[Hp - 48] = _sfw4z::I64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 55;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 38;
           I64[Sp - 16] = block_cfwhh_info;
           R3 = 0;
           _cfwhg::P64 = Hp - 14;
           R2 = _cfwhg::P64;
           P64[Sp - 8] = _cfwhg::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfwhh() //  [R1]
         { info_tbl: [(cfwhh,
                       label: block_cfwhh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwhh: // global
           I64[Sp] = block_cfwhu_info;
           R2 = 8;
           R1 = R1 << 3;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwhu() //  [R1]
         { info_tbl: [(cfwhu,
                       label: block_cfwhu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwhu: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _cfwhU() args: 0, res: 0, upd: 0;
     }
 },
 _cfwhU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwhU: // global
           _sfw50::P64 = P64[Sp];
           I64[Sp] = block_cfwhX_info;
           R1 = _sfw50::P64;
           if (R1 & 7 != 0) goto ufwim; else goto cfwhZ;
       ufwim: // global
           call _cfwhX(R1) args: 0, res: 0, upd: 0;
       cfwhZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwhX() //  [R1]
         { info_tbl: [(cfwhX,
                       label: block_cfwhX_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwhX: // global
           if (R1 & 7 == 1) goto ufwij; else goto cfwia;
       ufwij: // global
           Sp = Sp + 8;
           call _cfwhD() args: 0, res: 0, upd: 0;
       cfwia: // global
           I64[Sp - 8] = block_cfwi8_info;
           _sfw55::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sfw55::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwin; else goto cfwib;
       ufwin: // global
           call _cfwi8(R1) args: 0, res: 0, upd: 0;
       cfwib: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwhD() //  []
         { info_tbl: [(cfwhD,
                       label: block_cfwhD_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwhD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfwhH; else goto cfwhG;
       cfwhH: // global
           HpAlloc = 16;
           I64[Sp] = block_cfwhD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfwhG: // global
           _sfw4M::P64 = P64[Sp + 16];
           (_sfw4T::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] hs_spt_lookup(I64[Sp + 8]);
           call MO_Touch(_sfw4M::P64);
           if (_sfw4T::I64 == 0) goto cfwhR; else goto cfwhQ;
       cfwhR: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfwhQ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           I64[Hp] = _sfw4T::I64;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfwi8() //  [R1]
         { info_tbl: [(cfwi8,
                       label: block_cfwi8_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwi8: // global
           _sfw51::I64 = I64[Sp + 16];
           _sfw55::P64 = P64[Sp + 8];
           I64[I64[Sp + 24] + (_sfw51::I64 << 3)] = I64[R1 + 7];
           P64[Sp + 8] = _sfw55::P64;
           I64[Sp + 16] = _sfw51::I64 + 1;
           Sp = Sp + 8;
           call _cfwhU() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.228933895 UTC

[section ""data" . GHC.StaticPtr.unsafeLookupStaticPtr1_closure" {
     GHC.StaticPtr.unsafeLookupStaticPtr1_closure:
         const GHC.StaticPtr.unsafeLookupStaticPtr1_info;
 },
 GHC.StaticPtr.unsafeLookupStaticPtr1_entry() //  [R2]
         { info_tbl: [(cfwjk,
                       label: GHC.StaticPtr.unsafeLookupStaticPtr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwjk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfwjl; else goto cfwjm;
       cfwjl: // global
           R2 = R2;
           R1 = GHC.StaticPtr.unsafeLookupStaticPtr1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfwjm: // global
           I64[Sp - 8] = block_cfwjh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwjq; else goto cfwji;
       ufwjq: // global
           call _cfwjh(R1) args: 0, res: 0, upd: 0;
       cfwji: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwjh() //  [R1]
         { info_tbl: [(cfwjh,
                       label: block_cfwjh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwjh: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.StaticPtr.$wunsafeLookupStaticPtr_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.235038903 UTC

[section ""data" . GHC.StaticPtr.unsafeLookupStaticPtr_closure" {
     GHC.StaticPtr.unsafeLookupStaticPtr_closure:
         const GHC.StaticPtr.unsafeLookupStaticPtr_info;
 },
 GHC.StaticPtr.unsafeLookupStaticPtr_entry() //  [R2]
         { info_tbl: [(cfwjF,
                       label: GHC.StaticPtr.unsafeLookupStaticPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwjF: // global
           R2 = R2;
           call GHC.StaticPtr.unsafeLookupStaticPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.238638584 UTC

[section ""cstring" . lvl_rfvlG_bytes" {
     lvl_rfvlG_bytes:
         I8[] [71,72,67,47,83,116,97,116,105,99,80,116,114,46,104,115,58,49,51,49,58,52,49,45,55,57,124,108,97,109,98,100,97]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.241557398 UTC

[section ""data" . lvl1_rfvlH_closure" {
     lvl1_rfvlH_closure:
         const lvl1_rfvlH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rfvlH_entry() //  [R1]
         { info_tbl: [(cfwjT,
                       label: lvl1_rfvlH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwjT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwjU; else goto cfwjV;
       cfwjU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwjV: // global
           (_cfwjQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwjQ::I64 == 0) goto cfwjS; else goto cfwjR;
       cfwjS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwjR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwjQ::I64;
           R2 = lvl_rfvlG_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.247722512 UTC

[section ""data" . GHC.StaticPtr.staticPtrKeys2_closure" {
     GHC.StaticPtr.staticPtrKeys2_closure:
         const GHC.StaticPtr.staticPtrKeys2_info;
         const 0;
 },
 sat_sfw5C_entry() //  [R1]
         { info_tbl: [(cfwkW,
                       label: sat_sfw5C_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwkW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfwl0; else goto cfwl1;
       cfwl0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwl1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cfwkT_info;
           _sfw5r::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sfw5r::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufwl5; else goto cfwkU;
       ufwl5: // global
           call _cfwkT(R1) args: 0, res: 0, upd: 0;
       cfwkU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfwkT() //  [R1]
         { info_tbl: [(cfwkT,
                       label: block_cfwkT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwkT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfwl4; else goto cfwl3;
       cfwl4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cfwl3: // global
           _sfw5B::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _sfw5B::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.StaticPtr.staticPtrKeys2_entry() //  [R2]
         { info_tbl: [(cfwla,
                       label: GHC.StaticPtr.staticPtrKeys2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwla: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfwlb; else goto cfwlc;
       cfwlb: // global
           R2 = R2;
           R1 = GHC.StaticPtr.staticPtrKeys2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfwlc: // global
           I64[Sp - 8] = block_cfwk8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwlV; else goto cfwk9;
       ufwlV: // global
           call _cfwk8(R1) args: 0, res: 0, upd: 0;
       cfwk9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwk8() //  [R1]
         { info_tbl: [(cfwk8,
                       label: block_cfwk8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwk8: // global
           if (R1 & 7 == 1) goto cfwl7; else goto cfwl8;
       cfwl7: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfwl8: // global
           P64[Sp - 24] = P64[R1 + 14];
           I64[Sp - 16] = 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 24;
           call _cfwki() args: 0, res: 0, upd: 0;
     }
 },
 _cfwki() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwki: // global
           _sfw5i::P64 = P64[Sp + 24];
           _sfw5L::I64 = I64[Sp + 8];
           if (_sfw5L::I64 != 0) goto cfwlB; else goto cfwlF;
       cfwlB: // global
           I64[Sp - 8] = block_cfwkn_info;
           R1 = _sfw5i::P64;
           I64[Sp + 8] = _sfw5L::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwlO; else goto cfwko;
       ufwlO: // global
           call _cfwkn(R1) args: 0, res: 0, upd: 0;
       cfwko: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfwlF: // global
           I64[Sp - 8] = block_cfwkx_info;
           R1 = _sfw5i::P64;
           P64[Sp + 24] = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwlP; else goto cfwky;
       ufwlP: // global
           call _cfwkx(R1) args: 0, res: 0, upd: 0;
       cfwky: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwkn() //  [R1]
         { info_tbl: [(cfwkn,
                       label: block_cfwkn_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwkn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfwlE; else goto cfwlD;
       cfwlE: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfwlD: // global
           _sfw5L::I64 = I64[Sp + 16];
           _sfw5Q::I64 = I64[I64[R1 + 7] + (_sfw5L::I64 << 3)];
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = _sfw5Q::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 16] = _sfw5L::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           Sp = Sp + 8;
           call _cfwki() args: 0, res: 0, upd: 0;
     }
 },
 _cfwkx() //  [R1]
         { info_tbl: [(cfwkx,
                       label: block_cfwkx_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwkx: // global
           _sfw5r::I64 = I64[I64[R1 + 7]];
           I64[Sp] = block_cfwkC_info;
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sfw5r::I64;
           if (R1 & 7 != 0) goto ufwlR; else goto cfwkD;
       ufwlR: // global
           call _cfwkC(R1) args: 0, res: 0, upd: 0;
       cfwkD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwkC() //  [R1]
         { info_tbl: [(cfwkC,
                       label: block_cfwkC_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwkC: // global
           if (R1 & 7 == 1) goto ufwlL; else goto cfwln;
       ufwlL: // global
           Sp = Sp + 40;
           call _cfwly() args: 0, res: 0, upd: 0;
       cfwln: // global
           I64[Sp] = block_cfwkI_info;
           _sfw5u::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp + 24] = _sfw5u::P64;
           if (R1 & 7 != 0) goto ufwlS; else goto cfwkJ;
       ufwlS: // global
           call _cfwkI(R1) args: 0, res: 0, upd: 0;
       cfwkJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwkI() //  [R1]
         { info_tbl: [(cfwkI,
                       label: block_cfwkI_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwkI: // global
           if (R1 & 7 == 1) goto cfwlr; else goto ufwlM;
       cfwlr: // global
           I64[Sp + 16] = block_cfwkN_info;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.StaticPtr.staticPtrKeys2_entry(R2) args: 8, res: 8, upd: 8;
       ufwlM: // global
           Sp = Sp + 40;
           call _cfwly() args: 0, res: 0, upd: 0;
     }
 },
 _cfwkN() //  [R1]
         { info_tbl: [(cfwkN,
                       label: block_cfwkN_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwkN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfwlu; else goto cfwlt;
       cfwlu: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfwlt: // global
           I64[Hp - 48] = sat_sfw5C_info;
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfwly() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwly: // global
           R1 = lvl1_rfvlH_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.274053861 UTC

[section ""data" . GHC.StaticPtr.staticPtrKeys1_closure" {
     GHC.StaticPtr.staticPtrKeys1_closure:
         const GHC.StaticPtr.staticPtrKeys1_info;
         const 0;
 },
 GHC.StaticPtr.staticPtrKeys1_entry() //  []
         { info_tbl: [(cfwnP,
                       label: GHC.StaticPtr.staticPtrKeys1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwnP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfwnQ; else goto cfwnR;
       cfwnQ: // global
           R1 = GHC.StaticPtr.staticPtrKeys1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cfwnR: // global
           (_sfw5Y::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] hs_spt_key_count();
           I64[Sp - 16] = block_cfwnn_info;
           R2 = 8;
           _sfw5Z::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sfw5Y::I64));
           R1 = _sfw5Z::I64 << 3;
           I64[Sp - 8] = _sfw5Z::I64;
           Sp = Sp - 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwnn() //  [R1]
         { info_tbl: [(cfwnn,
                       label: block_cfwnn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwnn: // global
           _sfw67::I64 = R1 + 16;
           (_sfw6b::I64) = call "ccall" arg hints:  [PtrHint,
                                                     ‘signed’]  result hints:  [‘signed’] hs_spt_keys(_sfw67::I64, I64[Sp + 8]);
           _sfw6c::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sfw6b::I64));
           if (%MO_S_Gt_W64(_sfw6c::I64, 0)) goto cfwob; else goto cfwoe;
       cfwob: // global
           I64[Sp - 16] = _sfw6c::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = _sfw67::I64;
           P64[Sp + 8] = R1;
           Sp = Sp - 24;
           call _cfwnI() args: 0, res: 0, upd: 0;
       cfwoe: // global
           I64[Sp] = block_cfwod_info;
           R2 = GHC.Types.[]_closure+1;
           P64[Sp + 8] = R1;
           call GHC.StaticPtr.staticPtrKeys2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfwnI() //  []
         { info_tbl: [(cfwnI,
                       label: block_cfwnI_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwnI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfwo6; else goto cfwo5;
       cfwo6: // global
           HpAlloc = 40;
           I64[Sp] = block_cfwnI_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfwo5: // global
           _sfw6s::P64 = P64[Sp + 16];
           _sfw6u::I64 = I64[Sp + 8];
           if (_sfw6u::I64 != 0) goto cfwo8; else goto cfwo9;
       cfwo8: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 24] + (_sfw6u::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sfw6s::P64;
           I64[Sp + 8] = _sfw6u::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _cfwnI() args: 0, res: 0, upd: 0;
       cfwo9: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _sfw6s::P64;
           Sp = Sp + 16;
           call _cfwnU() args: 0, res: 0, upd: 0;
     }
 },
 _cfwnU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwnU: // global
           Hp = Hp + 40;
           _sfw6f::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cfwo1; else goto cfwo0;
       cfwo1: // global
           HpAlloc = 40;
           I64[Sp] = block_cfwnT_info;
           R1 = _sfw6f::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfwo0: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 8]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sfw6f::P64;
           I64[Sp + 8] = block_cfwnY_info;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.StaticPtr.staticPtrKeys2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfwnT() //  [R1]
         { info_tbl: [(cfwnT,
                       label: block_cfwnT_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwnT: // global
           P64[Sp] = R1;
           call _cfwnU() args: 0, res: 0, upd: 0;
     }
 },
 _cfwnY() //  [R1]
         { info_tbl: [(cfwnY,
                       label: block_cfwnY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwnY: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfwod() //  [R1]
         { info_tbl: [(cfwod,
                       label: block_cfwod_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwod: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.291333849 UTC

[section ""data" . GHC.StaticPtr.staticPtrKeys_closure" {
     GHC.StaticPtr.staticPtrKeys_closure:
         const GHC.StaticPtr.staticPtrKeys_info;
         const 0;
 },
 GHC.StaticPtr.staticPtrKeys_entry() //  []
         { info_tbl: [(cfwpf,
                       label: GHC.StaticPtr.staticPtrKeys_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwpf: // global
           call GHC.StaticPtr.staticPtrKeys1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.295200803 UTC

[section ""data" . GHC.StaticPtr.StaticPtr_closure" {
     GHC.StaticPtr.StaticPtr_closure:
         const GHC.StaticPtr.StaticPtr_info;
 },
 GHC.StaticPtr.StaticPtr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwpn: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.StaticPtr.StaticPtr_entry(R5,
                                              R4,
                                              R3,
                                              R2,
                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.StaticPtr.StaticPtr_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfwps,
                       label: GHC.StaticPtr.StaticPtr_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwps: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfwpw; else goto cfwpv;
       cfwpw: // global
           HpAlloc = 40;
           R1 = GHC.StaticPtr.StaticPtr_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cfwpv: // global
           I64[Hp - 32] = GHC.StaticPtr.StaticPtr_con_info;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.301200148 UTC

[section ""data" . GHC.StaticPtr.StaticPtrInfo_closure" {
     GHC.StaticPtr.StaticPtrInfo_closure:
         const GHC.StaticPtr.StaticPtrInfo_info;
 },
 GHC.StaticPtr.StaticPtrInfo_entry() //  [R2, R3, R4]
         { info_tbl: [(cfwpK,
                       label: GHC.StaticPtr.StaticPtrInfo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwpK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfwpO; else goto cfwpN;
       cfwpO: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.StaticPtrInfo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwpN: // global
           I64[Hp - 24] = GHC.StaticPtr.StaticPtrInfo_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.305300492 UTC

[GHC.StaticPtr.StaticPtr_con_entry() //  [R1]
         { info_tbl: [(cfwpV,
                       label: GHC.StaticPtr.StaticPtr_con_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,105,99,80,116,114,46,83,116,97,116,105,99,80,116,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwpV: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.308767614 UTC

[GHC.StaticPtr.StaticPtrInfo_con_entry() //  [R1]
         { info_tbl: [(cfwq2,
                       label: GHC.StaticPtr.StaticPtrInfo_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,105,99,80,116,114,46,83,116,97,116,105,99,80,116,114,73,110,102,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwq2: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.312573176 UTC

[section ""relreadonly" . Sfwa4_srt" {
     Sfwa4_srt:
         const GHC.Show.$fShow(,)_go1_closure;
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Show.showLitString_closure;
         const GHC.StaticPtr.$w$cshowsPrec_closure;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshowsPrec_closure;
         const GHC.StaticPtr.$fShowStaticPtrInfo_$cshow_closure;
         const GHC.StaticPtr.$fShowStaticPtrInfo1_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.StaticPtr.staticPtrKeys2_closure;
         const lvl1_rfvlH_closure;
         const GHC.StaticPtr.staticPtrKeys1_closure;
 }]

