
==================== Raw Cmm ====================
2018-03-16 15:55:00.771551291 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:55:00.774752229 UTC

[section ""data" . GHC.MVar.$fEqMVar_$c==_closure" {
     GHC.MVar.$fEqMVar_$c==_closure:
         const GHC.MVar.$fEqMVar_$c==_info;
 },
 GHC.MVar.$fEqMVar_$c==_entry() //  [R2, R3]
         { []
         }
     {offset
       cn7x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cn7B; else goto cn7C;
       cn7B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.$fEqMVar_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cn7C: // global
           I64[Sp - 16] = block_cn7u_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto un7L; else goto cn7v;
       un7L: // global
           call _cn7u(R1) args: 0, res: 0, upd: 0;
       cn7v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.$fEqMVar_$c==_info" {
     GHC.MVar.$fEqMVar_$c==_info:
         const GHC.MVar.$fEqMVar_$c==_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cn7u() //  [R1]
         { []
         }
     {offset
       cn7u: // global
           I64[Sp] = block_cn7A_info;
           _smV7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _smV7::P64;
           if (R1 & 7 != 0) goto un7K; else goto cn7E;
       un7K: // global
           call _cn7A(R1) args: 0, res: 0, upd: 0;
       cn7E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cn7u_info" {
     block_cn7u_info:
         const _cn7u;
         const 1;
         const 30;
 },
 _cn7A() //  [R1]
         { []
         }
     {offset
       cn7A: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cn7A_info" {
     block_cn7A_info:
         const _cn7A;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.787103098 UTC

[section ""data" . GHC.MVar.$fEqMVar_$c/=_closure" {
     GHC.MVar.$fEqMVar_$c/=_closure:
         const GHC.MVar.$fEqMVar_$c/=_info;
 },
 GHC.MVar.$fEqMVar_$c/=_entry() //  [R2, R3]
         { []
         }
     {offset
       cn8a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cn8e; else goto cn8f;
       cn8e: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.$fEqMVar_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cn8f: // global
           I64[Sp - 16] = block_cn87_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto un8C; else goto cn88;
       un8C: // global
           call _cn87(R1) args: 0, res: 0, upd: 0;
       cn88: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.$fEqMVar_$c/=_info" {
     GHC.MVar.$fEqMVar_$c/=_info:
         const GHC.MVar.$fEqMVar_$c/=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cn87() //  [R1]
         { []
         }
     {offset
       cn87: // global
           I64[Sp] = block_cn8d_info;
           _smVe::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _smVe::P64;
           if (R1 & 7 != 0) goto un8B; else goto cn8h;
       un8B: // global
           call _cn8d(R1) args: 0, res: 0, upd: 0;
       cn8h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cn87_info" {
     block_cn87_info:
         const _cn87;
         const 1;
         const 30;
 },
 _cn8d() //  [R1]
         { []
         }
     {offset
       cn8d: // global
           if (P64[Sp + 8] == P64[R1 + 7]) goto cn8x; else goto cn8r;
       cn8x: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cn8r: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cn8d_info" {
     block_cn8d_info:
         const _cn8d;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.798013547 UTC

[section ""data" . GHC.MVar.$fEqMVar_closure" {
     GHC.MVar.$fEqMVar_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.MVar.$fEqMVar_$c==_closure+2;
         const GHC.MVar.$fEqMVar_$c/=_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.802609046 UTC

[section ""data" . GHC.MVar.newEmptyMVar1_closure" {
     GHC.MVar.newEmptyMVar1_closure:
         const GHC.MVar.newEmptyMVar1_info;
 },
 GHC.MVar.newEmptyMVar1_entry() //  []
         { []
         }
     {offset
       cn91: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cn92; else goto cn93;
       cn92: // global
           R1 = GHC.MVar.newEmptyMVar1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cn93: // global
           I64[Sp - 8] = block_cn8Y_info;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.newEmptyMVar1_info" {
     GHC.MVar.newEmptyMVar1_info:
         const GHC.MVar.newEmptyMVar1_entry;
         const 0;
         const 14;
         const 4294967299;
 },
 _cn8Y() //  [R1]
         { []
         }
     {offset
       cn8Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cn96; else goto cn95;
       cn96: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cn95: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cn8Y_info" {
     block_cn8Y_info:
         const _cn8Y;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.810040032 UTC

[section ""data" . GHC.MVar.newEmptyMVar_closure" {
     GHC.MVar.newEmptyMVar_closure:
         const GHC.MVar.newEmptyMVar_info;
 },
 GHC.MVar.newEmptyMVar_entry() //  []
         { []
         }
     {offset
       cn9k: // global
           call GHC.MVar.newEmptyMVar1_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.newEmptyMVar_info" {
     GHC.MVar.newEmptyMVar_info:
         const GHC.MVar.newEmptyMVar_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.814979156 UTC

[section ""data" . GHC.MVar.takeMVar1_closure" {
     GHC.MVar.takeMVar1_closure:
         const GHC.MVar.takeMVar1_info;
 },
 GHC.MVar.takeMVar1_entry() //  [R2]
         { []
         }
     {offset
       cn9y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cn9z; else goto cn9A;
       cn9z: // global
           R2 = R2;
           R1 = GHC.MVar.takeMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cn9A: // global
           I64[Sp - 8] = block_cn9v_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto un9E; else goto cn9w;
       un9E: // global
           call _cn9v(R1) args: 0, res: 0, upd: 0;
       cn9w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.takeMVar1_info" {
     GHC.MVar.takeMVar1_info:
         const GHC.MVar.takeMVar1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cn9v() //  [R1]
         { []
         }
     {offset
       cn9v: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cn9v_info" {
     block_cn9v_info:
         const _cn9v;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.820279935 UTC

[section ""data" . GHC.MVar.takeMVar_closure" {
     GHC.MVar.takeMVar_closure:
         const GHC.MVar.takeMVar_info;
 },
 GHC.MVar.takeMVar_entry() //  [R2]
         { []
         }
     {offset
       cn9S: // global
           R2 = R2;
           call GHC.MVar.takeMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.takeMVar_info" {
     GHC.MVar.takeMVar_info:
         const GHC.MVar.takeMVar_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.823861073 UTC

[section ""data" . GHC.MVar.readMVar1_closure" {
     GHC.MVar.readMVar1_closure:
         const GHC.MVar.readMVar1_info;
 },
 GHC.MVar.readMVar1_entry() //  [R2]
         { []
         }
     {offset
       cna6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cna7; else goto cna8;
       cna7: // global
           R2 = R2;
           R1 = GHC.MVar.readMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cna8: // global
           I64[Sp - 8] = block_cna3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unac; else goto cna4;
       unac: // global
           call _cna3(R1) args: 0, res: 0, upd: 0;
       cna4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.readMVar1_info" {
     GHC.MVar.readMVar1_info:
         const GHC.MVar.readMVar1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cna3() //  [R1]
         { []
         }
     {offset
       cna3: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cna3_info" {
     block_cna3_info:
         const _cna3;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.831697213 UTC

[section ""data" . GHC.MVar.readMVar_closure" {
     GHC.MVar.readMVar_closure:
         const GHC.MVar.readMVar_info;
 },
 GHC.MVar.readMVar_entry() //  [R2]
         { []
         }
     {offset
       cnaq: // global
           R2 = R2;
           call GHC.MVar.readMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.readMVar_info" {
     GHC.MVar.readMVar_info:
         const GHC.MVar.readMVar_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.835791569 UTC

[section ""data" . GHC.MVar.putMVar1_closure" {
     GHC.MVar.putMVar1_closure:
         const GHC.MVar.putMVar1_info;
 },
 GHC.MVar.putMVar1_entry() //  [R2, R3]
         { []
         }
     {offset
       cnaE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnaI; else goto cnaJ;
       cnaI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.putMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cnaJ: // global
           I64[Sp - 16] = block_cnaB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto unaN; else goto cnaC;
       unaN: // global
           call _cnaB(R1) args: 0, res: 0, upd: 0;
       cnaC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.putMVar1_info" {
     GHC.MVar.putMVar1_info:
         const GHC.MVar.putMVar1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cnaB() //  [R1]
         { []
         }
     {offset
       cnaB: // global
           _smVw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cnaH_info;
           R2 = _smVw::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cnaB_info" {
     block_cnaB_info:
         const _cnaB;
         const 1;
         const 30;
 },
 _cnaH() //  []
         { []
         }
     {offset
       cnaH: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnaH_info" {
     block_cnaH_info:
         const _cnaH;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.84314302 UTC

[section ""data" . GHC.MVar.putMVar_closure" {
     GHC.MVar.putMVar_closure:
         const GHC.MVar.putMVar_info;
 },
 GHC.MVar.putMVar_entry() //  [R2, R3]
         { []
         }
     {offset
       cnb5: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.putMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.putMVar_info" {
     GHC.MVar.putMVar_info:
         const GHC.MVar.putMVar_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.846993584 UTC

[section ""data" . GHC.MVar.newMVar1_closure" {
     GHC.MVar.newMVar1_closure:
         const GHC.MVar.newMVar1_info;
 },
 GHC.MVar.newMVar1_entry() //  [R2]
         { []
         }
     {offset
       cnbl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnbm; else goto cnbn;
       cnbm: // global
           R2 = R2;
           R1 = GHC.MVar.newMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnbn: // global
           I64[Sp - 16] = block_cnbg_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.newMVar1_info" {
     GHC.MVar.newMVar1_info:
         const GHC.MVar.newMVar1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cnbg() //  [R1]
         { []
         }
     {offset
       cnbg: // global
           I64[Sp] = block_cnbi_info;
           R2 = P64[Sp + 8];
           _smVF::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _smVF::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cnbg_info" {
     block_cnbg_info:
         const _cnbg;
         const 1;
         const 30;
 },
 _cnbi() //  []
         { []
         }
     {offset
       cnbi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnbr; else goto cnbq;
       cnbr: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cnbq: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnbi_info" {
     block_cnbi_info:
         const _cnbi;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.85332204 UTC

[section ""data" . GHC.MVar.newMVar_closure" {
     GHC.MVar.newMVar_closure:
         const GHC.MVar.newMVar_info;
 },
 GHC.MVar.newMVar_entry() //  [R2]
         { []
         }
     {offset
       cnbJ: // global
           R2 = R2;
           call GHC.MVar.newMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.newMVar_info" {
     GHC.MVar.newMVar_info:
         const GHC.MVar.newMVar_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.857918116 UTC

[section ""data" . GHC.MVar.tryTakeMVar1_closure" {
     GHC.MVar.tryTakeMVar1_closure:
         const GHC.MVar.tryTakeMVar1_info;
 },
 GHC.MVar.tryTakeMVar1_entry() //  [R2]
         { []
         }
     {offset
       cnbX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cnbY; else goto cnbZ;
       cnbY: // global
           R2 = R2;
           R1 = GHC.MVar.tryTakeMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnbZ: // global
           I64[Sp - 8] = block_cnbU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unch; else goto cnbV;
       unch: // global
           call _cnbU(R1) args: 0, res: 0, upd: 0;
       cnbV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.tryTakeMVar1_info" {
     GHC.MVar.tryTakeMVar1_info:
         const GHC.MVar.tryTakeMVar1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cnbU() //  [R1]
         { []
         }
     {offset
       cnbU: // global
           I64[Sp] = block_cnc2_info;
           R1 = P64[R1 + 7];
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cnbU_info" {
     block_cnbU_info:
         const _cnbU;
         const 0;
         const 30;
 },
 _cnc2() //  [R1, R2]
         { []
         }
     {offset
       cnc2: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cnc4() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cnc2_info" {
     block_cnc2_info:
         const _cnc2;
         const 0;
         const 30;
 },
 _cnc4() //  []
         { []
         }
     {offset
       cnc4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnc9; else goto cnc8;
       cnc9: // global
           HpAlloc = 16;
           I64[Sp] = block_cnc4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cnc8: // global
           if (I64[Sp + 16] == 0) goto cncf; else goto cnce;
       cncf: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cnce: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnc4_info" {
     block_cnc4_info:
         const _cnc4;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.865888378 UTC

[section ""data" . GHC.MVar.tryTakeMVar_closure" {
     GHC.MVar.tryTakeMVar_closure:
         const GHC.MVar.tryTakeMVar_info;
 },
 GHC.MVar.tryTakeMVar_entry() //  [R2]
         { []
         }
     {offset
       cncF: // global
           R2 = R2;
           call GHC.MVar.tryTakeMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.tryTakeMVar_info" {
     GHC.MVar.tryTakeMVar_info:
         const GHC.MVar.tryTakeMVar_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.869842211 UTC

[section ""data" . GHC.MVar.tryPutMVar1_closure" {
     GHC.MVar.tryPutMVar1_closure:
         const GHC.MVar.tryPutMVar1_info;
 },
 GHC.MVar.tryPutMVar1_entry() //  [R2, R3]
         { []
         }
     {offset
       cncT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cncU; else goto cncV;
       cncU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.tryPutMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cncV: // global
           I64[Sp - 16] = block_cncQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto und6; else goto cncR;
       und6: // global
           call _cncQ(R1) args: 0, res: 0, upd: 0;
       cncR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.tryPutMVar1_info" {
     GHC.MVar.tryPutMVar1_info:
         const GHC.MVar.tryPutMVar1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cncQ() //  [R1]
         { []
         }
     {offset
       cncQ: // global
           _smVT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cncY_info;
           R2 = _smVT::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cncQ_info" {
     block_cncQ_info:
         const _cncQ;
         const 1;
         const 30;
 },
 _cncY() //  [R1]
         { []
         }
     {offset
       cncY: // global
           if (R1 == 0) goto cnd5; else goto cnd4;
       cnd5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cnd4: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cncY_info" {
     block_cncY_info:
         const _cncY;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.87740479 UTC

[section ""data" . GHC.MVar.tryPutMVar_closure" {
     GHC.MVar.tryPutMVar_closure:
         const GHC.MVar.tryPutMVar_info;
 },
 GHC.MVar.tryPutMVar_entry() //  [R2, R3]
         { []
         }
     {offset
       cndp: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.tryPutMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.tryPutMVar_info" {
     GHC.MVar.tryPutMVar_info:
         const GHC.MVar.tryPutMVar_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.881622009 UTC

[section ""data" . GHC.MVar.tryReadMVar1_closure" {
     GHC.MVar.tryReadMVar1_closure:
         const GHC.MVar.tryReadMVar1_info;
 },
 GHC.MVar.tryReadMVar1_entry() //  [R2]
         { []
         }
     {offset
       cndD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cndE; else goto cndF;
       cndE: // global
           R2 = R2;
           R1 = GHC.MVar.tryReadMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cndF: // global
           I64[Sp - 8] = block_cndA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto undX; else goto cndB;
       undX: // global
           call _cndA(R1) args: 0, res: 0, upd: 0;
       cndB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.tryReadMVar1_info" {
     GHC.MVar.tryReadMVar1_info:
         const GHC.MVar.tryReadMVar1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cndA() //  [R1]
         { []
         }
     {offset
       cndA: // global
           I64[Sp] = block_cndI_info;
           R1 = P64[R1 + 7];
           call stg_tryReadMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cndA_info" {
     block_cndA_info:
         const _cndA;
         const 0;
         const 30;
 },
 _cndI() //  [R1, R2]
         { []
         }
     {offset
       cndI: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cndK() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cndI_info" {
     block_cndI_info:
         const _cndI;
         const 0;
         const 30;
 },
 _cndK() //  []
         { []
         }
     {offset
       cndK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cndP; else goto cndO;
       cndP: // global
           HpAlloc = 16;
           I64[Sp] = block_cndK_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cndO: // global
           if (I64[Sp + 16] == 0) goto cndV; else goto cndU;
       cndV: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cndU: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cndK_info" {
     block_cndK_info:
         const _cndK;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.889974341 UTC

[section ""data" . GHC.MVar.tryReadMVar_closure" {
     GHC.MVar.tryReadMVar_closure:
         const GHC.MVar.tryReadMVar_info;
 },
 GHC.MVar.tryReadMVar_entry() //  [R2]
         { []
         }
     {offset
       cnel: // global
           R2 = R2;
           call GHC.MVar.tryReadMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.tryReadMVar_info" {
     GHC.MVar.tryReadMVar_info:
         const GHC.MVar.tryReadMVar_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.894446841 UTC

[section ""data" . GHC.MVar.isEmptyMVar1_closure" {
     GHC.MVar.isEmptyMVar1_closure:
         const GHC.MVar.isEmptyMVar1_info;
 },
 sat_smWj_entry() //  [R1]
         { []
         }
     {offset
       cneL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cneM; else goto cneN;
       cneM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cneN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto cneK; else goto cneJ;
       cneK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cneJ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_smWj_info" {
     sat_smWj_info:
         const sat_smWj_entry;
         const 4294967296;
         const 17;
 },
 GHC.MVar.isEmptyMVar1_entry() //  [R2]
         { []
         }
     {offset
       cneO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cneP; else goto cneQ;
       cneP: // global
           R2 = R2;
           R1 = GHC.MVar.isEmptyMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cneQ: // global
           I64[Sp - 8] = block_cnew_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uneV; else goto cnex;
       uneV: // global
           call _cnew(R1) args: 0, res: 0, upd: 0;
       cnex: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.isEmptyMVar1_info" {
     GHC.MVar.isEmptyMVar1_info:
         const GHC.MVar.isEmptyMVar1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cnew() //  [R1]
         { []
         }
     {offset
       cnew: // global
           I64[Sp] = block_cneB_info;
           R1 = P64[R1 + 7];
           call stg_isEmptyMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cnew_info" {
     block_cnew_info:
         const _cnew;
         const 0;
         const 30;
 },
 _cneB() //  [R1]
         { []
         }
     {offset
       cneB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cneU; else goto cneT;
       cneU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cneT: // global
           I64[Hp - 16] = sat_smWj_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cneB_info" {
     block_cneB_info:
         const _cneB;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.902945589 UTC

[section ""data" . GHC.MVar.isEmptyMVar_closure" {
     GHC.MVar.isEmptyMVar_closure:
         const GHC.MVar.isEmptyMVar_info;
 },
 GHC.MVar.isEmptyMVar_entry() //  [R2]
         { []
         }
     {offset
       cnfj: // global
           R2 = R2;
           call GHC.MVar.isEmptyMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.isEmptyMVar_info" {
     GHC.MVar.isEmptyMVar_info:
         const GHC.MVar.isEmptyMVar_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.907342631 UTC

[section ""data" . GHC.MVar.addMVarFinalizer1_closure" {
     GHC.MVar.addMVarFinalizer1_closure:
         const GHC.MVar.addMVarFinalizer1_info;
 },
 GHC.MVar.addMVarFinalizer1_entry() //  [R2, R3]
         { []
         }
     {offset
       cnfx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnfB; else goto cnfC;
       cnfB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.addMVarFinalizer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cnfC: // global
           I64[Sp - 16] = block_cnfu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto unfG; else goto cnfv;
       unfG: // global
           call _cnfu(R1) args: 0, res: 0, upd: 0;
       cnfv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.addMVarFinalizer1_info" {
     GHC.MVar.addMVarFinalizer1_info:
         const GHC.MVar.addMVarFinalizer1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cnfu() //  [R1]
         { []
         }
     {offset
       cnfu: // global
           _smWl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cnfA_info;
           R3 = _smWl::P64;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cnfu_info" {
     block_cnfu_info:
         const _cnfu;
         const 1;
         const 30;
 },
 _cnfA() //  []
         { []
         }
     {offset
       cnfA: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnfA_info" {
     block_cnfA_info:
         const _cnfA;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.913935467 UTC

[section ""data" . GHC.MVar.addMVarFinalizer_closure" {
     GHC.MVar.addMVarFinalizer_closure:
         const GHC.MVar.addMVarFinalizer_info;
 },
 GHC.MVar.addMVarFinalizer_entry() //  [R2, R3]
         { []
         }
     {offset
       cnfY: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.addMVarFinalizer1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.addMVarFinalizer_info" {
     GHC.MVar.addMVarFinalizer_info:
         const GHC.MVar.addMVarFinalizer_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.916960269 UTC

[section ""cstring" . GHC.MVar.$trModule4_bytes" {
     GHC.MVar.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.91861908 UTC

[section ""data" . GHC.MVar.$trModule3_closure" {
     GHC.MVar.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.920188212 UTC

[section ""cstring" . GHC.MVar.$trModule2_bytes" {
     GHC.MVar.$trModule2_bytes:
         I8[] [71,72,67,46,77,86,97,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.921816219 UTC

[section ""data" . GHC.MVar.$trModule1_closure" {
     GHC.MVar.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.92338921 UTC

[section ""data" . GHC.MVar.$trModule_closure" {
     GHC.MVar.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.MVar.$trModule3_closure+1;
         const GHC.MVar.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.92502479 UTC

[section ""data" . $krep_rmUX_closure" {
     $krep_rmUX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRealWorld_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.926884203 UTC

[section ""data" . $krep1_rmUY_closure" {
     $krep1_rmUY_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.928493908 UTC

[section ""data" . $krep2_rmUZ_closure" {
     $krep2_rmUZ_closure:
         const :_con_info;
         const $krep1_rmUY_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.930161378 UTC

[section ""data" . $krep3_rmV0_closure" {
     $krep3_rmV0_closure:
         const :_con_info;
         const $krep_rmUX_closure+1;
         const $krep2_rmUZ_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.932283848 UTC

[section ""data" . $krep4_rmV1_closure" {
     $krep4_rmV1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcMVar#_closure;
         const $krep3_rmV0_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.933926064 UTC

[section ""cstring" . GHC.MVar.$tcMVar2_bytes" {
     GHC.MVar.$tcMVar2_bytes:
         I8[] [77,86,97,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.935493778 UTC

[section ""data" . GHC.MVar.$tcMVar1_closure" {
     GHC.MVar.$tcMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$tcMVar2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.937155994 UTC

[section ""data" . GHC.MVar.$tcMVar_closure" {
     GHC.MVar.$tcMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.MVar.$trModule_closure+1;
         const GHC.MVar.$tcMVar1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 4036113818353836845;
         const 5005913288165264115;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.938929346 UTC

[section ""data" . $krep5_rmV2_closure" {
     $krep5_rmV2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure+1;
         const $krep2_rmUZ_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.940557441 UTC

[section ""data" . GHC.MVar.$tc'MVar1_closure" {
     GHC.MVar.$tc'MVar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rmV1_closure+1;
         const $krep5_rmV2_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.942193893 UTC

[section ""cstring" . GHC.MVar.$tc'MVar3_bytes" {
     GHC.MVar.$tc'MVar3_bytes:
         I8[] [39,77,86,97,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.943816893 UTC

[section ""data" . GHC.MVar.$tc'MVar2_closure" {
     GHC.MVar.$tc'MVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$tc'MVar3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.945474075 UTC

[section ""data" . GHC.MVar.$tc'MVar_closure" {
     GHC.MVar.$tc'MVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.MVar.$trModule_closure+1;
         const GHC.MVar.$tc'MVar2_closure+1;
         const GHC.MVar.$tc'MVar1_closure+4;
         const 1422225975627779673;
         const 4396512866399833428;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.947759223 UTC

[section ""data" . GHC.MVar.MVar_closure" {
     GHC.MVar.MVar_closure:
         const GHC.MVar.MVar_info;
 },
 GHC.MVar.MVar_entry() //  [R2]
         { []
         }
     {offset
       cngs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cngw; else goto cngv;
       cngw: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.MVar.MVar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cngv: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.MVar_info" {
     GHC.MVar.MVar_info:
         const GHC.MVar.MVar_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.951819642 UTC

[section ""cstring" . in7p_str" {
     in7p_str:
         I8[] [98,97,115,101,58,71,72,67,46,77,86,97,114,46,77,86,97,114]
 },
 GHC.MVar.MVar_con_entry() //  [R1]
         { []
         }
     {offset
       cngC: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.MVar_con_info" {
     GHC.MVar.MVar_con_info:
         const GHC.MVar.MVar_con_entry;
         const 1;
         const 2;
         const in7p_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:00.954654939 UTC

[section ""relreadonly" . Sn1V_srt" { Sn1V_srt:
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.190904873 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:55:01.193479825 UTC

[section ""data" . GHC.MVar.$fEqMVar_$c==_closure" {
     GHC.MVar.$fEqMVar_$c==_closure:
         const GHC.MVar.$fEqMVar_$c==_info;
 },
 GHC.MVar.$fEqMVar_$c==_entry() //  [R2, R3]
         { []
         }
     {offset
       cnie: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnii; else goto cnij;
       cnii: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.$fEqMVar_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cnij: // global
           I64[Sp - 16] = block_cnib_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto unis; else goto cnic;
       unis: // global
           call _cnib(R1) args: 0, res: 0, upd: 0;
       cnic: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.$fEqMVar_$c==_info" {
     GHC.MVar.$fEqMVar_$c==_info:
         const GHC.MVar.$fEqMVar_$c==_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cnib() //  [R1]
         { []
         }
     {offset
       cnib: // global
           I64[Sp] = block_cnih_info;
           _sngM::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sngM::P64;
           if (R1 & 7 != 0) goto unir; else goto cnil;
       unir: // global
           call _cnih(R1) args: 0, res: 0, upd: 0;
       cnil: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cnib_info" {
     block_cnib_info:
         const _cnib;
         const 1;
         const 30;
 },
 _cnih() //  [R1]
         { []
         }
     {offset
       cnih: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnih_info" {
     block_cnih_info:
         const _cnih;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.201141707 UTC

[section ""data" . GHC.MVar.$fEqMVar_$c/=_closure" {
     GHC.MVar.$fEqMVar_$c/=_closure:
         const GHC.MVar.$fEqMVar_$c/=_info;
 },
 GHC.MVar.$fEqMVar_$c/=_entry() //  [R2, R3]
         { []
         }
     {offset
       cniU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cniY; else goto cniZ;
       cniY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.$fEqMVar_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cniZ: // global
           I64[Sp - 16] = block_cniR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto unjm; else goto cniS;
       unjm: // global
           call _cniR(R1) args: 0, res: 0, upd: 0;
       cniS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.$fEqMVar_$c/=_info" {
     GHC.MVar.$fEqMVar_$c/=_info:
         const GHC.MVar.$fEqMVar_$c/=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cniR() //  [R1]
         { []
         }
     {offset
       cniR: // global
           I64[Sp] = block_cniX_info;
           _sngT::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sngT::P64;
           if (R1 & 7 != 0) goto unjl; else goto cnj1;
       unjl: // global
           call _cniX(R1) args: 0, res: 0, upd: 0;
       cnj1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cniR_info" {
     block_cniR_info:
         const _cniR;
         const 1;
         const 30;
 },
 _cniX() //  [R1]
         { []
         }
     {offset
       cniX: // global
           if (P64[Sp + 8] == P64[R1 + 7]) goto cnjh; else goto cnjb;
       cnjh: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cnjb: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cniX_info" {
     block_cniX_info:
         const _cniX;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.207583623 UTC

[section ""data" . GHC.MVar.$fEqMVar_closure" {
     GHC.MVar.$fEqMVar_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.MVar.$fEqMVar_$c==_closure+2;
         const GHC.MVar.$fEqMVar_$c/=_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.210098986 UTC

[section ""data" . GHC.MVar.newEmptyMVar1_closure" {
     GHC.MVar.newEmptyMVar1_closure:
         const GHC.MVar.newEmptyMVar1_info;
 },
 GHC.MVar.newEmptyMVar1_entry() //  []
         { []
         }
     {offset
       cnjP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cnjQ; else goto cnjR;
       cnjQ: // global
           R1 = GHC.MVar.newEmptyMVar1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cnjR: // global
           I64[Sp - 8] = block_cnjM_info;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.newEmptyMVar1_info" {
     GHC.MVar.newEmptyMVar1_info:
         const GHC.MVar.newEmptyMVar1_entry;
         const 0;
         const 14;
         const 4294967299;
 },
 _cnjM() //  [R1]
         { []
         }
     {offset
       cnjM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnjU; else goto cnjT;
       cnjU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cnjT: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnjM_info" {
     block_cnjM_info:
         const _cnjM;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.215060795 UTC

[section ""data" . GHC.MVar.newEmptyMVar_closure" {
     GHC.MVar.newEmptyMVar_closure:
         const GHC.MVar.newEmptyMVar_info;
 },
 GHC.MVar.newEmptyMVar_entry() //  []
         { []
         }
     {offset
       cnka: // global
           call GHC.MVar.newEmptyMVar1_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.newEmptyMVar_info" {
     GHC.MVar.newEmptyMVar_info:
         const GHC.MVar.newEmptyMVar_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.218610841 UTC

[section ""data" . GHC.MVar.takeMVar1_closure" {
     GHC.MVar.takeMVar1_closure:
         const GHC.MVar.takeMVar1_info;
 },
 GHC.MVar.takeMVar1_entry() //  [R2]
         { []
         }
     {offset
       cnko: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cnkp; else goto cnkq;
       cnkp: // global
           R2 = R2;
           R1 = GHC.MVar.takeMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnkq: // global
           I64[Sp - 8] = block_cnkl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unku; else goto cnkm;
       unku: // global
           call _cnkl(R1) args: 0, res: 0, upd: 0;
       cnkm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.takeMVar1_info" {
     GHC.MVar.takeMVar1_info:
         const GHC.MVar.takeMVar1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cnkl() //  [R1]
         { []
         }
     {offset
       cnkl: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnkl_info" {
     block_cnkl_info:
         const _cnkl;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.224119023 UTC

[section ""data" . GHC.MVar.takeMVar_closure" {
     GHC.MVar.takeMVar_closure:
         const GHC.MVar.takeMVar_info;
 },
 GHC.MVar.takeMVar_entry() //  [R2]
         { []
         }
     {offset
       cnkJ: // global
           R2 = R2;
           call GHC.MVar.takeMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.takeMVar_info" {
     GHC.MVar.takeMVar_info:
         const GHC.MVar.takeMVar_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.227623888 UTC

[section ""data" . GHC.MVar.readMVar1_closure" {
     GHC.MVar.readMVar1_closure:
         const GHC.MVar.readMVar1_info;
 },
 GHC.MVar.readMVar1_entry() //  [R2]
         { []
         }
     {offset
       cnkX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cnkY; else goto cnkZ;
       cnkY: // global
           R2 = R2;
           R1 = GHC.MVar.readMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnkZ: // global
           I64[Sp - 8] = block_cnkU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unl3; else goto cnkV;
       unl3: // global
           call _cnkU(R1) args: 0, res: 0, upd: 0;
       cnkV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.readMVar1_info" {
     GHC.MVar.readMVar1_info:
         const GHC.MVar.readMVar1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cnkU() //  [R1]
         { []
         }
     {offset
       cnkU: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnkU_info" {
     block_cnkU_info:
         const _cnkU;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.233124549 UTC

[section ""data" . GHC.MVar.readMVar_closure" {
     GHC.MVar.readMVar_closure:
         const GHC.MVar.readMVar_info;
 },
 GHC.MVar.readMVar_entry() //  [R2]
         { []
         }
     {offset
       cnli: // global
           R2 = R2;
           call GHC.MVar.readMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.readMVar_info" {
     GHC.MVar.readMVar_info:
         const GHC.MVar.readMVar_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.236918483 UTC

[section ""data" . GHC.MVar.putMVar1_closure" {
     GHC.MVar.putMVar1_closure:
         const GHC.MVar.putMVar1_info;
 },
 GHC.MVar.putMVar1_entry() //  [R2, R3]
         { []
         }
     {offset
       cnlw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnlA; else goto cnlB;
       cnlA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.putMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cnlB: // global
           I64[Sp - 16] = block_cnlt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto unlF; else goto cnlu;
       unlF: // global
           call _cnlt(R1) args: 0, res: 0, upd: 0;
       cnlu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.putMVar1_info" {
     GHC.MVar.putMVar1_info:
         const GHC.MVar.putMVar1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cnlt() //  [R1]
         { []
         }
     {offset
       cnlt: // global
           _snhb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cnlz_info;
           R2 = _snhb::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cnlt_info" {
     block_cnlt_info:
         const _cnlt;
         const 1;
         const 30;
 },
 _cnlz() //  []
         { []
         }
     {offset
       cnlz: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnlz_info" {
     block_cnlz_info:
         const _cnlz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.243463884 UTC

[section ""data" . GHC.MVar.putMVar_closure" {
     GHC.MVar.putMVar_closure:
         const GHC.MVar.putMVar_info;
 },
 GHC.MVar.putMVar_entry() //  [R2, R3]
         { []
         }
     {offset
       cnm0: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.putMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.putMVar_info" {
     GHC.MVar.putMVar_info:
         const GHC.MVar.putMVar_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.247224979 UTC

[section ""data" . GHC.MVar.newMVar1_closure" {
     GHC.MVar.newMVar1_closure:
         const GHC.MVar.newMVar1_info;
 },
 GHC.MVar.newMVar1_entry() //  [R2]
         { []
         }
     {offset
       cnmg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnmh; else goto cnmi;
       cnmh: // global
           R2 = R2;
           R1 = GHC.MVar.newMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnmi: // global
           I64[Sp - 16] = block_cnmb_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.newMVar1_info" {
     GHC.MVar.newMVar1_info:
         const GHC.MVar.newMVar1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cnmb() //  [R1]
         { []
         }
     {offset
       cnmb: // global
           I64[Sp] = block_cnmd_info;
           R2 = P64[Sp + 8];
           _snhk::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _snhk::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cnmb_info" {
     block_cnmb_info:
         const _cnmb;
         const 1;
         const 30;
 },
 _cnmd() //  []
         { []
         }
     {offset
       cnmd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnmm; else goto cnml;
       cnmm: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cnml: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnmd_info" {
     block_cnmd_info:
         const _cnmd;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.253487419 UTC

[section ""data" . GHC.MVar.newMVar_closure" {
     GHC.MVar.newMVar_closure:
         const GHC.MVar.newMVar_info;
 },
 GHC.MVar.newMVar_entry() //  [R2]
         { []
         }
     {offset
       cnmH: // global
           R2 = R2;
           call GHC.MVar.newMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.newMVar_info" {
     GHC.MVar.newMVar_info:
         const GHC.MVar.newMVar_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.258772945 UTC

[section ""data" . GHC.MVar.tryTakeMVar1_closure" {
     GHC.MVar.tryTakeMVar1_closure:
         const GHC.MVar.tryTakeMVar1_info;
 },
 GHC.MVar.tryTakeMVar1_entry() //  [R2]
         { []
         }
     {offset
       cnmV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cnmW; else goto cnmX;
       cnmW: // global
           R2 = R2;
           R1 = GHC.MVar.tryTakeMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnmX: // global
           I64[Sp - 8] = block_cnmS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unnf; else goto cnmT;
       unnf: // global
           call _cnmS(R1) args: 0, res: 0, upd: 0;
       cnmT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.tryTakeMVar1_info" {
     GHC.MVar.tryTakeMVar1_info:
         const GHC.MVar.tryTakeMVar1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cnmS() //  [R1]
         { []
         }
     {offset
       cnmS: // global
           I64[Sp] = block_cnn0_info;
           R1 = P64[R1 + 7];
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cnmS_info" {
     block_cnmS_info:
         const _cnmS;
         const 0;
         const 30;
 },
 _cnn0() //  [R1, R2]
         { []
         }
     {offset
       cnn0: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cnn2() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cnn0_info" {
     block_cnn0_info:
         const _cnn0;
         const 0;
         const 30;
 },
 _cnn2() //  []
         { []
         }
     {offset
       cnn2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnn7; else goto cnn6;
       cnn7: // global
           HpAlloc = 16;
           I64[Sp] = block_cnn2_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cnn6: // global
           if (I64[Sp + 16] == 0) goto cnnd; else goto cnnc;
       cnnd: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cnnc: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnn2_info" {
     block_cnn2_info:
         const _cnn2;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.266916081 UTC

[section ""data" . GHC.MVar.tryTakeMVar_closure" {
     GHC.MVar.tryTakeMVar_closure:
         const GHC.MVar.tryTakeMVar_info;
 },
 GHC.MVar.tryTakeMVar_entry() //  [R2]
         { []
         }
     {offset
       cnnI: // global
           R2 = R2;
           call GHC.MVar.tryTakeMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.tryTakeMVar_info" {
     GHC.MVar.tryTakeMVar_info:
         const GHC.MVar.tryTakeMVar_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.270891366 UTC

[section ""data" . GHC.MVar.tryPutMVar1_closure" {
     GHC.MVar.tryPutMVar1_closure:
         const GHC.MVar.tryPutMVar1_info;
 },
 GHC.MVar.tryPutMVar1_entry() //  [R2, R3]
         { []
         }
     {offset
       cnnW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnnX; else goto cnnY;
       cnnX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.tryPutMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cnnY: // global
           I64[Sp - 16] = block_cnnT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uno9; else goto cnnU;
       uno9: // global
           call _cnnT(R1) args: 0, res: 0, upd: 0;
       cnnU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.tryPutMVar1_info" {
     GHC.MVar.tryPutMVar1_info:
         const GHC.MVar.tryPutMVar1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cnnT() //  [R1]
         { []
         }
     {offset
       cnnT: // global
           _snhy::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cno1_info;
           R2 = _snhy::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cnnT_info" {
     block_cnnT_info:
         const _cnnT;
         const 1;
         const 30;
 },
 _cno1() //  [R1]
         { []
         }
     {offset
       cno1: // global
           if (R1 == 0) goto cno8; else goto cno7;
       cno8: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cno7: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cno1_info" {
     block_cno1_info:
         const _cno1;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.277947491 UTC

[section ""data" . GHC.MVar.tryPutMVar_closure" {
     GHC.MVar.tryPutMVar_closure:
         const GHC.MVar.tryPutMVar_info;
 },
 GHC.MVar.tryPutMVar_entry() //  [R2, R3]
         { []
         }
     {offset
       cnow: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.tryPutMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.tryPutMVar_info" {
     GHC.MVar.tryPutMVar_info:
         const GHC.MVar.tryPutMVar_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.282214682 UTC

[section ""data" . GHC.MVar.tryReadMVar1_closure" {
     GHC.MVar.tryReadMVar1_closure:
         const GHC.MVar.tryReadMVar1_info;
 },
 GHC.MVar.tryReadMVar1_entry() //  [R2]
         { []
         }
     {offset
       cnoK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cnoL; else goto cnoM;
       cnoL: // global
           R2 = R2;
           R1 = GHC.MVar.tryReadMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnoM: // global
           I64[Sp - 8] = block_cnoH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unp4; else goto cnoI;
       unp4: // global
           call _cnoH(R1) args: 0, res: 0, upd: 0;
       cnoI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.tryReadMVar1_info" {
     GHC.MVar.tryReadMVar1_info:
         const GHC.MVar.tryReadMVar1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cnoH() //  [R1]
         { []
         }
     {offset
       cnoH: // global
           I64[Sp] = block_cnoP_info;
           R1 = P64[R1 + 7];
           call stg_tryReadMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cnoH_info" {
     block_cnoH_info:
         const _cnoH;
         const 0;
         const 30;
 },
 _cnoP() //  [R1, R2]
         { []
         }
     {offset
       cnoP: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cnoR() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cnoP_info" {
     block_cnoP_info:
         const _cnoP;
         const 0;
         const 30;
 },
 _cnoR() //  []
         { []
         }
     {offset
       cnoR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnoW; else goto cnoV;
       cnoW: // global
           HpAlloc = 16;
           I64[Sp] = block_cnoR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cnoV: // global
           if (I64[Sp + 16] == 0) goto cnp2; else goto cnp1;
       cnp2: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cnp1: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnoR_info" {
     block_cnoR_info:
         const _cnoR;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.2908649 UTC

[section ""data" . GHC.MVar.tryReadMVar_closure" {
     GHC.MVar.tryReadMVar_closure:
         const GHC.MVar.tryReadMVar_info;
 },
 GHC.MVar.tryReadMVar_entry() //  [R2]
         { []
         }
     {offset
       cnpx: // global
           R2 = R2;
           call GHC.MVar.tryReadMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.tryReadMVar_info" {
     GHC.MVar.tryReadMVar_info:
         const GHC.MVar.tryReadMVar_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.295162363 UTC

[section ""data" . GHC.MVar.isEmptyMVar1_closure" {
     GHC.MVar.isEmptyMVar1_closure:
         const GHC.MVar.isEmptyMVar1_info;
 },
 sat_snhY_entry() //  [R1]
         { []
         }
     {offset
       cnpX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnpY; else goto cnpZ;
       cnpY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cnpZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto cnpW; else goto cnpV;
       cnpW: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cnpV: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_snhY_info" {
     sat_snhY_info:
         const sat_snhY_entry;
         const 4294967296;
         const 17;
 },
 GHC.MVar.isEmptyMVar1_entry() //  [R2]
         { []
         }
     {offset
       cnq0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cnq1; else goto cnq2;
       cnq1: // global
           R2 = R2;
           R1 = GHC.MVar.isEmptyMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnq2: // global
           I64[Sp - 8] = block_cnpI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto unq7; else goto cnpJ;
       unq7: // global
           call _cnpI(R1) args: 0, res: 0, upd: 0;
       cnpJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.isEmptyMVar1_info" {
     GHC.MVar.isEmptyMVar1_info:
         const GHC.MVar.isEmptyMVar1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cnpI() //  [R1]
         { []
         }
     {offset
       cnpI: // global
           I64[Sp] = block_cnpN_info;
           R1 = P64[R1 + 7];
           call stg_isEmptyMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cnpI_info" {
     block_cnpI_info:
         const _cnpI;
         const 0;
         const 30;
 },
 _cnpN() //  [R1]
         { []
         }
     {offset
       cnpN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cnq6; else goto cnq5;
       cnq6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cnq5: // global
           I64[Hp - 16] = sat_snhY_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnpN_info" {
     block_cnpN_info:
         const _cnpN;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.303888922 UTC

[section ""data" . GHC.MVar.isEmptyMVar_closure" {
     GHC.MVar.isEmptyMVar_closure:
         const GHC.MVar.isEmptyMVar_info;
 },
 GHC.MVar.isEmptyMVar_entry() //  [R2]
         { []
         }
     {offset
       cnqB: // global
           R2 = R2;
           call GHC.MVar.isEmptyMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.isEmptyMVar_info" {
     GHC.MVar.isEmptyMVar_info:
         const GHC.MVar.isEmptyMVar_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.30778974 UTC

[section ""data" . GHC.MVar.addMVarFinalizer1_closure" {
     GHC.MVar.addMVarFinalizer1_closure:
         const GHC.MVar.addMVarFinalizer1_info;
 },
 GHC.MVar.addMVarFinalizer1_entry() //  [R2, R3]
         { []
         }
     {offset
       cnqP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cnqT; else goto cnqU;
       cnqT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.MVar.addMVarFinalizer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cnqU: // global
           I64[Sp - 16] = block_cnqM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto unqY; else goto cnqN;
       unqY: // global
           call _cnqM(R1) args: 0, res: 0, upd: 0;
       cnqN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.addMVarFinalizer1_info" {
     GHC.MVar.addMVarFinalizer1_info:
         const GHC.MVar.addMVarFinalizer1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cnqM() //  [R1]
         { []
         }
     {offset
       cnqM: // global
           _sni0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cnqS_info;
           R3 = _sni0::P64;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cnqM_info" {
     block_cnqM_info:
         const _cnqM;
         const 1;
         const 30;
 },
 _cnqS() //  []
         { []
         }
     {offset
       cnqS: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cnqS_info" {
     block_cnqS_info:
         const _cnqS;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.314278331 UTC

[section ""data" . GHC.MVar.addMVarFinalizer_closure" {
     GHC.MVar.addMVarFinalizer_closure:
         const GHC.MVar.addMVarFinalizer_info;
 },
 GHC.MVar.addMVarFinalizer_entry() //  [R2, R3]
         { []
         }
     {offset
       cnrk: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.addMVarFinalizer1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.addMVarFinalizer_info" {
     GHC.MVar.addMVarFinalizer_info:
         const GHC.MVar.addMVarFinalizer_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.31728737 UTC

[section ""cstring" . GHC.MVar.$trModule4_bytes" {
     GHC.MVar.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.318886683 UTC

[section ""data" . GHC.MVar.$trModule3_closure" {
     GHC.MVar.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.320962261 UTC

[section ""cstring" . GHC.MVar.$trModule2_bytes" {
     GHC.MVar.$trModule2_bytes:
         I8[] [71,72,67,46,77,86,97,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.322605847 UTC

[section ""data" . GHC.MVar.$trModule1_closure" {
     GHC.MVar.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.324242196 UTC

[section ""data" . GHC.MVar.$trModule_closure" {
     GHC.MVar.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.MVar.$trModule3_closure+1;
         const GHC.MVar.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.325935341 UTC

[section ""data" . $krep_rmUX_closure" {
     $krep_rmUX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRealWorld_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.327638838 UTC

[section ""data" . $krep1_rmUY_closure" {
     $krep1_rmUY_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.329283071 UTC

[section ""data" . $krep2_rmUZ_closure" {
     $krep2_rmUZ_closure:
         const :_con_info;
         const $krep1_rmUY_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.330878162 UTC

[section ""data" . $krep3_rmV0_closure" {
     $krep3_rmV0_closure:
         const :_con_info;
         const $krep_rmUX_closure+1;
         const $krep2_rmUZ_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.332476193 UTC

[section ""data" . $krep4_rmV1_closure" {
     $krep4_rmV1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcMVar#_closure;
         const $krep3_rmV0_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.33447603 UTC

[section ""cstring" . GHC.MVar.$tcMVar2_bytes" {
     GHC.MVar.$tcMVar2_bytes:
         I8[] [77,86,97,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.336006105 UTC

[section ""data" . GHC.MVar.$tcMVar1_closure" {
     GHC.MVar.$tcMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$tcMVar2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.337693193 UTC

[section ""data" . GHC.MVar.$tcMVar_closure" {
     GHC.MVar.$tcMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.MVar.$trModule_closure+1;
         const GHC.MVar.$tcMVar1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 4036113818353836845;
         const 5005913288165264115;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.339389979 UTC

[section ""data" . $krep5_rmV2_closure" {
     $krep5_rmV2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure+1;
         const $krep2_rmUZ_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.341094283 UTC

[section ""data" . GHC.MVar.$tc'MVar1_closure" {
     GHC.MVar.$tc'MVar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rmV1_closure+1;
         const $krep5_rmV2_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.343435329 UTC

[section ""cstring" . GHC.MVar.$tc'MVar3_bytes" {
     GHC.MVar.$tc'MVar3_bytes:
         I8[] [39,77,86,97,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.345509049 UTC

[section ""data" . GHC.MVar.$tc'MVar2_closure" {
     GHC.MVar.$tc'MVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.MVar.$tc'MVar3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.34718177 UTC

[section ""data" . GHC.MVar.$tc'MVar_closure" {
     GHC.MVar.$tc'MVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.MVar.$trModule_closure+1;
         const GHC.MVar.$tc'MVar2_closure+1;
         const GHC.MVar.$tc'MVar1_closure+4;
         const 1422225975627779673;
         const 4396512866399833428;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.349503197 UTC

[section ""data" . GHC.MVar.MVar_closure" {
     GHC.MVar.MVar_closure:
         const GHC.MVar.MVar_info;
 },
 GHC.MVar.MVar_entry() //  [R2]
         { []
         }
     {offset
       cnrO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cnrS; else goto cnrR;
       cnrS: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.MVar.MVar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cnrR: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.MVar_info" {
     GHC.MVar.MVar_info:
         const GHC.MVar.MVar_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.352971429 UTC

[section ""cstring" . ins0_str" {
     ins0_str:
         I8[] [98,97,115,101,58,71,72,67,46,77,86,97,114,46,77,86,97,114]
 },
 GHC.MVar.MVar_con_entry() //  [R1]
         { []
         }
     {offset
       cnrZ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.MVar.MVar_con_info" {
     GHC.MVar.MVar_con_info:
         const GHC.MVar.MVar_con_entry;
         const 1;
         const 2;
         const ins0_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:01.356395727 UTC

[section ""relreadonly" . Sns6_srt" { Sns6_srt:
 }]

