
==================== Output Cmm ====================
2018-03-16 15:55:35.686916327 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:35.68758709 UTC

[section ""cstring" . lvl_rQ8I_bytes" {
     lvl_rQ8I_bytes:
         I8[] [80,114,101,108,117,100,101,46,99,104,114,58,32,98,97,100,32,97,114,103,117,109,101,110,116,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.688828629 UTC

[section ""data" . GHC.Char.$wlvl_closure" {
     GHC.Char.$wlvl_closure:
         const GHC.Char.$wlvl_info;
         const 0;
 },
 sat_sQ8O_entry() //  [R1]
         { info_tbl: [(cQ9a,
                       label: sat_sQ8O_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQ9a: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cQ9b; else goto cQ9c;
       cQ9b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cQ9c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cQ97_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cQ97() //  [R1, R2]
         { info_tbl: [(cQ97,
                       label: block_cQ97_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQ97: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cQ9f; else goto cQ9e;
       cQ9f: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cQ9e: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Char.$wlvl_entry() //  [R2]
         { info_tbl: [(cQ9i,
                       label: GHC.Char.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQ9i: // global
           _sQ8K::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cQ9j; else goto cQ9k;
       cQ9k: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cQ9m; else goto cQ9l;
       cQ9m: // global
           HpAlloc = 24;
           goto cQ9j;
       cQ9j: // global
           R2 = _sQ8K::I64;
           R1 = GHC.Char.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cQ9l: // global
           I64[Hp - 16] = sat_sQ8O_info;
           I64[Hp] = _sQ8K::I64;
           I64[Sp - 8] = block_cQ9g_info;
           R3 = Hp - 16;
           R2 = lvl_rQ8I_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cQ9g() //  [R1]
         { info_tbl: [(cQ9g,
                       label: block_cQ9g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQ9g: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.690628807 UTC

[section ""data" . GHC.Char.chr1_closure" {
     GHC.Char.chr1_closure:
         const GHC.Char.chr1_info;
         const 0;
 },
 GHC.Char.chr1_entry() //  [R2]
         { info_tbl: [(cQ9y,
                       label: GHC.Char.chr1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQ9y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cQ9z; else goto cQ9A;
       cQ9z: // global
           R2 = R2;
           R1 = GHC.Char.chr1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cQ9A: // global
           I64[Sp - 8] = block_cQ9v_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uQ9E; else goto cQ9w;
       uQ9E: // global
           call _cQ9v(R1) args: 0, res: 0, upd: 0;
       cQ9w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cQ9v() //  [R1]
         { info_tbl: [(cQ9v,
                       label: block_cQ9v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQ9v: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.692071551 UTC

[section ""data" . GHC.Char.chr_closure" {
     GHC.Char.chr_closure:
         const GHC.Char.chr_info;
         const 0;
 },
 GHC.Char.chr_entry() //  [R2]
         { info_tbl: [(cQ9M,
                       label: GHC.Char.chr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQ9M: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cQ9N; else goto cQ9O;
       cQ9N: // global
           R2 = R2;
           R1 = GHC.Char.chr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cQ9O: // global
           I64[Sp - 8] = block_cQ9J_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uQa8; else goto cQ9K;
       uQa8: // global
           call _cQ9J(R1) args: 0, res: 0, upd: 0;
       cQ9K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cQ9J() //  [R1]
         { info_tbl: [(cQ9J,
                       label: block_cQ9J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQ9J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cQ9T; else goto cQ9S;
       cQ9T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cQ9S: // global
           _sQ8V::I64 = I64[R1 + 7];
           if (_sQ8V::I64 > 1114111) goto cQa0; else goto cQa7;
       cQa0: // global
           Hp = Hp - 16;
           R2 = _sQ8V::I64;
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       cQa7: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sQ8V::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.693234386 UTC

[section ""cstring" . GHC.Char.$trModule4_bytes" {
     GHC.Char.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.693850641 UTC

[section ""data" . GHC.Char.$trModule3_closure" {
     GHC.Char.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Char.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.694445959 UTC

[section ""cstring" . GHC.Char.$trModule2_bytes" {
     GHC.Char.$trModule2_bytes:
         I8[] [71,72,67,46,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.694978672 UTC

[section ""data" . GHC.Char.$trModule1_closure" {
     GHC.Char.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Char.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.695522978 UTC

[section ""data" . GHC.Char.$trModule_closure" {
     GHC.Char.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Char.$trModule3_closure+1;
         const GHC.Char.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.696066124 UTC

[section ""relreadonly" . SQ9q_srt" {
     SQ9q_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.Char.chr1_closure;
         const GHC.Char.chr_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.696595939 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:35.697099633 UTC

[section ""cstring" . lvl_rQ8I_bytes" {
     lvl_rQ8I_bytes:
         I8[] [80,114,101,108,117,100,101,46,99,104,114,58,32,98,97,100,32,97,114,103,117,109,101,110,116,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.698301963 UTC

[section ""data" . GHC.Char.$wlvl_closure" {
     GHC.Char.$wlvl_closure:
         const GHC.Char.$wlvl_info;
         const 0;
 },
 sat_sQ8O_entry() //  [R1]
         { info_tbl: [(cQak,
                       label: sat_sQ8O_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQak: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cQal; else goto cQam;
       cQal: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cQam: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cQah_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cQah() //  [R1, R2]
         { info_tbl: [(cQah,
                       label: block_cQah_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQah: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cQap; else goto cQao;
       cQap: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cQao: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Char.$wlvl_entry() //  [R2]
         { info_tbl: [(cQas,
                       label: GHC.Char.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQas: // global
           _sQ8K::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cQat; else goto cQau;
       cQau: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cQaw; else goto cQav;
       cQaw: // global
           HpAlloc = 24;
           goto cQat;
       cQat: // global
           R2 = _sQ8K::I64;
           R1 = GHC.Char.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cQav: // global
           I64[Hp - 16] = sat_sQ8O_info;
           I64[Hp] = _sQ8K::I64;
           I64[Sp - 8] = block_cQaq_info;
           R3 = Hp - 16;
           R2 = lvl_rQ8I_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cQaq() //  [R1]
         { info_tbl: [(cQaq,
                       label: block_cQaq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQaq: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.700055387 UTC

[section ""data" . GHC.Char.chr1_closure" {
     GHC.Char.chr1_closure:
         const GHC.Char.chr1_info;
         const 0;
 },
 GHC.Char.chr1_entry() //  [R2]
         { info_tbl: [(cQaH,
                       label: GHC.Char.chr1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQaH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cQaI; else goto cQaJ;
       cQaI: // global
           R2 = R2;
           R1 = GHC.Char.chr1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cQaJ: // global
           I64[Sp - 8] = block_cQaE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uQaN; else goto cQaF;
       uQaN: // global
           call _cQaE(R1) args: 0, res: 0, upd: 0;
       cQaF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cQaE() //  [R1]
         { info_tbl: [(cQaE,
                       label: block_cQaE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQaE: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.701560245 UTC

[section ""data" . GHC.Char.chr_closure" {
     GHC.Char.chr_closure:
         const GHC.Char.chr_info;
         const 0;
 },
 GHC.Char.chr_entry() //  [R2]
         { info_tbl: [(cQaV,
                       label: GHC.Char.chr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQaV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cQaW; else goto cQaX;
       cQaW: // global
           R2 = R2;
           R1 = GHC.Char.chr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cQaX: // global
           I64[Sp - 8] = block_cQaS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uQbh; else goto cQaT;
       uQbh: // global
           call _cQaS(R1) args: 0, res: 0, upd: 0;
       cQaT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cQaS() //  [R1]
         { info_tbl: [(cQaS,
                       label: block_cQaS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQaS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cQb2; else goto cQb1;
       cQb2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cQb1: // global
           _sQ8V::I64 = I64[R1 + 7];
           if (_sQ8V::I64 > 1114111) goto cQb9; else goto cQbg;
       cQb9: // global
           Hp = Hp - 16;
           R2 = _sQ8V::I64;
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       cQbg: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sQ8V::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.702747765 UTC

[section ""cstring" . GHC.Char.$trModule4_bytes" {
     GHC.Char.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.703283094 UTC

[section ""data" . GHC.Char.$trModule3_closure" {
     GHC.Char.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Char.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.703859007 UTC

[section ""cstring" . GHC.Char.$trModule2_bytes" {
     GHC.Char.$trModule2_bytes:
         I8[] [71,72,67,46,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.704441375 UTC

[section ""data" . GHC.Char.$trModule1_closure" {
     GHC.Char.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Char.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.704993866 UTC

[section ""data" . GHC.Char.$trModule_closure" {
     GHC.Char.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Char.$trModule3_closure+1;
         const GHC.Char.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.705628898 UTC

[section ""relreadonly" . SQ9q_srt" {
     SQ9q_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.Char.chr1_closure;
         const GHC.Char.chr_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.706406824 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:35.715972971 UTC

[section ""cstring" . lvl_rQ8I_bytes" {
     lvl_rQ8I_bytes:
         I8[] [80,114,101,108,117,100,101,46,99,104,114,58,32,98,97,100,32,97,114,103,117,109,101,110,116,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.718631044 UTC

[section ""data" . GHC.Char.$wlvl_closure" {
     GHC.Char.$wlvl_closure:
         const GHC.Char.$wlvl_info;
         const 0;
 },
 sat_sQ8O_entry() //  [R1]
         { info_tbl: [(cQbu,
                       label: sat_sQ8O_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQbu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cQbv; else goto cQbw;
       cQbv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cQbw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cQbr_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cQbr() //  [R1, R2]
         { info_tbl: [(cQbr,
                       label: block_cQbr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQbr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cQbz; else goto cQby;
       cQbz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cQby: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Char.$wlvl_entry() //  [R2]
         { info_tbl: [(cQbC,
                       label: GHC.Char.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQbC: // global
           _sQ8K::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cQbD; else goto cQbE;
       cQbE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cQbG; else goto cQbF;
       cQbG: // global
           HpAlloc = 24;
           goto cQbD;
       cQbD: // global
           R2 = _sQ8K::I64;
           R1 = GHC.Char.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cQbF: // global
           I64[Hp - 16] = sat_sQ8O_info;
           I64[Hp] = _sQ8K::I64;
           I64[Sp - 8] = block_cQbA_info;
           R3 = Hp - 16;
           R2 = lvl_rQ8I_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cQbA() //  [R1]
         { info_tbl: [(cQbA,
                       label: block_cQbA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQbA: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.728808938 UTC

[section ""data" . GHC.Char.chr1_closure" {
     GHC.Char.chr1_closure:
         const GHC.Char.chr1_info;
         const 0;
 },
 GHC.Char.chr1_entry() //  [R2]
         { info_tbl: [(cQc7,
                       label: GHC.Char.chr1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQc7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cQc8; else goto cQc9;
       cQc8: // global
           R2 = R2;
           R1 = GHC.Char.chr1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cQc9: // global
           I64[Sp - 8] = block_cQc4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uQcd; else goto cQc5;
       uQcd: // global
           call _cQc4(R1) args: 0, res: 0, upd: 0;
       cQc5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cQc4() //  [R1]
         { info_tbl: [(cQc4,
                       label: block_cQc4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQc4: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.7355862 UTC

[section ""data" . GHC.Char.chr_closure" {
     GHC.Char.chr_closure:
         const GHC.Char.chr_info;
         const 0;
 },
 GHC.Char.chr_entry() //  [R2]
         { info_tbl: [(cQcu,
                       label: GHC.Char.chr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQcu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cQcv; else goto cQcw;
       cQcv: // global
           R2 = R2;
           R1 = GHC.Char.chr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cQcw: // global
           I64[Sp - 8] = block_cQcr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uQcQ; else goto cQcs;
       uQcQ: // global
           call _cQcr(R1) args: 0, res: 0, upd: 0;
       cQcs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cQcr() //  [R1]
         { info_tbl: [(cQcr,
                       label: block_cQcr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQcr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cQcB; else goto cQcA;
       cQcB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cQcA: // global
           _sQ8V::I64 = I64[R1 + 7];
           if (_sQ8V::I64 > 1114111) goto cQcI; else goto cQcP;
       cQcI: // global
           Hp = Hp - 16;
           R2 = _sQ8V::I64;
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       cQcP: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sQ8V::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.741656032 UTC

[section ""cstring" . GHC.Char.$trModule4_bytes" {
     GHC.Char.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.743277798 UTC

[section ""data" . GHC.Char.$trModule3_closure" {
     GHC.Char.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Char.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.744930586 UTC

[section ""cstring" . GHC.Char.$trModule2_bytes" {
     GHC.Char.$trModule2_bytes:
         I8[] [71,72,67,46,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.74662963 UTC

[section ""data" . GHC.Char.$trModule1_closure" {
     GHC.Char.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Char.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.748479101 UTC

[section ""data" . GHC.Char.$trModule_closure" {
     GHC.Char.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Char.$trModule3_closure+1;
         const GHC.Char.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.750734143 UTC

[section ""relreadonly" . SQ9q_srt" {
     SQ9q_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.Char.chr1_closure;
         const GHC.Char.chr_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.803144585 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:35.804568937 UTC

[section ""cstring" . lvl_rQ8I_bytes" {
     lvl_rQ8I_bytes:
         I8[] [80,114,101,108,117,100,101,46,99,104,114,58,32,98,97,100,32,97,114,103,117,109,101,110,116,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.807384315 UTC

[section ""data" . GHC.Char.$wlvl_closure" {
     GHC.Char.$wlvl_closure:
         const GHC.Char.$wlvl_info;
         const 0;
 },
 sat_sQdb_entry() //  [R1]
         { info_tbl: [(cQdy,
                       label: sat_sQdb_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQdy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cQdz; else goto cQdA;
       cQdz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cQdA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cQdv_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cQdv() //  [R1, R2]
         { info_tbl: [(cQdv,
                       label: block_cQdv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQdv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cQdD; else goto cQdC;
       cQdD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cQdC: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Char.$wlvl_entry() //  [R2]
         { info_tbl: [(cQdG,
                       label: GHC.Char.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQdG: // global
           _sQd7::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cQdH; else goto cQdI;
       cQdI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cQdK; else goto cQdJ;
       cQdK: // global
           HpAlloc = 24;
           goto cQdH;
       cQdH: // global
           R2 = _sQd7::I64;
           R1 = GHC.Char.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cQdJ: // global
           I64[Hp - 16] = sat_sQdb_info;
           I64[Hp] = _sQd7::I64;
           I64[Sp - 8] = block_cQdE_info;
           R3 = Hp - 16;
           R2 = lvl_rQ8I_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cQdE() //  [R1]
         { info_tbl: [(cQdE,
                       label: block_cQdE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQdE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.817410573 UTC

[section ""data" . GHC.Char.chr1_closure" {
     GHC.Char.chr1_closure:
         const GHC.Char.chr1_info;
         const 0;
 },
 GHC.Char.chr1_entry() //  [R2]
         { info_tbl: [(cQei,
                       label: GHC.Char.chr1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQei: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cQej; else goto cQek;
       cQej: // global
           R2 = R2;
           R1 = GHC.Char.chr1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cQek: // global
           I64[Sp - 8] = block_cQef_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uQeo; else goto cQeg;
       uQeo: // global
           call _cQef(R1) args: 0, res: 0, upd: 0;
       cQeg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cQef() //  [R1]
         { info_tbl: [(cQef,
                       label: block_cQef_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQef: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.823246636 UTC

[section ""data" . GHC.Char.chr_closure" {
     GHC.Char.chr_closure:
         const GHC.Char.chr_info;
         const 0;
 },
 GHC.Char.chr_entry() //  [R2]
         { info_tbl: [(cQeG,
                       label: GHC.Char.chr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQeG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cQeH; else goto cQeI;
       cQeH: // global
           R2 = R2;
           R1 = GHC.Char.chr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cQeI: // global
           I64[Sp - 8] = block_cQeD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uQf2; else goto cQeE;
       uQf2: // global
           call _cQeD(R1) args: 0, res: 0, upd: 0;
       cQeE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cQeD() //  [R1]
         { info_tbl: [(cQeD,
                       label: block_cQeD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cQeD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cQeN; else goto cQeM;
       cQeN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cQeM: // global
           _sQdi::I64 = I64[R1 + 7];
           if (_sQdi::I64 > 1114111) goto cQeU; else goto cQf1;
       cQeU: // global
           Hp = Hp - 16;
           R2 = _sQdi::I64;
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       cQf1: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sQdi::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.829807853 UTC

[section ""cstring" . GHC.Char.$trModule4_bytes" {
     GHC.Char.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.831497665 UTC

[section ""data" . GHC.Char.$trModule3_closure" {
     GHC.Char.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Char.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.834039385 UTC

[section ""cstring" . GHC.Char.$trModule2_bytes" {
     GHC.Char.$trModule2_bytes:
         I8[] [71,72,67,46,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.835664226 UTC

[section ""data" . GHC.Char.$trModule1_closure" {
     GHC.Char.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Char.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.837487313 UTC

[section ""data" . GHC.Char.$trModule_closure" {
     GHC.Char.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Char.$trModule3_closure+1;
         const GHC.Char.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:35.83933607 UTC

[section ""relreadonly" . SQdO_srt" {
     SQdO_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.Char.chr1_closure;
         const GHC.Char.chr_closure;
 }]

