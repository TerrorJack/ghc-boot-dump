
==================== Output Cmm ====================
2018-03-16 15:50:22.33798701 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:50:22.371716547 UTC

[section ""data" . GHC.Debug.debugErrLn_len_closure" {
     GHC.Debug.debugErrLn_len_closure:
         const GHC.Debug.debugErrLn_len_info;
 },
 GHC.Debug.debugErrLn_len_entry() //  [R2, R3]
         { info_tbl: [(cB5V,
                       label: GHC.Debug.debugErrLn_len_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB5V: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cB5W; else goto uB65;
       cB5W: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Debug.debugErrLn_len_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uB65: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cB5L() args: 0, res: 0, upd: 0;
     }
 },
 _cB5L() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB5L: // global
           I64[Sp - 8] = block_cB5O_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uB67; else goto cB5P;
       uB67: // global
           call _cB5O(R1) args: 0, res: 0, upd: 0;
       cB5P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cB5O() //  [R1]
         { info_tbl: [(cB5O,
                       label: block_cB5O_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB5O: // global
           _sB59::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cB5S; else goto cB5T;
       cB5S: // global
           R1 = _sB59::I64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cB5T: // global
           I64[Sp + 8] = _sB59::I64 + 1;
           P64[Sp + 16] = P64[R1 + 14];
           Sp = Sp + 8;
           call _cB5L() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.373802098 UTC

[section ""data" . GHC.Debug.debugErrLn_write_closure" {
     GHC.Debug.debugErrLn_write_closure:
         const GHC.Debug.debugErrLn_write_info;
 },
 GHC.Debug.debugErrLn_write_entry() //  [R2, R3, R4]
         { info_tbl: [(cB6l,
                       label: GHC.Debug.debugErrLn_write_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB6l: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cB6m; else goto uB6B;
       cB6m: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Debug.debugErrLn_write_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uB6B: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cB6b() args: 0, res: 0, upd: 0;
     }
 },
 _cB6b() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB6b: // global
           I64[Sp - 8] = block_cB6e_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uB6D; else goto cB6f;
       uB6D: // global
           call _cB6e(R1) args: 0, res: 0, upd: 0;
       cB6f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cB6e() //  [R1]
         { info_tbl: [(cB6e,
                       label: block_cB6e_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB6e: // global
           if (R1 & 7 == 1) goto cB6i; else goto cB6j;
       cB6i: // global
           I8[P64[Sp + 8] + (I64[Sp + 16] + 16)] = 0 :: W8;
           Sp = Sp + 32;
           call (I64[P64[Sp]])() args: 8, res: 0, upd: 8;
       cB6j: // global
           I64[Sp] = block_cB6t_info;
           _sB5l::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sB5l::P64;
           if (R1 & 7 != 0) goto uB6E; else goto cB6v;
       uB6E: // global
           call _cB6t(R1) args: 0, res: 0, upd: 0;
       cB6v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cB6t() //  [R1]
         { info_tbl: [(cB6t,
                       label: block_cB6t_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB6t: // global
           _sB5f::P64 = P64[Sp + 8];
           _sB5g::I64 = I64[Sp + 16];
           _sB5l::P64 = P64[Sp + 24];
           I8[(_sB5f::P64 + 16) + _sB5g::I64] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _sB5f::P64;
           I64[Sp + 16] = _sB5g::I64 + 1;
           P64[Sp + 24] = _sB5l::P64;
           Sp = Sp + 8;
           call _cB6b() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.375371309 UTC

[section ""cstring" . GHC.Debug.$trModule4_bytes" {
     GHC.Debug.$trModule4_bytes:
         I8[] [103,104,99,45,112,114,105,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.375947022 UTC

[section ""data" . GHC.Debug.$trModule3_closure" {
     GHC.Debug.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Debug.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.376679989 UTC

[section ""cstring" . GHC.Debug.$trModule2_bytes" {
     GHC.Debug.$trModule2_bytes:
         I8[] [71,72,67,46,68,101,98,117,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.377367114 UTC

[section ""data" . GHC.Debug.$trModule1_closure" {
     GHC.Debug.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Debug.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.377997478 UTC

[section ""data" . GHC.Debug.$trModule_closure" {
     GHC.Debug.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Debug.$trModule3_closure+1;
         const GHC.Debug.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.3790624 UTC

[section ""data" . GHC.Debug.debugLn1_closure" {
     GHC.Debug.debugLn1_closure:
         const GHC.Debug.debugLn1_info;
 },
 GHC.Debug.debugLn1_entry() //  [R2]
         { info_tbl: [(cB6N,
                       label: GHC.Debug.debugLn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB6N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cB6O; else goto cB6P;
       cB6O: // global
           R2 = R2;
           R1 = GHC.Debug.debugLn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cB6P: // global
           I64[Sp - 16] = block_cB6L_info;
           R3 = R2;
           _sB5q::P64 = R2;
           R2 = 1;
           P64[Sp - 8] = _sB5q::P64;
           Sp = Sp - 16;
           call GHC.Debug.debugErrLn_len_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cB6L() //  [R1]
         { info_tbl: [(cB6L,
                       label: block_cB6L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB6L: // global
           I64[Sp] = block_cB6S_info;
           R1 = R1;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cB6S() //  [R1]
         { info_tbl: [(cB6S,
                       label: block_cB6S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB6S: // global
           I64[Sp] = block_cB6U_info;
           R4 = P64[Sp + 8];
           R3 = 0;
           R2 = R1;
           P64[Sp + 8] = R1;
           call GHC.Debug.debugErrLn_write_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cB6U() //  []
         { info_tbl: [(cB6U,
                       label: block_cB6U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB6U: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] debugLn(P64[Sp + 8] + 16);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.380499042 UTC

[section ""data" . GHC.Debug.debugLn_closure" {
     GHC.Debug.debugLn_closure:
         const GHC.Debug.debugLn_info;
 },
 GHC.Debug.debugLn_entry() //  [R2]
         { info_tbl: [(cB75,
                       label: GHC.Debug.debugLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB75: // global
           R2 = R2;
           call GHC.Debug.debugLn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.381629946 UTC

[section ""data" . GHC.Debug.debugErrLn1_closure" {
     GHC.Debug.debugErrLn1_closure:
         const GHC.Debug.debugErrLn1_info;
 },
 GHC.Debug.debugErrLn1_entry() //  [R2]
         { info_tbl: [(cB7e,
                       label: GHC.Debug.debugErrLn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB7e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cB7f; else goto cB7g;
       cB7f: // global
           R2 = R2;
           R1 = GHC.Debug.debugErrLn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cB7g: // global
           I64[Sp - 16] = block_cB7c_info;
           R3 = R2;
           _sB5A::P64 = R2;
           R2 = 1;
           P64[Sp - 8] = _sB5A::P64;
           Sp = Sp - 16;
           call GHC.Debug.debugErrLn_len_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cB7c() //  [R1]
         { info_tbl: [(cB7c,
                       label: block_cB7c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB7c: // global
           I64[Sp] = block_cB7j_info;
           R1 = R1;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cB7j() //  [R1]
         { info_tbl: [(cB7j,
                       label: block_cB7j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB7j: // global
           I64[Sp] = block_cB7l_info;
           R4 = P64[Sp + 8];
           R3 = 0;
           R2 = R1;
           P64[Sp + 8] = R1;
           call GHC.Debug.debugErrLn_write_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cB7l() //  []
         { info_tbl: [(cB7l,
                       label: block_cB7l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB7l: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] debugErrLn(P64[Sp + 8] + 16);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.383149885 UTC

[section ""data" . GHC.Debug.debugErrLn_closure" {
     GHC.Debug.debugErrLn_closure:
         const GHC.Debug.debugErrLn_info;
 },
 GHC.Debug.debugErrLn_entry() //  [R2]
         { info_tbl: [(cB7w,
                       label: GHC.Debug.debugErrLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB7w: // global
           R2 = R2;
           call GHC.Debug.debugErrLn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.384046415 UTC

[section ""relreadonly" . SB7z_srt" { SB7z_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.38466972 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:50:22.385727307 UTC

[section ""data" . GHC.Debug.debugErrLn_len_closure" {
     GHC.Debug.debugErrLn_len_closure:
         const GHC.Debug.debugErrLn_len_info;
 },
 GHC.Debug.debugErrLn_len_entry() //  [R2, R3]
         { info_tbl: [(cB7L,
                       label: GHC.Debug.debugErrLn_len_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB7L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cB7M; else goto uB7V;
       cB7M: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Debug.debugErrLn_len_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uB7V: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cB7B() args: 0, res: 0, upd: 0;
     }
 },
 _cB7B() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB7B: // global
           I64[Sp - 8] = block_cB7E_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uB7X; else goto cB7F;
       uB7X: // global
           call _cB7E(R1) args: 0, res: 0, upd: 0;
       cB7F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cB7E() //  [R1]
         { info_tbl: [(cB7E,
                       label: block_cB7E_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB7E: // global
           _sB59::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cB7I; else goto cB7J;
       cB7I: // global
           R1 = _sB59::I64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cB7J: // global
           I64[Sp + 8] = _sB59::I64 + 1;
           P64[Sp + 16] = P64[R1 + 14];
           Sp = Sp + 8;
           call _cB7B() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.387556324 UTC

[section ""data" . GHC.Debug.debugErrLn_write_closure" {
     GHC.Debug.debugErrLn_write_closure:
         const GHC.Debug.debugErrLn_write_info;
 },
 GHC.Debug.debugErrLn_write_entry() //  [R2, R3, R4]
         { info_tbl: [(cB8b,
                       label: GHC.Debug.debugErrLn_write_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB8b: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cB8c; else goto uB8r;
       cB8c: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Debug.debugErrLn_write_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uB8r: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cB81() args: 0, res: 0, upd: 0;
     }
 },
 _cB81() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB81: // global
           I64[Sp - 8] = block_cB84_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uB8t; else goto cB85;
       uB8t: // global
           call _cB84(R1) args: 0, res: 0, upd: 0;
       cB85: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cB84() //  [R1]
         { info_tbl: [(cB84,
                       label: block_cB84_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB84: // global
           if (R1 & 7 == 1) goto cB88; else goto cB89;
       cB88: // global
           I8[P64[Sp + 8] + (I64[Sp + 16] + 16)] = 0 :: W8;
           Sp = Sp + 32;
           call (I64[P64[Sp]])() args: 8, res: 0, upd: 8;
       cB89: // global
           I64[Sp] = block_cB8j_info;
           _sB5l::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sB5l::P64;
           if (R1 & 7 != 0) goto uB8u; else goto cB8l;
       uB8u: // global
           call _cB8j(R1) args: 0, res: 0, upd: 0;
       cB8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cB8j() //  [R1]
         { info_tbl: [(cB8j,
                       label: block_cB8j_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB8j: // global
           _sB5f::P64 = P64[Sp + 8];
           _sB5g::I64 = I64[Sp + 16];
           _sB5l::P64 = P64[Sp + 24];
           I8[(_sB5f::P64 + 16) + _sB5g::I64] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _sB5f::P64;
           I64[Sp + 16] = _sB5g::I64 + 1;
           P64[Sp + 24] = _sB5l::P64;
           Sp = Sp + 8;
           call _cB81() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.389167444 UTC

[section ""cstring" . GHC.Debug.$trModule4_bytes" {
     GHC.Debug.$trModule4_bytes:
         I8[] [103,104,99,45,112,114,105,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.389838404 UTC

[section ""data" . GHC.Debug.$trModule3_closure" {
     GHC.Debug.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Debug.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.390442091 UTC

[section ""cstring" . GHC.Debug.$trModule2_bytes" {
     GHC.Debug.$trModule2_bytes:
         I8[] [71,72,67,46,68,101,98,117,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.39116471 UTC

[section ""data" . GHC.Debug.$trModule1_closure" {
     GHC.Debug.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Debug.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.391761285 UTC

[section ""data" . GHC.Debug.$trModule_closure" {
     GHC.Debug.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Debug.$trModule3_closure+1;
         const GHC.Debug.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.392787255 UTC

[section ""data" . GHC.Debug.debugLn1_closure" {
     GHC.Debug.debugLn1_closure:
         const GHC.Debug.debugLn1_info;
 },
 GHC.Debug.debugLn1_entry() //  [R2]
         { info_tbl: [(cB8D,
                       label: GHC.Debug.debugLn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB8D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cB8E; else goto cB8F;
       cB8E: // global
           R2 = R2;
           R1 = GHC.Debug.debugLn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cB8F: // global
           I64[Sp - 16] = block_cB8B_info;
           R3 = R2;
           _sB5q::P64 = R2;
           R2 = 1;
           P64[Sp - 8] = _sB5q::P64;
           Sp = Sp - 16;
           call GHC.Debug.debugErrLn_len_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cB8B() //  [R1]
         { info_tbl: [(cB8B,
                       label: block_cB8B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB8B: // global
           I64[Sp] = block_cB8I_info;
           R1 = R1;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cB8I() //  [R1]
         { info_tbl: [(cB8I,
                       label: block_cB8I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB8I: // global
           I64[Sp] = block_cB8K_info;
           R4 = P64[Sp + 8];
           R3 = 0;
           R2 = R1;
           P64[Sp + 8] = R1;
           call GHC.Debug.debugErrLn_write_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cB8K() //  []
         { info_tbl: [(cB8K,
                       label: block_cB8K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB8K: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] debugLn(P64[Sp + 8] + 16);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.394304387 UTC

[section ""data" . GHC.Debug.debugLn_closure" {
     GHC.Debug.debugLn_closure:
         const GHC.Debug.debugLn_info;
 },
 GHC.Debug.debugLn_entry() //  [R2]
         { info_tbl: [(cB8V,
                       label: GHC.Debug.debugLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB8V: // global
           R2 = R2;
           call GHC.Debug.debugLn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.395445698 UTC

[section ""data" . GHC.Debug.debugErrLn1_closure" {
     GHC.Debug.debugErrLn1_closure:
         const GHC.Debug.debugErrLn1_info;
 },
 GHC.Debug.debugErrLn1_entry() //  [R2]
         { info_tbl: [(cB94,
                       label: GHC.Debug.debugErrLn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB94: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cB95; else goto cB96;
       cB95: // global
           R2 = R2;
           R1 = GHC.Debug.debugErrLn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cB96: // global
           I64[Sp - 16] = block_cB92_info;
           R3 = R2;
           _sB5A::P64 = R2;
           R2 = 1;
           P64[Sp - 8] = _sB5A::P64;
           Sp = Sp - 16;
           call GHC.Debug.debugErrLn_len_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cB92() //  [R1]
         { info_tbl: [(cB92,
                       label: block_cB92_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB92: // global
           I64[Sp] = block_cB99_info;
           R1 = R1;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cB99() //  [R1]
         { info_tbl: [(cB99,
                       label: block_cB99_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB99: // global
           I64[Sp] = block_cB9b_info;
           R4 = P64[Sp + 8];
           R3 = 0;
           R2 = R1;
           P64[Sp + 8] = R1;
           call GHC.Debug.debugErrLn_write_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cB9b() //  []
         { info_tbl: [(cB9b,
                       label: block_cB9b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB9b: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] debugErrLn(P64[Sp + 8] + 16);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.396929433 UTC

[section ""data" . GHC.Debug.debugErrLn_closure" {
     GHC.Debug.debugErrLn_closure:
         const GHC.Debug.debugErrLn_info;
 },
 GHC.Debug.debugErrLn_entry() //  [R2]
         { info_tbl: [(cB9m,
                       label: GHC.Debug.debugErrLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB9m: // global
           R2 = R2;
           call GHC.Debug.debugErrLn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.397755394 UTC

[section ""relreadonly" . SB7z_srt" { SB7z_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.398663402 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:50:22.400413389 UTC

[section ""data" . GHC.Debug.debugErrLn_len_closure" {
     GHC.Debug.debugErrLn_len_closure:
         const GHC.Debug.debugErrLn_len_info;
 },
 GHC.Debug.debugErrLn_len_entry() //  [R2, R3]
         { info_tbl: [(cB9A,
                       label: GHC.Debug.debugErrLn_len_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB9A: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cB9B; else goto uB9K;
       cB9B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Debug.debugErrLn_len_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uB9K: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cB9q() args: 0, res: 0, upd: 0;
     }
 },
 _cB9q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB9q: // global
           I64[Sp - 8] = block_cB9t_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uB9M; else goto cB9u;
       uB9M: // global
           call _cB9t(R1) args: 0, res: 0, upd: 0;
       cB9u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cB9t() //  [R1]
         { info_tbl: [(cB9t,
                       label: block_cB9t_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cB9t: // global
           _sB59::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cB9x; else goto cB9y;
       cB9x: // global
           R1 = _sB59::I64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cB9y: // global
           I64[Sp + 8] = _sB59::I64 + 1;
           P64[Sp + 16] = P64[R1 + 14];
           Sp = Sp + 8;
           call _cB9q() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.410127913 UTC

[section ""data" . GHC.Debug.debugErrLn_write_closure" {
     GHC.Debug.debugErrLn_write_closure:
         const GHC.Debug.debugErrLn_write_info;
 },
 GHC.Debug.debugErrLn_write_entry() //  [R2, R3, R4]
         { info_tbl: [(cBag,
                       label: GHC.Debug.debugErrLn_write_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBag: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cBah; else goto uBaw;
       cBah: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Debug.debugErrLn_write_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uBaw: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cBa6() args: 0, res: 0, upd: 0;
     }
 },
 _cBa6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBa6: // global
           I64[Sp - 8] = block_cBa9_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uBay; else goto cBaa;
       uBay: // global
           call _cBa9(R1) args: 0, res: 0, upd: 0;
       cBaa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cBa9() //  [R1]
         { info_tbl: [(cBa9,
                       label: block_cBa9_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBa9: // global
           if (R1 & 7 == 1) goto cBad; else goto cBae;
       cBad: // global
           I8[P64[Sp + 8] + (I64[Sp + 16] + 16)] = 0 :: W8;
           Sp = Sp + 32;
           call (I64[P64[Sp]])() args: 8, res: 0, upd: 8;
       cBae: // global
           I64[Sp] = block_cBao_info;
           _sB5l::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sB5l::P64;
           if (R1 & 7 != 0) goto uBaz; else goto cBaq;
       uBaz: // global
           call _cBao(R1) args: 0, res: 0, upd: 0;
       cBaq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cBao() //  [R1]
         { info_tbl: [(cBao,
                       label: block_cBao_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBao: // global
           _sB5f::P64 = P64[Sp + 8];
           _sB5g::I64 = I64[Sp + 16];
           _sB5l::P64 = P64[Sp + 24];
           I8[(_sB5f::P64 + 16) + _sB5g::I64] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _sB5f::P64;
           I64[Sp + 16] = _sB5g::I64 + 1;
           P64[Sp + 24] = _sB5l::P64;
           Sp = Sp + 8;
           call _cBa6() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.419831933 UTC

[section ""cstring" . GHC.Debug.$trModule4_bytes" {
     GHC.Debug.$trModule4_bytes:
         I8[] [103,104,99,45,112,114,105,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.421592036 UTC

[section ""data" . GHC.Debug.$trModule3_closure" {
     GHC.Debug.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Debug.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.423319796 UTC

[section ""cstring" . GHC.Debug.$trModule2_bytes" {
     GHC.Debug.$trModule2_bytes:
         I8[] [71,72,67,46,68,101,98,117,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.425011129 UTC

[section ""data" . GHC.Debug.$trModule1_closure" {
     GHC.Debug.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Debug.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.426763592 UTC

[section ""data" . GHC.Debug.$trModule_closure" {
     GHC.Debug.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Debug.$trModule3_closure+1;
         const GHC.Debug.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.428882635 UTC

[section ""data" . GHC.Debug.debugLn1_closure" {
     GHC.Debug.debugLn1_closure:
         const GHC.Debug.debugLn1_info;
 },
 GHC.Debug.debugLn1_entry() //  [R2]
         { info_tbl: [(cBbb,
                       label: GHC.Debug.debugLn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBbb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cBbc; else goto cBbd;
       cBbc: // global
           R2 = R2;
           R1 = GHC.Debug.debugLn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cBbd: // global
           I64[Sp - 16] = block_cBb9_info;
           R3 = R2;
           _sB5q::P64 = R2;
           R2 = 1;
           P64[Sp - 8] = _sB5q::P64;
           Sp = Sp - 16;
           call GHC.Debug.debugErrLn_len_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cBb9() //  [R1]
         { info_tbl: [(cBb9,
                       label: block_cBb9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBb9: // global
           I64[Sp] = block_cBbg_info;
           R1 = R1;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cBbg() //  [R1]
         { info_tbl: [(cBbg,
                       label: block_cBbg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBbg: // global
           I64[Sp] = block_cBbi_info;
           R4 = P64[Sp + 8];
           R3 = 0;
           R2 = R1;
           P64[Sp + 8] = R1;
           call GHC.Debug.debugErrLn_write_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cBbi() //  []
         { info_tbl: [(cBbi,
                       label: block_cBbi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBbi: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] debugLn(P64[Sp + 8] + 16);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.437428715 UTC

[section ""data" . GHC.Debug.debugLn_closure" {
     GHC.Debug.debugLn_closure:
         const GHC.Debug.debugLn_info;
 },
 GHC.Debug.debugLn_entry() //  [R2]
         { info_tbl: [(cBbJ,
                       label: GHC.Debug.debugLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBbJ: // global
           R2 = R2;
           call GHC.Debug.debugLn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.441010264 UTC

[section ""data" . GHC.Debug.debugErrLn1_closure" {
     GHC.Debug.debugErrLn1_closure:
         const GHC.Debug.debugErrLn1_info;
 },
 GHC.Debug.debugErrLn1_entry() //  [R2]
         { info_tbl: [(cBbW,
                       label: GHC.Debug.debugErrLn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBbW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cBbX; else goto cBbY;
       cBbX: // global
           R2 = R2;
           R1 = GHC.Debug.debugErrLn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cBbY: // global
           I64[Sp - 16] = block_cBbU_info;
           R3 = R2;
           _sB5A::P64 = R2;
           R2 = 1;
           P64[Sp - 8] = _sB5A::P64;
           Sp = Sp - 16;
           call GHC.Debug.debugErrLn_len_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cBbU() //  [R1]
         { info_tbl: [(cBbU,
                       label: block_cBbU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBbU: // global
           I64[Sp] = block_cBc1_info;
           R1 = R1;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cBc1() //  [R1]
         { info_tbl: [(cBc1,
                       label: block_cBc1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBc1: // global
           I64[Sp] = block_cBc3_info;
           R4 = P64[Sp + 8];
           R3 = 0;
           R2 = R1;
           P64[Sp + 8] = R1;
           call GHC.Debug.debugErrLn_write_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cBc3() //  []
         { info_tbl: [(cBc3,
                       label: block_cBc3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBc3: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] debugErrLn(P64[Sp + 8] + 16);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.450260806 UTC

[section ""data" . GHC.Debug.debugErrLn_closure" {
     GHC.Debug.debugErrLn_closure:
         const GHC.Debug.debugErrLn_info;
 },
 GHC.Debug.debugErrLn_entry() //  [R2]
         { info_tbl: [(cBcu,
                       label: GHC.Debug.debugErrLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBcu: // global
           R2 = R2;
           call GHC.Debug.debugErrLn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.453389701 UTC

[section ""relreadonly" . SB7z_srt" { SB7z_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.570773353 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:50:22.572640382 UTC

[section ""data" . GHC.Debug.debugErrLn_len_closure" {
     GHC.Debug.debugErrLn_len_closure:
         const GHC.Debug.debugErrLn_len_info;
 },
 GHC.Debug.debugErrLn_len_entry() //  [R2, R3]
         { info_tbl: [(cBdo,
                       label: GHC.Debug.debugErrLn_len_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBdo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cBdp; else goto uBdy;
       cBdp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Debug.debugErrLn_len_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uBdy: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cBde() args: 0, res: 0, upd: 0;
     }
 },
 _cBde() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBde: // global
           I64[Sp - 8] = block_cBdh_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uBdA; else goto cBdi;
       uBdA: // global
           call _cBdh(R1) args: 0, res: 0, upd: 0;
       cBdi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cBdh() //  [R1]
         { info_tbl: [(cBdh,
                       label: block_cBdh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBdh: // global
           _sBcC::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cBdl; else goto cBdm;
       cBdl: // global
           R1 = _sBcC::I64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cBdm: // global
           I64[Sp + 8] = _sBcC::I64 + 1;
           P64[Sp + 16] = P64[R1 + 14];
           Sp = Sp + 8;
           call _cBde() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.58169862 UTC

[section ""data" . GHC.Debug.debugErrLn_write_closure" {
     GHC.Debug.debugErrLn_write_closure:
         const GHC.Debug.debugErrLn_write_info;
 },
 GHC.Debug.debugErrLn_write_entry() //  [R2, R3, R4]
         { info_tbl: [(cBe5,
                       label: GHC.Debug.debugErrLn_write_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBe5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cBe6; else goto uBel;
       cBe6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Debug.debugErrLn_write_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uBel: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cBdV() args: 0, res: 0, upd: 0;
     }
 },
 _cBdV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBdV: // global
           I64[Sp - 8] = block_cBdY_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uBen; else goto cBdZ;
       uBen: // global
           call _cBdY(R1) args: 0, res: 0, upd: 0;
       cBdZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cBdY() //  [R1]
         { info_tbl: [(cBdY,
                       label: block_cBdY_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBdY: // global
           if (R1 & 7 == 1) goto cBe2; else goto cBe3;
       cBe2: // global
           I8[P64[Sp + 8] + (I64[Sp + 16] + 16)] = 0 :: W8;
           Sp = Sp + 32;
           call (I64[P64[Sp]])() args: 8, res: 0, upd: 8;
       cBe3: // global
           I64[Sp] = block_cBed_info;
           _sBcO::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sBcO::P64;
           if (R1 & 7 != 0) goto uBeo; else goto cBef;
       uBeo: // global
           call _cBed(R1) args: 0, res: 0, upd: 0;
       cBef: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cBed() //  [R1]
         { info_tbl: [(cBed,
                       label: block_cBed_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBed: // global
           _sBcI::P64 = P64[Sp + 8];
           _sBcJ::I64 = I64[Sp + 16];
           _sBcO::P64 = P64[Sp + 24];
           I8[(_sBcI::P64 + 16) + _sBcJ::I64] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _sBcI::P64;
           I64[Sp + 16] = _sBcJ::I64 + 1;
           P64[Sp + 24] = _sBcO::P64;
           Sp = Sp + 8;
           call _cBdV() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.591088573 UTC

[section ""cstring" . GHC.Debug.$trModule4_bytes" {
     GHC.Debug.$trModule4_bytes:
         I8[] [103,104,99,45,112,114,105,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.592984017 UTC

[section ""data" . GHC.Debug.$trModule3_closure" {
     GHC.Debug.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Debug.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.594957024 UTC

[section ""cstring" . GHC.Debug.$trModule2_bytes" {
     GHC.Debug.$trModule2_bytes:
         I8[] [71,72,67,46,68,101,98,117,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.596734069 UTC

[section ""data" . GHC.Debug.$trModule1_closure" {
     GHC.Debug.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Debug.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.598618744 UTC

[section ""data" . GHC.Debug.$trModule_closure" {
     GHC.Debug.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Debug.$trModule3_closure+1;
         const GHC.Debug.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.602037753 UTC

[section ""data" . GHC.Debug.debugLn1_closure" {
     GHC.Debug.debugLn1_closure:
         const GHC.Debug.debugLn1_info;
 },
 GHC.Debug.debugLn1_entry() //  [R2]
         { info_tbl: [(cBf2,
                       label: GHC.Debug.debugLn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBf2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cBf3; else goto cBf4;
       cBf3: // global
           R2 = R2;
           R1 = GHC.Debug.debugLn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cBf4: // global
           I64[Sp - 16] = block_cBf0_info;
           R3 = R2;
           _sBcT::P64 = R2;
           R2 = 1;
           P64[Sp - 8] = _sBcT::P64;
           Sp = Sp - 16;
           call GHC.Debug.debugErrLn_len_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cBf0() //  [R1]
         { info_tbl: [(cBf0,
                       label: block_cBf0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBf0: // global
           I64[Sp] = block_cBf7_info;
           R1 = R1;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cBf7() //  [R1]
         { info_tbl: [(cBf7,
                       label: block_cBf7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBf7: // global
           I64[Sp] = block_cBf9_info;
           R4 = P64[Sp + 8];
           R3 = 0;
           R2 = R1;
           P64[Sp + 8] = R1;
           call GHC.Debug.debugErrLn_write_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cBf9() //  []
         { info_tbl: [(cBf9,
                       label: block_cBf9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBf9: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] debugLn(P64[Sp + 8] + 16);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.611828157 UTC

[section ""data" . GHC.Debug.debugLn_closure" {
     GHC.Debug.debugLn_closure:
         const GHC.Debug.debugLn_info;
 },
 GHC.Debug.debugLn_entry() //  [R2]
         { info_tbl: [(cBfE,
                       label: GHC.Debug.debugLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBfE: // global
           R2 = R2;
           call GHC.Debug.debugLn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.615931285 UTC

[section ""data" . GHC.Debug.debugErrLn1_closure" {
     GHC.Debug.debugErrLn1_closure:
         const GHC.Debug.debugErrLn1_info;
 },
 GHC.Debug.debugErrLn1_entry() //  [R2]
         { info_tbl: [(cBfR,
                       label: GHC.Debug.debugErrLn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBfR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cBfS; else goto cBfT;
       cBfS: // global
           R2 = R2;
           R1 = GHC.Debug.debugErrLn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cBfT: // global
           I64[Sp - 16] = block_cBfP_info;
           R3 = R2;
           _sBd3::P64 = R2;
           R2 = 1;
           P64[Sp - 8] = _sBd3::P64;
           Sp = Sp - 16;
           call GHC.Debug.debugErrLn_len_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cBfP() //  [R1]
         { info_tbl: [(cBfP,
                       label: block_cBfP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBfP: // global
           I64[Sp] = block_cBfW_info;
           R1 = R1;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cBfW() //  [R1]
         { info_tbl: [(cBfW,
                       label: block_cBfW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBfW: // global
           I64[Sp] = block_cBfY_info;
           R4 = P64[Sp + 8];
           R3 = 0;
           R2 = R1;
           P64[Sp + 8] = R1;
           call GHC.Debug.debugErrLn_write_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cBfY() //  []
         { info_tbl: [(cBfY,
                       label: block_cBfY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBfY: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] debugErrLn(P64[Sp + 8] + 16);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.625757419 UTC

[section ""data" . GHC.Debug.debugErrLn_closure" {
     GHC.Debug.debugErrLn_closure:
         const GHC.Debug.debugErrLn_info;
 },
 GHC.Debug.debugErrLn_entry() //  [R2]
         { info_tbl: [(cBgt,
                       label: GHC.Debug.debugErrLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cBgt: // global
           R2 = R2;
           call GHC.Debug.debugErrLn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:50:22.629447114 UTC

[section ""relreadonly" . SBgA_srt" { SBgA_srt:
 }]

