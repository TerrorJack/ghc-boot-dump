
==================== Raw Cmm ====================
2018-03-16 15:49:39.736209513 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:49:39.739766835 UTC

[section ""data" . GHC.CString.unpackCString#_closure" {
     GHC.CString.unpackCString#_closure:
         const GHC.CString.unpackCString#_info;
 },
 sat_sjMu_entry() //  [R1]
         { []
         }
     {offset
       ck24: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck25; else goto ck26;
       ck25: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck26: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMp_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sjMu_info" {
     sat_sjMu_info:
         const sat_sjMu_entry;
         const 4294967297;
         const 19;
 },
 unpack_sjMp_entry() //  [R1, R2]
         { []
         }
     {offset
       ck2a: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ck2b; else goto ck2c;
       ck2b: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck2c: // global
           _sjMr::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 7] + R2]);
           if (_sjMr::I64 == 0) goto ck29; else goto uk2n;
       ck29: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uk2n: // global
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMr::I64;
           Sp = Sp - 24;
           call _ck1W() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . unpack_sjMp_info" {
     unpack_sjMp_info:
         const unpack_sjMp_entry;
         const 4294967296;
         const 10;
         const 4294967300;
 },
 _ck1W() //  []
         { []
         }
     {offset
       ck1W: // global
           Hp = Hp + 72;
           _sjMr::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto ck2h; else goto ck2g;
       ck2h: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_ck1V_info;
           R1 = _sjMr::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ck2g: // global
           I64[Hp - 64] = sat_sjMu_info;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sjMr::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ck1V() //  [R1]
         { []
         }
     {offset
       ck1V: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _ck1W() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ck1V_info" {
     block_ck1V_info:
         const _ck1V;
         const 387;
         const 30;
 },
 GHC.CString.unpackCString#_entry() //  [R2]
         { []
         }
     {offset
       ck2r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ck2v; else goto ck2u;
       ck2v: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.CString.unpackCString#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck2u: // global
           I64[Hp - 8] = unpack_sjMp_info;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 7;
           call unpack_sjMp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.CString.unpackCString#_info" {
     GHC.CString.unpackCString#_info:
         const GHC.CString.unpackCString#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:39.753651002 UTC

[section ""data" . GHC.CString.unpackAppendCString#_closure" {
     GHC.CString.unpackAppendCString#_closure:
         const GHC.CString.unpackAppendCString#_info;
 },
 sat_sjMC_entry() //  [R1]
         { []
         }
     {offset
       ck3g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck3h; else goto ck3i;
       ck3h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck3i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMx_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sjMC_info" {
     sat_sjMC_info:
         const sat_sjMC_entry;
         const 4294967297;
         const 19;
 },
 unpack_sjMx_entry() //  [R1, R2]
         { []
         }
     {offset
       ck3m: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ck3n; else goto ck3o;
       ck3n: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck3o: // global
           _sjMz::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 15] + R2]);
           if (_sjMz::I64 == 0) goto ck3l; else goto uk3z;
       ck3l: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       uk3z: // global
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMz::I64;
           Sp = Sp - 24;
           call _ck38() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . unpack_sjMx_info" {
     unpack_sjMx_info:
         const unpack_sjMx_entry;
         const 4294967297;
         const 12;
         const 4294967300;
 },
 _ck38() //  []
         { []
         }
     {offset
       ck38: // global
           Hp = Hp + 72;
           _sjMz::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto ck3t; else goto ck3s;
       ck3t: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_ck37_info;
           R1 = _sjMz::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ck3s: // global
           I64[Hp - 64] = sat_sjMC_info;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sjMz::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ck37() //  [R1]
         { []
         }
     {offset
       ck37: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _ck38() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ck37_info" {
     block_ck37_info:
         const _ck37;
         const 387;
         const 30;
 },
 GHC.CString.unpackAppendCString#_entry() //  [R2, R3]
         { []
         }
     {offset
       ck3D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ck3H; else goto ck3G;
       ck3H: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackAppendCString#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ck3G: // global
           I64[Hp - 16] = unpack_sjMx_info;
           P64[Hp - 8] = R3;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 15;
           call unpack_sjMx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.CString.unpackAppendCString#_info" {
     GHC.CString.unpackAppendCString#_info:
         const GHC.CString.unpackAppendCString#_entry;
         const 0;
         const 14;
         const 8589934605;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:39.766472127 UTC

[section ""data" . GHC.CString.unpackFoldrCString#_closure" {
     GHC.CString.unpackFoldrCString#_closure:
         const GHC.CString.unpackFoldrCString#_info;
 },
 sat_sjML_entry() //  [R1]
         { []
         }
     {offset
       ck4t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck4u; else goto ck4v;
       ck4u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck4v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMG_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sjML_info" {
     sat_sjML_info:
         const sat_sjML_entry;
         const 4294967297;
         const 19;
 },
 unpack_sjMG_entry() //  [R1, R2]
         { []
         }
     {offset
       ck4z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck4A; else goto ck4B;
       ck4A: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck4B: // global
           _sjMI::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 23] + R2]);
           if (_sjMI::I64 == 0) goto ck4y; else goto uk4L;
       ck4y: // global
           R1 = P64[R1 + 15];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       uk4L: // global
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMI::I64;
           Sp = Sp - 32;
           call _ck4l() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . unpack_sjMG_info" {
     unpack_sjMG_info:
         const unpack_sjMG_entry;
         const 4294967298;
         const 8;
         const 4294967300;
 },
 _ck4l() //  []
         { []
         }
     {offset
       ck4l: // global
           Hp = Hp + 48;
           _sjMI::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto ck4F; else goto ck4E;
       ck4F: // global
           HpAlloc = 48;
           I64[Sp - 8] = block_ck4k_info;
           R1 = _sjMI::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ck4E: // global
           I64[Hp - 40] = sat_sjML_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sjMI::I64;
           R3 = Hp - 40;
           R2 = Hp - 7;
           R1 = P64[Sp];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ck4k() //  [R1]
         { []
         }
     {offset
       ck4k: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _ck4l() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ck4k_info" {
     block_ck4k_info:
         const _ck4k;
         const 772;
         const 30;
 },
 GHC.CString.unpackFoldrCString#_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ck4P: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ck4T; else goto ck4S;
       ck4T: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackFoldrCString#_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ck4S: // global
           I64[Hp - 24] = unpack_sjMG_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 23;
           call unpack_sjMG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.CString.unpackFoldrCString#_info" {
     GHC.CString.unpackFoldrCString#_info:
         const GHC.CString.unpackFoldrCString#_entry;
         const 0;
         const 14;
         const 12884901907;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:39.781091975 UTC

[section ""data" . GHC.CString.unpackCStringUtf8#_closure" {
     GHC.CString.unpackCStringUtf8#_closure:
         const GHC.CString.unpackCStringUtf8#_info;
 },
 sat_sjNg_entry() //  [R1]
         { []
         }
     {offset
       ck62: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck63; else goto ck64;
       ck63: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck64: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 4;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sjNg_info" {
     sat_sjNg_info:
         const sat_sjNg_entry;
         const 4294967297;
         const 19;
 },
 sat_sjNy_entry() //  [R1]
         { []
         }
     {offset
       ck6o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck6p; else goto ck6q;
       ck6p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck6q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 3;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sjNy_info" {
     sat_sjNy_info:
         const sat_sjNy_entry;
         const 4294967297;
         const 19;
 },
 sat_sjNK_entry() //  [R1]
         { []
         }
     {offset
       ck6E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck6F; else goto ck6G;
       ck6F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck6G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sjNK_info" {
     sat_sjNK_info:
         const sat_sjNK_entry;
         const 4294967297;
         const 19;
 },
 sat_sjNN_entry() //  [R1]
         { []
         }
     {offset
       ck6O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck6P; else goto ck6Q;
       ck6P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck6Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sjNN_info" {
     sat_sjNN_info:
         const sat_sjNN_entry;
         const 4294967297;
         const 19;
 },
 unpack_sjMN_entry() //  [R1, R2]
         { []
         }
     {offset
       ck6U: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck6V; else goto ck6W;
       ck6V: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck6W: // global
           _sjMM::I64 = I64[R1 + 7];
           _sjMP::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + R2]);
           if (_sjMP::I64 == 0) goto ck6T; else goto uk8X;
       ck6T: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uk8X: // global
           I64[Sp - 32] = _sjMM::I64;
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMP::I64;
           Sp = Sp - 32;
           call _ck5t() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . unpack_sjMN_info" {
     unpack_sjMN_info:
         const unpack_sjMN_entry;
         const 4294967296;
         const 10;
         const 4294967300;
 },
 _ck5t() //  []
         { []
         }
     {offset
       ck5t: // global
           Hp = Hp + 72;
           _sjMP::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto ck6Z; else goto ck6Y;
       ck6Z: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_ck5s_info;
           R1 = _sjMP::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ck6Y: // global
           _sjMN::P64 = P64[Sp + 8];
           _sjMO::I64 = I64[Sp + 16];
           if (_sjMP::I64 > 127) goto ck8O; else goto ck8R;
       ck8O: // global
           _sjMM::I64 = I64[Sp];
           if (_sjMP::I64 > 223) goto ck8o; else goto ck8M;
       ck8o: // global
           if (_sjMP::I64 > 239) goto ck7M; else goto ck8m;
       ck7M: // global
           _sjMU::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 3)]);
           _sjMW::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 2)]);
           _sjMY::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 1)]);
           I64[Hp - 64] = sat_sjNg_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_sjMP::I64 + -240) << 18) + (((_sjMY::I64 + -128) << 12) + (((_sjMW::I64 + -128) << 6) + (_sjMU::I64 + -128)));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck8m: // global
           _sjNi::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 2)]);
           _sjNk::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 1)]);
           I64[Hp - 64] = sat_sjNy_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_sjMP::I64 + -224) << 12) + (((_sjNk::I64 + -128) << 6) + (_sjNi::I64 + -128));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck8M: // global
           _sjNA::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 1)]);
           I64[Hp - 64] = sat_sjNK_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_sjMP::I64 + -192) << 6) + (_sjNA::I64 + -128);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck8R: // global
           I64[Hp - 64] = sat_sjNN_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sjMP::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ck5s() //  [R1]
         { []
         }
     {offset
       ck5s: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _ck5t() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ck5s_info" {
     block_ck5s_info:
         const _ck5s;
         const 836;
         const 30;
 },
 GHC.CString.unpackCStringUtf8#_entry() //  [R2]
         { []
         }
     {offset
       ck91: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ck95; else goto ck94;
       ck95: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.CString.unpackCStringUtf8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck94: // global
           I64[Hp - 8] = unpack_sjMN_info;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 7;
           call unpack_sjMN_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.CString.unpackCStringUtf8#_info" {
     GHC.CString.unpackCStringUtf8#_info:
         const GHC.CString.unpackCStringUtf8#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:39.800118954 UTC

[section ""data" . GHC.CString.unpackNBytes#_closure" {
     GHC.CString.unpackNBytes#_closure:
         const GHC.CString.unpackNBytes#_info;
 },
 GHC.CString.unpackNBytes#_entry() //  [R2, R3]
         { []
         }
     {offset
       ckaD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ckaE; else goto ckaF;
       ckaE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackNBytes#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckaF: // global
           if (R3 == 0) goto ckaC; else goto ckaB;
       ckaC: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckaB: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = R3 - 1;
           Sp = Sp - 32;
           call _ckam() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.CString.unpackNBytes#_info" {
     GHC.CString.unpackNBytes#_info:
         const GHC.CString.unpackNBytes#_entry;
         const 0;
         const 14;
         const 8589934604;
 },
 _ckam() //  []
         { []
         }
     {offset
       ckam: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ckaI; else goto ckaH;
       ckaI: // global
           HpAlloc = 40;
           I64[Sp] = block_ckam_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ckaH: // global
           _sjNS::P64 = P64[Sp + 16];
           _sjNT::I64 = I64[Sp + 24];
           if (%MO_S_Ge_W64(_sjNT::I64, 0)) goto ckaK; else goto ckaL;
       ckaK: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + _sjNT::I64]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sjNS::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _sjNT::I64 - 1;
           call _ckam() args: 0, res: 0, upd: 0;
       ckaL: // global
           Hp = Hp - 40;
           R1 = _sjNS::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckam_info" {
     block_ckam_info:
         const _ckam;
         const 323;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:39.805812086 UTC

[section ""cstring" . GHC.CString.$trModule4_bytes" {
     GHC.CString.$trModule4_bytes:
         I8[] [103,104,99,45,112,114,105,109]
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:39.807491965 UTC

[section ""data" . GHC.CString.$trModule3_closure" {
     GHC.CString.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.CString.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:39.809322759 UTC

[section ""cstring" . GHC.CString.$trModule2_bytes" {
     GHC.CString.$trModule2_bytes:
         I8[] [71,72,67,46,67,83,116,114,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:39.811055609 UTC

[section ""data" . GHC.CString.$trModule1_closure" {
     GHC.CString.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.CString.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:39.812923204 UTC

[section ""data" . GHC.CString.$trModule_closure" {
     GHC.CString.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.CString.$trModule3_closure+1;
         const GHC.CString.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:39.815312849 UTC

[section ""relreadonly" . SjUR_srt" { SjUR_srt:
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:40.017919824 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:49:40.021503456 UTC

[section ""data" . GHC.CString.unpackCString#_closure" {
     GHC.CString.unpackCString#_closure:
         const GHC.CString.unpackCString#_info;
 },
 sat_skbj_entry() //  [R1]
         { []
         }
     {offset
       ckda: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckdb; else goto ckdc;
       ckdb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbe_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_skbj_info" {
     sat_skbj_info:
         const sat_skbj_entry;
         const 4294967297;
         const 19;
 },
 unpack_skbe_entry() //  [R1, R2]
         { []
         }
     {offset
       ckdg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ckdh; else goto ckdi;
       ckdh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckdi: // global
           _skbg::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 7] + R2]);
           if (_skbg::I64 == 0) goto ckdf; else goto ukdt;
       ckdf: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ukdt: // global
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _skbg::I64;
           Sp = Sp - 24;
           call _ckd2() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . unpack_skbe_info" {
     unpack_skbe_info:
         const unpack_skbe_entry;
         const 4294967296;
         const 10;
         const 4294967300;
 },
 _ckd2() //  []
         { []
         }
     {offset
       ckd2: // global
           Hp = Hp + 72;
           _skbg::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto ckdn; else goto ckdm;
       ckdn: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_ckd1_info;
           R1 = _skbg::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ckdm: // global
           I64[Hp - 64] = sat_skbj_info;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _skbg::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ckd1() //  [R1]
         { []
         }
     {offset
       ckd1: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _ckd2() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ckd1_info" {
     block_ckd1_info:
         const _ckd1;
         const 387;
         const 30;
 },
 GHC.CString.unpackCString#_entry() //  [R2]
         { []
         }
     {offset
       ckdx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ckdB; else goto ckdA;
       ckdB: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.CString.unpackCString#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckdA: // global
           I64[Hp - 8] = unpack_skbe_info;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 7;
           call unpack_skbe_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.CString.unpackCString#_info" {
     GHC.CString.unpackCString#_info:
         const GHC.CString.unpackCString#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:40.033608372 UTC

[section ""data" . GHC.CString.unpackAppendCString#_closure" {
     GHC.CString.unpackAppendCString#_closure:
         const GHC.CString.unpackAppendCString#_info;
 },
 sat_skbr_entry() //  [R1]
         { []
         }
     {offset
       cket: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckeu; else goto ckev;
       ckeu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckev: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbm_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_skbr_info" {
     sat_skbr_info:
         const sat_skbr_entry;
         const 4294967297;
         const 19;
 },
 unpack_skbm_entry() //  [R1, R2]
         { []
         }
     {offset
       ckez: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ckeA; else goto ckeB;
       ckeA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckeB: // global
           _skbo::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 15] + R2]);
           if (_skbo::I64 == 0) goto ckey; else goto ukeM;
       ckey: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ukeM: // global
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _skbo::I64;
           Sp = Sp - 24;
           call _ckel() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . unpack_skbm_info" {
     unpack_skbm_info:
         const unpack_skbm_entry;
         const 4294967297;
         const 12;
         const 4294967300;
 },
 _ckel() //  []
         { []
         }
     {offset
       ckel: // global
           Hp = Hp + 72;
           _skbo::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto ckeG; else goto ckeF;
       ckeG: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_ckek_info;
           R1 = _skbo::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ckeF: // global
           I64[Hp - 64] = sat_skbr_info;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _skbo::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ckek() //  [R1]
         { []
         }
     {offset
       ckek: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _ckel() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ckek_info" {
     block_ckek_info:
         const _ckek;
         const 387;
         const 30;
 },
 GHC.CString.unpackAppendCString#_entry() //  [R2, R3]
         { []
         }
     {offset
       ckeQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ckeU; else goto ckeT;
       ckeU: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackAppendCString#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckeT: // global
           I64[Hp - 16] = unpack_skbm_info;
           P64[Hp - 8] = R3;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 15;
           call unpack_skbm_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.CString.unpackAppendCString#_info" {
     GHC.CString.unpackAppendCString#_info:
         const GHC.CString.unpackAppendCString#_entry;
         const 0;
         const 14;
         const 8589934605;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:40.047309934 UTC

[section ""data" . GHC.CString.unpackFoldrCString#_closure" {
     GHC.CString.unpackFoldrCString#_closure:
         const GHC.CString.unpackFoldrCString#_info;
 },
 sat_skbA_entry() //  [R1]
         { []
         }
     {offset
       ckfM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckfN; else goto ckfO;
       ckfN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckfO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbv_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_skbA_info" {
     sat_skbA_info:
         const sat_skbA_entry;
         const 4294967297;
         const 19;
 },
 unpack_skbv_entry() //  [R1, R2]
         { []
         }
     {offset
       ckfS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckfT; else goto ckfU;
       ckfT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckfU: // global
           _skbx::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 23] + R2]);
           if (_skbx::I64 == 0) goto ckfR; else goto ukg4;
       ckfR: // global
           R1 = P64[R1 + 15];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ukg4: // global
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _skbx::I64;
           Sp = Sp - 32;
           call _ckfE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . unpack_skbv_info" {
     unpack_skbv_info:
         const unpack_skbv_entry;
         const 4294967298;
         const 8;
         const 4294967300;
 },
 _ckfE() //  []
         { []
         }
     {offset
       ckfE: // global
           Hp = Hp + 48;
           _skbx::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto ckfY; else goto ckfX;
       ckfY: // global
           HpAlloc = 48;
           I64[Sp - 8] = block_ckfD_info;
           R1 = _skbx::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ckfX: // global
           I64[Hp - 40] = sat_skbA_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _skbx::I64;
           R3 = Hp - 40;
           R2 = Hp - 7;
           R1 = P64[Sp];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ckfD() //  [R1]
         { []
         }
     {offset
       ckfD: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _ckfE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ckfD_info" {
     block_ckfD_info:
         const _ckfD;
         const 772;
         const 30;
 },
 GHC.CString.unpackFoldrCString#_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ckg8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckgc; else goto ckgb;
       ckgc: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackFoldrCString#_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckgb: // global
           I64[Hp - 24] = unpack_skbv_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 23;
           call unpack_skbv_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.CString.unpackFoldrCString#_info" {
     GHC.CString.unpackFoldrCString#_info:
         const GHC.CString.unpackFoldrCString#_entry;
         const 0;
         const 14;
         const 12884901907;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:40.062883741 UTC

[section ""data" . GHC.CString.unpackCStringUtf8#_closure" {
     GHC.CString.unpackCStringUtf8#_closure:
         const GHC.CString.unpackCStringUtf8#_info;
 },
 sat_skc5_entry() //  [R1]
         { []
         }
     {offset
       ckhq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhr; else goto ckhs;
       ckhr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 4;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbC_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_skc5_info" {
     sat_skc5_info:
         const sat_skc5_entry;
         const 4294967297;
         const 19;
 },
 sat_skcn_entry() //  [R1]
         { []
         }
     {offset
       ckhM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhN; else goto ckhO;
       ckhN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 3;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbC_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_skcn_info" {
     sat_skcn_info:
         const sat_skcn_entry;
         const 4294967297;
         const 19;
 },
 sat_skcz_entry() //  [R1]
         { []
         }
     {offset
       cki2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cki3; else goto cki4;
       cki3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cki4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbC_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_skcz_info" {
     sat_skcz_info:
         const sat_skcz_entry;
         const 4294967297;
         const 19;
 },
 sat_skcC_entry() //  [R1]
         { []
         }
     {offset
       ckic: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckid; else goto ckie;
       ckid: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckie: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbC_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_skcC_info" {
     sat_skcC_info:
         const sat_skcC_entry;
         const 4294967297;
         const 19;
 },
 unpack_skbC_entry() //  [R1, R2]
         { []
         }
     {offset
       ckii: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckij; else goto ckik;
       ckij: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckik: // global
           _skbB::I64 = I64[R1 + 7];
           _skbE::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + R2]);
           if (_skbE::I64 == 0) goto ckih; else goto ukkl;
       ckih: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ukkl: // global
           I64[Sp - 32] = _skbB::I64;
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _skbE::I64;
           Sp = Sp - 32;
           call _ckgR() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . unpack_skbC_info" {
     unpack_skbC_info:
         const unpack_skbC_entry;
         const 4294967296;
         const 10;
         const 4294967300;
 },
 _ckgR() //  []
         { []
         }
     {offset
       ckgR: // global
           Hp = Hp + 72;
           _skbE::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto ckin; else goto ckim;
       ckin: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_ckgQ_info;
           R1 = _skbE::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ckim: // global
           _skbC::P64 = P64[Sp + 8];
           _skbD::I64 = I64[Sp + 16];
           if (_skbE::I64 > 127) goto ckkc; else goto ckkf;
       ckkc: // global
           _skbB::I64 = I64[Sp];
           if (_skbE::I64 > 223) goto ckjM; else goto ckka;
       ckjM: // global
           if (_skbE::I64 > 239) goto ckja; else goto ckjK;
       ckja: // global
           _skbJ::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + (_skbD::I64 + 3)]);
           _skbL::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + (_skbD::I64 + 2)]);
           _skbN::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + (_skbD::I64 + 1)]);
           I64[Hp - 64] = sat_skc5_info;
           P64[Hp - 48] = _skbC::P64;
           I64[Hp - 40] = _skbD::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_skbE::I64 + -240) << 18) + (((_skbN::I64 + -128) << 12) + (((_skbL::I64 + -128) << 6) + (_skbJ::I64 + -128)));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckjK: // global
           _skc7::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + (_skbD::I64 + 2)]);
           _skc9::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + (_skbD::I64 + 1)]);
           I64[Hp - 64] = sat_skcn_info;
           P64[Hp - 48] = _skbC::P64;
           I64[Hp - 40] = _skbD::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_skbE::I64 + -224) << 12) + (((_skc9::I64 + -128) << 6) + (_skc7::I64 + -128));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckka: // global
           _skcp::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + (_skbD::I64 + 1)]);
           I64[Hp - 64] = sat_skcz_info;
           P64[Hp - 48] = _skbC::P64;
           I64[Hp - 40] = _skbD::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_skbE::I64 + -192) << 6) + (_skcp::I64 + -128);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckkf: // global
           I64[Hp - 64] = sat_skcC_info;
           P64[Hp - 48] = _skbC::P64;
           I64[Hp - 40] = _skbD::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _skbE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ckgQ() //  [R1]
         { []
         }
     {offset
       ckgQ: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _ckgR() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ckgQ_info" {
     block_ckgQ_info:
         const _ckgQ;
         const 836;
         const 30;
 },
 GHC.CString.unpackCStringUtf8#_entry() //  [R2]
         { []
         }
     {offset
       ckkp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ckkt; else goto ckks;
       ckkt: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.CString.unpackCStringUtf8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckks: // global
           I64[Hp - 8] = unpack_skbC_info;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 7;
           call unpack_skbC_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.CString.unpackCStringUtf8#_info" {
     GHC.CString.unpackCStringUtf8#_info:
         const GHC.CString.unpackCStringUtf8#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:40.083478738 UTC

[section ""data" . GHC.CString.unpackNBytes#_closure" {
     GHC.CString.unpackNBytes#_closure:
         const GHC.CString.unpackNBytes#_info;
 },
 GHC.CString.unpackNBytes#_entry() //  [R2, R3]
         { []
         }
     {offset
       ckmk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ckml; else goto ckmm;
       ckml: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackNBytes#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckmm: // global
           if (R3 == 0) goto ckmj; else goto ckmi;
       ckmj: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckmi: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = R3 - 1;
           Sp = Sp - 32;
           call _ckm3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.CString.unpackNBytes#_info" {
     GHC.CString.unpackNBytes#_info:
         const GHC.CString.unpackNBytes#_entry;
         const 0;
         const 14;
         const 8589934604;
 },
 _ckm3() //  []
         { []
         }
     {offset
       ckm3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ckmp; else goto ckmo;
       ckmp: // global
           HpAlloc = 40;
           I64[Sp] = block_ckm3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ckmo: // global
           _skcH::P64 = P64[Sp + 16];
           _skcI::I64 = I64[Sp + 24];
           if (%MO_S_Ge_W64(_skcI::I64, 0)) goto ckmr; else goto ckms;
       ckmr: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + _skcI::I64]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _skcH::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _skcI::I64 - 1;
           call _ckm3() args: 0, res: 0, upd: 0;
       ckms: // global
           Hp = Hp - 40;
           R1 = _skcH::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckm3_info" {
     block_ckm3_info:
         const _ckm3;
         const 323;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:40.089678039 UTC

[section ""cstring" . GHC.CString.$trModule4_bytes" {
     GHC.CString.$trModule4_bytes:
         I8[] [103,104,99,45,112,114,105,109]
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:40.091423203 UTC

[section ""data" . GHC.CString.$trModule3_closure" {
     GHC.CString.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.CString.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:40.09321741 UTC

[section ""cstring" . GHC.CString.$trModule2_bytes" {
     GHC.CString.$trModule2_bytes:
         I8[] [71,72,67,46,67,83,116,114,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:40.09514776 UTC

[section ""data" . GHC.CString.$trModule1_closure" {
     GHC.CString.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.CString.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:40.097150242 UTC

[section ""data" . GHC.CString.$trModule_closure" {
     GHC.CString.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.CString.$trModule3_closure+1;
         const GHC.CString.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:49:40.099002136 UTC

[section ""relreadonly" . SkmZ_srt" { SkmZ_srt:
 }]

