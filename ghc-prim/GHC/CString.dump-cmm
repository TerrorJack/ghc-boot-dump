
==================== Output Cmm ====================
2018-03-16 15:49:39.692244009 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:49:39.693936498 UTC

[section ""data" . GHC.CString.unpackCString#_closure" {
     GHC.CString.unpackCString#_closure:
         const GHC.CString.unpackCString#_info;
 },
 sat_sjMu_entry() //  [R1]
         { info_tbl: [(cjOl,
                       label: sat_sjMu_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjOl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjOm; else goto cjOn;
       cjOm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjOn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMp_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_sjMp_entry() //  [R1, R2]
         { info_tbl: [(cjOr,
                       label: unpack_sjMp_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjOr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjOs; else goto cjOt;
       cjOs: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjOt: // global
           _sjMr::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 7] + R2]);
           if (_sjMr::I64 == 0) goto cjOq; else goto ujOE;
       cjOq: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ujOE: // global
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMr::I64;
           Sp = Sp - 24;
           call _cjOd() args: 0, res: 0, upd: 0;
     }
 },
 _cjOd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjOd: // global
           Hp = Hp + 72;
           _sjMr::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto cjOy; else goto cjOx;
       cjOy: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_cjOc_info;
           R1 = _sjMr::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cjOx: // global
           I64[Hp - 64] = sat_sjMu_info;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sjMr::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjOc() //  [R1]
         { info_tbl: [(cjOc,
                       label: block_cjOc_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjOc: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cjOd() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackCString#_entry() //  [R2]
         { info_tbl: [(cjOI,
                       label: GHC.CString.unpackCString#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjOI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cjOM; else goto cjOL;
       cjOM: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.CString.unpackCString#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjOL: // global
           I64[Hp - 8] = unpack_sjMp_info;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 7;
           call unpack_sjMp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.696677636 UTC

[section ""data" . GHC.CString.unpackAppendCString#_closure" {
     GHC.CString.unpackAppendCString#_closure:
         const GHC.CString.unpackAppendCString#_info;
 },
 sat_sjMC_entry() //  [R1]
         { info_tbl: [(cjP8,
                       label: sat_sjMC_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjP8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjP9; else goto cjPa;
       cjP9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjPa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMx_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_sjMx_entry() //  [R1, R2]
         { info_tbl: [(cjPe,
                       label: unpack_sjMx_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjPe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjPf; else goto cjPg;
       cjPf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjPg: // global
           _sjMz::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 15] + R2]);
           if (_sjMz::I64 == 0) goto cjPd; else goto ujPr;
       cjPd: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ujPr: // global
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMz::I64;
           Sp = Sp - 24;
           call _cjP0() args: 0, res: 0, upd: 0;
     }
 },
 _cjP0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjP0: // global
           Hp = Hp + 72;
           _sjMz::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto cjPl; else goto cjPk;
       cjPl: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_cjOZ_info;
           R1 = _sjMz::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cjPk: // global
           I64[Hp - 64] = sat_sjMC_info;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sjMz::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjOZ() //  [R1]
         { info_tbl: [(cjOZ,
                       label: block_cjOZ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjOZ: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cjP0() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackAppendCString#_entry() //  [R2, R3]
         { info_tbl: [(cjPv,
                       label: GHC.CString.unpackAppendCString#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjPv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cjPz; else goto cjPy;
       cjPz: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackAppendCString#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cjPy: // global
           I64[Hp - 16] = unpack_sjMx_info;
           P64[Hp - 8] = R3;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 15;
           call unpack_sjMx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.699454697 UTC

[section ""data" . GHC.CString.unpackFoldrCString#_closure" {
     GHC.CString.unpackFoldrCString#_closure:
         const GHC.CString.unpackFoldrCString#_info;
 },
 sat_sjML_entry() //  [R1]
         { info_tbl: [(cjPV,
                       label: sat_sjML_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjPV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjPW; else goto cjPX;
       cjPW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjPX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMG_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_sjMG_entry() //  [R1, R2]
         { info_tbl: [(cjQ1,
                       label: unpack_sjMG_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjQ1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjQ2; else goto cjQ3;
       cjQ2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjQ3: // global
           _sjMI::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 23] + R2]);
           if (_sjMI::I64 == 0) goto cjQ0; else goto ujQd;
       cjQ0: // global
           R1 = P64[R1 + 15];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ujQd: // global
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMI::I64;
           Sp = Sp - 32;
           call _cjPN() args: 0, res: 0, upd: 0;
     }
 },
 _cjPN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjPN: // global
           Hp = Hp + 48;
           _sjMI::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto cjQ7; else goto cjQ6;
       cjQ7: // global
           HpAlloc = 48;
           I64[Sp - 8] = block_cjPM_info;
           R1 = _sjMI::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cjQ6: // global
           I64[Hp - 40] = sat_sjML_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sjMI::I64;
           R3 = Hp - 40;
           R2 = Hp - 7;
           R1 = P64[Sp];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjPM() //  [R1]
         { info_tbl: [(cjPM,
                       label: block_cjPM_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjPM: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _cjPN() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackFoldrCString#_entry() //  [R2, R3, R4]
         { info_tbl: [(cjQh,
                       label: GHC.CString.unpackFoldrCString#_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjQh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cjQl; else goto cjQk;
       cjQl: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackFoldrCString#_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjQk: // global
           I64[Hp - 24] = unpack_sjMG_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 23;
           call unpack_sjMG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.703621147 UTC

[section ""data" . GHC.CString.unpackCStringUtf8#_closure" {
     GHC.CString.unpackCStringUtf8#_closure:
         const GHC.CString.unpackCStringUtf8#_info;
 },
 sat_sjNg_entry() //  [R1]
         { info_tbl: [(cjR8,
                       label: sat_sjNg_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjR8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjR9; else goto cjRa;
       cjR9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjRa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 4;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sjNy_entry() //  [R1]
         { info_tbl: [(cjRu,
                       label: sat_sjNy_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjRu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjRv; else goto cjRw;
       cjRv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjRw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 3;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sjNK_entry() //  [R1]
         { info_tbl: [(cjRK,
                       label: sat_sjNK_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjRK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjRL; else goto cjRM;
       cjRL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjRM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sjNN_entry() //  [R1]
         { info_tbl: [(cjRU,
                       label: sat_sjNN_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjRU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjRV; else goto cjRW;
       cjRV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjRW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_sjMN_entry() //  [R1, R2]
         { info_tbl: [(cjS0,
                       label: unpack_sjMN_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjS0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjS1; else goto cjS2;
       cjS1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjS2: // global
           _sjMM::I64 = I64[R1 + 7];
           _sjMP::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + R2]);
           if (_sjMP::I64 == 0) goto cjRZ; else goto ujU3;
       cjRZ: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ujU3: // global
           I64[Sp - 32] = _sjMM::I64;
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMP::I64;
           Sp = Sp - 32;
           call _cjQz() args: 0, res: 0, upd: 0;
     }
 },
 _cjQz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjQz: // global
           Hp = Hp + 72;
           _sjMP::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto cjS5; else goto cjS4;
       cjS5: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_cjQy_info;
           R1 = _sjMP::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cjS4: // global
           _sjMN::P64 = P64[Sp + 8];
           _sjMO::I64 = I64[Sp + 16];
           if (_sjMP::I64 > 127) goto cjTU; else goto cjTX;
       cjTU: // global
           _sjMM::I64 = I64[Sp];
           if (_sjMP::I64 > 223) goto cjTu; else goto cjTS;
       cjTu: // global
           if (_sjMP::I64 > 239) goto cjSS; else goto cjTs;
       cjSS: // global
           _sjMU::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 3)]);
           _sjMW::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 2)]);
           _sjMY::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 1)]);
           I64[Hp - 64] = sat_sjNg_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_sjMP::I64 + -240) << 18) + (((_sjMY::I64 + -128) << 12) + (((_sjMW::I64 + -128) << 6) + (_sjMU::I64 + -128)));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjTs: // global
           _sjNi::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 2)]);
           _sjNk::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 1)]);
           I64[Hp - 64] = sat_sjNy_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_sjMP::I64 + -224) << 12) + (((_sjNk::I64 + -128) << 6) + (_sjNi::I64 + -128));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjTS: // global
           _sjNA::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 1)]);
           I64[Hp - 64] = sat_sjNK_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_sjMP::I64 + -192) << 6) + (_sjNA::I64 + -128);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjTX: // global
           I64[Hp - 64] = sat_sjNN_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sjMP::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjQy() //  [R1]
         { info_tbl: [(cjQy,
                       label: block_cjQy_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjQy: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _cjQz() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackCStringUtf8#_entry() //  [R2]
         { info_tbl: [(cjU7,
                       label: GHC.CString.unpackCStringUtf8#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjU7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cjUb; else goto cjUa;
       cjUb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.CString.unpackCStringUtf8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjUa: // global
           I64[Hp - 8] = unpack_sjMN_info;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 7;
           call unpack_sjMN_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.707904549 UTC

[section ""data" . GHC.CString.unpackNBytes#_closure" {
     GHC.CString.unpackNBytes#_closure:
         const GHC.CString.unpackNBytes#_info;
 },
 GHC.CString.unpackNBytes#_entry() //  [R2, R3]
         { info_tbl: [(cjUE,
                       label: GHC.CString.unpackNBytes#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjUE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjUF; else goto cjUG;
       cjUF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackNBytes#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cjUG: // global
           if (R3 == 0) goto cjUD; else goto cjUC;
       cjUD: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjUC: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = R3 - 1;
           Sp = Sp - 32;
           call _cjUn() args: 0, res: 0, upd: 0;
     }
 },
 _cjUn() //  []
         { info_tbl: [(cjUn,
                       label: block_cjUn_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjUn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cjUJ; else goto cjUI;
       cjUJ: // global
           HpAlloc = 40;
           I64[Sp] = block_cjUn_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cjUI: // global
           _sjNS::P64 = P64[Sp + 16];
           _sjNT::I64 = I64[Sp + 24];
           if (%MO_S_Ge_W64(_sjNT::I64, 0)) goto cjUL; else goto cjUM;
       cjUL: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + _sjNT::I64]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sjNS::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _sjNT::I64 - 1;
           call _cjUn() args: 0, res: 0, upd: 0;
       cjUM: // global
           Hp = Hp - 40;
           R1 = _sjNS::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.709342154 UTC

[section ""cstring" . GHC.CString.$trModule4_bytes" {
     GHC.CString.$trModule4_bytes:
         I8[] [103,104,99,45,112,114,105,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.710771405 UTC

[section ""data" . GHC.CString.$trModule3_closure" {
     GHC.CString.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.CString.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.711547302 UTC

[section ""cstring" . GHC.CString.$trModule2_bytes" {
     GHC.CString.$trModule2_bytes:
         I8[] [71,72,67,46,67,83,116,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.712160432 UTC

[section ""data" . GHC.CString.$trModule1_closure" {
     GHC.CString.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.CString.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.71285333 UTC

[section ""data" . GHC.CString.$trModule_closure" {
     GHC.CString.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.CString.$trModule3_closure+1;
         const GHC.CString.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.713532073 UTC

[section ""relreadonly" . SjUR_srt" { SjUR_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.714222913 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:49:39.715594732 UTC

[section ""data" . GHC.CString.unpackCString#_closure" {
     GHC.CString.unpackCString#_closure:
         const GHC.CString.unpackCString#_info;
 },
 sat_sjMu_entry() //  [R1]
         { info_tbl: [(cjVd,
                       label: sat_sjMu_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjVd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjVe; else goto cjVf;
       cjVe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjVf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMp_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_sjMp_entry() //  [R1, R2]
         { info_tbl: [(cjVj,
                       label: unpack_sjMp_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjVj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjVk; else goto cjVl;
       cjVk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjVl: // global
           _sjMr::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 7] + R2]);
           if (_sjMr::I64 == 0) goto cjVi; else goto ujVw;
       cjVi: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ujVw: // global
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMr::I64;
           Sp = Sp - 24;
           call _cjV5() args: 0, res: 0, upd: 0;
     }
 },
 _cjV5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjV5: // global
           Hp = Hp + 72;
           _sjMr::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto cjVq; else goto cjVp;
       cjVq: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_cjV4_info;
           R1 = _sjMr::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cjVp: // global
           I64[Hp - 64] = sat_sjMu_info;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sjMr::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjV4() //  [R1]
         { info_tbl: [(cjV4,
                       label: block_cjV4_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjV4: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cjV5() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackCString#_entry() //  [R2]
         { info_tbl: [(cjVA,
                       label: GHC.CString.unpackCString#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjVA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cjVE; else goto cjVD;
       cjVE: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.CString.unpackCString#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjVD: // global
           I64[Hp - 8] = unpack_sjMp_info;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 7;
           call unpack_sjMp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.718721536 UTC

[section ""data" . GHC.CString.unpackAppendCString#_closure" {
     GHC.CString.unpackAppendCString#_closure:
         const GHC.CString.unpackAppendCString#_info;
 },
 sat_sjMC_entry() //  [R1]
         { info_tbl: [(cjW0,
                       label: sat_sjMC_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjW0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjW1; else goto cjW2;
       cjW1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjW2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMx_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_sjMx_entry() //  [R1, R2]
         { info_tbl: [(cjW6,
                       label: unpack_sjMx_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjW6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjW7; else goto cjW8;
       cjW7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjW8: // global
           _sjMz::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 15] + R2]);
           if (_sjMz::I64 == 0) goto cjW5; else goto ujWj;
       cjW5: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ujWj: // global
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMz::I64;
           Sp = Sp - 24;
           call _cjVS() args: 0, res: 0, upd: 0;
     }
 },
 _cjVS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjVS: // global
           Hp = Hp + 72;
           _sjMz::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto cjWd; else goto cjWc;
       cjWd: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_cjVR_info;
           R1 = _sjMz::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cjWc: // global
           I64[Hp - 64] = sat_sjMC_info;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sjMz::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjVR() //  [R1]
         { info_tbl: [(cjVR,
                       label: block_cjVR_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjVR: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cjVS() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackAppendCString#_entry() //  [R2, R3]
         { info_tbl: [(cjWn,
                       label: GHC.CString.unpackAppendCString#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjWn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cjWr; else goto cjWq;
       cjWr: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackAppendCString#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cjWq: // global
           I64[Hp - 16] = unpack_sjMx_info;
           P64[Hp - 8] = R3;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 15;
           call unpack_sjMx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.721662389 UTC

[section ""data" . GHC.CString.unpackFoldrCString#_closure" {
     GHC.CString.unpackFoldrCString#_closure:
         const GHC.CString.unpackFoldrCString#_info;
 },
 sat_sjML_entry() //  [R1]
         { info_tbl: [(cjWN,
                       label: sat_sjML_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjWN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjWO; else goto cjWP;
       cjWO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjWP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMG_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_sjMG_entry() //  [R1, R2]
         { info_tbl: [(cjWT,
                       label: unpack_sjMG_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjWT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjWU; else goto cjWV;
       cjWU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjWV: // global
           _sjMI::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 23] + R2]);
           if (_sjMI::I64 == 0) goto cjWS; else goto ujX5;
       cjWS: // global
           R1 = P64[R1 + 15];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ujX5: // global
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMI::I64;
           Sp = Sp - 32;
           call _cjWF() args: 0, res: 0, upd: 0;
     }
 },
 _cjWF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjWF: // global
           Hp = Hp + 48;
           _sjMI::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto cjWZ; else goto cjWY;
       cjWZ: // global
           HpAlloc = 48;
           I64[Sp - 8] = block_cjWE_info;
           R1 = _sjMI::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cjWY: // global
           I64[Hp - 40] = sat_sjML_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sjMI::I64;
           R3 = Hp - 40;
           R2 = Hp - 7;
           R1 = P64[Sp];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjWE() //  [R1]
         { info_tbl: [(cjWE,
                       label: block_cjWE_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjWE: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _cjWF() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackFoldrCString#_entry() //  [R2, R3, R4]
         { info_tbl: [(cjX9,
                       label: GHC.CString.unpackFoldrCString#_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjX9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cjXd; else goto cjXc;
       cjXd: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackFoldrCString#_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjXc: // global
           I64[Hp - 24] = unpack_sjMG_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 23;
           call unpack_sjMG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.725793947 UTC

[section ""data" . GHC.CString.unpackCStringUtf8#_closure" {
     GHC.CString.unpackCStringUtf8#_closure:
         const GHC.CString.unpackCStringUtf8#_info;
 },
 sat_sjNg_entry() //  [R1]
         { info_tbl: [(cjY0,
                       label: sat_sjNg_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjY0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjY1; else goto cjY2;
       cjY1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjY2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 4;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sjNy_entry() //  [R1]
         { info_tbl: [(cjYm,
                       label: sat_sjNy_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjYm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjYn; else goto cjYo;
       cjYn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjYo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 3;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sjNK_entry() //  [R1]
         { info_tbl: [(cjYC,
                       label: sat_sjNK_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjYC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjYD; else goto cjYE;
       cjYD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjYE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sjNN_entry() //  [R1]
         { info_tbl: [(cjYM,
                       label: sat_sjNN_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjYM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjYN; else goto cjYO;
       cjYN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjYO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_sjMN_entry() //  [R1, R2]
         { info_tbl: [(cjYS,
                       label: unpack_sjMN_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjYS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjYT; else goto cjYU;
       cjYT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjYU: // global
           _sjMM::I64 = I64[R1 + 7];
           _sjMP::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + R2]);
           if (_sjMP::I64 == 0) goto cjYR; else goto uk0V;
       cjYR: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uk0V: // global
           I64[Sp - 32] = _sjMM::I64;
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMP::I64;
           Sp = Sp - 32;
           call _cjXr() args: 0, res: 0, upd: 0;
     }
 },
 _cjXr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjXr: // global
           Hp = Hp + 72;
           _sjMP::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto cjYX; else goto cjYW;
       cjYX: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_cjXq_info;
           R1 = _sjMP::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cjYW: // global
           _sjMN::P64 = P64[Sp + 8];
           _sjMO::I64 = I64[Sp + 16];
           if (_sjMP::I64 > 127) goto ck0M; else goto ck0P;
       ck0M: // global
           _sjMM::I64 = I64[Sp];
           if (_sjMP::I64 > 223) goto ck0m; else goto ck0K;
       ck0m: // global
           if (_sjMP::I64 > 239) goto cjZK; else goto ck0k;
       cjZK: // global
           _sjMU::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 3)]);
           _sjMW::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 2)]);
           _sjMY::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 1)]);
           I64[Hp - 64] = sat_sjNg_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_sjMP::I64 + -240) << 18) + (((_sjMY::I64 + -128) << 12) + (((_sjMW::I64 + -128) << 6) + (_sjMU::I64 + -128)));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck0k: // global
           _sjNi::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 2)]);
           _sjNk::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 1)]);
           I64[Hp - 64] = sat_sjNy_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_sjMP::I64 + -224) << 12) + (((_sjNk::I64 + -128) << 6) + (_sjNi::I64 + -128));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck0K: // global
           _sjNA::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 1)]);
           I64[Hp - 64] = sat_sjNK_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_sjMP::I64 + -192) << 6) + (_sjNA::I64 + -128);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck0P: // global
           I64[Hp - 64] = sat_sjNN_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sjMP::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjXq() //  [R1]
         { info_tbl: [(cjXq,
                       label: block_cjXq_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjXq: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _cjXr() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackCStringUtf8#_entry() //  [R2]
         { info_tbl: [(ck0Z,
                       label: GHC.CString.unpackCStringUtf8#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck0Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ck13; else goto ck12;
       ck13: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.CString.unpackCStringUtf8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck12: // global
           I64[Hp - 8] = unpack_sjMN_info;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 7;
           call unpack_sjMN_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.730311588 UTC

[section ""data" . GHC.CString.unpackNBytes#_closure" {
     GHC.CString.unpackNBytes#_closure:
         const GHC.CString.unpackNBytes#_info;
 },
 GHC.CString.unpackNBytes#_entry() //  [R2, R3]
         { info_tbl: [(ck1w,
                       label: GHC.CString.unpackNBytes#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck1w: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ck1x; else goto ck1y;
       ck1x: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackNBytes#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ck1y: // global
           if (R3 == 0) goto ck1v; else goto ck1u;
       ck1v: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck1u: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = R3 - 1;
           Sp = Sp - 32;
           call _ck1f() args: 0, res: 0, upd: 0;
     }
 },
 _ck1f() //  []
         { info_tbl: [(ck1f,
                       label: block_ck1f_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck1f: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ck1B; else goto ck1A;
       ck1B: // global
           HpAlloc = 40;
           I64[Sp] = block_ck1f_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ck1A: // global
           _sjNS::P64 = P64[Sp + 16];
           _sjNT::I64 = I64[Sp + 24];
           if (%MO_S_Ge_W64(_sjNT::I64, 0)) goto ck1D; else goto ck1E;
       ck1D: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + _sjNT::I64]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sjNS::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _sjNT::I64 - 1;
           call _ck1f() args: 0, res: 0, upd: 0;
       ck1E: // global
           Hp = Hp - 40;
           R1 = _sjNS::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.731660911 UTC

[section ""cstring" . GHC.CString.$trModule4_bytes" {
     GHC.CString.$trModule4_bytes:
         I8[] [103,104,99,45,112,114,105,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.732267757 UTC

[section ""data" . GHC.CString.$trModule3_closure" {
     GHC.CString.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.CString.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.732911427 UTC

[section ""cstring" . GHC.CString.$trModule2_bytes" {
     GHC.CString.$trModule2_bytes:
         I8[] [71,72,67,46,67,83,116,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.733559147 UTC

[section ""data" . GHC.CString.$trModule1_closure" {
     GHC.CString.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.CString.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.73418703 UTC

[section ""data" . GHC.CString.$trModule_closure" {
     GHC.CString.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.CString.$trModule3_closure+1;
         const GHC.CString.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.734793444 UTC

[section ""relreadonly" . SjUR_srt" { SjUR_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.7356496 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:49:39.737770923 UTC

[section ""data" . GHC.CString.unpackCString#_closure" {
     GHC.CString.unpackCString#_closure:
         const GHC.CString.unpackCString#_info;
 },
 sat_sjMu_entry() //  [R1]
         { info_tbl: [(ck24,
                       label: sat_sjMu_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck24: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck25; else goto ck26;
       ck25: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck26: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMp_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_sjMp_entry() //  [R1, R2]
         { info_tbl: [(ck2a,
                       label: unpack_sjMp_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck2a: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ck2b; else goto ck2c;
       ck2b: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck2c: // global
           _sjMr::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 7] + R2]);
           if (_sjMr::I64 == 0) goto ck29; else goto uk2n;
       ck29: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uk2n: // global
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMr::I64;
           Sp = Sp - 24;
           call _ck1W() args: 0, res: 0, upd: 0;
     }
 },
 _ck1W() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck1W: // global
           Hp = Hp + 72;
           _sjMr::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto ck2h; else goto ck2g;
       ck2h: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_ck1V_info;
           R1 = _sjMr::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ck2g: // global
           I64[Hp - 64] = sat_sjMu_info;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sjMr::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ck1V() //  [R1]
         { info_tbl: [(ck1V,
                       label: block_ck1V_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck1V: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _ck1W() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackCString#_entry() //  [R2]
         { info_tbl: [(ck2r,
                       label: GHC.CString.unpackCString#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck2r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ck2v; else goto ck2u;
       ck2v: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.CString.unpackCString#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck2u: // global
           I64[Hp - 8] = unpack_sjMp_info;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 7;
           call unpack_sjMp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.751405538 UTC

[section ""data" . GHC.CString.unpackAppendCString#_closure" {
     GHC.CString.unpackAppendCString#_closure:
         const GHC.CString.unpackAppendCString#_info;
 },
 sat_sjMC_entry() //  [R1]
         { info_tbl: [(ck3g,
                       label: sat_sjMC_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck3g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck3h; else goto ck3i;
       ck3h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck3i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMx_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_sjMx_entry() //  [R1, R2]
         { info_tbl: [(ck3m,
                       label: unpack_sjMx_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck3m: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ck3n; else goto ck3o;
       ck3n: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck3o: // global
           _sjMz::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 15] + R2]);
           if (_sjMz::I64 == 0) goto ck3l; else goto uk3z;
       ck3l: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       uk3z: // global
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMz::I64;
           Sp = Sp - 24;
           call _ck38() args: 0, res: 0, upd: 0;
     }
 },
 _ck38() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck38: // global
           Hp = Hp + 72;
           _sjMz::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto ck3t; else goto ck3s;
       ck3t: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_ck37_info;
           R1 = _sjMz::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ck3s: // global
           I64[Hp - 64] = sat_sjMC_info;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sjMz::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ck37() //  [R1]
         { info_tbl: [(ck37,
                       label: block_ck37_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck37: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _ck38() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackAppendCString#_entry() //  [R2, R3]
         { info_tbl: [(ck3D,
                       label: GHC.CString.unpackAppendCString#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck3D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ck3H; else goto ck3G;
       ck3H: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackAppendCString#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ck3G: // global
           I64[Hp - 16] = unpack_sjMx_info;
           P64[Hp - 8] = R3;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 15;
           call unpack_sjMx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.764308213 UTC

[section ""data" . GHC.CString.unpackFoldrCString#_closure" {
     GHC.CString.unpackFoldrCString#_closure:
         const GHC.CString.unpackFoldrCString#_info;
 },
 sat_sjML_entry() //  [R1]
         { info_tbl: [(ck4t,
                       label: sat_sjML_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck4t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck4u; else goto ck4v;
       ck4u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck4v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMG_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_sjMG_entry() //  [R1, R2]
         { info_tbl: [(ck4z,
                       label: unpack_sjMG_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck4z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck4A; else goto ck4B;
       ck4A: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck4B: // global
           _sjMI::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 23] + R2]);
           if (_sjMI::I64 == 0) goto ck4y; else goto uk4L;
       ck4y: // global
           R1 = P64[R1 + 15];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       uk4L: // global
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMI::I64;
           Sp = Sp - 32;
           call _ck4l() args: 0, res: 0, upd: 0;
     }
 },
 _ck4l() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck4l: // global
           Hp = Hp + 48;
           _sjMI::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto ck4F; else goto ck4E;
       ck4F: // global
           HpAlloc = 48;
           I64[Sp - 8] = block_ck4k_info;
           R1 = _sjMI::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ck4E: // global
           I64[Hp - 40] = sat_sjML_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sjMI::I64;
           R3 = Hp - 40;
           R2 = Hp - 7;
           R1 = P64[Sp];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ck4k() //  [R1]
         { info_tbl: [(ck4k,
                       label: block_ck4k_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck4k: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _ck4l() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackFoldrCString#_entry() //  [R2, R3, R4]
         { info_tbl: [(ck4P,
                       label: GHC.CString.unpackFoldrCString#_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck4P: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ck4T; else goto ck4S;
       ck4T: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackFoldrCString#_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ck4S: // global
           I64[Hp - 24] = unpack_sjMG_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 23;
           call unpack_sjMG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.777600445 UTC

[section ""data" . GHC.CString.unpackCStringUtf8#_closure" {
     GHC.CString.unpackCStringUtf8#_closure:
         const GHC.CString.unpackCStringUtf8#_info;
 },
 sat_sjNg_entry() //  [R1]
         { info_tbl: [(ck62,
                       label: sat_sjNg_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck62: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck63; else goto ck64;
       ck63: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck64: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 4;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sjNy_entry() //  [R1]
         { info_tbl: [(ck6o,
                       label: sat_sjNy_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck6o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck6p; else goto ck6q;
       ck6p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck6q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 3;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sjNK_entry() //  [R1]
         { info_tbl: [(ck6E,
                       label: sat_sjNK_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck6E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck6F; else goto ck6G;
       ck6F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck6G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sjNN_entry() //  [R1]
         { info_tbl: [(ck6O,
                       label: sat_sjNN_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck6O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck6P; else goto ck6Q;
       ck6P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck6Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_sjMN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_sjMN_entry() //  [R1, R2]
         { info_tbl: [(ck6U,
                       label: unpack_sjMN_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck6U: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck6V; else goto ck6W;
       ck6V: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck6W: // global
           _sjMM::I64 = I64[R1 + 7];
           _sjMP::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + R2]);
           if (_sjMP::I64 == 0) goto ck6T; else goto uk8X;
       ck6T: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uk8X: // global
           I64[Sp - 32] = _sjMM::I64;
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _sjMP::I64;
           Sp = Sp - 32;
           call _ck5t() args: 0, res: 0, upd: 0;
     }
 },
 _ck5t() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck5t: // global
           Hp = Hp + 72;
           _sjMP::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto ck6Z; else goto ck6Y;
       ck6Z: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_ck5s_info;
           R1 = _sjMP::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ck6Y: // global
           _sjMN::P64 = P64[Sp + 8];
           _sjMO::I64 = I64[Sp + 16];
           if (_sjMP::I64 > 127) goto ck8O; else goto ck8R;
       ck8O: // global
           _sjMM::I64 = I64[Sp];
           if (_sjMP::I64 > 223) goto ck8o; else goto ck8M;
       ck8o: // global
           if (_sjMP::I64 > 239) goto ck7M; else goto ck8m;
       ck7M: // global
           _sjMU::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 3)]);
           _sjMW::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 2)]);
           _sjMY::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 1)]);
           I64[Hp - 64] = sat_sjNg_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_sjMP::I64 + -240) << 18) + (((_sjMY::I64 + -128) << 12) + (((_sjMW::I64 + -128) << 6) + (_sjMU::I64 + -128)));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck8m: // global
           _sjNi::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 2)]);
           _sjNk::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 1)]);
           I64[Hp - 64] = sat_sjNy_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_sjMP::I64 + -224) << 12) + (((_sjNk::I64 + -128) << 6) + (_sjNi::I64 + -128));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck8M: // global
           _sjNA::I64 = %MO_UU_Conv_W8_W64(I8[_sjMM::I64 + (_sjMO::I64 + 1)]);
           I64[Hp - 64] = sat_sjNK_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_sjMP::I64 + -192) << 6) + (_sjNA::I64 + -128);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck8R: // global
           I64[Hp - 64] = sat_sjNN_info;
           P64[Hp - 48] = _sjMN::P64;
           I64[Hp - 40] = _sjMO::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sjMP::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ck5s() //  [R1]
         { info_tbl: [(ck5s,
                       label: block_ck5s_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck5s: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _ck5t() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackCStringUtf8#_entry() //  [R2]
         { info_tbl: [(ck91,
                       label: GHC.CString.unpackCStringUtf8#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck91: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ck95; else goto ck94;
       ck95: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.CString.unpackCStringUtf8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck94: // global
           I64[Hp - 8] = unpack_sjMN_info;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 7;
           call unpack_sjMN_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.798734574 UTC

[section ""data" . GHC.CString.unpackNBytes#_closure" {
     GHC.CString.unpackNBytes#_closure:
         const GHC.CString.unpackNBytes#_info;
 },
 GHC.CString.unpackNBytes#_entry() //  [R2, R3]
         { info_tbl: [(ckaD,
                       label: GHC.CString.unpackNBytes#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckaD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ckaE; else goto ckaF;
       ckaE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackNBytes#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckaF: // global
           if (R3 == 0) goto ckaC; else goto ckaB;
       ckaC: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckaB: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = R3 - 1;
           Sp = Sp - 32;
           call _ckam() args: 0, res: 0, upd: 0;
     }
 },
 _ckam() //  []
         { info_tbl: [(ckam,
                       label: block_ckam_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckam: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ckaI; else goto ckaH;
       ckaI: // global
           HpAlloc = 40;
           I64[Sp] = block_ckam_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ckaH: // global
           _sjNS::P64 = P64[Sp + 16];
           _sjNT::I64 = I64[Sp + 24];
           if (%MO_S_Ge_W64(_sjNT::I64, 0)) goto ckaK; else goto ckaL;
       ckaK: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + _sjNT::I64]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sjNS::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _sjNT::I64 - 1;
           call _ckam() args: 0, res: 0, upd: 0;
       ckaL: // global
           Hp = Hp - 40;
           R1 = _sjNS::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.805156102 UTC

[section ""cstring" . GHC.CString.$trModule4_bytes" {
     GHC.CString.$trModule4_bytes:
         I8[] [103,104,99,45,112,114,105,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.80693371 UTC

[section ""data" . GHC.CString.$trModule3_closure" {
     GHC.CString.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.CString.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.808661219 UTC

[section ""cstring" . GHC.CString.$trModule2_bytes" {
     GHC.CString.$trModule2_bytes:
         I8[] [71,72,67,46,67,83,116,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.81048246 UTC

[section ""data" . GHC.CString.$trModule1_closure" {
     GHC.CString.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.CString.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.81229369 UTC

[section ""data" . GHC.CString.$trModule_closure" {
     GHC.CString.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.CString.$trModule3_closure+1;
         const GHC.CString.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:49:39.814703627 UTC

[section ""relreadonly" . SjUR_srt" { SjUR_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:49:40.017372714 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:49:40.019417229 UTC

[section ""data" . GHC.CString.unpackCString#_closure" {
     GHC.CString.unpackCString#_closure:
         const GHC.CString.unpackCString#_info;
 },
 sat_skbj_entry() //  [R1]
         { info_tbl: [(ckda,
                       label: sat_skbj_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckda: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckdb; else goto ckdc;
       ckdb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbe_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_skbe_entry() //  [R1, R2]
         { info_tbl: [(ckdg,
                       label: unpack_skbe_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckdg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ckdh; else goto ckdi;
       ckdh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckdi: // global
           _skbg::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 7] + R2]);
           if (_skbg::I64 == 0) goto ckdf; else goto ukdt;
       ckdf: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ukdt: // global
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _skbg::I64;
           Sp = Sp - 24;
           call _ckd2() args: 0, res: 0, upd: 0;
     }
 },
 _ckd2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckd2: // global
           Hp = Hp + 72;
           _skbg::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto ckdn; else goto ckdm;
       ckdn: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_ckd1_info;
           R1 = _skbg::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ckdm: // global
           I64[Hp - 64] = sat_skbj_info;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _skbg::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ckd1() //  [R1]
         { info_tbl: [(ckd1,
                       label: block_ckd1_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckd1: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _ckd2() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackCString#_entry() //  [R2]
         { info_tbl: [(ckdx,
                       label: GHC.CString.unpackCString#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckdx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ckdB; else goto ckdA;
       ckdB: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.CString.unpackCString#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckdA: // global
           I64[Hp - 8] = unpack_skbe_info;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 7;
           call unpack_skbe_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:40.031546925 UTC

[section ""data" . GHC.CString.unpackAppendCString#_closure" {
     GHC.CString.unpackAppendCString#_closure:
         const GHC.CString.unpackAppendCString#_info;
 },
 sat_skbr_entry() //  [R1]
         { info_tbl: [(cket,
                       label: sat_skbr_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cket: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckeu; else goto ckev;
       ckeu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckev: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbm_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_skbm_entry() //  [R1, R2]
         { info_tbl: [(ckez,
                       label: unpack_skbm_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckez: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ckeA; else goto ckeB;
       ckeA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckeB: // global
           _skbo::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 15] + R2]);
           if (_skbo::I64 == 0) goto ckey; else goto ukeM;
       ckey: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ukeM: // global
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _skbo::I64;
           Sp = Sp - 24;
           call _ckel() args: 0, res: 0, upd: 0;
     }
 },
 _ckel() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckel: // global
           Hp = Hp + 72;
           _skbo::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto ckeG; else goto ckeF;
       ckeG: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_ckek_info;
           R1 = _skbo::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ckeF: // global
           I64[Hp - 64] = sat_skbr_info;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _skbo::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ckek() //  [R1]
         { info_tbl: [(ckek,
                       label: block_ckek_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckek: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _ckel() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackAppendCString#_entry() //  [R2, R3]
         { info_tbl: [(ckeQ,
                       label: GHC.CString.unpackAppendCString#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckeQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ckeU; else goto ckeT;
       ckeU: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackAppendCString#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckeT: // global
           I64[Hp - 16] = unpack_skbm_info;
           P64[Hp - 8] = R3;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 15;
           call unpack_skbm_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:40.044921599 UTC

[section ""data" . GHC.CString.unpackFoldrCString#_closure" {
     GHC.CString.unpackFoldrCString#_closure:
         const GHC.CString.unpackFoldrCString#_info;
 },
 sat_skbA_entry() //  [R1]
         { info_tbl: [(ckfM,
                       label: sat_skbA_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckfM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckfN; else goto ckfO;
       ckfN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckfO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbv_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_skbv_entry() //  [R1, R2]
         { info_tbl: [(ckfS,
                       label: unpack_skbv_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckfS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckfT; else goto ckfU;
       ckfT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckfU: // global
           _skbx::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 23] + R2]);
           if (_skbx::I64 == 0) goto ckfR; else goto ukg4;
       ckfR: // global
           R1 = P64[R1 + 15];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ukg4: // global
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _skbx::I64;
           Sp = Sp - 32;
           call _ckfE() args: 0, res: 0, upd: 0;
     }
 },
 _ckfE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckfE: // global
           Hp = Hp + 48;
           _skbx::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto ckfY; else goto ckfX;
       ckfY: // global
           HpAlloc = 48;
           I64[Sp - 8] = block_ckfD_info;
           R1 = _skbx::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ckfX: // global
           I64[Hp - 40] = sat_skbA_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _skbx::I64;
           R3 = Hp - 40;
           R2 = Hp - 7;
           R1 = P64[Sp];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ckfD() //  [R1]
         { info_tbl: [(ckfD,
                       label: block_ckfD_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckfD: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _ckfE() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackFoldrCString#_entry() //  [R2, R3, R4]
         { info_tbl: [(ckg8,
                       label: GHC.CString.unpackFoldrCString#_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckg8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckgc; else goto ckgb;
       ckgc: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackFoldrCString#_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckgb: // global
           I64[Hp - 24] = unpack_skbv_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 23;
           call unpack_skbv_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:40.059079807 UTC

[section ""data" . GHC.CString.unpackCStringUtf8#_closure" {
     GHC.CString.unpackCStringUtf8#_closure:
         const GHC.CString.unpackCStringUtf8#_info;
 },
 sat_skc5_entry() //  [R1]
         { info_tbl: [(ckhq,
                       label: sat_skc5_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckhq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhr; else goto ckhs;
       ckhr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 4;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbC_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_skcn_entry() //  [R1]
         { info_tbl: [(ckhM,
                       label: sat_skcn_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckhM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhN; else goto ckhO;
       ckhN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 3;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbC_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_skcz_entry() //  [R1]
         { info_tbl: [(cki2,
                       label: sat_skcz_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cki2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cki3; else goto cki4;
       cki3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cki4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbC_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_skcC_entry() //  [R1]
         { info_tbl: [(ckic,
                       label: sat_skcC_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckic: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckid; else goto ckie;
       ckid: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckie: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call unpack_skbC_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 unpack_skbC_entry() //  [R1, R2]
         { info_tbl: [(ckii,
                       label: unpack_skbC_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckii: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckij; else goto ckik;
       ckij: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckik: // global
           _skbB::I64 = I64[R1 + 7];
           _skbE::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + R2]);
           if (_skbE::I64 == 0) goto ckih; else goto ukkl;
       ckih: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ukkl: // global
           I64[Sp - 32] = _skbB::I64;
           P64[Sp - 24] = R1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = _skbE::I64;
           Sp = Sp - 32;
           call _ckgR() args: 0, res: 0, upd: 0;
     }
 },
 _ckgR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckgR: // global
           Hp = Hp + 72;
           _skbE::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto ckin; else goto ckim;
       ckin: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_ckgQ_info;
           R1 = _skbE::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ckim: // global
           _skbC::P64 = P64[Sp + 8];
           _skbD::I64 = I64[Sp + 16];
           if (_skbE::I64 > 127) goto ckkc; else goto ckkf;
       ckkc: // global
           _skbB::I64 = I64[Sp];
           if (_skbE::I64 > 223) goto ckjM; else goto ckka;
       ckjM: // global
           if (_skbE::I64 > 239) goto ckja; else goto ckjK;
       ckja: // global
           _skbJ::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + (_skbD::I64 + 3)]);
           _skbL::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + (_skbD::I64 + 2)]);
           _skbN::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + (_skbD::I64 + 1)]);
           I64[Hp - 64] = sat_skc5_info;
           P64[Hp - 48] = _skbC::P64;
           I64[Hp - 40] = _skbD::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_skbE::I64 + -240) << 18) + (((_skbN::I64 + -128) << 12) + (((_skbL::I64 + -128) << 6) + (_skbJ::I64 + -128)));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckjK: // global
           _skc7::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + (_skbD::I64 + 2)]);
           _skc9::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + (_skbD::I64 + 1)]);
           I64[Hp - 64] = sat_skcn_info;
           P64[Hp - 48] = _skbC::P64;
           I64[Hp - 40] = _skbD::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_skbE::I64 + -224) << 12) + (((_skc9::I64 + -128) << 6) + (_skc7::I64 + -128));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckka: // global
           _skcp::I64 = %MO_UU_Conv_W8_W64(I8[_skbB::I64 + (_skbD::I64 + 1)]);
           I64[Hp - 64] = sat_skcz_info;
           P64[Hp - 48] = _skbC::P64;
           I64[Hp - 40] = _skbD::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = ((_skbE::I64 + -192) << 6) + (_skcp::I64 + -128);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckkf: // global
           I64[Hp - 64] = sat_skcC_info;
           P64[Hp - 48] = _skbC::P64;
           I64[Hp - 40] = _skbD::I64;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _skbE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ckgQ() //  [R1]
         { info_tbl: [(ckgQ,
                       label: block_ckgQ_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckgQ: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _ckgR() args: 0, res: 0, upd: 0;
     }
 },
 GHC.CString.unpackCStringUtf8#_entry() //  [R2]
         { info_tbl: [(ckkp,
                       label: GHC.CString.unpackCStringUtf8#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckkp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ckkt; else goto ckks;
       ckkt: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.CString.unpackCStringUtf8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckks: // global
           I64[Hp - 8] = unpack_skbC_info;
           I64[Hp] = R2;
           R2 = 0;
           R1 = Hp - 7;
           call unpack_skbC_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:40.082003078 UTC

[section ""data" . GHC.CString.unpackNBytes#_closure" {
     GHC.CString.unpackNBytes#_closure:
         const GHC.CString.unpackNBytes#_info;
 },
 GHC.CString.unpackNBytes#_entry() //  [R2, R3]
         { info_tbl: [(ckmk,
                       label: GHC.CString.unpackNBytes#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckmk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ckml; else goto ckmm;
       ckml: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.CString.unpackNBytes#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckmm: // global
           if (R3 == 0) goto ckmj; else goto ckmi;
       ckmj: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckmi: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = R3 - 1;
           Sp = Sp - 32;
           call _ckm3() args: 0, res: 0, upd: 0;
     }
 },
 _ckm3() //  []
         { info_tbl: [(ckm3,
                       label: block_ckm3_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckm3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ckmp; else goto ckmo;
       ckmp: // global
           HpAlloc = 40;
           I64[Sp] = block_ckm3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ckmo: // global
           _skcH::P64 = P64[Sp + 16];
           _skcI::I64 = I64[Sp + 24];
           if (%MO_S_Ge_W64(_skcI::I64, 0)) goto ckmr; else goto ckms;
       ckmr: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + _skcI::I64]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _skcH::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _skcI::I64 - 1;
           call _ckm3() args: 0, res: 0, upd: 0;
       ckms: // global
           Hp = Hp - 40;
           R1 = _skcH::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:49:40.089050486 UTC

[section ""cstring" . GHC.CString.$trModule4_bytes" {
     GHC.CString.$trModule4_bytes:
         I8[] [103,104,99,45,112,114,105,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:49:40.090918558 UTC

[section ""data" . GHC.CString.$trModule3_closure" {
     GHC.CString.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.CString.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:49:40.092658285 UTC

[section ""cstring" . GHC.CString.$trModule2_bytes" {
     GHC.CString.$trModule2_bytes:
         I8[] [71,72,67,46,67,83,116,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:49:40.094586614 UTC

[section ""data" . GHC.CString.$trModule1_closure" {
     GHC.CString.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.CString.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:49:40.096572174 UTC

[section ""data" . GHC.CString.$trModule_closure" {
     GHC.CString.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.CString.$trModule3_closure+1;
         const GHC.CString.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:49:40.098407117 UTC

[section ""relreadonly" . SkmZ_srt" { SkmZ_srt:
 }]

