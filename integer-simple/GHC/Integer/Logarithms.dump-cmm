
==================== Output Cmm ====================
2018-03-16 15:53:58.656987463 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:53:58.658704841 UTC

[section ""data" . GHC.Integer.Logarithms.integerLogBase#_closure" {
     GHC.Integer.Logarithms.integerLogBase#_closure:
         const GHC.Integer.Logarithms.integerLogBase#_info;
         const 0;
 },
 sat_sb6r_entry() //  [R1]
         { info_tbl: [(cb77,
                       label: sat_sb6r_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb77: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb78; else goto cb79;
       cb78: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb79: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 step_sb6j_entry() //  [R1, R2]
         { info_tbl: [(cb7d,
                       label: step_sb6j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7d: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb7e; else goto cb7f;
       cb7e: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb7f: // global
           I64[Sp - 32] = block_cb6H_info;
           R3 = R2;
           _sb6k::P64 = R2;
           _sb6i::P64 = P64[R1 + 7];
           R2 = _sb6i::P64;
           P64[Sp - 24] = _sb6i::P64;
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sb6k::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb6H() //  [R1]
         { info_tbl: [(cb6H,
                       label: block_cb6H_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb6H: // global
           if (R1 == 1) goto cb7c; else goto cb7b;
       cb7c: // global
           R2 = 0;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cb7b: // global
           I64[Sp + 8] = block_cb6L_info;
           _sb6k::P64 = P64[Sp + 24];
           R3 = _sb6k::P64;
           R2 = _sb6k::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb6L() //  [R1]
         { info_tbl: [(cb6L,
                       label: block_cb6L_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb6L: // global
           _sb6j::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb6P_info;
           R2 = R1;
           R1 = _sb6j::P64;
           Sp = Sp + 8;
           call step_sb6j_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb6P() //  [R1, R2]
         { info_tbl: [(cb6P,
                       label: block_cb6P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb6P: // global
           I64[Sp - 16] = block_cb6T_info;
           R3 = P64[Sp + 8];
           _sb6p::I64 = R2;
           R2 = R1;
           I64[Sp - 8] = _sb6p::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb6T() //  [R1]
         { info_tbl: [(cb6T,
                       label: block_cb6T_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb6T: // global
           _sb6o::P64 = P64[Sp + 16];
           _sb6p::I64 = I64[Sp + 8];
           if (R1 == 1) goto cb7r; else goto cb7k;
       cb7r: // global
           R2 = _sb6p::I64 << 1;
           R1 = _sb6o::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cb7k: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb7n; else goto cb7m;
       cb7n: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb7m: // global
           I64[Hp - 24] = sat_sb6r_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sb6o::P64;
           R2 = (_sb6p::I64 << 1) + 1;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Integer.Logarithms.integerLogBase#_entry() //  [R2, R3]
         { info_tbl: [(cb7A,
                       label: GHC.Integer.Logarithms.integerLogBase#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7A: // global
           _sb6i::P64 = R3;
           _sb6h::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb7B; else goto cb7C;
       cb7C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7E; else goto cb7D;
       cb7E: // global
           HpAlloc = 16;
           goto cb7B;
       cb7B: // global
           R3 = _sb6i::P64;
           R2 = _sb6h::P64;
           R1 = GHC.Integer.Logarithms.integerLogBase#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb7D: // global
           I64[Hp - 8] = step_sb6j_info;
           P64[Hp] = _sb6i::P64;
           I64[Sp - 8] = block_cb7w_info;
           R2 = _sb6h::P64;
           R1 = Hp - 7;
           Sp = Sp - 8;
           call step_sb6j_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7w() //  [R2]
         { info_tbl: [(cb7w,
                       label: block_cb7w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7w: // global
           R1 = R2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.661947362 UTC

[section ""data" . GHC.Integer.Logarithms.integerLog2#_closure" {
     GHC.Integer.Logarithms.integerLog2#_closure:
         const GHC.Integer.Logarithms.integerLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.integerLog2#_entry() //  [R2]
         { info_tbl: [(cb7L,
                       label: GHC.Integer.Logarithms.integerLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7L: // global
           R2 = R2;
           call GHC.Integer.Logarithms.Internals.integerLog2#_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.662879373 UTC

[section ""data" . GHC.Integer.Logarithms.wordLog2#_closure" {
     GHC.Integer.Logarithms.wordLog2#_closure:
         const GHC.Integer.Logarithms.wordLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.wordLog2#_entry() //  [R2]
         { info_tbl: [(cb7S,
                       label: GHC.Integer.Logarithms.wordLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7S: // global
           R2 = R2;
           call GHC.Integer.Logarithms.Internals.wordLog2#_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.663829244 UTC

[section ""cstring" . GHC.Integer.Logarithms.$trModule4_bytes" {
     GHC.Integer.Logarithms.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.664434103 UTC

[section ""data" . GHC.Integer.Logarithms.$trModule3_closure" {
     GHC.Integer.Logarithms.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.665042077 UTC

[section ""cstring" . GHC.Integer.Logarithms.$trModule2_bytes" {
     GHC.Integer.Logarithms.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.665958229 UTC

[section ""data" . GHC.Integer.Logarithms.$trModule1_closure" {
     GHC.Integer.Logarithms.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.666542412 UTC

[section ""data" . GHC.Integer.Logarithms.$trModule_closure" {
     GHC.Integer.Logarithms.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Logarithms.$trModule3_closure+1;
         const GHC.Integer.Logarithms.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.667122106 UTC

[section ""relreadonly" . Sb7G_srt" {
     Sb7G_srt:
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Logarithms.integerLogBase#_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_closure;
         const GHC.Integer.Logarithms.Internals.wordLog2#_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.667846857 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:53:58.669434816 UTC

[section ""data" . GHC.Integer.Logarithms.integerLogBase#_closure" {
     GHC.Integer.Logarithms.integerLogBase#_closure:
         const GHC.Integer.Logarithms.integerLogBase#_info;
         const 0;
 },
 sat_sb6r_entry() //  [R1]
         { info_tbl: [(cb8u,
                       label: sat_sb6r_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8v; else goto cb8w;
       cb8v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 step_sb6j_entry() //  [R1, R2]
         { info_tbl: [(cb8A,
                       label: step_sb6j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb8B; else goto cb8C;
       cb8B: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb8C: // global
           I64[Sp - 32] = block_cb84_info;
           R3 = R2;
           _sb6k::P64 = R2;
           _sb6i::P64 = P64[R1 + 7];
           R2 = _sb6i::P64;
           P64[Sp - 24] = _sb6i::P64;
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sb6k::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb84() //  [R1]
         { info_tbl: [(cb84,
                       label: block_cb84_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb84: // global
           if (R1 == 1) goto cb8z; else goto cb8y;
       cb8z: // global
           R2 = 0;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cb8y: // global
           I64[Sp + 8] = block_cb88_info;
           _sb6k::P64 = P64[Sp + 24];
           R3 = _sb6k::P64;
           R2 = _sb6k::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb88() //  [R1]
         { info_tbl: [(cb88,
                       label: block_cb88_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb88: // global
           _sb6j::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb8c_info;
           R2 = R1;
           R1 = _sb6j::P64;
           Sp = Sp + 8;
           call step_sb6j_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8c() //  [R1, R2]
         { info_tbl: [(cb8c,
                       label: block_cb8c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8c: // global
           I64[Sp - 16] = block_cb8g_info;
           R3 = P64[Sp + 8];
           _sb6p::I64 = R2;
           R2 = R1;
           I64[Sp - 8] = _sb6p::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8g() //  [R1]
         { info_tbl: [(cb8g,
                       label: block_cb8g_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8g: // global
           _sb6o::P64 = P64[Sp + 16];
           _sb6p::I64 = I64[Sp + 8];
           if (R1 == 1) goto cb8O; else goto cb8H;
       cb8O: // global
           R2 = _sb6p::I64 << 1;
           R1 = _sb6o::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cb8H: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb8K; else goto cb8J;
       cb8K: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb8J: // global
           I64[Hp - 24] = sat_sb6r_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sb6o::P64;
           R2 = (_sb6p::I64 << 1) + 1;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Integer.Logarithms.integerLogBase#_entry() //  [R2, R3]
         { info_tbl: [(cb8X,
                       label: GHC.Integer.Logarithms.integerLogBase#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8X: // global
           _sb6i::P64 = R3;
           _sb6h::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cb8Y; else goto cb8Z;
       cb8Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb91; else goto cb90;
       cb91: // global
           HpAlloc = 16;
           goto cb8Y;
       cb8Y: // global
           R3 = _sb6i::P64;
           R2 = _sb6h::P64;
           R1 = GHC.Integer.Logarithms.integerLogBase#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb90: // global
           I64[Hp - 8] = step_sb6j_info;
           P64[Hp] = _sb6i::P64;
           I64[Sp - 8] = block_cb8T_info;
           R2 = _sb6h::P64;
           R1 = Hp - 7;
           Sp = Sp - 8;
           call step_sb6j_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8T() //  [R2]
         { info_tbl: [(cb8T,
                       label: block_cb8T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8T: // global
           R1 = R2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.672349366 UTC

[section ""data" . GHC.Integer.Logarithms.integerLog2#_closure" {
     GHC.Integer.Logarithms.integerLog2#_closure:
         const GHC.Integer.Logarithms.integerLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.integerLog2#_entry() //  [R2]
         { info_tbl: [(cb97,
                       label: GHC.Integer.Logarithms.integerLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb97: // global
           R2 = R2;
           call GHC.Integer.Logarithms.Internals.integerLog2#_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.673188268 UTC

[section ""data" . GHC.Integer.Logarithms.wordLog2#_closure" {
     GHC.Integer.Logarithms.wordLog2#_closure:
         const GHC.Integer.Logarithms.wordLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.wordLog2#_entry() //  [R2]
         { info_tbl: [(cb9e,
                       label: GHC.Integer.Logarithms.wordLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9e: // global
           R2 = R2;
           call GHC.Integer.Logarithms.Internals.wordLog2#_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.674123561 UTC

[section ""cstring" . GHC.Integer.Logarithms.$trModule4_bytes" {
     GHC.Integer.Logarithms.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.674722821 UTC

[section ""data" . GHC.Integer.Logarithms.$trModule3_closure" {
     GHC.Integer.Logarithms.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.67534323 UTC

[section ""cstring" . GHC.Integer.Logarithms.$trModule2_bytes" {
     GHC.Integer.Logarithms.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.676092847 UTC

[section ""data" . GHC.Integer.Logarithms.$trModule1_closure" {
     GHC.Integer.Logarithms.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.676727699 UTC

[section ""data" . GHC.Integer.Logarithms.$trModule_closure" {
     GHC.Integer.Logarithms.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Logarithms.$trModule3_closure+1;
         const GHC.Integer.Logarithms.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.677470073 UTC

[section ""relreadonly" . Sb7G_srt" {
     Sb7G_srt:
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Logarithms.integerLogBase#_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_closure;
         const GHC.Integer.Logarithms.Internals.wordLog2#_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.678505258 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:53:58.685063571 UTC

[section ""data" . GHC.Integer.Logarithms.integerLogBase#_closure" {
     GHC.Integer.Logarithms.integerLogBase#_closure:
         const GHC.Integer.Logarithms.integerLogBase#_info;
         const 0;
 },
 sat_sb6r_entry() //  [R1]
         { info_tbl: [(cb9Q,
                       label: sat_sb6r_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9R; else goto cb9S;
       cb9R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 step_sb6j_entry() //  [R1, R2]
         { info_tbl: [(cb9W,
                       label: step_sb6j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9W: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb9X; else goto cb9Y;
       cb9X: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb9Y: // global
           I64[Sp - 32] = block_cb9q_info;
           R3 = R2;
           _sb6k::P64 = R2;
           _sb6i::P64 = P64[R1 + 7];
           R2 = _sb6i::P64;
           P64[Sp - 24] = _sb6i::P64;
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sb6k::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9q() //  [R1]
         { info_tbl: [(cb9q,
                       label: block_cb9q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9q: // global
           if (R1 == 1) goto cb9V; else goto cb9U;
       cb9V: // global
           R2 = 0;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cb9U: // global
           I64[Sp + 8] = block_cb9u_info;
           _sb6k::P64 = P64[Sp + 24];
           R3 = _sb6k::P64;
           R2 = _sb6k::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9u() //  [R1]
         { info_tbl: [(cb9u,
                       label: block_cb9u_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9u: // global
           _sb6j::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb9y_info;
           R2 = R1;
           R1 = _sb6j::P64;
           Sp = Sp + 8;
           call step_sb6j_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9y() //  [R1, R2]
         { info_tbl: [(cb9y,
                       label: block_cb9y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9y: // global
           I64[Sp - 16] = block_cb9C_info;
           R3 = P64[Sp + 8];
           _sb6p::I64 = R2;
           R2 = R1;
           I64[Sp - 8] = _sb6p::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9C() //  [R1]
         { info_tbl: [(cb9C,
                       label: block_cb9C_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9C: // global
           _sb6o::P64 = P64[Sp + 16];
           _sb6p::I64 = I64[Sp + 8];
           if (R1 == 1) goto cbaa; else goto cba3;
       cbaa: // global
           R2 = _sb6p::I64 << 1;
           R1 = _sb6o::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cba3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cba6; else goto cba5;
       cba6: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cba5: // global
           I64[Hp - 24] = sat_sb6r_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sb6o::P64;
           R2 = (_sb6p::I64 << 1) + 1;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Integer.Logarithms.integerLogBase#_entry() //  [R2, R3]
         { info_tbl: [(cbaj,
                       label: GHC.Integer.Logarithms.integerLogBase#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaj: // global
           _sb6i::P64 = R3;
           _sb6h::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbak; else goto cbal;
       cbal: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cban; else goto cbam;
       cban: // global
           HpAlloc = 16;
           goto cbak;
       cbak: // global
           R3 = _sb6i::P64;
           R2 = _sb6h::P64;
           R1 = GHC.Integer.Logarithms.integerLogBase#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbam: // global
           I64[Hp - 8] = step_sb6j_info;
           P64[Hp] = _sb6i::P64;
           I64[Sp - 8] = block_cbaf_info;
           R2 = _sb6h::P64;
           R1 = Hp - 7;
           Sp = Sp - 8;
           call step_sb6j_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaf() //  [R2]
         { info_tbl: [(cbaf,
                       label: block_cbaf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaf: // global
           R1 = R2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.713143829 UTC

[section ""data" . GHC.Integer.Logarithms.integerLog2#_closure" {
     GHC.Integer.Logarithms.integerLog2#_closure:
         const GHC.Integer.Logarithms.integerLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.integerLog2#_entry() //  [R2]
         { info_tbl: [(cbb1,
                       label: GHC.Integer.Logarithms.integerLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb1: // global
           R2 = R2;
           call GHC.Integer.Logarithms.Internals.integerLog2#_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.717726542 UTC

[section ""data" . GHC.Integer.Logarithms.wordLog2#_closure" {
     GHC.Integer.Logarithms.wordLog2#_closure:
         const GHC.Integer.Logarithms.wordLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.wordLog2#_entry() //  [R2]
         { info_tbl: [(cbbc,
                       label: GHC.Integer.Logarithms.wordLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbc: // global
           R2 = R2;
           call GHC.Integer.Logarithms.Internals.wordLog2#_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.721691428 UTC

[section ""cstring" . GHC.Integer.Logarithms.$trModule4_bytes" {
     GHC.Integer.Logarithms.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.72369118 UTC

[section ""data" . GHC.Integer.Logarithms.$trModule3_closure" {
     GHC.Integer.Logarithms.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.725824409 UTC

[section ""cstring" . GHC.Integer.Logarithms.$trModule2_bytes" {
     GHC.Integer.Logarithms.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.72779229 UTC

[section ""data" . GHC.Integer.Logarithms.$trModule1_closure" {
     GHC.Integer.Logarithms.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.729991371 UTC

[section ""data" . GHC.Integer.Logarithms.$trModule_closure" {
     GHC.Integer.Logarithms.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Logarithms.$trModule3_closure+1;
         const GHC.Integer.Logarithms.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.732026864 UTC

[section ""relreadonly" . Sb7G_srt" {
     Sb7G_srt:
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Logarithms.integerLogBase#_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_closure;
         const GHC.Integer.Logarithms.Internals.wordLog2#_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.903698296 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:53:58.906228252 UTC

[section ""data" . GHC.Integer.Logarithms.integerLogBase#_closure" {
     GHC.Integer.Logarithms.integerLogBase#_closure:
         const GHC.Integer.Logarithms.integerLogBase#_info;
         const 0;
 },
 sat_sbbz_entry() //  [R1]
         { info_tbl: [(cbcf,
                       label: sat_sbbz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbcg; else goto cbch;
       cbcg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbch: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.quotInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 step_sbbr_entry() //  [R1, R2]
         { info_tbl: [(cbcl,
                       label: step_sbbr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbcm; else goto cbcn;
       cbcm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbcn: // global
           I64[Sp - 32] = block_cbbP_info;
           R3 = R2;
           _sbbs::P64 = R2;
           _sbbq::P64 = P64[R1 + 7];
           R2 = _sbbq::P64;
           P64[Sp - 24] = _sbbq::P64;
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sbbs::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbbP() //  [R1]
         { info_tbl: [(cbbP,
                       label: block_cbbP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbP: // global
           if (R1 == 1) goto cbck; else goto cbcj;
       cbck: // global
           R2 = 0;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cbcj: // global
           I64[Sp + 8] = block_cbbT_info;
           _sbbs::P64 = P64[Sp + 24];
           R3 = _sbbs::P64;
           R2 = _sbbs::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbbT() //  [R1]
         { info_tbl: [(cbbT,
                       label: block_cbbT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbT: // global
           _sbbr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbbX_info;
           R2 = R1;
           R1 = _sbbr::P64;
           Sp = Sp + 8;
           call step_sbbr_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbX() //  [R1, R2]
         { info_tbl: [(cbbX,
                       label: block_cbbX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbX: // global
           I64[Sp - 16] = block_cbc1_info;
           R3 = P64[Sp + 8];
           _sbbx::I64 = R2;
           R2 = R1;
           I64[Sp - 8] = _sbbx::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbc1() //  [R1]
         { info_tbl: [(cbc1,
                       label: block_cbc1_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbc1: // global
           _sbbw::P64 = P64[Sp + 16];
           _sbbx::I64 = I64[Sp + 8];
           if (R1 == 1) goto cbcz; else goto cbcs;
       cbcz: // global
           R2 = _sbbx::I64 << 1;
           R1 = _sbbw::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cbcs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbcv; else goto cbcu;
       cbcv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbcu: // global
           I64[Hp - 24] = sat_sbbz_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sbbw::P64;
           R2 = (_sbbx::I64 << 1) + 1;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Integer.Logarithms.integerLogBase#_entry() //  [R2, R3]
         { info_tbl: [(cbcI,
                       label: GHC.Integer.Logarithms.integerLogBase#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcI: // global
           _sbbq::P64 = R3;
           _sbbp::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbcJ; else goto cbcK;
       cbcK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbcM; else goto cbcL;
       cbcM: // global
           HpAlloc = 16;
           goto cbcJ;
       cbcJ: // global
           R3 = _sbbq::P64;
           R2 = _sbbp::P64;
           R1 = GHC.Integer.Logarithms.integerLogBase#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbcL: // global
           I64[Hp - 8] = step_sbbr_info;
           P64[Hp] = _sbbq::P64;
           I64[Sp - 8] = block_cbcE_info;
           R2 = _sbbp::P64;
           R1 = Hp - 7;
           Sp = Sp - 8;
           call step_sbbr_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcE() //  [R2]
         { info_tbl: [(cbcE,
                       label: block_cbcE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcE: // global
           R1 = R2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.927055907 UTC

[section ""data" . GHC.Integer.Logarithms.integerLog2#_closure" {
     GHC.Integer.Logarithms.integerLog2#_closure:
         const GHC.Integer.Logarithms.integerLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.integerLog2#_entry() //  [R2]
         { info_tbl: [(cbdz,
                       label: GHC.Integer.Logarithms.integerLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdz: // global
           R2 = R2;
           call GHC.Integer.Logarithms.Internals.integerLog2#_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.931105751 UTC

[section ""data" . GHC.Integer.Logarithms.wordLog2#_closure" {
     GHC.Integer.Logarithms.wordLog2#_closure:
         const GHC.Integer.Logarithms.wordLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.wordLog2#_entry() //  [R2]
         { info_tbl: [(cbdK,
                       label: GHC.Integer.Logarithms.wordLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdK: // global
           R2 = R2;
           call GHC.Integer.Logarithms.Internals.wordLog2#_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.935169871 UTC

[section ""cstring" . GHC.Integer.Logarithms.$trModule4_bytes" {
     GHC.Integer.Logarithms.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.937208713 UTC

[section ""data" . GHC.Integer.Logarithms.$trModule3_closure" {
     GHC.Integer.Logarithms.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.940435528 UTC

[section ""cstring" . GHC.Integer.Logarithms.$trModule2_bytes" {
     GHC.Integer.Logarithms.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.943717149 UTC

[section ""data" . GHC.Integer.Logarithms.$trModule1_closure" {
     GHC.Integer.Logarithms.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.946674452 UTC

[section ""data" . GHC.Integer.Logarithms.$trModule_closure" {
     GHC.Integer.Logarithms.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Logarithms.$trModule3_closure+1;
         const GHC.Integer.Logarithms.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.949499111 UTC

[section ""relreadonly" . SbcO_srt" {
     SbcO_srt:
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Logarithms.integerLogBase#_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_closure;
         const GHC.Integer.Logarithms.Internals.wordLog2#_closure;
 }]

