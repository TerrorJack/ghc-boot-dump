
==================== Raw Cmm ====================
2018-03-16 15:53:56.896936239 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:53:56.900291393 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.roundingMode#_closure" {
     GHC.Integer.Logarithms.Internals.roundingMode#_closure:
         const GHC.Integer.Logarithms.Internals.roundingMode#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.roundingMode#_entry() //  [R2, R3]
         { []
         }
     {offset
       cae0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caec; else goto caed;
       caec: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.roundingMode#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caed: // global
           I64[Sp - 16] = block_cadY_info;
           R3 = R3;
           _s9AM::P64 = R2;
           R2 = GHC.Integer.Type.oneInteger_closure;
           P64[Sp - 8] = _s9AM::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.roundingMode#_info" {
     GHC.Integer.Logarithms.Internals.roundingMode#_info:
         const GHC.Integer.Logarithms.Internals.roundingMode#_entry;
         const 0;
         const 30064771086;
         const 8589934606;
         const S9Ff_srt;
 },
 _cadY() //  [R1]
         { []
         }
     {offset
       cadY: // global
           I64[Sp - 8] = block_cae3_info;
           R3 = R1;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadY_info" {
     block_cadY_info:
         const _cadY;
         const 1;
         const 12884901918;
         const S9Ff_srt;
 },
 _cae3() //  [R1]
         { []
         }
     {offset
       cae3: // global
           I64[Sp] = block_cae7_info;
           R3 = GHC.Integer.Type.oneInteger_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae3_info" {
     block_cae3_info:
         const _cae3;
         const 2;
         const 4294967326;
         const S9Ff_srt+8;
 },
 _cae7() //  [R1]
         { []
         }
     {offset
       cae7: // global
           I64[Sp] = block_caeb_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae7_info" {
     block_cae7_info:
         const _cae7;
         const 2;
         const 30;
 },
 _caeb() //  [R1]
         { []
         }
     {offset
       caeb: // global
           I64[Sp] = block_caek_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeb_info" {
     block_caeb_info:
         const _caeb;
         const 130;
         const 30;
 },
 _caek() //  [R1]
         { []
         }
     {offset
       caek: // global
           if (R1 == 1) goto caeG; else goto caes;
       caeG: // global
           R1 = 2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caes: // global
           _s9AP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caep_info;
           R3 = _s9AP::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caek_info" {
     block_caek_info:
         const _caek;
         const 2;
         const 30;
 },
 _caep() //  [R1]
         { []
         }
     {offset
       caep: // global
           if (R1 == 1) goto caeC; else goto caey;
       caeC: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caey: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caep_info" {
     block_caep_info:
         const _caep;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.917613829 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.leadingZeros_closure" {
     GHC.Integer.Logarithms.Internals.leadingZeros_closure:
         const GHC.Integer.Logarithms.Internals.leadingZeros_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.leadingZeros_entry() //  [R1]
         { []
         }
     {offset
       cafj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cafk; else goto cafl;
       cafk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cafl: // global
           (_cafa::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cafa::I64 == 0) goto cafc; else goto cafb;
       cafc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cafb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cafa::I64;
           I64[Sp - 24] = block_cafd_info;
           R1 = 256;
           Sp = Sp - 24;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.leadingZeros_info" {
     GHC.Integer.Logarithms.Internals.leadingZeros_info:
         const GHC.Integer.Logarithms.Internals.leadingZeros_entry;
         const 0;
         const 21;
 },
 _cafd() //  [R1]
         { []
         }
     {offset
       cafd: // global
           I8[R1 + 16] = 9 :: W8;
           _s9AW::P64 = R1;
           _s9B6::I64 = 1;
           _s9B5::I64 = 8;
           _s9B4::I64 = 2;
           goto cafu;
       cafu: // global
           if (_s9B6::I64 == 256) goto uafP; else goto cafG;
       uafP: // global
           P64[Sp] = _s9AW::P64;
           Sp = Sp - 8;
           call _cafo() args: 0, res: 0, upd: 0;
       cafG: // global
           if (%MO_S_Ge_W64(_s9B6::I64,
                            _s9B4::I64)) goto cafD; else goto cafE;
       cafD: // global
           _s9B6::I64 = _s9B6::I64;
           _s9B5::I64 = _s9B5::I64 - 1;
           _s9B4::I64 = _s9B4::I64 << 1;
           goto cafu;
       cafE: // global
           I8[(_s9AW::P64 + 16) + _s9B6::I64] = %MO_UU_Conv_W64_W8(_s9B5::I64);
           _s9B6::I64 = _s9B6::I64 + 1;
           goto cafu;
     }
 },
 section ""relreadonly" . block_cafd_info" {
     block_cafd_info:
         const _cafd;
         const 0;
         const 30;
 },
 _cafo() //  []
         { []
         }
     {offset
       cafo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caft; else goto cafs;
       caft: // global
           HpAlloc = 16;
           I64[Sp] = block_cafo_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cafs: // global
           I64[Hp - 8] = GHC.Integer.Logarithms.Internals.BA_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cafo_info" {
     block_cafo_info:
         const _cafo;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.930022657 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.wordLog2#_closure" {
     GHC.Integer.Logarithms.Internals.wordLog2#_closure:
         const GHC.Integer.Logarithms.Internals.wordLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.wordLog2#_entry() //  [R2]
         { []
         }
     {offset
       cagf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagg; else goto cagh;
       cagg: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.wordLog2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagh: // global
           I64[Sp - 16] = block_cagc_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaiW; else goto cagd;
       uaiW: // global
           call _cagc(R1) args: 0, res: 0, upd: 0;
       cagd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.wordLog2#_info" {
     GHC.Integer.Logarithms.Internals.wordLog2#_info:
         const GHC.Integer.Logarithms.Internals.wordLog2#_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S9Ff_srt+24;
 },
 _cagc() //  [R1]
         { []
         }
     {offset
       cagc: // global
           _s9Be::I64 = I64[Sp + 8];
           _s9Bg::P64 = P64[R1 + 7];
           _s9Bh::I64 = _s9Be::I64 >> 56;
           if (_s9Bh::I64 != 0) goto cagz; else goto cagD;
       cagz: // global
           R1 = 64 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bh::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cagD: // global
           _s9Bk::I64 = _s9Be::I64 >> 48;
           if (_s9Bk::I64 != 0) goto cagV; else goto cagZ;
       cagV: // global
           R1 = 56 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bk::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cagZ: // global
           _s9Bn::I64 = _s9Be::I64 >> 40;
           if (_s9Bn::I64 != 0) goto cahh; else goto cahl;
       cahh: // global
           R1 = 48 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bn::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cahl: // global
           _s9Bq::I64 = _s9Be::I64 >> 32;
           if (_s9Bq::I64 != 0) goto cahD; else goto cahH;
       cahD: // global
           R1 = 40 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bq::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cahH: // global
           _s9Bt::I64 = _s9Be::I64 >> 24;
           if (_s9Bt::I64 != 0) goto cahZ; else goto cai3;
       cahZ: // global
           R1 = 32 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bt::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cai3: // global
           _s9Bw::I64 = _s9Be::I64 >> 16;
           if (_s9Bw::I64 != 0) goto cail; else goto caip;
       cail: // global
           R1 = 24 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bw::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caip: // global
           _s9Bz::I64 = _s9Be::I64 >> 8;
           if (_s9Bz::I64 != 0) goto caiH; else goto caiU;
       caiH: // global
           R1 = 16 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bz::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caiU: // global
           R1 = 8 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Be::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cagc_info" {
     block_cagc_info:
         const _cagc;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.942121437 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2#_step_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2#_step_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2#_step_entry() //  [R2,
                                                                 R3]
         { []
         }
     {offset
       cajN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cajO; else goto uanf;
       cajO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2#_step_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uanf: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cajD() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.integerLog2#_step_info" {
     GHC.Integer.Logarithms.Internals.integerLog2#_step_info:
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_entry;
         const 0;
         const 12884901902;
         const 8589934605;
         const S9Ff_srt+32;
 },
 _cajD() //  []
         { []
         }
     {offset
       cajD: // global
           I64[Sp - 8] = block_cajG_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uanh; else goto cajH;
       uanh: // global
           call _cajG(R1) args: 0, res: 0, upd: 0;
       cajH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajG() //  [R1]
         { []
         }
     {offset
       cajG: // global
           if (R1 & 7 == 1) goto cajK; else goto cajL;
       cajK: // global
           I64[Sp] = block_cajS_info;
           _s9BH::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _s9BH::I64;
           if (R1 & 7 != 0) goto uani; else goto cajU;
       uani: // global
           call _cajS(R1) args: 0, res: 0, upd: 0;
       cajU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cajL: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cajG_info" {
     block_cajG_info:
         const _cajG;
         const 194;
         const 4294967326;
         const S9Ff_srt+32;
 },
 _cajS() //  [R1]
         { []
         }
     {offset
       cajS: // global
           if (R1 & 7 == 1) goto cak0; else goto cak5;
       cak0: // global
           I64[Sp + 8] = I64[Sp + 8] + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cajD() args: 0, res: 0, upd: 0;
       cak5: // global
           I64[Sp] = block_cak3_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto uank; else goto cak6;
       uank: // global
           call _cak3(R1) args: 0, res: 0, upd: 0;
       cak6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cajS_info" {
     block_cajS_info:
         const _cajS;
         const 194;
         const 4294967326;
         const S9Ff_srt+32;
 },
 _cak3() //  [R1]
         { []
         }
     {offset
       cak3: // global
           _s9BE::I64 = I64[Sp + 8];
           _s9BH::I64 = I64[Sp + 16];
           _s9BO::P64 = P64[R1 + 7];
           _s9BP::I64 = _s9BH::I64 >> 56;
           if (_s9BP::I64 != 0) goto caks; else goto cakw;
       caks: // global
           R1 = _s9BE::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BP::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cakw: // global
           _s9BT::I64 = _s9BH::I64 >> 48;
           if (_s9BT::I64 != 0) goto cakR; else goto cakV;
       cakR: // global
           R1 = _s9BE::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BT::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cakV: // global
           _s9BX::I64 = _s9BH::I64 >> 40;
           if (_s9BX::I64 != 0) goto calg; else goto calk;
       calg: // global
           R1 = _s9BE::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BX::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       calk: // global
           _s9C1::I64 = _s9BH::I64 >> 32;
           if (_s9C1::I64 != 0) goto calF; else goto calJ;
       calF: // global
           R1 = _s9BE::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9C1::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       calJ: // global
           _s9C5::I64 = _s9BH::I64 >> 24;
           if (_s9C5::I64 != 0) goto cam4; else goto cam8;
       cam4: // global
           R1 = _s9BE::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9C5::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cam8: // global
           _s9C9::I64 = _s9BH::I64 >> 16;
           if (_s9C9::I64 != 0) goto camt; else goto camx;
       camt: // global
           R1 = _s9BE::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9C9::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       camx: // global
           _s9Cd::I64 = _s9BH::I64 >> 8;
           if (_s9Cd::I64 != 0) goto camS; else goto can8;
       camS: // global
           R1 = _s9BE::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9Cd::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       can8: // global
           R1 = _s9BE::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BH::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cak3_info" {
     block_cak3_info:
         const _cak3;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.958830669 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2#_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2#_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2#_entry() //  [R2]
         { []
         }
     {offset
       caoH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caoI; else goto caoJ;
       caoI: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caoJ: // global
           I64[Sp - 8] = block_caoA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaoQ; else goto caoB;
       uaoQ: // global
           call _caoA(R1) args: 0, res: 0, upd: 0;
       caoB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.integerLog2#_info" {
     GHC.Integer.Logarithms.Internals.integerLog2#_info:
         const GHC.Integer.Logarithms.Internals.integerLog2#_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S9Ff_srt+40;
 },
 _caoA() //  [R1]
         { []
         }
     {offset
       caoA: // global
           if (R1 & 7 == 1) goto caoF; else goto caoE;
       caoF: // global
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Logarithms.Internals.integerLog2#_step_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
       caoE: // global
           R1 = (-1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caoA_info" {
     block_caoA_info:
         const _caoA;
         const 0;
         const 4294967326;
         const S9Ff_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.97158772 UTC

[section ""data" . noPower_r9AI_closure" {
     noPower_r9AI_closure:
         const noPower_r9AI_info;
         const 0;
 },
 noPower_r9AI_entry() //  [R2, R3]
         { []
         }
     {offset
       cape: // global
           if ((Sp + -24) < SpLim) (likely: False) goto capf; else goto uasG;
       capf: // global
           R3 = R3;
           R2 = R2;
           R1 = noPower_r9AI_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uasG: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cap4() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . noPower_r9AI_info" {
     noPower_r9AI_info:
         const noPower_r9AI_entry;
         const 0;
         const 38654705678;
         const 8589934605;
         const S9Ff_srt+32;
 },
 _cap4() //  []
         { []
         }
     {offset
       cap4: // global
           I64[Sp - 8] = block_cap7_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uasI; else goto cap8;
       uasI: // global
           call _cap7(R1) args: 0, res: 0, upd: 0;
       cap8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cap7() //  [R1]
         { []
         }
     {offset
       cap7: // global
           if (R1 & 7 == 1) goto capb; else goto capc;
       capb: // global
           I64[Sp] = block_capj_info;
           _s9Cq::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _s9Cq::I64;
           if (R1 & 7 != 0) goto uasJ; else goto capl;
       uasJ: // global
           call _capj(R1) args: 0, res: 0, upd: 0;
       capl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       capc: // global
           R2 = 1;
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cap7_info" {
     block_cap7_info:
         const _cap7;
         const 194;
         const 4294967326;
         const S9Ff_srt+32;
 },
 _capj() //  [R1]
         { []
         }
     {offset
       capj: // global
           if (R1 & 7 == 1) goto capr; else goto capw;
       capr: // global
           I64[Sp + 8] = I64[Sp + 8] + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cap4() args: 0, res: 0, upd: 0;
       capw: // global
           I64[Sp] = block_capu_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto uasL; else goto capx;
       uasL: // global
           call _capu(R1) args: 0, res: 0, upd: 0;
       capx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_capj_info" {
     block_capj_info:
         const _capj;
         const 194;
         const 4294967326;
         const S9Ff_srt+32;
 },
 _capu() //  [R1]
         { []
         }
     {offset
       capu: // global
           _s9Cn::I64 = I64[Sp + 8];
           _s9Cq::I64 = I64[Sp + 16];
           _s9Cx::P64 = P64[R1 + 7];
           _s9Cy::I64 = _s9Cq::I64 >> 56;
           if (_s9Cy::I64 != 0) goto capH; else goto capN;
       capH: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9Cy::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       capN: // global
           _s9CD::I64 = _s9Cq::I64 >> 48;
           if (_s9CD::I64 != 0) goto capW; else goto caq2;
       capW: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CD::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caq2: // global
           _s9CI::I64 = _s9Cq::I64 >> 40;
           if (_s9CI::I64 != 0) goto caqb; else goto caqh;
       caqb: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CI::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caqh: // global
           _s9CN::I64 = _s9Cq::I64 >> 32;
           if (_s9CN::I64 != 0) goto caqq; else goto caqw;
       caqq: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CN::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caqw: // global
           _s9CS::I64 = _s9Cq::I64 >> 24;
           if (_s9CS::I64 != 0) goto caqF; else goto caqL;
       caqF: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CS::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caqL: // global
           _s9CX::I64 = _s9Cq::I64 >> 16;
           if (_s9CX::I64 != 0) goto caqU; else goto car0;
       caqU: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CX::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       car0: // global
           _s9D2::I64 = _s9Cq::I64 >> 8;
           if (_s9D2::I64 != 0) goto car9; else goto carf;
       car9: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9D2::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       carf: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9Cq::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_capu_info" {
     block_capu_info:
         const _capu;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.994178424 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry() //  [R2,
                                                                              R3]
         { []
         }
     {offset
       cau8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cau9; else goto uayR;
       cau9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uayR: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _catY() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry;
         const 0;
         const 107374182414;
         const 8589934605;
         const S9Ff_srt+32;
 },
 _catY() //  []
         { []
         }
     {offset
       catY: // global
           I64[Sp - 8] = block_cau1_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uayT; else goto cau2;
       uayT: // global
           call _cau1(R1) args: 0, res: 0, upd: 0;
       cau2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau1() //  [R1]
         { []
         }
     {offset
       cau1: // global
           if (R1 & 7 == 1) goto cau5; else goto cau6;
       cau5: // global
           I64[Sp] = block_caud_info;
           _s9De::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _s9De::I64;
           if (R1 & 7 != 0) goto uayU; else goto cauf;
       uayU: // global
           call _caud(R1) args: 0, res: 0, upd: 0;
       cauf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cau6: // global
           R2 = 1;
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cau1_info" {
     block_cau1_info:
         const _cau1;
         const 194;
         const 38654705694;
         const S9Ff_srt+32;
 },
 _caud() //  [R1]
         { []
         }
     {offset
       caud: // global
           if (R1 & 7 == 1) goto caup; else goto cauu;
       caup: // global
           _s9Db::I64 = I64[Sp + 8];
           if (I64[Sp + 16] == 0) goto caun; else goto caum;
       caun: // global
           I64[Sp + 8] = _s9Db::I64 + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _catY() args: 0, res: 0, upd: 0;
       caum: // global
           R3 = R1;
           R2 = _s9Db::I64 + 64;
           Sp = Sp + 24;
           call noPower_r9AI_entry(R3, R2) args: 8, res: 0, upd: 8;
       cauu: // global
           I64[Sp] = block_caus_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto uayW; else goto cauv;
       uayW: // global
           call _caus(R1) args: 0, res: 0, upd: 0;
       cauv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caud_info" {
     block_caud_info:
         const _caud;
         const 194;
         const 38654705694;
         const S9Ff_srt+32;
 },
 _caus() //  [R1]
         { []
         }
     {offset
       caus: // global
           _s9Db::I64 = I64[Sp + 8];
           _s9De::I64 = I64[Sp + 16];
           _s9Dn::P64 = P64[R1 + 7];
           _s9Do::I64 = _s9De::I64 >> 56;
           if (_s9Do::I64 != 0) goto cauF; else goto cauL;
       cauF: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9Do::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cauL: // global
           _s9Dw::I64 = _s9De::I64 >> 48;
           if (_s9Dw::I64 != 0) goto cauU; else goto cav0;
       cauU: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9Dw::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cav0: // global
           _s9DE::I64 = _s9De::I64 >> 40;
           if (_s9DE::I64 != 0) goto cav9; else goto cavf;
       cav9: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9DE::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cavf: // global
           _s9DM::I64 = _s9De::I64 >> 32;
           if (_s9DM::I64 != 0) goto cavo; else goto cavu;
       cavo: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9DM::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cavu: // global
           _s9DU::I64 = _s9De::I64 >> 24;
           if (_s9DU::I64 != 0) goto cavD; else goto cavJ;
       cavD: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9DU::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cavJ: // global
           _s9E2::I64 = _s9De::I64 >> 16;
           if (_s9E2::I64 != 0) goto cavS; else goto cavY;
       cavS: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9E2::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cavY: // global
           _s9Ea::I64 = _s9De::I64 >> 8;
           if (_s9Ea::I64 != 0) goto caw7; else goto cawd;
       caw7: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9Ea::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cawd: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9De::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caus_info" {
     block_caus_info:
         const _caus;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.009460888 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_entry() //  [R2]
         { []
         }
     {offset
       caAA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caAB; else goto caAC;
       caAB: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caAC: // global
           I64[Sp - 8] = block_caAt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaAJ; else goto caAu;
       uaAJ: // global
           call _caAt(R1) args: 0, res: 0, upd: 0;
       caAu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S9Ff_srt+64;
 },
 _caAt() //  [R1]
         { []
         }
     {offset
       caAt: // global
           if (R1 & 7 == 1) goto caAy; else goto caAx;
       caAy: // global
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry(R3,
                                                                                      R2) args: 8, res: 0, upd: 8;
       caAx: // global
           R2 = 1;
           R1 = (-1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caAt_info" {
     block_caAt_info:
         const _caAt;
         const 0;
         const 4294967326;
         const S9Ff_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.016405817 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$trModule4_bytes" {
     GHC.Integer.Logarithms.Internals.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.018839181 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule3_closure" {
     GHC.Integer.Logarithms.Internals.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.020865837 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$trModule2_bytes" {
     GHC.Integer.Logarithms.Internals.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115,46,73,110,116,101,114,110,97,108,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.023984055 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule1_closure" {
     GHC.Integer.Logarithms.Internals.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.026506158 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule_closure" {
     GHC.Integer.Logarithms.Internals.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule3_closure+1;
         const GHC.Integer.Logarithms.Internals.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.028913561 UTC

[section ""data" . $krep_r9AJ_closure" {
     $krep_r9AJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcByteArray#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.031669955 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$tcBA2_bytes" {
     GHC.Integer.Logarithms.Internals.$tcBA2_bytes:
         I8[] [66,65]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.034414931 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tcBA1_closure" {
     GHC.Integer.Logarithms.Internals.$tcBA1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$tcBA2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.03668451 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tcBA_closure" {
     GHC.Integer.Logarithms.Internals.$tcBA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule_closure+1;
         const GHC.Integer.Logarithms.Internals.$tcBA1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1270308961569198254;
         const 6805106280991229347;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.03894461 UTC

[section ""data" . $krep1_r9AK_closure" {
     $krep1_r9AK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Logarithms.Internals.$tcBA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.041566797 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA1_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r9AJ_closure+1;
         const $krep1_r9AK_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.043615855 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$tc'BA3_bytes" {
     GHC.Integer.Logarithms.Internals.$tc'BA3_bytes:
         I8[] [39,66,65]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.04595947 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA2_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$tc'BA3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.048426033 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule_closure+1;
         const GHC.Integer.Logarithms.Internals.$tc'BA2_closure+1;
         const GHC.Integer.Logarithms.Internals.$tc'BA1_closure+4;
         const 12402798602385785556;
         const 5679508278348334299;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.052308791 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.BA_closure" {
     GHC.Integer.Logarithms.Internals.BA_closure:
         const GHC.Integer.Logarithms.Internals.BA_info;
 },
 GHC.Integer.Logarithms.Internals.BA_entry() //  [R2]
         { []
         }
     {offset
       caBf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBj; else goto caBi;
       caBj: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.BA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBi: // global
           I64[Hp - 8] = GHC.Integer.Logarithms.Internals.BA_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.BA_info" {
     GHC.Integer.Logarithms.Internals.BA_info:
         const GHC.Integer.Logarithms.Internals.BA_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.057465433 UTC

[section ""cstring" . iadT_str" {
     iadT_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115,46,73,110,116,101,114,110,97,108,115,46,66,65]
 },
 GHC.Integer.Logarithms.Internals.BA_con_entry() //  [R1]
         { []
         }
     {offset
       caBp: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.BA_con_info" {
     GHC.Integer.Logarithms.Internals.BA_con_info:
         const GHC.Integer.Logarithms.Internals.BA_con_entry;
         const 1;
         const 2;
         const iadT_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:57.062499188 UTC

[section ""relreadonly" . S9Ff_srt" {
     S9Ff_srt:
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Integer.Logarithms.Internals.roundingMode#_closure;
         const GHC.Integer.Logarithms.Internals.wordLog2#_closure;
         const GHC.Integer.Logarithms.Internals.leadingZeros_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_closure;
         const noPower_r9AI_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.096692141 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:53:58.101029196 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.roundingMode#_closure" {
     GHC.Integer.Logarithms.Internals.roundingMode#_closure:
         const GHC.Integer.Logarithms.Internals.roundingMode#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.roundingMode#_entry() //  [R2, R3]
         { []
         }
     {offset
       caFi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caFu; else goto caFv;
       caFu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.roundingMode#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caFv: // global
           I64[Sp - 16] = block_caFg_info;
           R3 = R3;
           _saBw::P64 = R2;
           R2 = GHC.Integer.Type.oneInteger_closure;
           P64[Sp - 8] = _saBw::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.roundingMode#_info" {
     GHC.Integer.Logarithms.Internals.roundingMode#_info:
         const GHC.Integer.Logarithms.Internals.roundingMode#_entry;
         const 0;
         const 30064771086;
         const 8589934606;
         const SaFZ_srt;
 },
 _caFg() //  [R1]
         { []
         }
     {offset
       caFg: // global
           I64[Sp - 8] = block_caFl_info;
           R3 = R1;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caFg_info" {
     block_caFg_info:
         const _caFg;
         const 1;
         const 12884901918;
         const SaFZ_srt;
 },
 _caFl() //  [R1]
         { []
         }
     {offset
       caFl: // global
           I64[Sp] = block_caFp_info;
           R3 = GHC.Integer.Type.oneInteger_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caFl_info" {
     block_caFl_info:
         const _caFl;
         const 2;
         const 4294967326;
         const SaFZ_srt+8;
 },
 _caFp() //  [R1]
         { []
         }
     {offset
       caFp: // global
           I64[Sp] = block_caFt_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caFp_info" {
     block_caFp_info:
         const _caFp;
         const 2;
         const 30;
 },
 _caFt() //  [R1]
         { []
         }
     {offset
       caFt: // global
           I64[Sp] = block_caFC_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caFt_info" {
     block_caFt_info:
         const _caFt;
         const 130;
         const 30;
 },
 _caFC() //  [R1]
         { []
         }
     {offset
       caFC: // global
           if (R1 == 1) goto caFY; else goto caFK;
       caFY: // global
           R1 = 2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caFK: // global
           _saBz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caFH_info;
           R3 = _saBz::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caFC_info" {
     block_caFC_info:
         const _caFC;
         const 2;
         const 30;
 },
 _caFH() //  [R1]
         { []
         }
     {offset
       caFH: // global
           if (R1 == 1) goto caFU; else goto caFQ;
       caFU: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caFQ: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caFH_info" {
     block_caFH_info:
         const _caFH;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.117596027 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.leadingZeros_closure" {
     GHC.Integer.Logarithms.Internals.leadingZeros_closure:
         const GHC.Integer.Logarithms.Internals.leadingZeros_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.leadingZeros_entry() //  [R1]
         { []
         }
     {offset
       caGI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caGJ; else goto caGK;
       caGJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caGK: // global
           (_caGz::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caGz::I64 == 0) goto caGB; else goto caGA;
       caGB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caGA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caGz::I64;
           I64[Sp - 24] = block_caGC_info;
           R1 = 256;
           Sp = Sp - 24;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.leadingZeros_info" {
     GHC.Integer.Logarithms.Internals.leadingZeros_info:
         const GHC.Integer.Logarithms.Internals.leadingZeros_entry;
         const 0;
         const 21;
 },
 _caGC() //  [R1]
         { []
         }
     {offset
       caGC: // global
           I8[R1 + 16] = 9 :: W8;
           _saBG::P64 = R1;
           _saBQ::I64 = 1;
           _saBP::I64 = 8;
           _saBO::I64 = 2;
           goto caGT;
       caGT: // global
           if (_saBQ::I64 == 256) goto uaHe; else goto caH5;
       uaHe: // global
           P64[Sp] = _saBG::P64;
           Sp = Sp - 8;
           call _caGN() args: 0, res: 0, upd: 0;
       caH5: // global
           if (%MO_S_Ge_W64(_saBQ::I64,
                            _saBO::I64)) goto caH2; else goto caH3;
       caH2: // global
           _saBQ::I64 = _saBQ::I64;
           _saBP::I64 = _saBP::I64 - 1;
           _saBO::I64 = _saBO::I64 << 1;
           goto caGT;
       caH3: // global
           I8[(_saBG::P64 + 16) + _saBQ::I64] = %MO_UU_Conv_W64_W8(_saBP::I64);
           _saBQ::I64 = _saBQ::I64 + 1;
           goto caGT;
     }
 },
 section ""relreadonly" . block_caGC_info" {
     block_caGC_info:
         const _caGC;
         const 0;
         const 30;
 },
 _caGN() //  []
         { []
         }
     {offset
       caGN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGS; else goto caGR;
       caGS: // global
           HpAlloc = 16;
           I64[Sp] = block_caGN_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       caGR: // global
           I64[Hp - 8] = GHC.Integer.Logarithms.Internals.BA_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caGN_info" {
     block_caGN_info:
         const _caGN;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.129890821 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.wordLog2#_closure" {
     GHC.Integer.Logarithms.Internals.wordLog2#_closure:
         const GHC.Integer.Logarithms.Internals.wordLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.wordLog2#_entry() //  [R2]
         { []
         }
     {offset
       caHI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caHJ; else goto caHK;
       caHJ: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.wordLog2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHK: // global
           I64[Sp - 16] = block_caHF_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaKp; else goto caHG;
       uaKp: // global
           call _caHF(R1) args: 0, res: 0, upd: 0;
       caHG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.wordLog2#_info" {
     GHC.Integer.Logarithms.Internals.wordLog2#_info:
         const GHC.Integer.Logarithms.Internals.wordLog2#_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const SaFZ_srt+24;
 },
 _caHF() //  [R1]
         { []
         }
     {offset
       caHF: // global
           _saBY::I64 = I64[Sp + 8];
           _saC0::P64 = P64[R1 + 7];
           _saC1::I64 = _saBY::I64 >> 56;
           if (_saC1::I64 != 0) goto caI2; else goto caI6;
       caI2: // global
           R1 = 64 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saC1::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caI6: // global
           _saC4::I64 = _saBY::I64 >> 48;
           if (_saC4::I64 != 0) goto caIo; else goto caIs;
       caIo: // global
           R1 = 56 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saC4::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caIs: // global
           _saC7::I64 = _saBY::I64 >> 40;
           if (_saC7::I64 != 0) goto caIK; else goto caIO;
       caIK: // global
           R1 = 48 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saC7::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caIO: // global
           _saCa::I64 = _saBY::I64 >> 32;
           if (_saCa::I64 != 0) goto caJ6; else goto caJa;
       caJ6: // global
           R1 = 40 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saCa::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caJa: // global
           _saCd::I64 = _saBY::I64 >> 24;
           if (_saCd::I64 != 0) goto caJs; else goto caJw;
       caJs: // global
           R1 = 32 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saCd::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caJw: // global
           _saCg::I64 = _saBY::I64 >> 16;
           if (_saCg::I64 != 0) goto caJO; else goto caJS;
       caJO: // global
           R1 = 24 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saCg::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caJS: // global
           _saCj::I64 = _saBY::I64 >> 8;
           if (_saCj::I64 != 0) goto caKa; else goto caKn;
       caKa: // global
           R1 = 16 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saCj::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caKn: // global
           R1 = 8 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saBY::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caHF_info" {
     block_caHF_info:
         const _caHF;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.143891688 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2#_step_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2#_step_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2#_step_entry() //  [R2,
                                                                 R3]
         { []
         }
     {offset
       caLh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caLi; else goto uaOJ;
       caLi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2#_step_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uaOJ: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _caL7() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.integerLog2#_step_info" {
     GHC.Integer.Logarithms.Internals.integerLog2#_step_info:
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_entry;
         const 0;
         const 12884901902;
         const 8589934605;
         const SaFZ_srt+32;
 },
 _caL7() //  []
         { []
         }
     {offset
       caL7: // global
           I64[Sp - 8] = block_caLa_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOL; else goto caLb;
       uaOL: // global
           call _caLa(R1) args: 0, res: 0, upd: 0;
       caLb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caLa() //  [R1]
         { []
         }
     {offset
       caLa: // global
           if (R1 & 7 == 1) goto caLe; else goto caLf;
       caLe: // global
           I64[Sp] = block_caLm_info;
           _saCr::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _saCr::I64;
           if (R1 & 7 != 0) goto uaOM; else goto caLo;
       uaOM: // global
           call _caLm(R1) args: 0, res: 0, upd: 0;
       caLo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caLf: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caLa_info" {
     block_caLa_info:
         const _caLa;
         const 194;
         const 4294967326;
         const SaFZ_srt+32;
 },
 _caLm() //  [R1]
         { []
         }
     {offset
       caLm: // global
           if (R1 & 7 == 1) goto caLu; else goto caLz;
       caLu: // global
           I64[Sp + 8] = I64[Sp + 8] + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caL7() args: 0, res: 0, upd: 0;
       caLz: // global
           I64[Sp] = block_caLx_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto uaOO; else goto caLA;
       uaOO: // global
           call _caLx(R1) args: 0, res: 0, upd: 0;
       caLA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caLm_info" {
     block_caLm_info:
         const _caLm;
         const 194;
         const 4294967326;
         const SaFZ_srt+32;
 },
 _caLx() //  [R1]
         { []
         }
     {offset
       caLx: // global
           _saCo::I64 = I64[Sp + 8];
           _saCr::I64 = I64[Sp + 16];
           _saCy::P64 = P64[R1 + 7];
           _saCz::I64 = _saCr::I64 >> 56;
           if (_saCz::I64 != 0) goto caLW; else goto caM0;
       caLW: // global
           R1 = _saCo::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCz::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caM0: // global
           _saCD::I64 = _saCr::I64 >> 48;
           if (_saCD::I64 != 0) goto caMl; else goto caMp;
       caMl: // global
           R1 = _saCo::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCD::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMp: // global
           _saCH::I64 = _saCr::I64 >> 40;
           if (_saCH::I64 != 0) goto caMK; else goto caMO;
       caMK: // global
           R1 = _saCo::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCH::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMO: // global
           _saCL::I64 = _saCr::I64 >> 32;
           if (_saCL::I64 != 0) goto caN9; else goto caNd;
       caN9: // global
           R1 = _saCo::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCL::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNd: // global
           _saCP::I64 = _saCr::I64 >> 24;
           if (_saCP::I64 != 0) goto caNy; else goto caNC;
       caNy: // global
           R1 = _saCo::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCP::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNC: // global
           _saCT::I64 = _saCr::I64 >> 16;
           if (_saCT::I64 != 0) goto caNX; else goto caO1;
       caNX: // global
           R1 = _saCo::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCT::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caO1: // global
           _saCX::I64 = _saCr::I64 >> 8;
           if (_saCX::I64 != 0) goto caOm; else goto caOC;
       caOm: // global
           R1 = _saCo::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCX::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caOC: // global
           R1 = _saCo::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCr::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caLx_info" {
     block_caLx_info:
         const _caLx;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.162813337 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2#_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2#_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2#_entry() //  [R2]
         { []
         }
     {offset
       caQe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caQf; else goto caQg;
       caQf: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQg: // global
           I64[Sp - 8] = block_caQ7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQn; else goto caQ8;
       uaQn: // global
           call _caQ7(R1) args: 0, res: 0, upd: 0;
       caQ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.integerLog2#_info" {
     GHC.Integer.Logarithms.Internals.integerLog2#_info:
         const GHC.Integer.Logarithms.Internals.integerLog2#_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SaFZ_srt+40;
 },
 _caQ7() //  [R1]
         { []
         }
     {offset
       caQ7: // global
           if (R1 & 7 == 1) goto caQc; else goto caQb;
       caQc: // global
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Logarithms.Internals.integerLog2#_step_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
       caQb: // global
           R1 = (-1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caQ7_info" {
     block_caQ7_info:
         const _caQ7;
         const 0;
         const 4294967326;
         const SaFZ_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.174638304 UTC

[section ""data" . noPower_r9AI_closure" {
     noPower_r9AI_closure:
         const noPower_r9AI_info;
         const 0;
 },
 noPower_r9AI_entry() //  [R2, R3]
         { []
         }
     {offset
       caQM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caQN; else goto uaUe;
       caQN: // global
           R3 = R3;
           R2 = R2;
           R1 = noPower_r9AI_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uaUe: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _caQC() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . noPower_r9AI_info" {
     noPower_r9AI_info:
         const noPower_r9AI_entry;
         const 0;
         const 38654705678;
         const 8589934605;
         const SaFZ_srt+32;
 },
 _caQC() //  []
         { []
         }
     {offset
       caQC: // global
           I64[Sp - 8] = block_caQF_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaUg; else goto caQG;
       uaUg: // global
           call _caQF(R1) args: 0, res: 0, upd: 0;
       caQG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQF() //  [R1]
         { []
         }
     {offset
       caQF: // global
           if (R1 & 7 == 1) goto caQJ; else goto caQK;
       caQJ: // global
           I64[Sp] = block_caQR_info;
           _saDa::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _saDa::I64;
           if (R1 & 7 != 0) goto uaUh; else goto caQT;
       uaUh: // global
           call _caQR(R1) args: 0, res: 0, upd: 0;
       caQT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caQK: // global
           R2 = 1;
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caQF_info" {
     block_caQF_info:
         const _caQF;
         const 194;
         const 4294967326;
         const SaFZ_srt+32;
 },
 _caQR() //  [R1]
         { []
         }
     {offset
       caQR: // global
           if (R1 & 7 == 1) goto caQZ; else goto caR4;
       caQZ: // global
           I64[Sp + 8] = I64[Sp + 8] + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caQC() args: 0, res: 0, upd: 0;
       caR4: // global
           I64[Sp] = block_caR2_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto uaUj; else goto caR5;
       uaUj: // global
           call _caR2(R1) args: 0, res: 0, upd: 0;
       caR5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caQR_info" {
     block_caQR_info:
         const _caQR;
         const 194;
         const 4294967326;
         const SaFZ_srt+32;
 },
 _caR2() //  [R1]
         { []
         }
     {offset
       caR2: // global
           _saD7::I64 = I64[Sp + 8];
           _saDa::I64 = I64[Sp + 16];
           _saDh::P64 = P64[R1 + 7];
           _saDi::I64 = _saDa::I64 >> 56;
           if (_saDi::I64 != 0) goto caRf; else goto caRl;
       caRf: // global
           R2 = 1;
           R1 = _saD7::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDi::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caRl: // global
           _saDn::I64 = _saDa::I64 >> 48;
           if (_saDn::I64 != 0) goto caRu; else goto caRA;
       caRu: // global
           R2 = 1;
           R1 = _saD7::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDn::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caRA: // global
           _saDs::I64 = _saDa::I64 >> 40;
           if (_saDs::I64 != 0) goto caRJ; else goto caRP;
       caRJ: // global
           R2 = 1;
           R1 = _saD7::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDs::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caRP: // global
           _saDx::I64 = _saDa::I64 >> 32;
           if (_saDx::I64 != 0) goto caRY; else goto caS4;
       caRY: // global
           R2 = 1;
           R1 = _saD7::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDx::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caS4: // global
           _saDC::I64 = _saDa::I64 >> 24;
           if (_saDC::I64 != 0) goto caSd; else goto caSj;
       caSd: // global
           R2 = 1;
           R1 = _saD7::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDC::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caSj: // global
           _saDH::I64 = _saDa::I64 >> 16;
           if (_saDH::I64 != 0) goto caSs; else goto caSy;
       caSs: // global
           R2 = 1;
           R1 = _saD7::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDH::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caSy: // global
           _saDM::I64 = _saDa::I64 >> 8;
           if (_saDM::I64 != 0) goto caSH; else goto caSN;
       caSH: // global
           R2 = 1;
           R1 = _saD7::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDM::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caSN: // global
           R2 = 1;
           R1 = _saD7::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDa::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caR2_info" {
     block_caR2_info:
         const _caR2;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.199858531 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry() //  [R2,
                                                                              R3]
         { []
         }
     {offset
       caVJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caVK; else goto ub0s;
       caVK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ub0s: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _caVz() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry;
         const 0;
         const 107374182414;
         const 8589934605;
         const SaFZ_srt+32;
 },
 _caVz() //  []
         { []
         }
     {offset
       caVz: // global
           I64[Sp - 8] = block_caVC_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0u; else goto caVD;
       ub0u: // global
           call _caVC(R1) args: 0, res: 0, upd: 0;
       caVD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caVC() //  [R1]
         { []
         }
     {offset
       caVC: // global
           if (R1 & 7 == 1) goto caVG; else goto caVH;
       caVG: // global
           I64[Sp] = block_caVO_info;
           _saDY::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _saDY::I64;
           if (R1 & 7 != 0) goto ub0v; else goto caVQ;
       ub0v: // global
           call _caVO(R1) args: 0, res: 0, upd: 0;
       caVQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caVH: // global
           R2 = 1;
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caVC_info" {
     block_caVC_info:
         const _caVC;
         const 194;
         const 38654705694;
         const SaFZ_srt+32;
 },
 _caVO() //  [R1]
         { []
         }
     {offset
       caVO: // global
           if (R1 & 7 == 1) goto caW0; else goto caW5;
       caW0: // global
           _saDV::I64 = I64[Sp + 8];
           if (I64[Sp + 16] == 0) goto caVY; else goto caVX;
       caVY: // global
           I64[Sp + 8] = _saDV::I64 + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caVz() args: 0, res: 0, upd: 0;
       caVX: // global
           R3 = R1;
           R2 = _saDV::I64 + 64;
           Sp = Sp + 24;
           call noPower_r9AI_entry(R3, R2) args: 8, res: 0, upd: 8;
       caW5: // global
           I64[Sp] = block_caW3_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto ub0x; else goto caW6;
       ub0x: // global
           call _caW3(R1) args: 0, res: 0, upd: 0;
       caW6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caVO_info" {
     block_caVO_info:
         const _caVO;
         const 194;
         const 38654705694;
         const SaFZ_srt+32;
 },
 _caW3() //  [R1]
         { []
         }
     {offset
       caW3: // global
           _saDV::I64 = I64[Sp + 8];
           _saDY::I64 = I64[Sp + 16];
           _saE7::P64 = P64[R1 + 7];
           _saE8::I64 = _saDY::I64 >> 56;
           if (_saE8::I64 != 0) goto caWg; else goto caWm;
       caWg: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saE8::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caWm: // global
           _saEg::I64 = _saDY::I64 >> 48;
           if (_saEg::I64 != 0) goto caWv; else goto caWB;
       caWv: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saEg::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caWB: // global
           _saEo::I64 = _saDY::I64 >> 40;
           if (_saEo::I64 != 0) goto caWK; else goto caWQ;
       caWK: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saEo::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caWQ: // global
           _saEw::I64 = _saDY::I64 >> 32;
           if (_saEw::I64 != 0) goto caWZ; else goto caX5;
       caWZ: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saEw::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caX5: // global
           _saEE::I64 = _saDY::I64 >> 24;
           if (_saEE::I64 != 0) goto caXe; else goto caXk;
       caXe: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saEE::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caXk: // global
           _saEM::I64 = _saDY::I64 >> 16;
           if (_saEM::I64 != 0) goto caXt; else goto caXz;
       caXt: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saEM::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caXz: // global
           _saEU::I64 = _saDY::I64 >> 8;
           if (_saEU::I64 != 0) goto caXI; else goto caXO;
       caXI: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saEU::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caXO: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saDY::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caW3_info" {
     block_caW3_info:
         const _caW3;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.219729641 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_entry() //  [R2]
         { []
         }
     {offset
       cb2e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb2f; else goto cb2g;
       cb2f: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb2g: // global
           I64[Sp - 8] = block_cb27_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub2n; else goto cb28;
       ub2n: // global
           call _cb27(R1) args: 0, res: 0, upd: 0;
       cb28: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SaFZ_srt+64;
 },
 _cb27() //  [R1]
         { []
         }
     {offset
       cb27: // global
           if (R1 & 7 == 1) goto cb2c; else goto cb2b;
       cb2c: // global
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry(R3,
                                                                                      R2) args: 8, res: 0, upd: 8;
       cb2b: // global
           R2 = 1;
           R1 = (-1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cb27_info" {
     block_cb27_info:
         const _cb27;
         const 0;
         const 4294967326;
         const SaFZ_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.227208505 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$trModule4_bytes" {
     GHC.Integer.Logarithms.Internals.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.229555334 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule3_closure" {
     GHC.Integer.Logarithms.Internals.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.23155952 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$trModule2_bytes" {
     GHC.Integer.Logarithms.Internals.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115,46,73,110,116,101,114,110,97,108,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.233714409 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule1_closure" {
     GHC.Integer.Logarithms.Internals.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.235613037 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule_closure" {
     GHC.Integer.Logarithms.Internals.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule3_closure+1;
         const GHC.Integer.Logarithms.Internals.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.238057391 UTC

[section ""data" . $krep_r9AJ_closure" {
     $krep_r9AJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcByteArray#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.240301121 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$tcBA2_bytes" {
     GHC.Integer.Logarithms.Internals.$tcBA2_bytes:
         I8[] [66,65]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.242608537 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tcBA1_closure" {
     GHC.Integer.Logarithms.Internals.$tcBA1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$tcBA2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.244832428 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tcBA_closure" {
     GHC.Integer.Logarithms.Internals.$tcBA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule_closure+1;
         const GHC.Integer.Logarithms.Internals.$tcBA1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1270308961569198254;
         const 6805106280991229347;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.247205856 UTC

[section ""data" . $krep1_r9AK_closure" {
     $krep1_r9AK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Logarithms.Internals.$tcBA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.249560948 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA1_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r9AJ_closure+1;
         const $krep1_r9AK_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.251789041 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$tc'BA3_bytes" {
     GHC.Integer.Logarithms.Internals.$tc'BA3_bytes:
         I8[] [39,66,65]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.254099507 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA2_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$tc'BA3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.256451407 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule_closure+1;
         const GHC.Integer.Logarithms.Internals.$tc'BA2_closure+1;
         const GHC.Integer.Logarithms.Internals.$tc'BA1_closure+4;
         const 12402798602385785556;
         const 5679508278348334299;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.260143851 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.BA_closure" {
     GHC.Integer.Logarithms.Internals.BA_closure:
         const GHC.Integer.Logarithms.Internals.BA_info;
 },
 GHC.Integer.Logarithms.Internals.BA_entry() //  [R2]
         { []
         }
     {offset
       cb2U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb2Y; else goto cb2X;
       cb2Y: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.BA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb2X: // global
           I64[Hp - 8] = GHC.Integer.Logarithms.Internals.BA_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.BA_info" {
     GHC.Integer.Logarithms.Internals.BA_info:
         const GHC.Integer.Logarithms.Internals.BA_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.265072962 UTC

[section ""cstring" . ib36_str" {
     ib36_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115,46,73,110,116,101,114,110,97,108,115,46,66,65]
 },
 GHC.Integer.Logarithms.Internals.BA_con_entry() //  [R1]
         { []
         }
     {offset
       cb35: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Logarithms.Internals.BA_con_info" {
     GHC.Integer.Logarithms.Internals.BA_con_info:
         const GHC.Integer.Logarithms.Internals.BA_con_entry;
         const 1;
         const 2;
         const ib36_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:58.269808089 UTC

[section ""relreadonly" . SaFZ_srt" {
     SaFZ_srt:
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Integer.Logarithms.Internals.roundingMode#_closure;
         const GHC.Integer.Logarithms.Internals.wordLog2#_closure;
         const GHC.Integer.Logarithms.Internals.leadingZeros_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_closure;
         const noPower_r9AI_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure;
 }]

