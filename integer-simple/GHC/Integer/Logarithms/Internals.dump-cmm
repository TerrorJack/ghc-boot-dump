
==================== Output Cmm ====================
2018-03-16 15:53:56.80241064 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:53:56.803705047 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.roundingMode#_closure" {
     GHC.Integer.Logarithms.Internals.roundingMode#_closure:
         const GHC.Integer.Logarithms.Internals.roundingMode#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.roundingMode#_entry() //  [R2, R3]
         { info_tbl: [(c9Ey,
                       label: GHC.Integer.Logarithms.Internals.roundingMode#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ey: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9EK; else goto c9EL;
       c9EK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.roundingMode#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9EL: // global
           I64[Sp - 16] = block_c9Ew_info;
           R3 = R3;
           _s9AM::P64 = R2;
           R2 = GHC.Integer.Type.oneInteger_closure;
           P64[Sp - 8] = _s9AM::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ew() //  [R1]
         { info_tbl: [(c9Ew,
                       label: block_c9Ew_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ew: // global
           I64[Sp - 8] = block_c9EB_info;
           R3 = R1;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9EB() //  [R1]
         { info_tbl: [(c9EB,
                       label: block_c9EB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9EB: // global
           I64[Sp] = block_c9EF_info;
           R3 = GHC.Integer.Type.oneInteger_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9EF() //  [R1]
         { info_tbl: [(c9EF,
                       label: block_c9EF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9EF: // global
           I64[Sp] = block_c9EJ_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9EJ() //  [R1]
         { info_tbl: [(c9EJ,
                       label: block_c9EJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9EJ: // global
           I64[Sp] = block_c9ES_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9ES() //  [R1]
         { info_tbl: [(c9ES,
                       label: block_c9ES_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ES: // global
           if (R1 == 1) goto c9Fe; else goto c9F0;
       c9Fe: // global
           R1 = 2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9F0: // global
           _s9AP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9EX_info;
           R3 = _s9AP::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9EX() //  [R1]
         { info_tbl: [(c9EX,
                       label: block_c9EX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9EX: // global
           if (R1 == 1) goto c9Fa; else goto c9F6;
       c9Fa: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9F6: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.811597414 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.leadingZeros_closure" {
     GHC.Integer.Logarithms.Internals.leadingZeros_closure:
         const GHC.Integer.Logarithms.Internals.leadingZeros_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.leadingZeros_entry() //  [R1]
         { info_tbl: [(c9Fs,
                       label: GHC.Integer.Logarithms.Internals.leadingZeros_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Fs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9Ft; else goto c9Fu;
       c9Ft: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Fu: // global
           (_c9Fj::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Fj::I64 == 0) goto c9Fl; else goto c9Fk;
       c9Fl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Fk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Fj::I64;
           I64[Sp - 24] = block_c9Fm_info;
           R1 = 256;
           Sp = Sp - 24;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9Fm() //  [R1]
         { info_tbl: [(c9Fm,
                       label: block_c9Fm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Fm: // global
           I8[R1 + 16] = 9 :: W8;
           _s9AW::P64 = R1;
           _s9B6::I64 = 1;
           _s9B5::I64 = 8;
           _s9B4::I64 = 2;
           goto c9FD;
       c9FD: // global
           if (_s9B6::I64 == 256) goto u9FY; else goto c9FP;
       u9FY: // global
           P64[Sp] = _s9AW::P64;
           Sp = Sp - 8;
           call _c9Fx() args: 0, res: 0, upd: 0;
       c9FP: // global
           if (%MO_S_Ge_W64(_s9B6::I64,
                            _s9B4::I64)) goto c9FM; else goto c9FN;
       c9FM: // global
           _s9B6::I64 = _s9B6::I64;
           _s9B5::I64 = _s9B5::I64 - 1;
           _s9B4::I64 = _s9B4::I64 << 1;
           goto c9FD;
       c9FN: // global
           I8[(_s9AW::P64 + 16) + _s9B6::I64] = %MO_UU_Conv_W64_W8(_s9B5::I64);
           _s9B6::I64 = _s9B6::I64 + 1;
           goto c9FD;
     }
 },
 _c9Fx() //  []
         { info_tbl: [(c9Fx,
                       label: block_c9Fx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Fx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9FC; else goto c9FB;
       c9FC: // global
           HpAlloc = 16;
           I64[Sp] = block_c9Fx_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c9FB: // global
           I64[Hp - 8] = GHC.Integer.Logarithms.Internals.BA_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.815682205 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.wordLog2#_closure" {
     GHC.Integer.Logarithms.Internals.wordLog2#_closure:
         const GHC.Integer.Logarithms.Internals.wordLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.wordLog2#_entry() //  [R2]
         { info_tbl: [(c9G7,
                       label: GHC.Integer.Logarithms.Internals.wordLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9G8; else goto c9G9;
       c9G8: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.wordLog2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9G9: // global
           I64[Sp - 16] = block_c9G4_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9IO; else goto c9G5;
       u9IO: // global
           call _c9G4(R1) args: 0, res: 0, upd: 0;
       c9G5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G4() //  [R1]
         { info_tbl: [(c9G4,
                       label: block_c9G4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G4: // global
           _s9Be::I64 = I64[Sp + 8];
           _s9Bg::P64 = P64[R1 + 7];
           _s9Bh::I64 = _s9Be::I64 >> 56;
           if (_s9Bh::I64 != 0) goto c9Gr; else goto c9Gv;
       c9Gr: // global
           R1 = 64 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bh::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Gv: // global
           _s9Bk::I64 = _s9Be::I64 >> 48;
           if (_s9Bk::I64 != 0) goto c9GN; else goto c9GR;
       c9GN: // global
           R1 = 56 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bk::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9GR: // global
           _s9Bn::I64 = _s9Be::I64 >> 40;
           if (_s9Bn::I64 != 0) goto c9H9; else goto c9Hd;
       c9H9: // global
           R1 = 48 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bn::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Hd: // global
           _s9Bq::I64 = _s9Be::I64 >> 32;
           if (_s9Bq::I64 != 0) goto c9Hv; else goto c9Hz;
       c9Hv: // global
           R1 = 40 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bq::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Hz: // global
           _s9Bt::I64 = _s9Be::I64 >> 24;
           if (_s9Bt::I64 != 0) goto c9HR; else goto c9HV;
       c9HR: // global
           R1 = 32 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bt::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9HV: // global
           _s9Bw::I64 = _s9Be::I64 >> 16;
           if (_s9Bw::I64 != 0) goto c9Id; else goto c9Ih;
       c9Id: // global
           R1 = 24 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bw::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Ih: // global
           _s9Bz::I64 = _s9Be::I64 >> 8;
           if (_s9Bz::I64 != 0) goto c9Iz; else goto c9IM;
       c9Iz: // global
           R1 = 16 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bz::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9IM: // global
           R1 = 8 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Be::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.823867905 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2#_step_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2#_step_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2#_step_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(c9J0,
                       label: GHC.Integer.Logarithms.Internals.integerLog2#_step_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J1; else goto u9Ms;
       c9J1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2#_step_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u9Ms: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c9IQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9IQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IQ: // global
           I64[Sp - 8] = block_c9IT_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Mu; else goto c9IU;
       u9Mu: // global
           call _c9IT(R1) args: 0, res: 0, upd: 0;
       c9IU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IT() //  [R1]
         { info_tbl: [(c9IT,
                       label: block_c9IT_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IT: // global
           if (R1 & 7 == 1) goto c9IX; else goto c9IY;
       c9IX: // global
           I64[Sp] = block_c9J5_info;
           _s9BH::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _s9BH::I64;
           if (R1 & 7 != 0) goto u9Mv; else goto c9J7;
       u9Mv: // global
           call _c9J5(R1) args: 0, res: 0, upd: 0;
       c9J7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IY: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9J5() //  [R1]
         { info_tbl: [(c9J5,
                       label: block_c9J5_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J5: // global
           if (R1 & 7 == 1) goto c9Jd; else goto c9Ji;
       c9Jd: // global
           I64[Sp + 8] = I64[Sp + 8] + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c9IQ() args: 0, res: 0, upd: 0;
       c9Ji: // global
           I64[Sp] = block_c9Jg_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto u9Mx; else goto c9Jj;
       u9Mx: // global
           call _c9Jg(R1) args: 0, res: 0, upd: 0;
       c9Jj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jg() //  [R1]
         { info_tbl: [(c9Jg,
                       label: block_c9Jg_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jg: // global
           _s9BE::I64 = I64[Sp + 8];
           _s9BH::I64 = I64[Sp + 16];
           _s9BO::P64 = P64[R1 + 7];
           _s9BP::I64 = _s9BH::I64 >> 56;
           if (_s9BP::I64 != 0) goto c9JF; else goto c9JJ;
       c9JF: // global
           R1 = _s9BE::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BP::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9JJ: // global
           _s9BT::I64 = _s9BH::I64 >> 48;
           if (_s9BT::I64 != 0) goto c9K4; else goto c9K8;
       c9K4: // global
           R1 = _s9BE::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BT::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9K8: // global
           _s9BX::I64 = _s9BH::I64 >> 40;
           if (_s9BX::I64 != 0) goto c9Kt; else goto c9Kx;
       c9Kt: // global
           R1 = _s9BE::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BX::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Kx: // global
           _s9C1::I64 = _s9BH::I64 >> 32;
           if (_s9C1::I64 != 0) goto c9KS; else goto c9KW;
       c9KS: // global
           R1 = _s9BE::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9C1::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9KW: // global
           _s9C5::I64 = _s9BH::I64 >> 24;
           if (_s9C5::I64 != 0) goto c9Lh; else goto c9Ll;
       c9Lh: // global
           R1 = _s9BE::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9C5::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Ll: // global
           _s9C9::I64 = _s9BH::I64 >> 16;
           if (_s9C9::I64 != 0) goto c9LG; else goto c9LK;
       c9LG: // global
           R1 = _s9BE::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9C9::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9LK: // global
           _s9Cd::I64 = _s9BH::I64 >> 8;
           if (_s9Cd::I64 != 0) goto c9M5; else goto c9Ml;
       c9M5: // global
           R1 = _s9BE::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9Cd::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Ml: // global
           R1 = _s9BE::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BH::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.828505947 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2#_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2#_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2#_entry() //  [R2]
         { info_tbl: [(c9MK,
                       label: GHC.Integer.Logarithms.Internals.integerLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9ML; else goto c9MM;
       c9ML: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9MM: // global
           I64[Sp - 8] = block_c9MD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9MT; else goto c9ME;
       u9MT: // global
           call _c9MD(R1) args: 0, res: 0, upd: 0;
       c9ME: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MD() //  [R1]
         { info_tbl: [(c9MD,
                       label: block_c9MD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MD: // global
           if (R1 & 7 == 1) goto c9MI; else goto c9MH;
       c9MI: // global
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Logarithms.Internals.integerLog2#_step_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
       c9MH: // global
           R1 = (-1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.831777024 UTC

[section ""data" . noPower_r9AI_closure" {
     noPower_r9AI_closure:
         const noPower_r9AI_info;
         const 0;
 },
 noPower_r9AI_entry() //  [R2, R3]
         { info_tbl: [(c9N5,
                       label: noPower_r9AI_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9N6; else goto u9Qx;
       c9N6: // global
           R3 = R3;
           R2 = R2;
           R1 = noPower_r9AI_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u9Qx: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c9MV() args: 0, res: 0, upd: 0;
     }
 },
 _c9MV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MV: // global
           I64[Sp - 8] = block_c9MY_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Qz; else goto c9MZ;
       u9Qz: // global
           call _c9MY(R1) args: 0, res: 0, upd: 0;
       c9MZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MY() //  [R1]
         { info_tbl: [(c9MY,
                       label: block_c9MY_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MY: // global
           if (R1 & 7 == 1) goto c9N2; else goto c9N3;
       c9N2: // global
           I64[Sp] = block_c9Na_info;
           _s9Cq::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _s9Cq::I64;
           if (R1 & 7 != 0) goto u9QA; else goto c9Nc;
       u9QA: // global
           call _c9Na(R1) args: 0, res: 0, upd: 0;
       c9Nc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9N3: // global
           R2 = 1;
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Na() //  [R1]
         { info_tbl: [(c9Na,
                       label: block_c9Na_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Na: // global
           if (R1 & 7 == 1) goto c9Ni; else goto c9Nn;
       c9Ni: // global
           I64[Sp + 8] = I64[Sp + 8] + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c9MV() args: 0, res: 0, upd: 0;
       c9Nn: // global
           I64[Sp] = block_c9Nl_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto u9QC; else goto c9No;
       u9QC: // global
           call _c9Nl(R1) args: 0, res: 0, upd: 0;
       c9No: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Nl() //  [R1]
         { info_tbl: [(c9Nl,
                       label: block_c9Nl_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nl: // global
           _s9Cn::I64 = I64[Sp + 8];
           _s9Cq::I64 = I64[Sp + 16];
           _s9Cx::P64 = P64[R1 + 7];
           _s9Cy::I64 = _s9Cq::I64 >> 56;
           if (_s9Cy::I64 != 0) goto c9Ny; else goto c9NE;
       c9Ny: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9Cy::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9NE: // global
           _s9CD::I64 = _s9Cq::I64 >> 48;
           if (_s9CD::I64 != 0) goto c9NN; else goto c9NT;
       c9NN: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CD::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9NT: // global
           _s9CI::I64 = _s9Cq::I64 >> 40;
           if (_s9CI::I64 != 0) goto c9O2; else goto c9O8;
       c9O2: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CI::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9O8: // global
           _s9CN::I64 = _s9Cq::I64 >> 32;
           if (_s9CN::I64 != 0) goto c9Oh; else goto c9On;
       c9Oh: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CN::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9On: // global
           _s9CS::I64 = _s9Cq::I64 >> 24;
           if (_s9CS::I64 != 0) goto c9Ow; else goto c9OC;
       c9Ow: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CS::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9OC: // global
           _s9CX::I64 = _s9Cq::I64 >> 16;
           if (_s9CX::I64 != 0) goto c9OL; else goto c9OR;
       c9OL: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CX::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9OR: // global
           _s9D2::I64 = _s9Cq::I64 >> 8;
           if (_s9D2::I64 != 0) goto c9P0; else goto c9P6;
       c9P0: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9D2::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9P6: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9Cq::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.836992337 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry() //  [R2,
                                                                              R3]
         { info_tbl: [(c9QP,
                       label: GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9QP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9QQ; else goto u9Vy;
       c9QQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u9Vy: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c9QF() args: 0, res: 0, upd: 0;
     }
 },
 _c9QF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9QF: // global
           I64[Sp - 8] = block_c9QI_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VA; else goto c9QJ;
       u9VA: // global
           call _c9QI(R1) args: 0, res: 0, upd: 0;
       c9QJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9QI() //  [R1]
         { info_tbl: [(c9QI,
                       label: block_c9QI_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9QI: // global
           if (R1 & 7 == 1) goto c9QM; else goto c9QN;
       c9QM: // global
           I64[Sp] = block_c9QU_info;
           _s9De::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _s9De::I64;
           if (R1 & 7 != 0) goto u9VB; else goto c9QW;
       u9VB: // global
           call _c9QU(R1) args: 0, res: 0, upd: 0;
       c9QW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9QN: // global
           R2 = 1;
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9QU() //  [R1]
         { info_tbl: [(c9QU,
                       label: block_c9QU_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9QU: // global
           if (R1 & 7 == 1) goto c9R6; else goto c9Rb;
       c9R6: // global
           _s9Db::I64 = I64[Sp + 8];
           if (I64[Sp + 16] == 0) goto c9R4; else goto c9R3;
       c9R4: // global
           I64[Sp + 8] = _s9Db::I64 + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c9QF() args: 0, res: 0, upd: 0;
       c9R3: // global
           R3 = R1;
           R2 = _s9Db::I64 + 64;
           Sp = Sp + 24;
           call noPower_r9AI_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9Rb: // global
           I64[Sp] = block_c9R9_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto u9VD; else goto c9Rc;
       u9VD: // global
           call _c9R9(R1) args: 0, res: 0, upd: 0;
       c9Rc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9R9() //  [R1]
         { info_tbl: [(c9R9,
                       label: block_c9R9_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9R9: // global
           _s9Db::I64 = I64[Sp + 8];
           _s9De::I64 = I64[Sp + 16];
           _s9Dn::P64 = P64[R1 + 7];
           _s9Do::I64 = _s9De::I64 >> 56;
           if (_s9Do::I64 != 0) goto c9Rm; else goto c9Rs;
       c9Rm: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9Do::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9Rs: // global
           _s9Dw::I64 = _s9De::I64 >> 48;
           if (_s9Dw::I64 != 0) goto c9RB; else goto c9RH;
       c9RB: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9Dw::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9RH: // global
           _s9DE::I64 = _s9De::I64 >> 40;
           if (_s9DE::I64 != 0) goto c9RQ; else goto c9RW;
       c9RQ: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9DE::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9RW: // global
           _s9DM::I64 = _s9De::I64 >> 32;
           if (_s9DM::I64 != 0) goto c9S5; else goto c9Sb;
       c9S5: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9DM::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9Sb: // global
           _s9DU::I64 = _s9De::I64 >> 24;
           if (_s9DU::I64 != 0) goto c9Sk; else goto c9Sq;
       c9Sk: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9DU::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9Sq: // global
           _s9E2::I64 = _s9De::I64 >> 16;
           if (_s9E2::I64 != 0) goto c9Sz; else goto c9SF;
       c9Sz: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9E2::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9SF: // global
           _s9Ea::I64 = _s9De::I64 >> 8;
           if (_s9Ea::I64 != 0) goto c9SO; else goto c9SU;
       c9SO: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9Ea::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9SU: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9De::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.840359391 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_entry() //  [R2]
         { info_tbl: [(c9VQ,
                       label: GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9VR; else goto c9VS;
       c9VR: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9VS: // global
           I64[Sp - 8] = block_c9VJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9VZ; else goto c9VK;
       u9VZ: // global
           call _c9VJ(R1) args: 0, res: 0, upd: 0;
       c9VK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9VJ() //  [R1]
         { info_tbl: [(c9VJ,
                       label: block_c9VJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VJ: // global
           if (R1 & 7 == 1) goto c9VO; else goto c9VN;
       c9VO: // global
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry(R3,
                                                                                      R2) args: 8, res: 0, upd: 8;
       c9VN: // global
           R2 = 1;
           R1 = (-1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.841591324 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$trModule4_bytes" {
     GHC.Integer.Logarithms.Internals.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.842270224 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule3_closure" {
     GHC.Integer.Logarithms.Internals.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.84286277 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$trModule2_bytes" {
     GHC.Integer.Logarithms.Internals.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115,46,73,110,116,101,114,110,97,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.843561639 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule1_closure" {
     GHC.Integer.Logarithms.Internals.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.844270445 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule_closure" {
     GHC.Integer.Logarithms.Internals.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule3_closure+1;
         const GHC.Integer.Logarithms.Internals.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.845650256 UTC

[section ""data" . $krep_r9AJ_closure" {
     $krep_r9AJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcByteArray#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.846380361 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$tcBA2_bytes" {
     GHC.Integer.Logarithms.Internals.$tcBA2_bytes:
         I8[] [66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.847062442 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tcBA1_closure" {
     GHC.Integer.Logarithms.Internals.$tcBA1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$tcBA2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.847769856 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tcBA_closure" {
     GHC.Integer.Logarithms.Internals.$tcBA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule_closure+1;
         const GHC.Integer.Logarithms.Internals.$tcBA1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1270308961569198254;
         const 6805106280991229347;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.848475372 UTC

[section ""data" . $krep1_r9AK_closure" {
     $krep1_r9AK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Logarithms.Internals.$tcBA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.849169994 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA1_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r9AJ_closure+1;
         const $krep1_r9AK_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.849932556 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$tc'BA3_bytes" {
     GHC.Integer.Logarithms.Internals.$tc'BA3_bytes:
         I8[] [39,66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.850601059 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA2_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$tc'BA3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.851357001 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule_closure+1;
         const GHC.Integer.Logarithms.Internals.$tc'BA2_closure+1;
         const GHC.Integer.Logarithms.Internals.$tc'BA1_closure+4;
         const 12402798602385785556;
         const 5679508278348334299;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.852430607 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.BA_closure" {
     GHC.Integer.Logarithms.Internals.BA_closure:
         const GHC.Integer.Logarithms.Internals.BA_info;
 },
 GHC.Integer.Logarithms.Internals.BA_entry() //  [R2]
         { info_tbl: [(c9W5,
                       label: GHC.Integer.Logarithms.Internals.BA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9W9; else goto c9W8;
       c9W9: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.BA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9W8: // global
           I64[Hp - 8] = GHC.Integer.Logarithms.Internals.BA_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.853531686 UTC

[GHC.Integer.Logarithms.Internals.BA_con_entry() //  [R1]
         { info_tbl: [(c9Wa,
                       label: GHC.Integer.Logarithms.Internals.BA_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115,46,73,110,116,101,114,110,97,108,115,46,66,65]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wa: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.854818948 UTC

[section ""relreadonly" . S9Ff_srt" {
     S9Ff_srt:
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Integer.Logarithms.Internals.roundingMode#_closure;
         const GHC.Integer.Logarithms.Internals.wordLog2#_closure;
         const GHC.Integer.Logarithms.Internals.leadingZeros_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_closure;
         const noPower_r9AI_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.855541011 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:53:56.856725338 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.roundingMode#_closure" {
     GHC.Integer.Logarithms.Internals.roundingMode#_closure:
         const GHC.Integer.Logarithms.Internals.roundingMode#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.roundingMode#_entry() //  [R2, R3]
         { info_tbl: [(c9Wh,
                       label: GHC.Integer.Logarithms.Internals.roundingMode#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Wt; else goto c9Wu;
       c9Wt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.roundingMode#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Wu: // global
           I64[Sp - 16] = block_c9Wf_info;
           R3 = R3;
           _s9AM::P64 = R2;
           R2 = GHC.Integer.Type.oneInteger_closure;
           P64[Sp - 8] = _s9AM::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Wf() //  [R1]
         { info_tbl: [(c9Wf,
                       label: block_c9Wf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wf: // global
           I64[Sp - 8] = block_c9Wk_info;
           R3 = R1;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Wk() //  [R1]
         { info_tbl: [(c9Wk,
                       label: block_c9Wk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wk: // global
           I64[Sp] = block_c9Wo_info;
           R3 = GHC.Integer.Type.oneInteger_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Wo() //  [R1]
         { info_tbl: [(c9Wo,
                       label: block_c9Wo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wo: // global
           I64[Sp] = block_c9Ws_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ws() //  [R1]
         { info_tbl: [(c9Ws,
                       label: block_c9Ws_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ws: // global
           I64[Sp] = block_c9WB_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9WB() //  [R1]
         { info_tbl: [(c9WB,
                       label: block_c9WB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WB: // global
           if (R1 == 1) goto c9WX; else goto c9WJ;
       c9WX: // global
           R1 = 2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9WJ: // global
           _s9AP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9WG_info;
           R3 = _s9AP::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9WG() //  [R1]
         { info_tbl: [(c9WG,
                       label: block_c9WG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WG: // global
           if (R1 == 1) goto c9WT; else goto c9WP;
       c9WT: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9WP: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.859564032 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.leadingZeros_closure" {
     GHC.Integer.Logarithms.Internals.leadingZeros_closure:
         const GHC.Integer.Logarithms.Internals.leadingZeros_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.leadingZeros_entry() //  [R1]
         { info_tbl: [(c9Xa,
                       label: GHC.Integer.Logarithms.Internals.leadingZeros_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Xa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9Xb; else goto c9Xc;
       c9Xb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Xc: // global
           (_c9X1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9X1::I64 == 0) goto c9X3; else goto c9X2;
       c9X3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9X2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9X1::I64;
           I64[Sp - 24] = block_c9X4_info;
           R1 = 256;
           Sp = Sp - 24;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9X4() //  [R1]
         { info_tbl: [(c9X4,
                       label: block_c9X4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9X4: // global
           I8[R1 + 16] = 9 :: W8;
           _s9AW::P64 = R1;
           _s9B6::I64 = 1;
           _s9B5::I64 = 8;
           _s9B4::I64 = 2;
           goto c9Xl;
       c9Xl: // global
           if (_s9B6::I64 == 256) goto u9XG; else goto c9Xx;
       u9XG: // global
           P64[Sp] = _s9AW::P64;
           Sp = Sp - 8;
           call _c9Xf() args: 0, res: 0, upd: 0;
       c9Xx: // global
           if (%MO_S_Ge_W64(_s9B6::I64,
                            _s9B4::I64)) goto c9Xu; else goto c9Xv;
       c9Xu: // global
           _s9B6::I64 = _s9B6::I64;
           _s9B5::I64 = _s9B5::I64 - 1;
           _s9B4::I64 = _s9B4::I64 << 1;
           goto c9Xl;
       c9Xv: // global
           I8[(_s9AW::P64 + 16) + _s9B6::I64] = %MO_UU_Conv_W64_W8(_s9B5::I64);
           _s9B6::I64 = _s9B6::I64 + 1;
           goto c9Xl;
     }
 },
 _c9Xf() //  []
         { info_tbl: [(c9Xf,
                       label: block_c9Xf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Xf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Xk; else goto c9Xj;
       c9Xk: // global
           HpAlloc = 16;
           I64[Sp] = block_c9Xf_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c9Xj: // global
           I64[Hp - 8] = GHC.Integer.Logarithms.Internals.BA_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.862090679 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.wordLog2#_closure" {
     GHC.Integer.Logarithms.Internals.wordLog2#_closure:
         const GHC.Integer.Logarithms.Internals.wordLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.wordLog2#_entry() //  [R2]
         { info_tbl: [(c9XP,
                       label: GHC.Integer.Logarithms.Internals.wordLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9XP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9XQ; else goto c9XR;
       c9XQ: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.wordLog2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9XR: // global
           I64[Sp - 16] = block_c9XM_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua0w; else goto c9XN;
       ua0w: // global
           call _c9XM(R1) args: 0, res: 0, upd: 0;
       c9XN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9XM() //  [R1]
         { info_tbl: [(c9XM,
                       label: block_c9XM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9XM: // global
           _s9Be::I64 = I64[Sp + 8];
           _s9Bg::P64 = P64[R1 + 7];
           _s9Bh::I64 = _s9Be::I64 >> 56;
           if (_s9Bh::I64 != 0) goto c9Y9; else goto c9Yd;
       c9Y9: // global
           R1 = 64 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bh::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Yd: // global
           _s9Bk::I64 = _s9Be::I64 >> 48;
           if (_s9Bk::I64 != 0) goto c9Yv; else goto c9Yz;
       c9Yv: // global
           R1 = 56 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bk::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Yz: // global
           _s9Bn::I64 = _s9Be::I64 >> 40;
           if (_s9Bn::I64 != 0) goto c9YR; else goto c9YV;
       c9YR: // global
           R1 = 48 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bn::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9YV: // global
           _s9Bq::I64 = _s9Be::I64 >> 32;
           if (_s9Bq::I64 != 0) goto c9Zd; else goto c9Zh;
       c9Zd: // global
           R1 = 40 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bq::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Zh: // global
           _s9Bt::I64 = _s9Be::I64 >> 24;
           if (_s9Bt::I64 != 0) goto c9Zz; else goto c9ZD;
       c9Zz: // global
           R1 = 32 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bt::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9ZD: // global
           _s9Bw::I64 = _s9Be::I64 >> 16;
           if (_s9Bw::I64 != 0) goto c9ZV; else goto c9ZZ;
       c9ZV: // global
           R1 = 24 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bw::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9ZZ: // global
           _s9Bz::I64 = _s9Be::I64 >> 8;
           if (_s9Bz::I64 != 0) goto ca0h; else goto ca0u;
       ca0h: // global
           R1 = 16 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bz::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca0u: // global
           R1 = 8 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Be::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.866252478 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2#_step_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2#_step_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2#_step_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(ca0I,
                       label: GHC.Integer.Logarithms.Internals.integerLog2#_step_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca0I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca0J; else goto ua4a;
       ca0J: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2#_step_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ua4a: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _ca0y() args: 0, res: 0, upd: 0;
     }
 },
 _ca0y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca0y: // global
           I64[Sp - 8] = block_ca0B_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua4c; else goto ca0C;
       ua4c: // global
           call _ca0B(R1) args: 0, res: 0, upd: 0;
       ca0C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca0B() //  [R1]
         { info_tbl: [(ca0B,
                       label: block_ca0B_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca0B: // global
           if (R1 & 7 == 1) goto ca0F; else goto ca0G;
       ca0F: // global
           I64[Sp] = block_ca0N_info;
           _s9BH::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _s9BH::I64;
           if (R1 & 7 != 0) goto ua4d; else goto ca0P;
       ua4d: // global
           call _ca0N(R1) args: 0, res: 0, upd: 0;
       ca0P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca0G: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca0N() //  [R1]
         { info_tbl: [(ca0N,
                       label: block_ca0N_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca0N: // global
           if (R1 & 7 == 1) goto ca0V; else goto ca10;
       ca0V: // global
           I64[Sp + 8] = I64[Sp + 8] + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _ca0y() args: 0, res: 0, upd: 0;
       ca10: // global
           I64[Sp] = block_ca0Y_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto ua4f; else goto ca11;
       ua4f: // global
           call _ca0Y(R1) args: 0, res: 0, upd: 0;
       ca11: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca0Y() //  [R1]
         { info_tbl: [(ca0Y,
                       label: block_ca0Y_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca0Y: // global
           _s9BE::I64 = I64[Sp + 8];
           _s9BH::I64 = I64[Sp + 16];
           _s9BO::P64 = P64[R1 + 7];
           _s9BP::I64 = _s9BH::I64 >> 56;
           if (_s9BP::I64 != 0) goto ca1n; else goto ca1r;
       ca1n: // global
           R1 = _s9BE::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BP::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca1r: // global
           _s9BT::I64 = _s9BH::I64 >> 48;
           if (_s9BT::I64 != 0) goto ca1M; else goto ca1Q;
       ca1M: // global
           R1 = _s9BE::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BT::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca1Q: // global
           _s9BX::I64 = _s9BH::I64 >> 40;
           if (_s9BX::I64 != 0) goto ca2b; else goto ca2f;
       ca2b: // global
           R1 = _s9BE::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BX::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca2f: // global
           _s9C1::I64 = _s9BH::I64 >> 32;
           if (_s9C1::I64 != 0) goto ca2A; else goto ca2E;
       ca2A: // global
           R1 = _s9BE::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9C1::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca2E: // global
           _s9C5::I64 = _s9BH::I64 >> 24;
           if (_s9C5::I64 != 0) goto ca2Z; else goto ca33;
       ca2Z: // global
           R1 = _s9BE::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9C5::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca33: // global
           _s9C9::I64 = _s9BH::I64 >> 16;
           if (_s9C9::I64 != 0) goto ca3o; else goto ca3s;
       ca3o: // global
           R1 = _s9BE::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9C9::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca3s: // global
           _s9Cd::I64 = _s9BH::I64 >> 8;
           if (_s9Cd::I64 != 0) goto ca3N; else goto ca43;
       ca3N: // global
           R1 = _s9BE::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9Cd::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca43: // global
           R1 = _s9BE::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BH::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.869200993 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2#_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2#_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2#_entry() //  [R2]
         { info_tbl: [(ca4s,
                       label: GHC.Integer.Logarithms.Internals.integerLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca4s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca4t; else goto ca4u;
       ca4t: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca4u: // global
           I64[Sp - 8] = block_ca4l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua4B; else goto ca4m;
       ua4B: // global
           call _ca4l(R1) args: 0, res: 0, upd: 0;
       ca4m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca4l() //  [R1]
         { info_tbl: [(ca4l,
                       label: block_ca4l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca4l: // global
           if (R1 & 7 == 1) goto ca4q; else goto ca4p;
       ca4q: // global
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Logarithms.Internals.integerLog2#_step_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
       ca4p: // global
           R1 = (-1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.872106805 UTC

[section ""data" . noPower_r9AI_closure" {
     noPower_r9AI_closure:
         const noPower_r9AI_info;
         const 0;
 },
 noPower_r9AI_entry() //  [R2, R3]
         { info_tbl: [(ca4N,
                       label: noPower_r9AI_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca4N: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca4O; else goto ua8f;
       ca4O: // global
           R3 = R3;
           R2 = R2;
           R1 = noPower_r9AI_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ua8f: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _ca4D() args: 0, res: 0, upd: 0;
     }
 },
 _ca4D() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca4D: // global
           I64[Sp - 8] = block_ca4G_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8h; else goto ca4H;
       ua8h: // global
           call _ca4G(R1) args: 0, res: 0, upd: 0;
       ca4H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca4G() //  [R1]
         { info_tbl: [(ca4G,
                       label: block_ca4G_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca4G: // global
           if (R1 & 7 == 1) goto ca4K; else goto ca4L;
       ca4K: // global
           I64[Sp] = block_ca4S_info;
           _s9Cq::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _s9Cq::I64;
           if (R1 & 7 != 0) goto ua8i; else goto ca4U;
       ua8i: // global
           call _ca4S(R1) args: 0, res: 0, upd: 0;
       ca4U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca4L: // global
           R2 = 1;
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca4S() //  [R1]
         { info_tbl: [(ca4S,
                       label: block_ca4S_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca4S: // global
           if (R1 & 7 == 1) goto ca50; else goto ca55;
       ca50: // global
           I64[Sp + 8] = I64[Sp + 8] + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _ca4D() args: 0, res: 0, upd: 0;
       ca55: // global
           I64[Sp] = block_ca53_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto ua8k; else goto ca56;
       ua8k: // global
           call _ca53(R1) args: 0, res: 0, upd: 0;
       ca56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca53() //  [R1]
         { info_tbl: [(ca53,
                       label: block_ca53_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca53: // global
           _s9Cn::I64 = I64[Sp + 8];
           _s9Cq::I64 = I64[Sp + 16];
           _s9Cx::P64 = P64[R1 + 7];
           _s9Cy::I64 = _s9Cq::I64 >> 56;
           if (_s9Cy::I64 != 0) goto ca5g; else goto ca5m;
       ca5g: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9Cy::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ca5m: // global
           _s9CD::I64 = _s9Cq::I64 >> 48;
           if (_s9CD::I64 != 0) goto ca5v; else goto ca5B;
       ca5v: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CD::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ca5B: // global
           _s9CI::I64 = _s9Cq::I64 >> 40;
           if (_s9CI::I64 != 0) goto ca5K; else goto ca5Q;
       ca5K: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CI::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ca5Q: // global
           _s9CN::I64 = _s9Cq::I64 >> 32;
           if (_s9CN::I64 != 0) goto ca5Z; else goto ca65;
       ca5Z: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CN::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ca65: // global
           _s9CS::I64 = _s9Cq::I64 >> 24;
           if (_s9CS::I64 != 0) goto ca6e; else goto ca6k;
       ca6e: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CS::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ca6k: // global
           _s9CX::I64 = _s9Cq::I64 >> 16;
           if (_s9CX::I64 != 0) goto ca6t; else goto ca6z;
       ca6t: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CX::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ca6z: // global
           _s9D2::I64 = _s9Cq::I64 >> 8;
           if (_s9D2::I64 != 0) goto ca6I; else goto ca6O;
       ca6I: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9D2::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ca6O: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9Cq::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.87759784 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry() //  [R2,
                                                                              R3]
         { info_tbl: [(ca8x,
                       label: GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8x: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8y; else goto uadg;
       ca8y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uadg: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _ca8n() args: 0, res: 0, upd: 0;
     }
 },
 _ca8n() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8n: // global
           I64[Sp - 8] = block_ca8q_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadi; else goto ca8r;
       uadi: // global
           call _ca8q(R1) args: 0, res: 0, upd: 0;
       ca8r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8q() //  [R1]
         { info_tbl: [(ca8q,
                       label: block_ca8q_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8q: // global
           if (R1 & 7 == 1) goto ca8u; else goto ca8v;
       ca8u: // global
           I64[Sp] = block_ca8C_info;
           _s9De::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _s9De::I64;
           if (R1 & 7 != 0) goto uadj; else goto ca8E;
       uadj: // global
           call _ca8C(R1) args: 0, res: 0, upd: 0;
       ca8E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca8v: // global
           R2 = 1;
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca8C() //  [R1]
         { info_tbl: [(ca8C,
                       label: block_ca8C_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8C: // global
           if (R1 & 7 == 1) goto ca8O; else goto ca8T;
       ca8O: // global
           _s9Db::I64 = I64[Sp + 8];
           if (I64[Sp + 16] == 0) goto ca8M; else goto ca8L;
       ca8M: // global
           I64[Sp + 8] = _s9Db::I64 + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _ca8n() args: 0, res: 0, upd: 0;
       ca8L: // global
           R3 = R1;
           R2 = _s9Db::I64 + 64;
           Sp = Sp + 24;
           call noPower_r9AI_entry(R3, R2) args: 8, res: 0, upd: 8;
       ca8T: // global
           I64[Sp] = block_ca8R_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto uadl; else goto ca8U;
       uadl: // global
           call _ca8R(R1) args: 0, res: 0, upd: 0;
       ca8U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8R() //  [R1]
         { info_tbl: [(ca8R,
                       label: block_ca8R_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8R: // global
           _s9Db::I64 = I64[Sp + 8];
           _s9De::I64 = I64[Sp + 16];
           _s9Dn::P64 = P64[R1 + 7];
           _s9Do::I64 = _s9De::I64 >> 56;
           if (_s9Do::I64 != 0) goto ca94; else goto ca9a;
       ca94: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9Do::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ca9a: // global
           _s9Dw::I64 = _s9De::I64 >> 48;
           if (_s9Dw::I64 != 0) goto ca9j; else goto ca9p;
       ca9j: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9Dw::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ca9p: // global
           _s9DE::I64 = _s9De::I64 >> 40;
           if (_s9DE::I64 != 0) goto ca9y; else goto ca9E;
       ca9y: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9DE::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ca9E: // global
           _s9DM::I64 = _s9De::I64 >> 32;
           if (_s9DM::I64 != 0) goto ca9N; else goto ca9T;
       ca9N: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9DM::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ca9T: // global
           _s9DU::I64 = _s9De::I64 >> 24;
           if (_s9DU::I64 != 0) goto caa2; else goto caa8;
       caa2: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9DU::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caa8: // global
           _s9E2::I64 = _s9De::I64 >> 16;
           if (_s9E2::I64 != 0) goto caah; else goto caan;
       caah: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9E2::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caan: // global
           _s9Ea::I64 = _s9De::I64 >> 8;
           if (_s9Ea::I64 != 0) goto caaw; else goto caaC;
       caaw: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9Ea::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caaC: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9De::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.880882863 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_entry() //  [R2]
         { info_tbl: [(cady,
                       label: GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cady: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cadz; else goto cadA;
       cadz: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadA: // global
           I64[Sp - 8] = block_cadr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadH; else goto cads;
       uadH: // global
           call _cadr(R1) args: 0, res: 0, upd: 0;
       cads: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadr() //  [R1]
         { info_tbl: [(cadr,
                       label: block_cadr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadr: // global
           if (R1 & 7 == 1) goto cadw; else goto cadv;
       cadw: // global
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry(R3,
                                                                                      R2) args: 8, res: 0, upd: 8;
       cadv: // global
           R2 = 1;
           R1 = (-1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.882193085 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$trModule4_bytes" {
     GHC.Integer.Logarithms.Internals.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.882871421 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule3_closure" {
     GHC.Integer.Logarithms.Internals.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.883561898 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$trModule2_bytes" {
     GHC.Integer.Logarithms.Internals.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115,46,73,110,116,101,114,110,97,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.884207837 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule1_closure" {
     GHC.Integer.Logarithms.Internals.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.884914808 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule_closure" {
     GHC.Integer.Logarithms.Internals.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule3_closure+1;
         const GHC.Integer.Logarithms.Internals.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.886229334 UTC

[section ""data" . $krep_r9AJ_closure" {
     $krep_r9AJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcByteArray#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.88689226 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$tcBA2_bytes" {
     GHC.Integer.Logarithms.Internals.$tcBA2_bytes:
         I8[] [66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.88756901 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tcBA1_closure" {
     GHC.Integer.Logarithms.Internals.$tcBA1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$tcBA2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.888252324 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tcBA_closure" {
     GHC.Integer.Logarithms.Internals.$tcBA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule_closure+1;
         const GHC.Integer.Logarithms.Internals.$tcBA1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1270308961569198254;
         const 6805106280991229347;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.889036254 UTC

[section ""data" . $krep1_r9AK_closure" {
     $krep1_r9AK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Logarithms.Internals.$tcBA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.889789554 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA1_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r9AJ_closure+1;
         const $krep1_r9AK_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.890458561 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$tc'BA3_bytes" {
     GHC.Integer.Logarithms.Internals.$tc'BA3_bytes:
         I8[] [39,66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.891145085 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA2_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$tc'BA3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.891845234 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule_closure+1;
         const GHC.Integer.Logarithms.Internals.$tc'BA2_closure+1;
         const GHC.Integer.Logarithms.Internals.$tc'BA1_closure+4;
         const 12402798602385785556;
         const 5679508278348334299;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.892891774 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.BA_closure" {
     GHC.Integer.Logarithms.Internals.BA_closure:
         const GHC.Integer.Logarithms.Internals.BA_info;
 },
 GHC.Integer.Logarithms.Internals.BA_entry() //  [R2]
         { info_tbl: [(cadN,
                       label: GHC.Integer.Logarithms.Internals.BA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadR; else goto cadQ;
       cadR: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.BA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadQ: // global
           I64[Hp - 8] = GHC.Integer.Logarithms.Internals.BA_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.894016336 UTC

[GHC.Integer.Logarithms.Internals.BA_con_entry() //  [R1]
         { info_tbl: [(cadS,
                       label: GHC.Integer.Logarithms.Internals.BA_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115,46,73,110,116,101,114,110,97,108,115,46,66,65]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadS: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.895283646 UTC

[section ""relreadonly" . S9Ff_srt" {
     S9Ff_srt:
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Integer.Logarithms.Internals.roundingMode#_closure;
         const GHC.Integer.Logarithms.Internals.wordLog2#_closure;
         const GHC.Integer.Logarithms.Internals.leadingZeros_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_closure;
         const noPower_r9AI_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.896260901 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:53:56.898314058 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.roundingMode#_closure" {
     GHC.Integer.Logarithms.Internals.roundingMode#_closure:
         const GHC.Integer.Logarithms.Internals.roundingMode#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.roundingMode#_entry() //  [R2, R3]
         { info_tbl: [(cae0,
                       label: GHC.Integer.Logarithms.Internals.roundingMode#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caec; else goto caed;
       caec: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.roundingMode#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caed: // global
           I64[Sp - 16] = block_cadY_info;
           R3 = R3;
           _s9AM::P64 = R2;
           R2 = GHC.Integer.Type.oneInteger_closure;
           P64[Sp - 8] = _s9AM::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cadY() //  [R1]
         { info_tbl: [(cadY,
                       label: block_cadY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadY: // global
           I64[Sp - 8] = block_cae3_info;
           R3 = R1;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cae3() //  [R1]
         { info_tbl: [(cae3,
                       label: block_cae3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae3: // global
           I64[Sp] = block_cae7_info;
           R3 = GHC.Integer.Type.oneInteger_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cae7() //  [R1]
         { info_tbl: [(cae7,
                       label: block_cae7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae7: // global
           I64[Sp] = block_caeb_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeb() //  [R1]
         { info_tbl: [(caeb,
                       label: block_caeb_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeb: // global
           I64[Sp] = block_caek_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _caek() //  [R1]
         { info_tbl: [(caek,
                       label: block_caek_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caek: // global
           if (R1 == 1) goto caeG; else goto caes;
       caeG: // global
           R1 = 2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caes: // global
           _s9AP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caep_info;
           R3 = _s9AP::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _caep() //  [R1]
         { info_tbl: [(caep,
                       label: block_caep_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caep: // global
           if (R1 == 1) goto caeC; else goto caey;
       caeC: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caey: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.915945024 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.leadingZeros_closure" {
     GHC.Integer.Logarithms.Internals.leadingZeros_closure:
         const GHC.Integer.Logarithms.Internals.leadingZeros_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.leadingZeros_entry() //  [R1]
         { info_tbl: [(cafj,
                       label: GHC.Integer.Logarithms.Internals.leadingZeros_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cafk; else goto cafl;
       cafk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cafl: // global
           (_cafa::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cafa::I64 == 0) goto cafc; else goto cafb;
       cafc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cafb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cafa::I64;
           I64[Sp - 24] = block_cafd_info;
           R1 = 256;
           Sp = Sp - 24;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cafd() //  [R1]
         { info_tbl: [(cafd,
                       label: block_cafd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafd: // global
           I8[R1 + 16] = 9 :: W8;
           _s9AW::P64 = R1;
           _s9B6::I64 = 1;
           _s9B5::I64 = 8;
           _s9B4::I64 = 2;
           goto cafu;
       cafu: // global
           if (_s9B6::I64 == 256) goto uafP; else goto cafG;
       uafP: // global
           P64[Sp] = _s9AW::P64;
           Sp = Sp - 8;
           call _cafo() args: 0, res: 0, upd: 0;
       cafG: // global
           if (%MO_S_Ge_W64(_s9B6::I64,
                            _s9B4::I64)) goto cafD; else goto cafE;
       cafD: // global
           _s9B6::I64 = _s9B6::I64;
           _s9B5::I64 = _s9B5::I64 - 1;
           _s9B4::I64 = _s9B4::I64 << 1;
           goto cafu;
       cafE: // global
           I8[(_s9AW::P64 + 16) + _s9B6::I64] = %MO_UU_Conv_W64_W8(_s9B5::I64);
           _s9B6::I64 = _s9B6::I64 + 1;
           goto cafu;
     }
 },
 _cafo() //  []
         { info_tbl: [(cafo,
                       label: block_cafo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caft; else goto cafs;
       caft: // global
           HpAlloc = 16;
           I64[Sp] = block_cafo_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cafs: // global
           I64[Hp - 8] = GHC.Integer.Logarithms.Internals.BA_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.927922801 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.wordLog2#_closure" {
     GHC.Integer.Logarithms.Internals.wordLog2#_closure:
         const GHC.Integer.Logarithms.Internals.wordLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.wordLog2#_entry() //  [R2]
         { info_tbl: [(cagf,
                       label: GHC.Integer.Logarithms.Internals.wordLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagg; else goto cagh;
       cagg: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.wordLog2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagh: // global
           I64[Sp - 16] = block_cagc_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaiW; else goto cagd;
       uaiW: // global
           call _cagc(R1) args: 0, res: 0, upd: 0;
       cagd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagc() //  [R1]
         { info_tbl: [(cagc,
                       label: block_cagc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagc: // global
           _s9Be::I64 = I64[Sp + 8];
           _s9Bg::P64 = P64[R1 + 7];
           _s9Bh::I64 = _s9Be::I64 >> 56;
           if (_s9Bh::I64 != 0) goto cagz; else goto cagD;
       cagz: // global
           R1 = 64 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bh::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cagD: // global
           _s9Bk::I64 = _s9Be::I64 >> 48;
           if (_s9Bk::I64 != 0) goto cagV; else goto cagZ;
       cagV: // global
           R1 = 56 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bk::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cagZ: // global
           _s9Bn::I64 = _s9Be::I64 >> 40;
           if (_s9Bn::I64 != 0) goto cahh; else goto cahl;
       cahh: // global
           R1 = 48 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bn::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cahl: // global
           _s9Bq::I64 = _s9Be::I64 >> 32;
           if (_s9Bq::I64 != 0) goto cahD; else goto cahH;
       cahD: // global
           R1 = 40 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bq::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cahH: // global
           _s9Bt::I64 = _s9Be::I64 >> 24;
           if (_s9Bt::I64 != 0) goto cahZ; else goto cai3;
       cahZ: // global
           R1 = 32 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bt::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cai3: // global
           _s9Bw::I64 = _s9Be::I64 >> 16;
           if (_s9Bw::I64 != 0) goto cail; else goto caip;
       cail: // global
           R1 = 24 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bw::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caip: // global
           _s9Bz::I64 = _s9Be::I64 >> 8;
           if (_s9Bz::I64 != 0) goto caiH; else goto caiU;
       caiH: // global
           R1 = 16 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Bz::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caiU: // global
           R1 = 8 - %MO_SS_Conv_W8_W64(I8[(_s9Bg::P64 + 16) + _s9Be::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.939052039 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2#_step_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2#_step_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2#_step_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cajN,
                       label: GHC.Integer.Logarithms.Internals.integerLog2#_step_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cajO; else goto uanf;
       cajO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2#_step_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uanf: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cajD() args: 0, res: 0, upd: 0;
     }
 },
 _cajD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajD: // global
           I64[Sp - 8] = block_cajG_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uanh; else goto cajH;
       uanh: // global
           call _cajG(R1) args: 0, res: 0, upd: 0;
       cajH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajG() //  [R1]
         { info_tbl: [(cajG,
                       label: block_cajG_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajG: // global
           if (R1 & 7 == 1) goto cajK; else goto cajL;
       cajK: // global
           I64[Sp] = block_cajS_info;
           _s9BH::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _s9BH::I64;
           if (R1 & 7 != 0) goto uani; else goto cajU;
       uani: // global
           call _cajS(R1) args: 0, res: 0, upd: 0;
       cajU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cajL: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cajS() //  [R1]
         { info_tbl: [(cajS,
                       label: block_cajS_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajS: // global
           if (R1 & 7 == 1) goto cak0; else goto cak5;
       cak0: // global
           I64[Sp + 8] = I64[Sp + 8] + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cajD() args: 0, res: 0, upd: 0;
       cak5: // global
           I64[Sp] = block_cak3_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto uank; else goto cak6;
       uank: // global
           call _cak3(R1) args: 0, res: 0, upd: 0;
       cak6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak3() //  [R1]
         { info_tbl: [(cak3,
                       label: block_cak3_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak3: // global
           _s9BE::I64 = I64[Sp + 8];
           _s9BH::I64 = I64[Sp + 16];
           _s9BO::P64 = P64[R1 + 7];
           _s9BP::I64 = _s9BH::I64 >> 56;
           if (_s9BP::I64 != 0) goto caks; else goto cakw;
       caks: // global
           R1 = _s9BE::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BP::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cakw: // global
           _s9BT::I64 = _s9BH::I64 >> 48;
           if (_s9BT::I64 != 0) goto cakR; else goto cakV;
       cakR: // global
           R1 = _s9BE::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BT::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cakV: // global
           _s9BX::I64 = _s9BH::I64 >> 40;
           if (_s9BX::I64 != 0) goto calg; else goto calk;
       calg: // global
           R1 = _s9BE::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BX::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       calk: // global
           _s9C1::I64 = _s9BH::I64 >> 32;
           if (_s9C1::I64 != 0) goto calF; else goto calJ;
       calF: // global
           R1 = _s9BE::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9C1::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       calJ: // global
           _s9C5::I64 = _s9BH::I64 >> 24;
           if (_s9C5::I64 != 0) goto cam4; else goto cam8;
       cam4: // global
           R1 = _s9BE::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9C5::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cam8: // global
           _s9C9::I64 = _s9BH::I64 >> 16;
           if (_s9C9::I64 != 0) goto camt; else goto camx;
       camt: // global
           R1 = _s9BE::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9C9::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       camx: // global
           _s9Cd::I64 = _s9BH::I64 >> 8;
           if (_s9Cd::I64 != 0) goto camS; else goto can8;
       camS: // global
           R1 = _s9BE::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9Cd::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       can8: // global
           R1 = _s9BE::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_s9BO::P64 + 16) + _s9BH::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.956995743 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2#_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2#_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2#_entry() //  [R2]
         { info_tbl: [(caoH,
                       label: GHC.Integer.Logarithms.Internals.integerLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caoH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caoI; else goto caoJ;
       caoI: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caoJ: // global
           I64[Sp - 8] = block_caoA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaoQ; else goto caoB;
       uaoQ: // global
           call _caoA(R1) args: 0, res: 0, upd: 0;
       caoB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caoA() //  [R1]
         { info_tbl: [(caoA,
                       label: block_caoA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caoA: // global
           if (R1 & 7 == 1) goto caoF; else goto caoE;
       caoF: // global
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Logarithms.Internals.integerLog2#_step_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
       caoE: // global
           R1 = (-1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.968352859 UTC

[section ""data" . noPower_r9AI_closure" {
     noPower_r9AI_closure:
         const noPower_r9AI_info;
         const 0;
 },
 noPower_r9AI_entry() //  [R2, R3]
         { info_tbl: [(cape,
                       label: noPower_r9AI_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cape: // global
           if ((Sp + -24) < SpLim) (likely: False) goto capf; else goto uasG;
       capf: // global
           R3 = R3;
           R2 = R2;
           R1 = noPower_r9AI_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uasG: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cap4() args: 0, res: 0, upd: 0;
     }
 },
 _cap4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cap4: // global
           I64[Sp - 8] = block_cap7_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uasI; else goto cap8;
       uasI: // global
           call _cap7(R1) args: 0, res: 0, upd: 0;
       cap8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cap7() //  [R1]
         { info_tbl: [(cap7,
                       label: block_cap7_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cap7: // global
           if (R1 & 7 == 1) goto capb; else goto capc;
       capb: // global
           I64[Sp] = block_capj_info;
           _s9Cq::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _s9Cq::I64;
           if (R1 & 7 != 0) goto uasJ; else goto capl;
       uasJ: // global
           call _capj(R1) args: 0, res: 0, upd: 0;
       capl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       capc: // global
           R2 = 1;
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _capj() //  [R1]
         { info_tbl: [(capj,
                       label: block_capj_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       capj: // global
           if (R1 & 7 == 1) goto capr; else goto capw;
       capr: // global
           I64[Sp + 8] = I64[Sp + 8] + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cap4() args: 0, res: 0, upd: 0;
       capw: // global
           I64[Sp] = block_capu_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto uasL; else goto capx;
       uasL: // global
           call _capu(R1) args: 0, res: 0, upd: 0;
       capx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _capu() //  [R1]
         { info_tbl: [(capu,
                       label: block_capu_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       capu: // global
           _s9Cn::I64 = I64[Sp + 8];
           _s9Cq::I64 = I64[Sp + 16];
           _s9Cx::P64 = P64[R1 + 7];
           _s9Cy::I64 = _s9Cq::I64 >> 56;
           if (_s9Cy::I64 != 0) goto capH; else goto capN;
       capH: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9Cy::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       capN: // global
           _s9CD::I64 = _s9Cq::I64 >> 48;
           if (_s9CD::I64 != 0) goto capW; else goto caq2;
       capW: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CD::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caq2: // global
           _s9CI::I64 = _s9Cq::I64 >> 40;
           if (_s9CI::I64 != 0) goto caqb; else goto caqh;
       caqb: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CI::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caqh: // global
           _s9CN::I64 = _s9Cq::I64 >> 32;
           if (_s9CN::I64 != 0) goto caqq; else goto caqw;
       caqq: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CN::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caqw: // global
           _s9CS::I64 = _s9Cq::I64 >> 24;
           if (_s9CS::I64 != 0) goto caqF; else goto caqL;
       caqF: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CS::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caqL: // global
           _s9CX::I64 = _s9Cq::I64 >> 16;
           if (_s9CX::I64 != 0) goto caqU; else goto car0;
       caqU: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9CX::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       car0: // global
           _s9D2::I64 = _s9Cq::I64 >> 8;
           if (_s9D2::I64 != 0) goto car9; else goto carf;
       car9: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9D2::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       carf: // global
           R2 = 1;
           R1 = _s9Cn::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_s9Cx::P64 + 16) + _s9Cq::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.989139737 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry() //  [R2,
                                                                              R3]
         { info_tbl: [(cau8,
                       label: GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cau9; else goto uayR;
       cau9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uayR: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _catY() args: 0, res: 0, upd: 0;
     }
 },
 _catY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catY: // global
           I64[Sp - 8] = block_cau1_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uayT; else goto cau2;
       uayT: // global
           call _cau1(R1) args: 0, res: 0, upd: 0;
       cau2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau1() //  [R1]
         { info_tbl: [(cau1,
                       label: block_cau1_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau1: // global
           if (R1 & 7 == 1) goto cau5; else goto cau6;
       cau5: // global
           I64[Sp] = block_caud_info;
           _s9De::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _s9De::I64;
           if (R1 & 7 != 0) goto uayU; else goto cauf;
       uayU: // global
           call _caud(R1) args: 0, res: 0, upd: 0;
       cauf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cau6: // global
           R2 = 1;
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _caud() //  [R1]
         { info_tbl: [(caud,
                       label: block_caud_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caud: // global
           if (R1 & 7 == 1) goto caup; else goto cauu;
       caup: // global
           _s9Db::I64 = I64[Sp + 8];
           if (I64[Sp + 16] == 0) goto caun; else goto caum;
       caun: // global
           I64[Sp + 8] = _s9Db::I64 + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _catY() args: 0, res: 0, upd: 0;
       caum: // global
           R3 = R1;
           R2 = _s9Db::I64 + 64;
           Sp = Sp + 24;
           call noPower_r9AI_entry(R3, R2) args: 8, res: 0, upd: 8;
       cauu: // global
           I64[Sp] = block_caus_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto uayW; else goto cauv;
       uayW: // global
           call _caus(R1) args: 0, res: 0, upd: 0;
       cauv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caus() //  [R1]
         { info_tbl: [(caus,
                       label: block_caus_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caus: // global
           _s9Db::I64 = I64[Sp + 8];
           _s9De::I64 = I64[Sp + 16];
           _s9Dn::P64 = P64[R1 + 7];
           _s9Do::I64 = _s9De::I64 >> 56;
           if (_s9Do::I64 != 0) goto cauF; else goto cauL;
       cauF: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9Do::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cauL: // global
           _s9Dw::I64 = _s9De::I64 >> 48;
           if (_s9Dw::I64 != 0) goto cauU; else goto cav0;
       cauU: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9Dw::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cav0: // global
           _s9DE::I64 = _s9De::I64 >> 40;
           if (_s9DE::I64 != 0) goto cav9; else goto cavf;
       cav9: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9DE::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cavf: // global
           _s9DM::I64 = _s9De::I64 >> 32;
           if (_s9DM::I64 != 0) goto cavo; else goto cavu;
       cavo: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9DM::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cavu: // global
           _s9DU::I64 = _s9De::I64 >> 24;
           if (_s9DU::I64 != 0) goto cavD; else goto cavJ;
       cavD: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9DU::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cavJ: // global
           _s9E2::I64 = _s9De::I64 >> 16;
           if (_s9E2::I64 != 0) goto cavS; else goto cavY;
       cavS: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9E2::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cavY: // global
           _s9Ea::I64 = _s9De::I64 >> 8;
           if (_s9Ea::I64 != 0) goto caw7; else goto cawd;
       caw7: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9Ea::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cawd: // global
           R2 = _s9De::I64 & (_s9De::I64 + -1);
           R1 = _s9Db::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_s9Dn::P64 + 16) + _s9De::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.008048013 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_entry() //  [R2]
         { info_tbl: [(caAA,
                       label: GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caAB; else goto caAC;
       caAB: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caAC: // global
           I64[Sp - 8] = block_caAt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaAJ; else goto caAu;
       uaAJ: // global
           call _caAt(R1) args: 0, res: 0, upd: 0;
       caAu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAt() //  [R1]
         { info_tbl: [(caAt,
                       label: block_caAt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAt: // global
           if (R1 & 7 == 1) goto caAy; else goto caAx;
       caAy: // global
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry(R3,
                                                                                      R2) args: 8, res: 0, upd: 8;
       caAx: // global
           R2 = 1;
           R1 = (-1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.015582299 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$trModule4_bytes" {
     GHC.Integer.Logarithms.Internals.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.018041214 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule3_closure" {
     GHC.Integer.Logarithms.Internals.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.020233098 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$trModule2_bytes" {
     GHC.Integer.Logarithms.Internals.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115,46,73,110,116,101,114,110,97,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.023098313 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule1_closure" {
     GHC.Integer.Logarithms.Internals.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.025529428 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule_closure" {
     GHC.Integer.Logarithms.Internals.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule3_closure+1;
         const GHC.Integer.Logarithms.Internals.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.028114113 UTC

[section ""data" . $krep_r9AJ_closure" {
     $krep_r9AJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcByteArray#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.030629521 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$tcBA2_bytes" {
     GHC.Integer.Logarithms.Internals.$tcBA2_bytes:
         I8[] [66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.033679309 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tcBA1_closure" {
     GHC.Integer.Logarithms.Internals.$tcBA1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$tcBA2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.035836865 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tcBA_closure" {
     GHC.Integer.Logarithms.Internals.$tcBA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule_closure+1;
         const GHC.Integer.Logarithms.Internals.$tcBA1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1270308961569198254;
         const 6805106280991229347;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.038256754 UTC

[section ""data" . $krep1_r9AK_closure" {
     $krep1_r9AK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Logarithms.Internals.$tcBA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.040273894 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA1_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r9AJ_closure+1;
         const $krep1_r9AK_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.042973636 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$tc'BA3_bytes" {
     GHC.Integer.Logarithms.Internals.$tc'BA3_bytes:
         I8[] [39,66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.045149965 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA2_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$tc'BA3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.047537769 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule_closure+1;
         const GHC.Integer.Logarithms.Internals.$tc'BA2_closure+1;
         const GHC.Integer.Logarithms.Internals.$tc'BA1_closure+4;
         const 12402798602385785556;
         const 5679508278348334299;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.051097848 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.BA_closure" {
     GHC.Integer.Logarithms.Internals.BA_closure:
         const GHC.Integer.Logarithms.Internals.BA_info;
 },
 GHC.Integer.Logarithms.Internals.BA_entry() //  [R2]
         { info_tbl: [(caBf,
                       label: GHC.Integer.Logarithms.Internals.BA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBj; else goto caBi;
       caBj: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.BA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBi: // global
           I64[Hp - 8] = GHC.Integer.Logarithms.Internals.BA_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.056204486 UTC

[GHC.Integer.Logarithms.Internals.BA_con_entry() //  [R1]
         { info_tbl: [(caBp,
                       label: GHC.Integer.Logarithms.Internals.BA_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115,46,73,110,116,101,114,110,97,108,115,46,66,65]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBp: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:57.061785165 UTC

[section ""relreadonly" . S9Ff_srt" {
     S9Ff_srt:
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Integer.Logarithms.Internals.roundingMode#_closure;
         const GHC.Integer.Logarithms.Internals.wordLog2#_closure;
         const GHC.Integer.Logarithms.Internals.leadingZeros_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_closure;
         const noPower_r9AI_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.096006993 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:53:58.098728166 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.roundingMode#_closure" {
     GHC.Integer.Logarithms.Internals.roundingMode#_closure:
         const GHC.Integer.Logarithms.Internals.roundingMode#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.roundingMode#_entry() //  [R2, R3]
         { info_tbl: [(caFi,
                       label: GHC.Integer.Logarithms.Internals.roundingMode#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caFu; else goto caFv;
       caFu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.roundingMode#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caFv: // global
           I64[Sp - 16] = block_caFg_info;
           R3 = R3;
           _saBw::P64 = R2;
           R2 = GHC.Integer.Type.oneInteger_closure;
           P64[Sp - 8] = _saBw::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _caFg() //  [R1]
         { info_tbl: [(caFg,
                       label: block_caFg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFg: // global
           I64[Sp - 8] = block_caFl_info;
           R3 = R1;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _caFl() //  [R1]
         { info_tbl: [(caFl,
                       label: block_caFl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFl: // global
           I64[Sp] = block_caFp_info;
           R3 = GHC.Integer.Type.oneInteger_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _caFp() //  [R1]
         { info_tbl: [(caFp,
                       label: block_caFp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFp: // global
           I64[Sp] = block_caFt_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _caFt() //  [R1]
         { info_tbl: [(caFt,
                       label: block_caFt_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFt: // global
           I64[Sp] = block_caFC_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _caFC() //  [R1]
         { info_tbl: [(caFC,
                       label: block_caFC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFC: // global
           if (R1 == 1) goto caFY; else goto caFK;
       caFY: // global
           R1 = 2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caFK: // global
           _saBz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caFH_info;
           R3 = _saBz::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _caFH() //  [R1]
         { info_tbl: [(caFH,
                       label: block_caFH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFH: // global
           if (R1 == 1) goto caFU; else goto caFQ;
       caFU: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caFQ: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.115926087 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.leadingZeros_closure" {
     GHC.Integer.Logarithms.Internals.leadingZeros_closure:
         const GHC.Integer.Logarithms.Internals.leadingZeros_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.leadingZeros_entry() //  [R1]
         { info_tbl: [(caGI,
                       label: GHC.Integer.Logarithms.Internals.leadingZeros_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caGJ; else goto caGK;
       caGJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caGK: // global
           (_caGz::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caGz::I64 == 0) goto caGB; else goto caGA;
       caGB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caGA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caGz::I64;
           I64[Sp - 24] = block_caGC_info;
           R1 = 256;
           Sp = Sp - 24;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caGC() //  [R1]
         { info_tbl: [(caGC,
                       label: block_caGC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGC: // global
           I8[R1 + 16] = 9 :: W8;
           _saBG::P64 = R1;
           _saBQ::I64 = 1;
           _saBP::I64 = 8;
           _saBO::I64 = 2;
           goto caGT;
       caGT: // global
           if (_saBQ::I64 == 256) goto uaHe; else goto caH5;
       uaHe: // global
           P64[Sp] = _saBG::P64;
           Sp = Sp - 8;
           call _caGN() args: 0, res: 0, upd: 0;
       caH5: // global
           if (%MO_S_Ge_W64(_saBQ::I64,
                            _saBO::I64)) goto caH2; else goto caH3;
       caH2: // global
           _saBQ::I64 = _saBQ::I64;
           _saBP::I64 = _saBP::I64 - 1;
           _saBO::I64 = _saBO::I64 << 1;
           goto caGT;
       caH3: // global
           I8[(_saBG::P64 + 16) + _saBQ::I64] = %MO_UU_Conv_W64_W8(_saBP::I64);
           _saBQ::I64 = _saBQ::I64 + 1;
           goto caGT;
     }
 },
 _caGN() //  []
         { info_tbl: [(caGN,
                       label: block_caGN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGS; else goto caGR;
       caGS: // global
           HpAlloc = 16;
           I64[Sp] = block_caGN_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       caGR: // global
           I64[Hp - 8] = GHC.Integer.Logarithms.Internals.BA_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.127011809 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.wordLog2#_closure" {
     GHC.Integer.Logarithms.Internals.wordLog2#_closure:
         const GHC.Integer.Logarithms.Internals.wordLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.wordLog2#_entry() //  [R2]
         { info_tbl: [(caHI,
                       label: GHC.Integer.Logarithms.Internals.wordLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caHJ; else goto caHK;
       caHJ: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.wordLog2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHK: // global
           I64[Sp - 16] = block_caHF_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaKp; else goto caHG;
       uaKp: // global
           call _caHF(R1) args: 0, res: 0, upd: 0;
       caHG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHF() //  [R1]
         { info_tbl: [(caHF,
                       label: block_caHF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHF: // global
           _saBY::I64 = I64[Sp + 8];
           _saC0::P64 = P64[R1 + 7];
           _saC1::I64 = _saBY::I64 >> 56;
           if (_saC1::I64 != 0) goto caI2; else goto caI6;
       caI2: // global
           R1 = 64 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saC1::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caI6: // global
           _saC4::I64 = _saBY::I64 >> 48;
           if (_saC4::I64 != 0) goto caIo; else goto caIs;
       caIo: // global
           R1 = 56 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saC4::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caIs: // global
           _saC7::I64 = _saBY::I64 >> 40;
           if (_saC7::I64 != 0) goto caIK; else goto caIO;
       caIK: // global
           R1 = 48 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saC7::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caIO: // global
           _saCa::I64 = _saBY::I64 >> 32;
           if (_saCa::I64 != 0) goto caJ6; else goto caJa;
       caJ6: // global
           R1 = 40 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saCa::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caJa: // global
           _saCd::I64 = _saBY::I64 >> 24;
           if (_saCd::I64 != 0) goto caJs; else goto caJw;
       caJs: // global
           R1 = 32 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saCd::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caJw: // global
           _saCg::I64 = _saBY::I64 >> 16;
           if (_saCg::I64 != 0) goto caJO; else goto caJS;
       caJO: // global
           R1 = 24 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saCg::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caJS: // global
           _saCj::I64 = _saBY::I64 >> 8;
           if (_saCj::I64 != 0) goto caKa; else goto caKn;
       caKa: // global
           R1 = 16 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saCj::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caKn: // global
           R1 = 8 - %MO_SS_Conv_W8_W64(I8[(_saC0::P64 + 16) + _saBY::I64]);
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.140113984 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2#_step_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2#_step_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2#_step_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(caLh,
                       label: GHC.Integer.Logarithms.Internals.integerLog2#_step_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caLh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caLi; else goto uaOJ;
       caLi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2#_step_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uaOJ: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _caL7() args: 0, res: 0, upd: 0;
     }
 },
 _caL7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caL7: // global
           I64[Sp - 8] = block_caLa_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOL; else goto caLb;
       uaOL: // global
           call _caLa(R1) args: 0, res: 0, upd: 0;
       caLb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caLa() //  [R1]
         { info_tbl: [(caLa,
                       label: block_caLa_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caLa: // global
           if (R1 & 7 == 1) goto caLe; else goto caLf;
       caLe: // global
           I64[Sp] = block_caLm_info;
           _saCr::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _saCr::I64;
           if (R1 & 7 != 0) goto uaOM; else goto caLo;
       uaOM: // global
           call _caLm(R1) args: 0, res: 0, upd: 0;
       caLo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caLf: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caLm() //  [R1]
         { info_tbl: [(caLm,
                       label: block_caLm_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caLm: // global
           if (R1 & 7 == 1) goto caLu; else goto caLz;
       caLu: // global
           I64[Sp + 8] = I64[Sp + 8] + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caL7() args: 0, res: 0, upd: 0;
       caLz: // global
           I64[Sp] = block_caLx_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto uaOO; else goto caLA;
       uaOO: // global
           call _caLx(R1) args: 0, res: 0, upd: 0;
       caLA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caLx() //  [R1]
         { info_tbl: [(caLx,
                       label: block_caLx_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caLx: // global
           _saCo::I64 = I64[Sp + 8];
           _saCr::I64 = I64[Sp + 16];
           _saCy::P64 = P64[R1 + 7];
           _saCz::I64 = _saCr::I64 >> 56;
           if (_saCz::I64 != 0) goto caLW; else goto caM0;
       caLW: // global
           R1 = _saCo::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCz::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caM0: // global
           _saCD::I64 = _saCr::I64 >> 48;
           if (_saCD::I64 != 0) goto caMl; else goto caMp;
       caMl: // global
           R1 = _saCo::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCD::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMp: // global
           _saCH::I64 = _saCr::I64 >> 40;
           if (_saCH::I64 != 0) goto caMK; else goto caMO;
       caMK: // global
           R1 = _saCo::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCH::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMO: // global
           _saCL::I64 = _saCr::I64 >> 32;
           if (_saCL::I64 != 0) goto caN9; else goto caNd;
       caN9: // global
           R1 = _saCo::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCL::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNd: // global
           _saCP::I64 = _saCr::I64 >> 24;
           if (_saCP::I64 != 0) goto caNy; else goto caNC;
       caNy: // global
           R1 = _saCo::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCP::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNC: // global
           _saCT::I64 = _saCr::I64 >> 16;
           if (_saCT::I64 != 0) goto caNX; else goto caO1;
       caNX: // global
           R1 = _saCo::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCT::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caO1: // global
           _saCX::I64 = _saCr::I64 >> 8;
           if (_saCX::I64 != 0) goto caOm; else goto caOC;
       caOm: // global
           R1 = _saCo::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCX::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caOC: // global
           R1 = _saCo::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_saCy::P64 + 16) + _saCr::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.16098811 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2#_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2#_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2#_entry() //  [R2]
         { info_tbl: [(caQe,
                       label: GHC.Integer.Logarithms.Internals.integerLog2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caQf; else goto caQg;
       caQf: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQg: // global
           I64[Sp - 8] = block_caQ7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQn; else goto caQ8;
       uaQn: // global
           call _caQ7(R1) args: 0, res: 0, upd: 0;
       caQ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ7() //  [R1]
         { info_tbl: [(caQ7,
                       label: block_caQ7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ7: // global
           if (R1 & 7 == 1) goto caQc; else goto caQb;
       caQc: // global
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Logarithms.Internals.integerLog2#_step_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
       caQb: // global
           R1 = (-1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.171024286 UTC

[section ""data" . noPower_r9AI_closure" {
     noPower_r9AI_closure:
         const noPower_r9AI_info;
         const 0;
 },
 noPower_r9AI_entry() //  [R2, R3]
         { info_tbl: [(caQM,
                       label: noPower_r9AI_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caQN; else goto uaUe;
       caQN: // global
           R3 = R3;
           R2 = R2;
           R1 = noPower_r9AI_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uaUe: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _caQC() args: 0, res: 0, upd: 0;
     }
 },
 _caQC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQC: // global
           I64[Sp - 8] = block_caQF_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaUg; else goto caQG;
       uaUg: // global
           call _caQF(R1) args: 0, res: 0, upd: 0;
       caQG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQF() //  [R1]
         { info_tbl: [(caQF,
                       label: block_caQF_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQF: // global
           if (R1 & 7 == 1) goto caQJ; else goto caQK;
       caQJ: // global
           I64[Sp] = block_caQR_info;
           _saDa::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _saDa::I64;
           if (R1 & 7 != 0) goto uaUh; else goto caQT;
       uaUh: // global
           call _caQR(R1) args: 0, res: 0, upd: 0;
       caQT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caQK: // global
           R2 = 1;
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _caQR() //  [R1]
         { info_tbl: [(caQR,
                       label: block_caQR_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQR: // global
           if (R1 & 7 == 1) goto caQZ; else goto caR4;
       caQZ: // global
           I64[Sp + 8] = I64[Sp + 8] + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caQC() args: 0, res: 0, upd: 0;
       caR4: // global
           I64[Sp] = block_caR2_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto uaUj; else goto caR5;
       uaUj: // global
           call _caR2(R1) args: 0, res: 0, upd: 0;
       caR5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caR2() //  [R1]
         { info_tbl: [(caR2,
                       label: block_caR2_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caR2: // global
           _saD7::I64 = I64[Sp + 8];
           _saDa::I64 = I64[Sp + 16];
           _saDh::P64 = P64[R1 + 7];
           _saDi::I64 = _saDa::I64 >> 56;
           if (_saDi::I64 != 0) goto caRf; else goto caRl;
       caRf: // global
           R2 = 1;
           R1 = _saD7::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDi::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caRl: // global
           _saDn::I64 = _saDa::I64 >> 48;
           if (_saDn::I64 != 0) goto caRu; else goto caRA;
       caRu: // global
           R2 = 1;
           R1 = _saD7::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDn::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caRA: // global
           _saDs::I64 = _saDa::I64 >> 40;
           if (_saDs::I64 != 0) goto caRJ; else goto caRP;
       caRJ: // global
           R2 = 1;
           R1 = _saD7::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDs::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caRP: // global
           _saDx::I64 = _saDa::I64 >> 32;
           if (_saDx::I64 != 0) goto caRY; else goto caS4;
       caRY: // global
           R2 = 1;
           R1 = _saD7::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDx::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caS4: // global
           _saDC::I64 = _saDa::I64 >> 24;
           if (_saDC::I64 != 0) goto caSd; else goto caSj;
       caSd: // global
           R2 = 1;
           R1 = _saD7::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDC::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caSj: // global
           _saDH::I64 = _saDa::I64 >> 16;
           if (_saDH::I64 != 0) goto caSs; else goto caSy;
       caSs: // global
           R2 = 1;
           R1 = _saD7::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDH::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caSy: // global
           _saDM::I64 = _saDa::I64 >> 8;
           if (_saDM::I64 != 0) goto caSH; else goto caSN;
       caSH: // global
           R2 = 1;
           R1 = _saD7::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDM::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caSN: // global
           R2 = 1;
           R1 = _saD7::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_saDh::P64 + 16) + _saDa::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.195744926 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry() //  [R2,
                                                                              R3]
         { info_tbl: [(caVJ,
                       label: GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caVJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caVK; else goto ub0s;
       caVK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ub0s: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _caVz() args: 0, res: 0, upd: 0;
     }
 },
 _caVz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caVz: // global
           I64[Sp - 8] = block_caVC_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub0u; else goto caVD;
       ub0u: // global
           call _caVC(R1) args: 0, res: 0, upd: 0;
       caVD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caVC() //  [R1]
         { info_tbl: [(caVC,
                       label: block_caVC_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caVC: // global
           if (R1 & 7 == 1) goto caVG; else goto caVH;
       caVG: // global
           I64[Sp] = block_caVO_info;
           _saDY::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 16] = _saDY::I64;
           if (R1 & 7 != 0) goto ub0v; else goto caVQ;
       ub0v: // global
           call _caVO(R1) args: 0, res: 0, upd: 0;
       caVQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caVH: // global
           R2 = 1;
           R1 = I64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _caVO() //  [R1]
         { info_tbl: [(caVO,
                       label: block_caVO_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caVO: // global
           if (R1 & 7 == 1) goto caW0; else goto caW5;
       caW0: // global
           _saDV::I64 = I64[Sp + 8];
           if (I64[Sp + 16] == 0) goto caVY; else goto caVX;
       caVY: // global
           I64[Sp + 8] = _saDV::I64 + 64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caVz() args: 0, res: 0, upd: 0;
       caVX: // global
           R3 = R1;
           R2 = _saDV::I64 + 64;
           Sp = Sp + 24;
           call noPower_r9AI_entry(R3, R2) args: 8, res: 0, upd: 8;
       caW5: // global
           I64[Sp] = block_caW3_info;
           R1 = GHC.Integer.Logarithms.Internals.leadingZeros_closure;
           if (R1 & 7 != 0) goto ub0x; else goto caW6;
       ub0x: // global
           call _caW3(R1) args: 0, res: 0, upd: 0;
       caW6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caW3() //  [R1]
         { info_tbl: [(caW3,
                       label: block_caW3_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caW3: // global
           _saDV::I64 = I64[Sp + 8];
           _saDY::I64 = I64[Sp + 16];
           _saE7::P64 = P64[R1 + 7];
           _saE8::I64 = _saDY::I64 >> 56;
           if (_saE8::I64 != 0) goto caWg; else goto caWm;
       caWg: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (64 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saE8::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caWm: // global
           _saEg::I64 = _saDY::I64 >> 48;
           if (_saEg::I64 != 0) goto caWv; else goto caWB;
       caWv: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (56 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saEg::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caWB: // global
           _saEo::I64 = _saDY::I64 >> 40;
           if (_saEo::I64 != 0) goto caWK; else goto caWQ;
       caWK: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (48 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saEo::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caWQ: // global
           _saEw::I64 = _saDY::I64 >> 32;
           if (_saEw::I64 != 0) goto caWZ; else goto caX5;
       caWZ: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (40 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saEw::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caX5: // global
           _saEE::I64 = _saDY::I64 >> 24;
           if (_saEE::I64 != 0) goto caXe; else goto caXk;
       caXe: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (32 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saEE::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caXk: // global
           _saEM::I64 = _saDY::I64 >> 16;
           if (_saEM::I64 != 0) goto caXt; else goto caXz;
       caXt: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (24 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saEM::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caXz: // global
           _saEU::I64 = _saDY::I64 >> 8;
           if (_saEU::I64 != 0) goto caXI; else goto caXO;
       caXI: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (16 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saEU::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caXO: // global
           R2 = _saDY::I64 & (_saDY::I64 + -1);
           R1 = _saDV::I64 + (8 - %MO_SS_Conv_W8_W64(I8[(_saE7::P64 + 16) + _saDY::I64]));
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.217690597 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure" {
     GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure:
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info;
         const 0;
 },
 GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_entry() //  [R2]
         { info_tbl: [(cb2e,
                       label: GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb2e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb2f; else goto cb2g;
       cb2f: // global
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb2g: // global
           I64[Sp - 8] = block_cb27_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub2n; else goto cb28;
       ub2n: // global
           call _cb27(R1) args: 0, res: 0, upd: 0;
       cb28: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb27() //  [R1]
         { info_tbl: [(cb27,
                       label: block_cb27_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb27: // global
           if (R1 & 7 == 1) goto cb2c; else goto cb2b;
       cb2c: // global
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_entry(R3,
                                                                                      R2) args: 8, res: 0, upd: 8;
       cb2b: // global
           R2 = 1;
           R1 = (-1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.226494524 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$trModule4_bytes" {
     GHC.Integer.Logarithms.Internals.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.22854901 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule3_closure" {
     GHC.Integer.Logarithms.Internals.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.230810672 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$trModule2_bytes" {
     GHC.Integer.Logarithms.Internals.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115,46,73,110,116,101,114,110,97,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.232841187 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule1_closure" {
     GHC.Integer.Logarithms.Internals.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.234965262 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$trModule_closure" {
     GHC.Integer.Logarithms.Internals.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule3_closure+1;
         const GHC.Integer.Logarithms.Internals.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.237202239 UTC

[section ""data" . $krep_r9AJ_closure" {
     $krep_r9AJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcByteArray#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.239638943 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$tcBA2_bytes" {
     GHC.Integer.Logarithms.Internals.$tcBA2_bytes:
         I8[] [66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.24194667 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tcBA1_closure" {
     GHC.Integer.Logarithms.Internals.$tcBA1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$tcBA2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.244122822 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tcBA_closure" {
     GHC.Integer.Logarithms.Internals.$tcBA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule_closure+1;
         const GHC.Integer.Logarithms.Internals.$tcBA1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1270308961569198254;
         const 6805106280991229347;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.246524058 UTC

[section ""data" . $krep1_r9AK_closure" {
     $krep1_r9AK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Logarithms.Internals.$tcBA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.248737539 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA1_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r9AJ_closure+1;
         const $krep1_r9AK_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.251138903 UTC

[section ""cstring" . GHC.Integer.Logarithms.Internals.$tc'BA3_bytes" {
     GHC.Integer.Logarithms.Internals.$tc'BA3_bytes:
         I8[] [39,66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.253104842 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA2_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Logarithms.Internals.$tc'BA3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.255509206 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.$tc'BA_closure" {
     GHC.Integer.Logarithms.Internals.$tc'BA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Logarithms.Internals.$trModule_closure+1;
         const GHC.Integer.Logarithms.Internals.$tc'BA2_closure+1;
         const GHC.Integer.Logarithms.Internals.$tc'BA1_closure+4;
         const 12402798602385785556;
         const 5679508278348334299;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.258640656 UTC

[section ""data" . GHC.Integer.Logarithms.Internals.BA_closure" {
     GHC.Integer.Logarithms.Internals.BA_closure:
         const GHC.Integer.Logarithms.Internals.BA_info;
 },
 GHC.Integer.Logarithms.Internals.BA_entry() //  [R2]
         { info_tbl: [(cb2U,
                       label: GHC.Integer.Logarithms.Internals.BA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb2U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb2Y; else goto cb2X;
       cb2Y: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Logarithms.Internals.BA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb2X: // global
           I64[Hp - 8] = GHC.Integer.Logarithms.Internals.BA_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.264103158 UTC

[GHC.Integer.Logarithms.Internals.BA_con_entry() //  [R1]
         { info_tbl: [(cb35,
                       label: GHC.Integer.Logarithms.Internals.BA_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,76,111,103,97,114,105,116,104,109,115,46,73,110,116,101,114,110,97,108,115,46,66,65]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb35: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:58.268970981 UTC

[section ""relreadonly" . SaFZ_srt" {
     SaFZ_srt:
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Integer.Logarithms.Internals.roundingMode#_closure;
         const GHC.Integer.Logarithms.Internals.wordLog2#_closure;
         const GHC.Integer.Logarithms.Internals.leadingZeros_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_step_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2#_closure;
         const noPower_r9AI_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_couldBe_closure;
         const GHC.Integer.Logarithms.Internals.integerLog2IsPowerOf2#_closure;
 }]

