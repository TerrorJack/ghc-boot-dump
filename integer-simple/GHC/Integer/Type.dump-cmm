
==================== Output Cmm ====================
2018-03-16 15:53:48.973989633 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:53:48.9752581 UTC

[section ""data" . GHC.Integer.Type.$WPositive_closure" {
     GHC.Integer.Type.$WPositive_closure:
         const GHC.Integer.Type.$WPositive_info;
 },
 GHC.Integer.Type.$WPositive_entry() //  [R2]
         { info_tbl: [(c3NS,
                       label: GHC.Integer.Type.$WPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3NS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c3NW; else goto c3NX;
       c3NW: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$WPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3NX: // global
           I64[Sp - 8] = block_c3NP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u3O1; else goto c3NQ;
       u3O1: // global
           call _c3NP(R1) args: 0, res: 0, upd: 0;
       c3NQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3NP() //  [R1]
         { info_tbl: [(c3NP,
                       label: block_c3NP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3NP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c3O0; else goto c3NZ;
       c3O0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3NZ: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.976759137 UTC

[section ""data" . GHC.Integer.Type.$WNegative_closure" {
     GHC.Integer.Type.$WNegative_closure:
         const GHC.Integer.Type.$WNegative_info;
 },
 GHC.Integer.Type.$WNegative_entry() //  [R2]
         { info_tbl: [(c3O9,
                       label: GHC.Integer.Type.$WNegative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3O9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c3Od; else goto c3Oe;
       c3Od: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$WNegative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3Oe: // global
           I64[Sp - 8] = block_c3O6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u3Oi; else goto c3O7;
       u3Oi: // global
           call _c3O6(R1) args: 0, res: 0, upd: 0;
       c3O7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3O6() //  [R1]
         { info_tbl: [(c3O6,
                       label: block_c3O6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3O6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c3Oh; else goto c3Og;
       c3Oh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3Og: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.979168964 UTC

[section ""data" . GHC.Integer.Type.$WSome_closure" {
     GHC.Integer.Type.$WSome_closure:
         const GHC.Integer.Type.$WSome_info;
 },
 GHC.Integer.Type.$WSome_entry() //  [R2, R3]
         { info_tbl: [(c3Oq,
                       label: GHC.Integer.Type.$WSome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Oq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c3Ou; else goto c3Ov;
       c3Ou: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$WSome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c3Ov: // global
           I64[Sp - 16] = block_c3On_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3Oz; else goto c3Oo;
       u3Oz: // global
           call _c3On(R1) args: 0, res: 0, upd: 0;
       c3Oo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3On() //  [R1]
         { info_tbl: [(c3On,
                       label: block_c3On_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3On: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3Oy; else goto c3Ox;
       c3Oy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3Ox: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.980344626 UTC

[section ""data" . GHC.Integer.Type.errorPositive_closure" {
     GHC.Integer.Type.errorPositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 47;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.981064849 UTC

[section ""data" . GHC.Integer.Type.errorInteger_closure" {
     GHC.Integer.Type.errorInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.errorPositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.982423856 UTC

[section ""data" . GHC.Integer.Type.wordToInteger_closure" {
     GHC.Integer.Type.wordToInteger_closure:
         const GHC.Integer.Type.wordToInteger_info;
 },
 GHC.Integer.Type.wordToInteger_entry() //  [R2]
         { info_tbl: [(c3OI,
                       label: GHC.Integer.Type.wordToInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3OI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c3OM; else goto c3OL;
       c3OM: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Integer.Type.wordToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3OL: // global
           if (R2 == 0) goto c3OH; else goto c3OG;
       c3OH: // global
           Hp = Hp - 40;
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c3OG: // global
           I64[Hp - 32] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 24] = GHC.Integer.Type.None_closure+2;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.984058961 UTC

[section ""data" . GHC.Integer.Type.integerToWord_closure" {
     GHC.Integer.Type.integerToWord_closure:
         const GHC.Integer.Type.integerToWord_info;
 },
 GHC.Integer.Type.integerToWord_entry() //  [R2]
         { info_tbl: [(c3P2,
                       label: GHC.Integer.Type.integerToWord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3P2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c3P3; else goto c3P4;
       c3P3: // global
           R2 = R2;
           R1 = GHC.Integer.Type.integerToWord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3P4: // global
           I64[Sp - 8] = block_c3OU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u3PM; else goto c3OV;
       u3PM: // global
           call _c3OU(R1) args: 0, res: 0, upd: 0;
       c3OV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3OU() //  [R1]
         { info_tbl: [(c3OU,
                       label: block_c3OU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3OU: // global
           _c3P1::P64 = R1 & 7;
           if (_c3P1::P64 < 3) goto u3PF; else goto u3PG;
       u3PF: // global
           if (_c3P1::P64 < 2) goto c3OY; else goto c3OZ;
       c3OY: // global
           I64[Sp] = block_c3P7_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u3PJ; else goto c3P9;
       u3PJ: // global
           call _c3P7(R1) args: 0, res: 0, upd: 0;
       c3P9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c3OZ: // global
           I64[Sp] = block_c3Pm_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u3PK; else goto c3Po;
       u3PK: // global
           call _c3Pm(R1) args: 0, res: 0, upd: 0;
       c3Po: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u3PG: // global
           Sp = Sp + 8;
           call _c3P0() args: 0, res: 0, upd: 0;
     }
 },
 _c3P7() //  [R1]
         { info_tbl: [(c3P7,
                       label: block_c3P7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3P7: // global
           if (R1 & 7 == 1) goto c3Pf; else goto u3PH;
       c3Pf: // global
           R1 = I64[R1 + 15];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u3PH: // global
           Sp = Sp + 8;
           call _c3P0() args: 0, res: 0, upd: 0;
     }
 },
 _c3Pm() //  [R1]
         { info_tbl: [(c3Pm,
                       label: block_c3Pm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Pm: // global
           if (R1 & 7 == 1) goto c3Pv; else goto u3PI;
       c3Pv: // global
           R1 = 0 - I64[R1 + 15];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u3PI: // global
           Sp = Sp + 8;
           call _c3P0() args: 0, res: 0, upd: 0;
     }
 },
 _c3P0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3P0: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.986087475 UTC

[section ""data" . GHC.Integer.Type.integerToInt_closure" {
     GHC.Integer.Type.integerToInt_closure:
         const GHC.Integer.Type.integerToInt_info;
 },
 GHC.Integer.Type.integerToInt_entry() //  [R2]
         { info_tbl: [(c3PV,
                       label: GHC.Integer.Type.integerToInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3PV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c3PZ; else goto c3Q0;
       c3PZ: // global
           R2 = R2;
           R1 = GHC.Integer.Type.integerToInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3Q0: // global
           I64[Sp - 8] = block_c3PT_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c3PT() //  [R1]
         { info_tbl: [(c3PT,
                       label: block_c3PT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3PT: // global
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.987456631 UTC

[section ""data" . GHC.Integer.Type.hashInteger_closure" {
     GHC.Integer.Type.hashInteger_closure:
         const GHC.Integer.Type.hashInteger_info;
 },
 GHC.Integer.Type.hashInteger_entry() //  [R2]
         { info_tbl: [(c3Q6,
                       label: GHC.Integer.Type.hashInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Q6: // global
           R2 = R2;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.988626045 UTC

[section ""data" . GHC.Integer.Type.flipBitsDigits_closure" {
     GHC.Integer.Type.flipBitsDigits_closure:
         const GHC.Integer.Type.flipBitsDigits_info;
 },
 GHC.Integer.Type.flipBitsDigits_entry() //  [R2]
         { info_tbl: [(c3Qk,
                       label: GHC.Integer.Type.flipBitsDigits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Qk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c3Ql; else goto c3Qm;
       c3Ql: // global
           R2 = R2;
           R1 = GHC.Integer.Type.flipBitsDigits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3Qm: // global
           I64[Sp - 8] = block_c3Qd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u3QE; else goto c3Qe;
       u3QE: // global
           call _c3Qd(R1) args: 0, res: 0, upd: 0;
       c3Qe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3Qd() //  [R1]
         { info_tbl: [(c3Qd,
                       label: block_c3Qd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Qd: // global
           if (R1 & 7 == 1) goto c3Qh; else goto c3Qi;
       c3Qh: // global
           I64[Sp - 8] = block_c3Qp_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
       c3Qi: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c3Qp() //  [R1]
         { info_tbl: [(c3Qp,
                       label: block_c3Qp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Qp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3QA; else goto c3Qz;
       c3QA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3Qz: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = ~I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.990204907 UTC

[section ""data" . GHC.Integer.Type.flipBits1_closure" {
     GHC.Integer.Type.flipBits1_closure:
         const GHC.Integer.Type.flipBits1_info;
 },
 GHC.Integer.Type.flipBits1_entry() //  [R2]
         { info_tbl: [(c3QJ,
                       label: GHC.Integer.Type.flipBits1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3QJ: // global
           R2 = R2;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.991454958 UTC

[section ""data" . GHC.Integer.Type.flipBits_closure" {
     GHC.Integer.Type.flipBits_closure:
         const GHC.Integer.Type.flipBits_info;
 },
 GHC.Integer.Type.flipBits_entry() //  [R2]
         { info_tbl: [(c3QQ,
                       label: GHC.Integer.Type.flipBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3QQ: // global
           R2 = R2;
           call GHC.Integer.Type.flipBits1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.992698418 UTC

[section ""data" . GHC.Integer.Type.negateInteger_closure" {
     GHC.Integer.Type.negateInteger_closure:
         const GHC.Integer.Type.negateInteger_info;
 },
 GHC.Integer.Type.negateInteger_entry() //  [R2]
         { info_tbl: [(c3R5,
                       label: GHC.Integer.Type.negateInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3R5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c3R6; else goto c3R7;
       c3R6: // global
           R2 = R2;
           R1 = GHC.Integer.Type.negateInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3R7: // global
           I64[Sp - 8] = block_c3QX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u3Ro; else goto c3QY;
       u3Ro: // global
           call _c3QX(R1) args: 0, res: 0, upd: 0;
       c3QY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3QX() //  [R1]
         { info_tbl: [(c3QX,
                       label: block_c3QX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3QX: // global
           _c3R4::P64 = R1 & 7;
           if (_c3R4::P64 < 3) goto u3Rn; else goto c3R3;
       u3Rn: // global
           if (_c3R4::P64 < 2) goto c3R1; else goto c3R2;
       c3R1: // global
           Hp = Hp + 16;
           _s3C2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c3Rj; else goto c3Rc;
       c3Rc: // global
           _s3C3::P64 = P64[_s3C2::P64 + 7];
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = _s3C3::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c3R2: // global
           Hp = Hp + 16;
           _s3C2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c3Rj; else goto c3Ri;
       c3Rj: // global
           HpAlloc = 16;
           R1 = _s3C2::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3Ri: // global
           _s3C4::P64 = P64[_s3C2::P64 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3C4::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c3R3: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.994467495 UTC

[section ""data" . GHC.Integer.Type.smallInteger_closure" {
     GHC.Integer.Type.smallInteger_closure:
         const GHC.Integer.Type.smallInteger_info;
 },
 GHC.Integer.Type.smallInteger_entry() //  [R2]
         { info_tbl: [(c3Ry,
                       label: GHC.Integer.Type.smallInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Ry: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c3Rz; else goto c3RA;
       c3Rz: // global
           R2 = R2;
           R1 = GHC.Integer.Type.smallInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3RA: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c3Rw; else goto c3Rx;
       c3Rw: // global
           I64[Sp - 8] = block_c3RI_info;
           R2 = -R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c3Rx: // global
           R2 = R2;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c3RI() //  [R1]
         { info_tbl: [(c3RI,
                       label: block_c3RI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3RI: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.996266056 UTC

[section ""data" . GHC.Integer.Type.decodeFloatInteger_closure" {
     GHC.Integer.Type.decodeFloatInteger_closure:
         const GHC.Integer.Type.decodeFloatInteger_info;
 },
 sat_s3Cf_entry() //  [R1]
         { info_tbl: [(c3S1,
                       label: sat_s3Cf_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3S1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c3S2; else goto c3S3;
       c3S2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3S3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.decodeFloatInteger_entry() //  [F1]
         { info_tbl: [(c3S4,
                       label: GHC.Integer.Type.decodeFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 6} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3S4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c3S5; else goto c3S6;
       c3S5: // global
           F1 = F1;
           R1 = GHC.Integer.Type.decodeFloatInteger_closure;
           call (stg_gc_fun)(F1, R1) args: 8, res: 0, upd: 8;
       c3S6: // global
           I64[Sp - 8] = block_c3RT_info;
           F1 = F1;
           Sp = Sp - 8;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _c3RT() //  [R1, R2]
         { info_tbl: [(c3RT,
                       label: block_c3RT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3RT: // global
           I64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c3RU() args: 0, res: 0, upd: 0;
     }
 },
 _c3RU() //  []
         { info_tbl: [(c3RU,
                       label: block_c3RU_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3RU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3S9; else goto c3S8;
       c3S9: // global
           HpAlloc = 24;
           I64[Sp] = block_c3RU_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c3S8: // global
           I64[Hp - 16] = sat_s3Cf_info;
           I64[Hp] = I64[Sp + 16];
           R2 = I64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.998302197 UTC

[section ""data" . GHC.Integer.Type.absInteger_closure" {
     GHC.Integer.Type.absInteger_closure:
         const GHC.Integer.Type.absInteger_info;
 },
 GHC.Integer.Type.absInteger_entry() //  [R2]
         { info_tbl: [(c3Sn,
                       label: GHC.Integer.Type.absInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Sn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c3So; else goto c3Sp;
       c3So: // global
           R2 = R2;
           R1 = GHC.Integer.Type.absInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3Sp: // global
           I64[Sp - 8] = block_c3Sg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u3Sz; else goto c3Sh;
       u3Sz: // global
           call _c3Sg(R1) args: 0, res: 0, upd: 0;
       c3Sh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3Sg() //  [R1]
         { info_tbl: [(c3Sg,
                       label: block_c3Sg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Sg: // global
           if (R1 & 7 == 2) goto c3Sl; else goto c3Sk;
       c3Sl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c3Sy; else goto c3Sx;
       c3Sy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3Sx: // global
           _s3Ci::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3Ci::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c3Sk: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:48.999600277 UTC

[section ""data" . GHC.Integer.Type.onePositive_closure" {
     GHC.Integer.Type.onePositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.000656424 UTC

[section ""data" . GHC.Integer.Type.negativeOneInteger_closure" {
     GHC.Integer.Type.negativeOneInteger_closure:
         const GHC.Integer.Type.Negative_con_info;
         const GHC.Integer.Type.onePositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.001349913 UTC

[section ""data" . GHC.Integer.Type.oneInteger_closure" {
     GHC.Integer.Type.oneInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.onePositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.002382434 UTC

[section ""data" . GHC.Integer.Type.signumInteger_closure" {
     GHC.Integer.Type.signumInteger_closure:
         const GHC.Integer.Type.signumInteger_info;
 },
 GHC.Integer.Type.signumInteger_entry() //  [R2]
         { info_tbl: [(c3SM,
                       label: GHC.Integer.Type.signumInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3SM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c3SN; else goto c3SO;
       c3SN: // global
           R2 = R2;
           R1 = GHC.Integer.Type.signumInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3SO: // global
           I64[Sp - 8] = block_c3SE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u3SZ; else goto c3SF;
       u3SZ: // global
           call _c3SE(R1) args: 0, res: 0, upd: 0;
       c3SF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3SE() //  [R1]
         { info_tbl: [(c3SE,
                       label: block_c3SE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3SE: // global
           _c3SL::P64 = R1 & 7;
           if (_c3SL::P64 < 3) goto u3SY; else goto c3SK;
       u3SY: // global
           if (_c3SL::P64 < 2) goto c3SI; else goto c3SJ;
       c3SI: // global
           R1 = GHC.Integer.Type.oneInteger_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c3SJ: // global
           R1 = GHC.Integer.Type.negativeOneInteger_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c3SK: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.003807123 UTC

[section ""data" . GHC.Integer.Type.halfBoundUp_closure" {
     GHC.Integer.Type.halfBoundUp_closure:
         const GHC.Integer.Type.halfBoundUp_info;
 },
 GHC.Integer.Type.halfBoundUp_entry() //  [R2]
         { info_tbl: [(c3T7,
                       label: GHC.Integer.Type.halfBoundUp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3T7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c3T8; else goto c3T9;
       c3T8: // global
           R2 = R2;
           R1 = GHC.Integer.Type.halfBoundUp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3T9: // global
           I64[Sp - 8] = block_c3T4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u3Td; else goto c3T5;
       u3Td: // global
           call _c3T4() args: 0, res: 0, upd: 0;
       c3T5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3T4() //  []
         { info_tbl: [(c3T4,
                       label: block_c3T4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3T4: // global
           R1 = 9223372036854775808;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.005406449 UTC

[section ""data" . GHC.Integer.Type.fullBound_closure" {
     GHC.Integer.Type.fullBound_closure:
         const GHC.Integer.Type.fullBound_info;
 },
 GHC.Integer.Type.fullBound_entry() //  [R2]
         { info_tbl: [(c3Tl,
                       label: GHC.Integer.Type.fullBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Tl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c3Tm; else goto c3Tn;
       c3Tm: // global
           R2 = R2;
           R1 = GHC.Integer.Type.fullBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3Tn: // global
           I64[Sp - 8] = block_c3Ti_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u3Tr; else goto c3Tj;
       u3Tr: // global
           call _c3Ti() args: 0, res: 0, upd: 0;
       c3Tj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3Ti() //  []
         { info_tbl: [(c3Ti,
                       label: block_c3Ti_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Ti: // global
           R1 = 18446744073709551615;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.007078107 UTC

[section ""data" . GHC.Integer.Type.$wsuccPositive_closure" {
     GHC.Integer.Type.$wsuccPositive_closure:
         const GHC.Integer.Type.$wsuccPositive_info;
 },
 GHC.Integer.Type.$wsuccPositive_entry() //  [R2]
         { info_tbl: [(c3TD,
                       label: GHC.Integer.Type.$wsuccPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3TD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c3TE; else goto c3TF;
       c3TE: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$wsuccPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3TF: // global
           I64[Sp - 8] = block_c3Tw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u3U2; else goto c3Tx;
       u3U2: // global
           call _c3Tw(R1) args: 0, res: 0, upd: 0;
       c3Tx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3Tw() //  [R1]
         { info_tbl: [(c3Tw,
                       label: block_c3Tw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Tw: // global
           if (R1 & 7 == 1) goto c3TA; else goto c3TB;
       c3TA: // global
           _s3Cu::P64 = P64[R1 + 7];
           _s3Cv::I64 = I64[R1 + 15];
           if (_s3Cv::I64 != 18446744073709551615) goto c3TL; else goto c3TT;
       c3TL: // global
           R2 = _s3Cu::P64;
           R1 = _s3Cv::I64 + 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c3TT: // global
           I64[Sp] = block_c3TO_info;
           R2 = _s3Cu::P64;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
       c3TB: // global
           R2 = GHC.Integer.Type.None_closure+2;
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c3TO() //  [R1, R2]
         { info_tbl: [(c3TO,
                       label: block_c3TO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3TO: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c3TP() args: 0, res: 0, upd: 0;
     }
 },
 _c3TP() //  []
         { info_tbl: [(c3TP,
                       label: block_c3TP_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3TP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3TW; else goto c3TV;
       c3TW: // global
           HpAlloc = 24;
           I64[Sp] = block_c3TP_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c3TV: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = Hp - 15;
           R1 = 0;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.009419494 UTC

[section ""data" . GHC.Integer.Type.succPositive_closure" {
     GHC.Integer.Type.succPositive_closure:
         const GHC.Integer.Type.succPositive_info;
 },
 GHC.Integer.Type.succPositive_entry() //  [R2]
         { info_tbl: [(c3Ud,
                       label: GHC.Integer.Type.succPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Ud: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c3Ue; else goto c3Uf;
       c3Ue: // global
           R2 = R2;
           R1 = GHC.Integer.Type.succPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3Uf: // global
           I64[Sp - 8] = block_c3U8_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c3U8() //  [R1, R2]
         { info_tbl: [(c3U8,
                       label: block_c3U8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3U8: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c3U9() args: 0, res: 0, upd: 0;
     }
 },
 _c3U9() //  []
         { info_tbl: [(c3U9,
                       label: block_c3U9_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3U9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3Ui; else goto c3Uh;
       c3Ui: // global
           HpAlloc = 24;
           I64[Sp] = block_c3U9_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c3Uh: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.010994725 UTC

[section ""data" . lvl_r3Bo_closure" {
     lvl_r3Bo_closure:
         const lvl_r3Bo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r3Bo_entry() //  [R1]
         { info_tbl: [(c3Uw,
                       label: lvl_r3Bo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Uw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c3Ux; else goto c3Uy;
       c3Ux: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Uy: // global
           (_c3Uo::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c3Uo::I64 == 0) goto c3Uq; else goto c3Up;
       c3Uq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c3Up: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c3Uo::I64;
           I64[Sp - 24] = block_c3Ur_info;
           R2 = GHC.Integer.Type.None_closure+2;
           Sp = Sp - 24;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c3Ur() //  [R1, R2]
         { info_tbl: [(c3Ur,
                       label: block_c3Ur_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Ur: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c3Us() args: 0, res: 0, upd: 0;
     }
 },
 _c3Us() //  []
         { info_tbl: [(c3Us,
                       label: block_c3Us_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Us: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3UB; else goto c3UA;
       c3UB: // global
           HpAlloc = 24;
           I64[Sp] = block_c3Us_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c3UA: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.016160654 UTC

[section ""data" . GHC.Integer.Type.plusPositive_addWithCarry_closure" {
     GHC.Integer.Type.plusPositive_addWithCarry_closure:
         const GHC.Integer.Type.plusPositive_addWithCarry_info;
         const 0;
 },
 GHC.Integer.Type.plusPositive_addWithCarry_entry() //  [R2, R3, R4]
         { info_tbl: [(c3UP,
                       label: GHC.Integer.Type.plusPositive_addWithCarry_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3UP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c3UQ; else goto u3Xm;
       c3UQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.plusPositive_addWithCarry_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u3Xm: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c3UF() args: 0, res: 0, upd: 0;
     }
 },
 _c3UF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3UF: // global
           I64[Sp - 8] = block_c3UI_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u3Xq; else goto c3UJ;
       u3Xq: // global
           call _c3UI(R1) args: 0, res: 0, upd: 0;
       c3UJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3UI() //  [R1]
         { info_tbl: [(c3UI,
                       label: block_c3UI_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3UI: // global
           _s3CK::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c3UM; else goto c3UN;
       c3UM: // global
           I64[Sp - 8] = block_c3UU_info;
           _s3CL::P64 = R1;
           _s3CN::P64 = P64[R1 + 7];
           _s3CM::I64 = I64[R1 + 15];
           R1 = _s3CK::P64;
           P64[Sp] = _s3CN::P64;
           I64[Sp + 16] = _s3CM::I64;
           P64[Sp + 24] = _s3CL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u3Xr; else goto c3UW;
       u3Xr: // global
           call _c3UU(R1) args: 0, res: 0, upd: 0;
       c3UW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c3UN: // global
           I64[Sp] = block_c3WQ_info;
           R1 = _s3CK::P64;
           if (R1 & 7 != 0) goto u3Xs; else goto c3WS;
       u3Xs: // global
           call _c3WQ(R1) args: 0, res: 0, upd: 0;
       c3WS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3UU() //  [R1]
         { info_tbl: [(c3UU,
                       label: block_c3UU_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3UU: // global
           _s3CI::I64 = I64[Sp + 16];
           _s3CL::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c3Ww; else goto c3WN;
       c3Ww: // global
           _s3CM::I64 = I64[Sp + 24];
           _s3CP::I64 = I64[R1 + 15];
           if (_s3CM::I64 >= _s3CP::I64) goto c3Wt; else goto c3Wu;
       c3Wt: // global
           _s3CN::P64 = P64[Sp + 8];
           _s3CQ::P64 = P64[R1 + 7];
           if (_s3CP::I64 < 9223372036854775808) goto c3W5; else goto c3Wo;
       c3W5: // global
           if (_s3CM::I64 < 9223372036854775808) goto c3Vm; else goto c3W3;
       c3Vm: // global
           I64[Sp + 8] = block_c3Va_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 0;
           I64[Sp + 32] = _s3CP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c3W3: // global
           _s3CX::I64 = (_s3CM::I64 + -9223372036854775808) + (_s3CP::I64 + _s3CI::I64);
           if (_s3CX::I64 >= 9223372036854775808) goto c3VM; else goto c3VZ;
       c3VM: // global
           I64[Sp + 24] = block_c3VD_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 1;
           I64[Sp + 32] = _s3CX::I64;
           Sp = Sp + 24;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c3VZ: // global
           I64[Sp + 24] = block_c3VR_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 0;
           I64[Sp + 32] = _s3CX::I64;
           Sp = Sp + 24;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c3Wo: // global
           I64[Sp + 8] = block_c3W7_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 1;
           I64[Sp + 32] = _s3CP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c3Wu: // global
           I64[Sp + 16] = _s3CI::I64;
           P64[Sp + 24] = R1;
           P64[Sp + 32] = _s3CL::P64;
           Sp = Sp + 16;
           call _c3UF() args: 0, res: 0, upd: 0;
       c3WN: // global
           if (_s3CI::I64 == 0) goto c3WM; else goto c3WI;
       c3WM: // global
           R1 = _s3CL::P64 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c3WI: // global
           I64[Sp + 32] = block_c3WC_info;
           R2 = _s3CL::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c3Va() //  [R1]
         { info_tbl: [(c3Va,
                       label: block_c3Va_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Va: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3Vp; else goto c3Vo;
       c3Vp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3Vo: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] + (I64[Sp + 24] + I64[Sp + 8]);
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c3VD() //  [R1]
         { info_tbl: [(c3VD,
                       label: block_c3VD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3VD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3VP; else goto c3VO;
       c3VP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3VO: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - 9223372036854775808;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c3VR() //  [R1]
         { info_tbl: [(c3VR,
                       label: block_c3VR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3VR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3W2; else goto c3W1;
       c3W2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3W1: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - 9223372036854775808;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c3W7() //  [R1]
         { info_tbl: [(c3W7,
                       label: block_c3W7_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3W7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3Wr; else goto c3Wq;
       c3Wr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3Wq: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] + (I64[Sp + 24] + I64[Sp + 8]);
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c3WC() //  [R1, R2]
         { info_tbl: [(c3WC,
                       label: block_c3WC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3WC: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c3WD() args: 0, res: 0, upd: 0;
     }
 },
 _c3WD() //  []
         { info_tbl: [(c3WD,
                       label: block_c3WD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3WD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3WL; else goto c3WK;
       c3WL: // global
           HpAlloc = 24;
           I64[Sp] = block_c3WD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c3WK: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c3WQ() //  [R1]
         { info_tbl: [(c3WQ,
                       label: block_c3WQ_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3WQ: // global
           _s3CI::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c3Xb; else goto c3Xj;
       c3Xb: // global
           if (_s3CI::I64 == 0) goto c3X9; else goto c3X5;
       c3X9: // global
           R1 = R1 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c3X5: // global
           I64[Sp + 24] = block_c3WZ_info;
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
       c3Xj: // global
           if (_s3CI::I64 == 0) goto c3Xi; else goto c3Xh;
       c3Xi: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c3Xh: // global
           R1 = lvl_r3Bo_closure;
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c3WZ() //  [R1, R2]
         { info_tbl: [(c3WZ,
                       label: block_c3WZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3WZ: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c3X0() args: 0, res: 0, upd: 0;
     }
 },
 _c3X0() //  []
         { info_tbl: [(c3X0,
                       label: block_c3X0_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3X0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3X8; else goto c3X7;
       c3X8: // global
           HpAlloc = 24;
           I64[Sp] = block_c3X0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c3X7: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.02236614 UTC

[section ""data" . GHC.Integer.Type.plusPositive_closure" {
     GHC.Integer.Type.plusPositive_closure:
         const GHC.Integer.Type.plusPositive_info;
         const 0;
 },
 GHC.Integer.Type.plusPositive_entry() //  [R2, R3]
         { info_tbl: [(c3XC,
                       label: GHC.Integer.Type.plusPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3XC: // global
           R4 = R3;
           R3 = R2;
           R2 = 0;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.024640942 UTC

[section ""data" . GHC.Integer.Type.minusPositive_closure" {
     GHC.Integer.Type.minusPositive_closure:
         const GHC.Integer.Type.minusPositive_info;
 },
 GHC.Integer.Type.minusPositive_entry() //  [R2, R3]
         { info_tbl: [(c3XQ,
                       label: GHC.Integer.Type.minusPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3XQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c3XR; else goto c3XS;
       c3XR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.minusPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c3XS: // global
           I64[Sp - 16] = block_c3XJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3Zt; else goto c3XK;
       u3Zt: // global
           call _c3XJ(R1) args: 0, res: 0, upd: 0;
       c3XK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3XJ() //  [R1]
         { info_tbl: [(c3XJ,
                       label: block_c3XJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3XJ: // global
           _s3Dp::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c3XN; else goto c3XO;
       c3XN: // global
           I64[Sp - 16] = block_c3XV_info;
           _s3Dq::P64 = R1;
           _s3Ds::P64 = P64[R1 + 7];
           _s3Dr::I64 = I64[R1 + 15];
           R1 = _s3Dp::P64;
           P64[Sp - 8] = _s3Ds::P64;
           I64[Sp] = _s3Dr::I64;
           P64[Sp + 8] = _s3Dq::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3Zr; else goto c3XX;
       u3Zr: // global
           call _c3XV(R1) args: 0, res: 0, upd: 0;
       c3XX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c3XO: // global
           I64[Sp + 8] = block_c3Z9_info;
           R1 = _s3Dp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u3Zs; else goto c3Zb;
       u3Zs: // global
           call _c3Z9(R1) args: 0, res: 0, upd: 0;
       c3Zb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3XV() //  [R1]
         { info_tbl: [(c3XV,
                       label: block_c3XV_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3XV: // global
           if (R1 & 7 == 1) goto c3Z2; else goto c3Z6;
       c3Z2: // global
           _s3Dr::I64 = I64[Sp + 16];
           _s3Ds::P64 = P64[Sp + 8];
           _s3Dv::P64 = P64[R1 + 7];
           _s3Du::I64 = I64[R1 + 15];
           if (_s3Dr::I64 == _s3Du::I64) goto c3YN; else goto c3YK;
       c3YN: // global
           I64[Sp + 24] = block_c3YM_info;
           R3 = _s3Dv::P64;
           R2 = _s3Ds::P64;
           Sp = Sp + 24;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c3YK: // global
           if (_s3Dr::I64 <= _s3Du::I64) goto c3Yr; else goto c3YF;
       c3Yr: // global
           I64[Sp + 8] = block_c3Y8_info;
           R3 = _s3Dv::P64;
           R2 = _s3Ds::P64;
           I64[Sp + 24] = _s3Du::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c3YF: // global
           I64[Sp + 8] = block_c3Yx_info;
           R3 = _s3Dv::P64;
           R2 = _s3Ds::P64;
           I64[Sp + 24] = _s3Du::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c3Z6: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c3YM() //  [R1]
         { info_tbl: [(c3YM,
                       label: block_c3YM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3YM: // global
           if (R1 & 7 == 1) goto c3YT; else goto u3Zq;
       c3YT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3YW; else goto c3YV;
       c3YW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3YV: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u3Zq: // global
           Sp = Sp + 8;
           call _c3Zl() args: 0, res: 0, upd: 0;
     }
 },
 _c3Y8() //  [R1]
         { info_tbl: [(c3Y8,
                       label: block_c3Y8_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Y8: // global
           I64[Sp] = block_c3Yc_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = R1;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c3Yc() //  [R1]
         { info_tbl: [(c3Yc,
                       label: block_c3Yc_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Yc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3Yv; else goto c3Yu;
       c3Yv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3Yu: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 18446744073709551615 - I64[Sp + 16] + (I64[Sp + 8] + 1);
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c3Yx() //  [R1]
         { info_tbl: [(c3Yx,
                       label: block_c3Yx_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Yx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c3YI; else goto c3YH;
       c3YI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3YH: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c3Z9() //  [R1]
         { info_tbl: [(c3Z9,
                       label: block_c3Z9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Z9: // global
           if (R1 & 7 == 1) goto c3Zh; else goto u3Zp;
       c3Zh: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u3Zp: // global
           Sp = Sp + 8;
           call _c3Zl() args: 0, res: 0, upd: 0;
     }
 },
 _c3Zl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Zl: // global
           R1 = GHC.Integer.Type.None_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.028489155 UTC

[section ""data" . GHC.Integer.Type.twosComplementPositive1_closure" {
     GHC.Integer.Type.twosComplementPositive1_closure:
         const GHC.Integer.Type.twosComplementPositive1_info;
 },
 GHC.Integer.Type.twosComplementPositive1_entry() //  [R2]
         { info_tbl: [(c3ZC,
                       label: GHC.Integer.Type.twosComplementPositive1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3ZC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c3ZD; else goto c3ZE;
       c3ZD: // global
           R2 = R2;
           R1 = GHC.Integer.Type.twosComplementPositive1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3ZE: // global
           I64[Sp - 8] = block_c3ZA_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c3ZA() //  [R1]
         { info_tbl: [(c3ZA,
                       label: block_c3ZA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3ZA: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.030072088 UTC

[section ""data" . GHC.Integer.Type.twosComplementPositive_closure" {
     GHC.Integer.Type.twosComplementPositive_closure:
         const GHC.Integer.Type.twosComplementPositive_info;
 },
 GHC.Integer.Type.twosComplementPositive_entry() //  [R2]
         { info_tbl: [(c3ZM,
                       label: GHC.Integer.Type.twosComplementPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3ZM: // global
           R2 = R2;
           call GHC.Integer.Type.twosComplementPositive1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.031096373 UTC

[section ""data" . GHC.Integer.Type.lowHalfMask_closure" {
     GHC.Integer.Type.lowHalfMask_closure:
         const GHC.Integer.Type.lowHalfMask_info;
 },
 GHC.Integer.Type.lowHalfMask_entry() //  [R2]
         { info_tbl: [(c3ZW,
                       label: GHC.Integer.Type.lowHalfMask_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3ZW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c3ZX; else goto c3ZY;
       c3ZX: // global
           R2 = R2;
           R1 = GHC.Integer.Type.lowHalfMask_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c3ZY: // global
           I64[Sp - 8] = block_c3ZT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u402; else goto c3ZU;
       u402: // global
           call _c3ZT() args: 0, res: 0, upd: 0;
       c3ZU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c3ZT() //  []
         { info_tbl: [(c3ZT,
                       label: block_c3ZT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3ZT: // global
           R1 = 4294967295;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.032362722 UTC

[section ""data" . GHC.Integer.Type.highHalfShift_closure" {
     GHC.Integer.Type.highHalfShift_closure:
         const GHC.Integer.Type.highHalfShift_info;
 },
 GHC.Integer.Type.highHalfShift_entry() //  [R2]
         { info_tbl: [(c40a,
                       label: GHC.Integer.Type.highHalfShift_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c40a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c40b; else goto c40c;
       c40b: // global
           R2 = R2;
           R1 = GHC.Integer.Type.highHalfShift_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c40c: // global
           I64[Sp - 8] = block_c407_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u40g; else goto c408;
       u40g: // global
           call _c407() args: 0, res: 0, upd: 0;
       c408: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c407() //  []
         { info_tbl: [(c407,
                       label: block_c407_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c407: // global
           R1 = 32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.03414946 UTC

[section ""data" . GHC.Integer.Type.splitHalves_closure" {
     GHC.Integer.Type.splitHalves_closure:
         const GHC.Integer.Type.splitHalves_info;
 },
 GHC.Integer.Type.splitHalves_entry() //  [R2]
         { info_tbl: [(c40n,
                       label: GHC.Integer.Type.splitHalves_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c40n: // global
           _s3DS::I64 = R2 >> 32;
           R2 = R2 & 4294967295;
           R1 = _s3DS::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.035539206 UTC

[section ""data" . GHC.Integer.Type.doubleFromPositive_closure" {
     GHC.Integer.Type.doubleFromPositive_closure:
         const GHC.Integer.Type.doubleFromPositive_info;
 },
 GHC.Integer.Type.doubleFromPositive_entry() //  [R2]
         { info_tbl: [(c40D,
                       label: GHC.Integer.Type.doubleFromPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c40D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c40E; else goto c40F;
       c40E: // global
           R2 = R2;
           R1 = GHC.Integer.Type.doubleFromPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c40F: // global
           I64[Sp - 8] = block_c40w_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u41t; else goto c40x;
       u41t: // global
           call _c40w(R1) args: 0, res: 0, upd: 0;
       c40x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c40w() //  [R1]
         { info_tbl: [(c40w,
                       label: block_c40w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c40w: // global
           if (R1 & 7 == 1) goto c40A; else goto c40B;
       c40A: // global
           I64[Sp - 8] = block_c40I_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c40B: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 _c40I() //  [D1]
         { info_tbl: [(c40I,
                       label: block_c40I_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c40I: // global
           _s3DW::I64 = I64[Sp + 8];
           _s3DY::F64 = D1;
           (_c40V::F64) = call MO_F64_Pwr(2.0 :: W64, 32.0 :: W64);
           (_c41c::F64) = call MO_F64_Pwr(2.0 :: W64, 64.0 :: W64);
           D1 = %MO_F_Add_W64(%MO_F_Add_W64(%MO_F_Mul_W64(_s3DY::F64,
                                                          _c41c::F64),
                                            %MO_F_Mul_W64(%MO_SF_Conv_W64_W64(_s3DW::I64 >> 32),
                                                          _c40V::F64)),
                              %MO_SF_Conv_W64_W64(_s3DW::I64 & 4294967295));
           Sp = Sp + 16;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.037448099 UTC

[section ""data" . GHC.Integer.Type.doubleFromInteger_closure" {
     GHC.Integer.Type.doubleFromInteger_closure:
         const GHC.Integer.Type.doubleFromInteger_info;
 },
 GHC.Integer.Type.doubleFromInteger_entry() //  [R2]
         { info_tbl: [(c41G,
                       label: GHC.Integer.Type.doubleFromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c41G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c41H; else goto c41I;
       c41H: // global
           R2 = R2;
           R1 = GHC.Integer.Type.doubleFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c41I: // global
           I64[Sp - 8] = block_c41y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u41Z; else goto c41z;
       u41Z: // global
           call _c41y(R1) args: 0, res: 0, upd: 0;
       c41z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c41y() //  [R1]
         { info_tbl: [(c41y,
                       label: block_c41y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c41y: // global
           _c41F::P64 = R1 & 7;
           if (_c41F::P64 < 3) goto u41Y; else goto c41E;
       u41Y: // global
           if (_c41F::P64 < 2) goto c41C; else goto c41D;
       c41C: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 0, upd: 8;
       c41D: // global
           I64[Sp] = block_c41O_info;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c41E: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 _c41O() //  [D1]
         { info_tbl: [(c41O,
                       label: block_c41O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c41O: // global
           D1 = %MO_F_Neg_W64(D1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.039910572 UTC

[section ""data" . GHC.Integer.Type.floatFromPositive_closure" {
     GHC.Integer.Type.floatFromPositive_closure:
         const GHC.Integer.Type.floatFromPositive_info;
 },
 GHC.Integer.Type.floatFromPositive_entry() //  [R2]
         { info_tbl: [(c42b,
                       label: GHC.Integer.Type.floatFromPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c42b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c42c; else goto c42d;
       c42c: // global
           R2 = R2;
           R1 = GHC.Integer.Type.floatFromPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c42d: // global
           I64[Sp - 8] = block_c424_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u431; else goto c425;
       u431: // global
           call _c424(R1) args: 0, res: 0, upd: 0;
       c425: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c424() //  [R1]
         { info_tbl: [(c424,
                       label: block_c424_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c424: // global
           if (R1 & 7 == 1) goto c428; else goto c429;
       c428: // global
           I64[Sp - 8] = block_c42g_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c429: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 _c42g() //  [F1]
         { info_tbl: [(c42g,
                       label: block_c42g_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c42g: // global
           _s3Eh::I64 = I64[Sp + 8];
           _s3Ej::F32 = F1;
           (_c42t::F32) = call MO_F32_Pwr(2.0 :: W32, 32.0 :: W32);
           (_c42K::F32) = call MO_F32_Pwr(2.0 :: W32, 64.0 :: W32);
           F1 = %MO_F_Add_W32(%MO_F_Add_W32(%MO_F_Mul_W32(_s3Ej::F32,
                                                          _c42K::F32),
                                            %MO_F_Mul_W32(%MO_SF_Conv_W64_W32(_s3Eh::I64 >> 32),
                                                          _c42t::F32)),
                              %MO_SF_Conv_W64_W32(_s3Eh::I64 & 4294967295));
           Sp = Sp + 16;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.041865972 UTC

[section ""data" . GHC.Integer.Type.floatFromInteger_closure" {
     GHC.Integer.Type.floatFromInteger_closure:
         const GHC.Integer.Type.floatFromInteger_info;
 },
 GHC.Integer.Type.floatFromInteger_entry() //  [R2]
         { info_tbl: [(c43e,
                       label: GHC.Integer.Type.floatFromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c43f; else goto c43g;
       c43f: // global
           R2 = R2;
           R1 = GHC.Integer.Type.floatFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c43g: // global
           I64[Sp - 8] = block_c436_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u43x; else goto c437;
       u43x: // global
           call _c436(R1) args: 0, res: 0, upd: 0;
       c437: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c436() //  [R1]
         { info_tbl: [(c436,
                       label: block_c436_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c436: // global
           _c43d::P64 = R1 & 7;
           if (_c43d::P64 < 3) goto u43w; else goto c43c;
       u43w: // global
           if (_c43d::P64 < 2) goto c43a; else goto c43b;
       c43a: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 0, upd: 8;
       c43b: // global
           I64[Sp] = block_c43m_info;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c43c: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 _c43m() //  [F1]
         { info_tbl: [(c43m,
                       label: block_c43m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43m: // global
           F1 = %MO_F_Neg_W32(F1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.044369799 UTC

[section ""data" . GHC.Integer.Type.timesDigit_closure" {
     GHC.Integer.Type.timesDigit_closure:
         const GHC.Integer.Type.timesDigit_info;
         const 0;
 },
 GHC.Integer.Type.timesDigit_entry() //  [R2, R3]
         { info_tbl: [(c43E,
                       label: GHC.Integer.Type.timesDigit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43E: // global
           _s3EB::I64 = R3;
           _s3EA::I64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c44i; else goto c44j;
       c44j: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c44l; else goto c44k;
       c44l: // global
           HpAlloc = 72;
           goto c44i;
       c44i: // global
           R3 = _s3EB::I64;
           R2 = _s3EA::I64;
           R1 = GHC.Integer.Type.timesDigit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44k: // global
           I64[Hp - 64] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 56] = GHC.Integer.Type.None_closure+2;
           _s3ED::I64 = _s3EB::I64 & 4294967295;
           _s3EF::I64 = _s3EA::I64 & 4294967295;
           I64[Hp - 48] = _s3EF::I64 * _s3ED::I64;
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = GHC.Integer.Type.None_closure+2;
           _s3EG::I64 = _s3EB::I64 >> 32;
           _s3EH::I64 = _s3EF::I64 * _s3EG::I64;
           I64[Hp - 24] = _s3EH::I64 & 4294967295 << 32;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           _s3EC::I64 = _s3EA::I64 >> 32;
           _s3EE::I64 = _s3EC::I64 * _s3ED::I64;
           I64[Hp] = _s3EE::I64 & 4294967295 << 32;
           I64[Sp - 48] = block_c44d_info;
           R4 = Hp - 39;
           R3 = Hp - 15;
           R2 = 0;
           P64[Sp - 40] = Hp - 63;
           I64[Sp - 32] = _s3EC::I64;
           I64[Sp - 24] = _s3EE::I64;
           I64[Sp - 16] = _s3EG::I64;
           I64[Sp - 8] = _s3EH::I64;
           Sp = Sp - 48;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44d() //  [R1]
         { info_tbl: [(c44d,
                       label: block_c44d_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44d: // global
           _c43Y::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c44h_info;
           R4 = _c43Y::P64;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44h() //  [R1]
         { info_tbl: [(c44h,
                       label: block_c44h_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44h: // global
           _s3EW::I64 = I64[Sp + 8] * I64[Sp + 24] + ((I64[Sp + 16] >> 32) + (I64[Sp + 32] >> 32));
           if (_s3EW::I64 == 0) goto c44S; else goto u44W;
       c44S: // global
           R1 = R1 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u44W: // global
           I64[Sp + 24] = _s3EW::I64;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call _c44H() args: 0, res: 0, upd: 0;
     }
 },
 _c44H() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44H: // global
           Hp = Hp + 48;
           _s3EW::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c44P; else goto c44O;
       c44P: // global
           HpAlloc = 48;
           I64[Sp] = block_c44G_info;
           R1 = _s3EW::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c44O: // global
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = GHC.Integer.Type.None_closure+2;
           I64[Hp - 24] = _s3EW::I64;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = 0;
           R4 = P64[Sp + 8];
           R3 = Hp - 15;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c44G() //  [R1]
         { info_tbl: [(c44G,
                       label: block_c44G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44G: // global
           I64[Sp] = R1;
           call _c44H() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.048304927 UTC

[section ""data" . GHC.Integer.Type.timesPositive_closure" {
     GHC.Integer.Type.timesPositive_closure:
         const GHC.Integer.Type.timesPositive_info;
         const 0;
 },
 GHC.Integer.Type.timesPositive_entry() //  [R2, R3]
         { info_tbl: [(c45b,
                       label: GHC.Integer.Type.timesPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45b: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c45c; else goto u46V;
       c45c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.timesPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u46V: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c451() args: 0, res: 0, upd: 0;
     }
 },
 _c451() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c451: // global
           _s3EZ::P64 = P64[Sp];
           I64[Sp] = block_c454_info;
           R1 = _s3EZ::P64;
           if (R1 & 7 != 0) goto u46X; else goto c455;
       u46X: // global
           call _c454(R1) args: 0, res: 0, upd: 0;
       c455: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c454() //  [R1]
         { info_tbl: [(c454,
                       label: block_c454_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c454: // global
           _s3F0::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c458; else goto c459;
       c458: // global
           I64[Sp - 16] = block_c45g_info;
           _s3F1::P64 = R1;
           _s3F3::P64 = P64[R1 + 7];
           _s3F2::I64 = I64[R1 + 15];
           R1 = _s3F0::P64;
           P64[Sp - 8] = _s3F3::P64;
           I64[Sp] = _s3F2::I64;
           P64[Sp + 8] = _s3F1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u46Y; else goto c45i;
       u46Y: // global
           call _c45g(R1) args: 0, res: 0, upd: 0;
       c45i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c459: // global
           I64[Sp + 8] = block_c46K_info;
           R1 = _s3F0::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u46Z; else goto c46M;
       u46Z: // global
           call _c46K() args: 0, res: 0, upd: 0;
       c46M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45g() //  [R1]
         { info_tbl: [(c45g,
                       label: block_c45g_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45g: // global
           if (R1 & 7 == 1) goto c45p; else goto c46H;
       c45p: // global
           I64[Sp - 16] = block_c45m_info;
           _s3F4::P64 = R1;
           _s3F6::P64 = P64[R1 + 7];
           _s3F5::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s3F6::P64;
           I64[Sp] = _s3F5::I64;
           P64[Sp + 8] = _s3F4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u471; else goto c45q;
       u471: // global
           call _c45m(R1) args: 0, res: 0, upd: 0;
       c45q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c46H: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c45m() //  [R1]
         { info_tbl: [(c45m,
                       label: block_c45m_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45m: // global
           _s3F6::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c45x; else goto c46s;
       c45x: // global
           I64[Sp + 8] = block_c45u_info;
           _s3F7::P64 = R1;
           R1 = _s3F6::P64;
           P64[Sp + 40] = _s3F7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u472; else goto c45y;
       u472: // global
           call _c45u(R1) args: 0, res: 0, upd: 0;
       c45y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c46s: // global
           I64[Sp + 8] = block_c46q_info;
           R1 = _s3F6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u473; else goto c46t;
       u473: // global
           call _c46q(R1) args: 0, res: 0, upd: 0;
       c46t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45u() //  [R1]
         { info_tbl: [(c45u,
                       label: block_c45u_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45u: // global
           _s3F4::P64 = P64[Sp + 16];
           _s3F7::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c45L; else goto c46n;
       c45L: // global
           I64[Sp + 8] = block_c45C_info;
           R3 = _s3F4::P64;
           R2 = _s3F7::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c46n: // global
           _s3Fh::I64 = I64[Sp + 24];
           if (_s3Fh::I64 != 0) goto c465; else goto c46j;
       c465: // global
           I64[Sp] = block_c45Y_info;
           R3 = _s3F4::P64;
           R2 = _s3F7::P64;
           I64[Sp + 32] = _s3Fh::I64;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c46j: // global
           I64[Sp + 32] = block_c46e_info;
           R3 = _s3F4::P64;
           R2 = _s3F7::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45C() //  [R1]
         { info_tbl: [(c45C,
                       label: block_c45C_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45C: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c45O; else goto c45N;
       c45O: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45N: // global
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c45I_info;
           R3 = P64[Sp + 8];
           R2 = Hp - 15;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45I() //  [R1]
         { info_tbl: [(c45I,
                       label: block_c45I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45I: // global
           R4 = P64[Sp + 8];
           R3 = R1;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c45Y() //  [R1]
         { info_tbl: [(c45Y,
                       label: block_c45Y_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c468; else goto c467;
       c468: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c467: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           I64[Sp + 24] = block_c463_info;
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 32];
           P64[Sp + 32] = Hp - 15;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesDigit_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c463() //  [R1]
         { info_tbl: [(c463,
                       label: block_c463_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c463: // global
           R4 = P64[Sp + 8];
           R3 = R1;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c46e() //  [R1]
         { info_tbl: [(c46e,
                       label: block_c46e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46m; else goto c46l;
       c46m: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46l: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c46q() //  [R1]
         { info_tbl: [(c46q,
                       label: block_c46q_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46q: // global
           if (R1 & 7 == 1) goto c46z; else goto c46D;
       c46z: // global
           P64[Sp + 24] = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 32];
           Sp = Sp + 24;
           call _c451() args: 0, res: 0, upd: 0;
       c46D: // global
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Integer.Type.timesDigit_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _c46K() //  []
         { info_tbl: [(c46K,
                       label: block_c46K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46K: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.054093751 UTC

[section ""data" . GHC.Integer.Type.timesInteger_closure" {
     GHC.Integer.Type.timesInteger_closure:
         const GHC.Integer.Type.timesInteger_info;
         const 0;
 },
 GHC.Integer.Type.timesInteger_entry() //  [R2, R3]
         { info_tbl: [(c47h,
                       label: GHC.Integer.Type.timesInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47i; else goto c47j;
       c47i: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.timesInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47j: // global
           I64[Sp - 16] = block_c479_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48L; else goto c47a;
       u48L: // global
           call _c479(R1) args: 0, res: 0, upd: 0;
       c47a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c479() //  [R1]
         { info_tbl: [(c479,
                       label: block_c479_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c479: // global
           _s3Fr::P64 = P64[Sp + 8];
           _c47g::P64 = R1 & 7;
           if (_c47g::P64 < 3) goto u48D; else goto c47f;
       u48D: // global
           if (_c47g::P64 < 2) goto c47d; else goto c47e;
       c47d: // global
           I64[Sp] = block_c47m_info;
           _s3Ft::P64 = P64[R1 + 7];
           R1 = _s3Fr::P64;
           P64[Sp + 8] = _s3Ft::P64;
           if (R1 & 7 != 0) goto u48I; else goto c47o;
       u48I: // global
           call _c47m(R1) args: 0, res: 0, upd: 0;
       c47o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c47e: // global
           I64[Sp] = block_c47V_info;
           _s3Fz::P64 = P64[R1 + 6];
           R1 = _s3Fr::P64;
           P64[Sp + 8] = _s3Fz::P64;
           if (R1 & 7 != 0) goto u48J; else goto c47X;
       u48J: // global
           call _c47V(R1) args: 0, res: 0, upd: 0;
       c47X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c47f: // global
           I64[Sp + 8] = block_c48u_info;
           R1 = _s3Fr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u48K; else goto c48w;
       u48K: // global
           call _c48u() args: 0, res: 0, upd: 0;
       c48w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47m() //  [R1]
         { info_tbl: [(c47m,
                       label: block_c47m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47m: // global
           _c48C::P64 = R1 & 7;
           if (_c48C::P64 < 3) goto u48E; else goto u48G;
       u48E: // global
           _s3Ft::P64 = P64[Sp + 8];
           if (_c48C::P64 < 2) goto c47z; else goto c47L;
       c47z: // global
           I64[Sp + 8] = block_c47s_info;
           R3 = P64[R1 + 7];
           R2 = _s3Ft::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c47L: // global
           I64[Sp + 8] = block_c47F_info;
           R3 = P64[R1 + 6];
           R2 = _s3Ft::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       u48G: // global
           Sp = Sp + 16;
           call _c48r() args: 0, res: 0, upd: 0;
     }
 },
 _c47s() //  [R1]
         { info_tbl: [(c47s,
                       label: block_c47s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c47C; else goto c47B;
       c47C: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c47B: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c47F() //  [R1]
         { info_tbl: [(c47F,
                       label: block_c47F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c47O; else goto c47N;
       c47O: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c47N: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c47V() //  [R1]
         { info_tbl: [(c47V,
                       label: block_c47V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47V: // global
           _c48B::P64 = R1 & 7;
           if (_c48B::P64 < 3) goto u48F; else goto u48H;
       u48F: // global
           _s3Fz::P64 = P64[Sp + 8];
           if (_c48B::P64 < 2) goto c488; else goto c48k;
       c488: // global
           I64[Sp + 8] = block_c481_info;
           R3 = P64[R1 + 7];
           R2 = _s3Fz::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c48k: // global
           I64[Sp + 8] = block_c48e_info;
           R3 = P64[R1 + 6];
           R2 = _s3Fz::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       u48H: // global
           Sp = Sp + 16;
           call _c48r() args: 0, res: 0, upd: 0;
     }
 },
 _c481() //  [R1]
         { info_tbl: [(c481,
                       label: block_c481_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c481: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48b; else goto c48a;
       c48b: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48a: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c48e() //  [R1]
         { info_tbl: [(c48e,
                       label: block_c48e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48n; else goto c48m;
       c48n: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48m: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c48r() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48r: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c48u() //  []
         { info_tbl: [(c48u,
                       label: block_c48u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48u: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.057896177 UTC

[section ""data" . GHC.Integer.Type.twoToTheThirtytwoPositive_closure" {
     GHC.Integer.Type.twoToTheThirtytwoPositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 4294967296;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.058610862 UTC

[section ""data" . GHC.Integer.Type.twoToTheThirtytwoInteger_closure" {
     GHC.Integer.Type.twoToTheThirtytwoInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.twoToTheThirtytwoPositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.06026729 UTC

[section ""data" . GHC.Integer.Type.digitsMaybeZeroToInteger_closure" {
     GHC.Integer.Type.digitsMaybeZeroToInteger_closure:
         const GHC.Integer.Type.digitsMaybeZeroToInteger_info;
 },
 GHC.Integer.Type.digitsMaybeZeroToInteger_entry() //  [R2]
         { info_tbl: [(c48Z,
                       label: GHC.Integer.Type.digitsMaybeZeroToInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c490; else goto c491;
       c490: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsMaybeZeroToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c491: // global
           I64[Sp - 8] = block_c48S_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u49b; else goto c48T;
       u49b: // global
           call _c48S(R1) args: 0, res: 0, upd: 0;
       c48T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48S() //  [R1]
         { info_tbl: [(c48S,
                       label: block_c48S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48S: // global
           if (R1 & 7 == 1) goto c48W; else goto c48X;
       c48W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c497; else goto c496;
       c497: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c496: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48X: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.06258304 UTC

[section ""data" . GHC.Integer.Type.removeZeroTails_closure" {
     GHC.Integer.Type.removeZeroTails_closure:
         const GHC.Integer.Type.removeZeroTails_info;
 },
 GHC.Integer.Type.removeZeroTails_entry() //  [R2]
         { info_tbl: [(c49n,
                       label: GHC.Integer.Type.removeZeroTails_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c49n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c49o; else goto c49p;
       c49o: // global
           R2 = R2;
           R1 = GHC.Integer.Type.removeZeroTails_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c49p: // global
           I64[Sp - 8] = block_c49g_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4a2; else goto c49h;
       u4a2: // global
           call _c49g(R1) args: 0, res: 0, upd: 0;
       c49h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c49g() //  [R1]
         { info_tbl: [(c49g,
                       label: block_c49g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c49g: // global
           if (R1 & 7 == 1) goto c49k; else goto u49Z;
       c49k: // global
           _s3FN::P64 = P64[R1 + 7];
           _s3FO::I64 = I64[R1 + 15];
           if (_s3FO::I64 != 0) goto c49B; else goto c49H;
       c49B: // global
           I64[Sp - 8] = block_c49v_info;
           R2 = _s3FN::P64;
           I64[Sp] = _s3FO::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
       c49H: // global
           I64[Sp] = block_c49G_info;
           R2 = _s3FN::P64;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
       u49Z: // global
           Sp = Sp + 8;
           call _c49l() args: 0, res: 0, upd: 0;
     }
 },
 _c49v() //  [R1]
         { info_tbl: [(c49v,
                       label: block_c49v_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c49v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c49E; else goto c49D;
       c49E: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c49D: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c49G() //  [R1]
         { info_tbl: [(c49G,
                       label: block_c49G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c49G: // global
           if (R1 & 7 == 1) goto c49N; else goto u4a0;
       c49N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c49Q; else goto c49P;
       c49Q: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c49P: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4a0: // global
           Sp = Sp + 8;
           call _c49l() args: 0, res: 0, upd: 0;
     }
 },
 _c49l() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c49l: // global
           R1 = GHC.Integer.Type.None_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.066030571 UTC

[section ""data" . GHC.Integer.Type.digitsToNegativeInteger_closure" {
     GHC.Integer.Type.digitsToNegativeInteger_closure:
         const GHC.Integer.Type.digitsToNegativeInteger_info;
 },
 GHC.Integer.Type.digitsToNegativeInteger_entry() //  [R2]
         { info_tbl: [(c4ae,
                       label: GHC.Integer.Type.digitsToNegativeInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ae: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4af; else goto c4ag;
       c4af: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsToNegativeInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ag: // global
           I64[Sp - 8] = block_c4a8_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4a8() //  [R1]
         { info_tbl: [(c4a8,
                       label: block_c4a8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a8: // global
           if (R1 & 7 == 1) goto c4ab; else goto c4ac;
       c4ab: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4am; else goto c4al;
       c4am: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4al: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ac: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.067634708 UTC

[section ""data" . GHC.Integer.Type.digitsToInteger_closure" {
     GHC.Integer.Type.digitsToInteger_closure:
         const GHC.Integer.Type.digitsToInteger_info;
 },
 GHC.Integer.Type.digitsToInteger_entry() //  [R2]
         { info_tbl: [(c4aA,
                       label: GHC.Integer.Type.digitsToInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4aB; else goto c4aC;
       c4aB: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4aC: // global
           I64[Sp - 8] = block_c4au_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4au() //  [R1]
         { info_tbl: [(c4au,
                       label: block_c4au_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4au: // global
           if (R1 & 7 == 1) goto c4ax; else goto c4ay;
       c4ax: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4aI; else goto c4aH;
       c4aI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4aH: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ay: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.07077014 UTC

[section ""data" . GHC.Integer.Type.comparePositive_closure" {
     GHC.Integer.Type.comparePositive_closure:
         const GHC.Integer.Type.comparePositive_info;
 },
 GHC.Integer.Type.comparePositive_entry() //  [R2, R3]
         { info_tbl: [(c4aX,
                       label: GHC.Integer.Type.comparePositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4aY; else goto c4aZ;
       c4aY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.comparePositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aZ: // global
           I64[Sp - 16] = block_c4aQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4c1; else goto c4aR;
       u4c1: // global
           call _c4aQ(R1) args: 0, res: 0, upd: 0;
       c4aR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aQ() //  [R1]
         { info_tbl: [(c4aQ,
                       label: block_c4aQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aQ: // global
           _s3G2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c4aU; else goto c4aV;
       c4aU: // global
           I64[Sp - 8] = block_c4b2_info;
           _s3G5::P64 = P64[R1 + 7];
           _s3G4::I64 = I64[R1 + 15];
           R1 = _s3G2::P64;
           P64[Sp] = _s3G5::P64;
           I64[Sp + 8] = _s3G4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4bZ; else goto c4b4;
       u4bZ: // global
           call _c4b2(R1) args: 0, res: 0, upd: 0;
       c4b4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4aV: // global
           I64[Sp + 8] = block_c4bD_info;
           R1 = _s3G2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4c0; else goto c4bF;
       u4c0: // global
           call _c4bD(R1) args: 0, res: 0, upd: 0;
       c4bF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4b2() //  [R1]
         { info_tbl: [(c4b2,
                       label: block_c4b2_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4b2: // global
           if (R1 & 7 == 1) goto c4bb; else goto u4bV;
       c4bb: // global
           I64[Sp] = block_c4b8_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u4bV: // global
           Sp = Sp + 24;
           call _c4bA() args: 0, res: 0, upd: 0;
     }
 },
 _c4b8() //  [R1]
         { info_tbl: [(c4b8,
                       label: block_c4b8_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4b8: // global
           if (R1 & 7 == 2) goto c4bw; else goto c4bh;
       c4bw: // global
           _s3G4::I64 = I64[Sp + 16];
           _s3G7::I64 = I64[Sp + 8];
           if (_s3G4::I64 >= _s3G7::I64) goto c4bu; else goto u4bW;
       c4bu: // global
           if (_s3G4::I64 <= _s3G7::I64) goto u4bY; else goto u4bX;
       u4bY: // global
           Sp = Sp + 24;
           call _c4bP() args: 0, res: 0, upd: 0;
       u4bX: // global
           Sp = Sp + 24;
           call _c4bA() args: 0, res: 0, upd: 0;
       u4bW: // global
           Sp = Sp + 24;
           call _c4bL() args: 0, res: 0, upd: 0;
       c4bh: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4bA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bA: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4bD() //  [R1]
         { info_tbl: [(c4bD,
                       label: block_c4bD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bD: // global
           if (R1 & 7 == 1) goto u4bT; else goto u4bU;
       u4bT: // global
           Sp = Sp + 8;
           call _c4bL() args: 0, res: 0, upd: 0;
       u4bU: // global
           Sp = Sp + 8;
           call _c4bP() args: 0, res: 0, upd: 0;
     }
 },
 _c4bL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bL: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4bP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bP: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.076217611 UTC

[section ""data" . GHC.Integer.Type.compareInteger_closure" {
     GHC.Integer.Type.compareInteger_closure:
         const GHC.Integer.Type.compareInteger_info;
 },
 GHC.Integer.Type.compareInteger_entry() //  [R2, R3]
         { info_tbl: [(c4ck,
                       label: GHC.Integer.Type.compareInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ck: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cl; else goto c4cm;
       c4cl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.compareInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4cm: // global
           I64[Sp - 16] = block_c4cc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4dm; else goto c4cd;
       u4dm: // global
           call _c4cc(R1) args: 0, res: 0, upd: 0;
       c4cd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4cc() //  [R1]
         { info_tbl: [(c4cc,
                       label: block_c4cc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cc: // global
           _s3Gg::P64 = P64[Sp + 8];
           _c4cj::P64 = R1 & 7;
           if (_c4cj::P64 < 3) goto u4dd; else goto c4ci;
       u4dd: // global
           if (_c4cj::P64 < 2) goto c4cg; else goto c4ch;
       c4cg: // global
           I64[Sp] = block_c4cp_info;
           _s3Gi::P64 = P64[R1 + 7];
           R1 = _s3Gg::P64;
           P64[Sp + 8] = _s3Gi::P64;
           if (R1 & 7 != 0) goto u4dj; else goto c4cr;
       u4dj: // global
           call _c4cp(R1) args: 0, res: 0, upd: 0;
       c4cr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4ch: // global
           I64[Sp] = block_c4cE_info;
           _s3Gl::P64 = P64[R1 + 6];
           R1 = _s3Gg::P64;
           P64[Sp + 8] = _s3Gl::P64;
           if (R1 & 7 != 0) goto u4dk; else goto c4cG;
       u4dk: // global
           call _c4cE(R1) args: 0, res: 0, upd: 0;
       c4cG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4ci: // global
           I64[Sp + 8] = block_c4cT_info;
           R1 = _s3Gg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4dl; else goto c4cV;
       u4dl: // global
           call _c4cT(R1) args: 0, res: 0, upd: 0;
       c4cV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4cp() //  [R1]
         { info_tbl: [(c4cp,
                       label: block_c4cp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cp: // global
           if (R1 & 7 == 1) goto c4cB; else goto u4df;
       c4cB: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       u4df: // global
           Sp = Sp + 16;
           call _c4d5() args: 0, res: 0, upd: 0;
     }
 },
 _c4cE() //  [R1]
         { info_tbl: [(c4cE,
                       label: block_c4cE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cE: // global
           if (R1 & 7 == 2) goto c4cQ; else goto u4dg;
       c4cQ: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       u4dg: // global
           Sp = Sp + 16;
           call _c4d1() args: 0, res: 0, upd: 0;
     }
 },
 _c4cT() //  [R1]
         { info_tbl: [(c4cT,
                       label: block_c4cT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cT: // global
           _c4da::P64 = R1 & 7;
           if (_c4da::P64 < 3) goto u4de; else goto c4d9;
       u4de: // global
           if (_c4da::P64 < 2) goto u4di; else goto u4dh;
       u4di: // global
           Sp = Sp + 8;
           call _c4d1() args: 0, res: 0, upd: 0;
       u4dh: // global
           Sp = Sp + 8;
           call _c4d5() args: 0, res: 0, upd: 0;
       c4d9: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4d1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4d1: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4d5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4d5: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.081023335 UTC

[section ""data" . GHC.Integer.Type.eqInteger#_closure" {
     GHC.Integer.Type.eqInteger#_closure:
         const GHC.Integer.Type.eqInteger#_info;
 },
 GHC.Integer.Type.eqInteger#_entry() //  [R2, R3]
         { info_tbl: [(c4dB,
                       label: GHC.Integer.Type.eqInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4dB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4dC; else goto c4dD;
       c4dC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.eqInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4dD: // global
           I64[Sp - 8] = block_c4dv_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4dv() //  [R1]
         { info_tbl: [(c4dv,
                       label: block_c4dv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4dv: // global
           if (R1 & 7 == 2) goto c4dz; else goto c4dy;
       c4dz: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4dy: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.082525077 UTC

[section ""data" . GHC.Integer.Type.eqInteger_closure" {
     GHC.Integer.Type.eqInteger_closure:
         const GHC.Integer.Type.eqInteger_info;
 },
 GHC.Integer.Type.eqInteger_entry() //  [R2, R3]
         { info_tbl: [(c4dQ,
                       label: GHC.Integer.Type.eqInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4dQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4dR; else goto c4dS;
       c4dR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.eqInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4dS: // global
           I64[Sp - 8] = block_c4dO_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4dO() //  [R1]
         { info_tbl: [(c4dO,
                       label: block_c4dO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4dO: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.084557593 UTC

[section ""data" . GHC.Integer.Type.neqInteger#_closure" {
     GHC.Integer.Type.neqInteger#_closure:
         const GHC.Integer.Type.neqInteger#_info;
 },
 GHC.Integer.Type.neqInteger#_entry() //  [R2, R3]
         { info_tbl: [(c4e6,
                       label: GHC.Integer.Type.neqInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4e6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4e7; else goto c4e8;
       c4e7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.neqInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4e8: // global
           I64[Sp - 8] = block_c4e0_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4e0() //  [R1]
         { info_tbl: [(c4e0,
                       label: block_c4e0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4e0: // global
           if (R1 & 7 == 2) goto c4e4; else goto c4e3;
       c4e4: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4e3: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.086167895 UTC

[section ""data" . GHC.Integer.Type.neqInteger_closure" {
     GHC.Integer.Type.neqInteger_closure:
         const GHC.Integer.Type.neqInteger_info;
 },
 GHC.Integer.Type.neqInteger_entry() //  [R2, R3]
         { info_tbl: [(c4el,
                       label: GHC.Integer.Type.neqInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4el: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4em; else goto c4en;
       c4em: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.neqInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4en: // global
           I64[Sp - 8] = block_c4ej_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ej() //  [R1]
         { info_tbl: [(c4ej,
                       label: block_c4ej_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ej: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.087258535 UTC

[section ""data" . GHC.Integer.Type.$fEqInteger_closure" {
     GHC.Integer.Type.$fEqInteger_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.088549265 UTC

[section ""data" . GHC.Integer.Type.ltInteger#_closure" {
     GHC.Integer.Type.ltInteger#_closure:
         const GHC.Integer.Type.ltInteger#_info;
 },
 GHC.Integer.Type.ltInteger#_entry() //  [R2, R3]
         { info_tbl: [(c4eB,
                       label: GHC.Integer.Type.ltInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4eB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4eC; else goto c4eD;
       c4eC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.ltInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4eD: // global
           I64[Sp - 8] = block_c4ev_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ev() //  [R1]
         { info_tbl: [(c4ev,
                       label: block_c4ev_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ev: // global
           if (R1 & 7 == 1) goto c4ez; else goto c4ey;
       c4ez: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ey: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.089773023 UTC

[section ""data" . GHC.Integer.Type.ltInteger_closure" {
     GHC.Integer.Type.ltInteger_closure:
         const GHC.Integer.Type.ltInteger_info;
 },
 GHC.Integer.Type.ltInteger_entry() //  [R2, R3]
         { info_tbl: [(c4eQ,
                       label: GHC.Integer.Type.ltInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4eQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4eR; else goto c4eS;
       c4eR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.ltInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4eS: // global
           I64[Sp - 8] = block_c4eO_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4eO() //  [R1]
         { info_tbl: [(c4eO,
                       label: block_c4eO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4eO: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.090956284 UTC

[section ""data" . GHC.Integer.Type.gtInteger#_closure" {
     GHC.Integer.Type.gtInteger#_closure:
         const GHC.Integer.Type.gtInteger#_info;
 },
 GHC.Integer.Type.gtInteger#_entry() //  [R2, R3]
         { info_tbl: [(c4f6,
                       label: GHC.Integer.Type.gtInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4f6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4f7; else goto c4f8;
       c4f7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.gtInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4f8: // global
           I64[Sp - 8] = block_c4f0_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4f0() //  [R1]
         { info_tbl: [(c4f0,
                       label: block_c4f0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4f0: // global
           if (R1 & 7 == 3) goto c4f4; else goto c4f3;
       c4f4: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4f3: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.092337769 UTC

[section ""data" . GHC.Integer.Type.gtInteger_closure" {
     GHC.Integer.Type.gtInteger_closure:
         const GHC.Integer.Type.gtInteger_info;
 },
 GHC.Integer.Type.gtInteger_entry() //  [R2, R3]
         { info_tbl: [(c4fl,
                       label: GHC.Integer.Type.gtInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4fl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4fm; else goto c4fn;
       c4fm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.gtInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4fn: // global
           I64[Sp - 8] = block_c4fj_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4fj() //  [R1]
         { info_tbl: [(c4fj,
                       label: block_c4fj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4fj: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.093604601 UTC

[section ""data" . GHC.Integer.Type.leInteger#_closure" {
     GHC.Integer.Type.leInteger#_closure:
         const GHC.Integer.Type.leInteger#_info;
 },
 GHC.Integer.Type.leInteger#_entry() //  [R2, R3]
         { info_tbl: [(c4fB,
                       label: GHC.Integer.Type.leInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4fB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4fC; else goto c4fD;
       c4fC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.leInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4fD: // global
           I64[Sp - 8] = block_c4fv_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4fv() //  [R1]
         { info_tbl: [(c4fv,
                       label: block_c4fv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4fv: // global
           if (R1 & 7 == 3) goto c4fz; else goto c4fy;
       c4fz: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4fy: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.094882749 UTC

[section ""data" . GHC.Integer.Type.leInteger_closure" {
     GHC.Integer.Type.leInteger_closure:
         const GHC.Integer.Type.leInteger_info;
 },
 GHC.Integer.Type.leInteger_entry() //  [R2, R3]
         { info_tbl: [(c4fQ,
                       label: GHC.Integer.Type.leInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4fQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4fR; else goto c4fS;
       c4fR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.leInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4fS: // global
           I64[Sp - 8] = block_c4fO_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4fO() //  [R1]
         { info_tbl: [(c4fO,
                       label: block_c4fO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4fO: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.096469173 UTC

[section ""data" . GHC.Integer.Type.geInteger#_closure" {
     GHC.Integer.Type.geInteger#_closure:
         const GHC.Integer.Type.geInteger#_info;
 },
 GHC.Integer.Type.geInteger#_entry() //  [R2, R3]
         { info_tbl: [(c4g6,
                       label: GHC.Integer.Type.geInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4g6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4g7; else goto c4g8;
       c4g7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.geInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4g8: // global
           I64[Sp - 8] = block_c4g0_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4g0() //  [R1]
         { info_tbl: [(c4g0,
                       label: block_c4g0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4g0: // global
           if (R1 & 7 == 1) goto c4g4; else goto c4g3;
       c4g4: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4g3: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.097841767 UTC

[section ""data" . GHC.Integer.Type.geInteger_closure" {
     GHC.Integer.Type.geInteger_closure:
         const GHC.Integer.Type.geInteger_info;
 },
 GHC.Integer.Type.geInteger_entry() //  [R2, R3]
         { info_tbl: [(c4gl,
                       label: GHC.Integer.Type.geInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4gl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4gm; else goto c4gn;
       c4gm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.geInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4gn: // global
           I64[Sp - 8] = block_c4gj_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4gj() //  [R1]
         { info_tbl: [(c4gj,
                       label: block_c4gj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4gj: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.099169785 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_$cmax_closure" {
     GHC.Integer.Type.$fOrdInteger_$cmax_closure:
         const GHC.Integer.Type.$fOrdInteger_$cmax_info;
 },
 GHC.Integer.Type.$fOrdInteger_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4gA,
                       label: GHC.Integer.Type.$fOrdInteger_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4gA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4gB; else goto c4gC;
       c4gB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$fOrdInteger_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4gC: // global
           I64[Sp - 24] = block_c4gv_info;
           _s3H2::P64 = R3;
           R3 = R3;
           _s3H1::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s3H1::P64;
           P64[Sp - 8] = _s3H2::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4gv() //  [R1]
         { info_tbl: [(c4gv,
                       label: block_c4gv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4gv: // global
           if (R1 == 1) goto c4gz; else goto c4gy;
       c4gz: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4gy: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.100826372 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_$cmin_closure" {
     GHC.Integer.Type.$fOrdInteger_$cmin_closure:
         const GHC.Integer.Type.$fOrdInteger_$cmin_info;
 },
 GHC.Integer.Type.$fOrdInteger_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4gS,
                       label: GHC.Integer.Type.$fOrdInteger_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4gS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4gT; else goto c4gU;
       c4gT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$fOrdInteger_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4gU: // global
           I64[Sp - 24] = block_c4gN_info;
           _s3H5::P64 = R3;
           R3 = R3;
           _s3H4::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s3H4::P64;
           P64[Sp - 8] = _s3H5::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4gN() //  [R1]
         { info_tbl: [(c4gN,
                       label: block_c4gN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4gN: // global
           if (R1 == 1) goto c4gR; else goto c4gQ;
       c4gR: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4gQ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.102054159 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_closure" {
     GHC.Integer.Type.$fOrdInteger_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Integer.Type.$fEqInteger_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.104689128 UTC

[section ""data" . GHC.Integer.Type.plusInteger_closure" {
     GHC.Integer.Type.plusInteger_closure:
         const GHC.Integer.Type.plusInteger_info;
         const 0;
 },
 GHC.Integer.Type.plusInteger_entry() //  [R2, R3]
         { info_tbl: [(c4hd,
                       label: GHC.Integer.Type.plusInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4hd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4he; else goto u4iN;
       c4he: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.plusInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u4iN: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c4h2() args: 0, res: 0, upd: 0;
     }
 },
 _c4h2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4h2: // global
           _s3H7::P64 = P64[Sp];
           I64[Sp] = block_c4h5_info;
           R1 = _s3H7::P64;
           if (R1 & 7 != 0) goto u4iR; else goto c4h6;
       u4iR: // global
           call _c4h5(R1) args: 0, res: 0, upd: 0;
       c4h6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4h5() //  [R1]
         { info_tbl: [(c4h5,
                       label: block_c4h5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4h5: // global
           _s3H8::P64 = P64[Sp + 8];
           _c4hc::P64 = R1 & 7;
           if (_c4hc::P64 < 3) goto u4iJ; else goto c4hb;
       u4iJ: // global
           if (_c4hc::P64 < 2) goto c4h9; else goto c4ha;
       c4h9: // global
           I64[Sp - 8] = block_c4hi_info;
           _s3H9::P64 = R1;
           _s3Ha::P64 = P64[R1 + 7];
           R1 = _s3H8::P64;
           P64[Sp] = _s3Ha::P64;
           P64[Sp + 8] = _s3H9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4iS; else goto c4hk;
       u4iS: // global
           call _c4hi(R1) args: 0, res: 0, upd: 0;
       c4hk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4ha: // global
           I64[Sp - 8] = block_c4ie_info;
           _s3H9::P64 = R1;
           _s3Hi::P64 = P64[R1 + 6];
           R1 = _s3H8::P64;
           P64[Sp] = _s3Hi::P64;
           P64[Sp + 8] = _s3H9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4iT; else goto c4ig;
       u4iT: // global
           call _c4ie(R1) args: 0, res: 0, upd: 0;
       c4ig: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4hb: // global
           R1 = _s3H8::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4hi() //  [R1]
         { info_tbl: [(c4hi,
                       label: block_c4hi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4hi: // global
           _c4iH::P64 = R1 & 7;
           if (_c4iH::P64 < 3) goto u4iK; else goto u4iO;
       u4iK: // global
           _s3Ha::P64 = P64[Sp + 8];
           if (_c4iH::P64 < 2) goto c4hv; else goto c4hD;
       c4hv: // global
           I64[Sp + 16] = block_c4ho_info;
           R4 = P64[R1 + 7];
           R3 = _s3Ha::P64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c4hD: // global
           I64[Sp] = block_c4hB_info;
           _s3He::P64 = P64[R1 + 6];
           R3 = _s3He::P64;
           R2 = _s3Ha::P64;
           P64[Sp + 16] = _s3He::P64;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u4iO: // global
           Sp = Sp + 16;
           call _c4iC() args: 0, res: 0, upd: 0;
     }
 },
 _c4ho() //  [R1]
         { info_tbl: [(c4ho,
                       label: block_c4ho_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ho: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4hy; else goto c4hx;
       c4hy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4hx: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4hB() //  [R1]
         { info_tbl: [(c4hB,
                       label: block_c4hB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4hB: // global
           _s3Ha::P64 = P64[Sp + 8];
           _s3He::P64 = P64[Sp + 16];
           _c4iI::P64 = R1 & 7;
           if (_c4iI::P64 < 3) goto u4iL; else goto c4i4;
       u4iL: // global
           if (_c4iI::P64 < 2) goto c4hO; else goto c4hV;
       c4hO: // global
           I64[Sp + 16] = block_c4hH_info;
           R3 = _s3Ha::P64;
           R2 = _s3He::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c4hV: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4i4: // global
           I64[Sp + 16] = block_c4hY_info;
           R3 = _s3He::P64;
           R2 = _s3Ha::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4hH() //  [R1]
         { info_tbl: [(c4hH,
                       label: block_c4hH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4hH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4hR; else goto c4hQ;
       c4hR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4hQ: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4hY() //  [R1]
         { info_tbl: [(c4hY,
                       label: block_c4hY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4hY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4i7; else goto c4i6;
       c4i7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4i6: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4ie() //  [R1]
         { info_tbl: [(c4ie,
                       label: block_c4ie_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ie: // global
           _c4iG::P64 = R1 & 7;
           if (_c4iG::P64 < 3) goto u4iM; else goto u4iP;
       u4iM: // global
           if (_c4iG::P64 < 2) goto c4im; else goto c4iv;
       c4im: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c4h2() args: 0, res: 0, upd: 0;
       c4iv: // global
           I64[Sp + 16] = block_c4ip_info;
           R4 = P64[R1 + 6];
           R3 = P64[Sp + 8];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       u4iP: // global
           Sp = Sp + 16;
           call _c4iC() args: 0, res: 0, upd: 0;
     }
 },
 _c4ip() //  [R1]
         { info_tbl: [(c4ip,
                       label: block_c4ip_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ip: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4iy; else goto c4ix;
       c4iy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ix: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4iC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4iC: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.108943289 UTC

[section ""data" . GHC.Integer.Type.minusInteger_closure" {
     GHC.Integer.Type.minusInteger_closure:
         const GHC.Integer.Type.minusInteger_info;
         const 0;
 },
 GHC.Integer.Type.minusInteger_entry() //  [R2, R3]
         { info_tbl: [(c4j4,
                       label: GHC.Integer.Type.minusInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4j4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4j5; else goto c4j6;
       c4j5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.minusInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4j6: // global
           I64[Sp - 16] = block_c4j2_info;
           _s3Hn::P64 = R2;
           R2 = R3;
           P64[Sp - 8] = _s3Hn::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4j2() //  [R1]
         { info_tbl: [(c4j2,
                       label: block_c4j2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4j2: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.110243969 UTC

[section ""data" . GHC.Integer.Type.complementInteger_closure" {
     GHC.Integer.Type.complementInteger_closure:
         const GHC.Integer.Type.complementInteger_info;
         const 0;
 },
 GHC.Integer.Type.complementInteger_entry() //  [R2]
         { info_tbl: [(c4je,
                       label: GHC.Integer.Type.complementInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4je: // global
           R3 = R2;
           R2 = GHC.Integer.Type.negativeOneInteger_closure+2;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.112206097 UTC

[section ""data" . GHC.Integer.Type.decodeDoubleInteger_closure" {
     GHC.Integer.Type.decodeDoubleInteger_closure:
         const GHC.Integer.Type.decodeDoubleInteger_info;
         const 0;
 },
 sat_s3HC_entry() //  [R1]
         { info_tbl: [(c4jv,
                       label: sat_s3HC_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4jv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4jL; else goto c4jM;
       c4jL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4jM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4jt_info;
           R2 = I64[R1 + 32];
           I64[Sp - 32] = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4jt() //  [R1]
         { info_tbl: [(c4jt,
                       label: block_c4jt_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4jt: // global
           I64[Sp] = block_c4jy_info;
           R2 = I64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4jy() //  [R1]
         { info_tbl: [(c4jy,
                       label: block_c4jy_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4jy: // global
           I64[Sp] = block_c4jC_info;
           R3 = GHC.Integer.Type.twoToTheThirtytwoInteger_closure+1;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4jC() //  [R1]
         { info_tbl: [(c4jC,
                       label: block_c4jC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4jC: // global
           I64[Sp] = block_c4jG_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4jG() //  [R1]
         { info_tbl: [(c4jG,
                       label: block_c4jG_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4jG: // global
           _s3Ht::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4jK_info;
           R2 = _s3Ht::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4jK() //  [R1]
         { info_tbl: [(c4jK,
                       label: block_c4jK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4jK: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.decodeDoubleInteger_entry() //  [D1]
         { info_tbl: [(c4jV,
                       label: GHC.Integer.Type.decodeDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 7} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4jV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4jW; else goto c4jX;
       c4jW: // global
           D1 = D1;
           R1 = GHC.Integer.Type.decodeDoubleInteger_closure;
           call (stg_gc_fun)(D1, R1) args: 8, res: 0, upd: 8;
       c4jX: // global
           I64[Sp - 8] = block_c4jl_info;
           D1 = D1;
           Sp = Sp - 8;
           call stg_decodeDouble_2Int#(D1) args: 8, res: 8, upd: 8;
     }
 },
 _c4jl() //  [R1, R2, R3, R4]
         { info_tbl: [(c4jl,
                       label: block_c4jl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4jl: // global
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           I64[Sp] = R1;
           Sp = Sp - 32;
           call _c4jm() args: 0, res: 0, upd: 0;
     }
 },
 _c4jm() //  []
         { info_tbl: [(c4jm,
                       label: block_c4jm_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4jm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4k0; else goto c4jZ;
       c4k0: // global
           HpAlloc = 40;
           I64[Sp] = block_c4jm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4jZ: // global
           I64[Hp - 32] = sat_s3HC_info;
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = I64[Sp + 24];
           R1 = Hp - 32;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.115535644 UTC

[section ""data" . GHC.Integer.Type.smallShiftLPositive_closure" {
     GHC.Integer.Type.smallShiftLPositive_closure:
         const GHC.Integer.Type.smallShiftLPositive_info;
 },
 f2_s3HH_entry() //  [R1, R2, R3]
         { info_tbl: [(c4ko,
                       label: f2_s3HH_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ko: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4kp; else goto c4kq;
       c4kp: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4kq: // global
           I64[Sp - 40] = block_c4kh_info;
           _s3HH::P64 = R1;
           _s3HF::I64 = I64[R1 + 6];
           _s3HG::I64 = I64[R1 + 14];
           R1 = R3;
           I64[Sp - 32] = _s3HF::I64;
           I64[Sp - 24] = _s3HG::I64;
           P64[Sp - 16] = _s3HH::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u4kW; else goto c4ki;
       u4kW: // global
           call _c4kh(R1) args: 0, res: 0, upd: 0;
       c4ki: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4kh() //  [R1]
         { info_tbl: [(c4kh,
                       label: block_c4kh_info
                       rep:StackRep [True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4kh: // global
           if (R1 & 7 == 1) goto c4kl; else goto c4km;
       c4kl: // global
           I64[Sp] = block_c4kw_info;
           R3 = P64[R1 + 7];
           _s3HL::I64 = I64[R1 + 15];
           R2 = _s3HL::I64 >> I64[Sp + 16];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s3HL::I64;
           call f2_s3HH_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
       c4km: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4kP; else goto c4kO;
       c4kP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4kO: // global
           _s3HR::I64 = I64[Sp + 32];
           if (_s3HR::I64 != 0) goto c4kU; else goto c4kV;
       c4kU: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s3HR::I64;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4kV: // global
           Hp = Hp - 24;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4kw() //  [R1]
         { info_tbl: [(c4kw,
                       label: block_c4kw_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4kw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4kK; else goto c4kJ;
       c4kK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4kJ: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = (I64[Sp + 24] << I64[Sp + 8]) | I64[Sp + 32];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Integer.Type.smallShiftLPositive_entry() //  [R2, R3]
         { info_tbl: [(c4l0,
                       label: GHC.Integer.Type.smallShiftLPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4l0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4l4; else goto c4l3;
       c4l4: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.smallShiftLPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4l3: // global
           if (R3 == 0) goto c4kZ; else goto c4kY;
       c4kZ: // global
           Hp = Hp - 24;
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4kY: // global
           I64[Hp - 16] = f2_s3HH_info;
           I64[Hp - 8] = R3;
           I64[Hp] = 64 - R3;
           R3 = R2;
           R2 = 0;
           R1 = Hp - 14;
           call f2_s3HH_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.119392932 UTC

[section ""data" . GHC.Integer.Type.smallShiftRPositive_closure" {
     GHC.Integer.Type.smallShiftRPositive_closure:
         const GHC.Integer.Type.smallShiftRPositive_info;
 },
 GHC.Integer.Type.smallShiftRPositive_entry() //  [R2, R3]
         { info_tbl: [(c4lc,
                       label: GHC.Integer.Type.smallShiftRPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ld; else goto c4le;
       c4ld: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.smallShiftRPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4le: // global
           I64[Sp - 16] = block_c4l9_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4lY; else goto c4la;
       u4lY: // global
           call _c4l9(R1) args: 0, res: 0, upd: 0;
       c4la: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4l9() //  [R1]
         { info_tbl: [(c4l9,
                       label: block_c4l9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4l9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lj; else goto c4li;
       c4lj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4li: // global
           _s3HV::I64 = I64[Sp + 8];
           if (_s3HV::I64 == 0) goto c4lT; else goto c4lr;
       c4lT: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lr: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_c4lp_info;
           R3 = 64 - _s3HV::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4lp() //  [R1]
         { info_tbl: [(c4lp,
                       label: block_c4lp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lp: // global
           if (R1 & 7 == 1) goto c4ly; else goto u4lW;
       c4ly: // global
           I64[Sp] = block_c4lv_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u4lZ; else goto c4lz;
       u4lZ: // global
           call _c4lv(R1) args: 0, res: 0, upd: 0;
       c4lz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4lW: // global
           Sp = Sp + 8;
           call _c4lQ() args: 0, res: 0, upd: 0;
     }
 },
 _c4lv() //  [R1]
         { info_tbl: [(c4lv,
                       label: block_c4lv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lv: // global
           if (R1 & 7 == 1) goto c4lF; else goto u4lX;
       c4lF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lI; else goto c4lH;
       c4lI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4lH: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4lX: // global
           Sp = Sp + 8;
           call _c4lQ() args: 0, res: 0, upd: 0;
     }
 },
 _c4lQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lQ: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.122592977 UTC

[section ""data" . GHC.Integer.Type.shiftRPositive_closure" {
     GHC.Integer.Type.shiftRPositive_closure:
         const GHC.Integer.Type.shiftRPositive_info;
 },
 GHC.Integer.Type.shiftRPositive_entry() //  [R2, R3]
         { info_tbl: [(c4md,
                       label: GHC.Integer.Type.shiftRPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4md: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4me; else goto u4mu;
       c4me: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftRPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u4mu: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c4m3() args: 0, res: 0, upd: 0;
     }
 },
 _c4m3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m3: // global
           _s3I3::P64 = P64[Sp];
           I64[Sp] = block_c4m6_info;
           R1 = _s3I3::P64;
           if (R1 & 7 != 0) goto u4mw; else goto c4m7;
       u4mw: // global
           call _c4m6(R1) args: 0, res: 0, upd: 0;
       c4m7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m6() //  [R1]
         { info_tbl: [(c4m6,
                       label: block_c4m6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m6: // global
           if (R1 & 7 == 1) goto c4ma; else goto c4mb;
       c4ma: // global
           _s3I4::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s3I4::I64, 64)) goto c4mm; else goto c4mn;
       c4mm: // global
           R3 = _s3I4::I64;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallShiftRPositive_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       c4mn: // global
           P64[Sp] = P64[R1 + 7];
           I64[Sp + 8] = _s3I4::I64 - 64;
           call _c4m3() args: 0, res: 0, upd: 0;
       c4mb: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.12463661 UTC

[section ""data" . GHC.Integer.Type.shiftRInteger_closure" {
     GHC.Integer.Type.shiftRInteger_closure:
         const GHC.Integer.Type.shiftRInteger_info;
         const 0;
 },
 GHC.Integer.Type.shiftRInteger_entry() //  [R2, R3]
         { info_tbl: [(c4mL,
                       label: GHC.Integer.Type.shiftRInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mM; else goto c4mN;
       c4mM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftRInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mN: // global
           I64[Sp - 16] = block_c4mD_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4n8; else goto c4mE;
       u4n8: // global
           call _c4mD(R1) args: 0, res: 0, upd: 0;
       c4mE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mD() //  [R1]
         { info_tbl: [(c4mD,
                       label: block_c4mD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mD: // global
           _c4mK::P64 = R1 & 7;
           if (_c4mK::P64 < 3) goto u4n7; else goto c4mJ;
       u4n7: // global
           if (_c4mK::P64 < 2) goto c4mH; else goto c4mI;
       c4mH: // global
           R3 = I64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRPositive_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
       c4mI: // global
           I64[Sp] = block_c4mT_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
       c4mJ: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4mT() //  [R1]
         { info_tbl: [(c4mT,
                       label: block_c4mT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mT: // global
           _s3Ib::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4mX_info;
           R3 = _s3Ib::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4mX() //  [R1]
         { info_tbl: [(c4mX,
                       label: block_c4mX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mX: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.127460285 UTC

[section ""data" . GHC.Integer.Type.shiftLPositive_closure" {
     GHC.Integer.Type.shiftLPositive_closure:
         const GHC.Integer.Type.shiftLPositive_info;
 },
 GHC.Integer.Type.shiftLPositive_entry() //  [R2, R3]
         { info_tbl: [(c4nt,
                       label: GHC.Integer.Type.shiftLPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nu; else goto u4nz;
       c4nu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftLPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u4nz: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c4na() args: 0, res: 0, upd: 0;
     }
 },
 _c4na() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4na: // global
           _s3Ih::P64 = P64[Sp];
           _s3Ii::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s3Ii::I64, 64)) goto c4nr; else goto c4ns;
       c4nr: // global
           R3 = _s3Ii::I64;
           R2 = _s3Ih::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       c4ns: // global
           I64[Sp] = block_c4nh_info;
           R1 = _s3Ih::P64;
           if (R1 & 7 != 0) goto u4nB; else goto c4ni;
       u4nB: // global
           call _c4nh(R1) args: 0, res: 0, upd: 0;
       c4ni: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nh() //  [R1]
         { info_tbl: [(c4nh,
                       label: block_c4nh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ny; else goto c4nx;
       c4ny: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nx: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           P64[Sp] = Hp - 15;
           I64[Sp + 8] = I64[Sp + 8] - 64;
           call _c4na() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.129803818 UTC

[section ""data" . GHC.Integer.Type.shiftLInteger_closure" {
     GHC.Integer.Type.shiftLInteger_closure:
         const GHC.Integer.Type.shiftLInteger_info;
 },
 GHC.Integer.Type.shiftLInteger_entry() //  [R2, R3]
         { info_tbl: [(c4nQ,
                       label: GHC.Integer.Type.shiftLInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nR; else goto c4nS;
       c4nR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftLInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nS: // global
           I64[Sp - 16] = block_c4nI_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4oj; else goto c4nJ;
       u4oj: // global
           call _c4nI(R1) args: 0, res: 0, upd: 0;
       c4nJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nI() //  [R1]
         { info_tbl: [(c4nI,
                       label: block_c4nI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nI: // global
           _c4nP::P64 = R1 & 7;
           if (_c4nP::P64 < 3) goto u4oi; else goto c4nO;
       u4oi: // global
           _s3Io::I64 = I64[Sp + 8];
           if (_c4nP::P64 < 2) goto c4nM; else goto c4nN;
       c4nM: // global
           I64[Sp + 8] = block_c4nV_info;
           R3 = _s3Io::I64;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLPositive_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
       c4nN: // global
           I64[Sp + 8] = block_c4o6_info;
           R3 = _s3Io::I64;
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLPositive_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
       c4nO: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4nV() //  [R1]
         { info_tbl: [(c4nV,
                       label: block_c4nV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4o3; else goto c4o2;
       c4o3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4o2: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4o6() //  [R1]
         { info_tbl: [(c4o6,
                       label: block_c4o6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oe; else goto c4od;
       c4oe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4od: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.132597371 UTC

[section ""data" . GHC.Integer.Type.some_closure" {
     GHC.Integer.Type.some_closure:
         const GHC.Integer.Type.some_info;
 },
 GHC.Integer.Type.some_entry() //  [R2, R3]
         { info_tbl: [(c4ov,
                       label: GHC.Integer.Type.some_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ov: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ow; else goto c4ox;
       c4ow: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.some_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ox: // global
           I64[Sp - 16] = block_c4oo_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4oP; else goto c4op;
       u4oP: // global
           call _c4oo(R1) args: 0, res: 0, upd: 0;
       c4op: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oo() //  [R1]
         { info_tbl: [(c4oo,
                       label: block_c4oo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oo: // global
           _s3Iu::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c4os; else goto c4ot;
       c4os: // global
           Hp = Hp + 24;
           _s3Iw::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4oI; else goto c4oC;
       c4oC: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = _s3Iw::P64;
           I64[Hp] = _s3Iu::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ot: // global
           Hp = Hp + 24;
           _s3Iw::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4oI; else goto c4oH;
       c4oI: // global
           HpAlloc = 24;
           R1 = _s3Iw::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4oH: // global
           if (_s3Iu::I64 == 0) goto c4oO; else goto c4oN;
       c4oO: // global
           Hp = Hp - 24;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oN: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s3Iu::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.135183403 UTC

[section ""data" . GHC.Integer.Type.quotRemPositive_g_closure" {
     GHC.Integer.Type.quotRemPositive_g_closure:
         const GHC.Integer.Type.quotRemPositive_g_info;
 },
 GHC.Integer.Type.quotRemPositive_g_entry() //  [R2, R3, R4]
         { info_tbl: [(c4p1,
                       label: GHC.Integer.Type.quotRemPositive_g_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4p2; else goto u4pC;
       c4p2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemPositive_g_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u4pC: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4oR() args: 0, res: 0, upd: 0;
     }
 },
 _c4oR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oR: // global
           I64[Sp - 8] = block_c4oU_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pF; else goto c4oV;
       u4pF: // global
           call _c4oU(R1) args: 0, res: 0, upd: 0;
       c4oV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oU() //  [R1]
         { info_tbl: [(c4oU,
                       label: block_c4oU_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oU: // global
           _s3IC::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c4oY; else goto c4oZ;
       c4oY: // global
           I64[Sp] = block_c4p6_info;
           R1 = _s3IC::P64;
           if (R1 & 7 != 0) goto u4pG; else goto c4p8;
       u4pG: // global
           call _c4p6(R1) args: 0, res: 0, upd: 0;
       c4p8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4oZ: // global
           I64[Sp - 8] = block_c4pf_info;
           _s3IF::P64 = P64[R1 + 6];
           R3 = _s3IF::P64;
           R2 = _s3IC::P64;
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 16] = _s3IF::P64;
           Sp = Sp - 8;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4p6() //  [R1]
         { info_tbl: [(c4p6,
                       label: block_c4p6_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p6: // global
           R2 = R1;
           R1 = I64[Sp + 8];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4pf() //  [R1]
         { info_tbl: [(c4pf,
                       label: block_c4pf_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pf: // global
           _s3IC::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c4pv; else goto c4pn;
       c4pv: // global
           I64[Sp + 16] = I64[Sp + 16] << 1;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _s3IC::P64;
           Sp = Sp + 16;
           call _c4oR() args: 0, res: 0, upd: 0;
       c4pn: // global
           I64[Sp] = block_c4pk_info;
           R3 = P64[Sp + 24];
           R2 = _s3IC::P64;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4pk() //  [R1]
         { info_tbl: [(c4pk,
                       label: block_c4pk_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pk: // global
           I64[Sp + 16] = (I64[Sp + 16] << 1) + 1;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call _c4oR() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.140581685 UTC

[section ""data" . GHC.Integer.Type.quotRemPositive_closure" {
     GHC.Integer.Type.quotRemPositive_closure:
         const GHC.Integer.Type.quotRemPositive_info;
 },
 sat_s3IW_entry() //  [R1]
         { info_tbl: [(c4qb,
                       label: sat_s3IW_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qc; else goto c4qd;
       c4qc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4qd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call mkSubtractors_s3IR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3IU_entry() //  [R1]
         { info_tbl: [(c4qi,
                       label: sat_s3IU_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qj; else goto c4qk;
       c4qj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4qk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 mkSubtractors_s3IR_entry() //  [R1, R2]
         { info_tbl: [(c4qo,
                       label: mkSubtractors_s3IR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qo: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4qs; else goto c4qr;
       c4qs: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qr: // global
           if (R2 == 0) goto c4qn; else goto c4qm;
       c4qn: // global
           _s3IQ::P64 = P64[R1 + 15];
           Hp = Hp - 88;
           R1 = _s3IQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qm: // global
           _s3IO::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s3IW_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s3IU_info;
           P64[Hp - 32] = _s3IO::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 subtractors_s3IP_entry() //  [R1]
         { info_tbl: [(c4qu,
                       label: subtractors_s3IP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qu: // global
           _s3IP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4qv; else goto c4qw;
       c4qw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4qy; else goto c4qx;
       c4qy: // global
           HpAlloc = 48;
           goto c4qv;
       c4qv: // global
           R1 = _s3IP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4qx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s3IP::P64;
           _s3IO::P64 = P64[_s3IP::P64 + 16];
           I64[Hp - 40] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 32] = _s3IO::P64;
           P64[Hp - 24] = GHC.Integer.Type.Nil_closure+1;
           I64[Hp - 16] = mkSubtractors_s3IR_info;
           P64[Hp - 8] = _s3IO::P64;
           P64[Hp] = Hp - 38;
           R2 = 63;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call mkSubtractors_s3IR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3Jc_entry() //  [R1]
         { info_tbl: [(c4qZ,
                       label: sat_s3Jc_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4r0; else goto c4r1;
       c4r0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4r1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3Ji_entry() //  [R1]
         { info_tbl: [(c4rf,
                       label: sat_s3Ji_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rg; else goto c4rh;
       c4rg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3Jm_entry() //  [R1]
         { info_tbl: [(c4rr,
                       label: sat_s3Jm_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rs; else goto c4rt;
       c4rs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 f2_s3IX_entry() //  [R1, R2]
         { info_tbl: [(c4ry,
                       label: f2_s3IX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ry: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4rz; else goto c4rA;
       c4rz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rA: // global
           I64[Sp - 24] = block_c4qE_info;
           _s3IX::P64 = R1;
           _s3IP::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s3IP::P64;
           P64[Sp - 8] = _s3IX::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4s9; else goto c4qF;
       u4s9: // global
           call _c4qE(R1) args: 0, res: 0, upd: 0;
       c4qF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qE() //  [R1]
         { info_tbl: [(c4qE,
                       label: block_c4qE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qE: // global
           if (R1 & 7 == 1) goto c4rv; else goto c4rw;
       c4rv: // global
           I64[Sp] = block_c4qJ_info;
           R2 = P64[R1 + 7];
           _s3J0::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s3J0::I64;
           call f2_s3IX_entry(R2, R1) args: 8, res: 8, upd: 8;
       c4rw: // global
           R2 = GHC.Integer.Type.None_closure+2;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4qJ() //  [R1, R2]
         { info_tbl: [(c4qJ,
                       label: block_c4qJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qJ: // global
           I64[Sp - 8] = block_c4qL_info;
           _s3J3::P64 = R1;
           R1 = R2;
           P64[Sp] = _s3J3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4s5; else goto c4qM;
       u4s5: // global
           call _c4qL(R1) args: 0, res: 0, upd: 0;
       c4qM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qL() //  [R1]
         { info_tbl: [(c4qL,
                       label: block_c4qL_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qL: // global
           _s3IP::P64 = P64[Sp + 16];
           _s3J0::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c4rE; else goto c4rL;
       c4rE: // global
           Hp = Hp + 24;
           _s3J5::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4rO; else goto c4rG;
       c4rG: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = _s3J5::P64;
           I64[Hp] = _s3J0::I64;
           I64[Sp] = block_c4qR_info;
           R4 = Hp - 15;
           R3 = _s3IP::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
       c4rL: // global
           Hp = Hp + 24;
           _s3J5::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4rO; else goto c4rN;
       c4rO: // global
           HpAlloc = 24;
           R1 = _s3J5::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rN: // global
           if (_s3J0::I64 == 0) goto c4rU; else goto c4rQ;
       c4rU: // global
           Hp = Hp - 24;
           I64[Sp] = block_c4rj_info;
           R4 = GHC.Integer.Type.None_closure+2;
           R3 = _s3IP::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
       c4rQ: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s3J0::I64;
           I64[Sp] = block_c4r7_info;
           R4 = Hp - 15;
           R3 = _s3IP::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qR() //  [R1, R2]
         { info_tbl: [(c4qR,
                       label: block_c4qR_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qR: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c4qS() args: 0, res: 0, upd: 0;
     }
 },
 _c4qS() //  []
         { info_tbl: [(c4qS,
                       label: block_c4qS_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4rK; else goto c4rJ;
       c4rK: // global
           HpAlloc = 32;
           I64[Sp] = block_c4qS_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4rJ: // global
           I64[Hp - 24] = sat_s3Jc_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4rj() //  [R1, R2]
         { info_tbl: [(c4rj,
                       label: block_c4rj_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rj: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c4rk() args: 0, res: 0, upd: 0;
     }
 },
 _c4rk() //  []
         { info_tbl: [(c4rk,
                       label: block_c4rk_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4rX; else goto c4rW;
       c4rX: // global
           HpAlloc = 32;
           I64[Sp] = block_c4rk_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4rW: // global
           I64[Hp - 24] = sat_s3Jm_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4r7() //  [R1, R2]
         { info_tbl: [(c4r7,
                       label: block_c4r7_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r7: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c4r8() args: 0, res: 0, upd: 0;
     }
 },
 _c4r8() //  []
         { info_tbl: [(c4r8,
                       label: block_c4r8_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4rT; else goto c4rS;
       c4rT: // global
           HpAlloc = 32;
           I64[Sp] = block_c4r8_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4rS: // global
           I64[Hp - 24] = sat_s3Ji_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3Jr_entry() //  [R1]
         { info_tbl: [(c4sg,
                       label: sat_s3Jr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sh; else goto c4si;
       c4sh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4si: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.digitsMaybeZeroToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3Jq_entry() //  [R1]
         { info_tbl: [(c4sn,
                       label: sat_s3Jq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4so; else goto c4sp;
       c4so: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4sp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.digitsMaybeZeroToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.quotRemPositive_entry() //  [R2, R3]
         { info_tbl: [(c4sq,
                       label: GHC.Integer.Type.quotRemPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sr; else goto c4ss;
       c4sr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ss: // global
           I64[Sp - 16] = block_c4pO_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sz; else goto c4pP;
       u4sz: // global
           call _c4pO(R1) args: 0, res: 0, upd: 0;
       c4pP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pO() //  [R1]
         { info_tbl: [(c4pO,
                       label: block_c4pO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4sv; else goto c4su;
       c4sv: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4su: // global
           I64[Hp - 32] = subtractors_s3IP_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = f2_s3IX_info;
           P64[Hp] = Hp - 32;
           _s3IM::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4sa_info;
           R2 = _s3IM::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call f2_s3IX_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sa() //  [R1, R2]
         { info_tbl: [(c4sa,
                       label: block_c4sa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sa: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4sy; else goto c4sx;
       c4sy: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4sx: // global
           I64[Hp - 40] = sat_s3Jr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s3Jq_info;
           P64[Hp] = R1;
           R2 = Hp - 40;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.149316314 UTC

[section ""data" . GHC.Integer.Type.quotRemInteger_closure" {
     GHC.Integer.Type.quotRemInteger_closure:
         const GHC.Integer.Type.quotRemInteger_info;
 },
 sat_s3JE_entry() //  [R1]
         { info_tbl: [(c4t5,
                       label: sat_s3JE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t6; else goto c4t7;
       c4t6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4t7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3JM_entry() //  [R1]
         { info_tbl: [(c4tl,
                       label: sat_s3JM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tm; else goto c4tn;
       c4tm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4tn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3JL_entry() //  [R1]
         { info_tbl: [(c4ts,
                       label: sat_s3JL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ts: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tt; else goto c4tu;
       c4tt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4tu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3JR_entry() //  [R1]
         { info_tbl: [(c4tD,
                       label: sat_s3JR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tE; else goto c4tF;
       c4tE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4tF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.quotRemInteger_entry() //  [R2, R3]
         { info_tbl: [(c4tK,
                       label: GHC.Integer.Type.quotRemInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tL; else goto c4tM;
       c4tL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tM: // global
           I64[Sp - 16] = block_c4sE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uC; else goto c4sF;
       u4uC: // global
           call _c4sE(R1) args: 0, res: 0, upd: 0;
       c4sF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sE() //  [R1]
         { info_tbl: [(c4sE,
                       label: block_c4sE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sE: // global
           _s3Jt::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c4tI; else goto c4tH;
       c4tI: // global
           I64[Sp + 8] = block_c4um_info;
           R1 = _s3Jt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4uy; else goto c4uo;
       u4uy: // global
           call _c4um() args: 0, res: 0, upd: 0;
       c4uo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4tH: // global
           I64[Sp] = block_c4sJ_info;
           _s3Ju::P64 = R1;
           R1 = _s3Jt::P64;
           P64[Sp + 8] = _s3Ju::P64;
           if (R1 & 7 != 0) goto u4ux; else goto c4sK;
       u4ux: // global
           call _c4sJ(R1) args: 0, res: 0, upd: 0;
       c4sK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4um() //  []
         { info_tbl: [(c4um,
                       label: block_c4um_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4um: // global
           R2 = GHC.Integer.Type.Naught_closure+3;
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4sJ() //  [R1]
         { info_tbl: [(c4sJ,
                       label: block_c4sJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sJ: // global
           if (R1 & 7 == 3) goto c4uj; else goto c4tQ;
       c4uj: // global
           R2 = GHC.Integer.Type.errorInteger_closure+1;
           R1 = GHC.Integer.Type.errorInteger_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4tQ: // global
           I64[Sp] = block_c4sO_info;
           _s3Jv::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s3Jv::P64;
           if (R1 & 7 != 0) goto u4uz; else goto c4sP;
       u4uz: // global
           call _c4sO(R1) args: 0, res: 0, upd: 0;
       c4sP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sO() //  [R1]
         { info_tbl: [(c4sO,
                       label: block_c4sO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sO: // global
           _s3Jv::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c4tT; else goto c4u4;
       c4tT: // global
           I64[Sp] = block_c4sT_info;
           _s3Jx::P64 = P64[R1 + 7];
           R1 = _s3Jv::P64;
           P64[Sp + 8] = _s3Jx::P64;
           if (R1 & 7 != 0) goto u4uA; else goto c4sU;
       u4uA: // global
           call _c4sT(R1) args: 0, res: 0, upd: 0;
       c4sU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4u4: // global
           I64[Sp] = block_c4ta_info;
           _s3JF::P64 = P64[R1 + 6];
           R1 = _s3Jv::P64;
           P64[Sp + 8] = _s3JF::P64;
           if (R1 & 7 != 0) goto u4uB; else goto c4tb;
       u4uB: // global
           call _c4ta(R1) args: 0, res: 0, upd: 0;
       c4tb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sT() //  [R1]
         { info_tbl: [(c4sT,
                       label: block_c4sT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sT: // global
           _s3Jx::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c4tX; else goto c4tZ;
       c4tX: // global
           R3 = P64[R1 + 7];
           R2 = _s3Jx::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c4tZ: // global
           I64[Sp + 8] = block_c4sZ_info;
           R3 = P64[R1 + 6];
           R2 = _s3Jx::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4sZ() //  [R1, R2]
         { info_tbl: [(c4sZ,
                       label: block_c4sZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4u2; else goto c4u1;
       c4u2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4u1: // global
           I64[Hp - 16] = sat_s3JE_info;
           P64[Hp] = R1;
           R2 = R2;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4ta() //  [R1]
         { info_tbl: [(c4ta,
                       label: block_c4ta_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ta: // global
           _s3JF::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c4u7; else goto c4uc;
       c4u7: // global
           I64[Sp + 8] = block_c4tf_info;
           R3 = P64[R1 + 7];
           R2 = _s3JF::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       c4uc: // global
           I64[Sp + 8] = block_c4tx_info;
           R3 = P64[R1 + 6];
           R2 = _s3JF::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4tf() //  [R1, R2]
         { info_tbl: [(c4tf,
                       label: block_c4tf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4ua; else goto c4u9;
       c4ua: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4u9: // global
           I64[Hp - 40] = sat_s3JM_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s3JL_info;
           P64[Hp] = R1;
           R2 = Hp - 40;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4tx() //  [R1, R2]
         { info_tbl: [(c4tx,
                       label: block_c4tx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4uf; else goto c4ue;
       c4uf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4ue: // global
           I64[Hp - 16] = sat_s3JR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.154805557 UTC

[section ""data" . GHC.Integer.Type.divModInteger_closure" {
     GHC.Integer.Type.divModInteger_closure:
         const GHC.Integer.Type.divModInteger_info;
         const 0;
 },
 sat_s3K3_entry() //  [R1]
         { info_tbl: [(c4v4,
                       label: sat_s3K3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4v5; else goto c4v6;
       c4v5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4v6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3K2_entry() //  [R1]
         { info_tbl: [(c4vb,
                       label: sat_s3K2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vc; else goto c4vd;
       c4vc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4vd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Integer.Type.oneInteger_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.divModInteger_entry() //  [R2, R3]
         { info_tbl: [(c4ve,
                       label: GHC.Integer.Type.divModInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ve: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4vf; else goto c4vg;
       c4vf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.divModInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vg: // global
           I64[Sp - 16] = block_c4uH_info;
           _s3JU::P64 = R3;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = _s3JU::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uH() //  [R1, R2]
         { info_tbl: [(c4uH,
                       label: block_c4uH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uH: // global
           I64[Sp - 16] = block_c4uJ_info;
           _s3JX::P64 = R2;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = _s3JX::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uJ() //  [R1]
         { info_tbl: [(c4uJ,
                       label: block_c4uJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uJ: // global
           I64[Sp] = block_c4uN_info;
           R2 = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uN() //  [R1]
         { info_tbl: [(c4uN,
                       label: block_c4uN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uN: // global
           I64[Sp - 8] = block_c4uR_info;
           R2 = P64[Sp + 8];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uR() //  [R1]
         { info_tbl: [(c4uR,
                       label: block_c4uR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uR: // global
           _s3K0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4uV_info;
           R3 = _s3K0::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uV() //  [R1]
         { info_tbl: [(c4uV,
                       label: block_c4uV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uV: // global
           _s3JW::P64 = P64[Sp + 16];
           _s3JX::P64 = P64[Sp + 8];
           if (R1 == 1) goto c4vp; else goto c4vo;
       c4vp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4vs; else goto c4vr;
       c4vs: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4vr: // global
           I64[Hp - 48] = sat_s3K3_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s3JX::P64;
           I64[Hp - 16] = sat_s3K2_info;
           P64[Hp] = _s3JW::P64;
           R2 = Hp - 48;
           R1 = Hp - 16;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4vo: // global
           R2 = _s3JX::P64;
           R1 = _s3JW::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.157427054 UTC

[section ""data" . GHC.Integer.Type.divInteger_closure" {
     GHC.Integer.Type.divInteger_closure:
         const GHC.Integer.Type.divInteger_info;
         const 0;
 },
 GHC.Integer.Type.divInteger_entry() //  [R2, R3]
         { info_tbl: [(c4vz,
                       label: GHC.Integer.Type.divInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4vA; else goto c4vB;
       c4vA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.divInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vB: // global
           I64[Sp - 8] = block_c4vx_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vx() //  [R1]
         { info_tbl: [(c4vx,
                       label: block_c4vx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vx: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.158987273 UTC

[section ""data" . GHC.Integer.Type.modInteger_closure" {
     GHC.Integer.Type.modInteger_closure:
         const GHC.Integer.Type.modInteger_info;
         const 0;
 },
 GHC.Integer.Type.modInteger_entry() //  [R2, R3]
         { info_tbl: [(c4vJ,
                       label: GHC.Integer.Type.modInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4vK; else goto c4vL;
       c4vK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.modInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vL: // global
           I64[Sp - 8] = block_c4vH_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vH() //  [R2]
         { info_tbl: [(c4vH,
                       label: block_c4vH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vH: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.160267773 UTC

[section ""data" . GHC.Integer.Type.quotInteger_closure" {
     GHC.Integer.Type.quotInteger_closure:
         const GHC.Integer.Type.quotInteger_info;
 },
 GHC.Integer.Type.quotInteger_entry() //  [R2, R3]
         { info_tbl: [(c4vT,
                       label: GHC.Integer.Type.quotInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4vU; else goto c4vV;
       c4vU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vV: // global
           I64[Sp - 8] = block_c4vR_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vR() //  [R1]
         { info_tbl: [(c4vR,
                       label: block_c4vR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vR: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.162294504 UTC

[section ""data" . GHC.Integer.Type.remInteger_closure" {
     GHC.Integer.Type.remInteger_closure:
         const GHC.Integer.Type.remInteger_info;
 },
 GHC.Integer.Type.remInteger_entry() //  [R2, R3]
         { info_tbl: [(c4w3,
                       label: GHC.Integer.Type.remInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4w3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4w4; else goto c4w5;
       c4w4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.remInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4w5: // global
           I64[Sp - 8] = block_c4w1_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4w1() //  [R2]
         { info_tbl: [(c4w1,
                       label: block_c4w1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4w1: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.164043475 UTC

[section ""data" . GHC.Integer.Type.andDigits_closure" {
     GHC.Integer.Type.andDigits_closure:
         const GHC.Integer.Type.andDigits_info;
 },
 GHC.Integer.Type.andDigits_entry() //  [R2, R3]
         { info_tbl: [(c4wi,
                       label: GHC.Integer.Type.andDigits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wj; else goto c4wk;
       c4wj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wk: // global
           I64[Sp - 16] = block_c4wb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wX; else goto c4wc;
       u4wX: // global
           call _c4wb(R1) args: 0, res: 0, upd: 0;
       c4wc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wb() //  [R1]
         { info_tbl: [(c4wb,
                       label: block_c4wb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wb: // global
           _s3Kp::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c4wf; else goto c4wg;
       c4wf: // global
           I64[Sp - 8] = block_c4wn_info;
           _s3Ks::P64 = P64[R1 + 7];
           _s3Kr::I64 = I64[R1 + 15];
           R1 = _s3Kp::P64;
           P64[Sp] = _s3Ks::P64;
           I64[Sp + 8] = _s3Kr::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wV; else goto c4wp;
       u4wV: // global
           call _c4wn(R1) args: 0, res: 0, upd: 0;
       c4wp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4wg: // global
           I64[Sp + 8] = block_c4wN_info;
           R1 = _s3Kp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4wW; else goto c4wP;
       u4wW: // global
           call _c4wN() args: 0, res: 0, upd: 0;
       c4wP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wn() //  [R1]
         { info_tbl: [(c4wn,
                       label: block_c4wn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wn: // global
           if (R1 & 7 == 1) goto c4wD; else goto c4wK;
       c4wD: // global
           I64[Sp] = block_c4wt_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c4wK: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4wt() //  [R1]
         { info_tbl: [(c4wt,
                       label: block_c4wt_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wG; else goto c4wF;
       c4wG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wF: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] & I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4wN() //  []
         { info_tbl: [(c4wN,
                       label: block_c4wN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wN: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.167392497 UTC

[section ""data" . GHC.Integer.Type.andDigitsOnes_closure" {
     GHC.Integer.Type.andDigitsOnes_closure:
         const GHC.Integer.Type.andDigitsOnes_info;
 },
 GHC.Integer.Type.andDigitsOnes_entry() //  [R2, R3]
         { info_tbl: [(c4x9,
                       label: GHC.Integer.Type.andDigitsOnes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4xa; else goto c4xb;
       c4xa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andDigitsOnes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xb: // global
           I64[Sp - 16] = block_c4x2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xH; else goto c4x3;
       u4xH: // global
           call _c4x2(R1) args: 0, res: 0, upd: 0;
       c4x3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4x2() //  [R1]
         { info_tbl: [(c4x2,
                       label: block_c4x2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x2: // global
           _s3KA::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c4x6; else goto c4x7;
       c4x6: // global
           I64[Sp - 8] = block_c4xe_info;
           _s3KD::P64 = P64[R1 + 7];
           _s3KC::I64 = I64[R1 + 15];
           R1 = _s3KA::P64;
           P64[Sp] = _s3KD::P64;
           I64[Sp + 8] = _s3KC::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xG; else goto c4xg;
       u4xG: // global
           call _c4xe(R1) args: 0, res: 0, upd: 0;
       c4xg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4x7: // global
           R1 = _s3KA::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4xe() //  [R1]
         { info_tbl: [(c4xe,
                       label: block_c4xe_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xe: // global
           if (R1 & 7 == 1) goto c4xu; else goto c4xB;
       c4xu: // global
           I64[Sp] = block_c4xk_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c4xB: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4xk() //  [R1]
         { info_tbl: [(c4xk,
                       label: block_c4xk_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4xx; else goto c4xw;
       c4xx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xw: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] & I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.169883899 UTC

[section ""data" . GHC.Integer.Type.orDigits_closure" {
     GHC.Integer.Type.orDigits_closure:
         const GHC.Integer.Type.orDigits_info;
 },
 GHC.Integer.Type.orDigits_entry() //  [R2, R3]
         { info_tbl: [(c4xT,
                       label: GHC.Integer.Type.orDigits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4xU; else goto c4xV;
       c4xU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.orDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xV: // global
           I64[Sp - 16] = block_c4xM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yr; else goto c4xN;
       u4yr: // global
           call _c4xM(R1) args: 0, res: 0, upd: 0;
       c4xN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xM() //  [R1]
         { info_tbl: [(c4xM,
                       label: block_c4xM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xM: // global
           _s3KK::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c4xQ; else goto c4xR;
       c4xQ: // global
           I64[Sp - 16] = block_c4xY_info;
           _s3KL::P64 = R1;
           _s3KN::P64 = P64[R1 + 7];
           _s3KM::I64 = I64[R1 + 15];
           R1 = _s3KK::P64;
           P64[Sp - 8] = _s3KN::P64;
           I64[Sp] = _s3KM::I64;
           P64[Sp + 8] = _s3KL::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yq; else goto c4y0;
       u4yq: // global
           call _c4xY(R1) args: 0, res: 0, upd: 0;
       c4y0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4xR: // global
           R1 = _s3KK::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4xY() //  [R1]
         { info_tbl: [(c4xY,
                       label: block_c4xY_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xY: // global
           if (R1 & 7 == 1) goto c4ye; else goto c4yl;
       c4ye: // global
           _s3KN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4y4_info;
           R3 = P64[R1 + 7];
           R2 = _s3KN::P64;
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
       c4yl: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4y4() //  [R1]
         { info_tbl: [(c4y4,
                       label: block_c4y4_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4yh; else goto c4yg;
       c4yh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yg: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] | I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.173742132 UTC

[section ""data" . GHC.Integer.Type.orInteger_closure" {
     GHC.Integer.Type.orInteger_closure:
         const GHC.Integer.Type.orInteger_info;
 },
 GHC.Integer.Type.orInteger_entry() //  [R2, R3]
         { info_tbl: [(c4yD,
                       label: GHC.Integer.Type.orInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yE; else goto u4AY;
       c4yE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.orInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u4AY: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c4yt() args: 0, res: 0, upd: 0;
     }
 },
 _c4yt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yt: // global
           _s3KT::P64 = P64[Sp];
           I64[Sp] = block_c4yw_info;
           R1 = _s3KT::P64;
           if (R1 & 7 != 0) goto u4B4; else goto c4yx;
       u4B4: // global
           call _c4yw(R1) args: 0, res: 0, upd: 0;
       c4yx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yw() //  [R1]
         { info_tbl: [(c4yw,
                       label: block_c4yw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yw: // global
           _s3KU::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c4yB; else goto c4yA;
       c4yB: // global
           R1 = _s3KU::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4yA: // global
           I64[Sp] = block_c4yI_info;
           _s3KV::P64 = R1;
           R1 = _s3KU::P64;
           P64[Sp + 8] = _s3KV::P64;
           if (R1 & 7 != 0) goto u4B5; else goto c4yK;
       u4B5: // global
           call _c4yI(R1) args: 0, res: 0, upd: 0;
       c4yK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yI() //  [R1]
         { info_tbl: [(c4yI,
                       label: block_c4yI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yI: // global
           _s3KV::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c4AO; else goto c4yR;
       c4AO: // global
           R1 = _s3KV::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4yR: // global
           I64[Sp] = block_c4yO_info;
           _s3KW::P64 = R1;
           R1 = _s3KV::P64;
           P64[Sp + 8] = _s3KW::P64;
           if (R1 & 7 != 0) goto u4B7; else goto c4yS;
       u4B7: // global
           call _c4yO(R1) args: 0, res: 0, upd: 0;
       c4yS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yO() //  [R1]
         { info_tbl: [(c4yO,
                       label: block_c4yO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yO: // global
           _s3KW::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c4yZ; else goto c4zY;
       c4yZ: // global
           I64[Sp] = block_c4yW_info;
           _s3KY::P64 = P64[R1 + 7];
           R1 = _s3KW::P64;
           P64[Sp + 8] = _s3KY::P64;
           if (R1 & 7 != 0) goto u4B8; else goto c4z0;
       u4B8: // global
           call _c4yW(R1) args: 0, res: 0, upd: 0;
       c4z0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4zY: // global
           I64[Sp - 8] = block_c4zW_info;
           _s3KX::P64 = R1;
           _s3Ld::P64 = P64[R1 + 6];
           R1 = _s3KW::P64;
           P64[Sp] = _s3Ld::P64;
           P64[Sp + 8] = _s3KX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4B9; else goto c4zZ;
       u4B9: // global
           call _c4zW(R1) args: 0, res: 0, upd: 0;
       c4zZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yW() //  [R1]
         { info_tbl: [(c4yW,
                       label: block_c4yW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yW: // global
           if (R1 & 7 < 2) goto c4zb; else goto c4zr;
       c4zb: // global
           _s3KY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4z4_info;
           R3 = P64[R1 + 7];
           R2 = _s3KY::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
       c4zr: // global
           I64[Sp] = block_c4zh_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4z4() //  [R1]
         { info_tbl: [(c4z4,
                       label: block_c4z4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ze; else goto c4zd;
       c4ze: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zd: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4zh() //  [R1]
         { info_tbl: [(c4zh,
                       label: block_c4zh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zh: // global
           I64[Sp] = block_c4zl_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zl() //  [R1]
         { info_tbl: [(c4zl,
                       label: block_c4zl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zl: // global
           _s3L4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4zp_info;
           R3 = _s3L4::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zp() //  [R1]
         { info_tbl: [(c4zp,
                       label: block_c4zp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zp: // global
           I64[Sp] = block_c4zx_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zx() //  [R1, R2]
         { info_tbl: [(c4zx,
                       label: block_c4zx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zx: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c4zy() args: 0, res: 0, upd: 0;
     }
 },
 _c4zy() //  []
         { info_tbl: [(c4zy,
                       label: block_c4zy_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4zG; else goto c4zF;
       c4zG: // global
           HpAlloc = 24;
           I64[Sp] = block_c4zy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4zF: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c4zC_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zC() //  [R1]
         { info_tbl: [(c4zC,
                       label: block_c4zC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zC: // global
           if (R1 & 7 == 1) goto c4zM; else goto u4B0;
       c4zM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zP; else goto c4zO;
       c4zP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zO: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4B0: // global
           Sp = Sp + 8;
           call _c4AK() args: 0, res: 0, upd: 0;
     }
 },
 _c4zW() //  [R1]
         { info_tbl: [(c4zW,
                       label: block_c4zW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zW: // global
           if (R1 & 7 < 2) goto c4A5; else goto c4Ai;
       c4A5: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c4yt() args: 0, res: 0, upd: 0;
       c4Ai: // global
           I64[Sp] = block_c4A8_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4A8() //  [R1]
         { info_tbl: [(c4A8,
                       label: block_c4A8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A8: // global
           _s3Ld::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Ac_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s3Ld::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ac() //  [R1]
         { info_tbl: [(c4Ac,
                       label: block_c4Ac_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ac: // global
           _s3Li::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Ag_info;
           R3 = _s3Li::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ag() //  [R1]
         { info_tbl: [(c4Ag,
                       label: block_c4Ag_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ag: // global
           I64[Sp] = block_c4Ao_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ao() //  [R1, R2]
         { info_tbl: [(c4Ao,
                       label: block_c4Ao_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ao: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c4Ap() args: 0, res: 0, upd: 0;
     }
 },
 _c4Ap() //  []
         { info_tbl: [(c4Ap,
                       label: block_c4Ap_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ap: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Ax; else goto c4Aw;
       c4Ax: // global
           HpAlloc = 24;
           I64[Sp] = block_c4Ap_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4Aw: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c4At_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4At() //  [R1]
         { info_tbl: [(c4At,
                       label: block_c4At_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4At: // global
           if (R1 & 7 == 1) goto c4AD; else goto u4B3;
       c4AD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AG; else goto c4AF;
       c4AG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4AF: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4B3: // global
           Sp = Sp + 8;
           call _c4AK() args: 0, res: 0, upd: 0;
     }
 },
 _c4AK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AK: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.179077044 UTC

[section ""data" . GHC.Integer.Type.mkInteger_f_closure" {
     GHC.Integer.Type.mkInteger_f_closure:
         const GHC.Integer.Type.mkInteger_f_info;
 },
 GHC.Integer.Type.mkInteger_f_entry() //  [R2]
         { info_tbl: [(c4Bq,
                       label: GHC.Integer.Type.mkInteger_f_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Bq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Br; else goto c4Bs;
       c4Br: // global
           R2 = R2;
           R1 = GHC.Integer.Type.mkInteger_f_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Bs: // global
           I64[Sp - 8] = block_c4Bj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4BV; else goto c4Bk;
       u4BV: // global
           call _c4Bj(R1) args: 0, res: 0, upd: 0;
       c4Bk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Bj() //  [R1]
         { info_tbl: [(c4Bj,
                       label: block_c4Bj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Bj: // global
           if (R1 & 7 == 1) goto c4Bn; else goto c4Bo;
       c4Bn: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Bo: // global
           I64[Sp - 8] = block_c4By_info;
           _s3Lu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s3Lu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4BU; else goto c4Bz;
       u4BU: // global
           call _c4By(R1) args: 0, res: 0, upd: 0;
       c4Bz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4By() //  [R1]
         { info_tbl: [(c4By,
                       label: block_c4By_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4By: // global
           I64[Sp] = block_c4BD_info;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4BD() //  [R1]
         { info_tbl: [(c4BD,
                       label: block_c4BD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BD: // global
           I64[Sp] = block_c4BH_info;
           R3 = 31;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4BH() //  [R1]
         { info_tbl: [(c4BH,
                       label: block_c4BH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BH: // global
           I64[Sp] = block_c4BL_info;
           R2 = I64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4BL() //  [R1]
         { info_tbl: [(c4BL,
                       label: block_c4BL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BL: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.181169331 UTC

[section ""data" . GHC.Integer.Type.mkInteger_closure" {
     GHC.Integer.Type.mkInteger_closure:
         const GHC.Integer.Type.mkInteger_info;
 },
 GHC.Integer.Type.mkInteger_entry() //  [R2, R3]
         { info_tbl: [(c4C7,
                       label: GHC.Integer.Type.mkInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4C8; else goto c4C9;
       c4C8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.mkInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C9: // global
           I64[Sp - 16] = block_c4C0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Cl; else goto c4C1;
       u4Cl: // global
           call _c4C0(R1) args: 0, res: 0, upd: 0;
       c4C1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C0() //  [R1]
         { info_tbl: [(c4C0,
                       label: block_c4C0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C0: // global
           _s3LB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c4C4; else goto c4C5;
       c4C4: // global
           I64[Sp + 8] = block_c4Cc_info;
           R2 = _s3LB::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 8, upd: 8;
       c4C5: // global
           R2 = _s3LB::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c4Cc() //  [R1]
         { info_tbl: [(c4Cc,
                       label: block_c4Cc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cc: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.184691241 UTC

[section ""data" . GHC.Integer.Type.andInteger_closure" {
     GHC.Integer.Type.andInteger_closure:
         const GHC.Integer.Type.andInteger_info;
 },
 GHC.Integer.Type.andInteger_entry() //  [R2, R3]
         { info_tbl: [(c4Cx,
                       label: GHC.Integer.Type.andInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Cy; else goto u4F2;
       c4Cy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u4F2: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c4Cn() args: 0, res: 0, upd: 0;
     }
 },
 _c4Cn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cn: // global
           _s3LE::P64 = P64[Sp];
           I64[Sp] = block_c4Cq_info;
           R1 = _s3LE::P64;
           if (R1 & 7 != 0) goto u4F9; else goto c4Cr;
       u4F9: // global
           call _c4Cq(R1) args: 0, res: 0, upd: 0;
       c4Cr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cq() //  [R1]
         { info_tbl: [(c4Cq,
                       label: block_c4Cq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cq: // global
           _s3LF::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c4Cv; else goto c4Cu;
       c4Cv: // global
           I64[Sp + 8] = block_c4EO_info;
           R1 = _s3LF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Fb; else goto c4EQ;
       u4Fb: // global
           call _c4EO() args: 0, res: 0, upd: 0;
       c4EQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Cu: // global
           I64[Sp] = block_c4CC_info;
           _s3LG::P64 = R1;
           R1 = _s3LF::P64;
           P64[Sp + 8] = _s3LG::P64;
           if (R1 & 7 != 0) goto u4Fa; else goto c4CE;
       u4Fa: // global
           call _c4CC(R1) args: 0, res: 0, upd: 0;
       c4CE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4EO() //  []
         { info_tbl: [(c4EO,
                       label: block_c4EO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4EO: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4CC() //  [R1]
         { info_tbl: [(c4CC,
                       label: block_c4CC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CC: // global
           if (R1 & 7 == 3) goto u4F3; else goto c4CL;
       u4F3: // global
           Sp = Sp + 16;
           call _c4EL() args: 0, res: 0, upd: 0;
       c4CL: // global
           I64[Sp] = block_c4CI_info;
           _s3LH::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s3LH::P64;
           if (R1 & 7 != 0) goto u4Fd; else goto c4CM;
       u4Fd: // global
           call _c4CI(R1) args: 0, res: 0, upd: 0;
       c4CM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CI() //  [R1]
         { info_tbl: [(c4CI,
                       label: block_c4CI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CI: // global
           _s3LH::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c4CT; else goto c4DV;
       c4CT: // global
           I64[Sp] = block_c4CQ_info;
           _s3LJ::P64 = P64[R1 + 7];
           R1 = _s3LH::P64;
           P64[Sp + 8] = _s3LJ::P64;
           if (R1 & 7 != 0) goto u4Ff; else goto c4CU;
       u4Ff: // global
           call _c4CQ(R1) args: 0, res: 0, upd: 0;
       c4CU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4DV: // global
           I64[Sp - 8] = block_c4DT_info;
           _s3LI::P64 = R1;
           _s3LX::P64 = P64[R1 + 6];
           R1 = _s3LH::P64;
           P64[Sp] = _s3LX::P64;
           P64[Sp + 8] = _s3LI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Fg; else goto c4DW;
       u4Fg: // global
           call _c4DT(R1) args: 0, res: 0, upd: 0;
       c4DW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CQ() //  [R1]
         { info_tbl: [(c4CQ,
                       label: block_c4CQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CQ: // global
           if (R1 & 7 < 2) goto c4D1; else goto c4Dw;
       c4D1: // global
           _s3LJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4CY_info;
           R3 = P64[R1 + 7];
           R2 = _s3LJ::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c4Dw: // global
           I64[Sp] = block_c4Dm_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4CY() //  [R1]
         { info_tbl: [(c4CY,
                       label: block_c4CY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CY: // global
           I64[Sp] = block_c4D5_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4D5() //  [R1]
         { info_tbl: [(c4D5,
                       label: block_c4D5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D5: // global
           if (R1 & 7 == 1) goto c4Dc; else goto u4F4;
       c4Dc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Df; else goto c4De;
       c4Df: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4De: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4F4: // global
           Sp = Sp + 8;
           call _c4EL() args: 0, res: 0, upd: 0;
     }
 },
 _c4Dm() //  [R1]
         { info_tbl: [(c4Dm,
                       label: block_c4Dm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Dm: // global
           I64[Sp] = block_c4Dq_info;
           R2 = R1;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Dq() //  [R1]
         { info_tbl: [(c4Dq,
                       label: block_c4Dq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Dq: // global
           _s3LJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Du_info;
           R3 = _s3LJ::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Du() //  [R1]
         { info_tbl: [(c4Du,
                       label: block_c4Du_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Du: // global
           I64[Sp] = block_c4DC_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4DC() //  [R1]
         { info_tbl: [(c4DC,
                       label: block_c4DC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4DC: // global
           if (R1 & 7 == 1) goto c4DJ; else goto u4F5;
       c4DJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4DM; else goto c4DL;
       c4DM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4DL: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4F5: // global
           Sp = Sp + 8;
           call _c4EL() args: 0, res: 0, upd: 0;
     }
 },
 _c4DT() //  [R1]
         { info_tbl: [(c4DT,
                       label: block_c4DT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4DT: // global
           if (R1 & 7 < 2) goto c4E2; else goto c4Ef;
       c4E2: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c4Cn() args: 0, res: 0, upd: 0;
       c4Ef: // global
           I64[Sp] = block_c4E5_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4E5() //  [R1]
         { info_tbl: [(c4E5,
                       label: block_c4E5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4E5: // global
           _s3LX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4E9_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s3LX::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4E9() //  [R1]
         { info_tbl: [(c4E9,
                       label: block_c4E9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4E9: // global
           _s3M2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Ed_info;
           R3 = _s3M2::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ed() //  [R1]
         { info_tbl: [(c4Ed,
                       label: block_c4Ed_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ed: // global
           I64[Sp] = block_c4El_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4El() //  [R1, R2]
         { info_tbl: [(c4El,
                       label: block_c4El_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4El: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c4Em() args: 0, res: 0, upd: 0;
     }
 },
 _c4Em() //  []
         { info_tbl: [(c4Em,
                       label: block_c4Em_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Em: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Eu; else goto c4Et;
       c4Eu: // global
           HpAlloc = 24;
           I64[Sp] = block_c4Em_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4Et: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c4Eq_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Eq() //  [R1]
         { info_tbl: [(c4Eq,
                       label: block_c4Eq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Eq: // global
           if (R1 & 7 == 1) goto c4EA; else goto u4F8;
       c4EA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ED; else goto c4EC;
       c4ED: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4EC: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4F8: // global
           Sp = Sp + 8;
           call _c4EL() args: 0, res: 0, upd: 0;
     }
 },
 _c4EL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4EL: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.190417545 UTC

[section ""data" . GHC.Integer.Type.testBitInteger_closure" {
     GHC.Integer.Type.testBitInteger_closure:
         const GHC.Integer.Type.testBitInteger_info;
 },
 GHC.Integer.Type.testBitInteger_entry() //  [R2, R3]
         { info_tbl: [(c4Fs,
                       label: GHC.Integer.Type.testBitInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FA; else goto c4FB;
       c4FA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.testBitInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FB: // global
           I64[Sp - 16] = block_c4Fq_info;
           R3 = R3;
           _s3Mc::P64 = R2;
           R2 = GHC.Integer.Type.oneInteger_closure+1;
           P64[Sp - 8] = _s3Mc::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Fq() //  [R1]
         { info_tbl: [(c4Fq,
                       label: block_c4Fq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fq: // global
           _s3Mc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Fv_info;
           R3 = R1;
           R2 = _s3Mc::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Fv() //  [R1]
         { info_tbl: [(c4Fv,
                       label: block_c4Fv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fv: // global
           I64[Sp] = block_c4Fz_info;
           R3 = GHC.Integer.Type.Naught_closure+3;
           R2 = R1;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Fz() //  [R1]
         { info_tbl: [(c4Fz,
                       label: block_c4Fz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fz: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.192818059 UTC

[section ""data" . GHC.Integer.Type.xorDigits_closure" {
     GHC.Integer.Type.xorDigits_closure:
         const GHC.Integer.Type.xorDigits_info;
 },
 GHC.Integer.Type.xorDigits_entry() //  [R2, R3]
         { info_tbl: [(c4FT,
                       label: GHC.Integer.Type.xorDigits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4FU; else goto c4FV;
       c4FU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.xorDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FV: // global
           I64[Sp - 16] = block_c4FM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Gr; else goto c4FN;
       u4Gr: // global
           call _c4FM(R1) args: 0, res: 0, upd: 0;
       c4FN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FM() //  [R1]
         { info_tbl: [(c4FM,
                       label: block_c4FM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FM: // global
           _s3Mi::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c4FQ; else goto c4FR;
       c4FQ: // global
           I64[Sp - 16] = block_c4FY_info;
           _s3Mj::P64 = R1;
           _s3Ml::P64 = P64[R1 + 7];
           _s3Mk::I64 = I64[R1 + 15];
           R1 = _s3Mi::P64;
           P64[Sp - 8] = _s3Ml::P64;
           I64[Sp] = _s3Mk::I64;
           P64[Sp + 8] = _s3Mj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Gq; else goto c4G0;
       u4Gq: // global
           call _c4FY(R1) args: 0, res: 0, upd: 0;
       c4G0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4FR: // global
           R1 = _s3Mi::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4FY() //  [R1]
         { info_tbl: [(c4FY,
                       label: block_c4FY_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FY: // global
           if (R1 & 7 == 1) goto c4Ge; else goto c4Gl;
       c4Ge: // global
           _s3Ml::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4G4_info;
           R3 = P64[R1 + 7];
           R2 = _s3Ml::P64;
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c4Gl: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4G4() //  [R1]
         { info_tbl: [(c4G4,
                       label: block_c4G4_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Gh; else goto c4Gg;
       c4Gh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Gg: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] ^ I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.196983392 UTC

[section ""data" . GHC.Integer.Type.xorInteger_closure" {
     GHC.Integer.Type.xorInteger_closure:
         const GHC.Integer.Type.xorInteger_info;
 },
 GHC.Integer.Type.xorInteger_entry() //  [R2, R3]
         { info_tbl: [(c4GD,
                       label: GHC.Integer.Type.xorInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GE; else goto u4IX;
       c4GE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.xorInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u4IX: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c4Gt() args: 0, res: 0, upd: 0;
     }
 },
 _c4Gt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gt: // global
           _s3Mr::P64 = P64[Sp];
           I64[Sp] = block_c4Gw_info;
           R1 = _s3Mr::P64;
           if (R1 & 7 != 0) goto u4J3; else goto c4Gx;
       u4J3: // global
           call _c4Gw(R1) args: 0, res: 0, upd: 0;
       c4Gx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gw() //  [R1]
         { info_tbl: [(c4Gw,
                       label: block_c4Gw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gw: // global
           _s3Ms::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c4GB; else goto c4GA;
       c4GB: // global
           R1 = _s3Ms::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4GA: // global
           I64[Sp] = block_c4GI_info;
           _s3Mt::P64 = R1;
           R1 = _s3Ms::P64;
           P64[Sp + 8] = _s3Mt::P64;
           if (R1 & 7 != 0) goto u4J4; else goto c4GK;
       u4J4: // global
           call _c4GI(R1) args: 0, res: 0, upd: 0;
       c4GK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GI() //  [R1]
         { info_tbl: [(c4GI,
                       label: block_c4GI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GI: // global
           _s3Mt::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c4IM; else goto c4GR;
       c4IM: // global
           R1 = _s3Mt::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4GR: // global
           I64[Sp] = block_c4GO_info;
           _s3Mu::P64 = R1;
           R1 = _s3Mt::P64;
           P64[Sp + 8] = _s3Mu::P64;
           if (R1 & 7 != 0) goto u4J6; else goto c4GS;
       u4J6: // global
           call _c4GO(R1) args: 0, res: 0, upd: 0;
       c4GS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GO() //  [R1]
         { info_tbl: [(c4GO,
                       label: block_c4GO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GO: // global
           _s3Mu::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c4GZ; else goto c4I4;
       c4GZ: // global
           I64[Sp] = block_c4GW_info;
           _s3Mw::P64 = P64[R1 + 7];
           R1 = _s3Mu::P64;
           P64[Sp + 8] = _s3Mw::P64;
           if (R1 & 7 != 0) goto u4J7; else goto c4H0;
       u4J7: // global
           call _c4GW(R1) args: 0, res: 0, upd: 0;
       c4H0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4I4: // global
           I64[Sp - 8] = block_c4I2_info;
           _s3Mv::P64 = R1;
           _s3MN::P64 = P64[R1 + 6];
           R1 = _s3Mu::P64;
           P64[Sp] = _s3MN::P64;
           P64[Sp + 8] = _s3Mv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4J8; else goto c4I5;
       u4J8: // global
           call _c4I2(R1) args: 0, res: 0, upd: 0;
       c4I5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GW() //  [R1]
         { info_tbl: [(c4GW,
                       label: block_c4GW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GW: // global
           if (R1 & 7 < 2) goto c4H7; else goto c4Hy;
       c4H7: // global
           _s3Mw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4H4_info;
           R3 = P64[R1 + 7];
           R2 = _s3Mw::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c4Hy: // global
           I64[Sp] = block_c4Hs_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4H4() //  [R1]
         { info_tbl: [(c4H4,
                       label: block_c4H4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H4: // global
           I64[Sp] = block_c4Hb_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hb() //  [R1]
         { info_tbl: [(c4Hb,
                       label: block_c4Hb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hb: // global
           if (R1 & 7 == 1) goto c4Hi; else goto u4IY;
       c4Hi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Hl; else goto c4Hk;
       c4Hl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Hk: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4IY: // global
           Sp = Sp + 8;
           call _c4II() args: 0, res: 0, upd: 0;
     }
 },
 _c4Hs() //  [R1]
         { info_tbl: [(c4Hs,
                       label: block_c4Hs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hs: // global
           _s3Mw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Hw_info;
           R3 = R1;
           R2 = _s3Mw::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hw() //  [R1]
         { info_tbl: [(c4Hw,
                       label: block_c4Hw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hw: // global
           I64[Sp] = block_c4HD_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4HD() //  [R1, R2]
         { info_tbl: [(c4HD,
                       label: block_c4HD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HD: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c4HE() args: 0, res: 0, upd: 0;
     }
 },
 _c4HE() //  []
         { info_tbl: [(c4HE,
                       label: block_c4HE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4HM; else goto c4HL;
       c4HM: // global
           HpAlloc = 24;
           I64[Sp] = block_c4HE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4HL: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c4HI_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4HI() //  [R1]
         { info_tbl: [(c4HI,
                       label: block_c4HI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HI: // global
           if (R1 & 7 == 1) goto c4HS; else goto u4J0;
       c4HS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HV; else goto c4HU;
       c4HV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HU: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4J0: // global
           Sp = Sp + 8;
           call _c4II() args: 0, res: 0, upd: 0;
     }
 },
 _c4I2() //  [R1]
         { info_tbl: [(c4I2,
                       label: block_c4I2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I2: // global
           if (R1 & 7 < 2) goto c4Ib; else goto c4Io;
       c4Ib: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c4Gt() args: 0, res: 0, upd: 0;
       c4Io: // global
           I64[Sp] = block_c4Ie_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ie() //  [R1]
         { info_tbl: [(c4Ie,
                       label: block_c4Ie_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ie: // global
           _s3MN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Ii_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s3MN::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ii() //  [R1]
         { info_tbl: [(c4Ii,
                       label: block_c4Ii_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ii: // global
           _s3MS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Im_info;
           R3 = _s3MS::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Im() //  [R1]
         { info_tbl: [(c4Im,
                       label: block_c4Im_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Im: // global
           I64[Sp] = block_c4Iu_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Iu() //  [R1]
         { info_tbl: [(c4Iu,
                       label: block_c4Iu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Iu: // global
           if (R1 & 7 == 1) goto c4IB; else goto u4J2;
       c4IB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4IE; else goto c4ID;
       c4IE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ID: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4J2: // global
           Sp = Sp + 8;
           call _c4II() args: 0, res: 0, upd: 0;
     }
 },
 _c4II() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4II: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.202150781 UTC

[section ""cstring" . GHC.Integer.Type.$trModule4_bytes" {
     GHC.Integer.Type.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.202811505 UTC

[section ""data" . GHC.Integer.Type.$trModule3_closure" {
     GHC.Integer.Type.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.203439984 UTC

[section ""cstring" . GHC.Integer.Type.$trModule2_bytes" {
     GHC.Integer.Type.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.20404468 UTC

[section ""data" . GHC.Integer.Type.$trModule1_closure" {
     GHC.Integer.Type.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.204781427 UTC

[section ""data" . GHC.Integer.Type.$trModule_closure" {
     GHC.Integer.Type.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Type.$trModule3_closure+1;
         const GHC.Integer.Type.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.205671756 UTC

[section ""data" . $krep_r3Bp_closure" {
     $krep_r3Bp_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.206312894 UTC

[section ""data" . $krep1_r3Bq_closure" {
     $krep1_r3Bq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.206969259 UTC

[section ""cstring" . GHC.Integer.Type.$tcDigits2_bytes" {
     GHC.Integer.Type.$tcDigits2_bytes:
         I8[] [68,105,103,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.207911479 UTC

[section ""data" . GHC.Integer.Type.$tcDigits1_closure" {
     GHC.Integer.Type.$tcDigits1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcDigits2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.208570111 UTC

[section ""data" . GHC.Integer.Type.$tcDigits_closure" {
     GHC.Integer.Type.$tcDigits_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcDigits1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16647862651490579480;
         const 7069031713090282797;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.209479655 UTC

[section ""data" . GHC.Integer.Type.$tc'None1_closure" {
     GHC.Integer.Type.$tc'None1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcDigits_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.21016805 UTC

[section ""cstring" . GHC.Integer.Type.$tc'None3_bytes" {
     GHC.Integer.Type.$tc'None3_bytes:
         I8[] [39,78,111,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.21098797 UTC

[section ""data" . GHC.Integer.Type.$tc'None2_closure" {
     GHC.Integer.Type.$tc'None2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'None3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.211604179 UTC

[section ""data" . GHC.Integer.Type.$tc'None_closure" {
     GHC.Integer.Type.$tc'None_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'None2_closure+1;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const 903679638320298226;
         const 12977397153301278560;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.212305534 UTC

[section ""data" . $krep2_r3Br_closure" {
     $krep2_r3Br_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.213076476 UTC

[section ""data" . GHC.Integer.Type.$tc'Some1_closure" {
     GHC.Integer.Type.$tc'Some1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r3Bq_closure+1;
         const $krep2_r3Br_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.213737786 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Some3_bytes" {
     GHC.Integer.Type.$tc'Some3_bytes:
         I8[] [39,83,111,109,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.214390055 UTC

[section ""data" . GHC.Integer.Type.$tc'Some2_closure" {
     GHC.Integer.Type.$tc'Some2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Some3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.215008575 UTC

[section ""data" . GHC.Integer.Type.$tc'Some_closure" {
     GHC.Integer.Type.$tc'Some_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Some2_closure+1;
         const GHC.Integer.Type.$tc'Some1_closure+4;
         const 6045911439621864566;
         const 9702873355935012388;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.215823242 UTC

[section ""cstring" . GHC.Integer.Type.$tcInteger2_bytes" {
     GHC.Integer.Type.$tcInteger2_bytes:
         I8[] [73,110,116,101,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.21649338 UTC

[section ""data" . GHC.Integer.Type.$tcInteger1_closure" {
     GHC.Integer.Type.$tcInteger1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcInteger2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.217132756 UTC

[section ""data" . GHC.Integer.Type.$tcInteger_closure" {
     GHC.Integer.Type.$tcInteger_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcInteger1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12260413788024328428;
         const 9583620696682509916;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.218075758 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught1_closure" {
     GHC.Integer.Type.$tc'Naught1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.219051664 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Naught3_bytes" {
     GHC.Integer.Type.$tc'Naught3_bytes:
         I8[] [39,78,97,117,103,104,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.219785938 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught2_closure" {
     GHC.Integer.Type.$tc'Naught2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Naught3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.220497475 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught_closure" {
     GHC.Integer.Type.$tc'Naught_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Naught2_closure+1;
         const GHC.Integer.Type.$tc'Naught1_closure+1;
         const 7287704174224038176;
         const 776397532388787230;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.221201517 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative1_closure" {
     GHC.Integer.Type.$tc'Negative1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const GHC.Integer.Type.$tc'Naught1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.222198441 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Positive2_bytes" {
     GHC.Integer.Type.$tc'Positive2_bytes:
         I8[] [39,80,111,115,105,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.222912884 UTC

[section ""data" . GHC.Integer.Type.$tc'Positive1_closure" {
     GHC.Integer.Type.$tc'Positive1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Positive2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.223552448 UTC

[section ""data" . GHC.Integer.Type.$tc'Positive_closure" {
     GHC.Integer.Type.$tc'Positive_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Positive1_closure+1;
         const GHC.Integer.Type.$tc'Negative1_closure+4;
         const 6887932004110746796;
         const 9391890139750561935;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.224241362 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Negative3_bytes" {
     GHC.Integer.Type.$tc'Negative3_bytes:
         I8[] [39,78,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.225168029 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative2_closure" {
     GHC.Integer.Type.$tc'Negative2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Negative3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.225948019 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative_closure" {
     GHC.Integer.Type.$tc'Negative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Negative2_closure+1;
         const GHC.Integer.Type.$tc'Negative1_closure+4;
         const 4010847856516363452;
         const 15624358648337932456;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.226698354 UTC

[section ""cstring" . GHC.Integer.Type.$tcList2_bytes" {
     GHC.Integer.Type.$tcList2_bytes:
         I8[] [76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.227343838 UTC

[section ""data" . GHC.Integer.Type.$tcList1_closure" {
     GHC.Integer.Type.$tcList1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcList2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.228222097 UTC

[section ""data" . GHC.Integer.Type.$tcList_closure" {
     GHC.Integer.Type.$tcList_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 732340346576824023;
         const 9653115931589988500;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.228918706 UTC

[section ""data" . $krep3_r3Bs_closure" {
     $krep3_r3Bs_closure:
         const :_con_info;
         const $krep_r3Bp_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.229758584 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil1_closure" {
     GHC.Integer.Type.$tc'Nil1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcList_closure+1;
         const $krep3_r3Bs_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.230376843 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Nil3_bytes" {
     GHC.Integer.Type.$tc'Nil3_bytes:
         I8[] [39,78,105,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.231234991 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil2_closure" {
     GHC.Integer.Type.$tc'Nil2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Nil3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.231853393 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil_closure" {
     GHC.Integer.Type.$tc'Nil_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Nil2_closure+1;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const 13538585131509945451;
         const 9366316088405446135;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.232532661 UTC

[section ""data" . $krep4_r3Bt_closure" {
     $krep4_r3Bt_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.23314763 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons1_closure" {
     GHC.Integer.Type.$tc'Cons1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r3Bp_closure+2;
         const $krep4_r3Bt_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.233966603 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Cons3_bytes" {
     GHC.Integer.Type.$tc'Cons3_bytes:
         I8[] [39,67,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.234625333 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons2_closure" {
     GHC.Integer.Type.$tc'Cons2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Cons3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.235248814 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons_closure" {
     GHC.Integer.Type.$tc'Cons_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Cons2_closure+1;
         const GHC.Integer.Type.$tc'Cons1_closure+4;
         const 3906777924842222150;
         const 5463288556346842885;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.235921481 UTC

[section ""cstring" . GHC.Integer.Type.$tcDigitsOnes2_bytes" {
     GHC.Integer.Type.$tcDigitsOnes2_bytes:
         I8[] [68,105,103,105,116,115,79,110,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.236718262 UTC

[section ""data" . GHC.Integer.Type.$tcDigitsOnes1_closure" {
     GHC.Integer.Type.$tcDigitsOnes1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcDigitsOnes2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.237404228 UTC

[section ""data" . GHC.Integer.Type.$tcDigitsOnes_closure" {
     GHC.Integer.Type.$tcDigitsOnes_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcDigitsOnes1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4554239703586147919;
         const 6957361150436389790;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.238109165 UTC

[section ""data" . $krep5_r3Bu_closure" {
     $krep5_r3Bu_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcDigitsOnes_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.238756876 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes1_closure" {
     GHC.Integer.Type.$tc'DigitsOnes1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const $krep5_r3Bu_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.239594395 UTC

[section ""cstring" . GHC.Integer.Type.$tc'DigitsOnes3_bytes" {
     GHC.Integer.Type.$tc'DigitsOnes3_bytes:
         I8[] [39,68,105,103,105,116,115,79,110,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.240246269 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes2_closure" {
     GHC.Integer.Type.$tc'DigitsOnes2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'DigitsOnes3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.240871504 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes_closure" {
     GHC.Integer.Type.$tc'DigitsOnes_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'DigitsOnes2_closure+1;
         const GHC.Integer.Type.$tc'DigitsOnes1_closure+4;
         const 15211110739657495015;
         const 1682512192113792266;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.242624151 UTC

[section ""data" . GHC.Integer.Type.encodeDouble#_closure" {
     GHC.Integer.Type.encodeDouble#_closure:
         const GHC.Integer.Type.encodeDouble#_info;
 },
 GHC.Integer.Type.encodeDouble#_entry() //  [R2, R3]
         { info_tbl: [(c4Jl,
                       label: GHC.Integer.Type.encodeDouble#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jl: // global
           _c4Jk::I64 = R3;
           (_s3N2::F64) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeDouble(R2, _c4Jk::I64);
           D1 = _s3N2::F64;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.244682424 UTC

[section ""data" . f_r3Bv_closure" {
     f_r3Bv_closure:
         const f_r3Bv_info;
 },
 f_r3Bv_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jp: // global
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           D1 = F64[Sp];
           R1 = R1;
           Sp = Sp + 24;
           call f_r3Bv_entry(R3, R2, D1, R1) args: 8, res: 0, upd: 8;
     }
 },
 f_r3Bv_entry() //  [R2, R3, D1]
         { info_tbl: [(c4JA,
                       label: f_r3Bv_info
                       rep:HeapRep static {
                             Fun {arity: 3 fun_type: ArgGen [True, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4JB; else goto u4JQ;
       c4JB: // global
           R1 = f_r3Bv_closure;
           F64[Sp - 24] = D1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       u4JQ: // global
           F64[Sp - 24] = D1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _c4Jq() args: 0, res: 0, upd: 0;
     }
 },
 _c4Jq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jq: // global
           I64[Sp - 8] = block_c4Jt_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4JS; else goto c4Ju;
       u4JS: // global
           call _c4Jt(R1) args: 0, res: 0, upd: 0;
       c4Ju: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jt() //  [R1]
         { info_tbl: [(c4Jt,
                       label: block_c4Jt_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jt: // global
           _s3N3::F64 = F64[Sp + 8];
           if (R1 & 7 == 1) goto c4Jx; else goto c4Jy;
       c4Jx: // global
           _s3N5::I64 = I64[Sp + 24];
           _s3N8::P64 = P64[R1 + 7];
           (_s3Nc::F64) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeDouble(I64[R1 + 15], _s3N5::I64);
           F64[Sp + 8] = %MO_F_Add_W64(_s3N3::F64, _s3Nc::F64);
           P64[Sp + 16] = _s3N8::P64;
           I64[Sp + 24] = _s3N5::I64 + 64;
           Sp = Sp + 8;
           call _c4Jq() args: 0, res: 0, upd: 0;
       c4Jy: // global
           D1 = _s3N3::F64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.247611367 UTC

[section ""data" . GHC.Integer.Type.encodeDoubleInteger_closure" {
     GHC.Integer.Type.encodeDoubleInteger_closure:
         const GHC.Integer.Type.encodeDoubleInteger_info;
 },
 GHC.Integer.Type.encodeDoubleInteger_entry() //  [R2, R3]
         { info_tbl: [(c4K7,
                       label: GHC.Integer.Type.encodeDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4K7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4K8; else goto c4K9;
       c4K8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.encodeDoubleInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4K9: // global
           I64[Sp - 16] = block_c4JZ_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Kt; else goto c4K0;
       u4Kt: // global
           call _c4JZ(R1) args: 0, res: 0, upd: 0;
       c4K0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JZ() //  [R1]
         { info_tbl: [(c4JZ,
                       label: block_c4JZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JZ: // global
           _c4K6::P64 = R1 & 7;
           if (_c4K6::P64 < 3) goto u4Ks; else goto c4K5;
       u4Ks: // global
           _s3Ng::I64 = I64[Sp + 8];
           if (_c4K6::P64 < 2) goto c4K3; else goto c4K4;
       c4K3: // global
           R3 = _s3Ng::I64;
           R2 = P64[R1 + 7];
           D1 = 0.0 :: W64;
           Sp = Sp + 16;
           call f_r3Bv_entry(R3, R2, D1) args: 8, res: 0, upd: 8;
       c4K4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Kn; else goto c4Km;
       c4Kn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Km: // global
           _s3Nj::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3Nj::P64;
           I64[Sp + 8] = block_c4Kg_info;
           R3 = _s3Ng::I64;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       c4K5: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Kg() //  [D1]
         { info_tbl: [(c4Kg,
                       label: block_c4Kg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Kg: // global
           D1 = %MO_F_Neg_W64(D1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.249613367 UTC

[section ""data" . GHC.Integer.Type.encodeFloat#_closure" {
     GHC.Integer.Type.encodeFloat#_closure:
         const GHC.Integer.Type.encodeFloat#_info;
 },
 GHC.Integer.Type.encodeFloat#_entry() //  [R2, R3]
         { info_tbl: [(c4KB,
                       label: GHC.Integer.Type.encodeFloat#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4KB: // global
           _c4KA::I64 = R3;
           (_s3Nr::F32) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeFloat(R2, _c4KA::I64);
           F1 = _s3Nr::F32;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.251769418 UTC

[section ""data" . f1_r3Bw_closure" {
     f1_r3Bw_closure:
         const f1_r3Bw_info;
 },
 f1_r3Bw_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4KF: // global
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           F1 = F32[Sp];
           R1 = R1;
           Sp = Sp + 24;
           call f1_r3Bw_entry(R3, R2, F1, R1) args: 8, res: 0, upd: 8;
     }
 },
 f1_r3Bw_entry() //  [R2, R3, F1]
         { info_tbl: [(c4KQ,
                       label: f1_r3Bw_info
                       rep:HeapRep static {
                             Fun {arity: 3 fun_type: ArgGen [True, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4KQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4KR; else goto u4L6;
       c4KR: // global
           R1 = f1_r3Bw_closure;
           F32[Sp - 24] = F1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       u4L6: // global
           F32[Sp - 24] = F1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _c4KG() args: 0, res: 0, upd: 0;
     }
 },
 _c4KG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4KG: // global
           I64[Sp - 8] = block_c4KJ_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4L8; else goto c4KK;
       u4L8: // global
           call _c4KJ(R1) args: 0, res: 0, upd: 0;
       c4KK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4KJ() //  [R1]
         { info_tbl: [(c4KJ,
                       label: block_c4KJ_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4KJ: // global
           _s3Ns::F32 = F32[Sp + 8];
           if (R1 & 7 == 1) goto c4KN; else goto c4KO;
       c4KN: // global
           _s3Nu::I64 = I64[Sp + 24];
           _s3Nx::P64 = P64[R1 + 7];
           (_s3NB::F32) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeFloat(I64[R1 + 15], _s3Nu::I64);
           F32[Sp + 8] = %MO_F_Add_W32(_s3Ns::F32, _s3NB::F32);
           P64[Sp + 16] = _s3Nx::P64;
           I64[Sp + 24] = _s3Nu::I64 + 64;
           Sp = Sp + 8;
           call _c4KG() args: 0, res: 0, upd: 0;
       c4KO: // global
           F1 = _s3Ns::F32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.254636675 UTC

[section ""data" . GHC.Integer.Type.encodeFloatInteger_closure" {
     GHC.Integer.Type.encodeFloatInteger_closure:
         const GHC.Integer.Type.encodeFloatInteger_info;
 },
 GHC.Integer.Type.encodeFloatInteger_entry() //  [R2, R3]
         { info_tbl: [(c4Ln,
                       label: GHC.Integer.Type.encodeFloatInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ln: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Lo; else goto c4Lp;
       c4Lo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.encodeFloatInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Lp: // global
           I64[Sp - 16] = block_c4Lf_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4LJ; else goto c4Lg;
       u4LJ: // global
           call _c4Lf(R1) args: 0, res: 0, upd: 0;
       c4Lg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lf() //  [R1]
         { info_tbl: [(c4Lf,
                       label: block_c4Lf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lf: // global
           _c4Lm::P64 = R1 & 7;
           if (_c4Lm::P64 < 3) goto u4LI; else goto c4Ll;
       u4LI: // global
           _s3NF::I64 = I64[Sp + 8];
           if (_c4Lm::P64 < 2) goto c4Lj; else goto c4Lk;
       c4Lj: // global
           R3 = _s3NF::I64;
           R2 = P64[R1 + 7];
           F1 = 0.0 :: W32;
           Sp = Sp + 16;
           call f1_r3Bw_entry(R3, R2, F1) args: 8, res: 0, upd: 8;
       c4Lk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4LD; else goto c4LC;
       c4LD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4LC: // global
           _s3NI::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3NI::P64;
           I64[Sp + 8] = block_c4Lw_info;
           R3 = _s3NF::I64;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
       c4Ll: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lw() //  [F1]
         { info_tbl: [(c4Lw,
                       label: block_c4Lw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lw: // global
           F1 = %MO_F_Neg_W32(F1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.256860255 UTC

[section ""data" . GHC.Integer.Type.Positive_closure" {
     GHC.Integer.Type.Positive_closure:
         const GHC.Integer.Type.Positive_info;
 },
 GHC.Integer.Type.Positive_entry() //  [R2]
         { info_tbl: [(c4LP,
                       label: GHC.Integer.Type.Positive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4LT; else goto c4LS;
       c4LT: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Type.Positive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LS: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.258451285 UTC

[section ""data" . GHC.Integer.Type.Negative_closure" {
     GHC.Integer.Type.Negative_closure:
         const GHC.Integer.Type.Negative_info;
 },
 GHC.Integer.Type.Negative_entry() //  [R2]
         { info_tbl: [(c4LZ,
                       label: GHC.Integer.Type.Negative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4M3; else goto c4M2;
       c4M3: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Type.Negative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4M2: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.259890306 UTC

[section ""data" . GHC.Integer.Type.Naught_closure" {
     GHC.Integer.Type.Naught_closure:
         const GHC.Integer.Type.Naught_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.261357615 UTC

[section ""data" . GHC.Integer.Type.Nil_closure" {
     GHC.Integer.Type.Nil_closure:
         const GHC.Integer.Type.Nil_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.262303427 UTC

[section ""data" . GHC.Integer.Type.Cons_closure" {
     GHC.Integer.Type.Cons_closure:
         const GHC.Integer.Type.Cons_info;
 },
 GHC.Integer.Type.Cons_entry() //  [R2, R3]
         { info_tbl: [(c4M9,
                       label: GHC.Integer.Type.Cons_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Md; else goto c4Mc;
       c4Md: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.Cons_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Mc: // global
           I64[Hp - 16] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.263489526 UTC

[section ""data" . GHC.Integer.Type.Some_closure" {
     GHC.Integer.Type.Some_closure:
         const GHC.Integer.Type.Some_info;
 },
 GHC.Integer.Type.Some_entry() //  [R2, R3]
         { info_tbl: [(c4Mj,
                       label: GHC.Integer.Type.Some_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Mn; else goto c4Mm;
       c4Mn: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.Some_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Mm: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R3;
           I64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.264722471 UTC

[section ""data" . GHC.Integer.Type.None_closure" {
     GHC.Integer.Type.None_closure:
         const GHC.Integer.Type.None_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.265854884 UTC

[GHC.Integer.Type.Positive_con_entry() //  [R1]
         { info_tbl: [(c4Mo,
                       label: GHC.Integer.Type.Positive_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,80,111,115,105,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mo: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.266709503 UTC

[GHC.Integer.Type.Negative_con_entry() //  [R1]
         { info_tbl: [(c4Mp,
                       label: GHC.Integer.Type.Negative_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,101,103,97,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mp: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.26779068 UTC

[GHC.Integer.Type.Naught_con_entry() //  [R1]
         { info_tbl: [(c4Mq,
                       label: GHC.Integer.Type.Naught_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,97,117,103,104,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mq: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.268640327 UTC

[GHC.Integer.Type.Nil_con_entry() //  [R1]
         { info_tbl: [(c4Mr,
                       label: GHC.Integer.Type.Nil_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,105,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mr: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.269533796 UTC

[GHC.Integer.Type.Cons_con_entry() //  [R1]
         { info_tbl: [(c4Ms,
                       label: GHC.Integer.Type.Cons_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 1
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,67,111,110,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ms: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.270396549 UTC

[GHC.Integer.Type.Some_con_entry() //  [R1]
         { info_tbl: [(c4Mt,
                       label: GHC.Integer.Type.Some_con_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,83,111,109,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mt: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.271890694 UTC

[GHC.Integer.Type.None_con_entry() //  [R1]
         { info_tbl: [(c4Mu,
                       label: GHC.Integer.Type.None_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,111,110,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mu: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.273159798 UTC

[section ""relreadonly" . S3Xx_srt" {
     S3Xx_srt:
         const GHC.Integer.Type.plusPositive_addWithCarry_closure;
         const lvl_r3Bo_closure;
         const GHC.Integer.Type.timesDigit_closure;
         const GHC.Integer.Type.timesPositive_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const GHC.Integer.Type.complementInteger_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Integer.Type.modInteger_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.274714165 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:53:49.276834182 UTC

[section ""data" . GHC.Integer.Type.$WPositive_closure" {
     GHC.Integer.Type.$WPositive_closure:
         const GHC.Integer.Type.$WPositive_info;
 },
 GHC.Integer.Type.$WPositive_entry() //  [R2]
         { info_tbl: [(c4MC,
                       label: GHC.Integer.Type.$WPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4MG; else goto c4MH;
       c4MG: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$WPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MH: // global
           I64[Sp - 8] = block_c4Mz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ML; else goto c4MA;
       u4ML: // global
           call _c4Mz(R1) args: 0, res: 0, upd: 0;
       c4MA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Mz() //  [R1]
         { info_tbl: [(c4Mz,
                       label: block_c4Mz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4MK; else goto c4MJ;
       c4MK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4MJ: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.279532585 UTC

[section ""data" . GHC.Integer.Type.$WNegative_closure" {
     GHC.Integer.Type.$WNegative_closure:
         const GHC.Integer.Type.$WNegative_info;
 },
 GHC.Integer.Type.$WNegative_entry() //  [R2]
         { info_tbl: [(c4MT,
                       label: GHC.Integer.Type.$WNegative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4MX; else goto c4MY;
       c4MX: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$WNegative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MY: // global
           I64[Sp - 8] = block_c4MQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4N2; else goto c4MR;
       u4N2: // global
           call _c4MQ(R1) args: 0, res: 0, upd: 0;
       c4MR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MQ() //  [R1]
         { info_tbl: [(c4MQ,
                       label: block_c4MQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4N1; else goto c4N0;
       c4N1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4N0: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.282151141 UTC

[section ""data" . GHC.Integer.Type.$WSome_closure" {
     GHC.Integer.Type.$WSome_closure:
         const GHC.Integer.Type.$WSome_info;
 },
 GHC.Integer.Type.$WSome_entry() //  [R2, R3]
         { info_tbl: [(c4Na,
                       label: GHC.Integer.Type.$WSome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Na: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ne; else goto c4Nf;
       c4Ne: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$WSome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Nf: // global
           I64[Sp - 16] = block_c4N7_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Nj; else goto c4N8;
       u4Nj: // global
           call _c4N7(R1) args: 0, res: 0, upd: 0;
       c4N8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4N7() //  [R1]
         { info_tbl: [(c4N7,
                       label: block_c4N7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Ni; else goto c4Nh;
       c4Ni: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Nh: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.283463099 UTC

[section ""data" . GHC.Integer.Type.errorPositive_closure" {
     GHC.Integer.Type.errorPositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 47;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.284217301 UTC

[section ""data" . GHC.Integer.Type.errorInteger_closure" {
     GHC.Integer.Type.errorInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.errorPositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.285579448 UTC

[section ""data" . GHC.Integer.Type.wordToInteger_closure" {
     GHC.Integer.Type.wordToInteger_closure:
         const GHC.Integer.Type.wordToInteger_info;
 },
 GHC.Integer.Type.wordToInteger_entry() //  [R2]
         { info_tbl: [(c4Ns,
                       label: GHC.Integer.Type.wordToInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ns: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4Nw; else goto c4Nv;
       c4Nw: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Integer.Type.wordToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Nv: // global
           if (R2 == 0) goto c4Nr; else goto c4Nq;
       c4Nr: // global
           Hp = Hp - 40;
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Nq: // global
           I64[Hp - 32] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 24] = GHC.Integer.Type.None_closure+2;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.287202416 UTC

[section ""data" . GHC.Integer.Type.integerToWord_closure" {
     GHC.Integer.Type.integerToWord_closure:
         const GHC.Integer.Type.integerToWord_info;
 },
 GHC.Integer.Type.integerToWord_entry() //  [R2]
         { info_tbl: [(c4NM,
                       label: GHC.Integer.Type.integerToWord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4NN; else goto c4NO;
       c4NN: // global
           R2 = R2;
           R1 = GHC.Integer.Type.integerToWord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4NO: // global
           I64[Sp - 8] = block_c4NE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Ow; else goto c4NF;
       u4Ow: // global
           call _c4NE(R1) args: 0, res: 0, upd: 0;
       c4NF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NE() //  [R1]
         { info_tbl: [(c4NE,
                       label: block_c4NE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NE: // global
           _c4NL::P64 = R1 & 7;
           if (_c4NL::P64 < 3) goto u4Op; else goto u4Oq;
       u4Op: // global
           if (_c4NL::P64 < 2) goto c4NI; else goto c4NJ;
       c4NI: // global
           I64[Sp] = block_c4NR_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u4Ot; else goto c4NT;
       u4Ot: // global
           call _c4NR(R1) args: 0, res: 0, upd: 0;
       c4NT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NJ: // global
           I64[Sp] = block_c4O6_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u4Ou; else goto c4O8;
       u4Ou: // global
           call _c4O6(R1) args: 0, res: 0, upd: 0;
       c4O8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Oq: // global
           Sp = Sp + 8;
           call _c4NK() args: 0, res: 0, upd: 0;
     }
 },
 _c4NR() //  [R1]
         { info_tbl: [(c4NR,
                       label: block_c4NR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NR: // global
           if (R1 & 7 == 1) goto c4NZ; else goto u4Or;
       c4NZ: // global
           R1 = I64[R1 + 15];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Or: // global
           Sp = Sp + 8;
           call _c4NK() args: 0, res: 0, upd: 0;
     }
 },
 _c4O6() //  [R1]
         { info_tbl: [(c4O6,
                       label: block_c4O6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O6: // global
           if (R1 & 7 == 1) goto c4Of; else goto u4Os;
       c4Of: // global
           R1 = 0 - I64[R1 + 15];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Os: // global
           Sp = Sp + 8;
           call _c4NK() args: 0, res: 0, upd: 0;
     }
 },
 _c4NK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NK: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.289700311 UTC

[section ""data" . GHC.Integer.Type.integerToInt_closure" {
     GHC.Integer.Type.integerToInt_closure:
         const GHC.Integer.Type.integerToInt_info;
 },
 GHC.Integer.Type.integerToInt_entry() //  [R2]
         { info_tbl: [(c4OF,
                       label: GHC.Integer.Type.integerToInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4OJ; else goto c4OK;
       c4OJ: // global
           R2 = R2;
           R1 = GHC.Integer.Type.integerToInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4OK: // global
           I64[Sp - 8] = block_c4OD_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4OD() //  [R1]
         { info_tbl: [(c4OD,
                       label: block_c4OD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OD: // global
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.290777005 UTC

[section ""data" . GHC.Integer.Type.hashInteger_closure" {
     GHC.Integer.Type.hashInteger_closure:
         const GHC.Integer.Type.hashInteger_info;
 },
 GHC.Integer.Type.hashInteger_entry() //  [R2]
         { info_tbl: [(c4OQ,
                       label: GHC.Integer.Type.hashInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OQ: // global
           R2 = R2;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.292347391 UTC

[section ""data" . GHC.Integer.Type.flipBitsDigits_closure" {
     GHC.Integer.Type.flipBitsDigits_closure:
         const GHC.Integer.Type.flipBitsDigits_info;
 },
 GHC.Integer.Type.flipBitsDigits_entry() //  [R2]
         { info_tbl: [(c4P4,
                       label: GHC.Integer.Type.flipBitsDigits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4P5; else goto c4P6;
       c4P5: // global
           R2 = R2;
           R1 = GHC.Integer.Type.flipBitsDigits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4P6: // global
           I64[Sp - 8] = block_c4OX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Po; else goto c4OY;
       u4Po: // global
           call _c4OX(R1) args: 0, res: 0, upd: 0;
       c4OY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4OX() //  [R1]
         { info_tbl: [(c4OX,
                       label: block_c4OX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OX: // global
           if (R1 & 7 == 1) goto c4P1; else goto c4P2;
       c4P1: // global
           I64[Sp - 8] = block_c4P9_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
       c4P2: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4P9() //  [R1]
         { info_tbl: [(c4P9,
                       label: block_c4P9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Pk; else goto c4Pj;
       c4Pk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Pj: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = ~I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.293930869 UTC

[section ""data" . GHC.Integer.Type.flipBits1_closure" {
     GHC.Integer.Type.flipBits1_closure:
         const GHC.Integer.Type.flipBits1_info;
 },
 GHC.Integer.Type.flipBits1_entry() //  [R2]
         { info_tbl: [(c4Pt,
                       label: GHC.Integer.Type.flipBits1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pt: // global
           R2 = R2;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.29491539 UTC

[section ""data" . GHC.Integer.Type.flipBits_closure" {
     GHC.Integer.Type.flipBits_closure:
         const GHC.Integer.Type.flipBits_info;
 },
 GHC.Integer.Type.flipBits_entry() //  [R2]
         { info_tbl: [(c4PA,
                       label: GHC.Integer.Type.flipBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PA: // global
           R2 = R2;
           call GHC.Integer.Type.flipBits1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.296533759 UTC

[section ""data" . GHC.Integer.Type.negateInteger_closure" {
     GHC.Integer.Type.negateInteger_closure:
         const GHC.Integer.Type.negateInteger_info;
 },
 GHC.Integer.Type.negateInteger_entry() //  [R2]
         { info_tbl: [(c4PP,
                       label: GHC.Integer.Type.negateInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4PQ; else goto c4PR;
       c4PQ: // global
           R2 = R2;
           R1 = GHC.Integer.Type.negateInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PR: // global
           I64[Sp - 8] = block_c4PH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Q8; else goto c4PI;
       u4Q8: // global
           call _c4PH(R1) args: 0, res: 0, upd: 0;
       c4PI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PH() //  [R1]
         { info_tbl: [(c4PH,
                       label: block_c4PH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PH: // global
           _c4PO::P64 = R1 & 7;
           if (_c4PO::P64 < 3) goto u4Q7; else goto c4PN;
       u4Q7: // global
           if (_c4PO::P64 < 2) goto c4PL; else goto c4PM;
       c4PL: // global
           Hp = Hp + 16;
           _s3C2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4Q3; else goto c4PW;
       c4PW: // global
           _s3C3::P64 = P64[_s3C2::P64 + 7];
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = _s3C3::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PM: // global
           Hp = Hp + 16;
           _s3C2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4Q3; else goto c4Q2;
       c4Q3: // global
           HpAlloc = 16;
           R1 = _s3C2::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Q2: // global
           _s3C4::P64 = P64[_s3C2::P64 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3C4::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PN: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.298550855 UTC

[section ""data" . GHC.Integer.Type.smallInteger_closure" {
     GHC.Integer.Type.smallInteger_closure:
         const GHC.Integer.Type.smallInteger_info;
 },
 GHC.Integer.Type.smallInteger_entry() //  [R2]
         { info_tbl: [(c4Qi,
                       label: GHC.Integer.Type.smallInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Qj; else goto c4Qk;
       c4Qj: // global
           R2 = R2;
           R1 = GHC.Integer.Type.smallInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Qk: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c4Qg; else goto c4Qh;
       c4Qg: // global
           I64[Sp - 8] = block_c4Qs_info;
           R2 = -R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c4Qh: // global
           R2 = R2;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c4Qs() //  [R1]
         { info_tbl: [(c4Qs,
                       label: block_c4Qs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qs: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.300429294 UTC

[section ""data" . GHC.Integer.Type.decodeFloatInteger_closure" {
     GHC.Integer.Type.decodeFloatInteger_closure:
         const GHC.Integer.Type.decodeFloatInteger_info;
 },
 sat_s3Cf_entry() //  [R1]
         { info_tbl: [(c4QL,
                       label: sat_s3Cf_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QM; else goto c4QN;
       c4QM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.decodeFloatInteger_entry() //  [F1]
         { info_tbl: [(c4QO,
                       label: GHC.Integer.Type.decodeFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 6} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4QP; else goto c4QQ;
       c4QP: // global
           F1 = F1;
           R1 = GHC.Integer.Type.decodeFloatInteger_closure;
           call (stg_gc_fun)(F1, R1) args: 8, res: 0, upd: 8;
       c4QQ: // global
           I64[Sp - 8] = block_c4QD_info;
           F1 = F1;
           Sp = Sp - 8;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _c4QD() //  [R1, R2]
         { info_tbl: [(c4QD,
                       label: block_c4QD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QD: // global
           I64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c4QE() args: 0, res: 0, upd: 0;
     }
 },
 _c4QE() //  []
         { info_tbl: [(c4QE,
                       label: block_c4QE_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4QT; else goto c4QS;
       c4QT: // global
           HpAlloc = 24;
           I64[Sp] = block_c4QE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4QS: // global
           I64[Hp - 16] = sat_s3Cf_info;
           I64[Hp] = I64[Sp + 16];
           R2 = I64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.302335821 UTC

[section ""data" . GHC.Integer.Type.absInteger_closure" {
     GHC.Integer.Type.absInteger_closure:
         const GHC.Integer.Type.absInteger_info;
 },
 GHC.Integer.Type.absInteger_entry() //  [R2]
         { info_tbl: [(c4R7,
                       label: GHC.Integer.Type.absInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4R7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4R8; else goto c4R9;
       c4R8: // global
           R2 = R2;
           R1 = GHC.Integer.Type.absInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4R9: // global
           I64[Sp - 8] = block_c4R0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Rj; else goto c4R1;
       u4Rj: // global
           call _c4R0(R1) args: 0, res: 0, upd: 0;
       c4R1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4R0() //  [R1]
         { info_tbl: [(c4R0,
                       label: block_c4R0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4R0: // global
           if (R1 & 7 == 2) goto c4R5; else goto c4R4;
       c4R5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Ri; else goto c4Rh;
       c4Ri: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Rh: // global
           _s3Ci::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3Ci::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4R4: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.303922049 UTC

[section ""data" . GHC.Integer.Type.onePositive_closure" {
     GHC.Integer.Type.onePositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.30456636 UTC

[section ""data" . GHC.Integer.Type.negativeOneInteger_closure" {
     GHC.Integer.Type.negativeOneInteger_closure:
         const GHC.Integer.Type.Negative_con_info;
         const GHC.Integer.Type.onePositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.305211882 UTC

[section ""data" . GHC.Integer.Type.oneInteger_closure" {
     GHC.Integer.Type.oneInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.onePositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.306674552 UTC

[section ""data" . GHC.Integer.Type.signumInteger_closure" {
     GHC.Integer.Type.signumInteger_closure:
         const GHC.Integer.Type.signumInteger_info;
 },
 GHC.Integer.Type.signumInteger_entry() //  [R2]
         { info_tbl: [(c4Rw,
                       label: GHC.Integer.Type.signumInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Rw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Rx; else goto c4Ry;
       c4Rx: // global
           R2 = R2;
           R1 = GHC.Integer.Type.signumInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Ry: // global
           I64[Sp - 8] = block_c4Ro_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4RJ; else goto c4Rp;
       u4RJ: // global
           call _c4Ro(R1) args: 0, res: 0, upd: 0;
       c4Rp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ro() //  [R1]
         { info_tbl: [(c4Ro,
                       label: block_c4Ro_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ro: // global
           _c4Rv::P64 = R1 & 7;
           if (_c4Rv::P64 < 3) goto u4RI; else goto c4Ru;
       u4RI: // global
           if (_c4Rv::P64 < 2) goto c4Rs; else goto c4Rt;
       c4Rs: // global
           R1 = GHC.Integer.Type.oneInteger_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Rt: // global
           R1 = GHC.Integer.Type.negativeOneInteger_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Ru: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.308061427 UTC

[section ""data" . GHC.Integer.Type.halfBoundUp_closure" {
     GHC.Integer.Type.halfBoundUp_closure:
         const GHC.Integer.Type.halfBoundUp_info;
 },
 GHC.Integer.Type.halfBoundUp_entry() //  [R2]
         { info_tbl: [(c4RR,
                       label: GHC.Integer.Type.halfBoundUp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4RR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4RS; else goto c4RT;
       c4RS: // global
           R2 = R2;
           R1 = GHC.Integer.Type.halfBoundUp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4RT: // global
           I64[Sp - 8] = block_c4RO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4RX; else goto c4RP;
       u4RX: // global
           call _c4RO() args: 0, res: 0, upd: 0;
       c4RP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4RO() //  []
         { info_tbl: [(c4RO,
                       label: block_c4RO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4RO: // global
           R1 = 9223372036854775808;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.309865199 UTC

[section ""data" . GHC.Integer.Type.fullBound_closure" {
     GHC.Integer.Type.fullBound_closure:
         const GHC.Integer.Type.fullBound_info;
 },
 GHC.Integer.Type.fullBound_entry() //  [R2]
         { info_tbl: [(c4S5,
                       label: GHC.Integer.Type.fullBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4S6; else goto c4S7;
       c4S6: // global
           R2 = R2;
           R1 = GHC.Integer.Type.fullBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4S7: // global
           I64[Sp - 8] = block_c4S2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Sb; else goto c4S3;
       u4Sb: // global
           call _c4S2() args: 0, res: 0, upd: 0;
       c4S3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4S2() //  []
         { info_tbl: [(c4S2,
                       label: block_c4S2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S2: // global
           R1 = 18446744073709551615;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.311538064 UTC

[section ""data" . GHC.Integer.Type.$wsuccPositive_closure" {
     GHC.Integer.Type.$wsuccPositive_closure:
         const GHC.Integer.Type.$wsuccPositive_info;
 },
 GHC.Integer.Type.$wsuccPositive_entry() //  [R2]
         { info_tbl: [(c4Sn,
                       label: GHC.Integer.Type.$wsuccPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Sn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4So; else goto c4Sp;
       c4So: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$wsuccPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Sp: // global
           I64[Sp - 8] = block_c4Sg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4SM; else goto c4Sh;
       u4SM: // global
           call _c4Sg(R1) args: 0, res: 0, upd: 0;
       c4Sh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Sg() //  [R1]
         { info_tbl: [(c4Sg,
                       label: block_c4Sg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Sg: // global
           if (R1 & 7 == 1) goto c4Sk; else goto c4Sl;
       c4Sk: // global
           _s3Cu::P64 = P64[R1 + 7];
           _s3Cv::I64 = I64[R1 + 15];
           if (_s3Cv::I64 != 18446744073709551615) goto c4Sv; else goto c4SD;
       c4Sv: // global
           R2 = _s3Cu::P64;
           R1 = _s3Cv::I64 + 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4SD: // global
           I64[Sp] = block_c4Sy_info;
           R2 = _s3Cu::P64;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
       c4Sl: // global
           R2 = GHC.Integer.Type.None_closure+2;
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Sy() //  [R1, R2]
         { info_tbl: [(c4Sy,
                       label: block_c4Sy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Sy: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c4Sz() args: 0, res: 0, upd: 0;
     }
 },
 _c4Sz() //  []
         { info_tbl: [(c4Sz,
                       label: block_c4Sz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Sz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4SG; else goto c4SF;
       c4SG: // global
           HpAlloc = 24;
           I64[Sp] = block_c4Sz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4SF: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = Hp - 15;
           R1 = 0;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.314067263 UTC

[section ""data" . GHC.Integer.Type.succPositive_closure" {
     GHC.Integer.Type.succPositive_closure:
         const GHC.Integer.Type.succPositive_info;
 },
 GHC.Integer.Type.succPositive_entry() //  [R2]
         { info_tbl: [(c4SX,
                       label: GHC.Integer.Type.succPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4SX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4SY; else goto c4SZ;
       c4SY: // global
           R2 = R2;
           R1 = GHC.Integer.Type.succPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4SZ: // global
           I64[Sp - 8] = block_c4SS_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4SS() //  [R1, R2]
         { info_tbl: [(c4SS,
                       label: block_c4SS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4SS: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c4ST() args: 0, res: 0, upd: 0;
     }
 },
 _c4ST() //  []
         { info_tbl: [(c4ST,
                       label: block_c4ST_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ST: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4T2; else goto c4T1;
       c4T2: // global
           HpAlloc = 24;
           I64[Sp] = block_c4ST_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4T1: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.315728226 UTC

[section ""data" . lvl_r3Bo_closure" {
     lvl_r3Bo_closure:
         const lvl_r3Bo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r3Bo_entry() //  [R1]
         { info_tbl: [(c4Tg,
                       label: lvl_r3Bo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Tg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4Th; else goto c4Ti;
       c4Th: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ti: // global
           (_c4T8::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4T8::I64 == 0) goto c4Ta; else goto c4T9;
       c4Ta: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4T9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4T8::I64;
           I64[Sp - 24] = block_c4Tb_info;
           R2 = GHC.Integer.Type.None_closure+2;
           Sp = Sp - 24;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4Tb() //  [R1, R2]
         { info_tbl: [(c4Tb,
                       label: block_c4Tb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Tb: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c4Tc() args: 0, res: 0, upd: 0;
     }
 },
 _c4Tc() //  []
         { info_tbl: [(c4Tc,
                       label: block_c4Tc_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Tc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Tl; else goto c4Tk;
       c4Tl: // global
           HpAlloc = 24;
           I64[Sp] = block_c4Tc_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c4Tk: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.319345444 UTC

[section ""data" . GHC.Integer.Type.plusPositive_addWithCarry_closure" {
     GHC.Integer.Type.plusPositive_addWithCarry_closure:
         const GHC.Integer.Type.plusPositive_addWithCarry_info;
         const 0;
 },
 GHC.Integer.Type.plusPositive_addWithCarry_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Tz,
                       label: GHC.Integer.Type.plusPositive_addWithCarry_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Tz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4TA; else goto u4W6;
       c4TA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.plusPositive_addWithCarry_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u4W6: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4Tp() args: 0, res: 0, upd: 0;
     }
 },
 _c4Tp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Tp: // global
           I64[Sp - 8] = block_c4Ts_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Wa; else goto c4Tt;
       u4Wa: // global
           call _c4Ts(R1) args: 0, res: 0, upd: 0;
       c4Tt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ts() //  [R1]
         { info_tbl: [(c4Ts,
                       label: block_c4Ts_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ts: // global
           _s3CK::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c4Tw; else goto c4Tx;
       c4Tw: // global
           I64[Sp - 8] = block_c4TE_info;
           _s3CL::P64 = R1;
           _s3CN::P64 = P64[R1 + 7];
           _s3CM::I64 = I64[R1 + 15];
           R1 = _s3CK::P64;
           P64[Sp] = _s3CN::P64;
           I64[Sp + 16] = _s3CM::I64;
           P64[Sp + 24] = _s3CL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Wb; else goto c4TG;
       u4Wb: // global
           call _c4TE(R1) args: 0, res: 0, upd: 0;
       c4TG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Tx: // global
           I64[Sp] = block_c4VA_info;
           R1 = _s3CK::P64;
           if (R1 & 7 != 0) goto u4Wc; else goto c4VC;
       u4Wc: // global
           call _c4VA(R1) args: 0, res: 0, upd: 0;
       c4VC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4TE() //  [R1]
         { info_tbl: [(c4TE,
                       label: block_c4TE_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4TE: // global
           _s3CI::I64 = I64[Sp + 16];
           _s3CL::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c4Vg; else goto c4Vx;
       c4Vg: // global
           _s3CM::I64 = I64[Sp + 24];
           _s3CP::I64 = I64[R1 + 15];
           if (_s3CM::I64 >= _s3CP::I64) goto c4Vd; else goto c4Ve;
       c4Vd: // global
           _s3CN::P64 = P64[Sp + 8];
           _s3CQ::P64 = P64[R1 + 7];
           if (_s3CP::I64 < 9223372036854775808) goto c4UP; else goto c4V8;
       c4UP: // global
           if (_s3CM::I64 < 9223372036854775808) goto c4U6; else goto c4UN;
       c4U6: // global
           I64[Sp + 8] = block_c4TU_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 0;
           I64[Sp + 32] = _s3CP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c4UN: // global
           _s3CX::I64 = (_s3CM::I64 + -9223372036854775808) + (_s3CP::I64 + _s3CI::I64);
           if (_s3CX::I64 >= 9223372036854775808) goto c4Uw; else goto c4UJ;
       c4Uw: // global
           I64[Sp + 24] = block_c4Un_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 1;
           I64[Sp + 32] = _s3CX::I64;
           Sp = Sp + 24;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c4UJ: // global
           I64[Sp + 24] = block_c4UB_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 0;
           I64[Sp + 32] = _s3CX::I64;
           Sp = Sp + 24;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c4V8: // global
           I64[Sp + 8] = block_c4UR_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 1;
           I64[Sp + 32] = _s3CP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c4Ve: // global
           I64[Sp + 16] = _s3CI::I64;
           P64[Sp + 24] = R1;
           P64[Sp + 32] = _s3CL::P64;
           Sp = Sp + 16;
           call _c4Tp() args: 0, res: 0, upd: 0;
       c4Vx: // global
           if (_s3CI::I64 == 0) goto c4Vw; else goto c4Vs;
       c4Vw: // global
           R1 = _s3CL::P64 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4Vs: // global
           I64[Sp + 32] = block_c4Vm_info;
           R2 = _s3CL::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4TU() //  [R1]
         { info_tbl: [(c4TU,
                       label: block_c4TU_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4TU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4U9; else goto c4U8;
       c4U9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4U8: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] + (I64[Sp + 24] + I64[Sp + 8]);
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Un() //  [R1]
         { info_tbl: [(c4Un,
                       label: block_c4Un_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Un: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Uz; else goto c4Uy;
       c4Uz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Uy: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - 9223372036854775808;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4UB() //  [R1]
         { info_tbl: [(c4UB,
                       label: block_c4UB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4UB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4UM; else goto c4UL;
       c4UM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4UL: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - 9223372036854775808;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4UR() //  [R1]
         { info_tbl: [(c4UR,
                       label: block_c4UR_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4UR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Vb; else goto c4Va;
       c4Vb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Va: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] + (I64[Sp + 24] + I64[Sp + 8]);
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Vm() //  [R1, R2]
         { info_tbl: [(c4Vm,
                       label: block_c4Vm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Vm: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c4Vn() args: 0, res: 0, upd: 0;
     }
 },
 _c4Vn() //  []
         { info_tbl: [(c4Vn,
                       label: block_c4Vn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Vn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Vv; else goto c4Vu;
       c4Vv: // global
           HpAlloc = 24;
           I64[Sp] = block_c4Vn_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4Vu: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4VA() //  [R1]
         { info_tbl: [(c4VA,
                       label: block_c4VA_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4VA: // global
           _s3CI::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c4VV; else goto c4W3;
       c4VV: // global
           if (_s3CI::I64 == 0) goto c4VT; else goto c4VP;
       c4VT: // global
           R1 = R1 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4VP: // global
           I64[Sp + 24] = block_c4VJ_info;
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
       c4W3: // global
           if (_s3CI::I64 == 0) goto c4W2; else goto c4W1;
       c4W2: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4W1: // global
           R1 = lvl_r3Bo_closure;
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4VJ() //  [R1, R2]
         { info_tbl: [(c4VJ,
                       label: block_c4VJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4VJ: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c4VK() args: 0, res: 0, upd: 0;
     }
 },
 _c4VK() //  []
         { info_tbl: [(c4VK,
                       label: block_c4VK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4VK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4VS; else goto c4VR;
       c4VS: // global
           HpAlloc = 24;
           I64[Sp] = block_c4VK_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4VR: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.32453507 UTC

[section ""data" . GHC.Integer.Type.plusPositive_closure" {
     GHC.Integer.Type.plusPositive_closure:
         const GHC.Integer.Type.plusPositive_info;
         const 0;
 },
 GHC.Integer.Type.plusPositive_entry() //  [R2, R3]
         { info_tbl: [(c4Wl,
                       label: GHC.Integer.Type.plusPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Wl: // global
           R4 = R3;
           R3 = R2;
           R2 = 0;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.326985305 UTC

[section ""data" . GHC.Integer.Type.minusPositive_closure" {
     GHC.Integer.Type.minusPositive_closure:
         const GHC.Integer.Type.minusPositive_info;
 },
 GHC.Integer.Type.minusPositive_entry() //  [R2, R3]
         { info_tbl: [(c4Wz,
                       label: GHC.Integer.Type.minusPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Wz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4WA; else goto c4WB;
       c4WA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.minusPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4WB: // global
           I64[Sp - 16] = block_c4Ws_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Yc; else goto c4Wt;
       u4Yc: // global
           call _c4Ws(R1) args: 0, res: 0, upd: 0;
       c4Wt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ws() //  [R1]
         { info_tbl: [(c4Ws,
                       label: block_c4Ws_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ws: // global
           _s3Dp::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c4Ww; else goto c4Wx;
       c4Ww: // global
           I64[Sp - 16] = block_c4WE_info;
           _s3Dq::P64 = R1;
           _s3Ds::P64 = P64[R1 + 7];
           _s3Dr::I64 = I64[R1 + 15];
           R1 = _s3Dp::P64;
           P64[Sp - 8] = _s3Ds::P64;
           I64[Sp] = _s3Dr::I64;
           P64[Sp + 8] = _s3Dq::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Ya; else goto c4WG;
       u4Ya: // global
           call _c4WE(R1) args: 0, res: 0, upd: 0;
       c4WG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Wx: // global
           I64[Sp + 8] = block_c4XS_info;
           R1 = _s3Dp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Yb; else goto c4XU;
       u4Yb: // global
           call _c4XS(R1) args: 0, res: 0, upd: 0;
       c4XU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4WE() //  [R1]
         { info_tbl: [(c4WE,
                       label: block_c4WE_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4WE: // global
           if (R1 & 7 == 1) goto c4XL; else goto c4XP;
       c4XL: // global
           _s3Dr::I64 = I64[Sp + 16];
           _s3Ds::P64 = P64[Sp + 8];
           _s3Dv::P64 = P64[R1 + 7];
           _s3Du::I64 = I64[R1 + 15];
           if (_s3Dr::I64 == _s3Du::I64) goto c4Xw; else goto c4Xt;
       c4Xw: // global
           I64[Sp + 24] = block_c4Xv_info;
           R3 = _s3Dv::P64;
           R2 = _s3Ds::P64;
           Sp = Sp + 24;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c4Xt: // global
           if (_s3Dr::I64 <= _s3Du::I64) goto c4Xa; else goto c4Xo;
       c4Xa: // global
           I64[Sp + 8] = block_c4WR_info;
           R3 = _s3Dv::P64;
           R2 = _s3Ds::P64;
           I64[Sp + 24] = _s3Du::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c4Xo: // global
           I64[Sp + 8] = block_c4Xg_info;
           R3 = _s3Dv::P64;
           R2 = _s3Ds::P64;
           I64[Sp + 24] = _s3Du::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c4XP: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Xv() //  [R1]
         { info_tbl: [(c4Xv,
                       label: block_c4Xv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Xv: // global
           if (R1 & 7 == 1) goto c4XC; else goto u4Y9;
       c4XC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4XF; else goto c4XE;
       c4XF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4XE: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Y9: // global
           Sp = Sp + 8;
           call _c4Y4() args: 0, res: 0, upd: 0;
     }
 },
 _c4WR() //  [R1]
         { info_tbl: [(c4WR,
                       label: block_c4WR_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4WR: // global
           I64[Sp] = block_c4WV_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = R1;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4WV() //  [R1]
         { info_tbl: [(c4WV,
                       label: block_c4WV_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4WV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Xe; else goto c4Xd;
       c4Xe: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Xd: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 18446744073709551615 - I64[Sp + 16] + (I64[Sp + 8] + 1);
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Xg() //  [R1]
         { info_tbl: [(c4Xg,
                       label: block_c4Xg_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Xg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Xr; else goto c4Xq;
       c4Xr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Xq: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4XS() //  [R1]
         { info_tbl: [(c4XS,
                       label: block_c4XS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4XS: // global
           if (R1 & 7 == 1) goto c4Y0; else goto u4Y8;
       c4Y0: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Y8: // global
           Sp = Sp + 8;
           call _c4Y4() args: 0, res: 0, upd: 0;
     }
 },
 _c4Y4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Y4: // global
           R1 = GHC.Integer.Type.None_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.330274068 UTC

[section ""data" . GHC.Integer.Type.twosComplementPositive1_closure" {
     GHC.Integer.Type.twosComplementPositive1_closure:
         const GHC.Integer.Type.twosComplementPositive1_info;
 },
 GHC.Integer.Type.twosComplementPositive1_entry() //  [R2]
         { info_tbl: [(c4Yl,
                       label: GHC.Integer.Type.twosComplementPositive1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Yl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Ym; else goto c4Yn;
       c4Ym: // global
           R2 = R2;
           R1 = GHC.Integer.Type.twosComplementPositive1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Yn: // global
           I64[Sp - 8] = block_c4Yj_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Yj() //  [R1]
         { info_tbl: [(c4Yj,
                       label: block_c4Yj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Yj: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.331287647 UTC

[section ""data" . GHC.Integer.Type.twosComplementPositive_closure" {
     GHC.Integer.Type.twosComplementPositive_closure:
         const GHC.Integer.Type.twosComplementPositive_info;
 },
 GHC.Integer.Type.twosComplementPositive_entry() //  [R2]
         { info_tbl: [(c4Yv,
                       label: GHC.Integer.Type.twosComplementPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Yv: // global
           R2 = R2;
           call GHC.Integer.Type.twosComplementPositive1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.332433304 UTC

[section ""data" . GHC.Integer.Type.lowHalfMask_closure" {
     GHC.Integer.Type.lowHalfMask_closure:
         const GHC.Integer.Type.lowHalfMask_info;
 },
 GHC.Integer.Type.lowHalfMask_entry() //  [R2]
         { info_tbl: [(c4YF,
                       label: GHC.Integer.Type.lowHalfMask_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4YF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4YG; else goto c4YH;
       c4YG: // global
           R2 = R2;
           R1 = GHC.Integer.Type.lowHalfMask_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4YH: // global
           I64[Sp - 8] = block_c4YC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4YL; else goto c4YD;
       u4YL: // global
           call _c4YC() args: 0, res: 0, upd: 0;
       c4YD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4YC() //  []
         { info_tbl: [(c4YC,
                       label: block_c4YC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4YC: // global
           R1 = 4294967295;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.333625151 UTC

[section ""data" . GHC.Integer.Type.highHalfShift_closure" {
     GHC.Integer.Type.highHalfShift_closure:
         const GHC.Integer.Type.highHalfShift_info;
 },
 GHC.Integer.Type.highHalfShift_entry() //  [R2]
         { info_tbl: [(c4YT,
                       label: GHC.Integer.Type.highHalfShift_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4YT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4YU; else goto c4YV;
       c4YU: // global
           R2 = R2;
           R1 = GHC.Integer.Type.highHalfShift_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4YV: // global
           I64[Sp - 8] = block_c4YQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4YZ; else goto c4YR;
       u4YZ: // global
           call _c4YQ() args: 0, res: 0, upd: 0;
       c4YR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4YQ() //  []
         { info_tbl: [(c4YQ,
                       label: block_c4YQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4YQ: // global
           R1 = 32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.33496107 UTC

[section ""data" . GHC.Integer.Type.splitHalves_closure" {
     GHC.Integer.Type.splitHalves_closure:
         const GHC.Integer.Type.splitHalves_info;
 },
 GHC.Integer.Type.splitHalves_entry() //  [R2]
         { info_tbl: [(c4Z6,
                       label: GHC.Integer.Type.splitHalves_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Z6: // global
           _s3DS::I64 = R2 >> 32;
           R2 = R2 & 4294967295;
           R1 = _s3DS::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.33628796 UTC

[section ""data" . GHC.Integer.Type.doubleFromPositive_closure" {
     GHC.Integer.Type.doubleFromPositive_closure:
         const GHC.Integer.Type.doubleFromPositive_info;
 },
 GHC.Integer.Type.doubleFromPositive_entry() //  [R2]
         { info_tbl: [(c4Zm,
                       label: GHC.Integer.Type.doubleFromPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Zm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Zn; else goto c4Zo;
       c4Zn: // global
           R2 = R2;
           R1 = GHC.Integer.Type.doubleFromPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Zo: // global
           I64[Sp - 8] = block_c4Zf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u50c; else goto c4Zg;
       u50c: // global
           call _c4Zf(R1) args: 0, res: 0, upd: 0;
       c4Zg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Zf() //  [R1]
         { info_tbl: [(c4Zf,
                       label: block_c4Zf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Zf: // global
           if (R1 & 7 == 1) goto c4Zj; else goto c4Zk;
       c4Zj: // global
           I64[Sp - 8] = block_c4Zr_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c4Zk: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Zr() //  [D1]
         { info_tbl: [(c4Zr,
                       label: block_c4Zr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Zr: // global
           _s3DW::I64 = I64[Sp + 8];
           _s3DY::F64 = D1;
           (_c4ZE::F64) = call MO_F64_Pwr(2.0 :: W64, 32.0 :: W64);
           (_c4ZV::F64) = call MO_F64_Pwr(2.0 :: W64, 64.0 :: W64);
           D1 = %MO_F_Add_W64(%MO_F_Add_W64(%MO_F_Mul_W64(_s3DY::F64,
                                                          _c4ZV::F64),
                                            %MO_F_Mul_W64(%MO_SF_Conv_W64_W64(_s3DW::I64 >> 32),
                                                          _c4ZE::F64)),
                              %MO_SF_Conv_W64_W64(_s3DW::I64 & 4294967295));
           Sp = Sp + 16;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.338698158 UTC

[section ""data" . GHC.Integer.Type.doubleFromInteger_closure" {
     GHC.Integer.Type.doubleFromInteger_closure:
         const GHC.Integer.Type.doubleFromInteger_info;
 },
 GHC.Integer.Type.doubleFromInteger_entry() //  [R2]
         { info_tbl: [(c50p,
                       label: GHC.Integer.Type.doubleFromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c50p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c50q; else goto c50r;
       c50q: // global
           R2 = R2;
           R1 = GHC.Integer.Type.doubleFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c50r: // global
           I64[Sp - 8] = block_c50h_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u50I; else goto c50i;
       u50I: // global
           call _c50h(R1) args: 0, res: 0, upd: 0;
       c50i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c50h() //  [R1]
         { info_tbl: [(c50h,
                       label: block_c50h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c50h: // global
           _c50o::P64 = R1 & 7;
           if (_c50o::P64 < 3) goto u50H; else goto c50n;
       u50H: // global
           if (_c50o::P64 < 2) goto c50l; else goto c50m;
       c50l: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 0, upd: 8;
       c50m: // global
           I64[Sp] = block_c50x_info;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c50n: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 _c50x() //  [D1]
         { info_tbl: [(c50x,
                       label: block_c50x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c50x: // global
           D1 = %MO_F_Neg_W64(D1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.340538914 UTC

[section ""data" . GHC.Integer.Type.floatFromPositive_closure" {
     GHC.Integer.Type.floatFromPositive_closure:
         const GHC.Integer.Type.floatFromPositive_info;
 },
 GHC.Integer.Type.floatFromPositive_entry() //  [R2]
         { info_tbl: [(c50U,
                       label: GHC.Integer.Type.floatFromPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c50U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c50V; else goto c50W;
       c50V: // global
           R2 = R2;
           R1 = GHC.Integer.Type.floatFromPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c50W: // global
           I64[Sp - 8] = block_c50N_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u51K; else goto c50O;
       u51K: // global
           call _c50N(R1) args: 0, res: 0, upd: 0;
       c50O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c50N() //  [R1]
         { info_tbl: [(c50N,
                       label: block_c50N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c50N: // global
           if (R1 & 7 == 1) goto c50R; else goto c50S;
       c50R: // global
           I64[Sp - 8] = block_c50Z_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c50S: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 _c50Z() //  [F1]
         { info_tbl: [(c50Z,
                       label: block_c50Z_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c50Z: // global
           _s3Eh::I64 = I64[Sp + 8];
           _s3Ej::F32 = F1;
           (_c51c::F32) = call MO_F32_Pwr(2.0 :: W32, 32.0 :: W32);
           (_c51t::F32) = call MO_F32_Pwr(2.0 :: W32, 64.0 :: W32);
           F1 = %MO_F_Add_W32(%MO_F_Add_W32(%MO_F_Mul_W32(_s3Ej::F32,
                                                          _c51t::F32),
                                            %MO_F_Mul_W32(%MO_SF_Conv_W64_W32(_s3Eh::I64 >> 32),
                                                          _c51c::F32)),
                              %MO_SF_Conv_W64_W32(_s3Eh::I64 & 4294967295));
           Sp = Sp + 16;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.342901746 UTC

[section ""data" . GHC.Integer.Type.floatFromInteger_closure" {
     GHC.Integer.Type.floatFromInteger_closure:
         const GHC.Integer.Type.floatFromInteger_info;
 },
 GHC.Integer.Type.floatFromInteger_entry() //  [R2]
         { info_tbl: [(c51X,
                       label: GHC.Integer.Type.floatFromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c51X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c51Y; else goto c51Z;
       c51Y: // global
           R2 = R2;
           R1 = GHC.Integer.Type.floatFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c51Z: // global
           I64[Sp - 8] = block_c51P_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u52g; else goto c51Q;
       u52g: // global
           call _c51P(R1) args: 0, res: 0, upd: 0;
       c51Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c51P() //  [R1]
         { info_tbl: [(c51P,
                       label: block_c51P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c51P: // global
           _c51W::P64 = R1 & 7;
           if (_c51W::P64 < 3) goto u52f; else goto c51V;
       u52f: // global
           if (_c51W::P64 < 2) goto c51T; else goto c51U;
       c51T: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 0, upd: 8;
       c51U: // global
           I64[Sp] = block_c525_info;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c51V: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 _c525() //  [F1]
         { info_tbl: [(c525,
                       label: block_c525_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c525: // global
           F1 = %MO_F_Neg_W32(F1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.34562463 UTC

[section ""data" . GHC.Integer.Type.timesDigit_closure" {
     GHC.Integer.Type.timesDigit_closure:
         const GHC.Integer.Type.timesDigit_info;
         const 0;
 },
 GHC.Integer.Type.timesDigit_entry() //  [R2, R3]
         { info_tbl: [(c52n,
                       label: GHC.Integer.Type.timesDigit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c52n: // global
           _s3EB::I64 = R3;
           _s3EA::I64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c531; else goto c532;
       c532: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c534; else goto c533;
       c534: // global
           HpAlloc = 72;
           goto c531;
       c531: // global
           R3 = _s3EB::I64;
           R2 = _s3EA::I64;
           R1 = GHC.Integer.Type.timesDigit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c533: // global
           I64[Hp - 64] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 56] = GHC.Integer.Type.None_closure+2;
           _s3ED::I64 = _s3EB::I64 & 4294967295;
           _s3EF::I64 = _s3EA::I64 & 4294967295;
           I64[Hp - 48] = _s3EF::I64 * _s3ED::I64;
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = GHC.Integer.Type.None_closure+2;
           _s3EG::I64 = _s3EB::I64 >> 32;
           _s3EH::I64 = _s3EF::I64 * _s3EG::I64;
           I64[Hp - 24] = _s3EH::I64 & 4294967295 << 32;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           _s3EC::I64 = _s3EA::I64 >> 32;
           _s3EE::I64 = _s3EC::I64 * _s3ED::I64;
           I64[Hp] = _s3EE::I64 & 4294967295 << 32;
           I64[Sp - 48] = block_c52W_info;
           R4 = Hp - 39;
           R3 = Hp - 15;
           R2 = 0;
           P64[Sp - 40] = Hp - 63;
           I64[Sp - 32] = _s3EC::I64;
           I64[Sp - 24] = _s3EE::I64;
           I64[Sp - 16] = _s3EG::I64;
           I64[Sp - 8] = _s3EH::I64;
           Sp = Sp - 48;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c52W() //  [R1]
         { info_tbl: [(c52W,
                       label: block_c52W_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c52W: // global
           _c52H::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c530_info;
           R4 = _c52H::P64;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c530() //  [R1]
         { info_tbl: [(c530,
                       label: block_c530_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c530: // global
           _s3EW::I64 = I64[Sp + 8] * I64[Sp + 24] + ((I64[Sp + 16] >> 32) + (I64[Sp + 32] >> 32));
           if (_s3EW::I64 == 0) goto c53B; else goto u53F;
       c53B: // global
           R1 = R1 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u53F: // global
           I64[Sp + 24] = _s3EW::I64;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call _c53q() args: 0, res: 0, upd: 0;
     }
 },
 _c53q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c53q: // global
           Hp = Hp + 48;
           _s3EW::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c53y; else goto c53x;
       c53y: // global
           HpAlloc = 48;
           I64[Sp] = block_c53p_info;
           R1 = _s3EW::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c53x: // global
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = GHC.Integer.Type.None_closure+2;
           I64[Hp - 24] = _s3EW::I64;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = 0;
           R4 = P64[Sp + 8];
           R3 = Hp - 15;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c53p() //  [R1]
         { info_tbl: [(c53p,
                       label: block_c53p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c53p: // global
           I64[Sp] = R1;
           call _c53q() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.349476784 UTC

[section ""data" . GHC.Integer.Type.timesPositive_closure" {
     GHC.Integer.Type.timesPositive_closure:
         const GHC.Integer.Type.timesPositive_info;
         const 0;
 },
 GHC.Integer.Type.timesPositive_entry() //  [R2, R3]
         { info_tbl: [(c53U,
                       label: GHC.Integer.Type.timesPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c53U: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c53V; else goto u55E;
       c53V: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.timesPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u55E: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c53K() args: 0, res: 0, upd: 0;
     }
 },
 _c53K() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c53K: // global
           _s3EZ::P64 = P64[Sp];
           I64[Sp] = block_c53N_info;
           R1 = _s3EZ::P64;
           if (R1 & 7 != 0) goto u55G; else goto c53O;
       u55G: // global
           call _c53N(R1) args: 0, res: 0, upd: 0;
       c53O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c53N() //  [R1]
         { info_tbl: [(c53N,
                       label: block_c53N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c53N: // global
           _s3F0::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c53R; else goto c53S;
       c53R: // global
           I64[Sp - 16] = block_c53Z_info;
           _s3F1::P64 = R1;
           _s3F3::P64 = P64[R1 + 7];
           _s3F2::I64 = I64[R1 + 15];
           R1 = _s3F0::P64;
           P64[Sp - 8] = _s3F3::P64;
           I64[Sp] = _s3F2::I64;
           P64[Sp + 8] = _s3F1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u55H; else goto c541;
       u55H: // global
           call _c53Z(R1) args: 0, res: 0, upd: 0;
       c541: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c53S: // global
           I64[Sp + 8] = block_c55t_info;
           R1 = _s3F0::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u55I; else goto c55v;
       u55I: // global
           call _c55t() args: 0, res: 0, upd: 0;
       c55v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c53Z() //  [R1]
         { info_tbl: [(c53Z,
                       label: block_c53Z_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c53Z: // global
           if (R1 & 7 == 1) goto c548; else goto c55q;
       c548: // global
           I64[Sp - 16] = block_c545_info;
           _s3F4::P64 = R1;
           _s3F6::P64 = P64[R1 + 7];
           _s3F5::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s3F6::P64;
           I64[Sp] = _s3F5::I64;
           P64[Sp + 8] = _s3F4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u55K; else goto c549;
       u55K: // global
           call _c545(R1) args: 0, res: 0, upd: 0;
       c549: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c55q: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c545() //  [R1]
         { info_tbl: [(c545,
                       label: block_c545_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c545: // global
           _s3F6::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c54g; else goto c55b;
       c54g: // global
           I64[Sp + 8] = block_c54d_info;
           _s3F7::P64 = R1;
           R1 = _s3F6::P64;
           P64[Sp + 40] = _s3F7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u55L; else goto c54h;
       u55L: // global
           call _c54d(R1) args: 0, res: 0, upd: 0;
       c54h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c55b: // global
           I64[Sp + 8] = block_c559_info;
           R1 = _s3F6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u55M; else goto c55c;
       u55M: // global
           call _c559(R1) args: 0, res: 0, upd: 0;
       c55c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c54d() //  [R1]
         { info_tbl: [(c54d,
                       label: block_c54d_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c54d: // global
           _s3F4::P64 = P64[Sp + 16];
           _s3F7::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c54u; else goto c556;
       c54u: // global
           I64[Sp + 8] = block_c54l_info;
           R3 = _s3F4::P64;
           R2 = _s3F7::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c556: // global
           _s3Fh::I64 = I64[Sp + 24];
           if (_s3Fh::I64 != 0) goto c54O; else goto c552;
       c54O: // global
           I64[Sp] = block_c54H_info;
           R3 = _s3F4::P64;
           R2 = _s3F7::P64;
           I64[Sp + 32] = _s3Fh::I64;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c552: // global
           I64[Sp + 32] = block_c54X_info;
           R3 = _s3F4::P64;
           R2 = _s3F7::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c54l() //  [R1]
         { info_tbl: [(c54l,
                       label: block_c54l_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c54l: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c54x; else goto c54w;
       c54x: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c54w: // global
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c54r_info;
           R3 = P64[Sp + 8];
           R2 = Hp - 15;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c54r() //  [R1]
         { info_tbl: [(c54r,
                       label: block_c54r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c54r: // global
           R4 = P64[Sp + 8];
           R3 = R1;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c54H() //  [R1]
         { info_tbl: [(c54H,
                       label: block_c54H_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c54H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c54R; else goto c54Q;
       c54R: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c54Q: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           I64[Sp + 24] = block_c54M_info;
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 32];
           P64[Sp + 32] = Hp - 15;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesDigit_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c54M() //  [R1]
         { info_tbl: [(c54M,
                       label: block_c54M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c54M: // global
           R4 = P64[Sp + 8];
           R3 = R1;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c54X() //  [R1]
         { info_tbl: [(c54X,
                       label: block_c54X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c54X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c555; else goto c554;
       c555: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c554: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c559() //  [R1]
         { info_tbl: [(c559,
                       label: block_c559_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c559: // global
           if (R1 & 7 == 1) goto c55i; else goto c55m;
       c55i: // global
           P64[Sp + 24] = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 32];
           Sp = Sp + 24;
           call _c53K() args: 0, res: 0, upd: 0;
       c55m: // global
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Integer.Type.timesDigit_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _c55t() //  []
         { info_tbl: [(c55t,
                       label: block_c55t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c55t: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.355135602 UTC

[section ""data" . GHC.Integer.Type.timesInteger_closure" {
     GHC.Integer.Type.timesInteger_closure:
         const GHC.Integer.Type.timesInteger_info;
         const 0;
 },
 GHC.Integer.Type.timesInteger_entry() //  [R2, R3]
         { info_tbl: [(c560,
                       label: GHC.Integer.Type.timesInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c560: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c561; else goto c562;
       c561: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.timesInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c562: // global
           I64[Sp - 16] = block_c55S_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57u; else goto c55T;
       u57u: // global
           call _c55S(R1) args: 0, res: 0, upd: 0;
       c55T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c55S() //  [R1]
         { info_tbl: [(c55S,
                       label: block_c55S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c55S: // global
           _s3Fr::P64 = P64[Sp + 8];
           _c55Z::P64 = R1 & 7;
           if (_c55Z::P64 < 3) goto u57m; else goto c55Y;
       u57m: // global
           if (_c55Z::P64 < 2) goto c55W; else goto c55X;
       c55W: // global
           I64[Sp] = block_c565_info;
           _s3Ft::P64 = P64[R1 + 7];
           R1 = _s3Fr::P64;
           P64[Sp + 8] = _s3Ft::P64;
           if (R1 & 7 != 0) goto u57r; else goto c567;
       u57r: // global
           call _c565(R1) args: 0, res: 0, upd: 0;
       c567: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c55X: // global
           I64[Sp] = block_c56E_info;
           _s3Fz::P64 = P64[R1 + 6];
           R1 = _s3Fr::P64;
           P64[Sp + 8] = _s3Fz::P64;
           if (R1 & 7 != 0) goto u57s; else goto c56G;
       u57s: // global
           call _c56E(R1) args: 0, res: 0, upd: 0;
       c56G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c55Y: // global
           I64[Sp + 8] = block_c57d_info;
           R1 = _s3Fr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57t; else goto c57f;
       u57t: // global
           call _c57d() args: 0, res: 0, upd: 0;
       c57f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c565() //  [R1]
         { info_tbl: [(c565,
                       label: block_c565_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c565: // global
           _c57l::P64 = R1 & 7;
           if (_c57l::P64 < 3) goto u57n; else goto u57p;
       u57n: // global
           _s3Ft::P64 = P64[Sp + 8];
           if (_c57l::P64 < 2) goto c56i; else goto c56u;
       c56i: // global
           I64[Sp + 8] = block_c56b_info;
           R3 = P64[R1 + 7];
           R2 = _s3Ft::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c56u: // global
           I64[Sp + 8] = block_c56o_info;
           R3 = P64[R1 + 6];
           R2 = _s3Ft::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       u57p: // global
           Sp = Sp + 16;
           call _c57a() args: 0, res: 0, upd: 0;
     }
 },
 _c56b() //  [R1]
         { info_tbl: [(c56b,
                       label: block_c56b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56l; else goto c56k;
       c56l: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c56k: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c56o() //  [R1]
         { info_tbl: [(c56o,
                       label: block_c56o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56x; else goto c56w;
       c56x: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c56w: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c56E() //  [R1]
         { info_tbl: [(c56E,
                       label: block_c56E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56E: // global
           _c57k::P64 = R1 & 7;
           if (_c57k::P64 < 3) goto u57o; else goto u57q;
       u57o: // global
           _s3Fz::P64 = P64[Sp + 8];
           if (_c57k::P64 < 2) goto c56R; else goto c573;
       c56R: // global
           I64[Sp + 8] = block_c56K_info;
           R3 = P64[R1 + 7];
           R2 = _s3Fz::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c573: // global
           I64[Sp + 8] = block_c56X_info;
           R3 = P64[R1 + 6];
           R2 = _s3Fz::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       u57q: // global
           Sp = Sp + 16;
           call _c57a() args: 0, res: 0, upd: 0;
     }
 },
 _c56K() //  [R1]
         { info_tbl: [(c56K,
                       label: block_c56K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56U; else goto c56T;
       c56U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c56T: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c56X() //  [R1]
         { info_tbl: [(c56X,
                       label: block_c56X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c576; else goto c575;
       c576: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c575: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c57a() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57a: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c57d() //  []
         { info_tbl: [(c57d,
                       label: block_c57d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57d: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.358494323 UTC

[section ""data" . GHC.Integer.Type.twoToTheThirtytwoPositive_closure" {
     GHC.Integer.Type.twoToTheThirtytwoPositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 4294967296;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.359199107 UTC

[section ""data" . GHC.Integer.Type.twoToTheThirtytwoInteger_closure" {
     GHC.Integer.Type.twoToTheThirtytwoInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.twoToTheThirtytwoPositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.360553688 UTC

[section ""data" . GHC.Integer.Type.digitsMaybeZeroToInteger_closure" {
     GHC.Integer.Type.digitsMaybeZeroToInteger_closure:
         const GHC.Integer.Type.digitsMaybeZeroToInteger_info;
 },
 GHC.Integer.Type.digitsMaybeZeroToInteger_entry() //  [R2]
         { info_tbl: [(c57I,
                       label: GHC.Integer.Type.digitsMaybeZeroToInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c57J; else goto c57K;
       c57J: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsMaybeZeroToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57K: // global
           I64[Sp - 8] = block_c57B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u57U; else goto c57C;
       u57U: // global
           call _c57B(R1) args: 0, res: 0, upd: 0;
       c57C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57B() //  [R1]
         { info_tbl: [(c57B,
                       label: block_c57B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57B: // global
           if (R1 & 7 == 1) goto c57F; else goto c57G;
       c57F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57Q; else goto c57P;
       c57Q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c57P: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c57G: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.362677454 UTC

[section ""data" . GHC.Integer.Type.removeZeroTails_closure" {
     GHC.Integer.Type.removeZeroTails_closure:
         const GHC.Integer.Type.removeZeroTails_info;
 },
 GHC.Integer.Type.removeZeroTails_entry() //  [R2]
         { info_tbl: [(c586,
                       label: GHC.Integer.Type.removeZeroTails_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c586: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c587; else goto c588;
       c587: // global
           R2 = R2;
           R1 = GHC.Integer.Type.removeZeroTails_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c588: // global
           I64[Sp - 8] = block_c57Z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u58L; else goto c580;
       u58L: // global
           call _c57Z(R1) args: 0, res: 0, upd: 0;
       c580: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Z() //  [R1]
         { info_tbl: [(c57Z,
                       label: block_c57Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Z: // global
           if (R1 & 7 == 1) goto c583; else goto u58I;
       c583: // global
           _s3FN::P64 = P64[R1 + 7];
           _s3FO::I64 = I64[R1 + 15];
           if (_s3FO::I64 != 0) goto c58k; else goto c58q;
       c58k: // global
           I64[Sp - 8] = block_c58e_info;
           R2 = _s3FN::P64;
           I64[Sp] = _s3FO::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
       c58q: // global
           I64[Sp] = block_c58p_info;
           R2 = _s3FN::P64;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
       u58I: // global
           Sp = Sp + 8;
           call _c584() args: 0, res: 0, upd: 0;
     }
 },
 _c58e() //  [R1]
         { info_tbl: [(c58e,
                       label: block_c58e_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c58n; else goto c58m;
       c58n: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c58m: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c58p() //  [R1]
         { info_tbl: [(c58p,
                       label: block_c58p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58p: // global
           if (R1 & 7 == 1) goto c58w; else goto u58J;
       c58w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c58z; else goto c58y;
       c58z: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c58y: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u58J: // global
           Sp = Sp + 8;
           call _c584() args: 0, res: 0, upd: 0;
     }
 },
 _c584() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c584: // global
           R1 = GHC.Integer.Type.None_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.365079197 UTC

[section ""data" . GHC.Integer.Type.digitsToNegativeInteger_closure" {
     GHC.Integer.Type.digitsToNegativeInteger_closure:
         const GHC.Integer.Type.digitsToNegativeInteger_info;
 },
 GHC.Integer.Type.digitsToNegativeInteger_entry() //  [R2]
         { info_tbl: [(c58X,
                       label: GHC.Integer.Type.digitsToNegativeInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c58Y; else goto c58Z;
       c58Y: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsToNegativeInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58Z: // global
           I64[Sp - 8] = block_c58R_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58R() //  [R1]
         { info_tbl: [(c58R,
                       label: block_c58R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58R: // global
           if (R1 & 7 == 1) goto c58U; else goto c58V;
       c58U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c595; else goto c594;
       c595: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c594: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c58V: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.366671752 UTC

[section ""data" . GHC.Integer.Type.digitsToInteger_closure" {
     GHC.Integer.Type.digitsToInteger_closure:
         const GHC.Integer.Type.digitsToInteger_info;
 },
 GHC.Integer.Type.digitsToInteger_entry() //  [R2]
         { info_tbl: [(c59j,
                       label: GHC.Integer.Type.digitsToInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c59k; else goto c59l;
       c59k: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59l: // global
           I64[Sp - 8] = block_c59d_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c59d() //  [R1]
         { info_tbl: [(c59d,
                       label: block_c59d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59d: // global
           if (R1 & 7 == 1) goto c59g; else goto c59h;
       c59g: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c59r; else goto c59q;
       c59r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c59q: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c59h: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.368611908 UTC

[section ""data" . GHC.Integer.Type.comparePositive_closure" {
     GHC.Integer.Type.comparePositive_closure:
         const GHC.Integer.Type.comparePositive_info;
 },
 GHC.Integer.Type.comparePositive_entry() //  [R2, R3]
         { info_tbl: [(c59G,
                       label: GHC.Integer.Type.comparePositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59G: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c59H; else goto c59I;
       c59H: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.comparePositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59I: // global
           I64[Sp - 16] = block_c59z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aK; else goto c59A;
       u5aK: // global
           call _c59z(R1) args: 0, res: 0, upd: 0;
       c59A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59z() //  [R1]
         { info_tbl: [(c59z,
                       label: block_c59z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59z: // global
           _s3G2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c59D; else goto c59E;
       c59D: // global
           I64[Sp - 8] = block_c59L_info;
           _s3G5::P64 = P64[R1 + 7];
           _s3G4::I64 = I64[R1 + 15];
           R1 = _s3G2::P64;
           P64[Sp] = _s3G5::P64;
           I64[Sp + 8] = _s3G4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5aI; else goto c59N;
       u5aI: // global
           call _c59L(R1) args: 0, res: 0, upd: 0;
       c59N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c59E: // global
           I64[Sp + 8] = block_c5am_info;
           R1 = _s3G2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5aJ; else goto c5ao;
       u5aJ: // global
           call _c5am(R1) args: 0, res: 0, upd: 0;
       c5ao: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59L() //  [R1]
         { info_tbl: [(c59L,
                       label: block_c59L_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59L: // global
           if (R1 & 7 == 1) goto c59U; else goto u5aE;
       c59U: // global
           I64[Sp] = block_c59R_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u5aE: // global
           Sp = Sp + 24;
           call _c5aj() args: 0, res: 0, upd: 0;
     }
 },
 _c59R() //  [R1]
         { info_tbl: [(c59R,
                       label: block_c59R_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59R: // global
           if (R1 & 7 == 2) goto c5af; else goto c5a0;
       c5af: // global
           _s3G4::I64 = I64[Sp + 16];
           _s3G7::I64 = I64[Sp + 8];
           if (_s3G4::I64 >= _s3G7::I64) goto c5ad; else goto u5aF;
       c5ad: // global
           if (_s3G4::I64 <= _s3G7::I64) goto u5aH; else goto u5aG;
       u5aH: // global
           Sp = Sp + 24;
           call _c5ay() args: 0, res: 0, upd: 0;
       u5aG: // global
           Sp = Sp + 24;
           call _c5aj() args: 0, res: 0, upd: 0;
       u5aF: // global
           Sp = Sp + 24;
           call _c5au() args: 0, res: 0, upd: 0;
       c5a0: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5aj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aj: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5am() //  [R1]
         { info_tbl: [(c5am,
                       label: block_c5am_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5am: // global
           if (R1 & 7 == 1) goto u5aC; else goto u5aD;
       u5aC: // global
           Sp = Sp + 8;
           call _c5au() args: 0, res: 0, upd: 0;
       u5aD: // global
           Sp = Sp + 8;
           call _c5ay() args: 0, res: 0, upd: 0;
     }
 },
 _c5au() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5au: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5ay() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ay: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.37211614 UTC

[section ""data" . GHC.Integer.Type.compareInteger_closure" {
     GHC.Integer.Type.compareInteger_closure:
         const GHC.Integer.Type.compareInteger_info;
 },
 GHC.Integer.Type.compareInteger_entry() //  [R2, R3]
         { info_tbl: [(c5b3,
                       label: GHC.Integer.Type.compareInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5b4; else goto c5b5;
       c5b4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.compareInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5b5: // global
           I64[Sp - 16] = block_c5aV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5c5; else goto c5aW;
       u5c5: // global
           call _c5aV(R1) args: 0, res: 0, upd: 0;
       c5aW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aV() //  [R1]
         { info_tbl: [(c5aV,
                       label: block_c5aV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aV: // global
           _s3Gg::P64 = P64[Sp + 8];
           _c5b2::P64 = R1 & 7;
           if (_c5b2::P64 < 3) goto u5bW; else goto c5b1;
       u5bW: // global
           if (_c5b2::P64 < 2) goto c5aZ; else goto c5b0;
       c5aZ: // global
           I64[Sp] = block_c5b8_info;
           _s3Gi::P64 = P64[R1 + 7];
           R1 = _s3Gg::P64;
           P64[Sp + 8] = _s3Gi::P64;
           if (R1 & 7 != 0) goto u5c2; else goto c5ba;
       u5c2: // global
           call _c5b8(R1) args: 0, res: 0, upd: 0;
       c5ba: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5b0: // global
           I64[Sp] = block_c5bn_info;
           _s3Gl::P64 = P64[R1 + 6];
           R1 = _s3Gg::P64;
           P64[Sp + 8] = _s3Gl::P64;
           if (R1 & 7 != 0) goto u5c3; else goto c5bp;
       u5c3: // global
           call _c5bn(R1) args: 0, res: 0, upd: 0;
       c5bp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5b1: // global
           I64[Sp + 8] = block_c5bC_info;
           R1 = _s3Gg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5c4; else goto c5bE;
       u5c4: // global
           call _c5bC(R1) args: 0, res: 0, upd: 0;
       c5bE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5b8() //  [R1]
         { info_tbl: [(c5b8,
                       label: block_c5b8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b8: // global
           if (R1 & 7 == 1) goto c5bk; else goto u5bY;
       c5bk: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       u5bY: // global
           Sp = Sp + 16;
           call _c5bO() args: 0, res: 0, upd: 0;
     }
 },
 _c5bn() //  [R1]
         { info_tbl: [(c5bn,
                       label: block_c5bn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5bn: // global
           if (R1 & 7 == 2) goto c5bz; else goto u5bZ;
       c5bz: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       u5bZ: // global
           Sp = Sp + 16;
           call _c5bK() args: 0, res: 0, upd: 0;
     }
 },
 _c5bC() //  [R1]
         { info_tbl: [(c5bC,
                       label: block_c5bC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5bC: // global
           _c5bT::P64 = R1 & 7;
           if (_c5bT::P64 < 3) goto u5bX; else goto c5bS;
       u5bX: // global
           if (_c5bT::P64 < 2) goto u5c1; else goto u5c0;
       u5c1: // global
           Sp = Sp + 8;
           call _c5bK() args: 0, res: 0, upd: 0;
       u5c0: // global
           Sp = Sp + 8;
           call _c5bO() args: 0, res: 0, upd: 0;
       c5bS: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5bK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5bK: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5bO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5bO: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.374859625 UTC

[section ""data" . GHC.Integer.Type.eqInteger#_closure" {
     GHC.Integer.Type.eqInteger#_closure:
         const GHC.Integer.Type.eqInteger#_info;
 },
 GHC.Integer.Type.eqInteger#_entry() //  [R2, R3]
         { info_tbl: [(c5ck,
                       label: GHC.Integer.Type.eqInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ck: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5cl; else goto c5cm;
       c5cl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.eqInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5cm: // global
           I64[Sp - 8] = block_c5ce_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5ce() //  [R1]
         { info_tbl: [(c5ce,
                       label: block_c5ce_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ce: // global
           if (R1 & 7 == 2) goto c5ci; else goto c5ch;
       c5ci: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5ch: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.376122457 UTC

[section ""data" . GHC.Integer.Type.eqInteger_closure" {
     GHC.Integer.Type.eqInteger_closure:
         const GHC.Integer.Type.eqInteger_info;
 },
 GHC.Integer.Type.eqInteger_entry() //  [R2, R3]
         { info_tbl: [(c5cz,
                       label: GHC.Integer.Type.eqInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5cz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5cA; else goto c5cB;
       c5cA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.eqInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5cB: // global
           I64[Sp - 8] = block_c5cx_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5cx() //  [R1]
         { info_tbl: [(c5cx,
                       label: block_c5cx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5cx: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.377852498 UTC

[section ""data" . GHC.Integer.Type.neqInteger#_closure" {
     GHC.Integer.Type.neqInteger#_closure:
         const GHC.Integer.Type.neqInteger#_info;
 },
 GHC.Integer.Type.neqInteger#_entry() //  [R2, R3]
         { info_tbl: [(c5cP,
                       label: GHC.Integer.Type.neqInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5cP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5cQ; else goto c5cR;
       c5cQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.neqInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5cR: // global
           I64[Sp - 8] = block_c5cJ_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5cJ() //  [R1]
         { info_tbl: [(c5cJ,
                       label: block_c5cJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5cJ: // global
           if (R1 & 7 == 2) goto c5cN; else goto c5cM;
       c5cN: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5cM: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.379112365 UTC

[section ""data" . GHC.Integer.Type.neqInteger_closure" {
     GHC.Integer.Type.neqInteger_closure:
         const GHC.Integer.Type.neqInteger_info;
 },
 GHC.Integer.Type.neqInteger_entry() //  [R2, R3]
         { info_tbl: [(c5d4,
                       label: GHC.Integer.Type.neqInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5d4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5d5; else goto c5d6;
       c5d5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.neqInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5d6: // global
           I64[Sp - 8] = block_c5d2_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5d2() //  [R1]
         { info_tbl: [(c5d2,
                       label: block_c5d2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5d2: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.380456609 UTC

[section ""data" . GHC.Integer.Type.$fEqInteger_closure" {
     GHC.Integer.Type.$fEqInteger_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.38138807 UTC

[section ""data" . GHC.Integer.Type.ltInteger#_closure" {
     GHC.Integer.Type.ltInteger#_closure:
         const GHC.Integer.Type.ltInteger#_info;
 },
 GHC.Integer.Type.ltInteger#_entry() //  [R2, R3]
         { info_tbl: [(c5dk,
                       label: GHC.Integer.Type.ltInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5dk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5dl; else goto c5dm;
       c5dl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.ltInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5dm: // global
           I64[Sp - 8] = block_c5de_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5de() //  [R1]
         { info_tbl: [(c5de,
                       label: block_c5de_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5de: // global
           if (R1 & 7 == 1) goto c5di; else goto c5dh;
       c5di: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5dh: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.382614221 UTC

[section ""data" . GHC.Integer.Type.ltInteger_closure" {
     GHC.Integer.Type.ltInteger_closure:
         const GHC.Integer.Type.ltInteger_info;
 },
 GHC.Integer.Type.ltInteger_entry() //  [R2, R3]
         { info_tbl: [(c5dz,
                       label: GHC.Integer.Type.ltInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5dz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5dA; else goto c5dB;
       c5dA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.ltInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5dB: // global
           I64[Sp - 8] = block_c5dx_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5dx() //  [R1]
         { info_tbl: [(c5dx,
                       label: block_c5dx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5dx: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.38410442 UTC

[section ""data" . GHC.Integer.Type.gtInteger#_closure" {
     GHC.Integer.Type.gtInteger#_closure:
         const GHC.Integer.Type.gtInteger#_info;
 },
 GHC.Integer.Type.gtInteger#_entry() //  [R2, R3]
         { info_tbl: [(c5dP,
                       label: GHC.Integer.Type.gtInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5dP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5dQ; else goto c5dR;
       c5dQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.gtInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5dR: // global
           I64[Sp - 8] = block_c5dJ_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5dJ() //  [R1]
         { info_tbl: [(c5dJ,
                       label: block_c5dJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5dJ: // global
           if (R1 & 7 == 3) goto c5dN; else goto c5dM;
       c5dN: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5dM: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.385341248 UTC

[section ""data" . GHC.Integer.Type.gtInteger_closure" {
     GHC.Integer.Type.gtInteger_closure:
         const GHC.Integer.Type.gtInteger_info;
 },
 GHC.Integer.Type.gtInteger_entry() //  [R2, R3]
         { info_tbl: [(c5e4,
                       label: GHC.Integer.Type.gtInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5e4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5e5; else goto c5e6;
       c5e5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.gtInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5e6: // global
           I64[Sp - 8] = block_c5e2_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5e2() //  [R1]
         { info_tbl: [(c5e2,
                       label: block_c5e2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5e2: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.386728305 UTC

[section ""data" . GHC.Integer.Type.leInteger#_closure" {
     GHC.Integer.Type.leInteger#_closure:
         const GHC.Integer.Type.leInteger#_info;
 },
 GHC.Integer.Type.leInteger#_entry() //  [R2, R3]
         { info_tbl: [(c5ek,
                       label: GHC.Integer.Type.leInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ek: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5el; else goto c5em;
       c5el: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.leInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5em: // global
           I64[Sp - 8] = block_c5ee_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5ee() //  [R1]
         { info_tbl: [(c5ee,
                       label: block_c5ee_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ee: // global
           if (R1 & 7 == 3) goto c5ei; else goto c5eh;
       c5ei: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5eh: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.387949843 UTC

[section ""data" . GHC.Integer.Type.leInteger_closure" {
     GHC.Integer.Type.leInteger_closure:
         const GHC.Integer.Type.leInteger_info;
 },
 GHC.Integer.Type.leInteger_entry() //  [R2, R3]
         { info_tbl: [(c5ez,
                       label: GHC.Integer.Type.leInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ez: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5eA; else goto c5eB;
       c5eA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.leInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5eB: // global
           I64[Sp - 8] = block_c5ex_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5ex() //  [R1]
         { info_tbl: [(c5ex,
                       label: block_c5ex_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ex: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.389421107 UTC

[section ""data" . GHC.Integer.Type.geInteger#_closure" {
     GHC.Integer.Type.geInteger#_closure:
         const GHC.Integer.Type.geInteger#_info;
 },
 GHC.Integer.Type.geInteger#_entry() //  [R2, R3]
         { info_tbl: [(c5eP,
                       label: GHC.Integer.Type.geInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5eP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5eQ; else goto c5eR;
       c5eQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.geInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5eR: // global
           I64[Sp - 8] = block_c5eJ_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5eJ() //  [R1]
         { info_tbl: [(c5eJ,
                       label: block_c5eJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5eJ: // global
           if (R1 & 7 == 1) goto c5eN; else goto c5eM;
       c5eN: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5eM: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.390655132 UTC

[section ""data" . GHC.Integer.Type.geInteger_closure" {
     GHC.Integer.Type.geInteger_closure:
         const GHC.Integer.Type.geInteger_info;
 },
 GHC.Integer.Type.geInteger_entry() //  [R2, R3]
         { info_tbl: [(c5f4,
                       label: GHC.Integer.Type.geInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5f4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5f5; else goto c5f6;
       c5f5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.geInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5f6: // global
           I64[Sp - 8] = block_c5f2_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5f2() //  [R1]
         { info_tbl: [(c5f2,
                       label: block_c5f2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5f2: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.392160425 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_$cmax_closure" {
     GHC.Integer.Type.$fOrdInteger_$cmax_closure:
         const GHC.Integer.Type.$fOrdInteger_$cmax_info;
 },
 GHC.Integer.Type.$fOrdInteger_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c5fj,
                       label: GHC.Integer.Type.$fOrdInteger_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5fj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5fk; else goto c5fl;
       c5fk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$fOrdInteger_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5fl: // global
           I64[Sp - 24] = block_c5fe_info;
           _s3H2::P64 = R3;
           R3 = R3;
           _s3H1::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s3H1::P64;
           P64[Sp - 8] = _s3H2::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5fe() //  [R1]
         { info_tbl: [(c5fe,
                       label: block_c5fe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5fe: // global
           if (R1 == 1) goto c5fi; else goto c5fh;
       c5fi: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c5fh: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.393675969 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_$cmin_closure" {
     GHC.Integer.Type.$fOrdInteger_$cmin_closure:
         const GHC.Integer.Type.$fOrdInteger_$cmin_info;
 },
 GHC.Integer.Type.$fOrdInteger_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c5fB,
                       label: GHC.Integer.Type.$fOrdInteger_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5fB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5fC; else goto c5fD;
       c5fC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$fOrdInteger_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5fD: // global
           I64[Sp - 24] = block_c5fw_info;
           _s3H5::P64 = R3;
           R3 = R3;
           _s3H4::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s3H4::P64;
           P64[Sp - 8] = _s3H5::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5fw() //  [R1]
         { info_tbl: [(c5fw,
                       label: block_c5fw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5fw: // global
           if (R1 == 1) goto c5fA; else goto c5fz;
       c5fA: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c5fz: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.395147374 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_closure" {
     GHC.Integer.Type.$fOrdInteger_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Integer.Type.$fEqInteger_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.397578175 UTC

[section ""data" . GHC.Integer.Type.plusInteger_closure" {
     GHC.Integer.Type.plusInteger_closure:
         const GHC.Integer.Type.plusInteger_info;
         const 0;
 },
 GHC.Integer.Type.plusInteger_entry() //  [R2, R3]
         { info_tbl: [(c5fW,
                       label: GHC.Integer.Type.plusInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5fW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5fX; else goto u5hw;
       c5fX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.plusInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u5hw: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c5fL() args: 0, res: 0, upd: 0;
     }
 },
 _c5fL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5fL: // global
           _s3H7::P64 = P64[Sp];
           I64[Sp] = block_c5fO_info;
           R1 = _s3H7::P64;
           if (R1 & 7 != 0) goto u5hA; else goto c5fP;
       u5hA: // global
           call _c5fO(R1) args: 0, res: 0, upd: 0;
       c5fP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5fO() //  [R1]
         { info_tbl: [(c5fO,
                       label: block_c5fO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5fO: // global
           _s3H8::P64 = P64[Sp + 8];
           _c5fV::P64 = R1 & 7;
           if (_c5fV::P64 < 3) goto u5hs; else goto c5fU;
       u5hs: // global
           if (_c5fV::P64 < 2) goto c5fS; else goto c5fT;
       c5fS: // global
           I64[Sp - 8] = block_c5g1_info;
           _s3H9::P64 = R1;
           _s3Ha::P64 = P64[R1 + 7];
           R1 = _s3H8::P64;
           P64[Sp] = _s3Ha::P64;
           P64[Sp + 8] = _s3H9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5hB; else goto c5g3;
       u5hB: // global
           call _c5g1(R1) args: 0, res: 0, upd: 0;
       c5g3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5fT: // global
           I64[Sp - 8] = block_c5gX_info;
           _s3H9::P64 = R1;
           _s3Hi::P64 = P64[R1 + 6];
           R1 = _s3H8::P64;
           P64[Sp] = _s3Hi::P64;
           P64[Sp + 8] = _s3H9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5hC; else goto c5gZ;
       u5hC: // global
           call _c5gX(R1) args: 0, res: 0, upd: 0;
       c5gZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5fU: // global
           R1 = _s3H8::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5g1() //  [R1]
         { info_tbl: [(c5g1,
                       label: block_c5g1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5g1: // global
           _c5hq::P64 = R1 & 7;
           if (_c5hq::P64 < 3) goto u5ht; else goto u5hx;
       u5ht: // global
           _s3Ha::P64 = P64[Sp + 8];
           if (_c5hq::P64 < 2) goto c5ge; else goto c5gm;
       c5ge: // global
           I64[Sp + 16] = block_c5g7_info;
           R4 = P64[R1 + 7];
           R3 = _s3Ha::P64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c5gm: // global
           I64[Sp] = block_c5gk_info;
           _s3He::P64 = P64[R1 + 6];
           R3 = _s3He::P64;
           R2 = _s3Ha::P64;
           P64[Sp + 16] = _s3He::P64;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u5hx: // global
           Sp = Sp + 16;
           call _c5hl() args: 0, res: 0, upd: 0;
     }
 },
 _c5g7() //  [R1]
         { info_tbl: [(c5g7,
                       label: block_c5g7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5g7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5gh; else goto c5gg;
       c5gh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5gg: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5gk() //  [R1]
         { info_tbl: [(c5gk,
                       label: block_c5gk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5gk: // global
           _s3Ha::P64 = P64[Sp + 8];
           _s3He::P64 = P64[Sp + 16];
           _c5hr::P64 = R1 & 7;
           if (_c5hr::P64 < 3) goto u5hu; else goto c5gN;
       u5hu: // global
           if (_c5hr::P64 < 2) goto c5gx; else goto c5gE;
       c5gx: // global
           I64[Sp + 16] = block_c5gq_info;
           R3 = _s3Ha::P64;
           R2 = _s3He::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c5gE: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5gN: // global
           I64[Sp + 16] = block_c5gH_info;
           R3 = _s3He::P64;
           R2 = _s3Ha::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5gq() //  [R1]
         { info_tbl: [(c5gq,
                       label: block_c5gq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5gq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5gA; else goto c5gz;
       c5gA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5gz: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5gH() //  [R1]
         { info_tbl: [(c5gH,
                       label: block_c5gH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5gH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5gQ; else goto c5gP;
       c5gQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5gP: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5gX() //  [R1]
         { info_tbl: [(c5gX,
                       label: block_c5gX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5gX: // global
           _c5hp::P64 = R1 & 7;
           if (_c5hp::P64 < 3) goto u5hv; else goto u5hy;
       u5hv: // global
           if (_c5hp::P64 < 2) goto c5h5; else goto c5he;
       c5h5: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c5fL() args: 0, res: 0, upd: 0;
       c5he: // global
           I64[Sp + 16] = block_c5h8_info;
           R4 = P64[R1 + 6];
           R3 = P64[Sp + 8];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       u5hy: // global
           Sp = Sp + 16;
           call _c5hl() args: 0, res: 0, upd: 0;
     }
 },
 _c5h8() //  [R1]
         { info_tbl: [(c5h8,
                       label: block_c5h8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5h8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5hh; else goto c5hg;
       c5hh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5hg: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5hl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5hl: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.401221627 UTC

[section ""data" . GHC.Integer.Type.minusInteger_closure" {
     GHC.Integer.Type.minusInteger_closure:
         const GHC.Integer.Type.minusInteger_info;
         const 0;
 },
 GHC.Integer.Type.minusInteger_entry() //  [R2, R3]
         { info_tbl: [(c5hN,
                       label: GHC.Integer.Type.minusInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5hN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5hO; else goto c5hP;
       c5hO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.minusInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5hP: // global
           I64[Sp - 16] = block_c5hL_info;
           _s3Hn::P64 = R2;
           R2 = R3;
           P64[Sp - 8] = _s3Hn::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5hL() //  [R1]
         { info_tbl: [(c5hL,
                       label: block_c5hL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5hL: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.402643432 UTC

[section ""data" . GHC.Integer.Type.complementInteger_closure" {
     GHC.Integer.Type.complementInteger_closure:
         const GHC.Integer.Type.complementInteger_info;
         const 0;
 },
 GHC.Integer.Type.complementInteger_entry() //  [R2]
         { info_tbl: [(c5hX,
                       label: GHC.Integer.Type.complementInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5hX: // global
           R3 = R2;
           R2 = GHC.Integer.Type.negativeOneInteger_closure+2;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.404088124 UTC

[section ""data" . GHC.Integer.Type.decodeDoubleInteger_closure" {
     GHC.Integer.Type.decodeDoubleInteger_closure:
         const GHC.Integer.Type.decodeDoubleInteger_info;
         const 0;
 },
 sat_s3HC_entry() //  [R1]
         { info_tbl: [(c5ie,
                       label: sat_s3HC_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ie: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c5iu; else goto c5iv;
       c5iu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5iv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c5ic_info;
           R2 = I64[R1 + 32];
           I64[Sp - 32] = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c5ic() //  [R1]
         { info_tbl: [(c5ic,
                       label: block_c5ic_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ic: // global
           I64[Sp] = block_c5ih_info;
           R2 = I64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c5ih() //  [R1]
         { info_tbl: [(c5ih,
                       label: block_c5ih_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ih: // global
           I64[Sp] = block_c5il_info;
           R3 = GHC.Integer.Type.twoToTheThirtytwoInteger_closure+1;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _c5il() //  [R1]
         { info_tbl: [(c5il,
                       label: block_c5il_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5il: // global
           I64[Sp] = block_c5ip_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c5ip() //  [R1]
         { info_tbl: [(c5ip,
                       label: block_c5ip_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ip: // global
           _s3Ht::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c5it_info;
           R2 = _s3Ht::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c5it() //  [R1]
         { info_tbl: [(c5it,
                       label: block_c5it_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5it: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.decodeDoubleInteger_entry() //  [D1]
         { info_tbl: [(c5iE,
                       label: GHC.Integer.Type.decodeDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 7} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5iE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c5iF; else goto c5iG;
       c5iF: // global
           D1 = D1;
           R1 = GHC.Integer.Type.decodeDoubleInteger_closure;
           call (stg_gc_fun)(D1, R1) args: 8, res: 0, upd: 8;
       c5iG: // global
           I64[Sp - 8] = block_c5i4_info;
           D1 = D1;
           Sp = Sp - 8;
           call stg_decodeDouble_2Int#(D1) args: 8, res: 8, upd: 8;
     }
 },
 _c5i4() //  [R1, R2, R3, R4]
         { info_tbl: [(c5i4,
                       label: block_c5i4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5i4: // global
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           I64[Sp] = R1;
           Sp = Sp - 32;
           call _c5i5() args: 0, res: 0, upd: 0;
     }
 },
 _c5i5() //  []
         { info_tbl: [(c5i5,
                       label: block_c5i5_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5i5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c5iJ; else goto c5iI;
       c5iJ: // global
           HpAlloc = 40;
           I64[Sp] = block_c5i5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5iI: // global
           I64[Hp - 32] = sat_s3HC_info;
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = I64[Sp + 24];
           R1 = Hp - 32;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.407542183 UTC

[section ""data" . GHC.Integer.Type.smallShiftLPositive_closure" {
     GHC.Integer.Type.smallShiftLPositive_closure:
         const GHC.Integer.Type.smallShiftLPositive_info;
 },
 f2_s3HH_entry() //  [R1, R2, R3]
         { info_tbl: [(c5j7,
                       label: f2_s3HH_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5j7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c5j8; else goto c5j9;
       c5j8: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5j9: // global
           I64[Sp - 40] = block_c5j0_info;
           _s3HH::P64 = R1;
           _s3HF::I64 = I64[R1 + 6];
           _s3HG::I64 = I64[R1 + 14];
           R1 = R3;
           I64[Sp - 32] = _s3HF::I64;
           I64[Sp - 24] = _s3HG::I64;
           P64[Sp - 16] = _s3HH::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u5jF; else goto c5j1;
       u5jF: // global
           call _c5j0(R1) args: 0, res: 0, upd: 0;
       c5j1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5j0() //  [R1]
         { info_tbl: [(c5j0,
                       label: block_c5j0_info
                       rep:StackRep [True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5j0: // global
           if (R1 & 7 == 1) goto c5j4; else goto c5j5;
       c5j4: // global
           I64[Sp] = block_c5jf_info;
           R3 = P64[R1 + 7];
           _s3HL::I64 = I64[R1 + 15];
           R2 = _s3HL::I64 >> I64[Sp + 16];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s3HL::I64;
           call f2_s3HH_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
       c5j5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5jy; else goto c5jx;
       c5jy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5jx: // global
           _s3HR::I64 = I64[Sp + 32];
           if (_s3HR::I64 != 0) goto c5jD; else goto c5jE;
       c5jD: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s3HR::I64;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5jE: // global
           Hp = Hp - 24;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5jf() //  [R1]
         { info_tbl: [(c5jf,
                       label: block_c5jf_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5jf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5jt; else goto c5js;
       c5jt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5js: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = (I64[Sp + 24] << I64[Sp + 8]) | I64[Sp + 32];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Integer.Type.smallShiftLPositive_entry() //  [R2, R3]
         { info_tbl: [(c5jJ,
                       label: GHC.Integer.Type.smallShiftLPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5jJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5jN; else goto c5jM;
       c5jN: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.smallShiftLPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5jM: // global
           if (R3 == 0) goto c5jI; else goto c5jH;
       c5jI: // global
           Hp = Hp - 24;
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c5jH: // global
           I64[Hp - 16] = f2_s3HH_info;
           I64[Hp - 8] = R3;
           I64[Hp] = 64 - R3;
           R3 = R2;
           R2 = 0;
           R1 = Hp - 14;
           call f2_s3HH_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.412909989 UTC

[section ""data" . GHC.Integer.Type.smallShiftRPositive_closure" {
     GHC.Integer.Type.smallShiftRPositive_closure:
         const GHC.Integer.Type.smallShiftRPositive_info;
 },
 GHC.Integer.Type.smallShiftRPositive_entry() //  [R2, R3]
         { info_tbl: [(c5jV,
                       label: GHC.Integer.Type.smallShiftRPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5jV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5jW; else goto c5jX;
       c5jW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.smallShiftRPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5jX: // global
           I64[Sp - 16] = block_c5jS_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5kH; else goto c5jT;
       u5kH: // global
           call _c5jS(R1) args: 0, res: 0, upd: 0;
       c5jT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5jS() //  [R1]
         { info_tbl: [(c5jS,
                       label: block_c5jS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5jS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5k2; else goto c5k1;
       c5k2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5k1: // global
           _s3HV::I64 = I64[Sp + 8];
           if (_s3HV::I64 == 0) goto c5kC; else goto c5ka;
       c5kC: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5ka: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_c5k8_info;
           R3 = 64 - _s3HV::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5k8() //  [R1]
         { info_tbl: [(c5k8,
                       label: block_c5k8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5k8: // global
           if (R1 & 7 == 1) goto c5kh; else goto u5kF;
       c5kh: // global
           I64[Sp] = block_c5ke_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u5kI; else goto c5ki;
       u5kI: // global
           call _c5ke(R1) args: 0, res: 0, upd: 0;
       c5ki: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u5kF: // global
           Sp = Sp + 8;
           call _c5kz() args: 0, res: 0, upd: 0;
     }
 },
 _c5ke() //  [R1]
         { info_tbl: [(c5ke,
                       label: block_c5ke_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ke: // global
           if (R1 & 7 == 1) goto c5ko; else goto u5kG;
       c5ko: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5kr; else goto c5kq;
       c5kr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5kq: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u5kG: // global
           Sp = Sp + 8;
           call _c5kz() args: 0, res: 0, upd: 0;
     }
 },
 _c5kz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5kz: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.417187939 UTC

[section ""data" . GHC.Integer.Type.shiftRPositive_closure" {
     GHC.Integer.Type.shiftRPositive_closure:
         const GHC.Integer.Type.shiftRPositive_info;
 },
 GHC.Integer.Type.shiftRPositive_entry() //  [R2, R3]
         { info_tbl: [(c5kW,
                       label: GHC.Integer.Type.shiftRPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5kW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5kX; else goto u5ld;
       c5kX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftRPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u5ld: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c5kM() args: 0, res: 0, upd: 0;
     }
 },
 _c5kM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5kM: // global
           _s3I3::P64 = P64[Sp];
           I64[Sp] = block_c5kP_info;
           R1 = _s3I3::P64;
           if (R1 & 7 != 0) goto u5lf; else goto c5kQ;
       u5lf: // global
           call _c5kP(R1) args: 0, res: 0, upd: 0;
       c5kQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5kP() //  [R1]
         { info_tbl: [(c5kP,
                       label: block_c5kP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5kP: // global
           if (R1 & 7 == 1) goto c5kT; else goto c5kU;
       c5kT: // global
           _s3I4::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s3I4::I64, 64)) goto c5l5; else goto c5l6;
       c5l5: // global
           R3 = _s3I4::I64;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallShiftRPositive_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       c5l6: // global
           P64[Sp] = P64[R1 + 7];
           I64[Sp + 8] = _s3I4::I64 - 64;
           call _c5kM() args: 0, res: 0, upd: 0;
       c5kU: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.421470086 UTC

[section ""data" . GHC.Integer.Type.shiftRInteger_closure" {
     GHC.Integer.Type.shiftRInteger_closure:
         const GHC.Integer.Type.shiftRInteger_info;
         const 0;
 },
 GHC.Integer.Type.shiftRInteger_entry() //  [R2, R3]
         { info_tbl: [(c5lu,
                       label: GHC.Integer.Type.shiftRInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5lu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5lv; else goto c5lw;
       c5lv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftRInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5lw: // global
           I64[Sp - 16] = block_c5lm_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5lR; else goto c5ln;
       u5lR: // global
           call _c5lm(R1) args: 0, res: 0, upd: 0;
       c5ln: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5lm() //  [R1]
         { info_tbl: [(c5lm,
                       label: block_c5lm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5lm: // global
           _c5lt::P64 = R1 & 7;
           if (_c5lt::P64 < 3) goto u5lQ; else goto c5ls;
       u5lQ: // global
           if (_c5lt::P64 < 2) goto c5lq; else goto c5lr;
       c5lq: // global
           R3 = I64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRPositive_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
       c5lr: // global
           I64[Sp] = block_c5lC_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
       c5ls: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5lC() //  [R1]
         { info_tbl: [(c5lC,
                       label: block_c5lC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5lC: // global
           _s3Ib::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c5lG_info;
           R3 = _s3Ib::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5lG() //  [R1]
         { info_tbl: [(c5lG,
                       label: block_c5lG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5lG: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.425635866 UTC

[section ""data" . GHC.Integer.Type.shiftLPositive_closure" {
     GHC.Integer.Type.shiftLPositive_closure:
         const GHC.Integer.Type.shiftLPositive_info;
 },
 GHC.Integer.Type.shiftLPositive_entry() //  [R2, R3]
         { info_tbl: [(c5mc,
                       label: GHC.Integer.Type.shiftLPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5mc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5md; else goto u5mi;
       c5md: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftLPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u5mi: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c5lT() args: 0, res: 0, upd: 0;
     }
 },
 _c5lT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5lT: // global
           _s3Ih::P64 = P64[Sp];
           _s3Ii::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s3Ii::I64, 64)) goto c5ma; else goto c5mb;
       c5ma: // global
           R3 = _s3Ii::I64;
           R2 = _s3Ih::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       c5mb: // global
           I64[Sp] = block_c5m0_info;
           R1 = _s3Ih::P64;
           if (R1 & 7 != 0) goto u5mk; else goto c5m1;
       u5mk: // global
           call _c5m0(R1) args: 0, res: 0, upd: 0;
       c5m1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5m0() //  [R1]
         { info_tbl: [(c5m0,
                       label: block_c5m0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5m0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5mh; else goto c5mg;
       c5mh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5mg: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           P64[Sp] = Hp - 15;
           I64[Sp + 8] = I64[Sp + 8] - 64;
           call _c5lT() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.429919904 UTC

[section ""data" . GHC.Integer.Type.shiftLInteger_closure" {
     GHC.Integer.Type.shiftLInteger_closure:
         const GHC.Integer.Type.shiftLInteger_info;
 },
 GHC.Integer.Type.shiftLInteger_entry() //  [R2, R3]
         { info_tbl: [(c5mz,
                       label: GHC.Integer.Type.shiftLInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5mz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5mA; else goto c5mB;
       c5mA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftLInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5mB: // global
           I64[Sp - 16] = block_c5mr_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5n2; else goto c5ms;
       u5n2: // global
           call _c5mr(R1) args: 0, res: 0, upd: 0;
       c5ms: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5mr() //  [R1]
         { info_tbl: [(c5mr,
                       label: block_c5mr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5mr: // global
           _c5my::P64 = R1 & 7;
           if (_c5my::P64 < 3) goto u5n1; else goto c5mx;
       u5n1: // global
           _s3Io::I64 = I64[Sp + 8];
           if (_c5my::P64 < 2) goto c5mv; else goto c5mw;
       c5mv: // global
           I64[Sp + 8] = block_c5mE_info;
           R3 = _s3Io::I64;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLPositive_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
       c5mw: // global
           I64[Sp + 8] = block_c5mP_info;
           R3 = _s3Io::I64;
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLPositive_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
       c5mx: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5mE() //  [R1]
         { info_tbl: [(c5mE,
                       label: block_c5mE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5mE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5mM; else goto c5mL;
       c5mM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5mL: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5mP() //  [R1]
         { info_tbl: [(c5mP,
                       label: block_c5mP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5mP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5mX; else goto c5mW;
       c5mX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5mW: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.434218778 UTC

[section ""data" . GHC.Integer.Type.some_closure" {
     GHC.Integer.Type.some_closure:
         const GHC.Integer.Type.some_info;
 },
 GHC.Integer.Type.some_entry() //  [R2, R3]
         { info_tbl: [(c5ne,
                       label: GHC.Integer.Type.some_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ne: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5nf; else goto c5ng;
       c5nf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.some_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5ng: // global
           I64[Sp - 16] = block_c5n7_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5ny; else goto c5n8;
       u5ny: // global
           call _c5n7(R1) args: 0, res: 0, upd: 0;
       c5n8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5n7() //  [R1]
         { info_tbl: [(c5n7,
                       label: block_c5n7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5n7: // global
           _s3Iu::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c5nb; else goto c5nc;
       c5nb: // global
           Hp = Hp + 24;
           _s3Iw::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c5nr; else goto c5nl;
       c5nl: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = _s3Iw::P64;
           I64[Hp] = _s3Iu::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5nc: // global
           Hp = Hp + 24;
           _s3Iw::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c5nr; else goto c5nq;
       c5nr: // global
           HpAlloc = 24;
           R1 = _s3Iw::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5nq: // global
           if (_s3Iu::I64 == 0) goto c5nx; else goto c5nw;
       c5nx: // global
           Hp = Hp - 24;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5nw: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s3Iu::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.438735916 UTC

[section ""data" . GHC.Integer.Type.quotRemPositive_g_closure" {
     GHC.Integer.Type.quotRemPositive_g_closure:
         const GHC.Integer.Type.quotRemPositive_g_info;
 },
 GHC.Integer.Type.quotRemPositive_g_entry() //  [R2, R3, R4]
         { info_tbl: [(c5nK,
                       label: GHC.Integer.Type.quotRemPositive_g_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5nK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c5nL; else goto u5ol;
       c5nL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemPositive_g_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u5ol: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c5nA() args: 0, res: 0, upd: 0;
     }
 },
 _c5nA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5nA: // global
           I64[Sp - 8] = block_c5nD_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5oo; else goto c5nE;
       u5oo: // global
           call _c5nD(R1) args: 0, res: 0, upd: 0;
       c5nE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5nD() //  [R1]
         { info_tbl: [(c5nD,
                       label: block_c5nD_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5nD: // global
           _s3IC::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c5nH; else goto c5nI;
       c5nH: // global
           I64[Sp] = block_c5nP_info;
           R1 = _s3IC::P64;
           if (R1 & 7 != 0) goto u5op; else goto c5nR;
       u5op: // global
           call _c5nP(R1) args: 0, res: 0, upd: 0;
       c5nR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5nI: // global
           I64[Sp - 8] = block_c5nY_info;
           _s3IF::P64 = P64[R1 + 6];
           R3 = _s3IF::P64;
           R2 = _s3IC::P64;
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 16] = _s3IF::P64;
           Sp = Sp - 8;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5nP() //  [R1]
         { info_tbl: [(c5nP,
                       label: block_c5nP_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5nP: // global
           R2 = R1;
           R1 = I64[Sp + 8];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5nY() //  [R1]
         { info_tbl: [(c5nY,
                       label: block_c5nY_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5nY: // global
           _s3IC::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c5oe; else goto c5o6;
       c5oe: // global
           I64[Sp + 16] = I64[Sp + 16] << 1;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _s3IC::P64;
           Sp = Sp + 16;
           call _c5nA() args: 0, res: 0, upd: 0;
       c5o6: // global
           I64[Sp] = block_c5o3_info;
           R3 = P64[Sp + 24];
           R2 = _s3IC::P64;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5o3() //  [R1]
         { info_tbl: [(c5o3,
                       label: block_c5o3_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5o3: // global
           I64[Sp + 16] = (I64[Sp + 16] << 1) + 1;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call _c5nA() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.448404784 UTC

[section ""data" . GHC.Integer.Type.quotRemPositive_closure" {
     GHC.Integer.Type.quotRemPositive_closure:
         const GHC.Integer.Type.quotRemPositive_info;
 },
 sat_s3IW_entry() //  [R1]
         { info_tbl: [(c5oU,
                       label: sat_s3IW_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5oU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5oV; else goto c5oW;
       c5oV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5oW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call mkSubtractors_s3IR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3IU_entry() //  [R1]
         { info_tbl: [(c5p1,
                       label: sat_s3IU_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5p1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5p2; else goto c5p3;
       c5p2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5p3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 mkSubtractors_s3IR_entry() //  [R1, R2]
         { info_tbl: [(c5p7,
                       label: mkSubtractors_s3IR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5p7: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c5pb; else goto c5pa;
       c5pb: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5pa: // global
           if (R2 == 0) goto c5p6; else goto c5p5;
       c5p6: // global
           _s3IQ::P64 = P64[R1 + 15];
           Hp = Hp - 88;
           R1 = _s3IQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5p5: // global
           _s3IO::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s3IW_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s3IU_info;
           P64[Hp - 32] = _s3IO::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 subtractors_s3IP_entry() //  [R1]
         { info_tbl: [(c5pd,
                       label: subtractors_s3IP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5pd: // global
           _s3IP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c5pe; else goto c5pf;
       c5pf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c5ph; else goto c5pg;
       c5ph: // global
           HpAlloc = 48;
           goto c5pe;
       c5pe: // global
           R1 = _s3IP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5pg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s3IP::P64;
           _s3IO::P64 = P64[_s3IP::P64 + 16];
           I64[Hp - 40] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 32] = _s3IO::P64;
           P64[Hp - 24] = GHC.Integer.Type.Nil_closure+1;
           I64[Hp - 16] = mkSubtractors_s3IR_info;
           P64[Hp - 8] = _s3IO::P64;
           P64[Hp] = Hp - 38;
           R2 = 63;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call mkSubtractors_s3IR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3Jc_entry() //  [R1]
         { info_tbl: [(c5pI,
                       label: sat_s3Jc_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5pI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5pJ; else goto c5pK;
       c5pJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5pK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3Ji_entry() //  [R1]
         { info_tbl: [(c5pY,
                       label: sat_s3Ji_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5pY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5pZ; else goto c5q0;
       c5pZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5q0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3Jm_entry() //  [R1]
         { info_tbl: [(c5qa,
                       label: sat_s3Jm_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5qa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5qb; else goto c5qc;
       c5qb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5qc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 f2_s3IX_entry() //  [R1, R2]
         { info_tbl: [(c5qh,
                       label: f2_s3IX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5qh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c5qi; else goto c5qj;
       c5qi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5qj: // global
           I64[Sp - 24] = block_c5pn_info;
           _s3IX::P64 = R1;
           _s3IP::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s3IP::P64;
           P64[Sp - 8] = _s3IX::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u5qS; else goto c5po;
       u5qS: // global
           call _c5pn(R1) args: 0, res: 0, upd: 0;
       c5po: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5pn() //  [R1]
         { info_tbl: [(c5pn,
                       label: block_c5pn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5pn: // global
           if (R1 & 7 == 1) goto c5qe; else goto c5qf;
       c5qe: // global
           I64[Sp] = block_c5ps_info;
           R2 = P64[R1 + 7];
           _s3J0::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s3J0::I64;
           call f2_s3IX_entry(R2, R1) args: 8, res: 8, upd: 8;
       c5qf: // global
           R2 = GHC.Integer.Type.None_closure+2;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5ps() //  [R1, R2]
         { info_tbl: [(c5ps,
                       label: block_c5ps_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ps: // global
           I64[Sp - 8] = block_c5pu_info;
           _s3J3::P64 = R1;
           R1 = R2;
           P64[Sp] = _s3J3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5qO; else goto c5pv;
       u5qO: // global
           call _c5pu(R1) args: 0, res: 0, upd: 0;
       c5pv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5pu() //  [R1]
         { info_tbl: [(c5pu,
                       label: block_c5pu_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5pu: // global
           _s3IP::P64 = P64[Sp + 16];
           _s3J0::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c5qn; else goto c5qu;
       c5qn: // global
           Hp = Hp + 24;
           _s3J5::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c5qx; else goto c5qp;
       c5qp: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = _s3J5::P64;
           I64[Hp] = _s3J0::I64;
           I64[Sp] = block_c5pA_info;
           R4 = Hp - 15;
           R3 = _s3IP::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
       c5qu: // global
           Hp = Hp + 24;
           _s3J5::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c5qx; else goto c5qw;
       c5qx: // global
           HpAlloc = 24;
           R1 = _s3J5::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5qw: // global
           if (_s3J0::I64 == 0) goto c5qD; else goto c5qz;
       c5qD: // global
           Hp = Hp - 24;
           I64[Sp] = block_c5q2_info;
           R4 = GHC.Integer.Type.None_closure+2;
           R3 = _s3IP::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
       c5qz: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s3J0::I64;
           I64[Sp] = block_c5pQ_info;
           R4 = Hp - 15;
           R3 = _s3IP::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5pA() //  [R1, R2]
         { info_tbl: [(c5pA,
                       label: block_c5pA_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5pA: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c5pB() args: 0, res: 0, upd: 0;
     }
 },
 _c5pB() //  []
         { info_tbl: [(c5pB,
                       label: block_c5pB_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5pB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5qt; else goto c5qs;
       c5qt: // global
           HpAlloc = 32;
           I64[Sp] = block_c5pB_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5qs: // global
           I64[Hp - 24] = sat_s3Jc_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5q2() //  [R1, R2]
         { info_tbl: [(c5q2,
                       label: block_c5q2_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5q2: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c5q3() args: 0, res: 0, upd: 0;
     }
 },
 _c5q3() //  []
         { info_tbl: [(c5q3,
                       label: block_c5q3_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5q3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5qG; else goto c5qF;
       c5qG: // global
           HpAlloc = 32;
           I64[Sp] = block_c5q3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5qF: // global
           I64[Hp - 24] = sat_s3Jm_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5pQ() //  [R1, R2]
         { info_tbl: [(c5pQ,
                       label: block_c5pQ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5pQ: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c5pR() args: 0, res: 0, upd: 0;
     }
 },
 _c5pR() //  []
         { info_tbl: [(c5pR,
                       label: block_c5pR_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5pR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5qC; else goto c5qB;
       c5qC: // global
           HpAlloc = 32;
           I64[Sp] = block_c5pR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5qB: // global
           I64[Hp - 24] = sat_s3Ji_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3Jr_entry() //  [R1]
         { info_tbl: [(c5qZ,
                       label: sat_s3Jr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5qZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5r0; else goto c5r1;
       c5r0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5r1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.digitsMaybeZeroToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3Jq_entry() //  [R1]
         { info_tbl: [(c5r6,
                       label: sat_s3Jq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5r6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5r7; else goto c5r8;
       c5r7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5r8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.digitsMaybeZeroToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.quotRemPositive_entry() //  [R2, R3]
         { info_tbl: [(c5r9,
                       label: GHC.Integer.Type.quotRemPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5r9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5ra; else goto c5rb;
       c5ra: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5rb: // global
           I64[Sp - 16] = block_c5ox_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5ri; else goto c5oy;
       u5ri: // global
           call _c5ox(R1) args: 0, res: 0, upd: 0;
       c5oy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ox() //  [R1]
         { info_tbl: [(c5ox,
                       label: block_c5ox_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ox: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c5re; else goto c5rd;
       c5re: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5rd: // global
           I64[Hp - 32] = subtractors_s3IP_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = f2_s3IX_info;
           P64[Hp] = Hp - 32;
           _s3IM::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5qT_info;
           R2 = _s3IM::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call f2_s3IX_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5qT() //  [R1, R2]
         { info_tbl: [(c5qT,
                       label: block_c5qT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5qT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c5rh; else goto c5rg;
       c5rh: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c5rg: // global
           I64[Hp - 40] = sat_s3Jr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s3Jq_info;
           P64[Hp] = R1;
           R2 = Hp - 40;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.468626874 UTC

[section ""data" . GHC.Integer.Type.quotRemInteger_closure" {
     GHC.Integer.Type.quotRemInteger_closure:
         const GHC.Integer.Type.quotRemInteger_info;
 },
 sat_s3JE_entry() //  [R1]
         { info_tbl: [(c5rO,
                       label: sat_s3JE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5rO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5rP; else goto c5rQ;
       c5rP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5rQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3JM_entry() //  [R1]
         { info_tbl: [(c5s4,
                       label: sat_s3JM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5s4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5s5; else goto c5s6;
       c5s5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5s6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3JL_entry() //  [R1]
         { info_tbl: [(c5sb,
                       label: sat_s3JL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5sb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5sc; else goto c5sd;
       c5sc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5sd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3JR_entry() //  [R1]
         { info_tbl: [(c5sm,
                       label: sat_s3JR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5sm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5sn; else goto c5so;
       c5sn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5so: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.quotRemInteger_entry() //  [R2, R3]
         { info_tbl: [(c5st,
                       label: GHC.Integer.Type.quotRemInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5st: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5su; else goto c5sv;
       c5su: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5sv: // global
           I64[Sp - 16] = block_c5rn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5tl; else goto c5ro;
       u5tl: // global
           call _c5rn(R1) args: 0, res: 0, upd: 0;
       c5ro: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5rn() //  [R1]
         { info_tbl: [(c5rn,
                       label: block_c5rn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5rn: // global
           _s3Jt::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c5sr; else goto c5sq;
       c5sr: // global
           I64[Sp + 8] = block_c5t5_info;
           R1 = _s3Jt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5th; else goto c5t7;
       u5th: // global
           call _c5t5() args: 0, res: 0, upd: 0;
       c5t7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5sq: // global
           I64[Sp] = block_c5rs_info;
           _s3Ju::P64 = R1;
           R1 = _s3Jt::P64;
           P64[Sp + 8] = _s3Ju::P64;
           if (R1 & 7 != 0) goto u5tg; else goto c5rt;
       u5tg: // global
           call _c5rs(R1) args: 0, res: 0, upd: 0;
       c5rt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5t5() //  []
         { info_tbl: [(c5t5,
                       label: block_c5t5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5t5: // global
           R2 = GHC.Integer.Type.Naught_closure+3;
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5rs() //  [R1]
         { info_tbl: [(c5rs,
                       label: block_c5rs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5rs: // global
           if (R1 & 7 == 3) goto c5t2; else goto c5sz;
       c5t2: // global
           R2 = GHC.Integer.Type.errorInteger_closure+1;
           R1 = GHC.Integer.Type.errorInteger_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c5sz: // global
           I64[Sp] = block_c5rx_info;
           _s3Jv::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s3Jv::P64;
           if (R1 & 7 != 0) goto u5ti; else goto c5ry;
       u5ti: // global
           call _c5rx(R1) args: 0, res: 0, upd: 0;
       c5ry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5rx() //  [R1]
         { info_tbl: [(c5rx,
                       label: block_c5rx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5rx: // global
           _s3Jv::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c5sC; else goto c5sN;
       c5sC: // global
           I64[Sp] = block_c5rC_info;
           _s3Jx::P64 = P64[R1 + 7];
           R1 = _s3Jv::P64;
           P64[Sp + 8] = _s3Jx::P64;
           if (R1 & 7 != 0) goto u5tj; else goto c5rD;
       u5tj: // global
           call _c5rC(R1) args: 0, res: 0, upd: 0;
       c5rD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5sN: // global
           I64[Sp] = block_c5rT_info;
           _s3JF::P64 = P64[R1 + 6];
           R1 = _s3Jv::P64;
           P64[Sp + 8] = _s3JF::P64;
           if (R1 & 7 != 0) goto u5tk; else goto c5rU;
       u5tk: // global
           call _c5rT(R1) args: 0, res: 0, upd: 0;
       c5rU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5rC() //  [R1]
         { info_tbl: [(c5rC,
                       label: block_c5rC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5rC: // global
           _s3Jx::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c5sG; else goto c5sI;
       c5sG: // global
           R3 = P64[R1 + 7];
           R2 = _s3Jx::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c5sI: // global
           I64[Sp + 8] = block_c5rI_info;
           R3 = P64[R1 + 6];
           R2 = _s3Jx::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5rI() //  [R1, R2]
         { info_tbl: [(c5rI,
                       label: block_c5rI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5rI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5sL; else goto c5sK;
       c5sL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c5sK: // global
           I64[Hp - 16] = sat_s3JE_info;
           P64[Hp] = R1;
           R2 = R2;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5rT() //  [R1]
         { info_tbl: [(c5rT,
                       label: block_c5rT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5rT: // global
           _s3JF::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c5sQ; else goto c5sV;
       c5sQ: // global
           I64[Sp + 8] = block_c5rY_info;
           R3 = P64[R1 + 7];
           R2 = _s3JF::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       c5sV: // global
           I64[Sp + 8] = block_c5sg_info;
           R3 = P64[R1 + 6];
           R2 = _s3JF::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5rY() //  [R1, R2]
         { info_tbl: [(c5rY,
                       label: block_c5rY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5rY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c5sT; else goto c5sS;
       c5sT: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c5sS: // global
           I64[Hp - 40] = sat_s3JM_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s3JL_info;
           P64[Hp] = R1;
           R2 = Hp - 40;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5sg() //  [R1, R2]
         { info_tbl: [(c5sg,
                       label: block_c5sg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5sg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5sY; else goto c5sX;
       c5sY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c5sX: // global
           I64[Hp - 16] = sat_s3JR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.478493684 UTC

[section ""data" . GHC.Integer.Type.divModInteger_closure" {
     GHC.Integer.Type.divModInteger_closure:
         const GHC.Integer.Type.divModInteger_info;
         const 0;
 },
 sat_s3K3_entry() //  [R1]
         { info_tbl: [(c5tN,
                       label: sat_s3K3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5tN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5tO; else goto c5tP;
       c5tO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5tP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3K2_entry() //  [R1]
         { info_tbl: [(c5tU,
                       label: sat_s3K2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5tU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5tV; else goto c5tW;
       c5tV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5tW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Integer.Type.oneInteger_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.divModInteger_entry() //  [R2, R3]
         { info_tbl: [(c5tX,
                       label: GHC.Integer.Type.divModInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5tX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c5tY; else goto c5tZ;
       c5tY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.divModInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5tZ: // global
           I64[Sp - 16] = block_c5tq_info;
           _s3JU::P64 = R3;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = _s3JU::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5tq() //  [R1, R2]
         { info_tbl: [(c5tq,
                       label: block_c5tq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5tq: // global
           I64[Sp - 16] = block_c5ts_info;
           _s3JX::P64 = R2;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = _s3JX::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5ts() //  [R1]
         { info_tbl: [(c5ts,
                       label: block_c5ts_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ts: // global
           I64[Sp] = block_c5tw_info;
           R2 = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5tw() //  [R1]
         { info_tbl: [(c5tw,
                       label: block_c5tw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5tw: // global
           I64[Sp - 8] = block_c5tA_info;
           R2 = P64[Sp + 8];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5tA() //  [R1]
         { info_tbl: [(c5tA,
                       label: block_c5tA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5tA: // global
           _s3K0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5tE_info;
           R3 = _s3K0::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5tE() //  [R1]
         { info_tbl: [(c5tE,
                       label: block_c5tE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5tE: // global
           _s3JW::P64 = P64[Sp + 16];
           _s3JX::P64 = P64[Sp + 8];
           if (R1 == 1) goto c5u8; else goto c5u7;
       c5u8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c5ub; else goto c5ua;
       c5ub: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c5ua: // global
           I64[Hp - 48] = sat_s3K3_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s3JX::P64;
           I64[Hp - 16] = sat_s3K2_info;
           P64[Hp] = _s3JW::P64;
           R2 = Hp - 48;
           R1 = Hp - 16;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c5u7: // global
           R2 = _s3JX::P64;
           R1 = _s3JW::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.484559764 UTC

[section ""data" . GHC.Integer.Type.divInteger_closure" {
     GHC.Integer.Type.divInteger_closure:
         const GHC.Integer.Type.divInteger_info;
         const 0;
 },
 GHC.Integer.Type.divInteger_entry() //  [R2, R3]
         { info_tbl: [(c5ui,
                       label: GHC.Integer.Type.divInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ui: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5uj; else goto c5uk;
       c5uj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.divInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5uk: // global
           I64[Sp - 8] = block_c5ug_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5ug() //  [R1]
         { info_tbl: [(c5ug,
                       label: block_c5ug_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ug: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.48684239 UTC

[section ""data" . GHC.Integer.Type.modInteger_closure" {
     GHC.Integer.Type.modInteger_closure:
         const GHC.Integer.Type.modInteger_info;
         const 0;
 },
 GHC.Integer.Type.modInteger_entry() //  [R2, R3]
         { info_tbl: [(c5us,
                       label: GHC.Integer.Type.modInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5us: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5ut; else goto c5uu;
       c5ut: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.modInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5uu: // global
           I64[Sp - 8] = block_c5uq_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5uq() //  [R2]
         { info_tbl: [(c5uq,
                       label: block_c5uq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5uq: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.490459454 UTC

[section ""data" . GHC.Integer.Type.quotInteger_closure" {
     GHC.Integer.Type.quotInteger_closure:
         const GHC.Integer.Type.quotInteger_info;
 },
 GHC.Integer.Type.quotInteger_entry() //  [R2, R3]
         { info_tbl: [(c5uC,
                       label: GHC.Integer.Type.quotInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5uC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5uD; else goto c5uE;
       c5uD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5uE: // global
           I64[Sp - 8] = block_c5uA_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5uA() //  [R1]
         { info_tbl: [(c5uA,
                       label: block_c5uA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5uA: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.492660455 UTC

[section ""data" . GHC.Integer.Type.remInteger_closure" {
     GHC.Integer.Type.remInteger_closure:
         const GHC.Integer.Type.remInteger_info;
 },
 GHC.Integer.Type.remInteger_entry() //  [R2, R3]
         { info_tbl: [(c5uM,
                       label: GHC.Integer.Type.remInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5uM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5uN; else goto c5uO;
       c5uN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.remInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5uO: // global
           I64[Sp - 8] = block_c5uK_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5uK() //  [R2]
         { info_tbl: [(c5uK,
                       label: block_c5uK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5uK: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.496266343 UTC

[section ""data" . GHC.Integer.Type.andDigits_closure" {
     GHC.Integer.Type.andDigits_closure:
         const GHC.Integer.Type.andDigits_info;
 },
 GHC.Integer.Type.andDigits_entry() //  [R2, R3]
         { info_tbl: [(c5v1,
                       label: GHC.Integer.Type.andDigits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5v1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5v2; else goto c5v3;
       c5v2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5v3: // global
           I64[Sp - 16] = block_c5uU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5vG; else goto c5uV;
       u5vG: // global
           call _c5uU(R1) args: 0, res: 0, upd: 0;
       c5uV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5uU() //  [R1]
         { info_tbl: [(c5uU,
                       label: block_c5uU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5uU: // global
           _s3Kp::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c5uY; else goto c5uZ;
       c5uY: // global
           I64[Sp - 8] = block_c5v6_info;
           _s3Ks::P64 = P64[R1 + 7];
           _s3Kr::I64 = I64[R1 + 15];
           R1 = _s3Kp::P64;
           P64[Sp] = _s3Ks::P64;
           I64[Sp + 8] = _s3Kr::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5vE; else goto c5v8;
       u5vE: // global
           call _c5v6(R1) args: 0, res: 0, upd: 0;
       c5v8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5uZ: // global
           I64[Sp + 8] = block_c5vw_info;
           R1 = _s3Kp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5vF; else goto c5vy;
       u5vF: // global
           call _c5vw() args: 0, res: 0, upd: 0;
       c5vy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5v6() //  [R1]
         { info_tbl: [(c5v6,
                       label: block_c5v6_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5v6: // global
           if (R1 & 7 == 1) goto c5vm; else goto c5vt;
       c5vm: // global
           I64[Sp] = block_c5vc_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c5vt: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5vc() //  [R1]
         { info_tbl: [(c5vc,
                       label: block_c5vc_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5vc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5vp; else goto c5vo;
       c5vp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5vo: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] & I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5vw() //  []
         { info_tbl: [(c5vw,
                       label: block_c5vw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5vw: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.500150457 UTC

[section ""data" . GHC.Integer.Type.andDigitsOnes_closure" {
     GHC.Integer.Type.andDigitsOnes_closure:
         const GHC.Integer.Type.andDigitsOnes_info;
 },
 GHC.Integer.Type.andDigitsOnes_entry() //  [R2, R3]
         { info_tbl: [(c5vS,
                       label: GHC.Integer.Type.andDigitsOnes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5vS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5vT; else goto c5vU;
       c5vT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andDigitsOnes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5vU: // global
           I64[Sp - 16] = block_c5vL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5wq; else goto c5vM;
       u5wq: // global
           call _c5vL(R1) args: 0, res: 0, upd: 0;
       c5vM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5vL() //  [R1]
         { info_tbl: [(c5vL,
                       label: block_c5vL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5vL: // global
           _s3KA::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c5vP; else goto c5vQ;
       c5vP: // global
           I64[Sp - 8] = block_c5vX_info;
           _s3KD::P64 = P64[R1 + 7];
           _s3KC::I64 = I64[R1 + 15];
           R1 = _s3KA::P64;
           P64[Sp] = _s3KD::P64;
           I64[Sp + 8] = _s3KC::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5wp; else goto c5vZ;
       u5wp: // global
           call _c5vX(R1) args: 0, res: 0, upd: 0;
       c5vZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5vQ: // global
           R1 = _s3KA::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5vX() //  [R1]
         { info_tbl: [(c5vX,
                       label: block_c5vX_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5vX: // global
           if (R1 & 7 == 1) goto c5wd; else goto c5wk;
       c5wd: // global
           I64[Sp] = block_c5w3_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c5wk: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5w3() //  [R1]
         { info_tbl: [(c5w3,
                       label: block_c5w3_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5w3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5wg; else goto c5wf;
       c5wg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5wf: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] & I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.504159114 UTC

[section ""data" . GHC.Integer.Type.orDigits_closure" {
     GHC.Integer.Type.orDigits_closure:
         const GHC.Integer.Type.orDigits_info;
 },
 GHC.Integer.Type.orDigits_entry() //  [R2, R3]
         { info_tbl: [(c5wC,
                       label: GHC.Integer.Type.orDigits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5wC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c5wD; else goto c5wE;
       c5wD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.orDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5wE: // global
           I64[Sp - 16] = block_c5wv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5xa; else goto c5ww;
       u5xa: // global
           call _c5wv(R1) args: 0, res: 0, upd: 0;
       c5ww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5wv() //  [R1]
         { info_tbl: [(c5wv,
                       label: block_c5wv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5wv: // global
           _s3KK::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c5wz; else goto c5wA;
       c5wz: // global
           I64[Sp - 16] = block_c5wH_info;
           _s3KL::P64 = R1;
           _s3KN::P64 = P64[R1 + 7];
           _s3KM::I64 = I64[R1 + 15];
           R1 = _s3KK::P64;
           P64[Sp - 8] = _s3KN::P64;
           I64[Sp] = _s3KM::I64;
           P64[Sp + 8] = _s3KL::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5x9; else goto c5wJ;
       u5x9: // global
           call _c5wH(R1) args: 0, res: 0, upd: 0;
       c5wJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5wA: // global
           R1 = _s3KK::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5wH() //  [R1]
         { info_tbl: [(c5wH,
                       label: block_c5wH_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5wH: // global
           if (R1 & 7 == 1) goto c5wX; else goto c5x4;
       c5wX: // global
           _s3KN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5wN_info;
           R3 = P64[R1 + 7];
           R2 = _s3KN::P64;
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
       c5x4: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5wN() //  [R1]
         { info_tbl: [(c5wN,
                       label: block_c5wN_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5wN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5x0; else goto c5wZ;
       c5x0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5wZ: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] | I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.510580514 UTC

[section ""data" . GHC.Integer.Type.orInteger_closure" {
     GHC.Integer.Type.orInteger_closure:
         const GHC.Integer.Type.orInteger_info;
 },
 GHC.Integer.Type.orInteger_entry() //  [R2, R3]
         { info_tbl: [(c5xm,
                       label: GHC.Integer.Type.orInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5xm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5xn; else goto u5zH;
       c5xn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.orInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u5zH: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c5xc() args: 0, res: 0, upd: 0;
     }
 },
 _c5xc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5xc: // global
           _s3KT::P64 = P64[Sp];
           I64[Sp] = block_c5xf_info;
           R1 = _s3KT::P64;
           if (R1 & 7 != 0) goto u5zN; else goto c5xg;
       u5zN: // global
           call _c5xf(R1) args: 0, res: 0, upd: 0;
       c5xg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5xf() //  [R1]
         { info_tbl: [(c5xf,
                       label: block_c5xf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5xf: // global
           _s3KU::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c5xk; else goto c5xj;
       c5xk: // global
           R1 = _s3KU::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c5xj: // global
           I64[Sp] = block_c5xr_info;
           _s3KV::P64 = R1;
           R1 = _s3KU::P64;
           P64[Sp + 8] = _s3KV::P64;
           if (R1 & 7 != 0) goto u5zO; else goto c5xt;
       u5zO: // global
           call _c5xr(R1) args: 0, res: 0, upd: 0;
       c5xt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5xr() //  [R1]
         { info_tbl: [(c5xr,
                       label: block_c5xr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5xr: // global
           _s3KV::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c5zx; else goto c5xA;
       c5zx: // global
           R1 = _s3KV::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c5xA: // global
           I64[Sp] = block_c5xx_info;
           _s3KW::P64 = R1;
           R1 = _s3KV::P64;
           P64[Sp + 8] = _s3KW::P64;
           if (R1 & 7 != 0) goto u5zQ; else goto c5xB;
       u5zQ: // global
           call _c5xx(R1) args: 0, res: 0, upd: 0;
       c5xB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5xx() //  [R1]
         { info_tbl: [(c5xx,
                       label: block_c5xx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5xx: // global
           _s3KW::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c5xI; else goto c5yH;
       c5xI: // global
           I64[Sp] = block_c5xF_info;
           _s3KY::P64 = P64[R1 + 7];
           R1 = _s3KW::P64;
           P64[Sp + 8] = _s3KY::P64;
           if (R1 & 7 != 0) goto u5zR; else goto c5xJ;
       u5zR: // global
           call _c5xF(R1) args: 0, res: 0, upd: 0;
       c5xJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5yH: // global
           I64[Sp - 8] = block_c5yF_info;
           _s3KX::P64 = R1;
           _s3Ld::P64 = P64[R1 + 6];
           R1 = _s3KW::P64;
           P64[Sp] = _s3Ld::P64;
           P64[Sp + 8] = _s3KX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5zS; else goto c5yI;
       u5zS: // global
           call _c5yF(R1) args: 0, res: 0, upd: 0;
       c5yI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5xF() //  [R1]
         { info_tbl: [(c5xF,
                       label: block_c5xF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5xF: // global
           if (R1 & 7 < 2) goto c5xU; else goto c5ya;
       c5xU: // global
           _s3KY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5xN_info;
           R3 = P64[R1 + 7];
           R2 = _s3KY::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
       c5ya: // global
           I64[Sp] = block_c5y0_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5xN() //  [R1]
         { info_tbl: [(c5xN,
                       label: block_c5xN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5xN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5xX; else goto c5xW;
       c5xX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5xW: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5y0() //  [R1]
         { info_tbl: [(c5y0,
                       label: block_c5y0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5y0: // global
           I64[Sp] = block_c5y4_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5y4() //  [R1]
         { info_tbl: [(c5y4,
                       label: block_c5y4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5y4: // global
           _s3L4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5y8_info;
           R3 = _s3L4::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5y8() //  [R1]
         { info_tbl: [(c5y8,
                       label: block_c5y8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5y8: // global
           I64[Sp] = block_c5yg_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5yg() //  [R1, R2]
         { info_tbl: [(c5yg,
                       label: block_c5yg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5yg: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5yh() args: 0, res: 0, upd: 0;
     }
 },
 _c5yh() //  []
         { info_tbl: [(c5yh,
                       label: block_c5yh_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5yh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5yp; else goto c5yo;
       c5yp: // global
           HpAlloc = 24;
           I64[Sp] = block_c5yh_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5yo: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c5yl_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5yl() //  [R1]
         { info_tbl: [(c5yl,
                       label: block_c5yl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5yl: // global
           if (R1 & 7 == 1) goto c5yv; else goto u5zJ;
       c5yv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5yy; else goto c5yx;
       c5yy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5yx: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u5zJ: // global
           Sp = Sp + 8;
           call _c5zt() args: 0, res: 0, upd: 0;
     }
 },
 _c5yF() //  [R1]
         { info_tbl: [(c5yF,
                       label: block_c5yF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5yF: // global
           if (R1 & 7 < 2) goto c5yO; else goto c5z1;
       c5yO: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c5xc() args: 0, res: 0, upd: 0;
       c5z1: // global
           I64[Sp] = block_c5yR_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5yR() //  [R1]
         { info_tbl: [(c5yR,
                       label: block_c5yR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5yR: // global
           _s3Ld::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5yV_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s3Ld::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5yV() //  [R1]
         { info_tbl: [(c5yV,
                       label: block_c5yV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5yV: // global
           _s3Li::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5yZ_info;
           R3 = _s3Li::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5yZ() //  [R1]
         { info_tbl: [(c5yZ,
                       label: block_c5yZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5yZ: // global
           I64[Sp] = block_c5z7_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5z7() //  [R1, R2]
         { info_tbl: [(c5z7,
                       label: block_c5z7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5z7: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5z8() args: 0, res: 0, upd: 0;
     }
 },
 _c5z8() //  []
         { info_tbl: [(c5z8,
                       label: block_c5z8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5z8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5zg; else goto c5zf;
       c5zg: // global
           HpAlloc = 24;
           I64[Sp] = block_c5z8_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5zf: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c5zc_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5zc() //  [R1]
         { info_tbl: [(c5zc,
                       label: block_c5zc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5zc: // global
           if (R1 & 7 == 1) goto c5zm; else goto u5zM;
       c5zm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5zp; else goto c5zo;
       c5zp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5zo: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u5zM: // global
           Sp = Sp + 8;
           call _c5zt() args: 0, res: 0, upd: 0;
     }
 },
 _c5zt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5zt: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.517123415 UTC

[section ""data" . GHC.Integer.Type.mkInteger_f_closure" {
     GHC.Integer.Type.mkInteger_f_closure:
         const GHC.Integer.Type.mkInteger_f_info;
 },
 GHC.Integer.Type.mkInteger_f_entry() //  [R2]
         { info_tbl: [(c5A9,
                       label: GHC.Integer.Type.mkInteger_f_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5A9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5Aa; else goto c5Ab;
       c5Aa: // global
           R2 = R2;
           R1 = GHC.Integer.Type.mkInteger_f_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Ab: // global
           I64[Sp - 8] = block_c5A2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5AE; else goto c5A3;
       u5AE: // global
           call _c5A2(R1) args: 0, res: 0, upd: 0;
       c5A3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5A2() //  [R1]
         { info_tbl: [(c5A2,
                       label: block_c5A2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5A2: // global
           if (R1 & 7 == 1) goto c5A6; else goto c5A7;
       c5A6: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5A7: // global
           I64[Sp - 8] = block_c5Ah_info;
           _s3Lu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s3Lu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5AD; else goto c5Ai;
       u5AD: // global
           call _c5Ah(R1) args: 0, res: 0, upd: 0;
       c5Ai: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Ah() //  [R1]
         { info_tbl: [(c5Ah,
                       label: block_c5Ah_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ah: // global
           I64[Sp] = block_c5Am_info;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5Am() //  [R1]
         { info_tbl: [(c5Am,
                       label: block_c5Am_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Am: // global
           I64[Sp] = block_c5Aq_info;
           R3 = 31;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5Aq() //  [R1]
         { info_tbl: [(c5Aq,
                       label: block_c5Aq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Aq: // global
           I64[Sp] = block_c5Au_info;
           R2 = I64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5Au() //  [R1]
         { info_tbl: [(c5Au,
                       label: block_c5Au_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Au: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.519369898 UTC

[section ""data" . GHC.Integer.Type.mkInteger_closure" {
     GHC.Integer.Type.mkInteger_closure:
         const GHC.Integer.Type.mkInteger_info;
 },
 GHC.Integer.Type.mkInteger_entry() //  [R2, R3]
         { info_tbl: [(c5AQ,
                       label: GHC.Integer.Type.mkInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5AQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5AR; else goto c5AS;
       c5AR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.mkInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5AS: // global
           I64[Sp - 16] = block_c5AJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5B4; else goto c5AK;
       u5B4: // global
           call _c5AJ(R1) args: 0, res: 0, upd: 0;
       c5AK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5AJ() //  [R1]
         { info_tbl: [(c5AJ,
                       label: block_c5AJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5AJ: // global
           _s3LB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c5AN; else goto c5AO;
       c5AN: // global
           I64[Sp + 8] = block_c5AV_info;
           R2 = _s3LB::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 8, upd: 8;
       c5AO: // global
           R2 = _s3LB::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c5AV() //  [R1]
         { info_tbl: [(c5AV,
                       label: block_c5AV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5AV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.523162517 UTC

[section ""data" . GHC.Integer.Type.andInteger_closure" {
     GHC.Integer.Type.andInteger_closure:
         const GHC.Integer.Type.andInteger_info;
 },
 GHC.Integer.Type.andInteger_entry() //  [R2, R3]
         { info_tbl: [(c5Bg,
                       label: GHC.Integer.Type.andInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Bg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5Bh; else goto u5DL;
       c5Bh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u5DL: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c5B6() args: 0, res: 0, upd: 0;
     }
 },
 _c5B6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5B6: // global
           _s3LE::P64 = P64[Sp];
           I64[Sp] = block_c5B9_info;
           R1 = _s3LE::P64;
           if (R1 & 7 != 0) goto u5DS; else goto c5Ba;
       u5DS: // global
           call _c5B9(R1) args: 0, res: 0, upd: 0;
       c5Ba: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5B9() //  [R1]
         { info_tbl: [(c5B9,
                       label: block_c5B9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5B9: // global
           _s3LF::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c5Be; else goto c5Bd;
       c5Be: // global
           I64[Sp + 8] = block_c5Dx_info;
           R1 = _s3LF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5DU; else goto c5Dz;
       u5DU: // global
           call _c5Dx() args: 0, res: 0, upd: 0;
       c5Dz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5Bd: // global
           I64[Sp] = block_c5Bl_info;
           _s3LG::P64 = R1;
           R1 = _s3LF::P64;
           P64[Sp + 8] = _s3LG::P64;
           if (R1 & 7 != 0) goto u5DT; else goto c5Bn;
       u5DT: // global
           call _c5Bl(R1) args: 0, res: 0, upd: 0;
       c5Bn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Dx() //  []
         { info_tbl: [(c5Dx,
                       label: block_c5Dx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Dx: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5Bl() //  [R1]
         { info_tbl: [(c5Bl,
                       label: block_c5Bl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Bl: // global
           if (R1 & 7 == 3) goto u5DM; else goto c5Bu;
       u5DM: // global
           Sp = Sp + 16;
           call _c5Du() args: 0, res: 0, upd: 0;
       c5Bu: // global
           I64[Sp] = block_c5Br_info;
           _s3LH::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s3LH::P64;
           if (R1 & 7 != 0) goto u5DW; else goto c5Bv;
       u5DW: // global
           call _c5Br(R1) args: 0, res: 0, upd: 0;
       c5Bv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Br() //  [R1]
         { info_tbl: [(c5Br,
                       label: block_c5Br_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Br: // global
           _s3LH::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c5BC; else goto c5CE;
       c5BC: // global
           I64[Sp] = block_c5Bz_info;
           _s3LJ::P64 = P64[R1 + 7];
           R1 = _s3LH::P64;
           P64[Sp + 8] = _s3LJ::P64;
           if (R1 & 7 != 0) goto u5DY; else goto c5BD;
       u5DY: // global
           call _c5Bz(R1) args: 0, res: 0, upd: 0;
       c5BD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5CE: // global
           I64[Sp - 8] = block_c5CC_info;
           _s3LI::P64 = R1;
           _s3LX::P64 = P64[R1 + 6];
           R1 = _s3LH::P64;
           P64[Sp] = _s3LX::P64;
           P64[Sp + 8] = _s3LI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5DZ; else goto c5CF;
       u5DZ: // global
           call _c5CC(R1) args: 0, res: 0, upd: 0;
       c5CF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Bz() //  [R1]
         { info_tbl: [(c5Bz,
                       label: block_c5Bz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Bz: // global
           if (R1 & 7 < 2) goto c5BK; else goto c5Cf;
       c5BK: // global
           _s3LJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5BH_info;
           R3 = P64[R1 + 7];
           R2 = _s3LJ::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c5Cf: // global
           I64[Sp] = block_c5C5_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5BH() //  [R1]
         { info_tbl: [(c5BH,
                       label: block_c5BH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5BH: // global
           I64[Sp] = block_c5BO_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5BO() //  [R1]
         { info_tbl: [(c5BO,
                       label: block_c5BO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5BO: // global
           if (R1 & 7 == 1) goto c5BV; else goto u5DN;
       c5BV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5BY; else goto c5BX;
       c5BY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5BX: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u5DN: // global
           Sp = Sp + 8;
           call _c5Du() args: 0, res: 0, upd: 0;
     }
 },
 _c5C5() //  [R1]
         { info_tbl: [(c5C5,
                       label: block_c5C5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5C5: // global
           I64[Sp] = block_c5C9_info;
           R2 = R1;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5C9() //  [R1]
         { info_tbl: [(c5C9,
                       label: block_c5C9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5C9: // global
           _s3LJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5Cd_info;
           R3 = _s3LJ::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5Cd() //  [R1]
         { info_tbl: [(c5Cd,
                       label: block_c5Cd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Cd: // global
           I64[Sp] = block_c5Cl_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5Cl() //  [R1]
         { info_tbl: [(c5Cl,
                       label: block_c5Cl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Cl: // global
           if (R1 & 7 == 1) goto c5Cs; else goto u5DO;
       c5Cs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5Cv; else goto c5Cu;
       c5Cv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Cu: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u5DO: // global
           Sp = Sp + 8;
           call _c5Du() args: 0, res: 0, upd: 0;
     }
 },
 _c5CC() //  [R1]
         { info_tbl: [(c5CC,
                       label: block_c5CC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5CC: // global
           if (R1 & 7 < 2) goto c5CL; else goto c5CY;
       c5CL: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c5B6() args: 0, res: 0, upd: 0;
       c5CY: // global
           I64[Sp] = block_c5CO_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5CO() //  [R1]
         { info_tbl: [(c5CO,
                       label: block_c5CO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5CO: // global
           _s3LX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5CS_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s3LX::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5CS() //  [R1]
         { info_tbl: [(c5CS,
                       label: block_c5CS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5CS: // global
           _s3M2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5CW_info;
           R3 = _s3M2::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5CW() //  [R1]
         { info_tbl: [(c5CW,
                       label: block_c5CW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5CW: // global
           I64[Sp] = block_c5D4_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5D4() //  [R1, R2]
         { info_tbl: [(c5D4,
                       label: block_c5D4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5D4: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5D5() args: 0, res: 0, upd: 0;
     }
 },
 _c5D5() //  []
         { info_tbl: [(c5D5,
                       label: block_c5D5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5D5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Dd; else goto c5Dc;
       c5Dd: // global
           HpAlloc = 24;
           I64[Sp] = block_c5D5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5Dc: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c5D9_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5D9() //  [R1]
         { info_tbl: [(c5D9,
                       label: block_c5D9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5D9: // global
           if (R1 & 7 == 1) goto c5Dj; else goto u5DR;
       c5Dj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5Dm; else goto c5Dl;
       c5Dm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Dl: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u5DR: // global
           Sp = Sp + 8;
           call _c5Du() args: 0, res: 0, upd: 0;
     }
 },
 _c5Du() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Du: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.528274755 UTC

[section ""data" . GHC.Integer.Type.testBitInteger_closure" {
     GHC.Integer.Type.testBitInteger_closure:
         const GHC.Integer.Type.testBitInteger_info;
 },
 GHC.Integer.Type.testBitInteger_entry() //  [R2, R3]
         { info_tbl: [(c5Eb,
                       label: GHC.Integer.Type.testBitInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Eb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5Ej; else goto c5Ek;
       c5Ej: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.testBitInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5Ek: // global
           I64[Sp - 16] = block_c5E9_info;
           R3 = R3;
           _s3Mc::P64 = R2;
           R2 = GHC.Integer.Type.oneInteger_closure+1;
           P64[Sp - 8] = _s3Mc::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5E9() //  [R1]
         { info_tbl: [(c5E9,
                       label: block_c5E9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5E9: // global
           _s3Mc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5Ee_info;
           R3 = R1;
           R2 = _s3Mc::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5Ee() //  [R1]
         { info_tbl: [(c5Ee,
                       label: block_c5Ee_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ee: // global
           I64[Sp] = block_c5Ei_info;
           R3 = GHC.Integer.Type.Naught_closure+3;
           R2 = R1;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5Ei() //  [R1]
         { info_tbl: [(c5Ei,
                       label: block_c5Ei_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ei: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.530534303 UTC

[section ""data" . GHC.Integer.Type.xorDigits_closure" {
     GHC.Integer.Type.xorDigits_closure:
         const GHC.Integer.Type.xorDigits_info;
 },
 GHC.Integer.Type.xorDigits_entry() //  [R2, R3]
         { info_tbl: [(c5EC,
                       label: GHC.Integer.Type.xorDigits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5EC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c5ED; else goto c5EE;
       c5ED: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.xorDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5EE: // global
           I64[Sp - 16] = block_c5Ev_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5Fa; else goto c5Ew;
       u5Fa: // global
           call _c5Ev(R1) args: 0, res: 0, upd: 0;
       c5Ew: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Ev() //  [R1]
         { info_tbl: [(c5Ev,
                       label: block_c5Ev_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ev: // global
           _s3Mi::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c5Ez; else goto c5EA;
       c5Ez: // global
           I64[Sp - 16] = block_c5EH_info;
           _s3Mj::P64 = R1;
           _s3Ml::P64 = P64[R1 + 7];
           _s3Mk::I64 = I64[R1 + 15];
           R1 = _s3Mi::P64;
           P64[Sp - 8] = _s3Ml::P64;
           I64[Sp] = _s3Mk::I64;
           P64[Sp + 8] = _s3Mj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5F9; else goto c5EJ;
       u5F9: // global
           call _c5EH(R1) args: 0, res: 0, upd: 0;
       c5EJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5EA: // global
           R1 = _s3Mi::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5EH() //  [R1]
         { info_tbl: [(c5EH,
                       label: block_c5EH_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5EH: // global
           if (R1 & 7 == 1) goto c5EX; else goto c5F4;
       c5EX: // global
           _s3Ml::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5EN_info;
           R3 = P64[R1 + 7];
           R2 = _s3Ml::P64;
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c5F4: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5EN() //  [R1]
         { info_tbl: [(c5EN,
                       label: block_c5EN_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5EN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5F0; else goto c5EZ;
       c5F0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5EZ: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] ^ I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.534629717 UTC

[section ""data" . GHC.Integer.Type.xorInteger_closure" {
     GHC.Integer.Type.xorInteger_closure:
         const GHC.Integer.Type.xorInteger_info;
 },
 GHC.Integer.Type.xorInteger_entry() //  [R2, R3]
         { info_tbl: [(c5Fm,
                       label: GHC.Integer.Type.xorInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Fm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5Fn; else goto u5HG;
       c5Fn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.xorInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u5HG: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c5Fc() args: 0, res: 0, upd: 0;
     }
 },
 _c5Fc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Fc: // global
           _s3Mr::P64 = P64[Sp];
           I64[Sp] = block_c5Ff_info;
           R1 = _s3Mr::P64;
           if (R1 & 7 != 0) goto u5HM; else goto c5Fg;
       u5HM: // global
           call _c5Ff(R1) args: 0, res: 0, upd: 0;
       c5Fg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Ff() //  [R1]
         { info_tbl: [(c5Ff,
                       label: block_c5Ff_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ff: // global
           _s3Ms::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c5Fk; else goto c5Fj;
       c5Fk: // global
           R1 = _s3Ms::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c5Fj: // global
           I64[Sp] = block_c5Fr_info;
           _s3Mt::P64 = R1;
           R1 = _s3Ms::P64;
           P64[Sp + 8] = _s3Mt::P64;
           if (R1 & 7 != 0) goto u5HN; else goto c5Ft;
       u5HN: // global
           call _c5Fr(R1) args: 0, res: 0, upd: 0;
       c5Ft: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Fr() //  [R1]
         { info_tbl: [(c5Fr,
                       label: block_c5Fr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Fr: // global
           _s3Mt::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c5Hv; else goto c5FA;
       c5Hv: // global
           R1 = _s3Mt::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c5FA: // global
           I64[Sp] = block_c5Fx_info;
           _s3Mu::P64 = R1;
           R1 = _s3Mt::P64;
           P64[Sp + 8] = _s3Mu::P64;
           if (R1 & 7 != 0) goto u5HP; else goto c5FB;
       u5HP: // global
           call _c5Fx(R1) args: 0, res: 0, upd: 0;
       c5FB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Fx() //  [R1]
         { info_tbl: [(c5Fx,
                       label: block_c5Fx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Fx: // global
           _s3Mu::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c5FI; else goto c5GN;
       c5FI: // global
           I64[Sp] = block_c5FF_info;
           _s3Mw::P64 = P64[R1 + 7];
           R1 = _s3Mu::P64;
           P64[Sp + 8] = _s3Mw::P64;
           if (R1 & 7 != 0) goto u5HQ; else goto c5FJ;
       u5HQ: // global
           call _c5FF(R1) args: 0, res: 0, upd: 0;
       c5FJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5GN: // global
           I64[Sp - 8] = block_c5GL_info;
           _s3Mv::P64 = R1;
           _s3MN::P64 = P64[R1 + 6];
           R1 = _s3Mu::P64;
           P64[Sp] = _s3MN::P64;
           P64[Sp + 8] = _s3Mv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5HR; else goto c5GO;
       u5HR: // global
           call _c5GL(R1) args: 0, res: 0, upd: 0;
       c5GO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5FF() //  [R1]
         { info_tbl: [(c5FF,
                       label: block_c5FF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5FF: // global
           if (R1 & 7 < 2) goto c5FQ; else goto c5Gh;
       c5FQ: // global
           _s3Mw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5FN_info;
           R3 = P64[R1 + 7];
           R2 = _s3Mw::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c5Gh: // global
           I64[Sp] = block_c5Gb_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5FN() //  [R1]
         { info_tbl: [(c5FN,
                       label: block_c5FN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5FN: // global
           I64[Sp] = block_c5FU_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5FU() //  [R1]
         { info_tbl: [(c5FU,
                       label: block_c5FU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5FU: // global
           if (R1 & 7 == 1) goto c5G1; else goto u5HH;
       c5G1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5G4; else goto c5G3;
       c5G4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5G3: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u5HH: // global
           Sp = Sp + 8;
           call _c5Hr() args: 0, res: 0, upd: 0;
     }
 },
 _c5Gb() //  [R1]
         { info_tbl: [(c5Gb,
                       label: block_c5Gb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Gb: // global
           _s3Mw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5Gf_info;
           R3 = R1;
           R2 = _s3Mw::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5Gf() //  [R1]
         { info_tbl: [(c5Gf,
                       label: block_c5Gf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Gf: // global
           I64[Sp] = block_c5Gm_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5Gm() //  [R1, R2]
         { info_tbl: [(c5Gm,
                       label: block_c5Gm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Gm: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5Gn() args: 0, res: 0, upd: 0;
     }
 },
 _c5Gn() //  []
         { info_tbl: [(c5Gn,
                       label: block_c5Gn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Gn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Gv; else goto c5Gu;
       c5Gv: // global
           HpAlloc = 24;
           I64[Sp] = block_c5Gn_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5Gu: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c5Gr_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5Gr() //  [R1]
         { info_tbl: [(c5Gr,
                       label: block_c5Gr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Gr: // global
           if (R1 & 7 == 1) goto c5GB; else goto u5HJ;
       c5GB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5GE; else goto c5GD;
       c5GE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5GD: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u5HJ: // global
           Sp = Sp + 8;
           call _c5Hr() args: 0, res: 0, upd: 0;
     }
 },
 _c5GL() //  [R1]
         { info_tbl: [(c5GL,
                       label: block_c5GL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5GL: // global
           if (R1 & 7 < 2) goto c5GU; else goto c5H7;
       c5GU: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c5Fc() args: 0, res: 0, upd: 0;
       c5H7: // global
           I64[Sp] = block_c5GX_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5GX() //  [R1]
         { info_tbl: [(c5GX,
                       label: block_c5GX_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5GX: // global
           _s3MN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5H1_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s3MN::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5H1() //  [R1]
         { info_tbl: [(c5H1,
                       label: block_c5H1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5H1: // global
           _s3MS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5H5_info;
           R3 = _s3MS::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5H5() //  [R1]
         { info_tbl: [(c5H5,
                       label: block_c5H5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5H5: // global
           I64[Sp] = block_c5Hd_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5Hd() //  [R1]
         { info_tbl: [(c5Hd,
                       label: block_c5Hd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Hd: // global
           if (R1 & 7 == 1) goto c5Hk; else goto u5HL;
       c5Hk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5Hn; else goto c5Hm;
       c5Hn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Hm: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u5HL: // global
           Sp = Sp + 8;
           call _c5Hr() args: 0, res: 0, upd: 0;
     }
 },
 _c5Hr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Hr: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.53930035 UTC

[section ""cstring" . GHC.Integer.Type.$trModule4_bytes" {
     GHC.Integer.Type.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.540063284 UTC

[section ""data" . GHC.Integer.Type.$trModule3_closure" {
     GHC.Integer.Type.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.54072029 UTC

[section ""cstring" . GHC.Integer.Type.$trModule2_bytes" {
     GHC.Integer.Type.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.5415691 UTC

[section ""data" . GHC.Integer.Type.$trModule1_closure" {
     GHC.Integer.Type.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.542171246 UTC

[section ""data" . GHC.Integer.Type.$trModule_closure" {
     GHC.Integer.Type.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Type.$trModule3_closure+1;
         const GHC.Integer.Type.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.542799517 UTC

[section ""data" . $krep_r3Bp_closure" {
     $krep_r3Bp_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.543569725 UTC

[section ""data" . $krep1_r3Bq_closure" {
     $krep1_r3Bq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.54417873 UTC

[section ""cstring" . GHC.Integer.Type.$tcDigits2_bytes" {
     GHC.Integer.Type.$tcDigits2_bytes:
         I8[] [68,105,103,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.5449869 UTC

[section ""data" . GHC.Integer.Type.$tcDigits1_closure" {
     GHC.Integer.Type.$tcDigits1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcDigits2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.545681716 UTC

[section ""data" . GHC.Integer.Type.$tcDigits_closure" {
     GHC.Integer.Type.$tcDigits_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcDigits1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16647862651490579480;
         const 7069031713090282797;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.546351024 UTC

[section ""data" . GHC.Integer.Type.$tc'None1_closure" {
     GHC.Integer.Type.$tc'None1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcDigits_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.547094686 UTC

[section ""cstring" . GHC.Integer.Type.$tc'None3_bytes" {
     GHC.Integer.Type.$tc'None3_bytes:
         I8[] [39,78,111,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.547762608 UTC

[section ""data" . GHC.Integer.Type.$tc'None2_closure" {
     GHC.Integer.Type.$tc'None2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'None3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.54853797 UTC

[section ""data" . GHC.Integer.Type.$tc'None_closure" {
     GHC.Integer.Type.$tc'None_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'None2_closure+1;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const 903679638320298226;
         const 12977397153301278560;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.549194449 UTC

[section ""data" . $krep2_r3Br_closure" {
     $krep2_r3Br_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.549982689 UTC

[section ""data" . GHC.Integer.Type.$tc'Some1_closure" {
     GHC.Integer.Type.$tc'Some1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r3Bq_closure+1;
         const $krep2_r3Br_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.550766293 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Some3_bytes" {
     GHC.Integer.Type.$tc'Some3_bytes:
         I8[] [39,83,111,109,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.551370563 UTC

[section ""data" . GHC.Integer.Type.$tc'Some2_closure" {
     GHC.Integer.Type.$tc'Some2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Some3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.55214665 UTC

[section ""data" . GHC.Integer.Type.$tc'Some_closure" {
     GHC.Integer.Type.$tc'Some_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Some2_closure+1;
         const GHC.Integer.Type.$tc'Some1_closure+4;
         const 6045911439621864566;
         const 9702873355935012388;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.55278806 UTC

[section ""cstring" . GHC.Integer.Type.$tcInteger2_bytes" {
     GHC.Integer.Type.$tcInteger2_bytes:
         I8[] [73,110,116,101,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.553478777 UTC

[section ""data" . GHC.Integer.Type.$tcInteger1_closure" {
     GHC.Integer.Type.$tcInteger1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcInteger2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.55423191 UTC

[section ""data" . GHC.Integer.Type.$tcInteger_closure" {
     GHC.Integer.Type.$tcInteger_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcInteger1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12260413788024328428;
         const 9583620696682509916;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.554916975 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught1_closure" {
     GHC.Integer.Type.$tc'Naught1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.555493218 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Naught3_bytes" {
     GHC.Integer.Type.$tc'Naught3_bytes:
         I8[] [39,78,97,117,103,104,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.556251562 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught2_closure" {
     GHC.Integer.Type.$tc'Naught2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Naught3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.556878144 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught_closure" {
     GHC.Integer.Type.$tc'Naught_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Naught2_closure+1;
         const GHC.Integer.Type.$tc'Naught1_closure+1;
         const 7287704174224038176;
         const 776397532388787230;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.557718255 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative1_closure" {
     GHC.Integer.Type.$tc'Negative1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const GHC.Integer.Type.$tc'Naught1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.558377484 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Positive2_bytes" {
     GHC.Integer.Type.$tc'Positive2_bytes:
         I8[] [39,80,111,115,105,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.559028671 UTC

[section ""data" . GHC.Integer.Type.$tc'Positive1_closure" {
     GHC.Integer.Type.$tc'Positive1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Positive2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.559793092 UTC

[section ""data" . GHC.Integer.Type.$tc'Positive_closure" {
     GHC.Integer.Type.$tc'Positive_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Positive1_closure+1;
         const GHC.Integer.Type.$tc'Negative1_closure+4;
         const 6887932004110746796;
         const 9391890139750561935;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.560442238 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Negative3_bytes" {
     GHC.Integer.Type.$tc'Negative3_bytes:
         I8[] [39,78,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.561159049 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative2_closure" {
     GHC.Integer.Type.$tc'Negative2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Negative3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.561880019 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative_closure" {
     GHC.Integer.Type.$tc'Negative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Negative2_closure+1;
         const GHC.Integer.Type.$tc'Negative1_closure+4;
         const 4010847856516363452;
         const 15624358648337932456;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.562496301 UTC

[section ""cstring" . GHC.Integer.Type.$tcList2_bytes" {
     GHC.Integer.Type.$tcList2_bytes:
         I8[] [76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.563225111 UTC

[section ""data" . GHC.Integer.Type.$tcList1_closure" {
     GHC.Integer.Type.$tcList1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcList2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.563853251 UTC

[section ""data" . GHC.Integer.Type.$tcList_closure" {
     GHC.Integer.Type.$tcList_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 732340346576824023;
         const 9653115931589988500;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.564640849 UTC

[section ""data" . $krep3_r3Bs_closure" {
     $krep3_r3Bs_closure:
         const :_con_info;
         const $krep_r3Bp_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.565467177 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil1_closure" {
     GHC.Integer.Type.$tc'Nil1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcList_closure+1;
         const $krep3_r3Bs_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.566064368 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Nil3_bytes" {
     GHC.Integer.Type.$tc'Nil3_bytes:
         I8[] [39,78,105,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.566809423 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil2_closure" {
     GHC.Integer.Type.$tc'Nil2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Nil3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.56739761 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil_closure" {
     GHC.Integer.Type.$tc'Nil_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Nil2_closure+1;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const 13538585131509945451;
         const 9366316088405446135;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.568185231 UTC

[section ""data" . $krep4_r3Bt_closure" {
     $krep4_r3Bt_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.568818301 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons1_closure" {
     GHC.Integer.Type.$tc'Cons1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r3Bp_closure+2;
         const $krep4_r3Bt_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.569549357 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Cons3_bytes" {
     GHC.Integer.Type.$tc'Cons3_bytes:
         I8[] [39,67,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.570271976 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons2_closure" {
     GHC.Integer.Type.$tc'Cons2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Cons3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.570884569 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons_closure" {
     GHC.Integer.Type.$tc'Cons_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Cons2_closure+1;
         const GHC.Integer.Type.$tc'Cons1_closure+4;
         const 3906777924842222150;
         const 5463288556346842885;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.571687352 UTC

[section ""cstring" . GHC.Integer.Type.$tcDigitsOnes2_bytes" {
     GHC.Integer.Type.$tcDigitsOnes2_bytes:
         I8[] [68,105,103,105,116,115,79,110,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.572320887 UTC

[section ""data" . GHC.Integer.Type.$tcDigitsOnes1_closure" {
     GHC.Integer.Type.$tcDigitsOnes1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcDigitsOnes2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.573011405 UTC

[section ""data" . GHC.Integer.Type.$tcDigitsOnes_closure" {
     GHC.Integer.Type.$tcDigitsOnes_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcDigitsOnes1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4554239703586147919;
         const 6957361150436389790;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.574535935 UTC

[section ""data" . $krep5_r3Bu_closure" {
     $krep5_r3Bu_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcDigitsOnes_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.575182212 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes1_closure" {
     GHC.Integer.Type.$tc'DigitsOnes1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const $krep5_r3Bu_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.576016095 UTC

[section ""cstring" . GHC.Integer.Type.$tc'DigitsOnes3_bytes" {
     GHC.Integer.Type.$tc'DigitsOnes3_bytes:
         I8[] [39,68,105,103,105,116,115,79,110,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.576611784 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes2_closure" {
     GHC.Integer.Type.$tc'DigitsOnes2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'DigitsOnes3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.577233289 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes_closure" {
     GHC.Integer.Type.$tc'DigitsOnes_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'DigitsOnes2_closure+1;
         const GHC.Integer.Type.$tc'DigitsOnes1_closure+4;
         const 15211110739657495015;
         const 1682512192113792266;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.578399188 UTC

[section ""data" . GHC.Integer.Type.encodeDouble#_closure" {
     GHC.Integer.Type.encodeDouble#_closure:
         const GHC.Integer.Type.encodeDouble#_info;
 },
 GHC.Integer.Type.encodeDouble#_entry() //  [R2, R3]
         { info_tbl: [(c5I4,
                       label: GHC.Integer.Type.encodeDouble#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5I4: // global
           _c5I3::I64 = R3;
           (_s3N2::F64) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeDouble(R2, _c5I3::I64);
           D1 = _s3N2::F64;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.579839234 UTC

[section ""data" . f_r3Bv_closure" {
     f_r3Bv_closure:
         const f_r3Bv_info;
 },
 f_r3Bv_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5I8: // global
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           D1 = F64[Sp];
           R1 = R1;
           Sp = Sp + 24;
           call f_r3Bv_entry(R3, R2, D1, R1) args: 8, res: 0, upd: 8;
     }
 },
 f_r3Bv_entry() //  [R2, R3, D1]
         { info_tbl: [(c5Ij,
                       label: f_r3Bv_info
                       rep:HeapRep static {
                             Fun {arity: 3 fun_type: ArgGen [True, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ij: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c5Ik; else goto u5Iz;
       c5Ik: // global
           R1 = f_r3Bv_closure;
           F64[Sp - 24] = D1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       u5Iz: // global
           F64[Sp - 24] = D1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _c5I9() args: 0, res: 0, upd: 0;
     }
 },
 _c5I9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5I9: // global
           I64[Sp - 8] = block_c5Ic_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5IB; else goto c5Id;
       u5IB: // global
           call _c5Ic(R1) args: 0, res: 0, upd: 0;
       c5Id: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Ic() //  [R1]
         { info_tbl: [(c5Ic,
                       label: block_c5Ic_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ic: // global
           _s3N3::F64 = F64[Sp + 8];
           if (R1 & 7 == 1) goto c5Ig; else goto c5Ih;
       c5Ig: // global
           _s3N5::I64 = I64[Sp + 24];
           _s3N8::P64 = P64[R1 + 7];
           (_s3Nc::F64) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeDouble(I64[R1 + 15], _s3N5::I64);
           F64[Sp + 8] = %MO_F_Add_W64(_s3N3::F64, _s3Nc::F64);
           P64[Sp + 16] = _s3N8::P64;
           I64[Sp + 24] = _s3N5::I64 + 64;
           Sp = Sp + 8;
           call _c5I9() args: 0, res: 0, upd: 0;
       c5Ih: // global
           D1 = _s3N3::F64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.582560981 UTC

[section ""data" . GHC.Integer.Type.encodeDoubleInteger_closure" {
     GHC.Integer.Type.encodeDoubleInteger_closure:
         const GHC.Integer.Type.encodeDoubleInteger_info;
 },
 GHC.Integer.Type.encodeDoubleInteger_entry() //  [R2, R3]
         { info_tbl: [(c5IQ,
                       label: GHC.Integer.Type.encodeDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5IQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5IR; else goto c5IS;
       c5IR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.encodeDoubleInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5IS: // global
           I64[Sp - 16] = block_c5II_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5Jc; else goto c5IJ;
       u5Jc: // global
           call _c5II(R1) args: 0, res: 0, upd: 0;
       c5IJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5II() //  [R1]
         { info_tbl: [(c5II,
                       label: block_c5II_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5II: // global
           _c5IP::P64 = R1 & 7;
           if (_c5IP::P64 < 3) goto u5Jb; else goto c5IO;
       u5Jb: // global
           _s3Ng::I64 = I64[Sp + 8];
           if (_c5IP::P64 < 2) goto c5IM; else goto c5IN;
       c5IM: // global
           R3 = _s3Ng::I64;
           R2 = P64[R1 + 7];
           D1 = 0.0 :: W64;
           Sp = Sp + 16;
           call f_r3Bv_entry(R3, R2, D1) args: 8, res: 0, upd: 8;
       c5IN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5J6; else goto c5J5;
       c5J6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5J5: // global
           _s3Nj::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3Nj::P64;
           I64[Sp + 8] = block_c5IZ_info;
           R3 = _s3Ng::I64;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       c5IO: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 _c5IZ() //  [D1]
         { info_tbl: [(c5IZ,
                       label: block_c5IZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5IZ: // global
           D1 = %MO_F_Neg_W64(D1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.584511685 UTC

[section ""data" . GHC.Integer.Type.encodeFloat#_closure" {
     GHC.Integer.Type.encodeFloat#_closure:
         const GHC.Integer.Type.encodeFloat#_info;
 },
 GHC.Integer.Type.encodeFloat#_entry() //  [R2, R3]
         { info_tbl: [(c5Jk,
                       label: GHC.Integer.Type.encodeFloat#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Jk: // global
           _c5Jj::I64 = R3;
           (_s3Nr::F32) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeFloat(R2, _c5Jj::I64);
           F1 = _s3Nr::F32;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.585912171 UTC

[section ""data" . f1_r3Bw_closure" {
     f1_r3Bw_closure:
         const f1_r3Bw_info;
 },
 f1_r3Bw_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Jo: // global
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           F1 = F32[Sp];
           R1 = R1;
           Sp = Sp + 24;
           call f1_r3Bw_entry(R3, R2, F1, R1) args: 8, res: 0, upd: 8;
     }
 },
 f1_r3Bw_entry() //  [R2, R3, F1]
         { info_tbl: [(c5Jz,
                       label: f1_r3Bw_info
                       rep:HeapRep static {
                             Fun {arity: 3 fun_type: ArgGen [True, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Jz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c5JA; else goto u5JP;
       c5JA: // global
           R1 = f1_r3Bw_closure;
           F32[Sp - 24] = F1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       u5JP: // global
           F32[Sp - 24] = F1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _c5Jp() args: 0, res: 0, upd: 0;
     }
 },
 _c5Jp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Jp: // global
           I64[Sp - 8] = block_c5Js_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5JR; else goto c5Jt;
       u5JR: // global
           call _c5Js(R1) args: 0, res: 0, upd: 0;
       c5Jt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Js() //  [R1]
         { info_tbl: [(c5Js,
                       label: block_c5Js_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Js: // global
           _s3Ns::F32 = F32[Sp + 8];
           if (R1 & 7 == 1) goto c5Jw; else goto c5Jx;
       c5Jw: // global
           _s3Nu::I64 = I64[Sp + 24];
           _s3Nx::P64 = P64[R1 + 7];
           (_s3NB::F32) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeFloat(I64[R1 + 15], _s3Nu::I64);
           F32[Sp + 8] = %MO_F_Add_W32(_s3Ns::F32, _s3NB::F32);
           P64[Sp + 16] = _s3Nx::P64;
           I64[Sp + 24] = _s3Nu::I64 + 64;
           Sp = Sp + 8;
           call _c5Jp() args: 0, res: 0, upd: 0;
       c5Jx: // global
           F1 = _s3Ns::F32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.588105749 UTC

[section ""data" . GHC.Integer.Type.encodeFloatInteger_closure" {
     GHC.Integer.Type.encodeFloatInteger_closure:
         const GHC.Integer.Type.encodeFloatInteger_info;
 },
 GHC.Integer.Type.encodeFloatInteger_entry() //  [R2, R3]
         { info_tbl: [(c5K6,
                       label: GHC.Integer.Type.encodeFloatInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5K6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5K7; else goto c5K8;
       c5K7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.encodeFloatInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5K8: // global
           I64[Sp - 16] = block_c5JY_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5Ks; else goto c5JZ;
       u5Ks: // global
           call _c5JY(R1) args: 0, res: 0, upd: 0;
       c5JZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5JY() //  [R1]
         { info_tbl: [(c5JY,
                       label: block_c5JY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5JY: // global
           _c5K5::P64 = R1 & 7;
           if (_c5K5::P64 < 3) goto u5Kr; else goto c5K4;
       u5Kr: // global
           _s3NF::I64 = I64[Sp + 8];
           if (_c5K5::P64 < 2) goto c5K2; else goto c5K3;
       c5K2: // global
           R3 = _s3NF::I64;
           R2 = P64[R1 + 7];
           F1 = 0.0 :: W32;
           Sp = Sp + 16;
           call f1_r3Bw_entry(R3, R2, F1) args: 8, res: 0, upd: 8;
       c5K3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5Km; else goto c5Kl;
       c5Km: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Kl: // global
           _s3NI::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3NI::P64;
           I64[Sp + 8] = block_c5Kf_info;
           R3 = _s3NF::I64;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
       c5K4: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 _c5Kf() //  [F1]
         { info_tbl: [(c5Kf,
                       label: block_c5Kf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Kf: // global
           F1 = %MO_F_Neg_W32(F1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.590187338 UTC

[section ""data" . GHC.Integer.Type.Positive_closure" {
     GHC.Integer.Type.Positive_closure:
         const GHC.Integer.Type.Positive_info;
 },
 GHC.Integer.Type.Positive_entry() //  [R2]
         { info_tbl: [(c5Ky,
                       label: GHC.Integer.Type.Positive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ky: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5KC; else goto c5KB;
       c5KC: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Type.Positive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5KB: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.591650221 UTC

[section ""data" . GHC.Integer.Type.Negative_closure" {
     GHC.Integer.Type.Negative_closure:
         const GHC.Integer.Type.Negative_info;
 },
 GHC.Integer.Type.Negative_entry() //  [R2]
         { info_tbl: [(c5KI,
                       label: GHC.Integer.Type.Negative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5KI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5KM; else goto c5KL;
       c5KM: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Type.Negative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5KL: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.592532427 UTC

[section ""data" . GHC.Integer.Type.Naught_closure" {
     GHC.Integer.Type.Naught_closure:
         const GHC.Integer.Type.Naught_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.593410892 UTC

[section ""data" . GHC.Integer.Type.Nil_closure" {
     GHC.Integer.Type.Nil_closure:
         const GHC.Integer.Type.Nil_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.594258695 UTC

[section ""data" . GHC.Integer.Type.Cons_closure" {
     GHC.Integer.Type.Cons_closure:
         const GHC.Integer.Type.Cons_info;
 },
 GHC.Integer.Type.Cons_entry() //  [R2, R3]
         { info_tbl: [(c5KS,
                       label: GHC.Integer.Type.Cons_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5KS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5KW; else goto c5KV;
       c5KW: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.Cons_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5KV: // global
           I64[Hp - 16] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.595536597 UTC

[section ""data" . GHC.Integer.Type.Some_closure" {
     GHC.Integer.Type.Some_closure:
         const GHC.Integer.Type.Some_info;
 },
 GHC.Integer.Type.Some_entry() //  [R2, R3]
         { info_tbl: [(c5L2,
                       label: GHC.Integer.Type.Some_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5L2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5L6; else goto c5L5;
       c5L6: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.Some_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5L5: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R3;
           I64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.596430875 UTC

[section ""data" . GHC.Integer.Type.None_closure" {
     GHC.Integer.Type.None_closure:
         const GHC.Integer.Type.None_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.597178728 UTC

[GHC.Integer.Type.Positive_con_entry() //  [R1]
         { info_tbl: [(c5L7,
                       label: GHC.Integer.Type.Positive_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,80,111,115,105,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5L7: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.598015103 UTC

[GHC.Integer.Type.Negative_con_entry() //  [R1]
         { info_tbl: [(c5L9,
                       label: GHC.Integer.Type.Negative_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,101,103,97,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5L9: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.599003277 UTC

[GHC.Integer.Type.Naught_con_entry() //  [R1]
         { info_tbl: [(c5Lb,
                       label: GHC.Integer.Type.Naught_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,97,117,103,104,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Lb: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.599783878 UTC

[GHC.Integer.Type.Nil_con_entry() //  [R1]
         { info_tbl: [(c5Ld,
                       label: GHC.Integer.Type.Nil_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,105,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ld: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.600769047 UTC

[GHC.Integer.Type.Cons_con_entry() //  [R1]
         { info_tbl: [(c5Lf,
                       label: GHC.Integer.Type.Cons_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 1
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,67,111,110,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Lf: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.601691131 UTC

[GHC.Integer.Type.Some_con_entry() //  [R1]
         { info_tbl: [(c5Lh,
                       label: GHC.Integer.Type.Some_con_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,83,111,109,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Lh: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.602698399 UTC

[GHC.Integer.Type.None_con_entry() //  [R1]
         { info_tbl: [(c5Lj,
                       label: GHC.Integer.Type.None_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,111,110,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Lj: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.603543412 UTC

[section ""relreadonly" . S3Xx_srt" {
     S3Xx_srt:
         const GHC.Integer.Type.plusPositive_addWithCarry_closure;
         const lvl_r3Bo_closure;
         const GHC.Integer.Type.timesDigit_closure;
         const GHC.Integer.Type.timesPositive_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const GHC.Integer.Type.complementInteger_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Integer.Type.modInteger_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.604693359 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:53:49.606528973 UTC

[section ""data" . GHC.Integer.Type.$WPositive_closure" {
     GHC.Integer.Type.$WPositive_closure:
         const GHC.Integer.Type.$WPositive_info;
 },
 GHC.Integer.Type.$WPositive_entry() //  [R2]
         { info_tbl: [(c5Ls,
                       label: GHC.Integer.Type.$WPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ls: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5Lw; else goto c5Lx;
       c5Lw: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$WPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Lx: // global
           I64[Sp - 8] = block_c5Lp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5LB; else goto c5Lq;
       u5LB: // global
           call _c5Lp(R1) args: 0, res: 0, upd: 0;
       c5Lq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Lp() //  [R1]
         { info_tbl: [(c5Lp,
                       label: block_c5Lp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Lp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5LA; else goto c5Lz;
       c5LA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Lz: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.614869323 UTC

[section ""data" . GHC.Integer.Type.$WNegative_closure" {
     GHC.Integer.Type.$WNegative_closure:
         const GHC.Integer.Type.$WNegative_info;
 },
 GHC.Integer.Type.$WNegative_entry() //  [R2]
         { info_tbl: [(c5LT,
                       label: GHC.Integer.Type.$WNegative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5LT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5LX; else goto c5LY;
       c5LX: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$WNegative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5LY: // global
           I64[Sp - 8] = block_c5LQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5M2; else goto c5LR;
       u5M2: // global
           call _c5LQ(R1) args: 0, res: 0, upd: 0;
       c5LR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5LQ() //  [R1]
         { info_tbl: [(c5LQ,
                       label: block_c5LQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5LQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5M1; else goto c5M0;
       c5M1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5M0: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.622275503 UTC

[section ""data" . GHC.Integer.Type.$WSome_closure" {
     GHC.Integer.Type.$WSome_closure:
         const GHC.Integer.Type.$WSome_info;
 },
 GHC.Integer.Type.$WSome_entry() //  [R2, R3]
         { info_tbl: [(c5Mk,
                       label: GHC.Integer.Type.$WSome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Mk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5Mo; else goto c5Mp;
       c5Mo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$WSome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5Mp: // global
           I64[Sp - 16] = block_c5Mh_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5Mt; else goto c5Mi;
       u5Mt: // global
           call _c5Mh(R1) args: 0, res: 0, upd: 0;
       c5Mi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Mh() //  [R1]
         { info_tbl: [(c5Mh,
                       label: block_c5Mh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Mh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Ms; else goto c5Mr;
       c5Ms: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Mr: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.6300103 UTC

[section ""data" . GHC.Integer.Type.errorPositive_closure" {
     GHC.Integer.Type.errorPositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 47;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.632046703 UTC

[section ""data" . GHC.Integer.Type.errorInteger_closure" {
     GHC.Integer.Type.errorInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.errorPositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.634743402 UTC

[section ""data" . GHC.Integer.Type.wordToInteger_closure" {
     GHC.Integer.Type.wordToInteger_closure:
         const GHC.Integer.Type.wordToInteger_info;
 },
 GHC.Integer.Type.wordToInteger_entry() //  [R2]
         { info_tbl: [(c5MP,
                       label: GHC.Integer.Type.wordToInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5MP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c5MT; else goto c5MS;
       c5MT: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Integer.Type.wordToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5MS: // global
           if (R2 == 0) goto c5MO; else goto c5MN;
       c5MO: // global
           Hp = Hp - 40;
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5MN: // global
           I64[Hp - 32] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 24] = GHC.Integer.Type.None_closure+2;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.640501751 UTC

[section ""data" . GHC.Integer.Type.integerToWord_closure" {
     GHC.Integer.Type.integerToWord_closure:
         const GHC.Integer.Type.integerToWord_info;
 },
 GHC.Integer.Type.integerToWord_entry() //  [R2]
         { info_tbl: [(c5Ng,
                       label: GHC.Integer.Type.integerToWord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ng: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5Nh; else goto c5Ni;
       c5Nh: // global
           R2 = R2;
           R1 = GHC.Integer.Type.integerToWord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Ni: // global
           I64[Sp - 8] = block_c5N8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5O0; else goto c5N9;
       u5O0: // global
           call _c5N8(R1) args: 0, res: 0, upd: 0;
       c5N9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5N8() //  [R1]
         { info_tbl: [(c5N8,
                       label: block_c5N8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5N8: // global
           _c5Nf::P64 = R1 & 7;
           if (_c5Nf::P64 < 3) goto u5NT; else goto u5NU;
       u5NT: // global
           if (_c5Nf::P64 < 2) goto c5Nc; else goto c5Nd;
       c5Nc: // global
           I64[Sp] = block_c5Nl_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u5NX; else goto c5Nn;
       u5NX: // global
           call _c5Nl(R1) args: 0, res: 0, upd: 0;
       c5Nn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5Nd: // global
           I64[Sp] = block_c5NA_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u5NY; else goto c5NC;
       u5NY: // global
           call _c5NA(R1) args: 0, res: 0, upd: 0;
       c5NC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u5NU: // global
           Sp = Sp + 8;
           call _c5Ne() args: 0, res: 0, upd: 0;
     }
 },
 _c5Nl() //  [R1]
         { info_tbl: [(c5Nl,
                       label: block_c5Nl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Nl: // global
           if (R1 & 7 == 1) goto c5Nt; else goto u5NV;
       c5Nt: // global
           R1 = I64[R1 + 15];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u5NV: // global
           Sp = Sp + 8;
           call _c5Ne() args: 0, res: 0, upd: 0;
     }
 },
 _c5NA() //  [R1]
         { info_tbl: [(c5NA,
                       label: block_c5NA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5NA: // global
           if (R1 & 7 == 1) goto c5NJ; else goto u5NW;
       c5NJ: // global
           R1 = 0 - I64[R1 + 15];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u5NW: // global
           Sp = Sp + 8;
           call _c5Ne() args: 0, res: 0, upd: 0;
     }
 },
 _c5Ne() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ne: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.652921777 UTC

[section ""data" . GHC.Integer.Type.integerToInt_closure" {
     GHC.Integer.Type.integerToInt_closure:
         const GHC.Integer.Type.integerToInt_info;
 },
 GHC.Integer.Type.integerToInt_entry() //  [R2]
         { info_tbl: [(c5OC,
                       label: GHC.Integer.Type.integerToInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5OC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5OG; else goto c5OH;
       c5OG: // global
           R2 = R2;
           R1 = GHC.Integer.Type.integerToInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5OH: // global
           I64[Sp - 8] = block_c5OA_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5OA() //  [R1]
         { info_tbl: [(c5OA,
                       label: block_c5OA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5OA: // global
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.659766026 UTC

[section ""data" . GHC.Integer.Type.hashInteger_closure" {
     GHC.Integer.Type.hashInteger_closure:
         const GHC.Integer.Type.hashInteger_info;
 },
 GHC.Integer.Type.hashInteger_entry() //  [R2]
         { info_tbl: [(c5OW,
                       label: GHC.Integer.Type.hashInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5OW: // global
           R2 = R2;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.664369314 UTC

[section ""data" . GHC.Integer.Type.flipBitsDigits_closure" {
     GHC.Integer.Type.flipBitsDigits_closure:
         const GHC.Integer.Type.flipBitsDigits_info;
 },
 GHC.Integer.Type.flipBitsDigits_entry() //  [R2]
         { info_tbl: [(c5Pe,
                       label: GHC.Integer.Type.flipBitsDigits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Pe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5Pf; else goto c5Pg;
       c5Pf: // global
           R2 = R2;
           R1 = GHC.Integer.Type.flipBitsDigits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Pg: // global
           I64[Sp - 8] = block_c5P7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5Py; else goto c5P8;
       u5Py: // global
           call _c5P7(R1) args: 0, res: 0, upd: 0;
       c5P8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5P7() //  [R1]
         { info_tbl: [(c5P7,
                       label: block_c5P7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5P7: // global
           if (R1 & 7 == 1) goto c5Pb; else goto c5Pc;
       c5Pb: // global
           I64[Sp - 8] = block_c5Pj_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
       c5Pc: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5Pj() //  [R1]
         { info_tbl: [(c5Pj,
                       label: block_c5Pj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Pj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Pu; else goto c5Pt;
       c5Pu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Pt: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = ~I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.673539989 UTC

[section ""data" . GHC.Integer.Type.flipBits1_closure" {
     GHC.Integer.Type.flipBits1_closure:
         const GHC.Integer.Type.flipBits1_info;
 },
 GHC.Integer.Type.flipBits1_entry() //  [R2]
         { info_tbl: [(c5PV,
                       label: GHC.Integer.Type.flipBits1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5PV: // global
           R2 = R2;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.677664107 UTC

[section ""data" . GHC.Integer.Type.flipBits_closure" {
     GHC.Integer.Type.flipBits_closure:
         const GHC.Integer.Type.flipBits_info;
 },
 GHC.Integer.Type.flipBits_entry() //  [R2]
         { info_tbl: [(c5Q6,
                       label: GHC.Integer.Type.flipBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Q6: // global
           R2 = R2;
           call GHC.Integer.Type.flipBits1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.682514667 UTC

[section ""data" . GHC.Integer.Type.negateInteger_closure" {
     GHC.Integer.Type.negateInteger_closure:
         const GHC.Integer.Type.negateInteger_info;
 },
 GHC.Integer.Type.negateInteger_entry() //  [R2]
         { info_tbl: [(c5Qp,
                       label: GHC.Integer.Type.negateInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Qp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5Qq; else goto c5Qr;
       c5Qq: // global
           R2 = R2;
           R1 = GHC.Integer.Type.negateInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Qr: // global
           I64[Sp - 8] = block_c5Qh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5QI; else goto c5Qi;
       u5QI: // global
           call _c5Qh(R1) args: 0, res: 0, upd: 0;
       c5Qi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Qh() //  [R1]
         { info_tbl: [(c5Qh,
                       label: block_c5Qh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Qh: // global
           _c5Qo::P64 = R1 & 7;
           if (_c5Qo::P64 < 3) goto u5QH; else goto c5Qn;
       u5QH: // global
           if (_c5Qo::P64 < 2) goto c5Ql; else goto c5Qm;
       c5Ql: // global
           Hp = Hp + 16;
           _s3C2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c5QD; else goto c5Qw;
       c5Qw: // global
           _s3C3::P64 = P64[_s3C2::P64 + 7];
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = _s3C3::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5Qm: // global
           Hp = Hp + 16;
           _s3C2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c5QD; else goto c5QC;
       c5QD: // global
           HpAlloc = 16;
           R1 = _s3C2::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5QC: // global
           _s3C4::P64 = P64[_s3C2::P64 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3C4::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5Qn: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.690914199 UTC

[section ""data" . GHC.Integer.Type.smallInteger_closure" {
     GHC.Integer.Type.smallInteger_closure:
         const GHC.Integer.Type.smallInteger_info;
 },
 GHC.Integer.Type.smallInteger_entry() //  [R2]
         { info_tbl: [(c5R5,
                       label: GHC.Integer.Type.smallInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5R5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5R6; else goto c5R7;
       c5R6: // global
           R2 = R2;
           R1 = GHC.Integer.Type.smallInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5R7: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c5R3; else goto c5R4;
       c5R3: // global
           I64[Sp - 8] = block_c5Rf_info;
           R2 = -R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c5R4: // global
           R2 = R2;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c5Rf() //  [R1]
         { info_tbl: [(c5Rf,
                       label: block_c5Rf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Rf: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.698028475 UTC

[section ""data" . GHC.Integer.Type.decodeFloatInteger_closure" {
     GHC.Integer.Type.decodeFloatInteger_closure:
         const GHC.Integer.Type.decodeFloatInteger_info;
 },
 sat_s3Cf_entry() //  [R1]
         { info_tbl: [(c5RG,
                       label: sat_s3Cf_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5RG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5RH; else goto c5RI;
       c5RH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5RI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.decodeFloatInteger_entry() //  [F1]
         { info_tbl: [(c5RJ,
                       label: GHC.Integer.Type.decodeFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 6} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5RJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5RK; else goto c5RL;
       c5RK: // global
           F1 = F1;
           R1 = GHC.Integer.Type.decodeFloatInteger_closure;
           call (stg_gc_fun)(F1, R1) args: 8, res: 0, upd: 8;
       c5RL: // global
           I64[Sp - 8] = block_c5Ry_info;
           F1 = F1;
           Sp = Sp - 8;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Ry() //  [R1, R2]
         { info_tbl: [(c5Ry,
                       label: block_c5Ry_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ry: // global
           I64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5Rz() args: 0, res: 0, upd: 0;
     }
 },
 _c5Rz() //  []
         { info_tbl: [(c5Rz,
                       label: block_c5Rz_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Rz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5RO; else goto c5RN;
       c5RO: // global
           HpAlloc = 24;
           I64[Sp] = block_c5Rz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5RN: // global
           I64[Hp - 16] = sat_s3Cf_info;
           I64[Hp] = I64[Sp + 16];
           R2 = I64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.709157661 UTC

[section ""data" . GHC.Integer.Type.absInteger_closure" {
     GHC.Integer.Type.absInteger_closure:
         const GHC.Integer.Type.absInteger_info;
 },
 GHC.Integer.Type.absInteger_entry() //  [R2]
         { info_tbl: [(c5Sj,
                       label: GHC.Integer.Type.absInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Sj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5Sk; else goto c5Sl;
       c5Sk: // global
           R2 = R2;
           R1 = GHC.Integer.Type.absInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Sl: // global
           I64[Sp - 8] = block_c5Sc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5Sv; else goto c5Sd;
       u5Sv: // global
           call _c5Sc(R1) args: 0, res: 0, upd: 0;
       c5Sd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Sc() //  [R1]
         { info_tbl: [(c5Sc,
                       label: block_c5Sc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Sc: // global
           if (R1 & 7 == 2) goto c5Sh; else goto c5Sg;
       c5Sh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5Su; else goto c5St;
       c5Su: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5St: // global
           _s3Ci::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3Ci::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5Sg: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.716058763 UTC

[section ""data" . GHC.Integer.Type.onePositive_closure" {
     GHC.Integer.Type.onePositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.718739029 UTC

[section ""data" . GHC.Integer.Type.negativeOneInteger_closure" {
     GHC.Integer.Type.negativeOneInteger_closure:
         const GHC.Integer.Type.Negative_con_info;
         const GHC.Integer.Type.onePositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.720978418 UTC

[section ""data" . GHC.Integer.Type.oneInteger_closure" {
     GHC.Integer.Type.oneInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.onePositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.723519254 UTC

[section ""data" . GHC.Integer.Type.signumInteger_closure" {
     GHC.Integer.Type.signumInteger_closure:
         const GHC.Integer.Type.signumInteger_info;
 },
 GHC.Integer.Type.signumInteger_entry() //  [R2]
         { info_tbl: [(c5SZ,
                       label: GHC.Integer.Type.signumInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5SZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5T0; else goto c5T1;
       c5T0: // global
           R2 = R2;
           R1 = GHC.Integer.Type.signumInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5T1: // global
           I64[Sp - 8] = block_c5SR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5Tc; else goto c5SS;
       u5Tc: // global
           call _c5SR(R1) args: 0, res: 0, upd: 0;
       c5SS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5SR() //  [R1]
         { info_tbl: [(c5SR,
                       label: block_c5SR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5SR: // global
           _c5SY::P64 = R1 & 7;
           if (_c5SY::P64 < 3) goto u5Tb; else goto c5SX;
       u5Tb: // global
           if (_c5SY::P64 < 2) goto c5SV; else goto c5SW;
       c5SV: // global
           R1 = GHC.Integer.Type.oneInteger_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5SW: // global
           R1 = GHC.Integer.Type.negativeOneInteger_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5SX: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.730528545 UTC

[section ""data" . GHC.Integer.Type.halfBoundUp_closure" {
     GHC.Integer.Type.halfBoundUp_closure:
         const GHC.Integer.Type.halfBoundUp_info;
 },
 GHC.Integer.Type.halfBoundUp_entry() //  [R2]
         { info_tbl: [(c5Tx,
                       label: GHC.Integer.Type.halfBoundUp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Tx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5Ty; else goto c5Tz;
       c5Ty: // global
           R2 = R2;
           R1 = GHC.Integer.Type.halfBoundUp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Tz: // global
           I64[Sp - 8] = block_c5Tu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5TD; else goto c5Tv;
       u5TD: // global
           call _c5Tu() args: 0, res: 0, upd: 0;
       c5Tv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Tu() //  []
         { info_tbl: [(c5Tu,
                       label: block_c5Tu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Tu: // global
           R1 = 9223372036854775808;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.737657118 UTC

[section ""data" . GHC.Integer.Type.fullBound_closure" {
     GHC.Integer.Type.fullBound_closure:
         const GHC.Integer.Type.fullBound_info;
 },
 GHC.Integer.Type.fullBound_entry() //  [R2]
         { info_tbl: [(c5TV,
                       label: GHC.Integer.Type.fullBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5TV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5TW; else goto c5TX;
       c5TW: // global
           R2 = R2;
           R1 = GHC.Integer.Type.fullBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5TX: // global
           I64[Sp - 8] = block_c5TS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5U1; else goto c5TT;
       u5U1: // global
           call _c5TS() args: 0, res: 0, upd: 0;
       c5TT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5TS() //  []
         { info_tbl: [(c5TS,
                       label: block_c5TS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5TS: // global
           R1 = 18446744073709551615;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.744611377 UTC

[section ""data" . GHC.Integer.Type.$wsuccPositive_closure" {
     GHC.Integer.Type.$wsuccPositive_closure:
         const GHC.Integer.Type.$wsuccPositive_info;
 },
 GHC.Integer.Type.$wsuccPositive_entry() //  [R2]
         { info_tbl: [(c5Un,
                       label: GHC.Integer.Type.$wsuccPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Un: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5Uo; else goto c5Up;
       c5Uo: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$wsuccPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Up: // global
           I64[Sp - 8] = block_c5Ug_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5UM; else goto c5Uh;
       u5UM: // global
           call _c5Ug(R1) args: 0, res: 0, upd: 0;
       c5Uh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Ug() //  [R1]
         { info_tbl: [(c5Ug,
                       label: block_c5Ug_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ug: // global
           if (R1 & 7 == 1) goto c5Uk; else goto c5Ul;
       c5Uk: // global
           _s3Cu::P64 = P64[R1 + 7];
           _s3Cv::I64 = I64[R1 + 15];
           if (_s3Cv::I64 != 18446744073709551615) goto c5Uv; else goto c5UD;
       c5Uv: // global
           R2 = _s3Cu::P64;
           R1 = _s3Cv::I64 + 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c5UD: // global
           I64[Sp] = block_c5Uy_info;
           R2 = _s3Cu::P64;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
       c5Ul: // global
           R2 = GHC.Integer.Type.None_closure+2;
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5Uy() //  [R1, R2]
         { info_tbl: [(c5Uy,
                       label: block_c5Uy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Uy: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5Uz() args: 0, res: 0, upd: 0;
     }
 },
 _c5Uz() //  []
         { info_tbl: [(c5Uz,
                       label: block_c5Uz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Uz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5UG; else goto c5UF;
       c5UG: // global
           HpAlloc = 24;
           I64[Sp] = block_c5Uz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5UF: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = Hp - 15;
           R1 = 0;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.757170766 UTC

[section ""data" . GHC.Integer.Type.succPositive_closure" {
     GHC.Integer.Type.succPositive_closure:
         const GHC.Integer.Type.succPositive_info;
 },
 GHC.Integer.Type.succPositive_entry() //  [R2]
         { info_tbl: [(c5Vj,
                       label: GHC.Integer.Type.succPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Vj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5Vk; else goto c5Vl;
       c5Vk: // global
           R2 = R2;
           R1 = GHC.Integer.Type.succPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Vl: // global
           I64[Sp - 8] = block_c5Ve_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5Ve() //  [R1, R2]
         { info_tbl: [(c5Ve,
                       label: block_c5Ve_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Ve: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5Vf() args: 0, res: 0, upd: 0;
     }
 },
 _c5Vf() //  []
         { info_tbl: [(c5Vf,
                       label: block_c5Vf_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Vf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Vo; else goto c5Vn;
       c5Vo: // global
           HpAlloc = 24;
           I64[Sp] = block_c5Vf_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5Vn: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.766337725 UTC

[section ""data" . lvl_r3Bo_closure" {
     lvl_r3Bo_closure:
         const lvl_r3Bo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r3Bo_entry() //  [R1]
         { info_tbl: [(c5VQ,
                       label: lvl_r3Bo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5VQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c5VR; else goto c5VS;
       c5VR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5VS: // global
           (_c5VI::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c5VI::I64 == 0) goto c5VK; else goto c5VJ;
       c5VK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c5VJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c5VI::I64;
           I64[Sp - 24] = block_c5VL_info;
           R2 = GHC.Integer.Type.None_closure+2;
           Sp = Sp - 24;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c5VL() //  [R1, R2]
         { info_tbl: [(c5VL,
                       label: block_c5VL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5VL: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5VM() args: 0, res: 0, upd: 0;
     }
 },
 _c5VM() //  []
         { info_tbl: [(c5VM,
                       label: block_c5VM_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5VM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5VV; else goto c5VU;
       c5VV: // global
           HpAlloc = 24;
           I64[Sp] = block_c5VM_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c5VU: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.77711433 UTC

[section ""data" . GHC.Integer.Type.plusPositive_addWithCarry_closure" {
     GHC.Integer.Type.plusPositive_addWithCarry_closure:
         const GHC.Integer.Type.plusPositive_addWithCarry_info;
         const 0;
 },
 GHC.Integer.Type.plusPositive_addWithCarry_entry() //  [R2, R3, R4]
         { info_tbl: [(c5Wp,
                       label: GHC.Integer.Type.plusPositive_addWithCarry_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Wp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c5Wq; else goto u5YW;
       c5Wq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.plusPositive_addWithCarry_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u5YW: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c5Wf() args: 0, res: 0, upd: 0;
     }
 },
 _c5Wf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Wf: // global
           I64[Sp - 8] = block_c5Wi_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5Z0; else goto c5Wj;
       u5Z0: // global
           call _c5Wi(R1) args: 0, res: 0, upd: 0;
       c5Wj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Wi() //  [R1]
         { info_tbl: [(c5Wi,
                       label: block_c5Wi_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Wi: // global
           _s3CK::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c5Wm; else goto c5Wn;
       c5Wm: // global
           I64[Sp - 8] = block_c5Wu_info;
           _s3CL::P64 = R1;
           _s3CN::P64 = P64[R1 + 7];
           _s3CM::I64 = I64[R1 + 15];
           R1 = _s3CK::P64;
           P64[Sp] = _s3CN::P64;
           I64[Sp + 16] = _s3CM::I64;
           P64[Sp + 24] = _s3CL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5Z1; else goto c5Ww;
       u5Z1: // global
           call _c5Wu(R1) args: 0, res: 0, upd: 0;
       c5Ww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5Wn: // global
           I64[Sp] = block_c5Yq_info;
           R1 = _s3CK::P64;
           if (R1 & 7 != 0) goto u5Z2; else goto c5Ys;
       u5Z2: // global
           call _c5Yq(R1) args: 0, res: 0, upd: 0;
       c5Ys: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Wu() //  [R1]
         { info_tbl: [(c5Wu,
                       label: block_c5Wu_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Wu: // global
           _s3CI::I64 = I64[Sp + 16];
           _s3CL::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c5Y6; else goto c5Yn;
       c5Y6: // global
           _s3CM::I64 = I64[Sp + 24];
           _s3CP::I64 = I64[R1 + 15];
           if (_s3CM::I64 >= _s3CP::I64) goto c5Y3; else goto c5Y4;
       c5Y3: // global
           _s3CN::P64 = P64[Sp + 8];
           _s3CQ::P64 = P64[R1 + 7];
           if (_s3CP::I64 < 9223372036854775808) goto c5XF; else goto c5XY;
       c5XF: // global
           if (_s3CM::I64 < 9223372036854775808) goto c5WW; else goto c5XD;
       c5WW: // global
           I64[Sp + 8] = block_c5WK_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 0;
           I64[Sp + 32] = _s3CP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c5XD: // global
           _s3CX::I64 = (_s3CM::I64 + -9223372036854775808) + (_s3CP::I64 + _s3CI::I64);
           if (_s3CX::I64 >= 9223372036854775808) goto c5Xm; else goto c5Xz;
       c5Xm: // global
           I64[Sp + 24] = block_c5Xd_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 1;
           I64[Sp + 32] = _s3CX::I64;
           Sp = Sp + 24;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c5Xz: // global
           I64[Sp + 24] = block_c5Xr_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 0;
           I64[Sp + 32] = _s3CX::I64;
           Sp = Sp + 24;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c5XY: // global
           I64[Sp + 8] = block_c5XH_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 1;
           I64[Sp + 32] = _s3CP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c5Y4: // global
           I64[Sp + 16] = _s3CI::I64;
           P64[Sp + 24] = R1;
           P64[Sp + 32] = _s3CL::P64;
           Sp = Sp + 16;
           call _c5Wf() args: 0, res: 0, upd: 0;
       c5Yn: // global
           if (_s3CI::I64 == 0) goto c5Ym; else goto c5Yi;
       c5Ym: // global
           R1 = _s3CL::P64 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c5Yi: // global
           I64[Sp + 32] = block_c5Yc_info;
           R2 = _s3CL::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5WK() //  [R1]
         { info_tbl: [(c5WK,
                       label: block_c5WK_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5WK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5WZ; else goto c5WY;
       c5WZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5WY: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] + (I64[Sp + 24] + I64[Sp + 8]);
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5Xd() //  [R1]
         { info_tbl: [(c5Xd,
                       label: block_c5Xd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Xd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Xp; else goto c5Xo;
       c5Xp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Xo: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - 9223372036854775808;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5Xr() //  [R1]
         { info_tbl: [(c5Xr,
                       label: block_c5Xr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Xr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5XC; else goto c5XB;
       c5XC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5XB: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - 9223372036854775808;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5XH() //  [R1]
         { info_tbl: [(c5XH,
                       label: block_c5XH_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5XH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Y1; else goto c5Y0;
       c5Y1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Y0: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] + (I64[Sp + 24] + I64[Sp + 8]);
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5Yc() //  [R1, R2]
         { info_tbl: [(c5Yc,
                       label: block_c5Yc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Yc: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5Yd() args: 0, res: 0, upd: 0;
     }
 },
 _c5Yd() //  []
         { info_tbl: [(c5Yd,
                       label: block_c5Yd_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Yd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Yl; else goto c5Yk;
       c5Yl: // global
           HpAlloc = 24;
           I64[Sp] = block_c5Yd_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5Yk: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5Yq() //  [R1]
         { info_tbl: [(c5Yq,
                       label: block_c5Yq_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Yq: // global
           _s3CI::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c5YL; else goto c5YT;
       c5YL: // global
           if (_s3CI::I64 == 0) goto c5YJ; else goto c5YF;
       c5YJ: // global
           R1 = R1 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c5YF: // global
           I64[Sp + 24] = block_c5Yz_info;
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
       c5YT: // global
           if (_s3CI::I64 == 0) goto c5YS; else goto c5YR;
       c5YS: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5YR: // global
           R1 = lvl_r3Bo_closure;
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c5Yz() //  [R1, R2]
         { info_tbl: [(c5Yz,
                       label: block_c5Yz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5Yz: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5YA() args: 0, res: 0, upd: 0;
     }
 },
 _c5YA() //  []
         { info_tbl: [(c5YA,
                       label: block_c5YA_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5YA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5YI; else goto c5YH;
       c5YI: // global
           HpAlloc = 24;
           I64[Sp] = block_c5YA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5YH: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.811169412 UTC

[section ""data" . GHC.Integer.Type.plusPositive_closure" {
     GHC.Integer.Type.plusPositive_closure:
         const GHC.Integer.Type.plusPositive_info;
         const 0;
 },
 GHC.Integer.Type.plusPositive_entry() //  [R2, R3]
         { info_tbl: [(c60A,
                       label: GHC.Integer.Type.plusPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c60A: // global
           R4 = R3;
           R3 = R2;
           R2 = 0;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.817496634 UTC

[section ""data" . GHC.Integer.Type.minusPositive_closure" {
     GHC.Integer.Type.minusPositive_closure:
         const GHC.Integer.Type.minusPositive_info;
 },
 GHC.Integer.Type.minusPositive_entry() //  [R2, R3]
         { info_tbl: [(c60S,
                       label: GHC.Integer.Type.minusPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c60S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c60T; else goto c60U;
       c60T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.minusPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c60U: // global
           I64[Sp - 16] = block_c60L_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u62v; else goto c60M;
       u62v: // global
           call _c60L(R1) args: 0, res: 0, upd: 0;
       c60M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c60L() //  [R1]
         { info_tbl: [(c60L,
                       label: block_c60L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c60L: // global
           _s3Dp::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c60P; else goto c60Q;
       c60P: // global
           I64[Sp - 16] = block_c60X_info;
           _s3Dq::P64 = R1;
           _s3Ds::P64 = P64[R1 + 7];
           _s3Dr::I64 = I64[R1 + 15];
           R1 = _s3Dp::P64;
           P64[Sp - 8] = _s3Ds::P64;
           I64[Sp] = _s3Dr::I64;
           P64[Sp + 8] = _s3Dq::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u62t; else goto c60Z;
       u62t: // global
           call _c60X(R1) args: 0, res: 0, upd: 0;
       c60Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c60Q: // global
           I64[Sp + 8] = block_c62b_info;
           R1 = _s3Dp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u62u; else goto c62d;
       u62u: // global
           call _c62b(R1) args: 0, res: 0, upd: 0;
       c62d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c60X() //  [R1]
         { info_tbl: [(c60X,
                       label: block_c60X_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c60X: // global
           if (R1 & 7 == 1) goto c624; else goto c628;
       c624: // global
           _s3Dr::I64 = I64[Sp + 16];
           _s3Ds::P64 = P64[Sp + 8];
           _s3Dv::P64 = P64[R1 + 7];
           _s3Du::I64 = I64[R1 + 15];
           if (_s3Dr::I64 == _s3Du::I64) goto c61P; else goto c61M;
       c61P: // global
           I64[Sp + 24] = block_c61O_info;
           R3 = _s3Dv::P64;
           R2 = _s3Ds::P64;
           Sp = Sp + 24;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c61M: // global
           if (_s3Dr::I64 <= _s3Du::I64) goto c61t; else goto c61H;
       c61t: // global
           I64[Sp + 8] = block_c61a_info;
           R3 = _s3Dv::P64;
           R2 = _s3Ds::P64;
           I64[Sp + 24] = _s3Du::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c61H: // global
           I64[Sp + 8] = block_c61z_info;
           R3 = _s3Dv::P64;
           R2 = _s3Ds::P64;
           I64[Sp + 24] = _s3Du::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c628: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c61O() //  [R1]
         { info_tbl: [(c61O,
                       label: block_c61O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c61O: // global
           if (R1 & 7 == 1) goto c61V; else goto u62s;
       c61V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c61Y; else goto c61X;
       c61Y: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c61X: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u62s: // global
           Sp = Sp + 8;
           call _c62n() args: 0, res: 0, upd: 0;
     }
 },
 _c61a() //  [R1]
         { info_tbl: [(c61a,
                       label: block_c61a_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c61a: // global
           I64[Sp] = block_c61e_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = R1;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c61e() //  [R1]
         { info_tbl: [(c61e,
                       label: block_c61e_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c61e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c61x; else goto c61w;
       c61x: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c61w: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 18446744073709551615 - I64[Sp + 16] + (I64[Sp + 8] + 1);
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c61z() //  [R1]
         { info_tbl: [(c61z,
                       label: block_c61z_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c61z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c61K; else goto c61J;
       c61K: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c61J: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c62b() //  [R1]
         { info_tbl: [(c62b,
                       label: block_c62b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c62b: // global
           if (R1 & 7 == 1) goto c62j; else goto u62r;
       c62j: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u62r: // global
           Sp = Sp + 8;
           call _c62n() args: 0, res: 0, upd: 0;
     }
 },
 _c62n() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c62n: // global
           R1 = GHC.Integer.Type.None_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.838633712 UTC

[section ""data" . GHC.Integer.Type.twosComplementPositive1_closure" {
     GHC.Integer.Type.twosComplementPositive1_closure:
         const GHC.Integer.Type.twosComplementPositive1_info;
 },
 GHC.Integer.Type.twosComplementPositive1_entry() //  [R2]
         { info_tbl: [(c63v,
                       label: GHC.Integer.Type.twosComplementPositive1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c63v: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c63w; else goto c63x;
       c63w: // global
           R2 = R2;
           R1 = GHC.Integer.Type.twosComplementPositive1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c63x: // global
           I64[Sp - 8] = block_c63t_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c63t() //  [R1]
         { info_tbl: [(c63t,
                       label: block_c63t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c63t: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.844866111 UTC

[section ""data" . GHC.Integer.Type.twosComplementPositive_closure" {
     GHC.Integer.Type.twosComplementPositive_closure:
         const GHC.Integer.Type.twosComplementPositive_info;
 },
 GHC.Integer.Type.twosComplementPositive_entry() //  [R2]
         { info_tbl: [(c63N,
                       label: GHC.Integer.Type.twosComplementPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c63N: // global
           R2 = R2;
           call GHC.Integer.Type.twosComplementPositive1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.849353524 UTC

[section ""data" . GHC.Integer.Type.lowHalfMask_closure" {
     GHC.Integer.Type.lowHalfMask_closure:
         const GHC.Integer.Type.lowHalfMask_info;
 },
 GHC.Integer.Type.lowHalfMask_entry() //  [R2]
         { info_tbl: [(c641,
                       label: GHC.Integer.Type.lowHalfMask_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c641: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c642; else goto c643;
       c642: // global
           R2 = R2;
           R1 = GHC.Integer.Type.lowHalfMask_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c643: // global
           I64[Sp - 8] = block_c63Y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u647; else goto c63Z;
       u647: // global
           call _c63Y() args: 0, res: 0, upd: 0;
       c63Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c63Y() //  []
         { info_tbl: [(c63Y,
                       label: block_c63Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c63Y: // global
           R1 = 4294967295;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.85581823 UTC

[section ""data" . GHC.Integer.Type.highHalfShift_closure" {
     GHC.Integer.Type.highHalfShift_closure:
         const GHC.Integer.Type.highHalfShift_info;
 },
 GHC.Integer.Type.highHalfShift_entry() //  [R2]
         { info_tbl: [(c64p,
                       label: GHC.Integer.Type.highHalfShift_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c64p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c64q; else goto c64r;
       c64q: // global
           R2 = R2;
           R1 = GHC.Integer.Type.highHalfShift_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c64r: // global
           I64[Sp - 8] = block_c64m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u64v; else goto c64n;
       u64v: // global
           call _c64m() args: 0, res: 0, upd: 0;
       c64n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c64m() //  []
         { info_tbl: [(c64m,
                       label: block_c64m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c64m: // global
           R1 = 32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.862423398 UTC

[section ""data" . GHC.Integer.Type.splitHalves_closure" {
     GHC.Integer.Type.splitHalves_closure:
         const GHC.Integer.Type.splitHalves_info;
 },
 GHC.Integer.Type.splitHalves_entry() //  [R2]
         { info_tbl: [(c64M,
                       label: GHC.Integer.Type.splitHalves_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c64M: // global
           _s3DS::I64 = R2 >> 32;
           R2 = R2 & 4294967295;
           R1 = _s3DS::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.870382917 UTC

[section ""data" . GHC.Integer.Type.doubleFromPositive_closure" {
     GHC.Integer.Type.doubleFromPositive_closure:
         const GHC.Integer.Type.doubleFromPositive_info;
 },
 GHC.Integer.Type.doubleFromPositive_entry() //  [R2]
         { info_tbl: [(c659,
                       label: GHC.Integer.Type.doubleFromPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c659: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c65a; else goto c65b;
       c65a: // global
           R2 = R2;
           R1 = GHC.Integer.Type.doubleFromPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c65b: // global
           I64[Sp - 8] = block_c652_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u65Z; else goto c653;
       u65Z: // global
           call _c652(R1) args: 0, res: 0, upd: 0;
       c653: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c652() //  [R1]
         { info_tbl: [(c652,
                       label: block_c652_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c652: // global
           if (R1 & 7 == 1) goto c656; else goto c657;
       c656: // global
           I64[Sp - 8] = block_c65e_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c657: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 _c65e() //  [D1]
         { info_tbl: [(c65e,
                       label: block_c65e_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c65e: // global
           _s3DW::I64 = I64[Sp + 8];
           _s3DY::F64 = D1;
           (_c65r::F64) = call MO_F64_Pwr(2.0 :: W64, 32.0 :: W64);
           (_c65I::F64) = call MO_F64_Pwr(2.0 :: W64, 64.0 :: W64);
           D1 = %MO_F_Add_W64(%MO_F_Add_W64(%MO_F_Mul_W64(_s3DY::F64,
                                                          _c65I::F64),
                                            %MO_F_Mul_W64(%MO_SF_Conv_W64_W64(_s3DW::I64 >> 32),
                                                          _c65r::F64)),
                              %MO_SF_Conv_W64_W64(_s3DW::I64 & 4294967295));
           Sp = Sp + 16;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.886627336 UTC

[section ""data" . GHC.Integer.Type.doubleFromInteger_closure" {
     GHC.Integer.Type.doubleFromInteger_closure:
         const GHC.Integer.Type.doubleFromInteger_info;
 },
 GHC.Integer.Type.doubleFromInteger_entry() //  [R2]
         { info_tbl: [(c66H,
                       label: GHC.Integer.Type.doubleFromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c66H: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c66I; else goto c66J;
       c66I: // global
           R2 = R2;
           R1 = GHC.Integer.Type.doubleFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c66J: // global
           I64[Sp - 8] = block_c66z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u670; else goto c66A;
       u670: // global
           call _c66z(R1) args: 0, res: 0, upd: 0;
       c66A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c66z() //  [R1]
         { info_tbl: [(c66z,
                       label: block_c66z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c66z: // global
           _c66G::P64 = R1 & 7;
           if (_c66G::P64 < 3) goto u66Z; else goto c66F;
       u66Z: // global
           if (_c66G::P64 < 2) goto c66D; else goto c66E;
       c66D: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 0, upd: 8;
       c66E: // global
           I64[Sp] = block_c66P_info;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c66F: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 _c66P() //  [D1]
         { info_tbl: [(c66P,
                       label: block_c66P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c66P: // global
           D1 = %MO_F_Neg_W64(D1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.90095686 UTC

[section ""data" . GHC.Integer.Type.floatFromPositive_closure" {
     GHC.Integer.Type.floatFromPositive_closure:
         const GHC.Integer.Type.floatFromPositive_info;
 },
 GHC.Integer.Type.floatFromPositive_entry() //  [R2]
         { info_tbl: [(c67t,
                       label: GHC.Integer.Type.floatFromPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c67t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c67u; else goto c67v;
       c67u: // global
           R2 = R2;
           R1 = GHC.Integer.Type.floatFromPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c67v: // global
           I64[Sp - 8] = block_c67m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u68j; else goto c67n;
       u68j: // global
           call _c67m(R1) args: 0, res: 0, upd: 0;
       c67n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c67m() //  [R1]
         { info_tbl: [(c67m,
                       label: block_c67m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c67m: // global
           if (R1 & 7 == 1) goto c67q; else goto c67r;
       c67q: // global
           I64[Sp - 8] = block_c67y_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c67r: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 _c67y() //  [F1]
         { info_tbl: [(c67y,
                       label: block_c67y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c67y: // global
           _s3Eh::I64 = I64[Sp + 8];
           _s3Ej::F32 = F1;
           (_c67L::F32) = call MO_F32_Pwr(2.0 :: W32, 32.0 :: W32);
           (_c682::F32) = call MO_F32_Pwr(2.0 :: W32, 64.0 :: W32);
           F1 = %MO_F_Add_W32(%MO_F_Add_W32(%MO_F_Mul_W32(_s3Ej::F32,
                                                          _c682::F32),
                                            %MO_F_Mul_W32(%MO_SF_Conv_W64_W32(_s3Eh::I64 >> 32),
                                                          _c67L::F32)),
                              %MO_SF_Conv_W64_W32(_s3Eh::I64 & 4294967295));
           Sp = Sp + 16;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.916491254 UTC

[section ""data" . GHC.Integer.Type.floatFromInteger_closure" {
     GHC.Integer.Type.floatFromInteger_closure:
         const GHC.Integer.Type.floatFromInteger_info;
 },
 GHC.Integer.Type.floatFromInteger_entry() //  [R2]
         { info_tbl: [(c691,
                       label: GHC.Integer.Type.floatFromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c691: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c692; else goto c693;
       c692: // global
           R2 = R2;
           R1 = GHC.Integer.Type.floatFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c693: // global
           I64[Sp - 8] = block_c68T_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u69k; else goto c68U;
       u69k: // global
           call _c68T(R1) args: 0, res: 0, upd: 0;
       c68U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c68T() //  [R1]
         { info_tbl: [(c68T,
                       label: block_c68T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c68T: // global
           _c690::P64 = R1 & 7;
           if (_c690::P64 < 3) goto u69j; else goto c68Z;
       u69j: // global
           if (_c690::P64 < 2) goto c68X; else goto c68Y;
       c68X: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 0, upd: 8;
       c68Y: // global
           I64[Sp] = block_c699_info;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c68Z: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 _c699() //  [F1]
         { info_tbl: [(c699,
                       label: block_c699_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c699: // global
           F1 = %MO_F_Neg_W32(F1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.931389396 UTC

[section ""data" . GHC.Integer.Type.timesDigit_closure" {
     GHC.Integer.Type.timesDigit_closure:
         const GHC.Integer.Type.timesDigit_info;
         const 0;
 },
 GHC.Integer.Type.timesDigit_entry() //  [R2, R3]
         { info_tbl: [(c69I,
                       label: GHC.Integer.Type.timesDigit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c69I: // global
           _s3EB::I64 = R3;
           _s3EA::I64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c6am; else goto c6an;
       c6an: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6ap; else goto c6ao;
       c6ap: // global
           HpAlloc = 72;
           goto c6am;
       c6am: // global
           R3 = _s3EB::I64;
           R2 = _s3EA::I64;
           R1 = GHC.Integer.Type.timesDigit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ao: // global
           I64[Hp - 64] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 56] = GHC.Integer.Type.None_closure+2;
           _s3ED::I64 = _s3EB::I64 & 4294967295;
           _s3EF::I64 = _s3EA::I64 & 4294967295;
           I64[Hp - 48] = _s3EF::I64 * _s3ED::I64;
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = GHC.Integer.Type.None_closure+2;
           _s3EG::I64 = _s3EB::I64 >> 32;
           _s3EH::I64 = _s3EF::I64 * _s3EG::I64;
           I64[Hp - 24] = _s3EH::I64 & 4294967295 << 32;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           _s3EC::I64 = _s3EA::I64 >> 32;
           _s3EE::I64 = _s3EC::I64 * _s3ED::I64;
           I64[Hp] = _s3EE::I64 & 4294967295 << 32;
           I64[Sp - 48] = block_c6ah_info;
           R4 = Hp - 39;
           R3 = Hp - 15;
           R2 = 0;
           P64[Sp - 40] = Hp - 63;
           I64[Sp - 32] = _s3EC::I64;
           I64[Sp - 24] = _s3EE::I64;
           I64[Sp - 16] = _s3EG::I64;
           I64[Sp - 8] = _s3EH::I64;
           Sp = Sp - 48;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6ah() //  [R1]
         { info_tbl: [(c6ah,
                       label: block_c6ah_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ah: // global
           _c6a2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6al_info;
           R4 = _c6a2::P64;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6al() //  [R1]
         { info_tbl: [(c6al,
                       label: block_c6al_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6al: // global
           _s3EW::I64 = I64[Sp + 8] * I64[Sp + 24] + ((I64[Sp + 16] >> 32) + (I64[Sp + 32] >> 32));
           if (_s3EW::I64 == 0) goto c6aW; else goto u6b0;
       c6aW: // global
           R1 = R1 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u6b0: // global
           I64[Sp + 24] = _s3EW::I64;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call _c6aL() args: 0, res: 0, upd: 0;
     }
 },
 _c6aL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6aL: // global
           Hp = Hp + 48;
           _s3EW::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c6aT; else goto c6aS;
       c6aT: // global
           HpAlloc = 48;
           I64[Sp] = block_c6aK_info;
           R1 = _s3EW::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c6aS: // global
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = GHC.Integer.Type.None_closure+2;
           I64[Hp - 24] = _s3EW::I64;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = 0;
           R4 = P64[Sp + 8];
           R3 = Hp - 15;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c6aK() //  [R1]
         { info_tbl: [(c6aK,
                       label: block_c6aK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6aK: // global
           I64[Sp] = R1;
           call _c6aL() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.953095495 UTC

[section ""data" . GHC.Integer.Type.timesPositive_closure" {
     GHC.Integer.Type.timesPositive_closure:
         const GHC.Integer.Type.timesPositive_info;
         const 0;
 },
 GHC.Integer.Type.timesPositive_entry() //  [R2, R3]
         { info_tbl: [(c6bS,
                       label: GHC.Integer.Type.timesPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6bS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6bT; else goto u6dC;
       c6bT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.timesPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6dC: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6bI() args: 0, res: 0, upd: 0;
     }
 },
 _c6bI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6bI: // global
           _s3EZ::P64 = P64[Sp];
           I64[Sp] = block_c6bL_info;
           R1 = _s3EZ::P64;
           if (R1 & 7 != 0) goto u6dE; else goto c6bM;
       u6dE: // global
           call _c6bL(R1) args: 0, res: 0, upd: 0;
       c6bM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6bL() //  [R1]
         { info_tbl: [(c6bL,
                       label: block_c6bL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6bL: // global
           _s3F0::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6bP; else goto c6bQ;
       c6bP: // global
           I64[Sp - 16] = block_c6bX_info;
           _s3F1::P64 = R1;
           _s3F3::P64 = P64[R1 + 7];
           _s3F2::I64 = I64[R1 + 15];
           R1 = _s3F0::P64;
           P64[Sp - 8] = _s3F3::P64;
           I64[Sp] = _s3F2::I64;
           P64[Sp + 8] = _s3F1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6dF; else goto c6bZ;
       u6dF: // global
           call _c6bX(R1) args: 0, res: 0, upd: 0;
       c6bZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6bQ: // global
           I64[Sp + 8] = block_c6dr_info;
           R1 = _s3F0::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6dG; else goto c6dt;
       u6dG: // global
           call _c6dr() args: 0, res: 0, upd: 0;
       c6dt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6bX() //  [R1]
         { info_tbl: [(c6bX,
                       label: block_c6bX_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6bX: // global
           if (R1 & 7 == 1) goto c6c6; else goto c6do;
       c6c6: // global
           I64[Sp - 16] = block_c6c3_info;
           _s3F4::P64 = R1;
           _s3F6::P64 = P64[R1 + 7];
           _s3F5::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s3F6::P64;
           I64[Sp] = _s3F5::I64;
           P64[Sp + 8] = _s3F4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6dI; else goto c6c7;
       u6dI: // global
           call _c6c3(R1) args: 0, res: 0, upd: 0;
       c6c7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6do: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6c3() //  [R1]
         { info_tbl: [(c6c3,
                       label: block_c6c3_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6c3: // global
           _s3F6::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6ce; else goto c6d9;
       c6ce: // global
           I64[Sp + 8] = block_c6cb_info;
           _s3F7::P64 = R1;
           R1 = _s3F6::P64;
           P64[Sp + 40] = _s3F7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6dJ; else goto c6cf;
       u6dJ: // global
           call _c6cb(R1) args: 0, res: 0, upd: 0;
       c6cf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6d9: // global
           I64[Sp + 8] = block_c6d7_info;
           R1 = _s3F6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6dK; else goto c6da;
       u6dK: // global
           call _c6d7(R1) args: 0, res: 0, upd: 0;
       c6da: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6cb() //  [R1]
         { info_tbl: [(c6cb,
                       label: block_c6cb_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6cb: // global
           _s3F4::P64 = P64[Sp + 16];
           _s3F7::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c6cs; else goto c6d4;
       c6cs: // global
           I64[Sp + 8] = block_c6cj_info;
           R3 = _s3F4::P64;
           R2 = _s3F7::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c6d4: // global
           _s3Fh::I64 = I64[Sp + 24];
           if (_s3Fh::I64 != 0) goto c6cM; else goto c6d0;
       c6cM: // global
           I64[Sp] = block_c6cF_info;
           R3 = _s3F4::P64;
           R2 = _s3F7::P64;
           I64[Sp + 32] = _s3Fh::I64;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c6d0: // global
           I64[Sp + 32] = block_c6cV_info;
           R3 = _s3F4::P64;
           R2 = _s3F7::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6cj() //  [R1]
         { info_tbl: [(c6cj,
                       label: block_c6cj_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6cj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6cv; else goto c6cu;
       c6cv: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6cu: // global
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c6cp_info;
           R3 = P64[Sp + 8];
           R2 = Hp - 15;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6cp() //  [R1]
         { info_tbl: [(c6cp,
                       label: block_c6cp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6cp: // global
           R4 = P64[Sp + 8];
           R3 = R1;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c6cF() //  [R1]
         { info_tbl: [(c6cF,
                       label: block_c6cF_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6cF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6cP; else goto c6cO;
       c6cP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6cO: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           I64[Sp + 24] = block_c6cK_info;
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 32];
           P64[Sp + 32] = Hp - 15;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesDigit_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6cK() //  [R1]
         { info_tbl: [(c6cK,
                       label: block_c6cK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6cK: // global
           R4 = P64[Sp + 8];
           R3 = R1;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c6cV() //  [R1]
         { info_tbl: [(c6cV,
                       label: block_c6cV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6cV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6d3; else goto c6d2;
       c6d3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6d2: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6d7() //  [R1]
         { info_tbl: [(c6d7,
                       label: block_c6d7_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6d7: // global
           if (R1 & 7 == 1) goto c6dg; else goto c6dk;
       c6dg: // global
           P64[Sp + 24] = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 32];
           Sp = Sp + 24;
           call _c6bI() args: 0, res: 0, upd: 0;
       c6dk: // global
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Integer.Type.timesDigit_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _c6dr() //  []
         { info_tbl: [(c6dr,
                       label: block_c6dr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6dr: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:49.985688885 UTC

[section ""data" . GHC.Integer.Type.timesInteger_closure" {
     GHC.Integer.Type.timesInteger_closure:
         const GHC.Integer.Type.timesInteger_info;
         const 0;
 },
 GHC.Integer.Type.timesInteger_entry() //  [R2, R3]
         { info_tbl: [(c6f0,
                       label: GHC.Integer.Type.timesInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6f0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6f1; else goto c6f2;
       c6f1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.timesInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6f2: // global
           I64[Sp - 16] = block_c6eS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6gu; else goto c6eT;
       u6gu: // global
           call _c6eS(R1) args: 0, res: 0, upd: 0;
       c6eT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6eS() //  [R1]
         { info_tbl: [(c6eS,
                       label: block_c6eS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6eS: // global
           _s3Fr::P64 = P64[Sp + 8];
           _c6eZ::P64 = R1 & 7;
           if (_c6eZ::P64 < 3) goto u6gm; else goto c6eY;
       u6gm: // global
           if (_c6eZ::P64 < 2) goto c6eW; else goto c6eX;
       c6eW: // global
           I64[Sp] = block_c6f5_info;
           _s3Ft::P64 = P64[R1 + 7];
           R1 = _s3Fr::P64;
           P64[Sp + 8] = _s3Ft::P64;
           if (R1 & 7 != 0) goto u6gr; else goto c6f7;
       u6gr: // global
           call _c6f5(R1) args: 0, res: 0, upd: 0;
       c6f7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6eX: // global
           I64[Sp] = block_c6fE_info;
           _s3Fz::P64 = P64[R1 + 6];
           R1 = _s3Fr::P64;
           P64[Sp + 8] = _s3Fz::P64;
           if (R1 & 7 != 0) goto u6gs; else goto c6fG;
       u6gs: // global
           call _c6fE(R1) args: 0, res: 0, upd: 0;
       c6fG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6eY: // global
           I64[Sp + 8] = block_c6gd_info;
           R1 = _s3Fr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6gt; else goto c6gf;
       u6gt: // global
           call _c6gd() args: 0, res: 0, upd: 0;
       c6gf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6f5() //  [R1]
         { info_tbl: [(c6f5,
                       label: block_c6f5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6f5: // global
           _c6gl::P64 = R1 & 7;
           if (_c6gl::P64 < 3) goto u6gn; else goto u6gp;
       u6gn: // global
           _s3Ft::P64 = P64[Sp + 8];
           if (_c6gl::P64 < 2) goto c6fi; else goto c6fu;
       c6fi: // global
           I64[Sp + 8] = block_c6fb_info;
           R3 = P64[R1 + 7];
           R2 = _s3Ft::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c6fu: // global
           I64[Sp + 8] = block_c6fo_info;
           R3 = P64[R1 + 6];
           R2 = _s3Ft::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       u6gp: // global
           Sp = Sp + 16;
           call _c6ga() args: 0, res: 0, upd: 0;
     }
 },
 _c6fb() //  [R1]
         { info_tbl: [(c6fb,
                       label: block_c6fb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6fb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6fl; else goto c6fk;
       c6fl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6fk: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6fo() //  [R1]
         { info_tbl: [(c6fo,
                       label: block_c6fo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6fo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6fx; else goto c6fw;
       c6fx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6fw: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6fE() //  [R1]
         { info_tbl: [(c6fE,
                       label: block_c6fE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6fE: // global
           _c6gk::P64 = R1 & 7;
           if (_c6gk::P64 < 3) goto u6go; else goto u6gq;
       u6go: // global
           _s3Fz::P64 = P64[Sp + 8];
           if (_c6gk::P64 < 2) goto c6fR; else goto c6g3;
       c6fR: // global
           I64[Sp + 8] = block_c6fK_info;
           R3 = P64[R1 + 7];
           R2 = _s3Fz::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c6g3: // global
           I64[Sp + 8] = block_c6fX_info;
           R3 = P64[R1 + 6];
           R2 = _s3Fz::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       u6gq: // global
           Sp = Sp + 16;
           call _c6ga() args: 0, res: 0, upd: 0;
     }
 },
 _c6fK() //  [R1]
         { info_tbl: [(c6fK,
                       label: block_c6fK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6fK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6fU; else goto c6fT;
       c6fU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6fT: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6fX() //  [R1]
         { info_tbl: [(c6fX,
                       label: block_c6fX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6fX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6g6; else goto c6g5;
       c6g6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6g5: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6ga() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ga: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6gd() //  []
         { info_tbl: [(c6gd,
                       label: block_c6gd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6gd: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.012721202 UTC

[section ""data" . GHC.Integer.Type.twoToTheThirtytwoPositive_closure" {
     GHC.Integer.Type.twoToTheThirtytwoPositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 4294967296;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.015754773 UTC

[section ""data" . GHC.Integer.Type.twoToTheThirtytwoInteger_closure" {
     GHC.Integer.Type.twoToTheThirtytwoInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.twoToTheThirtytwoPositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.019285564 UTC

[section ""data" . GHC.Integer.Type.digitsMaybeZeroToInteger_closure" {
     GHC.Integer.Type.digitsMaybeZeroToInteger_closure:
         const GHC.Integer.Type.digitsMaybeZeroToInteger_info;
 },
 GHC.Integer.Type.digitsMaybeZeroToInteger_entry() //  [R2]
         { info_tbl: [(c6hs,
                       label: GHC.Integer.Type.digitsMaybeZeroToInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6hs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6ht; else goto c6hu;
       c6ht: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsMaybeZeroToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6hu: // global
           I64[Sp - 8] = block_c6hl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6hE; else goto c6hm;
       u6hE: // global
           call _c6hl(R1) args: 0, res: 0, upd: 0;
       c6hm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6hl() //  [R1]
         { info_tbl: [(c6hl,
                       label: block_c6hl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6hl: // global
           if (R1 & 7 == 1) goto c6hp; else goto c6hq;
       c6hp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6hA; else goto c6hz;
       c6hA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6hz: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6hq: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.031359415 UTC

[section ""data" . GHC.Integer.Type.removeZeroTails_closure" {
     GHC.Integer.Type.removeZeroTails_closure:
         const GHC.Integer.Type.removeZeroTails_info;
 },
 GHC.Integer.Type.removeZeroTails_entry() //  [R2]
         { info_tbl: [(c6i3,
                       label: GHC.Integer.Type.removeZeroTails_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6i3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6i4; else goto c6i5;
       c6i4: // global
           R2 = R2;
           R1 = GHC.Integer.Type.removeZeroTails_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6i5: // global
           I64[Sp - 8] = block_c6hW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6iI; else goto c6hX;
       u6iI: // global
           call _c6hW(R1) args: 0, res: 0, upd: 0;
       c6hX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6hW() //  [R1]
         { info_tbl: [(c6hW,
                       label: block_c6hW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6hW: // global
           if (R1 & 7 == 1) goto c6i0; else goto u6iF;
       c6i0: // global
           _s3FN::P64 = P64[R1 + 7];
           _s3FO::I64 = I64[R1 + 15];
           if (_s3FO::I64 != 0) goto c6ih; else goto c6in;
       c6ih: // global
           I64[Sp - 8] = block_c6ib_info;
           R2 = _s3FN::P64;
           I64[Sp] = _s3FO::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
       c6in: // global
           I64[Sp] = block_c6im_info;
           R2 = _s3FN::P64;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
       u6iF: // global
           Sp = Sp + 8;
           call _c6i1() args: 0, res: 0, upd: 0;
     }
 },
 _c6ib() //  [R1]
         { info_tbl: [(c6ib,
                       label: block_c6ib_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ib: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ik; else goto c6ij;
       c6ik: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ij: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6im() //  [R1]
         { info_tbl: [(c6im,
                       label: block_c6im_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6im: // global
           if (R1 & 7 == 1) goto c6it; else goto u6iG;
       c6it: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6iw; else goto c6iv;
       c6iw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6iv: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u6iG: // global
           Sp = Sp + 8;
           call _c6i1() args: 0, res: 0, upd: 0;
     }
 },
 _c6i1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6i1: // global
           R1 = GHC.Integer.Type.None_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.044981818 UTC

[section ""data" . GHC.Integer.Type.digitsToNegativeInteger_closure" {
     GHC.Integer.Type.digitsToNegativeInteger_closure:
         const GHC.Integer.Type.digitsToNegativeInteger_info;
 },
 GHC.Integer.Type.digitsToNegativeInteger_entry() //  [R2]
         { info_tbl: [(c6jj,
                       label: GHC.Integer.Type.digitsToNegativeInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6jj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6jk; else goto c6jl;
       c6jk: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsToNegativeInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6jl: // global
           I64[Sp - 8] = block_c6jd_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6jd() //  [R1]
         { info_tbl: [(c6jd,
                       label: block_c6jd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6jd: // global
           if (R1 & 7 == 1) goto c6jg; else goto c6jh;
       c6jg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6jr; else goto c6jq;
       c6jr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6jq: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6jh: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.053328069 UTC

[section ""data" . GHC.Integer.Type.digitsToInteger_closure" {
     GHC.Integer.Type.digitsToInteger_closure:
         const GHC.Integer.Type.digitsToInteger_info;
 },
 GHC.Integer.Type.digitsToInteger_entry() //  [R2]
         { info_tbl: [(c6jR,
                       label: GHC.Integer.Type.digitsToInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6jR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6jS; else goto c6jT;
       c6jS: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6jT: // global
           I64[Sp - 8] = block_c6jL_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6jL() //  [R1]
         { info_tbl: [(c6jL,
                       label: block_c6jL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6jL: // global
           if (R1 & 7 == 1) goto c6jO; else goto c6jP;
       c6jO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6jZ; else goto c6jY;
       c6jZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6jY: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6jP: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.061730234 UTC

[section ""data" . GHC.Integer.Type.comparePositive_closure" {
     GHC.Integer.Type.comparePositive_closure:
         const GHC.Integer.Type.comparePositive_info;
 },
 GHC.Integer.Type.comparePositive_entry() //  [R2, R3]
         { info_tbl: [(c6kq,
                       label: GHC.Integer.Type.comparePositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6kq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6kr; else goto c6ks;
       c6kr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.comparePositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ks: // global
           I64[Sp - 16] = block_c6kj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6lu; else goto c6kk;
       u6lu: // global
           call _c6kj(R1) args: 0, res: 0, upd: 0;
       c6kk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6kj() //  [R1]
         { info_tbl: [(c6kj,
                       label: block_c6kj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6kj: // global
           _s3G2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6kn; else goto c6ko;
       c6kn: // global
           I64[Sp - 8] = block_c6kv_info;
           _s3G5::P64 = P64[R1 + 7];
           _s3G4::I64 = I64[R1 + 15];
           R1 = _s3G2::P64;
           P64[Sp] = _s3G5::P64;
           I64[Sp + 8] = _s3G4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6ls; else goto c6kx;
       u6ls: // global
           call _c6kv(R1) args: 0, res: 0, upd: 0;
       c6kx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6ko: // global
           I64[Sp + 8] = block_c6l6_info;
           R1 = _s3G2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6lt; else goto c6l8;
       u6lt: // global
           call _c6l6(R1) args: 0, res: 0, upd: 0;
       c6l8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6kv() //  [R1]
         { info_tbl: [(c6kv,
                       label: block_c6kv_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6kv: // global
           if (R1 & 7 == 1) goto c6kE; else goto u6lo;
       c6kE: // global
           I64[Sp] = block_c6kB_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u6lo: // global
           Sp = Sp + 24;
           call _c6l3() args: 0, res: 0, upd: 0;
     }
 },
 _c6kB() //  [R1]
         { info_tbl: [(c6kB,
                       label: block_c6kB_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6kB: // global
           if (R1 & 7 == 2) goto c6kZ; else goto c6kK;
       c6kZ: // global
           _s3G4::I64 = I64[Sp + 16];
           _s3G7::I64 = I64[Sp + 8];
           if (_s3G4::I64 >= _s3G7::I64) goto c6kX; else goto u6lp;
       c6kX: // global
           if (_s3G4::I64 <= _s3G7::I64) goto u6lr; else goto u6lq;
       u6lr: // global
           Sp = Sp + 24;
           call _c6li() args: 0, res: 0, upd: 0;
       u6lq: // global
           Sp = Sp + 24;
           call _c6l3() args: 0, res: 0, upd: 0;
       u6lp: // global
           Sp = Sp + 24;
           call _c6le() args: 0, res: 0, upd: 0;
       c6kK: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6l3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6l3: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6l6() //  [R1]
         { info_tbl: [(c6l6,
                       label: block_c6l6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6l6: // global
           if (R1 & 7 == 1) goto u6lm; else goto u6ln;
       u6lm: // global
           Sp = Sp + 8;
           call _c6le() args: 0, res: 0, upd: 0;
       u6ln: // global
           Sp = Sp + 8;
           call _c6li() args: 0, res: 0, upd: 0;
     }
 },
 _c6le() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6le: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6li() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6li: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.085685984 UTC

[section ""data" . GHC.Integer.Type.compareInteger_closure" {
     GHC.Integer.Type.compareInteger_closure:
         const GHC.Integer.Type.compareInteger_info;
 },
 GHC.Integer.Type.compareInteger_entry() //  [R2, R3]
         { info_tbl: [(c6mr,
                       label: GHC.Integer.Type.compareInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6mr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ms; else goto c6mt;
       c6ms: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.compareInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6mt: // global
           I64[Sp - 16] = block_c6mj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6nt; else goto c6mk;
       u6nt: // global
           call _c6mj(R1) args: 0, res: 0, upd: 0;
       c6mk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6mj() //  [R1]
         { info_tbl: [(c6mj,
                       label: block_c6mj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6mj: // global
           _s3Gg::P64 = P64[Sp + 8];
           _c6mq::P64 = R1 & 7;
           if (_c6mq::P64 < 3) goto u6nk; else goto c6mp;
       u6nk: // global
           if (_c6mq::P64 < 2) goto c6mn; else goto c6mo;
       c6mn: // global
           I64[Sp] = block_c6mw_info;
           _s3Gi::P64 = P64[R1 + 7];
           R1 = _s3Gg::P64;
           P64[Sp + 8] = _s3Gi::P64;
           if (R1 & 7 != 0) goto u6nq; else goto c6my;
       u6nq: // global
           call _c6mw(R1) args: 0, res: 0, upd: 0;
       c6my: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6mo: // global
           I64[Sp] = block_c6mL_info;
           _s3Gl::P64 = P64[R1 + 6];
           R1 = _s3Gg::P64;
           P64[Sp + 8] = _s3Gl::P64;
           if (R1 & 7 != 0) goto u6nr; else goto c6mN;
       u6nr: // global
           call _c6mL(R1) args: 0, res: 0, upd: 0;
       c6mN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6mp: // global
           I64[Sp + 8] = block_c6n0_info;
           R1 = _s3Gg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6ns; else goto c6n2;
       u6ns: // global
           call _c6n0(R1) args: 0, res: 0, upd: 0;
       c6n2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6mw() //  [R1]
         { info_tbl: [(c6mw,
                       label: block_c6mw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6mw: // global
           if (R1 & 7 == 1) goto c6mI; else goto u6nm;
       c6mI: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       u6nm: // global
           Sp = Sp + 16;
           call _c6nc() args: 0, res: 0, upd: 0;
     }
 },
 _c6mL() //  [R1]
         { info_tbl: [(c6mL,
                       label: block_c6mL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6mL: // global
           if (R1 & 7 == 2) goto c6mX; else goto u6nn;
       c6mX: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       u6nn: // global
           Sp = Sp + 16;
           call _c6n8() args: 0, res: 0, upd: 0;
     }
 },
 _c6n0() //  [R1]
         { info_tbl: [(c6n0,
                       label: block_c6n0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6n0: // global
           _c6nh::P64 = R1 & 7;
           if (_c6nh::P64 < 3) goto u6nl; else goto c6ng;
       u6nl: // global
           if (_c6nh::P64 < 2) goto u6np; else goto u6no;
       u6np: // global
           Sp = Sp + 8;
           call _c6n8() args: 0, res: 0, upd: 0;
       u6no: // global
           Sp = Sp + 8;
           call _c6nc() args: 0, res: 0, upd: 0;
       c6ng: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6n8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6n8: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6nc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6nc: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.110184179 UTC

[section ""data" . GHC.Integer.Type.eqInteger#_closure" {
     GHC.Integer.Type.eqInteger#_closure:
         const GHC.Integer.Type.eqInteger#_info;
 },
 GHC.Integer.Type.eqInteger#_entry() //  [R2, R3]
         { info_tbl: [(c6og,
                       label: GHC.Integer.Type.eqInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6og: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6oh; else goto c6oi;
       c6oh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.eqInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6oi: // global
           I64[Sp - 8] = block_c6oa_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6oa() //  [R1]
         { info_tbl: [(c6oa,
                       label: block_c6oa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6oa: // global
           if (R1 & 7 == 2) goto c6oe; else goto c6od;
       c6oe: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6od: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.118786146 UTC

[section ""data" . GHC.Integer.Type.eqInteger_closure" {
     GHC.Integer.Type.eqInteger_closure:
         const GHC.Integer.Type.eqInteger_info;
 },
 GHC.Integer.Type.eqInteger_entry() //  [R2, R3]
         { info_tbl: [(c6oH,
                       label: GHC.Integer.Type.eqInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6oH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6oI; else goto c6oJ;
       c6oI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.eqInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6oJ: // global
           I64[Sp - 8] = block_c6oF_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6oF() //  [R1]
         { info_tbl: [(c6oF,
                       label: block_c6oF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6oF: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.128037067 UTC

[section ""data" . GHC.Integer.Type.neqInteger#_closure" {
     GHC.Integer.Type.neqInteger#_closure:
         const GHC.Integer.Type.neqInteger#_info;
 },
 GHC.Integer.Type.neqInteger#_entry() //  [R2, R3]
         { info_tbl: [(c6p7,
                       label: GHC.Integer.Type.neqInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6p7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6p8; else goto c6p9;
       c6p8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.neqInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6p9: // global
           I64[Sp - 8] = block_c6p1_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6p1() //  [R1]
         { info_tbl: [(c6p1,
                       label: block_c6p1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6p1: // global
           if (R1 & 7 == 2) goto c6p5; else goto c6p4;
       c6p5: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6p4: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.19405869 UTC

[section ""data" . GHC.Integer.Type.neqInteger_closure" {
     GHC.Integer.Type.neqInteger_closure:
         const GHC.Integer.Type.neqInteger_info;
 },
 GHC.Integer.Type.neqInteger_entry() //  [R2, R3]
         { info_tbl: [(c6py,
                       label: GHC.Integer.Type.neqInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6py: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6pz; else goto c6pA;
       c6pz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.neqInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6pA: // global
           I64[Sp - 8] = block_c6pw_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6pw() //  [R1]
         { info_tbl: [(c6pw,
                       label: block_c6pw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6pw: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.205034164 UTC

[section ""data" . GHC.Integer.Type.$fEqInteger_closure" {
     GHC.Integer.Type.$fEqInteger_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.209119199 UTC

[section ""data" . GHC.Integer.Type.ltInteger#_closure" {
     GHC.Integer.Type.ltInteger#_closure:
         const GHC.Integer.Type.ltInteger#_info;
 },
 GHC.Integer.Type.ltInteger#_entry() //  [R2, R3]
         { info_tbl: [(c6pZ,
                       label: GHC.Integer.Type.ltInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6pZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6q0; else goto c6q1;
       c6q0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.ltInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6q1: // global
           I64[Sp - 8] = block_c6pT_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6pT() //  [R1]
         { info_tbl: [(c6pT,
                       label: block_c6pT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6pT: // global
           if (R1 & 7 == 1) goto c6pX; else goto c6pW;
       c6pX: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6pW: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.21707465 UTC

[section ""data" . GHC.Integer.Type.ltInteger_closure" {
     GHC.Integer.Type.ltInteger_closure:
         const GHC.Integer.Type.ltInteger_info;
 },
 GHC.Integer.Type.ltInteger_entry() //  [R2, R3]
         { info_tbl: [(c6qq,
                       label: GHC.Integer.Type.ltInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6qq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6qr; else goto c6qs;
       c6qr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.ltInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6qs: // global
           I64[Sp - 8] = block_c6qo_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6qo() //  [R1]
         { info_tbl: [(c6qo,
                       label: block_c6qo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6qo: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.224649271 UTC

[section ""data" . GHC.Integer.Type.gtInteger#_closure" {
     GHC.Integer.Type.gtInteger#_closure:
         const GHC.Integer.Type.gtInteger#_info;
 },
 GHC.Integer.Type.gtInteger#_entry() //  [R2, R3]
         { info_tbl: [(c6qQ,
                       label: GHC.Integer.Type.gtInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6qQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6qR; else goto c6qS;
       c6qR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.gtInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6qS: // global
           I64[Sp - 8] = block_c6qK_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6qK() //  [R1]
         { info_tbl: [(c6qK,
                       label: block_c6qK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6qK: // global
           if (R1 & 7 == 3) goto c6qO; else goto c6qN;
       c6qO: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6qN: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.232992783 UTC

[section ""data" . GHC.Integer.Type.gtInteger_closure" {
     GHC.Integer.Type.gtInteger_closure:
         const GHC.Integer.Type.gtInteger_info;
 },
 GHC.Integer.Type.gtInteger_entry() //  [R2, R3]
         { info_tbl: [(c6rh,
                       label: GHC.Integer.Type.gtInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6rh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6ri; else goto c6rj;
       c6ri: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.gtInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6rj: // global
           I64[Sp - 8] = block_c6rf_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6rf() //  [R1]
         { info_tbl: [(c6rf,
                       label: block_c6rf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6rf: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.239930274 UTC

[section ""data" . GHC.Integer.Type.leInteger#_closure" {
     GHC.Integer.Type.leInteger#_closure:
         const GHC.Integer.Type.leInteger#_info;
 },
 GHC.Integer.Type.leInteger#_entry() //  [R2, R3]
         { info_tbl: [(c6rH,
                       label: GHC.Integer.Type.leInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6rH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6rI; else goto c6rJ;
       c6rI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.leInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6rJ: // global
           I64[Sp - 8] = block_c6rB_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6rB() //  [R1]
         { info_tbl: [(c6rB,
                       label: block_c6rB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6rB: // global
           if (R1 & 7 == 3) goto c6rF; else goto c6rE;
       c6rF: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6rE: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.247918588 UTC

[section ""data" . GHC.Integer.Type.leInteger_closure" {
     GHC.Integer.Type.leInteger_closure:
         const GHC.Integer.Type.leInteger_info;
 },
 GHC.Integer.Type.leInteger_entry() //  [R2, R3]
         { info_tbl: [(c6s8,
                       label: GHC.Integer.Type.leInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6s8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6s9; else goto c6sa;
       c6s9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.leInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6sa: // global
           I64[Sp - 8] = block_c6s6_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6s6() //  [R1]
         { info_tbl: [(c6s6,
                       label: block_c6s6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6s6: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.255747004 UTC

[section ""data" . GHC.Integer.Type.geInteger#_closure" {
     GHC.Integer.Type.geInteger#_closure:
         const GHC.Integer.Type.geInteger#_info;
 },
 GHC.Integer.Type.geInteger#_entry() //  [R2, R3]
         { info_tbl: [(c6sy,
                       label: GHC.Integer.Type.geInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6sy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6sz; else goto c6sA;
       c6sz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.geInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6sA: // global
           I64[Sp - 8] = block_c6ss_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6ss() //  [R1]
         { info_tbl: [(c6ss,
                       label: block_c6ss_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ss: // global
           if (R1 & 7 == 1) goto c6sw; else goto c6sv;
       c6sw: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6sv: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.262215479 UTC

[section ""data" . GHC.Integer.Type.geInteger_closure" {
     GHC.Integer.Type.geInteger_closure:
         const GHC.Integer.Type.geInteger_info;
 },
 GHC.Integer.Type.geInteger_entry() //  [R2, R3]
         { info_tbl: [(c6sZ,
                       label: GHC.Integer.Type.geInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6sZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6t0; else goto c6t1;
       c6t0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.geInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6t1: // global
           I64[Sp - 8] = block_c6sX_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6sX() //  [R1]
         { info_tbl: [(c6sX,
                       label: block_c6sX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6sX: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.26921613 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_$cmax_closure" {
     GHC.Integer.Type.$fOrdInteger_$cmax_closure:
         const GHC.Integer.Type.$fOrdInteger_$cmax_info;
 },
 GHC.Integer.Type.$fOrdInteger_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c6to,
                       label: GHC.Integer.Type.$fOrdInteger_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6to: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6tp; else goto c6tq;
       c6tp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$fOrdInteger_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6tq: // global
           I64[Sp - 24] = block_c6tj_info;
           _s3H2::P64 = R3;
           R3 = R3;
           _s3H1::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s3H1::P64;
           P64[Sp - 8] = _s3H2::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6tj() //  [R1]
         { info_tbl: [(c6tj,
                       label: block_c6tj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6tj: // global
           if (R1 == 1) goto c6tn; else goto c6tm;
       c6tn: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6tm: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.276915817 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_$cmin_closure" {
     GHC.Integer.Type.$fOrdInteger_$cmin_closure:
         const GHC.Integer.Type.$fOrdInteger_$cmin_info;
 },
 GHC.Integer.Type.$fOrdInteger_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c6tS,
                       label: GHC.Integer.Type.$fOrdInteger_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6tS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6tT; else goto c6tU;
       c6tT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$fOrdInteger_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6tU: // global
           I64[Sp - 24] = block_c6tN_info;
           _s3H5::P64 = R3;
           R3 = R3;
           _s3H4::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s3H4::P64;
           P64[Sp - 8] = _s3H5::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6tN() //  [R1]
         { info_tbl: [(c6tN,
                       label: block_c6tN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6tN: // global
           if (R1 == 1) goto c6tR; else goto c6tQ;
       c6tR: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6tQ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.284905465 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_closure" {
     GHC.Integer.Type.$fOrdInteger_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Integer.Type.$fEqInteger_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.290070991 UTC

[section ""data" . GHC.Integer.Type.plusInteger_closure" {
     GHC.Integer.Type.plusInteger_closure:
         const GHC.Integer.Type.plusInteger_info;
         const 0;
 },
 GHC.Integer.Type.plusInteger_entry() //  [R2, R3]
         { info_tbl: [(c6uq,
                       label: GHC.Integer.Type.plusInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6uq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6ur; else goto u6w0;
       c6ur: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.plusInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6w0: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6uf() args: 0, res: 0, upd: 0;
     }
 },
 _c6uf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6uf: // global
           _s3H7::P64 = P64[Sp];
           I64[Sp] = block_c6ui_info;
           R1 = _s3H7::P64;
           if (R1 & 7 != 0) goto u6w4; else goto c6uj;
       u6w4: // global
           call _c6ui(R1) args: 0, res: 0, upd: 0;
       c6uj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ui() //  [R1]
         { info_tbl: [(c6ui,
                       label: block_c6ui_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ui: // global
           _s3H8::P64 = P64[Sp + 8];
           _c6up::P64 = R1 & 7;
           if (_c6up::P64 < 3) goto u6vW; else goto c6uo;
       u6vW: // global
           if (_c6up::P64 < 2) goto c6um; else goto c6un;
       c6um: // global
           I64[Sp - 8] = block_c6uv_info;
           _s3H9::P64 = R1;
           _s3Ha::P64 = P64[R1 + 7];
           R1 = _s3H8::P64;
           P64[Sp] = _s3Ha::P64;
           P64[Sp + 8] = _s3H9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6w5; else goto c6ux;
       u6w5: // global
           call _c6uv(R1) args: 0, res: 0, upd: 0;
       c6ux: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6un: // global
           I64[Sp - 8] = block_c6vr_info;
           _s3H9::P64 = R1;
           _s3Hi::P64 = P64[R1 + 6];
           R1 = _s3H8::P64;
           P64[Sp] = _s3Hi::P64;
           P64[Sp + 8] = _s3H9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6w6; else goto c6vt;
       u6w6: // global
           call _c6vr(R1) args: 0, res: 0, upd: 0;
       c6vt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6uo: // global
           R1 = _s3H8::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6uv() //  [R1]
         { info_tbl: [(c6uv,
                       label: block_c6uv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6uv: // global
           _c6vU::P64 = R1 & 7;
           if (_c6vU::P64 < 3) goto u6vX; else goto u6w1;
       u6vX: // global
           _s3Ha::P64 = P64[Sp + 8];
           if (_c6vU::P64 < 2) goto c6uI; else goto c6uQ;
       c6uI: // global
           I64[Sp + 16] = block_c6uB_info;
           R4 = P64[R1 + 7];
           R3 = _s3Ha::P64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c6uQ: // global
           I64[Sp] = block_c6uO_info;
           _s3He::P64 = P64[R1 + 6];
           R3 = _s3He::P64;
           R2 = _s3Ha::P64;
           P64[Sp + 16] = _s3He::P64;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u6w1: // global
           Sp = Sp + 16;
           call _c6vP() args: 0, res: 0, upd: 0;
     }
 },
 _c6uB() //  [R1]
         { info_tbl: [(c6uB,
                       label: block_c6uB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6uB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6uL; else goto c6uK;
       c6uL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6uK: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6uO() //  [R1]
         { info_tbl: [(c6uO,
                       label: block_c6uO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6uO: // global
           _s3Ha::P64 = P64[Sp + 8];
           _s3He::P64 = P64[Sp + 16];
           _c6vV::P64 = R1 & 7;
           if (_c6vV::P64 < 3) goto u6vY; else goto c6vh;
       u6vY: // global
           if (_c6vV::P64 < 2) goto c6v1; else goto c6v8;
       c6v1: // global
           I64[Sp + 16] = block_c6uU_info;
           R3 = _s3Ha::P64;
           R2 = _s3He::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c6v8: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6vh: // global
           I64[Sp + 16] = block_c6vb_info;
           R3 = _s3He::P64;
           R2 = _s3Ha::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6uU() //  [R1]
         { info_tbl: [(c6uU,
                       label: block_c6uU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6uU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6v4; else goto c6v3;
       c6v4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6v3: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6vb() //  [R1]
         { info_tbl: [(c6vb,
                       label: block_c6vb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vk; else goto c6vj;
       c6vk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vj: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6vr() //  [R1]
         { info_tbl: [(c6vr,
                       label: block_c6vr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vr: // global
           _c6vT::P64 = R1 & 7;
           if (_c6vT::P64 < 3) goto u6vZ; else goto u6w2;
       u6vZ: // global
           if (_c6vT::P64 < 2) goto c6vz; else goto c6vI;
       c6vz: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c6uf() args: 0, res: 0, upd: 0;
       c6vI: // global
           I64[Sp + 16] = block_c6vC_info;
           R4 = P64[R1 + 6];
           R3 = P64[Sp + 8];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       u6w2: // global
           Sp = Sp + 16;
           call _c6vP() args: 0, res: 0, upd: 0;
     }
 },
 _c6vC() //  [R1]
         { info_tbl: [(c6vC,
                       label: block_c6vC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vL; else goto c6vK;
       c6vL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vK: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6vP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vP: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.320559579 UTC

[section ""data" . GHC.Integer.Type.minusInteger_closure" {
     GHC.Integer.Type.minusInteger_closure:
         const GHC.Integer.Type.minusInteger_info;
         const 0;
 },
 GHC.Integer.Type.minusInteger_entry() //  [R2, R3]
         { info_tbl: [(c6x5,
                       label: GHC.Integer.Type.minusInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x6; else goto c6x7;
       c6x6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.minusInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6x7: // global
           I64[Sp - 16] = block_c6x3_info;
           _s3Hn::P64 = R2;
           R2 = R3;
           P64[Sp - 8] = _s3Hn::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6x3() //  [R1]
         { info_tbl: [(c6x3,
                       label: block_c6x3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x3: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.327274521 UTC

[section ""data" . GHC.Integer.Type.complementInteger_closure" {
     GHC.Integer.Type.complementInteger_closure:
         const GHC.Integer.Type.complementInteger_info;
         const 0;
 },
 GHC.Integer.Type.complementInteger_entry() //  [R2]
         { info_tbl: [(c6xn,
                       label: GHC.Integer.Type.complementInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xn: // global
           R3 = R2;
           R2 = GHC.Integer.Type.negativeOneInteger_closure+2;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.332350621 UTC

[section ""data" . GHC.Integer.Type.decodeDoubleInteger_closure" {
     GHC.Integer.Type.decodeDoubleInteger_closure:
         const GHC.Integer.Type.decodeDoubleInteger_info;
         const 0;
 },
 sat_s3HC_entry() //  [R1]
         { info_tbl: [(c6xI,
                       label: sat_s3HC_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6xY; else goto c6xZ;
       c6xY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c6xG_info;
           R2 = I64[R1 + 32];
           I64[Sp - 32] = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6xG() //  [R1]
         { info_tbl: [(c6xG,
                       label: block_c6xG_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xG: // global
           I64[Sp] = block_c6xL_info;
           R2 = I64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6xL() //  [R1]
         { info_tbl: [(c6xL,
                       label: block_c6xL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xL: // global
           I64[Sp] = block_c6xP_info;
           R3 = GHC.Integer.Type.twoToTheThirtytwoInteger_closure+1;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6xP() //  [R1]
         { info_tbl: [(c6xP,
                       label: block_c6xP_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xP: // global
           I64[Sp] = block_c6xT_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6xT() //  [R1]
         { info_tbl: [(c6xT,
                       label: block_c6xT_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xT: // global
           _s3Ht::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c6xX_info;
           R2 = _s3Ht::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6xX() //  [R1]
         { info_tbl: [(c6xX,
                       label: block_c6xX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xX: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.decodeDoubleInteger_entry() //  [D1]
         { info_tbl: [(c6y8,
                       label: GHC.Integer.Type.decodeDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 7} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6y9; else goto c6ya;
       c6y9: // global
           D1 = D1;
           R1 = GHC.Integer.Type.decodeDoubleInteger_closure;
           call (stg_gc_fun)(D1, R1) args: 8, res: 0, upd: 8;
       c6ya: // global
           I64[Sp - 8] = block_c6xy_info;
           D1 = D1;
           Sp = Sp - 8;
           call stg_decodeDouble_2Int#(D1) args: 8, res: 8, upd: 8;
     }
 },
 _c6xy() //  [R1, R2, R3, R4]
         { info_tbl: [(c6xy,
                       label: block_c6xy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xy: // global
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           I64[Sp] = R1;
           Sp = Sp - 32;
           call _c6xz() args: 0, res: 0, upd: 0;
     }
 },
 _c6xz() //  []
         { info_tbl: [(c6xz,
                       label: block_c6xz_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6yd; else goto c6yc;
       c6yd: // global
           HpAlloc = 40;
           I64[Sp] = block_c6xz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c6yc: // global
           I64[Hp - 32] = sat_s3HC_info;
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = I64[Sp + 24];
           R1 = Hp - 32;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.357844156 UTC

[section ""data" . GHC.Integer.Type.smallShiftLPositive_closure" {
     GHC.Integer.Type.smallShiftLPositive_closure:
         const GHC.Integer.Type.smallShiftLPositive_info;
 },
 f2_s3HH_entry() //  [R1, R2, R3]
         { info_tbl: [(c6zb,
                       label: f2_s3HH_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6zc; else goto c6zd;
       c6zc: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zd: // global
           I64[Sp - 40] = block_c6z4_info;
           _s3HH::P64 = R1;
           _s3HF::I64 = I64[R1 + 6];
           _s3HG::I64 = I64[R1 + 14];
           R1 = R3;
           I64[Sp - 32] = _s3HF::I64;
           I64[Sp - 24] = _s3HG::I64;
           P64[Sp - 16] = _s3HH::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u6zJ; else goto c6z5;
       u6zJ: // global
           call _c6z4(R1) args: 0, res: 0, upd: 0;
       c6z5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6z4() //  [R1]
         { info_tbl: [(c6z4,
                       label: block_c6z4_info
                       rep:StackRep [True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z4: // global
           if (R1 & 7 == 1) goto c6z8; else goto c6z9;
       c6z8: // global
           I64[Sp] = block_c6zj_info;
           R3 = P64[R1 + 7];
           _s3HL::I64 = I64[R1 + 15];
           R2 = _s3HL::I64 >> I64[Sp + 16];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s3HL::I64;
           call f2_s3HH_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
       c6z9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zC; else goto c6zB;
       c6zC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zB: // global
           _s3HR::I64 = I64[Sp + 32];
           if (_s3HR::I64 != 0) goto c6zH; else goto c6zI;
       c6zH: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s3HR::I64;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6zI: // global
           Hp = Hp - 24;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6zj() //  [R1]
         { info_tbl: [(c6zj,
                       label: block_c6zj_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zx; else goto c6zw;
       c6zx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zw: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = (I64[Sp + 24] << I64[Sp + 8]) | I64[Sp + 32];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Integer.Type.smallShiftLPositive_entry() //  [R2, R3]
         { info_tbl: [(c6zN,
                       label: GHC.Integer.Type.smallShiftLPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zR; else goto c6zQ;
       c6zR: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.smallShiftLPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zQ: // global
           if (R3 == 0) goto c6zM; else goto c6zL;
       c6zM: // global
           Hp = Hp - 24;
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6zL: // global
           I64[Hp - 16] = f2_s3HH_info;
           I64[Hp - 8] = R3;
           I64[Hp] = 64 - R3;
           R3 = R2;
           R2 = 0;
           R1 = Hp - 14;
           call f2_s3HH_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.371479704 UTC

[section ""data" . GHC.Integer.Type.smallShiftRPositive_closure" {
     GHC.Integer.Type.smallShiftRPositive_closure:
         const GHC.Integer.Type.smallShiftRPositive_info;
 },
 GHC.Integer.Type.smallShiftRPositive_entry() //  [R2, R3]
         { info_tbl: [(c6Ar,
                       label: GHC.Integer.Type.smallShiftRPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ar: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6As; else goto c6At;
       c6As: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.smallShiftRPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6At: // global
           I64[Sp - 16] = block_c6Ao_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Bd; else goto c6Ap;
       u6Bd: // global
           call _c6Ao(R1) args: 0, res: 0, upd: 0;
       c6Ap: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ao() //  [R1]
         { info_tbl: [(c6Ao,
                       label: block_c6Ao_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ao: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Ay; else goto c6Ax;
       c6Ay: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Ax: // global
           _s3HV::I64 = I64[Sp + 8];
           if (_s3HV::I64 == 0) goto c6B8; else goto c6AG;
       c6B8: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6AG: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_c6AE_info;
           R3 = 64 - _s3HV::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6AE() //  [R1]
         { info_tbl: [(c6AE,
                       label: block_c6AE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AE: // global
           if (R1 & 7 == 1) goto c6AN; else goto u6Bb;
       c6AN: // global
           I64[Sp] = block_c6AK_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u6Be; else goto c6AO;
       u6Be: // global
           call _c6AK(R1) args: 0, res: 0, upd: 0;
       c6AO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u6Bb: // global
           Sp = Sp + 8;
           call _c6B5() args: 0, res: 0, upd: 0;
     }
 },
 _c6AK() //  [R1]
         { info_tbl: [(c6AK,
                       label: block_c6AK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AK: // global
           if (R1 & 7 == 1) goto c6AU; else goto u6Bc;
       c6AU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6AX; else goto c6AW;
       c6AX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AW: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u6Bc: // global
           Sp = Sp + 8;
           call _c6B5() args: 0, res: 0, upd: 0;
     }
 },
 _c6B5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B5: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.386868715 UTC

[section ""data" . GHC.Integer.Type.shiftRPositive_closure" {
     GHC.Integer.Type.shiftRPositive_closure:
         const GHC.Integer.Type.shiftRPositive_info;
 },
 GHC.Integer.Type.shiftRPositive_entry() //  [R2, R3]
         { info_tbl: [(c6BS,
                       label: GHC.Integer.Type.shiftRPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BT; else goto u6C9;
       c6BT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftRPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6C9: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6BI() args: 0, res: 0, upd: 0;
     }
 },
 _c6BI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BI: // global
           _s3I3::P64 = P64[Sp];
           I64[Sp] = block_c6BL_info;
           R1 = _s3I3::P64;
           if (R1 & 7 != 0) goto u6Cb; else goto c6BM;
       u6Cb: // global
           call _c6BL(R1) args: 0, res: 0, upd: 0;
       c6BM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6BL() //  [R1]
         { info_tbl: [(c6BL,
                       label: block_c6BL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BL: // global
           if (R1 & 7 == 1) goto c6BP; else goto c6BQ;
       c6BP: // global
           _s3I4::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s3I4::I64, 64)) goto c6C1; else goto c6C2;
       c6C1: // global
           R3 = _s3I4::I64;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallShiftRPositive_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       c6C2: // global
           P64[Sp] = P64[R1 + 7];
           I64[Sp + 8] = _s3I4::I64 - 64;
           call _c6BI() args: 0, res: 0, upd: 0;
       c6BQ: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.398631607 UTC

[section ""data" . GHC.Integer.Type.shiftRInteger_closure" {
     GHC.Integer.Type.shiftRInteger_closure:
         const GHC.Integer.Type.shiftRInteger_info;
         const 0;
 },
 GHC.Integer.Type.shiftRInteger_entry() //  [R2, R3]
         { info_tbl: [(c6CG,
                       label: GHC.Integer.Type.shiftRInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CH; else goto c6CI;
       c6CH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftRInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CI: // global
           I64[Sp - 16] = block_c6Cy_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6D3; else goto c6Cz;
       u6D3: // global
           call _c6Cy(R1) args: 0, res: 0, upd: 0;
       c6Cz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Cy() //  [R1]
         { info_tbl: [(c6Cy,
                       label: block_c6Cy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cy: // global
           _c6CF::P64 = R1 & 7;
           if (_c6CF::P64 < 3) goto u6D2; else goto c6CE;
       u6D2: // global
           if (_c6CF::P64 < 2) goto c6CC; else goto c6CD;
       c6CC: // global
           R3 = I64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRPositive_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
       c6CD: // global
           I64[Sp] = block_c6CO_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
       c6CE: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6CO() //  [R1]
         { info_tbl: [(c6CO,
                       label: block_c6CO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CO: // global
           _s3Ib::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c6CS_info;
           R3 = _s3Ib::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6CS() //  [R1]
         { info_tbl: [(c6CS,
                       label: block_c6CS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CS: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.413207267 UTC

[section ""data" . GHC.Integer.Type.shiftLPositive_closure" {
     GHC.Integer.Type.shiftLPositive_closure:
         const GHC.Integer.Type.shiftLPositive_info;
 },
 GHC.Integer.Type.shiftLPositive_entry() //  [R2, R3]
         { info_tbl: [(c6DF,
                       label: GHC.Integer.Type.shiftLPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6DG; else goto u6DL;
       c6DG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftLPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6DL: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6Dm() args: 0, res: 0, upd: 0;
     }
 },
 _c6Dm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dm: // global
           _s3Ih::P64 = P64[Sp];
           _s3Ii::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s3Ii::I64, 64)) goto c6DD; else goto c6DE;
       c6DD: // global
           R3 = _s3Ii::I64;
           R2 = _s3Ih::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       c6DE: // global
           I64[Sp] = block_c6Dt_info;
           R1 = _s3Ih::P64;
           if (R1 & 7 != 0) goto u6DN; else goto c6Du;
       u6DN: // global
           call _c6Dt(R1) args: 0, res: 0, upd: 0;
       c6Du: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Dt() //  [R1]
         { info_tbl: [(c6Dt,
                       label: block_c6Dt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6DK; else goto c6DJ;
       c6DK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DJ: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           P64[Sp] = Hp - 15;
           I64[Sp + 8] = I64[Sp + 8] - 64;
           call _c6Dm() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.422427247 UTC

[section ""data" . GHC.Integer.Type.shiftLInteger_closure" {
     GHC.Integer.Type.shiftLInteger_closure:
         const GHC.Integer.Type.shiftLInteger_info;
 },
 GHC.Integer.Type.shiftLInteger_entry() //  [R2, R3]
         { info_tbl: [(c6Ee,
                       label: GHC.Integer.Type.shiftLInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ee: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ef; else goto c6Eg;
       c6Ef: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftLInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Eg: // global
           I64[Sp - 16] = block_c6E6_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6EH; else goto c6E7;
       u6EH: // global
           call _c6E6(R1) args: 0, res: 0, upd: 0;
       c6E7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6E6() //  [R1]
         { info_tbl: [(c6E6,
                       label: block_c6E6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6E6: // global
           _c6Ed::P64 = R1 & 7;
           if (_c6Ed::P64 < 3) goto u6EG; else goto c6Ec;
       u6EG: // global
           _s3Io::I64 = I64[Sp + 8];
           if (_c6Ed::P64 < 2) goto c6Ea; else goto c6Eb;
       c6Ea: // global
           I64[Sp + 8] = block_c6Ej_info;
           R3 = _s3Io::I64;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLPositive_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
       c6Eb: // global
           I64[Sp + 8] = block_c6Eu_info;
           R3 = _s3Io::I64;
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLPositive_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
       c6Ec: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Ej() //  [R1]
         { info_tbl: [(c6Ej,
                       label: block_c6Ej_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ej: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Er; else goto c6Eq;
       c6Er: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Eq: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Eu() //  [R1]
         { info_tbl: [(c6Eu,
                       label: block_c6Eu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Eu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6EC; else goto c6EB;
       c6EC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6EB: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.436039451 UTC

[section ""data" . GHC.Integer.Type.some_closure" {
     GHC.Integer.Type.some_closure:
         const GHC.Integer.Type.some_info;
 },
 GHC.Integer.Type.some_entry() //  [R2, R3]
         { info_tbl: [(c6Fc,
                       label: GHC.Integer.Type.some_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Fc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Fd; else goto c6Fe;
       c6Fd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.some_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Fe: // global
           I64[Sp - 16] = block_c6F5_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Fw; else goto c6F6;
       u6Fw: // global
           call _c6F5(R1) args: 0, res: 0, upd: 0;
       c6F6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6F5() //  [R1]
         { info_tbl: [(c6F5,
                       label: block_c6F5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6F5: // global
           _s3Iu::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c6F9; else goto c6Fa;
       c6F9: // global
           Hp = Hp + 24;
           _s3Iw::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6Fp; else goto c6Fj;
       c6Fj: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = _s3Iw::P64;
           I64[Hp] = _s3Iu::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Fa: // global
           Hp = Hp + 24;
           _s3Iw::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6Fp; else goto c6Fo;
       c6Fp: // global
           HpAlloc = 24;
           R1 = _s3Iw::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Fo: // global
           if (_s3Iu::I64 == 0) goto c6Fv; else goto c6Fu;
       c6Fv: // global
           Hp = Hp - 24;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Fu: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s3Iu::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.450862685 UTC

[section ""data" . GHC.Integer.Type.quotRemPositive_g_closure" {
     GHC.Integer.Type.quotRemPositive_g_closure:
         const GHC.Integer.Type.quotRemPositive_g_info;
 },
 GHC.Integer.Type.quotRemPositive_g_entry() //  [R2, R3, R4]
         { info_tbl: [(c6FW,
                       label: GHC.Integer.Type.quotRemPositive_g_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6FW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6FX; else goto u6Gx;
       c6FX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemPositive_g_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u6Gx: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c6FM() args: 0, res: 0, upd: 0;
     }
 },
 _c6FM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6FM: // global
           I64[Sp - 8] = block_c6FP_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6GA; else goto c6FQ;
       u6GA: // global
           call _c6FP(R1) args: 0, res: 0, upd: 0;
       c6FQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6FP() //  [R1]
         { info_tbl: [(c6FP,
                       label: block_c6FP_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6FP: // global
           _s3IC::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6FT; else goto c6FU;
       c6FT: // global
           I64[Sp] = block_c6G1_info;
           R1 = _s3IC::P64;
           if (R1 & 7 != 0) goto u6GB; else goto c6G3;
       u6GB: // global
           call _c6G1(R1) args: 0, res: 0, upd: 0;
       c6G3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6FU: // global
           I64[Sp - 8] = block_c6Ga_info;
           _s3IF::P64 = P64[R1 + 6];
           R3 = _s3IF::P64;
           R2 = _s3IC::P64;
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 16] = _s3IF::P64;
           Sp = Sp - 8;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6G1() //  [R1]
         { info_tbl: [(c6G1,
                       label: block_c6G1_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6G1: // global
           R2 = R1;
           R1 = I64[Sp + 8];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Ga() //  [R1]
         { info_tbl: [(c6Ga,
                       label: block_c6Ga_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ga: // global
           _s3IC::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c6Gq; else goto c6Gi;
       c6Gq: // global
           I64[Sp + 16] = I64[Sp + 16] << 1;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _s3IC::P64;
           Sp = Sp + 16;
           call _c6FM() args: 0, res: 0, upd: 0;
       c6Gi: // global
           I64[Sp] = block_c6Gf_info;
           R3 = P64[Sp + 24];
           R2 = _s3IC::P64;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Gf() //  [R1]
         { info_tbl: [(c6Gf,
                       label: block_c6Gf_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Gf: // global
           I64[Sp + 16] = (I64[Sp + 16] << 1) + 1;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call _c6FM() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.475463824 UTC

[section ""data" . GHC.Integer.Type.quotRemPositive_closure" {
     GHC.Integer.Type.quotRemPositive_closure:
         const GHC.Integer.Type.quotRemPositive_info;
 },
 sat_s3IW_entry() //  [R1]
         { info_tbl: [(c6HC,
                       label: sat_s3IW_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6HC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6HD; else goto c6HE;
       c6HD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6HE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call mkSubtractors_s3IR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3IU_entry() //  [R1]
         { info_tbl: [(c6HJ,
                       label: sat_s3IU_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6HJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6HK; else goto c6HL;
       c6HK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6HL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 mkSubtractors_s3IR_entry() //  [R1, R2]
         { info_tbl: [(c6HP,
                       label: mkSubtractors_s3IR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6HP: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6HT; else goto c6HS;
       c6HT: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6HS: // global
           if (R2 == 0) goto c6HO; else goto c6HN;
       c6HO: // global
           _s3IQ::P64 = P64[R1 + 15];
           Hp = Hp - 88;
           R1 = _s3IQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6HN: // global
           _s3IO::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s3IW_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s3IU_info;
           P64[Hp - 32] = _s3IO::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 subtractors_s3IP_entry() //  [R1]
         { info_tbl: [(c6HV,
                       label: subtractors_s3IP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6HV: // global
           _s3IP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6HW; else goto c6HX;
       c6HX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6HZ; else goto c6HY;
       c6HZ: // global
           HpAlloc = 48;
           goto c6HW;
       c6HW: // global
           R1 = _s3IP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6HY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s3IP::P64;
           _s3IO::P64 = P64[_s3IP::P64 + 16];
           I64[Hp - 40] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 32] = _s3IO::P64;
           P64[Hp - 24] = GHC.Integer.Type.Nil_closure+1;
           I64[Hp - 16] = mkSubtractors_s3IR_info;
           P64[Hp - 8] = _s3IO::P64;
           P64[Hp] = Hp - 38;
           R2 = 63;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call mkSubtractors_s3IR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3Jc_entry() //  [R1]
         { info_tbl: [(c6Iq,
                       label: sat_s3Jc_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ir; else goto c6Is;
       c6Ir: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Is: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3Ji_entry() //  [R1]
         { info_tbl: [(c6IG,
                       label: sat_s3Ji_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IH; else goto c6II;
       c6IH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6II: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3Jm_entry() //  [R1]
         { info_tbl: [(c6IS,
                       label: sat_s3Jm_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IT; else goto c6IU;
       c6IT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 f2_s3IX_entry() //  [R1, R2]
         { info_tbl: [(c6IZ,
                       label: f2_s3IX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6J0; else goto c6J1;
       c6J0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6J1: // global
           I64[Sp - 24] = block_c6I5_info;
           _s3IX::P64 = R1;
           _s3IP::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s3IP::P64;
           P64[Sp - 8] = _s3IX::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6JA; else goto c6I6;
       u6JA: // global
           call _c6I5(R1) args: 0, res: 0, upd: 0;
       c6I6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6I5() //  [R1]
         { info_tbl: [(c6I5,
                       label: block_c6I5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I5: // global
           if (R1 & 7 == 1) goto c6IW; else goto c6IX;
       c6IW: // global
           I64[Sp] = block_c6Ia_info;
           R2 = P64[R1 + 7];
           _s3J0::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s3J0::I64;
           call f2_s3IX_entry(R2, R1) args: 8, res: 8, upd: 8;
       c6IX: // global
           R2 = GHC.Integer.Type.None_closure+2;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Ia() //  [R1, R2]
         { info_tbl: [(c6Ia,
                       label: block_c6Ia_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ia: // global
           I64[Sp - 8] = block_c6Ic_info;
           _s3J3::P64 = R1;
           R1 = R2;
           P64[Sp] = _s3J3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Jw; else goto c6Id;
       u6Jw: // global
           call _c6Ic(R1) args: 0, res: 0, upd: 0;
       c6Id: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ic() //  [R1]
         { info_tbl: [(c6Ic,
                       label: block_c6Ic_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ic: // global
           _s3IP::P64 = P64[Sp + 16];
           _s3J0::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c6J5; else goto c6Jc;
       c6J5: // global
           Hp = Hp + 24;
           _s3J5::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6Jf; else goto c6J7;
       c6J7: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = _s3J5::P64;
           I64[Hp] = _s3J0::I64;
           I64[Sp] = block_c6Ii_info;
           R4 = Hp - 15;
           R3 = _s3IP::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
       c6Jc: // global
           Hp = Hp + 24;
           _s3J5::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6Jf; else goto c6Je;
       c6Jf: // global
           HpAlloc = 24;
           R1 = _s3J5::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Je: // global
           if (_s3J0::I64 == 0) goto c6Jl; else goto c6Jh;
       c6Jl: // global
           Hp = Hp - 24;
           I64[Sp] = block_c6IK_info;
           R4 = GHC.Integer.Type.None_closure+2;
           R3 = _s3IP::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
       c6Jh: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s3J0::I64;
           I64[Sp] = block_c6Iy_info;
           R4 = Hp - 15;
           R3 = _s3IP::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ii() //  [R1, R2]
         { info_tbl: [(c6Ii,
                       label: block_c6Ii_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ii: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c6Ij() args: 0, res: 0, upd: 0;
     }
 },
 _c6Ij() //  []
         { info_tbl: [(c6Ij,
                       label: block_c6Ij_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ij: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Jb; else goto c6Ja;
       c6Jb: // global
           HpAlloc = 32;
           I64[Sp] = block_c6Ij_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c6Ja: // global
           I64[Hp - 24] = sat_s3Jc_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6IK() //  [R1, R2]
         { info_tbl: [(c6IK,
                       label: block_c6IK_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IK: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c6IL() args: 0, res: 0, upd: 0;
     }
 },
 _c6IL() //  []
         { info_tbl: [(c6IL,
                       label: block_c6IL_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Jo; else goto c6Jn;
       c6Jo: // global
           HpAlloc = 32;
           I64[Sp] = block_c6IL_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c6Jn: // global
           I64[Hp - 24] = sat_s3Jm_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Iy() //  [R1, R2]
         { info_tbl: [(c6Iy,
                       label: block_c6Iy_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iy: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c6Iz() args: 0, res: 0, upd: 0;
     }
 },
 _c6Iz() //  []
         { info_tbl: [(c6Iz,
                       label: block_c6Iz_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Jk; else goto c6Jj;
       c6Jk: // global
           HpAlloc = 32;
           I64[Sp] = block_c6Iz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c6Jj: // global
           I64[Hp - 24] = sat_s3Ji_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3Jr_entry() //  [R1]
         { info_tbl: [(c6JH,
                       label: sat_s3Jr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JI; else goto c6JJ;
       c6JI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.digitsMaybeZeroToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3Jq_entry() //  [R1]
         { info_tbl: [(c6JO,
                       label: sat_s3Jq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JP; else goto c6JQ;
       c6JP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.digitsMaybeZeroToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.quotRemPositive_entry() //  [R2, R3]
         { info_tbl: [(c6JR,
                       label: GHC.Integer.Type.quotRemPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JS; else goto c6JT;
       c6JS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JT: // global
           I64[Sp - 16] = block_c6Hf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6K0; else goto c6Hg;
       u6K0: // global
           call _c6Hf(R1) args: 0, res: 0, upd: 0;
       c6Hg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Hf() //  [R1]
         { info_tbl: [(c6Hf,
                       label: block_c6Hf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Hf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6JW; else goto c6JV;
       c6JW: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6JV: // global
           I64[Hp - 32] = subtractors_s3IP_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = f2_s3IX_info;
           P64[Hp] = Hp - 32;
           _s3IM::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6JB_info;
           R2 = _s3IM::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call f2_s3IX_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6JB() //  [R1, R2]
         { info_tbl: [(c6JB,
                       label: block_c6JB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6JZ; else goto c6JY;
       c6JZ: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c6JY: // global
           I64[Hp - 40] = sat_s3Jr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s3Jq_info;
           P64[Hp] = R1;
           R2 = Hp - 40;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.53487729 UTC

[section ""data" . GHC.Integer.Type.quotRemInteger_closure" {
     GHC.Integer.Type.quotRemInteger_closure:
         const GHC.Integer.Type.quotRemInteger_info;
 },
 sat_s3JE_entry() //  [R1]
         { info_tbl: [(c6Ma,
                       label: sat_s3JE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ma: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Mb; else goto c6Mc;
       c6Mb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Mc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3JM_entry() //  [R1]
         { info_tbl: [(c6Mq,
                       label: sat_s3JM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Mq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Mr; else goto c6Ms;
       c6Mr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ms: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3JL_entry() //  [R1]
         { info_tbl: [(c6Mx,
                       label: sat_s3JL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Mx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6My; else goto c6Mz;
       c6My: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Mz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3JR_entry() //  [R1]
         { info_tbl: [(c6MI,
                       label: sat_s3JR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6MI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6MJ; else goto c6MK;
       c6MJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6MK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.quotRemInteger_entry() //  [R2, R3]
         { info_tbl: [(c6MP,
                       label: GHC.Integer.Type.quotRemInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6MP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6MQ; else goto c6MR;
       c6MQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6MR: // global
           I64[Sp - 16] = block_c6LJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6NH; else goto c6LK;
       u6NH: // global
           call _c6LJ(R1) args: 0, res: 0, upd: 0;
       c6LK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6LJ() //  [R1]
         { info_tbl: [(c6LJ,
                       label: block_c6LJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6LJ: // global
           _s3Jt::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c6MN; else goto c6MM;
       c6MN: // global
           I64[Sp + 8] = block_c6Nr_info;
           R1 = _s3Jt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6ND; else goto c6Nt;
       u6ND: // global
           call _c6Nr() args: 0, res: 0, upd: 0;
       c6Nt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6MM: // global
           I64[Sp] = block_c6LO_info;
           _s3Ju::P64 = R1;
           R1 = _s3Jt::P64;
           P64[Sp + 8] = _s3Ju::P64;
           if (R1 & 7 != 0) goto u6NC; else goto c6LP;
       u6NC: // global
           call _c6LO(R1) args: 0, res: 0, upd: 0;
       c6LP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Nr() //  []
         { info_tbl: [(c6Nr,
                       label: block_c6Nr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Nr: // global
           R2 = GHC.Integer.Type.Naught_closure+3;
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6LO() //  [R1]
         { info_tbl: [(c6LO,
                       label: block_c6LO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6LO: // global
           if (R1 & 7 == 3) goto c6No; else goto c6MV;
       c6No: // global
           R2 = GHC.Integer.Type.errorInteger_closure+1;
           R1 = GHC.Integer.Type.errorInteger_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c6MV: // global
           I64[Sp] = block_c6LT_info;
           _s3Jv::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s3Jv::P64;
           if (R1 & 7 != 0) goto u6NE; else goto c6LU;
       u6NE: // global
           call _c6LT(R1) args: 0, res: 0, upd: 0;
       c6LU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6LT() //  [R1]
         { info_tbl: [(c6LT,
                       label: block_c6LT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6LT: // global
           _s3Jv::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c6MY; else goto c6N9;
       c6MY: // global
           I64[Sp] = block_c6LY_info;
           _s3Jx::P64 = P64[R1 + 7];
           R1 = _s3Jv::P64;
           P64[Sp + 8] = _s3Jx::P64;
           if (R1 & 7 != 0) goto u6NF; else goto c6LZ;
       u6NF: // global
           call _c6LY(R1) args: 0, res: 0, upd: 0;
       c6LZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6N9: // global
           I64[Sp] = block_c6Mf_info;
           _s3JF::P64 = P64[R1 + 6];
           R1 = _s3Jv::P64;
           P64[Sp + 8] = _s3JF::P64;
           if (R1 & 7 != 0) goto u6NG; else goto c6Mg;
       u6NG: // global
           call _c6Mf(R1) args: 0, res: 0, upd: 0;
       c6Mg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6LY() //  [R1]
         { info_tbl: [(c6LY,
                       label: block_c6LY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6LY: // global
           _s3Jx::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c6N2; else goto c6N4;
       c6N2: // global
           R3 = P64[R1 + 7];
           R2 = _s3Jx::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c6N4: // global
           I64[Sp + 8] = block_c6M4_info;
           R3 = P64[R1 + 6];
           R2 = _s3Jx::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6M4() //  [R1, R2]
         { info_tbl: [(c6M4,
                       label: block_c6M4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6M4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6N7; else goto c6N6;
       c6N7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c6N6: // global
           I64[Hp - 16] = sat_s3JE_info;
           P64[Hp] = R1;
           R2 = R2;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Mf() //  [R1]
         { info_tbl: [(c6Mf,
                       label: block_c6Mf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Mf: // global
           _s3JF::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c6Nc; else goto c6Nh;
       c6Nc: // global
           I64[Sp + 8] = block_c6Mk_info;
           R3 = P64[R1 + 7];
           R2 = _s3JF::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       c6Nh: // global
           I64[Sp + 8] = block_c6MC_info;
           R3 = P64[R1 + 6];
           R2 = _s3JF::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Mk() //  [R1, R2]
         { info_tbl: [(c6Mk,
                       label: block_c6Mk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Mk: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6Nf; else goto c6Ne;
       c6Nf: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c6Ne: // global
           I64[Hp - 40] = sat_s3JM_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s3JL_info;
           P64[Hp] = R1;
           R2 = Hp - 40;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6MC() //  [R1, R2]
         { info_tbl: [(c6MC,
                       label: block_c6MC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6MC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Nk; else goto c6Nj;
       c6Nk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c6Nj: // global
           I64[Hp - 16] = sat_s3JR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.573688292 UTC

[section ""data" . GHC.Integer.Type.divModInteger_closure" {
     GHC.Integer.Type.divModInteger_closure:
         const GHC.Integer.Type.divModInteger_info;
         const 0;
 },
 sat_s3K3_entry() //  [R1]
         { info_tbl: [(c6Pg,
                       label: sat_s3K3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Pg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ph; else goto c6Pi;
       c6Ph: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Pi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3K2_entry() //  [R1]
         { info_tbl: [(c6Pn,
                       label: sat_s3K2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Pn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Po; else goto c6Pp;
       c6Po: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Pp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Integer.Type.oneInteger_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.divModInteger_entry() //  [R2, R3]
         { info_tbl: [(c6Pq,
                       label: GHC.Integer.Type.divModInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Pq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Pr; else goto c6Ps;
       c6Pr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.divModInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Ps: // global
           I64[Sp - 16] = block_c6OT_info;
           _s3JU::P64 = R3;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = _s3JU::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6OT() //  [R1, R2]
         { info_tbl: [(c6OT,
                       label: block_c6OT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6OT: // global
           I64[Sp - 16] = block_c6OV_info;
           _s3JX::P64 = R2;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = _s3JX::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6OV() //  [R1]
         { info_tbl: [(c6OV,
                       label: block_c6OV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6OV: // global
           I64[Sp] = block_c6OZ_info;
           R2 = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6OZ() //  [R1]
         { info_tbl: [(c6OZ,
                       label: block_c6OZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6OZ: // global
           I64[Sp - 8] = block_c6P3_info;
           R2 = P64[Sp + 8];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6P3() //  [R1]
         { info_tbl: [(c6P3,
                       label: block_c6P3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6P3: // global
           _s3K0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6P7_info;
           R3 = _s3K0::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6P7() //  [R1]
         { info_tbl: [(c6P7,
                       label: block_c6P7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6P7: // global
           _s3JW::P64 = P64[Sp + 16];
           _s3JX::P64 = P64[Sp + 8];
           if (R1 == 1) goto c6PB; else goto c6PA;
       c6PB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6PE; else goto c6PD;
       c6PE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c6PD: // global
           I64[Hp - 48] = sat_s3K3_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s3JX::P64;
           I64[Hp - 16] = sat_s3K2_info;
           P64[Hp] = _s3JW::P64;
           R2 = Hp - 48;
           R1 = Hp - 16;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c6PA: // global
           R2 = _s3JX::P64;
           R1 = _s3JW::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.59548423 UTC

[section ""data" . GHC.Integer.Type.divInteger_closure" {
     GHC.Integer.Type.divInteger_closure:
         const GHC.Integer.Type.divInteger_info;
         const 0;
 },
 GHC.Integer.Type.divInteger_entry() //  [R2, R3]
         { info_tbl: [(c6Qg,
                       label: GHC.Integer.Type.divInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Qg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6Qh; else goto c6Qi;
       c6Qh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.divInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Qi: // global
           I64[Sp - 8] = block_c6Qe_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Qe() //  [R1]
         { info_tbl: [(c6Qe,
                       label: block_c6Qe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Qe: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.603287208 UTC

[section ""data" . GHC.Integer.Type.modInteger_closure" {
     GHC.Integer.Type.modInteger_closure:
         const GHC.Integer.Type.modInteger_info;
         const 0;
 },
 GHC.Integer.Type.modInteger_entry() //  [R2, R3]
         { info_tbl: [(c6QA,
                       label: GHC.Integer.Type.modInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6QA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6QB; else goto c6QC;
       c6QB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.modInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6QC: // global
           I64[Sp - 8] = block_c6Qy_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Qy() //  [R2]
         { info_tbl: [(c6Qy,
                       label: block_c6Qy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Qy: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.612669757 UTC

[section ""data" . GHC.Integer.Type.quotInteger_closure" {
     GHC.Integer.Type.quotInteger_closure:
         const GHC.Integer.Type.quotInteger_info;
 },
 GHC.Integer.Type.quotInteger_entry() //  [R2, R3]
         { info_tbl: [(c6QU,
                       label: GHC.Integer.Type.quotInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6QU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6QV; else goto c6QW;
       c6QV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6QW: // global
           I64[Sp - 8] = block_c6QS_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6QS() //  [R1]
         { info_tbl: [(c6QS,
                       label: block_c6QS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6QS: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.620867884 UTC

[section ""data" . GHC.Integer.Type.remInteger_closure" {
     GHC.Integer.Type.remInteger_closure:
         const GHC.Integer.Type.remInteger_info;
 },
 GHC.Integer.Type.remInteger_entry() //  [R2, R3]
         { info_tbl: [(c6Re,
                       label: GHC.Integer.Type.remInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Re: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6Rf; else goto c6Rg;
       c6Rf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.remInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Rg: // global
           I64[Sp - 8] = block_c6Rc_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Rc() //  [R2]
         { info_tbl: [(c6Rc,
                       label: block_c6Rc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Rc: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.628917297 UTC

[section ""data" . GHC.Integer.Type.andDigits_closure" {
     GHC.Integer.Type.andDigits_closure:
         const GHC.Integer.Type.andDigits_info;
 },
 GHC.Integer.Type.andDigits_entry() //  [R2, R3]
         { info_tbl: [(c6RD,
                       label: GHC.Integer.Type.andDigits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6RD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6RE; else goto c6RF;
       c6RE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6RF: // global
           I64[Sp - 16] = block_c6Rw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Si; else goto c6Rx;
       u6Si: // global
           call _c6Rw(R1) args: 0, res: 0, upd: 0;
       c6Rx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Rw() //  [R1]
         { info_tbl: [(c6Rw,
                       label: block_c6Rw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Rw: // global
           _s3Kp::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6RA; else goto c6RB;
       c6RA: // global
           I64[Sp - 8] = block_c6RI_info;
           _s3Ks::P64 = P64[R1 + 7];
           _s3Kr::I64 = I64[R1 + 15];
           R1 = _s3Kp::P64;
           P64[Sp] = _s3Ks::P64;
           I64[Sp + 8] = _s3Kr::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Sg; else goto c6RK;
       u6Sg: // global
           call _c6RI(R1) args: 0, res: 0, upd: 0;
       c6RK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6RB: // global
           I64[Sp + 8] = block_c6S8_info;
           R1 = _s3Kp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6Sh; else goto c6Sa;
       u6Sh: // global
           call _c6S8() args: 0, res: 0, upd: 0;
       c6Sa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6RI() //  [R1]
         { info_tbl: [(c6RI,
                       label: block_c6RI_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6RI: // global
           if (R1 & 7 == 1) goto c6RY; else goto c6S5;
       c6RY: // global
           I64[Sp] = block_c6RO_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c6S5: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6RO() //  [R1]
         { info_tbl: [(c6RO,
                       label: block_c6RO_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6RO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6S1; else goto c6S0;
       c6S1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6S0: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] & I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6S8() //  []
         { info_tbl: [(c6S8,
                       label: block_c6S8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6S8: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.6450759 UTC

[section ""data" . GHC.Integer.Type.andDigitsOnes_closure" {
     GHC.Integer.Type.andDigitsOnes_closure:
         const GHC.Integer.Type.andDigitsOnes_info;
 },
 GHC.Integer.Type.andDigitsOnes_entry() //  [R2, R3]
         { info_tbl: [(c6SY,
                       label: GHC.Integer.Type.andDigitsOnes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6SY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6SZ; else goto c6T0;
       c6SZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andDigitsOnes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6T0: // global
           I64[Sp - 16] = block_c6SR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Tw; else goto c6SS;
       u6Tw: // global
           call _c6SR(R1) args: 0, res: 0, upd: 0;
       c6SS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6SR() //  [R1]
         { info_tbl: [(c6SR,
                       label: block_c6SR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6SR: // global
           _s3KA::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6SV; else goto c6SW;
       c6SV: // global
           I64[Sp - 8] = block_c6T3_info;
           _s3KD::P64 = P64[R1 + 7];
           _s3KC::I64 = I64[R1 + 15];
           R1 = _s3KA::P64;
           P64[Sp] = _s3KD::P64;
           I64[Sp + 8] = _s3KC::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Tv; else goto c6T5;
       u6Tv: // global
           call _c6T3(R1) args: 0, res: 0, upd: 0;
       c6T5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6SW: // global
           R1 = _s3KA::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6T3() //  [R1]
         { info_tbl: [(c6T3,
                       label: block_c6T3_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6T3: // global
           if (R1 & 7 == 1) goto c6Tj; else goto c6Tq;
       c6Tj: // global
           I64[Sp] = block_c6T9_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c6Tq: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6T9() //  [R1]
         { info_tbl: [(c6T9,
                       label: block_c6T9_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6T9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Tm; else goto c6Tl;
       c6Tm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Tl: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] & I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.660864655 UTC

[section ""data" . GHC.Integer.Type.orDigits_closure" {
     GHC.Integer.Type.orDigits_closure:
         const GHC.Integer.Type.orDigits_info;
 },
 GHC.Integer.Type.orDigits_entry() //  [R2, R3]
         { info_tbl: [(c6U9,
                       label: GHC.Integer.Type.orDigits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6U9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Ua; else goto c6Ub;
       c6Ua: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.orDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Ub: // global
           I64[Sp - 16] = block_c6U2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6UH; else goto c6U3;
       u6UH: // global
           call _c6U2(R1) args: 0, res: 0, upd: 0;
       c6U3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6U2() //  [R1]
         { info_tbl: [(c6U2,
                       label: block_c6U2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6U2: // global
           _s3KK::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6U6; else goto c6U7;
       c6U6: // global
           I64[Sp - 16] = block_c6Ue_info;
           _s3KL::P64 = R1;
           _s3KN::P64 = P64[R1 + 7];
           _s3KM::I64 = I64[R1 + 15];
           R1 = _s3KK::P64;
           P64[Sp - 8] = _s3KN::P64;
           I64[Sp] = _s3KM::I64;
           P64[Sp + 8] = _s3KL::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6UG; else goto c6Ug;
       u6UG: // global
           call _c6Ue(R1) args: 0, res: 0, upd: 0;
       c6Ug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6U7: // global
           R1 = _s3KK::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Ue() //  [R1]
         { info_tbl: [(c6Ue,
                       label: block_c6Ue_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ue: // global
           if (R1 & 7 == 1) goto c6Uu; else goto c6UB;
       c6Uu: // global
           _s3KN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6Uk_info;
           R3 = P64[R1 + 7];
           R2 = _s3KN::P64;
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
       c6UB: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Uk() //  [R1]
         { info_tbl: [(c6Uk,
                       label: block_c6Uk_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Uk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Ux; else goto c6Uw;
       c6Ux: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Uw: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] | I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.676319682 UTC

[section ""data" . GHC.Integer.Type.orInteger_closure" {
     GHC.Integer.Type.orInteger_closure:
         const GHC.Integer.Type.orInteger_info;
 },
 GHC.Integer.Type.orInteger_entry() //  [R2, R3]
         { info_tbl: [(c6Vl,
                       label: GHC.Integer.Type.orInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Vl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Vm; else goto u6XG;
       c6Vm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.orInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6XG: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6Vb() args: 0, res: 0, upd: 0;
     }
 },
 _c6Vb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Vb: // global
           _s3KT::P64 = P64[Sp];
           I64[Sp] = block_c6Ve_info;
           R1 = _s3KT::P64;
           if (R1 & 7 != 0) goto u6XM; else goto c6Vf;
       u6XM: // global
           call _c6Ve(R1) args: 0, res: 0, upd: 0;
       c6Vf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ve() //  [R1]
         { info_tbl: [(c6Ve,
                       label: block_c6Ve_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ve: // global
           _s3KU::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c6Vj; else goto c6Vi;
       c6Vj: // global
           R1 = _s3KU::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6Vi: // global
           I64[Sp] = block_c6Vq_info;
           _s3KV::P64 = R1;
           R1 = _s3KU::P64;
           P64[Sp + 8] = _s3KV::P64;
           if (R1 & 7 != 0) goto u6XN; else goto c6Vs;
       u6XN: // global
           call _c6Vq(R1) args: 0, res: 0, upd: 0;
       c6Vs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Vq() //  [R1]
         { info_tbl: [(c6Vq,
                       label: block_c6Vq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Vq: // global
           _s3KV::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c6Xw; else goto c6Vz;
       c6Xw: // global
           R1 = _s3KV::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6Vz: // global
           I64[Sp] = block_c6Vw_info;
           _s3KW::P64 = R1;
           R1 = _s3KV::P64;
           P64[Sp + 8] = _s3KW::P64;
           if (R1 & 7 != 0) goto u6XP; else goto c6VA;
       u6XP: // global
           call _c6Vw(R1) args: 0, res: 0, upd: 0;
       c6VA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Vw() //  [R1]
         { info_tbl: [(c6Vw,
                       label: block_c6Vw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Vw: // global
           _s3KW::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c6VH; else goto c6WG;
       c6VH: // global
           I64[Sp] = block_c6VE_info;
           _s3KY::P64 = P64[R1 + 7];
           R1 = _s3KW::P64;
           P64[Sp + 8] = _s3KY::P64;
           if (R1 & 7 != 0) goto u6XQ; else goto c6VI;
       u6XQ: // global
           call _c6VE(R1) args: 0, res: 0, upd: 0;
       c6VI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6WG: // global
           I64[Sp - 8] = block_c6WE_info;
           _s3KX::P64 = R1;
           _s3Ld::P64 = P64[R1 + 6];
           R1 = _s3KW::P64;
           P64[Sp] = _s3Ld::P64;
           P64[Sp + 8] = _s3KX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6XR; else goto c6WH;
       u6XR: // global
           call _c6WE(R1) args: 0, res: 0, upd: 0;
       c6WH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6VE() //  [R1]
         { info_tbl: [(c6VE,
                       label: block_c6VE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6VE: // global
           if (R1 & 7 < 2) goto c6VT; else goto c6W9;
       c6VT: // global
           _s3KY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6VM_info;
           R3 = P64[R1 + 7];
           R2 = _s3KY::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
       c6W9: // global
           I64[Sp] = block_c6VZ_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6VM() //  [R1]
         { info_tbl: [(c6VM,
                       label: block_c6VM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6VM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6VW; else goto c6VV;
       c6VW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6VV: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6VZ() //  [R1]
         { info_tbl: [(c6VZ,
                       label: block_c6VZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6VZ: // global
           I64[Sp] = block_c6W3_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6W3() //  [R1]
         { info_tbl: [(c6W3,
                       label: block_c6W3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6W3: // global
           _s3L4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6W7_info;
           R3 = _s3L4::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6W7() //  [R1]
         { info_tbl: [(c6W7,
                       label: block_c6W7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6W7: // global
           I64[Sp] = block_c6Wf_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Wf() //  [R1, R2]
         { info_tbl: [(c6Wf,
                       label: block_c6Wf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Wf: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c6Wg() args: 0, res: 0, upd: 0;
     }
 },
 _c6Wg() //  []
         { info_tbl: [(c6Wg,
                       label: block_c6Wg_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Wg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Wo; else goto c6Wn;
       c6Wo: // global
           HpAlloc = 24;
           I64[Sp] = block_c6Wg_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c6Wn: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c6Wk_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Wk() //  [R1]
         { info_tbl: [(c6Wk,
                       label: block_c6Wk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Wk: // global
           if (R1 & 7 == 1) goto c6Wu; else goto u6XI;
       c6Wu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Wx; else goto c6Ww;
       c6Wx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Ww: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u6XI: // global
           Sp = Sp + 8;
           call _c6Xs() args: 0, res: 0, upd: 0;
     }
 },
 _c6WE() //  [R1]
         { info_tbl: [(c6WE,
                       label: block_c6WE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6WE: // global
           if (R1 & 7 < 2) goto c6WN; else goto c6X0;
       c6WN: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c6Vb() args: 0, res: 0, upd: 0;
       c6X0: // global
           I64[Sp] = block_c6WQ_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6WQ() //  [R1]
         { info_tbl: [(c6WQ,
                       label: block_c6WQ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6WQ: // global
           _s3Ld::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6WU_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s3Ld::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6WU() //  [R1]
         { info_tbl: [(c6WU,
                       label: block_c6WU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6WU: // global
           _s3Li::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6WY_info;
           R3 = _s3Li::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6WY() //  [R1]
         { info_tbl: [(c6WY,
                       label: block_c6WY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6WY: // global
           I64[Sp] = block_c6X6_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6X6() //  [R1, R2]
         { info_tbl: [(c6X6,
                       label: block_c6X6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6X6: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c6X7() args: 0, res: 0, upd: 0;
     }
 },
 _c6X7() //  []
         { info_tbl: [(c6X7,
                       label: block_c6X7_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6X7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Xf; else goto c6Xe;
       c6Xf: // global
           HpAlloc = 24;
           I64[Sp] = block_c6X7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c6Xe: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c6Xb_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Xb() //  [R1]
         { info_tbl: [(c6Xb,
                       label: block_c6Xb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Xb: // global
           if (R1 & 7 == 1) goto c6Xl; else goto u6XL;
       c6Xl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Xo; else goto c6Xn;
       c6Xo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Xn: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u6XL: // global
           Sp = Sp + 8;
           call _c6Xs() args: 0, res: 0, upd: 0;
     }
 },
 _c6Xs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Xs: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.730277244 UTC

[section ""data" . GHC.Integer.Type.mkInteger_f_closure" {
     GHC.Integer.Type.mkInteger_f_closure:
         const GHC.Integer.Type.mkInteger_f_info;
 },
 GHC.Integer.Type.mkInteger_f_entry() //  [R2]
         { info_tbl: [(c6ZF,
                       label: GHC.Integer.Type.mkInteger_f_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ZF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ZG; else goto c6ZH;
       c6ZG: // global
           R2 = R2;
           R1 = GHC.Integer.Type.mkInteger_f_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ZH: // global
           I64[Sp - 8] = block_c6Zy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u70a; else goto c6Zz;
       u70a: // global
           call _c6Zy(R1) args: 0, res: 0, upd: 0;
       c6Zz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Zy() //  [R1]
         { info_tbl: [(c6Zy,
                       label: block_c6Zy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Zy: // global
           if (R1 & 7 == 1) goto c6ZC; else goto c6ZD;
       c6ZC: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6ZD: // global
           I64[Sp - 8] = block_c6ZN_info;
           _s3Lu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s3Lu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u709; else goto c6ZO;
       u709: // global
           call _c6ZN(R1) args: 0, res: 0, upd: 0;
       c6ZO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ZN() //  [R1]
         { info_tbl: [(c6ZN,
                       label: block_c6ZN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ZN: // global
           I64[Sp] = block_c6ZS_info;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6ZS() //  [R1]
         { info_tbl: [(c6ZS,
                       label: block_c6ZS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ZS: // global
           I64[Sp] = block_c6ZW_info;
           R3 = 31;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6ZW() //  [R1]
         { info_tbl: [(c6ZW,
                       label: block_c6ZW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ZW: // global
           I64[Sp] = block_c700_info;
           R2 = I64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c700() //  [R1]
         { info_tbl: [(c700,
                       label: block_c700_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c700: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.753507731 UTC

[section ""data" . GHC.Integer.Type.mkInteger_closure" {
     GHC.Integer.Type.mkInteger_closure:
         const GHC.Integer.Type.mkInteger_info;
 },
 GHC.Integer.Type.mkInteger_entry() //  [R2, R3]
         { info_tbl: [(c70M,
                       label: GHC.Integer.Type.mkInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c70M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c70N; else goto c70O;
       c70N: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.mkInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c70O: // global
           I64[Sp - 16] = block_c70F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u710; else goto c70G;
       u710: // global
           call _c70F(R1) args: 0, res: 0, upd: 0;
       c70G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c70F() //  [R1]
         { info_tbl: [(c70F,
                       label: block_c70F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c70F: // global
           _s3LB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c70J; else goto c70K;
       c70J: // global
           I64[Sp + 8] = block_c70R_info;
           R2 = _s3LB::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 8, upd: 8;
       c70K: // global
           R2 = _s3LB::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c70R() //  [R1]
         { info_tbl: [(c70R,
                       label: block_c70R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c70R: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.770926218 UTC

[section ""data" . GHC.Integer.Type.andInteger_closure" {
     GHC.Integer.Type.andInteger_closure:
         const GHC.Integer.Type.andInteger_info;
 },
 GHC.Integer.Type.andInteger_entry() //  [R2, R3]
         { info_tbl: [(c71q,
                       label: GHC.Integer.Type.andInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c71q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c71r; else goto u73V;
       c71r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u73V: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c71g() args: 0, res: 0, upd: 0;
     }
 },
 _c71g() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c71g: // global
           _s3LE::P64 = P64[Sp];
           I64[Sp] = block_c71j_info;
           R1 = _s3LE::P64;
           if (R1 & 7 != 0) goto u742; else goto c71k;
       u742: // global
           call _c71j(R1) args: 0, res: 0, upd: 0;
       c71k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c71j() //  [R1]
         { info_tbl: [(c71j,
                       label: block_c71j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c71j: // global
           _s3LF::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c71o; else goto c71n;
       c71o: // global
           I64[Sp + 8] = block_c73H_info;
           R1 = _s3LF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u744; else goto c73J;
       u744: // global
           call _c73H() args: 0, res: 0, upd: 0;
       c73J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c71n: // global
           I64[Sp] = block_c71v_info;
           _s3LG::P64 = R1;
           R1 = _s3LF::P64;
           P64[Sp + 8] = _s3LG::P64;
           if (R1 & 7 != 0) goto u743; else goto c71x;
       u743: // global
           call _c71v(R1) args: 0, res: 0, upd: 0;
       c71x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c73H() //  []
         { info_tbl: [(c73H,
                       label: block_c73H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c73H: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c71v() //  [R1]
         { info_tbl: [(c71v,
                       label: block_c71v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c71v: // global
           if (R1 & 7 == 3) goto u73W; else goto c71E;
       u73W: // global
           Sp = Sp + 16;
           call _c73E() args: 0, res: 0, upd: 0;
       c71E: // global
           I64[Sp] = block_c71B_info;
           _s3LH::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s3LH::P64;
           if (R1 & 7 != 0) goto u746; else goto c71F;
       u746: // global
           call _c71B(R1) args: 0, res: 0, upd: 0;
       c71F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c71B() //  [R1]
         { info_tbl: [(c71B,
                       label: block_c71B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c71B: // global
           _s3LH::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c71M; else goto c72O;
       c71M: // global
           I64[Sp] = block_c71J_info;
           _s3LJ::P64 = P64[R1 + 7];
           R1 = _s3LH::P64;
           P64[Sp + 8] = _s3LJ::P64;
           if (R1 & 7 != 0) goto u748; else goto c71N;
       u748: // global
           call _c71J(R1) args: 0, res: 0, upd: 0;
       c71N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c72O: // global
           I64[Sp - 8] = block_c72M_info;
           _s3LI::P64 = R1;
           _s3LX::P64 = P64[R1 + 6];
           R1 = _s3LH::P64;
           P64[Sp] = _s3LX::P64;
           P64[Sp + 8] = _s3LI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u749; else goto c72P;
       u749: // global
           call _c72M(R1) args: 0, res: 0, upd: 0;
       c72P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c71J() //  [R1]
         { info_tbl: [(c71J,
                       label: block_c71J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c71J: // global
           if (R1 & 7 < 2) goto c71U; else goto c72p;
       c71U: // global
           _s3LJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c71R_info;
           R3 = P64[R1 + 7];
           R2 = _s3LJ::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c72p: // global
           I64[Sp] = block_c72f_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c71R() //  [R1]
         { info_tbl: [(c71R,
                       label: block_c71R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c71R: // global
           I64[Sp] = block_c71Y_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c71Y() //  [R1]
         { info_tbl: [(c71Y,
                       label: block_c71Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c71Y: // global
           if (R1 & 7 == 1) goto c725; else goto u73X;
       c725: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c728; else goto c727;
       c728: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c727: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u73X: // global
           Sp = Sp + 8;
           call _c73E() args: 0, res: 0, upd: 0;
     }
 },
 _c72f() //  [R1]
         { info_tbl: [(c72f,
                       label: block_c72f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c72f: // global
           I64[Sp] = block_c72j_info;
           R2 = R1;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c72j() //  [R1]
         { info_tbl: [(c72j,
                       label: block_c72j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c72j: // global
           _s3LJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c72n_info;
           R3 = _s3LJ::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c72n() //  [R1]
         { info_tbl: [(c72n,
                       label: block_c72n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c72n: // global
           I64[Sp] = block_c72v_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c72v() //  [R1]
         { info_tbl: [(c72v,
                       label: block_c72v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c72v: // global
           if (R1 & 7 == 1) goto c72C; else goto u73Y;
       c72C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c72F; else goto c72E;
       c72F: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c72E: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u73Y: // global
           Sp = Sp + 8;
           call _c73E() args: 0, res: 0, upd: 0;
     }
 },
 _c72M() //  [R1]
         { info_tbl: [(c72M,
                       label: block_c72M_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c72M: // global
           if (R1 & 7 < 2) goto c72V; else goto c738;
       c72V: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c71g() args: 0, res: 0, upd: 0;
       c738: // global
           I64[Sp] = block_c72Y_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c72Y() //  [R1]
         { info_tbl: [(c72Y,
                       label: block_c72Y_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c72Y: // global
           _s3LX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c732_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s3LX::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c732() //  [R1]
         { info_tbl: [(c732,
                       label: block_c732_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c732: // global
           _s3M2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c736_info;
           R3 = _s3M2::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c736() //  [R1]
         { info_tbl: [(c736,
                       label: block_c736_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c736: // global
           I64[Sp] = block_c73e_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c73e() //  [R1, R2]
         { info_tbl: [(c73e,
                       label: block_c73e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c73e: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c73f() args: 0, res: 0, upd: 0;
     }
 },
 _c73f() //  []
         { info_tbl: [(c73f,
                       label: block_c73f_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c73f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c73n; else goto c73m;
       c73n: // global
           HpAlloc = 24;
           I64[Sp] = block_c73f_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c73m: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c73j_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c73j() //  [R1]
         { info_tbl: [(c73j,
                       label: block_c73j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c73j: // global
           if (R1 & 7 == 1) goto c73t; else goto u741;
       c73t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c73w; else goto c73v;
       c73w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c73v: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u741: // global
           Sp = Sp + 8;
           call _c73E() args: 0, res: 0, upd: 0;
     }
 },
 _c73E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c73E: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.83323068 UTC

[section ""data" . GHC.Integer.Type.testBitInteger_closure" {
     GHC.Integer.Type.testBitInteger_closure:
         const GHC.Integer.Type.testBitInteger_info;
 },
 GHC.Integer.Type.testBitInteger_entry() //  [R2, R3]
         { info_tbl: [(c75Q,
                       label: GHC.Integer.Type.testBitInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Y; else goto c75Z;
       c75Y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.testBitInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c75Z: // global
           I64[Sp - 16] = block_c75O_info;
           R3 = R3;
           _s3Mc::P64 = R2;
           R2 = GHC.Integer.Type.oneInteger_closure+1;
           P64[Sp - 8] = _s3Mc::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c75O() //  [R1]
         { info_tbl: [(c75O,
                       label: block_c75O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75O: // global
           _s3Mc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c75T_info;
           R3 = R1;
           R2 = _s3Mc::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c75T() //  [R1]
         { info_tbl: [(c75T,
                       label: block_c75T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75T: // global
           I64[Sp] = block_c75X_info;
           R3 = GHC.Integer.Type.Naught_closure+3;
           R2 = R1;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c75X() //  [R1]
         { info_tbl: [(c75X,
                       label: block_c75X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75X: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.84746229 UTC

[section ""data" . GHC.Integer.Type.xorDigits_closure" {
     GHC.Integer.Type.xorDigits_closure:
         const GHC.Integer.Type.xorDigits_info;
 },
 GHC.Integer.Type.xorDigits_entry() //  [R2, R3]
         { info_tbl: [(c76x,
                       label: GHC.Integer.Type.xorDigits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76x: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c76y; else goto c76z;
       c76y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.xorDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c76z: // global
           I64[Sp - 16] = block_c76q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u775; else goto c76r;
       u775: // global
           call _c76q(R1) args: 0, res: 0, upd: 0;
       c76r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c76q() //  [R1]
         { info_tbl: [(c76q,
                       label: block_c76q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76q: // global
           _s3Mi::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c76u; else goto c76v;
       c76u: // global
           I64[Sp - 16] = block_c76C_info;
           _s3Mj::P64 = R1;
           _s3Ml::P64 = P64[R1 + 7];
           _s3Mk::I64 = I64[R1 + 15];
           R1 = _s3Mi::P64;
           P64[Sp - 8] = _s3Ml::P64;
           I64[Sp] = _s3Mk::I64;
           P64[Sp + 8] = _s3Mj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u774; else goto c76E;
       u774: // global
           call _c76C(R1) args: 0, res: 0, upd: 0;
       c76E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c76v: // global
           R1 = _s3Mi::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c76C() //  [R1]
         { info_tbl: [(c76C,
                       label: block_c76C_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76C: // global
           if (R1 & 7 == 1) goto c76S; else goto c76Z;
       c76S: // global
           _s3Ml::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c76I_info;
           R3 = P64[R1 + 7];
           R2 = _s3Ml::P64;
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c76Z: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c76I() //  [R1]
         { info_tbl: [(c76I,
                       label: block_c76I_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76V; else goto c76U;
       c76V: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c76U: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] ^ I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.864214392 UTC

[section ""data" . GHC.Integer.Type.xorInteger_closure" {
     GHC.Integer.Type.xorInteger_closure:
         const GHC.Integer.Type.xorInteger_info;
 },
 GHC.Integer.Type.xorInteger_entry() //  [R2, R3]
         { info_tbl: [(c77J,
                       label: GHC.Integer.Type.xorInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77J: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c77K; else goto u7a3;
       c77K: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.xorInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u7a3: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c77z() args: 0, res: 0, upd: 0;
     }
 },
 _c77z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77z: // global
           _s3Mr::P64 = P64[Sp];
           I64[Sp] = block_c77C_info;
           R1 = _s3Mr::P64;
           if (R1 & 7 != 0) goto u7a9; else goto c77D;
       u7a9: // global
           call _c77C(R1) args: 0, res: 0, upd: 0;
       c77D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c77C() //  [R1]
         { info_tbl: [(c77C,
                       label: block_c77C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77C: // global
           _s3Ms::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c77H; else goto c77G;
       c77H: // global
           R1 = _s3Ms::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c77G: // global
           I64[Sp] = block_c77O_info;
           _s3Mt::P64 = R1;
           R1 = _s3Ms::P64;
           P64[Sp + 8] = _s3Mt::P64;
           if (R1 & 7 != 0) goto u7aa; else goto c77Q;
       u7aa: // global
           call _c77O(R1) args: 0, res: 0, upd: 0;
       c77Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c77O() //  [R1]
         { info_tbl: [(c77O,
                       label: block_c77O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77O: // global
           _s3Mt::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c79S; else goto c77X;
       c79S: // global
           R1 = _s3Mt::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c77X: // global
           I64[Sp] = block_c77U_info;
           _s3Mu::P64 = R1;
           R1 = _s3Mt::P64;
           P64[Sp + 8] = _s3Mu::P64;
           if (R1 & 7 != 0) goto u7ac; else goto c77Y;
       u7ac: // global
           call _c77U(R1) args: 0, res: 0, upd: 0;
       c77Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c77U() //  [R1]
         { info_tbl: [(c77U,
                       label: block_c77U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77U: // global
           _s3Mu::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c785; else goto c79a;
       c785: // global
           I64[Sp] = block_c782_info;
           _s3Mw::P64 = P64[R1 + 7];
           R1 = _s3Mu::P64;
           P64[Sp + 8] = _s3Mw::P64;
           if (R1 & 7 != 0) goto u7ad; else goto c786;
       u7ad: // global
           call _c782(R1) args: 0, res: 0, upd: 0;
       c786: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c79a: // global
           I64[Sp - 8] = block_c798_info;
           _s3Mv::P64 = R1;
           _s3MN::P64 = P64[R1 + 6];
           R1 = _s3Mu::P64;
           P64[Sp] = _s3MN::P64;
           P64[Sp + 8] = _s3Mv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ae; else goto c79b;
       u7ae: // global
           call _c798(R1) args: 0, res: 0, upd: 0;
       c79b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c782() //  [R1]
         { info_tbl: [(c782,
                       label: block_c782_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c782: // global
           if (R1 & 7 < 2) goto c78d; else goto c78E;
       c78d: // global
           _s3Mw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c78a_info;
           R3 = P64[R1 + 7];
           R2 = _s3Mw::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c78E: // global
           I64[Sp] = block_c78y_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c78a() //  [R1]
         { info_tbl: [(c78a,
                       label: block_c78a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c78a: // global
           I64[Sp] = block_c78h_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c78h() //  [R1]
         { info_tbl: [(c78h,
                       label: block_c78h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c78h: // global
           if (R1 & 7 == 1) goto c78o; else goto u7a4;
       c78o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c78r; else goto c78q;
       c78r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c78q: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7a4: // global
           Sp = Sp + 8;
           call _c79O() args: 0, res: 0, upd: 0;
     }
 },
 _c78y() //  [R1]
         { info_tbl: [(c78y,
                       label: block_c78y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c78y: // global
           _s3Mw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c78C_info;
           R3 = R1;
           R2 = _s3Mw::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c78C() //  [R1]
         { info_tbl: [(c78C,
                       label: block_c78C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c78C: // global
           I64[Sp] = block_c78J_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c78J() //  [R1, R2]
         { info_tbl: [(c78J,
                       label: block_c78J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c78J: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c78K() args: 0, res: 0, upd: 0;
     }
 },
 _c78K() //  []
         { info_tbl: [(c78K,
                       label: block_c78K_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c78K: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c78S; else goto c78R;
       c78S: // global
           HpAlloc = 24;
           I64[Sp] = block_c78K_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c78R: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c78O_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c78O() //  [R1]
         { info_tbl: [(c78O,
                       label: block_c78O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c78O: // global
           if (R1 & 7 == 1) goto c78Y; else goto u7a6;
       c78Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c791; else goto c790;
       c791: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c790: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7a6: // global
           Sp = Sp + 8;
           call _c79O() args: 0, res: 0, upd: 0;
     }
 },
 _c798() //  [R1]
         { info_tbl: [(c798,
                       label: block_c798_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c798: // global
           if (R1 & 7 < 2) goto c79h; else goto c79u;
       c79h: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c77z() args: 0, res: 0, upd: 0;
       c79u: // global
           I64[Sp] = block_c79k_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c79k() //  [R1]
         { info_tbl: [(c79k,
                       label: block_c79k_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c79k: // global
           _s3MN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c79o_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s3MN::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c79o() //  [R1]
         { info_tbl: [(c79o,
                       label: block_c79o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c79o: // global
           _s3MS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c79s_info;
           R3 = _s3MS::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c79s() //  [R1]
         { info_tbl: [(c79s,
                       label: block_c79s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c79s: // global
           I64[Sp] = block_c79A_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c79A() //  [R1]
         { info_tbl: [(c79A,
                       label: block_c79A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c79A: // global
           if (R1 & 7 == 1) goto c79H; else goto u7a8;
       c79H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c79K; else goto c79J;
       c79K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c79J: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7a8: // global
           Sp = Sp + 8;
           call _c79O() args: 0, res: 0, upd: 0;
     }
 },
 _c79O() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c79O: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.911891499 UTC

[section ""cstring" . GHC.Integer.Type.$trModule4_bytes" {
     GHC.Integer.Type.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.914931187 UTC

[section ""data" . GHC.Integer.Type.$trModule3_closure" {
     GHC.Integer.Type.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.917517068 UTC

[section ""cstring" . GHC.Integer.Type.$trModule2_bytes" {
     GHC.Integer.Type.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.920461769 UTC

[section ""data" . GHC.Integer.Type.$trModule1_closure" {
     GHC.Integer.Type.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.923880608 UTC

[section ""data" . GHC.Integer.Type.$trModule_closure" {
     GHC.Integer.Type.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Type.$trModule3_closure+1;
         const GHC.Integer.Type.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.926246706 UTC

[section ""data" . $krep_r3Bp_closure" {
     $krep_r3Bp_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.92894485 UTC

[section ""data" . $krep1_r3Bq_closure" {
     $krep1_r3Bq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.931694931 UTC

[section ""cstring" . GHC.Integer.Type.$tcDigits2_bytes" {
     GHC.Integer.Type.$tcDigits2_bytes:
         I8[] [68,105,103,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.936020096 UTC

[section ""data" . GHC.Integer.Type.$tcDigits1_closure" {
     GHC.Integer.Type.$tcDigits1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcDigits2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.938825903 UTC

[section ""data" . GHC.Integer.Type.$tcDigits_closure" {
     GHC.Integer.Type.$tcDigits_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcDigits1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16647862651490579480;
         const 7069031713090282797;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.94147147 UTC

[section ""data" . GHC.Integer.Type.$tc'None1_closure" {
     GHC.Integer.Type.$tc'None1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcDigits_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.944294331 UTC

[section ""cstring" . GHC.Integer.Type.$tc'None3_bytes" {
     GHC.Integer.Type.$tc'None3_bytes:
         I8[] [39,78,111,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.947225341 UTC

[section ""data" . GHC.Integer.Type.$tc'None2_closure" {
     GHC.Integer.Type.$tc'None2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'None3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.950359178 UTC

[section ""data" . GHC.Integer.Type.$tc'None_closure" {
     GHC.Integer.Type.$tc'None_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'None2_closure+1;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const 903679638320298226;
         const 12977397153301278560;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.953760568 UTC

[section ""data" . $krep2_r3Br_closure" {
     $krep2_r3Br_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.957477763 UTC

[section ""data" . GHC.Integer.Type.$tc'Some1_closure" {
     GHC.Integer.Type.$tc'Some1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r3Bq_closure+1;
         const $krep2_r3Br_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.960571665 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Some3_bytes" {
     GHC.Integer.Type.$tc'Some3_bytes:
         I8[] [39,83,111,109,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.963692575 UTC

[section ""data" . GHC.Integer.Type.$tc'Some2_closure" {
     GHC.Integer.Type.$tc'Some2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Some3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.966968103 UTC

[section ""data" . GHC.Integer.Type.$tc'Some_closure" {
     GHC.Integer.Type.$tc'Some_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Some2_closure+1;
         const GHC.Integer.Type.$tc'Some1_closure+4;
         const 6045911439621864566;
         const 9702873355935012388;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.970851448 UTC

[section ""cstring" . GHC.Integer.Type.$tcInteger2_bytes" {
     GHC.Integer.Type.$tcInteger2_bytes:
         I8[] [73,110,116,101,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.97409868 UTC

[section ""data" . GHC.Integer.Type.$tcInteger1_closure" {
     GHC.Integer.Type.$tcInteger1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcInteger2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.977125312 UTC

[section ""data" . GHC.Integer.Type.$tcInteger_closure" {
     GHC.Integer.Type.$tcInteger_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcInteger1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12260413788024328428;
         const 9583620696682509916;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.980513515 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught1_closure" {
     GHC.Integer.Type.$tc'Naught1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.983946706 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Naught3_bytes" {
     GHC.Integer.Type.$tc'Naught3_bytes:
         I8[] [39,78,97,117,103,104,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.986761963 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught2_closure" {
     GHC.Integer.Type.$tc'Naught2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Naught3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.989858189 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught_closure" {
     GHC.Integer.Type.$tc'Naught_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Naught2_closure+1;
         const GHC.Integer.Type.$tc'Naught1_closure+1;
         const 7287704174224038176;
         const 776397532388787230;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.992559572 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative1_closure" {
     GHC.Integer.Type.$tc'Negative1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const GHC.Integer.Type.$tc'Naught1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.99576222 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Positive2_bytes" {
     GHC.Integer.Type.$tc'Positive2_bytes:
         I8[] [39,80,111,115,105,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:50.99848052 UTC

[section ""data" . GHC.Integer.Type.$tc'Positive1_closure" {
     GHC.Integer.Type.$tc'Positive1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Positive2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.001175284 UTC

[section ""data" . GHC.Integer.Type.$tc'Positive_closure" {
     GHC.Integer.Type.$tc'Positive_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Positive1_closure+1;
         const GHC.Integer.Type.$tc'Negative1_closure+4;
         const 6887932004110746796;
         const 9391890139750561935;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.00404343 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Negative3_bytes" {
     GHC.Integer.Type.$tc'Negative3_bytes:
         I8[] [39,78,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.007355592 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative2_closure" {
     GHC.Integer.Type.$tc'Negative2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Negative3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.010572987 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative_closure" {
     GHC.Integer.Type.$tc'Negative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Negative2_closure+1;
         const GHC.Integer.Type.$tc'Negative1_closure+4;
         const 4010847856516363452;
         const 15624358648337932456;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.013389637 UTC

[section ""cstring" . GHC.Integer.Type.$tcList2_bytes" {
     GHC.Integer.Type.$tcList2_bytes:
         I8[] [76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.015992392 UTC

[section ""data" . GHC.Integer.Type.$tcList1_closure" {
     GHC.Integer.Type.$tcList1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcList2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.018369144 UTC

[section ""data" . GHC.Integer.Type.$tcList_closure" {
     GHC.Integer.Type.$tcList_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 732340346576824023;
         const 9653115931589988500;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.021340747 UTC

[section ""data" . $krep3_r3Bs_closure" {
     $krep3_r3Bs_closure:
         const :_con_info;
         const $krep_r3Bp_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.023631692 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil1_closure" {
     GHC.Integer.Type.$tc'Nil1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcList_closure+1;
         const $krep3_r3Bs_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.02613122 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Nil3_bytes" {
     GHC.Integer.Type.$tc'Nil3_bytes:
         I8[] [39,78,105,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.028709211 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil2_closure" {
     GHC.Integer.Type.$tc'Nil2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Nil3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.031757901 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil_closure" {
     GHC.Integer.Type.$tc'Nil_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Nil2_closure+1;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const 13538585131509945451;
         const 9366316088405446135;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.034315028 UTC

[section ""data" . $krep4_r3Bt_closure" {
     $krep4_r3Bt_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.036857822 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons1_closure" {
     GHC.Integer.Type.$tc'Cons1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r3Bp_closure+2;
         const $krep4_r3Bt_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.039636983 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Cons3_bytes" {
     GHC.Integer.Type.$tc'Cons3_bytes:
         I8[] [39,67,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.042765612 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons2_closure" {
     GHC.Integer.Type.$tc'Cons2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Cons3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.045335753 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons_closure" {
     GHC.Integer.Type.$tc'Cons_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Cons2_closure+1;
         const GHC.Integer.Type.$tc'Cons1_closure+4;
         const 3906777924842222150;
         const 5463288556346842885;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.047919071 UTC

[section ""cstring" . GHC.Integer.Type.$tcDigitsOnes2_bytes" {
     GHC.Integer.Type.$tcDigitsOnes2_bytes:
         I8[] [68,105,103,105,116,115,79,110,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.050734668 UTC

[section ""data" . GHC.Integer.Type.$tcDigitsOnes1_closure" {
     GHC.Integer.Type.$tcDigitsOnes1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcDigitsOnes2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.052977223 UTC

[section ""data" . GHC.Integer.Type.$tcDigitsOnes_closure" {
     GHC.Integer.Type.$tcDigitsOnes_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcDigitsOnes1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4554239703586147919;
         const 6957361150436389790;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.055604183 UTC

[section ""data" . $krep5_r3Bu_closure" {
     $krep5_r3Bu_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcDigitsOnes_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.058041569 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes1_closure" {
     GHC.Integer.Type.$tc'DigitsOnes1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const $krep5_r3Bu_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.06081778 UTC

[section ""cstring" . GHC.Integer.Type.$tc'DigitsOnes3_bytes" {
     GHC.Integer.Type.$tc'DigitsOnes3_bytes:
         I8[] [39,68,105,103,105,116,115,79,110,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.06358512 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes2_closure" {
     GHC.Integer.Type.$tc'DigitsOnes2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'DigitsOnes3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.065806016 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes_closure" {
     GHC.Integer.Type.$tc'DigitsOnes_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'DigitsOnes2_closure+1;
         const GHC.Integer.Type.$tc'DigitsOnes1_closure+4;
         const 15211110739657495015;
         const 1682512192113792266;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.068484563 UTC

[section ""data" . GHC.Integer.Type.encodeDouble#_closure" {
     GHC.Integer.Type.encodeDouble#_closure:
         const GHC.Integer.Type.encodeDouble#_info;
 },
 GHC.Integer.Type.encodeDouble#_entry() //  [R2, R3]
         { info_tbl: [(c7cK,
                       label: GHC.Integer.Type.encodeDouble#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7cK: // global
           _c7cJ::I64 = R3;
           (_s3N2::F64) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeDouble(R2, _c7cJ::I64);
           D1 = _s3N2::F64;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.074356756 UTC

[section ""data" . f_r3Bv_closure" {
     f_r3Bv_closure:
         const f_r3Bv_info;
 },
 f_r3Bv_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7cU: // global
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           D1 = F64[Sp];
           R1 = R1;
           Sp = Sp + 24;
           call f_r3Bv_entry(R3, R2, D1, R1) args: 8, res: 0, upd: 8;
     }
 },
 f_r3Bv_entry() //  [R2, R3, D1]
         { info_tbl: [(c7d5,
                       label: f_r3Bv_info
                       rep:HeapRep static {
                             Fun {arity: 3 fun_type: ArgGen [True, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7d5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7d6; else goto u7dl;
       c7d6: // global
           R1 = f_r3Bv_closure;
           F64[Sp - 24] = D1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       u7dl: // global
           F64[Sp - 24] = D1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _c7cV() args: 0, res: 0, upd: 0;
     }
 },
 _c7cV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7cV: // global
           I64[Sp - 8] = block_c7cY_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7dn; else goto c7cZ;
       u7dn: // global
           call _c7cY(R1) args: 0, res: 0, upd: 0;
       c7cZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7cY() //  [R1]
         { info_tbl: [(c7cY,
                       label: block_c7cY_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7cY: // global
           _s3N3::F64 = F64[Sp + 8];
           if (R1 & 7 == 1) goto c7d2; else goto c7d3;
       c7d2: // global
           _s3N5::I64 = I64[Sp + 24];
           _s3N8::P64 = P64[R1 + 7];
           (_s3Nc::F64) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeDouble(I64[R1 + 15], _s3N5::I64);
           F64[Sp + 8] = %MO_F_Add_W64(_s3N3::F64, _s3Nc::F64);
           P64[Sp + 16] = _s3N8::P64;
           I64[Sp + 24] = _s3N5::I64 + 64;
           Sp = Sp + 8;
           call _c7cV() args: 0, res: 0, upd: 0;
       c7d3: // global
           D1 = _s3N3::F64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.087034319 UTC

[section ""data" . GHC.Integer.Type.encodeDoubleInteger_closure" {
     GHC.Integer.Type.encodeDoubleInteger_closure:
         const GHC.Integer.Type.encodeDoubleInteger_info;
 },
 GHC.Integer.Type.encodeDoubleInteger_entry() //  [R2, R3]
         { info_tbl: [(c7dV,
                       label: GHC.Integer.Type.encodeDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7dV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7dW; else goto c7dX;
       c7dW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.encodeDoubleInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7dX: // global
           I64[Sp - 16] = block_c7dN_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7eh; else goto c7dO;
       u7eh: // global
           call _c7dN(R1) args: 0, res: 0, upd: 0;
       c7dO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7dN() //  [R1]
         { info_tbl: [(c7dN,
                       label: block_c7dN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7dN: // global
           _c7dU::P64 = R1 & 7;
           if (_c7dU::P64 < 3) goto u7eg; else goto c7dT;
       u7eg: // global
           _s3Ng::I64 = I64[Sp + 8];
           if (_c7dU::P64 < 2) goto c7dR; else goto c7dS;
       c7dR: // global
           R3 = _s3Ng::I64;
           R2 = P64[R1 + 7];
           D1 = 0.0 :: W64;
           Sp = Sp + 16;
           call f_r3Bv_entry(R3, R2, D1) args: 8, res: 0, upd: 8;
       c7dS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7eb; else goto c7ea;
       c7eb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ea: // global
           _s3Nj::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3Nj::P64;
           I64[Sp + 8] = block_c7e4_info;
           R3 = _s3Ng::I64;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       c7dT: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 _c7e4() //  [D1]
         { info_tbl: [(c7e4,
                       label: block_c7e4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7e4: // global
           D1 = %MO_F_Neg_W64(D1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.097832509 UTC

[section ""data" . GHC.Integer.Type.encodeFloat#_closure" {
     GHC.Integer.Type.encodeFloat#_closure:
         const GHC.Integer.Type.encodeFloat#_info;
 },
 GHC.Integer.Type.encodeFloat#_entry() //  [R2, R3]
         { info_tbl: [(c7eG,
                       label: GHC.Integer.Type.encodeFloat#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7eG: // global
           _c7eF::I64 = R3;
           (_s3Nr::F32) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeFloat(R2, _c7eF::I64);
           F1 = _s3Nr::F32;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.104523359 UTC

[section ""data" . f1_r3Bw_closure" {
     f1_r3Bw_closure:
         const f1_r3Bw_info;
 },
 f1_r3Bw_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7eQ: // global
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           F1 = F32[Sp];
           R1 = R1;
           Sp = Sp + 24;
           call f1_r3Bw_entry(R3, R2, F1, R1) args: 8, res: 0, upd: 8;
     }
 },
 f1_r3Bw_entry() //  [R2, R3, F1]
         { info_tbl: [(c7f1,
                       label: f1_r3Bw_info
                       rep:HeapRep static {
                             Fun {arity: 3 fun_type: ArgGen [True, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7f1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7f2; else goto u7fh;
       c7f2: // global
           R1 = f1_r3Bw_closure;
           F32[Sp - 24] = F1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       u7fh: // global
           F32[Sp - 24] = F1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _c7eR() args: 0, res: 0, upd: 0;
     }
 },
 _c7eR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7eR: // global
           I64[Sp - 8] = block_c7eU_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7fj; else goto c7eV;
       u7fj: // global
           call _c7eU(R1) args: 0, res: 0, upd: 0;
       c7eV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7eU() //  [R1]
         { info_tbl: [(c7eU,
                       label: block_c7eU_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7eU: // global
           _s3Ns::F32 = F32[Sp + 8];
           if (R1 & 7 == 1) goto c7eY; else goto c7eZ;
       c7eY: // global
           _s3Nu::I64 = I64[Sp + 24];
           _s3Nx::P64 = P64[R1 + 7];
           (_s3NB::F32) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeFloat(I64[R1 + 15], _s3Nu::I64);
           F32[Sp + 8] = %MO_F_Add_W32(_s3Ns::F32, _s3NB::F32);
           P64[Sp + 16] = _s3Nx::P64;
           I64[Sp + 24] = _s3Nu::I64 + 64;
           Sp = Sp + 8;
           call _c7eR() args: 0, res: 0, upd: 0;
       c7eZ: // global
           F1 = _s3Ns::F32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.117371174 UTC

[section ""data" . GHC.Integer.Type.encodeFloatInteger_closure" {
     GHC.Integer.Type.encodeFloatInteger_closure:
         const GHC.Integer.Type.encodeFloatInteger_info;
 },
 GHC.Integer.Type.encodeFloatInteger_entry() //  [R2, R3]
         { info_tbl: [(c7fR,
                       label: GHC.Integer.Type.encodeFloatInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7fR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7fS; else goto c7fT;
       c7fS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.encodeFloatInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7fT: // global
           I64[Sp - 16] = block_c7fJ_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7gd; else goto c7fK;
       u7gd: // global
           call _c7fJ(R1) args: 0, res: 0, upd: 0;
       c7fK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7fJ() //  [R1]
         { info_tbl: [(c7fJ,
                       label: block_c7fJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7fJ: // global
           _c7fQ::P64 = R1 & 7;
           if (_c7fQ::P64 < 3) goto u7gc; else goto c7fP;
       u7gc: // global
           _s3NF::I64 = I64[Sp + 8];
           if (_c7fQ::P64 < 2) goto c7fN; else goto c7fO;
       c7fN: // global
           R3 = _s3NF::I64;
           R2 = P64[R1 + 7];
           F1 = 0.0 :: W32;
           Sp = Sp + 16;
           call f1_r3Bw_entry(R3, R2, F1) args: 8, res: 0, upd: 8;
       c7fO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7g7; else goto c7g6;
       c7g7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7g6: // global
           _s3NI::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3NI::P64;
           I64[Sp + 8] = block_c7g0_info;
           R3 = _s3NF::I64;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
       c7fP: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 _c7g0() //  [F1]
         { info_tbl: [(c7g0,
                       label: block_c7g0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7g0: // global
           F1 = %MO_F_Neg_W32(F1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.130982128 UTC

[section ""data" . GHC.Integer.Type.Positive_closure" {
     GHC.Integer.Type.Positive_closure:
         const GHC.Integer.Type.Positive_info;
 },
 GHC.Integer.Type.Positive_entry() //  [R2]
         { info_tbl: [(c7gA,
                       label: GHC.Integer.Type.Positive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7gA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7gE; else goto c7gD;
       c7gE: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Type.Positive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7gD: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.136341007 UTC

[section ""data" . GHC.Integer.Type.Negative_closure" {
     GHC.Integer.Type.Negative_closure:
         const GHC.Integer.Type.Negative_info;
 },
 GHC.Integer.Type.Negative_entry() //  [R2]
         { info_tbl: [(c7gP,
                       label: GHC.Integer.Type.Negative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7gP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7gT; else goto c7gS;
       c7gT: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Type.Negative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7gS: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.140992343 UTC

[section ""data" . GHC.Integer.Type.Naught_closure" {
     GHC.Integer.Type.Naught_closure:
         const GHC.Integer.Type.Naught_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.143624981 UTC

[section ""data" . GHC.Integer.Type.Nil_closure" {
     GHC.Integer.Type.Nil_closure:
         const GHC.Integer.Type.Nil_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.146709703 UTC

[section ""data" . GHC.Integer.Type.Cons_closure" {
     GHC.Integer.Type.Cons_closure:
         const GHC.Integer.Type.Cons_info;
 },
 GHC.Integer.Type.Cons_entry() //  [R2, R3]
         { info_tbl: [(c7h6,
                       label: GHC.Integer.Type.Cons_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7h6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7ha; else goto c7h9;
       c7ha: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.Cons_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7h9: // global
           I64[Hp - 16] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.151802932 UTC

[section ""data" . GHC.Integer.Type.Some_closure" {
     GHC.Integer.Type.Some_closure:
         const GHC.Integer.Type.Some_info;
 },
 GHC.Integer.Type.Some_entry() //  [R2, R3]
         { info_tbl: [(c7hl,
                       label: GHC.Integer.Type.Some_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7hl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7hp; else goto c7ho;
       c7hp: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.Some_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ho: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R3;
           I64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.157452514 UTC

[section ""data" . GHC.Integer.Type.None_closure" {
     GHC.Integer.Type.None_closure:
         const GHC.Integer.Type.None_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.159600673 UTC

[GHC.Integer.Type.Positive_con_entry() //  [R1]
         { info_tbl: [(c7hw,
                       label: GHC.Integer.Type.Positive_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,80,111,115,105,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7hw: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.163907966 UTC

[GHC.Integer.Type.Negative_con_entry() //  [R1]
         { info_tbl: [(c7hC,
                       label: GHC.Integer.Type.Negative_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,101,103,97,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7hC: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.167992837 UTC

[GHC.Integer.Type.Naught_con_entry() //  [R1]
         { info_tbl: [(c7hI,
                       label: GHC.Integer.Type.Naught_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,97,117,103,104,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7hI: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.171912572 UTC

[GHC.Integer.Type.Nil_con_entry() //  [R1]
         { info_tbl: [(c7hO,
                       label: GHC.Integer.Type.Nil_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,105,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7hO: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.176315543 UTC

[GHC.Integer.Type.Cons_con_entry() //  [R1]
         { info_tbl: [(c7hU,
                       label: GHC.Integer.Type.Cons_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 1
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,67,111,110,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7hU: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.18034518 UTC

[GHC.Integer.Type.Some_con_entry() //  [R1]
         { info_tbl: [(c7i0,
                       label: GHC.Integer.Type.Some_con_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,83,111,109,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7i0: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.18470488 UTC

[GHC.Integer.Type.None_con_entry() //  [R1]
         { info_tbl: [(c7i6,
                       label: GHC.Integer.Type.None_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,111,110,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7i6: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:51.190149125 UTC

[section ""relreadonly" . S3Xx_srt" {
     S3Xx_srt:
         const GHC.Integer.Type.plusPositive_addWithCarry_closure;
         const lvl_r3Bo_closure;
         const GHC.Integer.Type.timesDigit_closure;
         const GHC.Integer.Type.timesPositive_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const GHC.Integer.Type.complementInteger_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Integer.Type.modInteger_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:54.940888064 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:53:54.95014479 UTC

[section ""data" . GHC.Integer.Type.$WPositive_closure" {
     GHC.Integer.Type.$WPositive_closure:
         const GHC.Integer.Type.$WPositive_info;
 },
 GHC.Integer.Type.$WPositive_entry() //  [R2]
         { info_tbl: [(c7ux,
                       label: GHC.Integer.Type.$WPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ux: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7uB; else goto c7uC;
       c7uB: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$WPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7uC: // global
           I64[Sp - 8] = block_c7uu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7uG; else goto c7uv;
       u7uG: // global
           call _c7uu(R1) args: 0, res: 0, upd: 0;
       c7uv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7uu() //  [R1]
         { info_tbl: [(c7uu,
                       label: block_c7uu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7uu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7uF; else goto c7uE;
       c7uF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7uE: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:54.957391369 UTC

[section ""data" . GHC.Integer.Type.$WNegative_closure" {
     GHC.Integer.Type.$WNegative_closure:
         const GHC.Integer.Type.$WNegative_info;
 },
 GHC.Integer.Type.$WNegative_entry() //  [R2]
         { info_tbl: [(c7v0,
                       label: GHC.Integer.Type.$WNegative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7v0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7v4; else goto c7v5;
       c7v4: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$WNegative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7v5: // global
           I64[Sp - 8] = block_c7uX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7v9; else goto c7uY;
       u7v9: // global
           call _c7uX(R1) args: 0, res: 0, upd: 0;
       c7uY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7uX() //  [R1]
         { info_tbl: [(c7uX,
                       label: block_c7uX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7uX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7v8; else goto c7v7;
       c7v8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7v7: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:54.964923219 UTC

[section ""data" . GHC.Integer.Type.$WSome_closure" {
     GHC.Integer.Type.$WSome_closure:
         const GHC.Integer.Type.$WSome_info;
 },
 GHC.Integer.Type.$WSome_entry() //  [R2, R3]
         { info_tbl: [(c7vt,
                       label: GHC.Integer.Type.$WSome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7vt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7vx; else goto c7vy;
       c7vx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$WSome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7vy: // global
           I64[Sp - 16] = block_c7vq_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7vC; else goto c7vr;
       u7vC: // global
           call _c7vq(R1) args: 0, res: 0, upd: 0;
       c7vr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7vq() //  [R1]
         { info_tbl: [(c7vq,
                       label: block_c7vq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7vq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7vB; else goto c7vA;
       c7vB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7vA: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:54.972090418 UTC

[section ""data" . GHC.Integer.Type.errorPositive_closure" {
     GHC.Integer.Type.errorPositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 47;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:54.974540533 UTC

[section ""data" . GHC.Integer.Type.errorInteger_closure" {
     GHC.Integer.Type.errorInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.errorPositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:54.978155584 UTC

[section ""data" . GHC.Integer.Type.wordToInteger_closure" {
     GHC.Integer.Type.wordToInteger_closure:
         const GHC.Integer.Type.wordToInteger_info;
 },
 GHC.Integer.Type.wordToInteger_entry() //  [R2]
         { info_tbl: [(c7w0,
                       label: GHC.Integer.Type.wordToInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7w0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7w4; else goto c7w3;
       c7w4: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Integer.Type.wordToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7w3: // global
           if (R2 == 0) goto c7vZ; else goto c7vY;
       c7vZ: // global
           Hp = Hp - 40;
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7vY: // global
           I64[Hp - 32] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 24] = GHC.Integer.Type.None_closure+2;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:54.985144359 UTC

[section ""data" . GHC.Integer.Type.integerToWord_closure" {
     GHC.Integer.Type.integerToWord_closure:
         const GHC.Integer.Type.integerToWord_info;
 },
 GHC.Integer.Type.integerToWord_entry() //  [R2]
         { info_tbl: [(c7wu,
                       label: GHC.Integer.Type.integerToWord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7wu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7wv; else goto c7ww;
       c7wv: // global
           R2 = R2;
           R1 = GHC.Integer.Type.integerToWord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ww: // global
           I64[Sp - 8] = block_c7wm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7xe; else goto c7wn;
       u7xe: // global
           call _c7wm(R1) args: 0, res: 0, upd: 0;
       c7wn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7wm() //  [R1]
         { info_tbl: [(c7wm,
                       label: block_c7wm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7wm: // global
           _c7wt::P64 = R1 & 7;
           if (_c7wt::P64 < 3) goto u7x7; else goto u7x8;
       u7x7: // global
           if (_c7wt::P64 < 2) goto c7wq; else goto c7wr;
       c7wq: // global
           I64[Sp] = block_c7wz_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u7xb; else goto c7wB;
       u7xb: // global
           call _c7wz(R1) args: 0, res: 0, upd: 0;
       c7wB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7wr: // global
           I64[Sp] = block_c7wO_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u7xc; else goto c7wQ;
       u7xc: // global
           call _c7wO(R1) args: 0, res: 0, upd: 0;
       c7wQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u7x8: // global
           Sp = Sp + 8;
           call _c7ws() args: 0, res: 0, upd: 0;
     }
 },
 _c7wz() //  [R1]
         { info_tbl: [(c7wz,
                       label: block_c7wz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7wz: // global
           if (R1 & 7 == 1) goto c7wH; else goto u7x9;
       c7wH: // global
           R1 = I64[R1 + 15];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7x9: // global
           Sp = Sp + 8;
           call _c7ws() args: 0, res: 0, upd: 0;
     }
 },
 _c7wO() //  [R1]
         { info_tbl: [(c7wO,
                       label: block_c7wO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7wO: // global
           if (R1 & 7 == 1) goto c7wX; else goto u7xa;
       c7wX: // global
           R1 = 0 - I64[R1 + 15];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7xa: // global
           Sp = Sp + 8;
           call _c7ws() args: 0, res: 0, upd: 0;
     }
 },
 _c7ws() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ws: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:54.997554204 UTC

[section ""data" . GHC.Integer.Type.integerToInt_closure" {
     GHC.Integer.Type.integerToInt_closure:
         const GHC.Integer.Type.integerToInt_info;
 },
 GHC.Integer.Type.integerToInt_entry() //  [R2]
         { info_tbl: [(c7xT,
                       label: GHC.Integer.Type.integerToInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7xT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7xX; else goto c7xY;
       c7xX: // global
           R2 = R2;
           R1 = GHC.Integer.Type.integerToInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7xY: // global
           I64[Sp - 8] = block_c7xR_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7xR() //  [R1]
         { info_tbl: [(c7xR,
                       label: block_c7xR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7xR: // global
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.003573051 UTC

[section ""data" . GHC.Integer.Type.hashInteger_closure" {
     GHC.Integer.Type.hashInteger_closure:
         const GHC.Integer.Type.hashInteger_info;
 },
 GHC.Integer.Type.hashInteger_entry() //  [R2]
         { info_tbl: [(c7ye,
                       label: GHC.Integer.Type.hashInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ye: // global
           R2 = R2;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.007922833 UTC

[section ""data" . GHC.Integer.Type.flipBitsDigits_closure" {
     GHC.Integer.Type.flipBitsDigits_closure:
         const GHC.Integer.Type.flipBitsDigits_info;
 },
 GHC.Integer.Type.flipBitsDigits_entry() //  [R2]
         { info_tbl: [(c7yw,
                       label: GHC.Integer.Type.flipBitsDigits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7yw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7yx; else goto c7yy;
       c7yx: // global
           R2 = R2;
           R1 = GHC.Integer.Type.flipBitsDigits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7yy: // global
           I64[Sp - 8] = block_c7yp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7yQ; else goto c7yq;
       u7yQ: // global
           call _c7yp(R1) args: 0, res: 0, upd: 0;
       c7yq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7yp() //  [R1]
         { info_tbl: [(c7yp,
                       label: block_c7yp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7yp: // global
           if (R1 & 7 == 1) goto c7yt; else goto c7yu;
       c7yt: // global
           I64[Sp - 8] = block_c7yB_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
       c7yu: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7yB() //  [R1]
         { info_tbl: [(c7yB,
                       label: block_c7yB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7yB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7yM; else goto c7yL;
       c7yM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7yL: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = ~I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.019901137 UTC

[section ""data" . GHC.Integer.Type.flipBits1_closure" {
     GHC.Integer.Type.flipBits1_closure:
         const GHC.Integer.Type.flipBits1_info;
 },
 GHC.Integer.Type.flipBits1_entry() //  [R2]
         { info_tbl: [(c7zg,
                       label: GHC.Integer.Type.flipBits1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7zg: // global
           R2 = R2;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.025942674 UTC

[section ""data" . GHC.Integer.Type.flipBits_closure" {
     GHC.Integer.Type.flipBits_closure:
         const GHC.Integer.Type.flipBits_info;
 },
 GHC.Integer.Type.flipBits_entry() //  [R2]
         { info_tbl: [(c7zr,
                       label: GHC.Integer.Type.flipBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7zr: // global
           R2 = R2;
           call GHC.Integer.Type.flipBits1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.032050948 UTC

[section ""data" . GHC.Integer.Type.negateInteger_closure" {
     GHC.Integer.Type.negateInteger_closure:
         const GHC.Integer.Type.negateInteger_info;
 },
 GHC.Integer.Type.negateInteger_entry() //  [R2]
         { info_tbl: [(c7zK,
                       label: GHC.Integer.Type.negateInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7zK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7zL; else goto c7zM;
       c7zL: // global
           R2 = R2;
           R1 = GHC.Integer.Type.negateInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7zM: // global
           I64[Sp - 8] = block_c7zC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7A3; else goto c7zD;
       u7A3: // global
           call _c7zC(R1) args: 0, res: 0, upd: 0;
       c7zD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7zC() //  [R1]
         { info_tbl: [(c7zC,
                       label: block_c7zC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7zC: // global
           _c7zJ::P64 = R1 & 7;
           if (_c7zJ::P64 < 3) goto u7A2; else goto c7zI;
       u7A2: // global
           if (_c7zJ::P64 < 2) goto c7zG; else goto c7zH;
       c7zG: // global
           Hp = Hp + 16;
           _s7iH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c7zY; else goto c7zR;
       c7zR: // global
           _s7iI::P64 = P64[_s7iH::P64 + 7];
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = _s7iI::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7zH: // global
           Hp = Hp + 16;
           _s7iH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c7zY; else goto c7zX;
       c7zY: // global
           HpAlloc = 16;
           R1 = _s7iH::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7zX: // global
           _s7iJ::P64 = P64[_s7iH::P64 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s7iJ::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7zI: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.040235174 UTC

[section ""data" . GHC.Integer.Type.smallInteger_closure" {
     GHC.Integer.Type.smallInteger_closure:
         const GHC.Integer.Type.smallInteger_info;
 },
 GHC.Integer.Type.smallInteger_entry() //  [R2]
         { info_tbl: [(c7At,
                       label: GHC.Integer.Type.smallInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7At: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Au; else goto c7Av;
       c7Au: // global
           R2 = R2;
           R1 = GHC.Integer.Type.smallInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Av: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c7Ar; else goto c7As;
       c7Ar: // global
           I64[Sp - 8] = block_c7AD_info;
           R2 = -R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c7As: // global
           R2 = R2;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c7AD() //  [R1]
         { info_tbl: [(c7AD,
                       label: block_c7AD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7AD: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.047622577 UTC

[section ""data" . GHC.Integer.Type.decodeFloatInteger_closure" {
     GHC.Integer.Type.decodeFloatInteger_closure:
         const GHC.Integer.Type.decodeFloatInteger_info;
 },
 sat_s7iU_entry() //  [R1]
         { info_tbl: [(c7B5,
                       label: sat_s7iU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7B5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7B6; else goto c7B7;
       c7B6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7B7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.decodeFloatInteger_entry() //  [F1]
         { info_tbl: [(c7B8,
                       label: GHC.Integer.Type.decodeFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 6} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7B8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7B9; else goto c7Ba;
       c7B9: // global
           F1 = F1;
           R1 = GHC.Integer.Type.decodeFloatInteger_closure;
           call (stg_gc_fun)(F1, R1) args: 8, res: 0, upd: 8;
       c7Ba: // global
           I64[Sp - 8] = block_c7AX_info;
           F1 = F1;
           Sp = Sp - 8;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _c7AX() //  [R1, R2]
         { info_tbl: [(c7AX,
                       label: block_c7AX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7AX: // global
           I64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c7AY() args: 0, res: 0, upd: 0;
     }
 },
 _c7AY() //  []
         { info_tbl: [(c7AY,
                       label: block_c7AY_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7AY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Bd; else goto c7Bc;
       c7Bd: // global
           HpAlloc = 24;
           I64[Sp] = block_c7AY_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7Bc: // global
           I64[Hp - 16] = sat_s7iU_info;
           I64[Hp] = I64[Sp + 16];
           R2 = I64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.058695193 UTC

[section ""data" . GHC.Integer.Type.absInteger_closure" {
     GHC.Integer.Type.absInteger_closure:
         const GHC.Integer.Type.absInteger_info;
 },
 GHC.Integer.Type.absInteger_entry() //  [R2]
         { info_tbl: [(c7BM,
                       label: GHC.Integer.Type.absInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7BM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7BN; else goto c7BO;
       c7BN: // global
           R2 = R2;
           R1 = GHC.Integer.Type.absInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7BO: // global
           I64[Sp - 8] = block_c7BF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7BY; else goto c7BG;
       u7BY: // global
           call _c7BF(R1) args: 0, res: 0, upd: 0;
       c7BG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7BF() //  [R1]
         { info_tbl: [(c7BF,
                       label: block_c7BF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7BF: // global
           if (R1 & 7 == 2) goto c7BK; else goto c7BJ;
       c7BK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7BX; else goto c7BW;
       c7BX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7BW: // global
           _s7iX::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s7iX::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7BJ: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.065848055 UTC

[section ""data" . GHC.Integer.Type.onePositive_closure" {
     GHC.Integer.Type.onePositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.067897555 UTC

[section ""data" . GHC.Integer.Type.negativeOneInteger_closure" {
     GHC.Integer.Type.negativeOneInteger_closure:
         const GHC.Integer.Type.Negative_con_info;
         const GHC.Integer.Type.onePositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.069985126 UTC

[section ""data" . GHC.Integer.Type.oneInteger_closure" {
     GHC.Integer.Type.oneInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.onePositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.072957671 UTC

[section ""data" . GHC.Integer.Type.signumInteger_closure" {
     GHC.Integer.Type.signumInteger_closure:
         const GHC.Integer.Type.signumInteger_info;
 },
 GHC.Integer.Type.signumInteger_entry() //  [R2]
         { info_tbl: [(c7Cu,
                       label: GHC.Integer.Type.signumInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Cu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Cv; else goto c7Cw;
       c7Cv: // global
           R2 = R2;
           R1 = GHC.Integer.Type.signumInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Cw: // global
           I64[Sp - 8] = block_c7Cm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7CH; else goto c7Cn;
       u7CH: // global
           call _c7Cm(R1) args: 0, res: 0, upd: 0;
       c7Cn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Cm() //  [R1]
         { info_tbl: [(c7Cm,
                       label: block_c7Cm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Cm: // global
           _c7Ct::P64 = R1 & 7;
           if (_c7Ct::P64 < 3) goto u7CG; else goto c7Cs;
       u7CG: // global
           if (_c7Ct::P64 < 2) goto c7Cq; else goto c7Cr;
       c7Cq: // global
           R1 = GHC.Integer.Type.oneInteger_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Cr: // global
           R1 = GHC.Integer.Type.negativeOneInteger_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Cs: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.081122428 UTC

[section ""data" . GHC.Integer.Type.halfBoundUp_closure" {
     GHC.Integer.Type.halfBoundUp_closure:
         const GHC.Integer.Type.halfBoundUp_info;
 },
 GHC.Integer.Type.halfBoundUp_entry() //  [R2]
         { info_tbl: [(c7D3,
                       label: GHC.Integer.Type.halfBoundUp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7D3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7D4; else goto c7D5;
       c7D4: // global
           R2 = R2;
           R1 = GHC.Integer.Type.halfBoundUp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7D5: // global
           I64[Sp - 8] = block_c7D0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7D9; else goto c7D1;
       u7D9: // global
           call _c7D0() args: 0, res: 0, upd: 0;
       c7D1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7D0() //  []
         { info_tbl: [(c7D0,
                       label: block_c7D0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7D0: // global
           R1 = 9223372036854775808;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.091097689 UTC

[section ""data" . GHC.Integer.Type.fullBound_closure" {
     GHC.Integer.Type.fullBound_closure:
         const GHC.Integer.Type.fullBound_info;
 },
 GHC.Integer.Type.fullBound_entry() //  [R2]
         { info_tbl: [(c7Ds,
                       label: GHC.Integer.Type.fullBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ds: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Dt; else goto c7Du;
       c7Dt: // global
           R2 = R2;
           R1 = GHC.Integer.Type.fullBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Du: // global
           I64[Sp - 8] = block_c7Dp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Dy; else goto c7Dq;
       u7Dy: // global
           call _c7Dp() args: 0, res: 0, upd: 0;
       c7Dq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Dp() //  []
         { info_tbl: [(c7Dp,
                       label: block_c7Dp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Dp: // global
           R1 = 18446744073709551615;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.100928739 UTC

[section ""data" . GHC.Integer.Type.$wsuccPositive_closure" {
     GHC.Integer.Type.$wsuccPositive_closure:
         const GHC.Integer.Type.$wsuccPositive_info;
 },
 GHC.Integer.Type.$wsuccPositive_entry() //  [R2]
         { info_tbl: [(c7DV,
                       label: GHC.Integer.Type.$wsuccPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7DV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7DW; else goto c7DX;
       c7DW: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$wsuccPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7DX: // global
           I64[Sp - 8] = block_c7DO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Ek; else goto c7DP;
       u7Ek: // global
           call _c7DO(R1) args: 0, res: 0, upd: 0;
       c7DP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7DO() //  [R1]
         { info_tbl: [(c7DO,
                       label: block_c7DO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7DO: // global
           if (R1 & 7 == 1) goto c7DS; else goto c7DT;
       c7DS: // global
           _s7j9::P64 = P64[R1 + 7];
           _s7ja::I64 = I64[R1 + 15];
           if (_s7ja::I64 != 18446744073709551615) goto c7E3; else goto c7Eb;
       c7E3: // global
           R2 = _s7j9::P64;
           R1 = _s7ja::I64 + 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c7Eb: // global
           I64[Sp] = block_c7E6_info;
           R2 = _s7j9::P64;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
       c7DT: // global
           R2 = GHC.Integer.Type.None_closure+2;
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7E6() //  [R1, R2]
         { info_tbl: [(c7E6,
                       label: block_c7E6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E6: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c7E7() args: 0, res: 0, upd: 0;
     }
 },
 _c7E7() //  []
         { info_tbl: [(c7E7,
                       label: block_c7E7_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Ee; else goto c7Ed;
       c7Ee: // global
           HpAlloc = 24;
           I64[Sp] = block_c7E7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7Ed: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = Hp - 15;
           R1 = 0;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.118560812 UTC

[section ""data" . GHC.Integer.Type.succPositive_closure" {
     GHC.Integer.Type.succPositive_closure:
         const GHC.Integer.Type.succPositive_info;
 },
 GHC.Integer.Type.succPositive_entry() //  [R2]
         { info_tbl: [(c7EV,
                       label: GHC.Integer.Type.succPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7EW; else goto c7EX;
       c7EW: // global
           R2 = R2;
           R1 = GHC.Integer.Type.succPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EX: // global
           I64[Sp - 8] = block_c7EQ_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7EQ() //  [R1, R2]
         { info_tbl: [(c7EQ,
                       label: block_c7EQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EQ: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c7ER() args: 0, res: 0, upd: 0;
     }
 },
 _c7ER() //  []
         { info_tbl: [(c7ER,
                       label: block_c7ER_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ER: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7F0; else goto c7EZ;
       c7F0: // global
           HpAlloc = 24;
           I64[Sp] = block_c7ER_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7EZ: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.131929706 UTC

[section ""data" . lvl_r3Bo_closure" {
     lvl_r3Bo_closure:
         const lvl_r3Bo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r3Bo_entry() //  [R1]
         { info_tbl: [(c7Fv,
                       label: lvl_r3Bo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7Fw; else goto c7Fx;
       c7Fw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Fx: // global
           (_c7Fn::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Fn::I64 == 0) goto c7Fp; else goto c7Fo;
       c7Fp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Fo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Fn::I64;
           I64[Sp - 24] = block_c7Fq_info;
           R2 = GHC.Integer.Type.None_closure+2;
           Sp = Sp - 24;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7Fq() //  [R1, R2]
         { info_tbl: [(c7Fq,
                       label: block_c7Fq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fq: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c7Fr() args: 0, res: 0, upd: 0;
     }
 },
 _c7Fr() //  []
         { info_tbl: [(c7Fr,
                       label: block_c7Fr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7FA; else goto c7Fz;
       c7FA: // global
           HpAlloc = 24;
           I64[Sp] = block_c7Fr_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c7Fz: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.144030413 UTC

[section ""data" . GHC.Integer.Type.plusPositive_addWithCarry_closure" {
     GHC.Integer.Type.plusPositive_addWithCarry_closure:
         const GHC.Integer.Type.plusPositive_addWithCarry_info;
         const 0;
 },
 GHC.Integer.Type.plusPositive_addWithCarry_entry() //  [R2, R3, R4]
         { info_tbl: [(c7G8,
                       label: GHC.Integer.Type.plusPositive_addWithCarry_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7G8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7G9; else goto u7IF;
       c7G9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.plusPositive_addWithCarry_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u7IF: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c7FY() args: 0, res: 0, upd: 0;
     }
 },
 _c7FY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FY: // global
           I64[Sp - 8] = block_c7G1_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7IJ; else goto c7G2;
       u7IJ: // global
           call _c7G1(R1) args: 0, res: 0, upd: 0;
       c7G2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7G1() //  [R1]
         { info_tbl: [(c7G1,
                       label: block_c7G1_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7G1: // global
           _s7jp::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c7G5; else goto c7G6;
       c7G5: // global
           I64[Sp - 8] = block_c7Gd_info;
           _s7jq::P64 = R1;
           _s7js::P64 = P64[R1 + 7];
           _s7jr::I64 = I64[R1 + 15];
           R1 = _s7jp::P64;
           P64[Sp] = _s7js::P64;
           I64[Sp + 16] = _s7jr::I64;
           P64[Sp + 24] = _s7jq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7IK; else goto c7Gf;
       u7IK: // global
           call _c7Gd(R1) args: 0, res: 0, upd: 0;
       c7Gf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7G6: // global
           I64[Sp] = block_c7I9_info;
           R1 = _s7jp::P64;
           if (R1 & 7 != 0) goto u7IL; else goto c7Ib;
       u7IL: // global
           call _c7I9(R1) args: 0, res: 0, upd: 0;
       c7Ib: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Gd() //  [R1]
         { info_tbl: [(c7Gd,
                       label: block_c7Gd_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Gd: // global
           _s7jn::I64 = I64[Sp + 16];
           _s7jq::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c7HP; else goto c7I6;
       c7HP: // global
           _s7jr::I64 = I64[Sp + 24];
           _s7ju::I64 = I64[R1 + 15];
           if (_s7jr::I64 >= _s7ju::I64) goto c7HM; else goto c7HN;
       c7HM: // global
           _s7js::P64 = P64[Sp + 8];
           _s7jv::P64 = P64[R1 + 7];
           if (_s7ju::I64 < 9223372036854775808) goto c7Ho; else goto c7HH;
       c7Ho: // global
           if (_s7jr::I64 < 9223372036854775808) goto c7GF; else goto c7Hm;
       c7GF: // global
           I64[Sp + 8] = block_c7Gt_info;
           R4 = _s7jv::P64;
           R3 = _s7js::P64;
           R2 = 0;
           I64[Sp + 32] = _s7ju::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c7Hm: // global
           _s7jC::I64 = (_s7jr::I64 + -9223372036854775808) + (_s7ju::I64 + _s7jn::I64);
           if (_s7jC::I64 >= 9223372036854775808) goto c7H5; else goto c7Hi;
       c7H5: // global
           I64[Sp + 24] = block_c7GW_info;
           R4 = _s7jv::P64;
           R3 = _s7js::P64;
           R2 = 1;
           I64[Sp + 32] = _s7jC::I64;
           Sp = Sp + 24;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c7Hi: // global
           I64[Sp + 24] = block_c7Ha_info;
           R4 = _s7jv::P64;
           R3 = _s7js::P64;
           R2 = 0;
           I64[Sp + 32] = _s7jC::I64;
           Sp = Sp + 24;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c7HH: // global
           I64[Sp + 8] = block_c7Hq_info;
           R4 = _s7jv::P64;
           R3 = _s7js::P64;
           R2 = 1;
           I64[Sp + 32] = _s7ju::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c7HN: // global
           I64[Sp + 16] = _s7jn::I64;
           P64[Sp + 24] = R1;
           P64[Sp + 32] = _s7jq::P64;
           Sp = Sp + 16;
           call _c7FY() args: 0, res: 0, upd: 0;
       c7I6: // global
           if (_s7jn::I64 == 0) goto c7I5; else goto c7I1;
       c7I5: // global
           R1 = _s7jq::P64 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c7I1: // global
           I64[Sp + 32] = block_c7HV_info;
           R2 = _s7jq::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7Gt() //  [R1]
         { info_tbl: [(c7Gt,
                       label: block_c7Gt_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Gt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7GI; else goto c7GH;
       c7GI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7GH: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] + (I64[Sp + 24] + I64[Sp + 8]);
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7GW() //  [R1]
         { info_tbl: [(c7GW,
                       label: block_c7GW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7GW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7H8; else goto c7H7;
       c7H8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7H7: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - 9223372036854775808;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Ha() //  [R1]
         { info_tbl: [(c7Ha,
                       label: block_c7Ha_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ha: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Hl; else goto c7Hk;
       c7Hl: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Hk: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - 9223372036854775808;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Hq() //  [R1]
         { info_tbl: [(c7Hq,
                       label: block_c7Hq_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Hq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7HK; else goto c7HJ;
       c7HK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7HJ: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] + (I64[Sp + 24] + I64[Sp + 8]);
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7HV() //  [R1, R2]
         { info_tbl: [(c7HV,
                       label: block_c7HV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7HV: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c7HW() args: 0, res: 0, upd: 0;
     }
 },
 _c7HW() //  []
         { info_tbl: [(c7HW,
                       label: block_c7HW_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7HW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7I4; else goto c7I3;
       c7I4: // global
           HpAlloc = 24;
           I64[Sp] = block_c7HW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7I3: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7I9() //  [R1]
         { info_tbl: [(c7I9,
                       label: block_c7I9_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7I9: // global
           _s7jn::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c7Iu; else goto c7IC;
       c7Iu: // global
           if (_s7jn::I64 == 0) goto c7Is; else goto c7Io;
       c7Is: // global
           R1 = R1 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c7Io: // global
           I64[Sp + 24] = block_c7Ii_info;
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
       c7IC: // global
           if (_s7jn::I64 == 0) goto c7IB; else goto c7IA;
       c7IB: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7IA: // global
           R1 = lvl_r3Bo_closure;
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Ii() //  [R1, R2]
         { info_tbl: [(c7Ii,
                       label: block_c7Ii_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ii: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c7Ij() args: 0, res: 0, upd: 0;
     }
 },
 _c7Ij() //  []
         { info_tbl: [(c7Ij,
                       label: block_c7Ij_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ij: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Ir; else goto c7Iq;
       c7Ir: // global
           HpAlloc = 24;
           I64[Sp] = block_c7Ij_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7Iq: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.17788974 UTC

[section ""data" . GHC.Integer.Type.plusPositive_closure" {
     GHC.Integer.Type.plusPositive_closure:
         const GHC.Integer.Type.plusPositive_info;
         const 0;
 },
 GHC.Integer.Type.plusPositive_entry() //  [R2, R3]
         { info_tbl: [(c7KB,
                       label: GHC.Integer.Type.plusPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7KB: // global
           R4 = R3;
           R3 = R2;
           R2 = 0;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.183679506 UTC

[section ""data" . GHC.Integer.Type.minusPositive_closure" {
     GHC.Integer.Type.minusPositive_closure:
         const GHC.Integer.Type.minusPositive_info;
 },
 GHC.Integer.Type.minusPositive_entry() //  [R2, R3]
         { info_tbl: [(c7KT,
                       label: GHC.Integer.Type.minusPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7KT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7KU; else goto c7KV;
       c7KU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.minusPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7KV: // global
           I64[Sp - 16] = block_c7KM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Mw; else goto c7KN;
       u7Mw: // global
           call _c7KM(R1) args: 0, res: 0, upd: 0;
       c7KN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7KM() //  [R1]
         { info_tbl: [(c7KM,
                       label: block_c7KM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7KM: // global
           _s7k4::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7KQ; else goto c7KR;
       c7KQ: // global
           I64[Sp - 16] = block_c7KY_info;
           _s7k5::P64 = R1;
           _s7k7::P64 = P64[R1 + 7];
           _s7k6::I64 = I64[R1 + 15];
           R1 = _s7k4::P64;
           P64[Sp - 8] = _s7k7::P64;
           I64[Sp] = _s7k6::I64;
           P64[Sp + 8] = _s7k5::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Mu; else goto c7L0;
       u7Mu: // global
           call _c7KY(R1) args: 0, res: 0, upd: 0;
       c7L0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7KR: // global
           I64[Sp + 8] = block_c7Mc_info;
           R1 = _s7k4::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Mv; else goto c7Me;
       u7Mv: // global
           call _c7Mc(R1) args: 0, res: 0, upd: 0;
       c7Me: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7KY() //  [R1]
         { info_tbl: [(c7KY,
                       label: block_c7KY_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7KY: // global
           if (R1 & 7 == 1) goto c7M5; else goto c7M9;
       c7M5: // global
           _s7k6::I64 = I64[Sp + 16];
           _s7k7::P64 = P64[Sp + 8];
           _s7ka::P64 = P64[R1 + 7];
           _s7k9::I64 = I64[R1 + 15];
           if (_s7k6::I64 == _s7k9::I64) goto c7LQ; else goto c7LN;
       c7LQ: // global
           I64[Sp + 24] = block_c7LP_info;
           R3 = _s7ka::P64;
           R2 = _s7k7::P64;
           Sp = Sp + 24;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c7LN: // global
           if (_s7k6::I64 <= _s7k9::I64) goto c7Lu; else goto c7LI;
       c7Lu: // global
           I64[Sp + 8] = block_c7Lb_info;
           R3 = _s7ka::P64;
           R2 = _s7k7::P64;
           I64[Sp + 24] = _s7k9::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c7LI: // global
           I64[Sp + 8] = block_c7LA_info;
           R3 = _s7ka::P64;
           R2 = _s7k7::P64;
           I64[Sp + 24] = _s7k9::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c7M9: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7LP() //  [R1]
         { info_tbl: [(c7LP,
                       label: block_c7LP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7LP: // global
           if (R1 & 7 == 1) goto c7LW; else goto u7Mt;
       c7LW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7LZ; else goto c7LY;
       c7LZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7LY: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7Mt: // global
           Sp = Sp + 8;
           call _c7Mo() args: 0, res: 0, upd: 0;
     }
 },
 _c7Lb() //  [R1]
         { info_tbl: [(c7Lb,
                       label: block_c7Lb_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Lb: // global
           I64[Sp] = block_c7Lf_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = R1;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7Lf() //  [R1]
         { info_tbl: [(c7Lf,
                       label: block_c7Lf_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Lf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Ly; else goto c7Lx;
       c7Ly: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Lx: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 18446744073709551615 - I64[Sp + 16] + (I64[Sp + 8] + 1);
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7LA() //  [R1]
         { info_tbl: [(c7LA,
                       label: block_c7LA_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7LA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7LL; else goto c7LK;
       c7LL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7LK: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Mc() //  [R1]
         { info_tbl: [(c7Mc,
                       label: block_c7Mc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Mc: // global
           if (R1 & 7 == 1) goto c7Mk; else goto u7Ms;
       c7Mk: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7Ms: // global
           Sp = Sp + 8;
           call _c7Mo() args: 0, res: 0, upd: 0;
     }
 },
 _c7Mo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Mo: // global
           R1 = GHC.Integer.Type.None_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.206463941 UTC

[section ""data" . GHC.Integer.Type.twosComplementPositive1_closure" {
     GHC.Integer.Type.twosComplementPositive1_closure:
         const GHC.Integer.Type.twosComplementPositive1_info;
 },
 GHC.Integer.Type.twosComplementPositive1_entry() //  [R2]
         { info_tbl: [(c7NG,
                       label: GHC.Integer.Type.twosComplementPositive1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7NH; else goto c7NI;
       c7NH: // global
           R2 = R2;
           R1 = GHC.Integer.Type.twosComplementPositive1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7NI: // global
           I64[Sp - 8] = block_c7NE_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7NE() //  [R1]
         { info_tbl: [(c7NE,
                       label: block_c7NE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.212821675 UTC

[section ""data" . GHC.Integer.Type.twosComplementPositive_closure" {
     GHC.Integer.Type.twosComplementPositive_closure:
         const GHC.Integer.Type.twosComplementPositive_info;
 },
 GHC.Integer.Type.twosComplementPositive_entry() //  [R2]
         { info_tbl: [(c7NZ,
                       label: GHC.Integer.Type.twosComplementPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NZ: // global
           R2 = R2;
           call GHC.Integer.Type.twosComplementPositive1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.217700376 UTC

[section ""data" . GHC.Integer.Type.lowHalfMask_closure" {
     GHC.Integer.Type.lowHalfMask_closure:
         const GHC.Integer.Type.lowHalfMask_info;
 },
 GHC.Integer.Type.lowHalfMask_entry() //  [R2]
         { info_tbl: [(c7Od,
                       label: GHC.Integer.Type.lowHalfMask_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Od: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Oe; else goto c7Of;
       c7Oe: // global
           R2 = R2;
           R1 = GHC.Integer.Type.lowHalfMask_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Of: // global
           I64[Sp - 8] = block_c7Oa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Oj; else goto c7Ob;
       u7Oj: // global
           call _c7Oa() args: 0, res: 0, upd: 0;
       c7Ob: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Oa() //  []
         { info_tbl: [(c7Oa,
                       label: block_c7Oa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Oa: // global
           R1 = 4294967295;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.230334945 UTC

[section ""data" . GHC.Integer.Type.highHalfShift_closure" {
     GHC.Integer.Type.highHalfShift_closure:
         const GHC.Integer.Type.highHalfShift_info;
 },
 GHC.Integer.Type.highHalfShift_entry() //  [R2]
         { info_tbl: [(c7OC,
                       label: GHC.Integer.Type.highHalfShift_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7OD; else goto c7OE;
       c7OD: // global
           R2 = R2;
           R1 = GHC.Integer.Type.highHalfShift_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7OE: // global
           I64[Sp - 8] = block_c7Oz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OI; else goto c7OA;
       u7OI: // global
           call _c7Oz() args: 0, res: 0, upd: 0;
       c7OA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Oz() //  []
         { info_tbl: [(c7Oz,
                       label: block_c7Oz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Oz: // global
           R1 = 32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.240991764 UTC

[section ""data" . GHC.Integer.Type.splitHalves_closure" {
     GHC.Integer.Type.splitHalves_closure:
         const GHC.Integer.Type.splitHalves_info;
 },
 GHC.Integer.Type.splitHalves_entry() //  [R2]
         { info_tbl: [(c7P0,
                       label: GHC.Integer.Type.splitHalves_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P0: // global
           _s7kx::I64 = R2 >> 32;
           R2 = R2 & 4294967295;
           R1 = _s7kx::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.24862976 UTC

[section ""data" . GHC.Integer.Type.doubleFromPositive_closure" {
     GHC.Integer.Type.doubleFromPositive_closure:
         const GHC.Integer.Type.doubleFromPositive_info;
 },
 GHC.Integer.Type.doubleFromPositive_entry() //  [R2]
         { info_tbl: [(c7Pn,
                       label: GHC.Integer.Type.doubleFromPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Po; else goto c7Pp;
       c7Po: // global
           R2 = R2;
           R1 = GHC.Integer.Type.doubleFromPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Pp: // global
           I64[Sp - 8] = block_c7Pg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Qd; else goto c7Ph;
       u7Qd: // global
           call _c7Pg(R1) args: 0, res: 0, upd: 0;
       c7Ph: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pg() //  [R1]
         { info_tbl: [(c7Pg,
                       label: block_c7Pg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pg: // global
           if (R1 & 7 == 1) goto c7Pk; else goto c7Pl;
       c7Pk: // global
           I64[Sp - 8] = block_c7Ps_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c7Pl: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Ps() //  [D1]
         { info_tbl: [(c7Ps,
                       label: block_c7Ps_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ps: // global
           _s7kB::I64 = I64[Sp + 8];
           _s7kD::F64 = D1;
           (_c7PF::F64) = call MO_F64_Pwr(2.0 :: W64, 32.0 :: W64);
           (_c7PW::F64) = call MO_F64_Pwr(2.0 :: W64, 64.0 :: W64);
           D1 = %MO_F_Add_W64(%MO_F_Add_W64(%MO_F_Mul_W64(_s7kD::F64,
                                                          _c7PW::F64),
                                            %MO_F_Mul_W64(%MO_SF_Conv_W64_W64(_s7kB::I64 >> 32),
                                                          _c7PF::F64)),
                              %MO_SF_Conv_W64_W64(_s7kB::I64 & 4294967295));
           Sp = Sp + 16;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.265078265 UTC

[section ""data" . GHC.Integer.Type.doubleFromInteger_closure" {
     GHC.Integer.Type.doubleFromInteger_closure:
         const GHC.Integer.Type.doubleFromInteger_info;
 },
 GHC.Integer.Type.doubleFromInteger_entry() //  [R2]
         { info_tbl: [(c7QX,
                       label: GHC.Integer.Type.doubleFromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7QY; else goto c7QZ;
       c7QY: // global
           R2 = R2;
           R1 = GHC.Integer.Type.doubleFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7QZ: // global
           I64[Sp - 8] = block_c7QP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Rg; else goto c7QQ;
       u7Rg: // global
           call _c7QP(R1) args: 0, res: 0, upd: 0;
       c7QQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QP() //  [R1]
         { info_tbl: [(c7QP,
                       label: block_c7QP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QP: // global
           _c7QW::P64 = R1 & 7;
           if (_c7QW::P64 < 3) goto u7Rf; else goto c7QV;
       u7Rf: // global
           if (_c7QW::P64 < 2) goto c7QT; else goto c7QU;
       c7QT: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 0, upd: 8;
       c7QU: // global
           I64[Sp] = block_c7R5_info;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c7QV: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 _c7R5() //  [D1]
         { info_tbl: [(c7R5,
                       label: block_c7R5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7R5: // global
           D1 = %MO_F_Neg_W64(D1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.279661162 UTC

[section ""data" . GHC.Integer.Type.floatFromPositive_closure" {
     GHC.Integer.Type.floatFromPositive_closure:
         const GHC.Integer.Type.floatFromPositive_info;
 },
 GHC.Integer.Type.floatFromPositive_entry() //  [R2]
         { info_tbl: [(c7RL,
                       label: GHC.Integer.Type.floatFromPositive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7RL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7RM; else goto c7RN;
       c7RM: // global
           R2 = R2;
           R1 = GHC.Integer.Type.floatFromPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7RN: // global
           I64[Sp - 8] = block_c7RE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7SB; else goto c7RF;
       u7SB: // global
           call _c7RE(R1) args: 0, res: 0, upd: 0;
       c7RF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7RE() //  [R1]
         { info_tbl: [(c7RE,
                       label: block_c7RE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7RE: // global
           if (R1 & 7 == 1) goto c7RI; else goto c7RJ;
       c7RI: // global
           I64[Sp - 8] = block_c7RQ_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c7RJ: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 _c7RQ() //  [F1]
         { info_tbl: [(c7RQ,
                       label: block_c7RQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7RQ: // global
           _s7kW::I64 = I64[Sp + 8];
           _s7kY::F32 = F1;
           (_c7S3::F32) = call MO_F32_Pwr(2.0 :: W32, 32.0 :: W32);
           (_c7Sk::F32) = call MO_F32_Pwr(2.0 :: W32, 64.0 :: W32);
           F1 = %MO_F_Add_W32(%MO_F_Add_W32(%MO_F_Mul_W32(_s7kY::F32,
                                                          _c7Sk::F32),
                                            %MO_F_Mul_W32(%MO_SF_Conv_W64_W32(_s7kW::I64 >> 32),
                                                          _c7S3::F32)),
                              %MO_SF_Conv_W64_W32(_s7kW::I64 & 4294967295));
           Sp = Sp + 16;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.297859018 UTC

[section ""data" . GHC.Integer.Type.floatFromInteger_closure" {
     GHC.Integer.Type.floatFromInteger_closure:
         const GHC.Integer.Type.floatFromInteger_info;
 },
 GHC.Integer.Type.floatFromInteger_entry() //  [R2]
         { info_tbl: [(c7Tl,
                       label: GHC.Integer.Type.floatFromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Tl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Tm; else goto c7Tn;
       c7Tm: // global
           R2 = R2;
           R1 = GHC.Integer.Type.floatFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Tn: // global
           I64[Sp - 8] = block_c7Td_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7TE; else goto c7Te;
       u7TE: // global
           call _c7Td(R1) args: 0, res: 0, upd: 0;
       c7Te: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Td() //  [R1]
         { info_tbl: [(c7Td,
                       label: block_c7Td_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Td: // global
           _c7Tk::P64 = R1 & 7;
           if (_c7Tk::P64 < 3) goto u7TD; else goto c7Tj;
       u7TD: // global
           if (_c7Tk::P64 < 2) goto c7Th; else goto c7Ti;
       c7Th: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 0, upd: 8;
       c7Ti: // global
           I64[Sp] = block_c7Tt_info;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c7Tj: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Tt() //  [F1]
         { info_tbl: [(c7Tt,
                       label: block_c7Tt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Tt: // global
           F1 = %MO_F_Neg_W32(F1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.313411655 UTC

[section ""data" . GHC.Integer.Type.timesDigit_closure" {
     GHC.Integer.Type.timesDigit_closure:
         const GHC.Integer.Type.timesDigit_info;
         const 0;
 },
 GHC.Integer.Type.timesDigit_entry() //  [R2, R3]
         { info_tbl: [(c7U4,
                       label: GHC.Integer.Type.timesDigit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7U4: // global
           _s7lg::I64 = R3;
           _s7lf::I64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c7UI; else goto c7UJ;
       c7UJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7UL; else goto c7UK;
       c7UL: // global
           HpAlloc = 72;
           goto c7UI;
       c7UI: // global
           R3 = _s7lg::I64;
           R2 = _s7lf::I64;
           R1 = GHC.Integer.Type.timesDigit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7UK: // global
           I64[Hp - 64] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 56] = GHC.Integer.Type.None_closure+2;
           _s7li::I64 = _s7lg::I64 & 4294967295;
           _s7lk::I64 = _s7lf::I64 & 4294967295;
           I64[Hp - 48] = _s7lk::I64 * _s7li::I64;
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = GHC.Integer.Type.None_closure+2;
           _s7ll::I64 = _s7lg::I64 >> 32;
           _s7lm::I64 = _s7lk::I64 * _s7ll::I64;
           I64[Hp - 24] = _s7lm::I64 & 4294967295 << 32;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           _s7lh::I64 = _s7lf::I64 >> 32;
           _s7lj::I64 = _s7lh::I64 * _s7li::I64;
           I64[Hp] = _s7lj::I64 & 4294967295 << 32;
           I64[Sp - 48] = block_c7UD_info;
           R4 = Hp - 39;
           R3 = Hp - 15;
           R2 = 0;
           P64[Sp - 40] = Hp - 63;
           I64[Sp - 32] = _s7lh::I64;
           I64[Sp - 24] = _s7lj::I64;
           I64[Sp - 16] = _s7ll::I64;
           I64[Sp - 8] = _s7lm::I64;
           Sp = Sp - 48;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7UD() //  [R1]
         { info_tbl: [(c7UD,
                       label: block_c7UD_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7UD: // global
           _c7Uo::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7UH_info;
           R4 = _c7Uo::P64;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7UH() //  [R1]
         { info_tbl: [(c7UH,
                       label: block_c7UH_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7UH: // global
           _s7lB::I64 = I64[Sp + 8] * I64[Sp + 24] + ((I64[Sp + 16] >> 32) + (I64[Sp + 32] >> 32));
           if (_s7lB::I64 == 0) goto c7Vi; else goto u7Vm;
       c7Vi: // global
           R1 = R1 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u7Vm: // global
           I64[Sp + 24] = _s7lB::I64;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call _c7V7() args: 0, res: 0, upd: 0;
     }
 },
 _c7V7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7V7: // global
           Hp = Hp + 48;
           _s7lB::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c7Vf; else goto c7Ve;
       c7Vf: // global
           HpAlloc = 48;
           I64[Sp] = block_c7V6_info;
           R1 = _s7lB::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7Ve: // global
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = GHC.Integer.Type.None_closure+2;
           I64[Hp - 24] = _s7lB::I64;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = 0;
           R4 = P64[Sp + 8];
           R3 = Hp - 15;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c7V6() //  [R1]
         { info_tbl: [(c7V6,
                       label: block_c7V6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7V6: // global
           I64[Sp] = R1;
           call _c7V7() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.336537292 UTC

[section ""data" . GHC.Integer.Type.timesPositive_closure" {
     GHC.Integer.Type.timesPositive_closure:
         const GHC.Integer.Type.timesPositive_info;
         const 0;
 },
 GHC.Integer.Type.timesPositive_entry() //  [R2, R3]
         { info_tbl: [(c7Wq,
                       label: GHC.Integer.Type.timesPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Wq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7Wr; else goto u7Ya;
       c7Wr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.timesPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u7Ya: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c7Wg() args: 0, res: 0, upd: 0;
     }
 },
 _c7Wg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Wg: // global
           _s7lE::P64 = P64[Sp];
           I64[Sp] = block_c7Wj_info;
           R1 = _s7lE::P64;
           if (R1 & 7 != 0) goto u7Yc; else goto c7Wk;
       u7Yc: // global
           call _c7Wj(R1) args: 0, res: 0, upd: 0;
       c7Wk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Wj() //  [R1]
         { info_tbl: [(c7Wj,
                       label: block_c7Wj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Wj: // global
           _s7lF::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7Wn; else goto c7Wo;
       c7Wn: // global
           I64[Sp - 16] = block_c7Wv_info;
           _s7lG::P64 = R1;
           _s7lI::P64 = P64[R1 + 7];
           _s7lH::I64 = I64[R1 + 15];
           R1 = _s7lF::P64;
           P64[Sp - 8] = _s7lI::P64;
           I64[Sp] = _s7lH::I64;
           P64[Sp + 8] = _s7lG::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Yd; else goto c7Wx;
       u7Yd: // global
           call _c7Wv(R1) args: 0, res: 0, upd: 0;
       c7Wx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7Wo: // global
           I64[Sp + 8] = block_c7XZ_info;
           R1 = _s7lF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Ye; else goto c7Y1;
       u7Ye: // global
           call _c7XZ() args: 0, res: 0, upd: 0;
       c7Y1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Wv() //  [R1]
         { info_tbl: [(c7Wv,
                       label: block_c7Wv_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Wv: // global
           if (R1 & 7 == 1) goto c7WE; else goto c7XW;
       c7WE: // global
           I64[Sp - 16] = block_c7WB_info;
           _s7lJ::P64 = R1;
           _s7lL::P64 = P64[R1 + 7];
           _s7lK::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s7lL::P64;
           I64[Sp] = _s7lK::I64;
           P64[Sp + 8] = _s7lJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Yg; else goto c7WF;
       u7Yg: // global
           call _c7WB(R1) args: 0, res: 0, upd: 0;
       c7WF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7XW: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7WB() //  [R1]
         { info_tbl: [(c7WB,
                       label: block_c7WB_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7WB: // global
           _s7lL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7WM; else goto c7XH;
       c7WM: // global
           I64[Sp + 8] = block_c7WJ_info;
           _s7lM::P64 = R1;
           R1 = _s7lL::P64;
           P64[Sp + 40] = _s7lM::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Yh; else goto c7WN;
       u7Yh: // global
           call _c7WJ(R1) args: 0, res: 0, upd: 0;
       c7WN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7XH: // global
           I64[Sp + 8] = block_c7XF_info;
           R1 = _s7lL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Yi; else goto c7XI;
       u7Yi: // global
           call _c7XF(R1) args: 0, res: 0, upd: 0;
       c7XI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7WJ() //  [R1]
         { info_tbl: [(c7WJ,
                       label: block_c7WJ_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7WJ: // global
           _s7lJ::P64 = P64[Sp + 16];
           _s7lM::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c7X0; else goto c7XC;
       c7X0: // global
           I64[Sp + 8] = block_c7WR_info;
           R3 = _s7lJ::P64;
           R2 = _s7lM::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c7XC: // global
           _s7lW::I64 = I64[Sp + 24];
           if (_s7lW::I64 != 0) goto c7Xk; else goto c7Xy;
       c7Xk: // global
           I64[Sp] = block_c7Xd_info;
           R3 = _s7lJ::P64;
           R2 = _s7lM::P64;
           I64[Sp + 32] = _s7lW::I64;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c7Xy: // global
           I64[Sp + 32] = block_c7Xt_info;
           R3 = _s7lJ::P64;
           R2 = _s7lM::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7WR() //  [R1]
         { info_tbl: [(c7WR,
                       label: block_c7WR_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7WR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7X3; else goto c7X2;
       c7X3: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7X2: // global
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c7WX_info;
           R3 = P64[Sp + 8];
           R2 = Hp - 15;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7WX() //  [R1]
         { info_tbl: [(c7WX,
                       label: block_c7WX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7WX: // global
           R4 = P64[Sp + 8];
           R3 = R1;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c7Xd() //  [R1]
         { info_tbl: [(c7Xd,
                       label: block_c7Xd_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Xn; else goto c7Xm;
       c7Xn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Xm: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           I64[Sp + 24] = block_c7Xi_info;
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 32];
           P64[Sp + 32] = Hp - 15;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesDigit_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xi() //  [R1]
         { info_tbl: [(c7Xi,
                       label: block_c7Xi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xi: // global
           R4 = P64[Sp + 8];
           R3 = R1;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c7Xt() //  [R1]
         { info_tbl: [(c7Xt,
                       label: block_c7Xt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7XB; else goto c7XA;
       c7XB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XA: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XF() //  [R1]
         { info_tbl: [(c7XF,
                       label: block_c7XF_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XF: // global
           if (R1 & 7 == 1) goto c7XO; else goto c7XS;
       c7XO: // global
           P64[Sp + 24] = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 32];
           Sp = Sp + 24;
           call _c7Wg() args: 0, res: 0, upd: 0;
       c7XS: // global
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Integer.Type.timesDigit_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _c7XZ() //  []
         { info_tbl: [(c7XZ,
                       label: block_c7XZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XZ: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.376424098 UTC

[section ""data" . GHC.Integer.Type.timesInteger_closure" {
     GHC.Integer.Type.timesInteger_closure:
         const GHC.Integer.Type.timesInteger_info;
         const 0;
 },
 GHC.Integer.Type.timesInteger_entry() //  [R2, R3]
         { info_tbl: [(c7ZO,
                       label: GHC.Integer.Type.timesInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ZP; else goto c7ZQ;
       c7ZP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.timesInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ZQ: // global
           I64[Sp - 16] = block_c7ZG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u81i; else goto c7ZH;
       u81i: // global
           call _c7ZG(R1) args: 0, res: 0, upd: 0;
       c7ZH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZG() //  [R1]
         { info_tbl: [(c7ZG,
                       label: block_c7ZG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZG: // global
           _s7m6::P64 = P64[Sp + 8];
           _c7ZN::P64 = R1 & 7;
           if (_c7ZN::P64 < 3) goto u81a; else goto c7ZM;
       u81a: // global
           if (_c7ZN::P64 < 2) goto c7ZK; else goto c7ZL;
       c7ZK: // global
           I64[Sp] = block_c7ZT_info;
           _s7m8::P64 = P64[R1 + 7];
           R1 = _s7m6::P64;
           P64[Sp + 8] = _s7m8::P64;
           if (R1 & 7 != 0) goto u81f; else goto c7ZV;
       u81f: // global
           call _c7ZT(R1) args: 0, res: 0, upd: 0;
       c7ZV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7ZL: // global
           I64[Sp] = block_c80s_info;
           _s7me::P64 = P64[R1 + 6];
           R1 = _s7m6::P64;
           P64[Sp + 8] = _s7me::P64;
           if (R1 & 7 != 0) goto u81g; else goto c80u;
       u81g: // global
           call _c80s(R1) args: 0, res: 0, upd: 0;
       c80u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7ZM: // global
           I64[Sp + 8] = block_c811_info;
           R1 = _s7m6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u81h; else goto c813;
       u81h: // global
           call _c811() args: 0, res: 0, upd: 0;
       c813: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZT() //  [R1]
         { info_tbl: [(c7ZT,
                       label: block_c7ZT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZT: // global
           _c819::P64 = R1 & 7;
           if (_c819::P64 < 3) goto u81b; else goto u81d;
       u81b: // global
           _s7m8::P64 = P64[Sp + 8];
           if (_c819::P64 < 2) goto c806; else goto c80i;
       c806: // global
           I64[Sp + 8] = block_c7ZZ_info;
           R3 = P64[R1 + 7];
           R2 = _s7m8::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c80i: // global
           I64[Sp + 8] = block_c80c_info;
           R3 = P64[R1 + 6];
           R2 = _s7m8::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       u81d: // global
           Sp = Sp + 16;
           call _c80Y() args: 0, res: 0, upd: 0;
     }
 },
 _c7ZZ() //  [R1]
         { info_tbl: [(c7ZZ,
                       label: block_c7ZZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c809; else goto c808;
       c809: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c808: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c80c() //  [R1]
         { info_tbl: [(c80c,
                       label: block_c80c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c80l; else goto c80k;
       c80l: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c80k: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c80s() //  [R1]
         { info_tbl: [(c80s,
                       label: block_c80s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80s: // global
           _c818::P64 = R1 & 7;
           if (_c818::P64 < 3) goto u81c; else goto u81e;
       u81c: // global
           _s7me::P64 = P64[Sp + 8];
           if (_c818::P64 < 2) goto c80F; else goto c80R;
       c80F: // global
           I64[Sp + 8] = block_c80y_info;
           R3 = P64[R1 + 7];
           R2 = _s7me::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c80R: // global
           I64[Sp + 8] = block_c80L_info;
           R3 = P64[R1 + 6];
           R2 = _s7me::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       u81e: // global
           Sp = Sp + 16;
           call _c80Y() args: 0, res: 0, upd: 0;
     }
 },
 _c80y() //  [R1]
         { info_tbl: [(c80y,
                       label: block_c80y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c80I; else goto c80H;
       c80I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c80H: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c80L() //  [R1]
         { info_tbl: [(c80L,
                       label: block_c80L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80L: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c80U; else goto c80T;
       c80U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c80T: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c80Y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80Y: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c811() //  []
         { info_tbl: [(c811,
                       label: block_c811_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c811: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.412994215 UTC

[section ""data" . GHC.Integer.Type.twoToTheThirtytwoPositive_closure" {
     GHC.Integer.Type.twoToTheThirtytwoPositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 4294967296;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.416041548 UTC

[section ""data" . GHC.Integer.Type.twoToTheThirtytwoInteger_closure" {
     GHC.Integer.Type.twoToTheThirtytwoInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.twoToTheThirtytwoPositive_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.419060946 UTC

[section ""data" . GHC.Integer.Type.digitsMaybeZeroToInteger_closure" {
     GHC.Integer.Type.digitsMaybeZeroToInteger_closure:
         const GHC.Integer.Type.digitsMaybeZeroToInteger_info;
 },
 GHC.Integer.Type.digitsMaybeZeroToInteger_entry() //  [R2]
         { info_tbl: [(c82s,
                       label: GHC.Integer.Type.digitsMaybeZeroToInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c82s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c82t; else goto c82u;
       c82t: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsMaybeZeroToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c82u: // global
           I64[Sp - 8] = block_c82l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u82E; else goto c82m;
       u82E: // global
           call _c82l(R1) args: 0, res: 0, upd: 0;
       c82m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c82l() //  [R1]
         { info_tbl: [(c82l,
                       label: block_c82l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c82l: // global
           if (R1 & 7 == 1) goto c82p; else goto c82q;
       c82p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c82A; else goto c82z;
       c82A: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c82z: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c82q: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.431241882 UTC

[section ""data" . GHC.Integer.Type.removeZeroTails_closure" {
     GHC.Integer.Type.removeZeroTails_closure:
         const GHC.Integer.Type.removeZeroTails_info;
 },
 GHC.Integer.Type.removeZeroTails_entry() //  [R2]
         { info_tbl: [(c835,
                       label: GHC.Integer.Type.removeZeroTails_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c835: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c836; else goto c837;
       c836: // global
           R2 = R2;
           R1 = GHC.Integer.Type.removeZeroTails_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c837: // global
           I64[Sp - 8] = block_c82Y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u83K; else goto c82Z;
       u83K: // global
           call _c82Y(R1) args: 0, res: 0, upd: 0;
       c82Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c82Y() //  [R1]
         { info_tbl: [(c82Y,
                       label: block_c82Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c82Y: // global
           if (R1 & 7 == 1) goto c832; else goto u83H;
       c832: // global
           _s7ms::P64 = P64[R1 + 7];
           _s7mt::I64 = I64[R1 + 15];
           if (_s7mt::I64 != 0) goto c83j; else goto c83p;
       c83j: // global
           I64[Sp - 8] = block_c83d_info;
           R2 = _s7ms::P64;
           I64[Sp] = _s7mt::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
       c83p: // global
           I64[Sp] = block_c83o_info;
           R2 = _s7ms::P64;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
       u83H: // global
           Sp = Sp + 8;
           call _c833() args: 0, res: 0, upd: 0;
     }
 },
 _c83d() //  [R1]
         { info_tbl: [(c83d,
                       label: block_c83d_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c83d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c83m; else goto c83l;
       c83m: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c83l: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c83o() //  [R1]
         { info_tbl: [(c83o,
                       label: block_c83o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c83o: // global
           if (R1 & 7 == 1) goto c83v; else goto u83I;
       c83v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c83y; else goto c83x;
       c83y: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c83x: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u83I: // global
           Sp = Sp + 8;
           call _c833() args: 0, res: 0, upd: 0;
     }
 },
 _c833() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c833: // global
           R1 = GHC.Integer.Type.None_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.448608526 UTC

[section ""data" . GHC.Integer.Type.digitsToNegativeInteger_closure" {
     GHC.Integer.Type.digitsToNegativeInteger_closure:
         const GHC.Integer.Type.digitsToNegativeInteger_info;
 },
 GHC.Integer.Type.digitsToNegativeInteger_entry() //  [R2]
         { info_tbl: [(c84q,
                       label: GHC.Integer.Type.digitsToNegativeInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c84q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c84r; else goto c84s;
       c84r: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsToNegativeInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c84s: // global
           I64[Sp - 8] = block_c84k_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c84k() //  [R1]
         { info_tbl: [(c84k,
                       label: block_c84k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c84k: // global
           if (R1 & 7 == 1) goto c84n; else goto c84o;
       c84n: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c84y; else goto c84x;
       c84y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c84x: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c84o: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.456418111 UTC

[section ""data" . GHC.Integer.Type.digitsToInteger_closure" {
     GHC.Integer.Type.digitsToInteger_closure:
         const GHC.Integer.Type.digitsToInteger_info;
 },
 GHC.Integer.Type.digitsToInteger_entry() //  [R2]
         { info_tbl: [(c850,
                       label: GHC.Integer.Type.digitsToInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c850: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c851; else goto c852;
       c851: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c852: // global
           I64[Sp - 8] = block_c84U_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c84U() //  [R1]
         { info_tbl: [(c84U,
                       label: block_c84U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c84U: // global
           if (R1 & 7 == 1) goto c84X; else goto c84Y;
       c84X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c858; else goto c857;
       c858: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c857: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c84Y: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.467874208 UTC

[section ""data" . GHC.Integer.Type.comparePositive_closure" {
     GHC.Integer.Type.comparePositive_closure:
         const GHC.Integer.Type.comparePositive_info;
 },
 GHC.Integer.Type.comparePositive_entry() //  [R2, R3]
         { info_tbl: [(c85B,
                       label: GHC.Integer.Type.comparePositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c85B: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c85C; else goto c85D;
       c85C: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.comparePositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c85D: // global
           I64[Sp - 16] = block_c85u_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u86F; else goto c85v;
       u86F: // global
           call _c85u(R1) args: 0, res: 0, upd: 0;
       c85v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c85u() //  [R1]
         { info_tbl: [(c85u,
                       label: block_c85u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c85u: // global
           _s7mH::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c85y; else goto c85z;
       c85y: // global
           I64[Sp - 8] = block_c85G_info;
           _s7mK::P64 = P64[R1 + 7];
           _s7mJ::I64 = I64[R1 + 15];
           R1 = _s7mH::P64;
           P64[Sp] = _s7mK::P64;
           I64[Sp + 8] = _s7mJ::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u86D; else goto c85I;
       u86D: // global
           call _c85G(R1) args: 0, res: 0, upd: 0;
       c85I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c85z: // global
           I64[Sp + 8] = block_c86h_info;
           R1 = _s7mH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u86E; else goto c86j;
       u86E: // global
           call _c86h(R1) args: 0, res: 0, upd: 0;
       c86j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c85G() //  [R1]
         { info_tbl: [(c85G,
                       label: block_c85G_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c85G: // global
           if (R1 & 7 == 1) goto c85P; else goto u86z;
       c85P: // global
           I64[Sp] = block_c85M_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u86z: // global
           Sp = Sp + 24;
           call _c86e() args: 0, res: 0, upd: 0;
     }
 },
 _c85M() //  [R1]
         { info_tbl: [(c85M,
                       label: block_c85M_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c85M: // global
           if (R1 & 7 == 2) goto c86a; else goto c85V;
       c86a: // global
           _s7mJ::I64 = I64[Sp + 16];
           _s7mM::I64 = I64[Sp + 8];
           if (_s7mJ::I64 >= _s7mM::I64) goto c868; else goto u86A;
       c868: // global
           if (_s7mJ::I64 <= _s7mM::I64) goto u86C; else goto u86B;
       u86C: // global
           Sp = Sp + 24;
           call _c86t() args: 0, res: 0, upd: 0;
       u86B: // global
           Sp = Sp + 24;
           call _c86e() args: 0, res: 0, upd: 0;
       u86A: // global
           Sp = Sp + 24;
           call _c86p() args: 0, res: 0, upd: 0;
       c85V: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c86e() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c86e: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c86h() //  [R1]
         { info_tbl: [(c86h,
                       label: block_c86h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c86h: // global
           if (R1 & 7 == 1) goto u86x; else goto u86y;
       u86x: // global
           Sp = Sp + 8;
           call _c86p() args: 0, res: 0, upd: 0;
       u86y: // global
           Sp = Sp + 8;
           call _c86t() args: 0, res: 0, upd: 0;
     }
 },
 _c86p() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c86p: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c86t() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c86t: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.490840781 UTC

[section ""data" . GHC.Integer.Type.compareInteger_closure" {
     GHC.Integer.Type.compareInteger_closure:
         const GHC.Integer.Type.compareInteger_info;
 },
 GHC.Integer.Type.compareInteger_entry() //  [R2, R3]
         { info_tbl: [(c87J,
                       label: GHC.Integer.Type.compareInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c87J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c87K; else goto c87L;
       c87K: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.compareInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c87L: // global
           I64[Sp - 16] = block_c87B_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u88L; else goto c87C;
       u88L: // global
           call _c87B(R1) args: 0, res: 0, upd: 0;
       c87C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c87B() //  [R1]
         { info_tbl: [(c87B,
                       label: block_c87B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c87B: // global
           _s7mV::P64 = P64[Sp + 8];
           _c87I::P64 = R1 & 7;
           if (_c87I::P64 < 3) goto u88C; else goto c87H;
       u88C: // global
           if (_c87I::P64 < 2) goto c87F; else goto c87G;
       c87F: // global
           I64[Sp] = block_c87O_info;
           _s7mX::P64 = P64[R1 + 7];
           R1 = _s7mV::P64;
           P64[Sp + 8] = _s7mX::P64;
           if (R1 & 7 != 0) goto u88I; else goto c87Q;
       u88I: // global
           call _c87O(R1) args: 0, res: 0, upd: 0;
       c87Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c87G: // global
           I64[Sp] = block_c883_info;
           _s7n0::P64 = P64[R1 + 6];
           R1 = _s7mV::P64;
           P64[Sp + 8] = _s7n0::P64;
           if (R1 & 7 != 0) goto u88J; else goto c885;
       u88J: // global
           call _c883(R1) args: 0, res: 0, upd: 0;
       c885: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c87H: // global
           I64[Sp + 8] = block_c88i_info;
           R1 = _s7mV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u88K; else goto c88k;
       u88K: // global
           call _c88i(R1) args: 0, res: 0, upd: 0;
       c88k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c87O() //  [R1]
         { info_tbl: [(c87O,
                       label: block_c87O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c87O: // global
           if (R1 & 7 == 1) goto c880; else goto u88E;
       c880: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       u88E: // global
           Sp = Sp + 16;
           call _c88u() args: 0, res: 0, upd: 0;
     }
 },
 _c883() //  [R1]
         { info_tbl: [(c883,
                       label: block_c883_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c883: // global
           if (R1 & 7 == 2) goto c88f; else goto u88F;
       c88f: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       u88F: // global
           Sp = Sp + 16;
           call _c88q() args: 0, res: 0, upd: 0;
     }
 },
 _c88i() //  [R1]
         { info_tbl: [(c88i,
                       label: block_c88i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c88i: // global
           _c88z::P64 = R1 & 7;
           if (_c88z::P64 < 3) goto u88D; else goto c88y;
       u88D: // global
           if (_c88z::P64 < 2) goto u88H; else goto u88G;
       u88H: // global
           Sp = Sp + 8;
           call _c88q() args: 0, res: 0, upd: 0;
       u88G: // global
           Sp = Sp + 8;
           call _c88u() args: 0, res: 0, upd: 0;
       c88y: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c88q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c88q: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c88u() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c88u: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.510532924 UTC

[section ""data" . GHC.Integer.Type.eqInteger#_closure" {
     GHC.Integer.Type.eqInteger#_closure:
         const GHC.Integer.Type.eqInteger#_info;
 },
 GHC.Integer.Type.eqInteger#_entry() //  [R2, R3]
         { info_tbl: [(c89F,
                       label: GHC.Integer.Type.eqInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c89F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c89G; else goto c89H;
       c89G: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.eqInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c89H: // global
           I64[Sp - 8] = block_c89z_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c89z() //  [R1]
         { info_tbl: [(c89z,
                       label: block_c89z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c89z: // global
           if (R1 & 7 == 2) goto c89D; else goto c89C;
       c89D: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c89C: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.520863801 UTC

[section ""data" . GHC.Integer.Type.eqInteger_closure" {
     GHC.Integer.Type.eqInteger_closure:
         const GHC.Integer.Type.eqInteger_info;
 },
 GHC.Integer.Type.eqInteger_entry() //  [R2, R3]
         { info_tbl: [(c8a7,
                       label: GHC.Integer.Type.eqInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8a7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8a8; else goto c8a9;
       c8a8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.eqInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8a9: // global
           I64[Sp - 8] = block_c8a5_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8a5() //  [R1]
         { info_tbl: [(c8a5,
                       label: block_c8a5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8a5: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.528077441 UTC

[section ""data" . GHC.Integer.Type.neqInteger#_closure" {
     GHC.Integer.Type.neqInteger#_closure:
         const GHC.Integer.Type.neqInteger#_info;
 },
 GHC.Integer.Type.neqInteger#_entry() //  [R2, R3]
         { info_tbl: [(c8az,
                       label: GHC.Integer.Type.neqInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8az: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8aA; else goto c8aB;
       c8aA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.neqInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aB: // global
           I64[Sp - 8] = block_c8at_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8at() //  [R1]
         { info_tbl: [(c8at,
                       label: block_c8at_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8at: // global
           if (R1 & 7 == 2) goto c8ax; else goto c8aw;
       c8ax: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8aw: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.534780112 UTC

[section ""data" . GHC.Integer.Type.neqInteger_closure" {
     GHC.Integer.Type.neqInteger_closure:
         const GHC.Integer.Type.neqInteger_info;
 },
 GHC.Integer.Type.neqInteger_entry() //  [R2, R3]
         { info_tbl: [(c8b1,
                       label: GHC.Integer.Type.neqInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8b2; else goto c8b3;
       c8b2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.neqInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8b3: // global
           I64[Sp - 8] = block_c8aZ_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8aZ() //  [R1]
         { info_tbl: [(c8aZ,
                       label: block_c8aZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aZ: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.542395624 UTC

[section ""data" . GHC.Integer.Type.$fEqInteger_closure" {
     GHC.Integer.Type.$fEqInteger_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.545181252 UTC

[section ""data" . GHC.Integer.Type.ltInteger#_closure" {
     GHC.Integer.Type.ltInteger#_closure:
         const GHC.Integer.Type.ltInteger#_info;
 },
 GHC.Integer.Type.ltInteger#_entry() //  [R2, R3]
         { info_tbl: [(c8bu,
                       label: GHC.Integer.Type.ltInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bv; else goto c8bw;
       c8bv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.ltInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bw: // global
           I64[Sp - 8] = block_c8bo_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8bo() //  [R1]
         { info_tbl: [(c8bo,
                       label: block_c8bo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bo: // global
           if (R1 & 7 == 1) goto c8bs; else goto c8br;
       c8bs: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8br: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.552507384 UTC

[section ""data" . GHC.Integer.Type.ltInteger_closure" {
     GHC.Integer.Type.ltInteger_closure:
         const GHC.Integer.Type.ltInteger_info;
 },
 GHC.Integer.Type.ltInteger_entry() //  [R2, R3]
         { info_tbl: [(c8bW,
                       label: GHC.Integer.Type.ltInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bX; else goto c8bY;
       c8bX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.ltInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bY: // global
           I64[Sp - 8] = block_c8bU_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8bU() //  [R1]
         { info_tbl: [(c8bU,
                       label: block_c8bU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bU: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.559093871 UTC

[section ""data" . GHC.Integer.Type.gtInteger#_closure" {
     GHC.Integer.Type.gtInteger#_closure:
         const GHC.Integer.Type.gtInteger#_info;
 },
 GHC.Integer.Type.gtInteger#_entry() //  [R2, R3]
         { info_tbl: [(c8co,
                       label: GHC.Integer.Type.gtInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8co: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cp; else goto c8cq;
       c8cp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.gtInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cq: // global
           I64[Sp - 8] = block_c8ci_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ci() //  [R1]
         { info_tbl: [(c8ci,
                       label: block_c8ci_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ci: // global
           if (R1 & 7 == 3) goto c8cm; else goto c8cl;
       c8cm: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8cl: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.566311922 UTC

[section ""data" . GHC.Integer.Type.gtInteger_closure" {
     GHC.Integer.Type.gtInteger_closure:
         const GHC.Integer.Type.gtInteger_info;
 },
 GHC.Integer.Type.gtInteger_entry() //  [R2, R3]
         { info_tbl: [(c8cQ,
                       label: GHC.Integer.Type.gtInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cR; else goto c8cS;
       c8cR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.gtInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cS: // global
           I64[Sp - 8] = block_c8cO_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8cO() //  [R1]
         { info_tbl: [(c8cO,
                       label: block_c8cO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cO: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.572773835 UTC

[section ""data" . GHC.Integer.Type.leInteger#_closure" {
     GHC.Integer.Type.leInteger#_closure:
         const GHC.Integer.Type.leInteger#_info;
 },
 GHC.Integer.Type.leInteger#_entry() //  [R2, R3]
         { info_tbl: [(c8di,
                       label: GHC.Integer.Type.leInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8di: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8dj; else goto c8dk;
       c8dj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.leInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8dk: // global
           I64[Sp - 8] = block_c8dc_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8dc() //  [R1]
         { info_tbl: [(c8dc,
                       label: block_c8dc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dc: // global
           if (R1 & 7 == 3) goto c8dg; else goto c8df;
       c8dg: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8df: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.58051986 UTC

[section ""data" . GHC.Integer.Type.leInteger_closure" {
     GHC.Integer.Type.leInteger_closure:
         const GHC.Integer.Type.leInteger_info;
 },
 GHC.Integer.Type.leInteger_entry() //  [R2, R3]
         { info_tbl: [(c8dK,
                       label: GHC.Integer.Type.leInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8dL; else goto c8dM;
       c8dL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.leInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8dM: // global
           I64[Sp - 8] = block_c8dI_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8dI() //  [R1]
         { info_tbl: [(c8dI,
                       label: block_c8dI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dI: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.587570654 UTC

[section ""data" . GHC.Integer.Type.geInteger#_closure" {
     GHC.Integer.Type.geInteger#_closure:
         const GHC.Integer.Type.geInteger#_info;
 },
 GHC.Integer.Type.geInteger#_entry() //  [R2, R3]
         { info_tbl: [(c8ec,
                       label: GHC.Integer.Type.geInteger#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ec: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ed; else goto c8ee;
       c8ed: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.geInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ee: // global
           I64[Sp - 8] = block_c8e6_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8e6() //  [R1]
         { info_tbl: [(c8e6,
                       label: block_c8e6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e6: // global
           if (R1 & 7 == 1) goto c8ea; else goto c8e9;
       c8ea: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8e9: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.594990756 UTC

[section ""data" . GHC.Integer.Type.geInteger_closure" {
     GHC.Integer.Type.geInteger_closure:
         const GHC.Integer.Type.geInteger_info;
 },
 GHC.Integer.Type.geInteger_entry() //  [R2, R3]
         { info_tbl: [(c8eE,
                       label: GHC.Integer.Type.geInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8eF; else goto c8eG;
       c8eF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.geInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eG: // global
           I64[Sp - 8] = block_c8eC_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8eC() //  [R1]
         { info_tbl: [(c8eC,
                       label: block_c8eC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eC: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.602284855 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_$cmax_closure" {
     GHC.Integer.Type.$fOrdInteger_$cmax_closure:
         const GHC.Integer.Type.$fOrdInteger_$cmax_info;
 },
 GHC.Integer.Type.$fOrdInteger_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8f5,
                       label: GHC.Integer.Type.$fOrdInteger_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8f6; else goto c8f7;
       c8f6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$fOrdInteger_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8f7: // global
           I64[Sp - 24] = block_c8f0_info;
           _s7nH::P64 = R3;
           R3 = R3;
           _s7nG::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s7nG::P64;
           P64[Sp - 8] = _s7nH::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8f0() //  [R1]
         { info_tbl: [(c8f0,
                       label: block_c8f0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f0: // global
           if (R1 == 1) goto c8f4; else goto c8f3;
       c8f4: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8f3: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.609966247 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_$cmin_closure" {
     GHC.Integer.Type.$fOrdInteger_$cmin_closure:
         const GHC.Integer.Type.$fOrdInteger_$cmin_info;
 },
 GHC.Integer.Type.$fOrdInteger_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8fA,
                       label: GHC.Integer.Type.$fOrdInteger_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8fB; else goto c8fC;
       c8fB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$fOrdInteger_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8fC: // global
           I64[Sp - 24] = block_c8fv_info;
           _s7nK::P64 = R3;
           R3 = R3;
           _s7nJ::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s7nJ::P64;
           P64[Sp - 8] = _s7nK::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8fv() //  [R1]
         { info_tbl: [(c8fv,
                       label: block_c8fv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fv: // global
           if (R1 == 1) goto c8fz; else goto c8fy;
       c8fz: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8fy: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.616529792 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_closure" {
     GHC.Integer.Type.$fOrdInteger_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Integer.Type.$fEqInteger_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.620953583 UTC

[section ""data" . GHC.Integer.Type.plusInteger_closure" {
     GHC.Integer.Type.plusInteger_closure:
         const GHC.Integer.Type.plusInteger_info;
         const 0;
 },
 GHC.Integer.Type.plusInteger_entry() //  [R2, R3]
         { info_tbl: [(c8g9,
                       label: GHC.Integer.Type.plusInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8ga; else goto u8hJ;
       c8ga: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.plusInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u8hJ: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c8fY() args: 0, res: 0, upd: 0;
     }
 },
 _c8fY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fY: // global
           _s7nM::P64 = P64[Sp];
           I64[Sp] = block_c8g1_info;
           R1 = _s7nM::P64;
           if (R1 & 7 != 0) goto u8hN; else goto c8g2;
       u8hN: // global
           call _c8g1(R1) args: 0, res: 0, upd: 0;
       c8g2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g1() //  [R1]
         { info_tbl: [(c8g1,
                       label: block_c8g1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g1: // global
           _s7nN::P64 = P64[Sp + 8];
           _c8g8::P64 = R1 & 7;
           if (_c8g8::P64 < 3) goto u8hF; else goto c8g7;
       u8hF: // global
           if (_c8g8::P64 < 2) goto c8g5; else goto c8g6;
       c8g5: // global
           I64[Sp - 8] = block_c8ge_info;
           _s7nO::P64 = R1;
           _s7nP::P64 = P64[R1 + 7];
           R1 = _s7nN::P64;
           P64[Sp] = _s7nP::P64;
           P64[Sp + 8] = _s7nO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8hO; else goto c8gg;
       u8hO: // global
           call _c8ge(R1) args: 0, res: 0, upd: 0;
       c8gg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8g6: // global
           I64[Sp - 8] = block_c8ha_info;
           _s7nO::P64 = R1;
           _s7nX::P64 = P64[R1 + 6];
           R1 = _s7nN::P64;
           P64[Sp] = _s7nX::P64;
           P64[Sp + 8] = _s7nO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8hP; else goto c8hc;
       u8hP: // global
           call _c8ha(R1) args: 0, res: 0, upd: 0;
       c8hc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8g7: // global
           R1 = _s7nN::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ge() //  [R1]
         { info_tbl: [(c8ge,
                       label: block_c8ge_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ge: // global
           _c8hD::P64 = R1 & 7;
           if (_c8hD::P64 < 3) goto u8hG; else goto u8hK;
       u8hG: // global
           _s7nP::P64 = P64[Sp + 8];
           if (_c8hD::P64 < 2) goto c8gr; else goto c8gz;
       c8gr: // global
           I64[Sp + 16] = block_c8gk_info;
           R4 = P64[R1 + 7];
           R3 = _s7nP::P64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c8gz: // global
           I64[Sp] = block_c8gx_info;
           _s7nT::P64 = P64[R1 + 6];
           R3 = _s7nT::P64;
           R2 = _s7nP::P64;
           P64[Sp + 16] = _s7nT::P64;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8hK: // global
           Sp = Sp + 16;
           call _c8hy() args: 0, res: 0, upd: 0;
     }
 },
 _c8gk() //  [R1]
         { info_tbl: [(c8gk,
                       label: block_c8gk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8gu; else goto c8gt;
       c8gu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8gt: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8gx() //  [R1]
         { info_tbl: [(c8gx,
                       label: block_c8gx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gx: // global
           _s7nP::P64 = P64[Sp + 8];
           _s7nT::P64 = P64[Sp + 16];
           _c8hE::P64 = R1 & 7;
           if (_c8hE::P64 < 3) goto u8hH; else goto c8h0;
       u8hH: // global
           if (_c8hE::P64 < 2) goto c8gK; else goto c8gR;
       c8gK: // global
           I64[Sp + 16] = block_c8gD_info;
           R3 = _s7nP::P64;
           R2 = _s7nT::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c8gR: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8h0: // global
           I64[Sp + 16] = block_c8gU_info;
           R3 = _s7nT::P64;
           R2 = _s7nP::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8gD() //  [R1]
         { info_tbl: [(c8gD,
                       label: block_c8gD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8gN; else goto c8gM;
       c8gN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8gM: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8gU() //  [R1]
         { info_tbl: [(c8gU,
                       label: block_c8gU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8h3; else goto c8h2;
       c8h3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8h2: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ha() //  [R1]
         { info_tbl: [(c8ha,
                       label: block_c8ha_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ha: // global
           _c8hC::P64 = R1 & 7;
           if (_c8hC::P64 < 3) goto u8hI; else goto u8hL;
       u8hI: // global
           if (_c8hC::P64 < 2) goto c8hi; else goto c8hr;
       c8hi: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c8fY() args: 0, res: 0, upd: 0;
       c8hr: // global
           I64[Sp + 16] = block_c8hl_info;
           R4 = P64[R1 + 6];
           R3 = P64[Sp + 8];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       u8hL: // global
           Sp = Sp + 16;
           call _c8hy() args: 0, res: 0, upd: 0;
     }
 },
 _c8hl() //  [R1]
         { info_tbl: [(c8hl,
                       label: block_c8hl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8hl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8hu; else goto c8ht;
       c8hu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ht: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8hy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8hy: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.649920895 UTC

[section ""data" . GHC.Integer.Type.minusInteger_closure" {
     GHC.Integer.Type.minusInteger_closure:
         const GHC.Integer.Type.minusInteger_info;
         const 0;
 },
 GHC.Integer.Type.minusInteger_entry() //  [R2, R3]
         { info_tbl: [(c8j0,
                       label: GHC.Integer.Type.minusInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8j0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8j1; else goto c8j2;
       c8j1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.minusInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8j2: // global
           I64[Sp - 16] = block_c8iY_info;
           _s7o2::P64 = R2;
           R2 = R3;
           P64[Sp - 8] = _s7o2::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8iY() //  [R1]
         { info_tbl: [(c8iY,
                       label: block_c8iY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8iY: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.656847056 UTC

[section ""data" . GHC.Integer.Type.complementInteger_closure" {
     GHC.Integer.Type.complementInteger_closure:
         const GHC.Integer.Type.complementInteger_info;
         const 0;
 },
 GHC.Integer.Type.complementInteger_entry() //  [R2]
         { info_tbl: [(c8jj,
                       label: GHC.Integer.Type.complementInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jj: // global
           R3 = R2;
           R2 = GHC.Integer.Type.negativeOneInteger_closure+2;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.661858271 UTC

[section ""data" . GHC.Integer.Type.decodeDoubleInteger_closure" {
     GHC.Integer.Type.decodeDoubleInteger_closure:
         const GHC.Integer.Type.decodeDoubleInteger_info;
         const 0;
 },
 sat_s7oh_entry() //  [R1]
         { info_tbl: [(c8jE,
                       label: sat_s7oh_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8jU; else goto c8jV;
       c8jU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8jC_info;
           R2 = I64[R1 + 32];
           I64[Sp - 32] = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8jC() //  [R1]
         { info_tbl: [(c8jC,
                       label: block_c8jC_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jC: // global
           I64[Sp] = block_c8jH_info;
           R2 = I64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8jH() //  [R1]
         { info_tbl: [(c8jH,
                       label: block_c8jH_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jH: // global
           I64[Sp] = block_c8jL_info;
           R3 = GHC.Integer.Type.twoToTheThirtytwoInteger_closure+1;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8jL() //  [R1]
         { info_tbl: [(c8jL,
                       label: block_c8jL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jL: // global
           I64[Sp] = block_c8jP_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8jP() //  [R1]
         { info_tbl: [(c8jP,
                       label: block_c8jP_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jP: // global
           _s7o8::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8jT_info;
           R2 = _s7o8::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8jT() //  [R1]
         { info_tbl: [(c8jT,
                       label: block_c8jT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jT: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.decodeDoubleInteger_entry() //  [D1]
         { info_tbl: [(c8k4,
                       label: GHC.Integer.Type.decodeDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 7} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8k4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8k5; else goto c8k6;
       c8k5: // global
           D1 = D1;
           R1 = GHC.Integer.Type.decodeDoubleInteger_closure;
           call (stg_gc_fun)(D1, R1) args: 8, res: 0, upd: 8;
       c8k6: // global
           I64[Sp - 8] = block_c8ju_info;
           D1 = D1;
           Sp = Sp - 8;
           call stg_decodeDouble_2Int#(D1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ju() //  [R1, R2, R3, R4]
         { info_tbl: [(c8ju,
                       label: block_c8ju_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ju: // global
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           I64[Sp] = R1;
           Sp = Sp - 32;
           call _c8jv() args: 0, res: 0, upd: 0;
     }
 },
 _c8jv() //  []
         { info_tbl: [(c8jv,
                       label: block_c8jv_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8jv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8k9; else goto c8k8;
       c8k9: // global
           HpAlloc = 40;
           I64[Sp] = block_c8jv_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8k8: // global
           I64[Hp - 32] = sat_s7oh_info;
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = I64[Sp + 24];
           R1 = Hp - 32;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.68439983 UTC

[section ""data" . GHC.Integer.Type.smallShiftLPositive_closure" {
     GHC.Integer.Type.smallShiftLPositive_closure:
         const GHC.Integer.Type.smallShiftLPositive_info;
 },
 f2_s7om_entry() //  [R1, R2, R3]
         { info_tbl: [(c8lg,
                       label: f2_s7om_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8lh; else goto c8li;
       c8lh: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8li: // global
           I64[Sp - 40] = block_c8l9_info;
           _s7om::P64 = R1;
           _s7ok::I64 = I64[R1 + 6];
           _s7ol::I64 = I64[R1 + 14];
           R1 = R3;
           I64[Sp - 32] = _s7ok::I64;
           I64[Sp - 24] = _s7ol::I64;
           P64[Sp - 16] = _s7om::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8lO; else goto c8la;
       u8lO: // global
           call _c8l9(R1) args: 0, res: 0, upd: 0;
       c8la: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8l9() //  [R1]
         { info_tbl: [(c8l9,
                       label: block_c8l9_info
                       rep:StackRep [True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8l9: // global
           if (R1 & 7 == 1) goto c8ld; else goto c8le;
       c8ld: // global
           I64[Sp] = block_c8lo_info;
           R3 = P64[R1 + 7];
           _s7oq::I64 = I64[R1 + 15];
           R2 = _s7oq::I64 >> I64[Sp + 16];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7oq::I64;
           call f2_s7om_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
       c8le: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lH; else goto c8lG;
       c8lH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lG: // global
           _s7ow::I64 = I64[Sp + 32];
           if (_s7ow::I64 != 0) goto c8lM; else goto c8lN;
       c8lM: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s7ow::I64;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lN: // global
           Hp = Hp - 24;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8lo() //  [R1]
         { info_tbl: [(c8lo,
                       label: block_c8lo_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lC; else goto c8lB;
       c8lC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lB: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = (I64[Sp + 24] << I64[Sp + 8]) | I64[Sp + 32];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Integer.Type.smallShiftLPositive_entry() //  [R2, R3]
         { info_tbl: [(c8lS,
                       label: GHC.Integer.Type.smallShiftLPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8lS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lW; else goto c8lV;
       c8lW: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.smallShiftLPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lV: // global
           if (R3 == 0) goto c8lR; else goto c8lQ;
       c8lR: // global
           Hp = Hp - 24;
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8lQ: // global
           I64[Hp - 16] = f2_s7om_info;
           I64[Hp - 8] = R3;
           I64[Hp] = 64 - R3;
           R3 = R2;
           R2 = 0;
           R1 = Hp - 14;
           call f2_s7om_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.698259888 UTC

[section ""data" . GHC.Integer.Type.smallShiftRPositive_closure" {
     GHC.Integer.Type.smallShiftRPositive_closure:
         const GHC.Integer.Type.smallShiftRPositive_info;
 },
 GHC.Integer.Type.smallShiftRPositive_entry() //  [R2, R3]
         { info_tbl: [(c8mC,
                       label: GHC.Integer.Type.smallShiftRPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mD; else goto c8mE;
       c8mD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.smallShiftRPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mE: // global
           I64[Sp - 16] = block_c8mz_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8no; else goto c8mA;
       u8no: // global
           call _c8mz(R1) args: 0, res: 0, upd: 0;
       c8mA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8mz() //  [R1]
         { info_tbl: [(c8mz,
                       label: block_c8mz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8mJ; else goto c8mI;
       c8mJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8mI: // global
           _s7oA::I64 = I64[Sp + 8];
           if (_s7oA::I64 == 0) goto c8nj; else goto c8mR;
       c8nj: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8mR: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_c8mP_info;
           R3 = 64 - _s7oA::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8mP() //  [R1]
         { info_tbl: [(c8mP,
                       label: block_c8mP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mP: // global
           if (R1 & 7 == 1) goto c8mY; else goto u8nm;
       c8mY: // global
           I64[Sp] = block_c8mV_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u8np; else goto c8mZ;
       u8np: // global
           call _c8mV(R1) args: 0, res: 0, upd: 0;
       c8mZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8nm: // global
           Sp = Sp + 8;
           call _c8ng() args: 0, res: 0, upd: 0;
     }
 },
 _c8mV() //  [R1]
         { info_tbl: [(c8mV,
                       label: block_c8mV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8mV: // global
           if (R1 & 7 == 1) goto c8n5; else goto u8nn;
       c8n5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8n8; else goto c8n7;
       c8n8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8n7: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8nn: // global
           Sp = Sp + 8;
           call _c8ng() args: 0, res: 0, upd: 0;
     }
 },
 _c8ng() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ng: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.713702659 UTC

[section ""data" . GHC.Integer.Type.shiftRPositive_closure" {
     GHC.Integer.Type.shiftRPositive_closure:
         const GHC.Integer.Type.shiftRPositive_info;
 },
 GHC.Integer.Type.shiftRPositive_entry() //  [R2, R3]
         { info_tbl: [(c8o8,
                       label: GHC.Integer.Type.shiftRPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8o9; else goto u8op;
       c8o9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftRPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u8op: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c8nY() args: 0, res: 0, upd: 0;
     }
 },
 _c8nY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8nY: // global
           _s7oI::P64 = P64[Sp];
           I64[Sp] = block_c8o1_info;
           R1 = _s7oI::P64;
           if (R1 & 7 != 0) goto u8or; else goto c8o2;
       u8or: // global
           call _c8o1(R1) args: 0, res: 0, upd: 0;
       c8o2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8o1() //  [R1]
         { info_tbl: [(c8o1,
                       label: block_c8o1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8o1: // global
           if (R1 & 7 == 1) goto c8o5; else goto c8o6;
       c8o5: // global
           _s7oJ::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s7oJ::I64, 64)) goto c8oh; else goto c8oi;
       c8oh: // global
           R3 = _s7oJ::I64;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallShiftRPositive_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       c8oi: // global
           P64[Sp] = P64[R1 + 7];
           I64[Sp + 8] = _s7oJ::I64 - 64;
           call _c8nY() args: 0, res: 0, upd: 0;
       c8o6: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.723131007 UTC

[section ""data" . GHC.Integer.Type.shiftRInteger_closure" {
     GHC.Integer.Type.shiftRInteger_closure:
         const GHC.Integer.Type.shiftRInteger_info;
         const 0;
 },
 GHC.Integer.Type.shiftRInteger_entry() //  [R2, R3]
         { info_tbl: [(c8oX,
                       label: GHC.Integer.Type.shiftRInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oY; else goto c8oZ;
       c8oY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftRInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oZ: // global
           I64[Sp - 16] = block_c8oP_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pk; else goto c8oQ;
       u8pk: // global
           call _c8oP(R1) args: 0, res: 0, upd: 0;
       c8oQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8oP() //  [R1]
         { info_tbl: [(c8oP,
                       label: block_c8oP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8oP: // global
           _c8oW::P64 = R1 & 7;
           if (_c8oW::P64 < 3) goto u8pj; else goto c8oV;
       u8pj: // global
           if (_c8oW::P64 < 2) goto c8oT; else goto c8oU;
       c8oT: // global
           R3 = I64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRPositive_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
       c8oU: // global
           I64[Sp] = block_c8p5_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
       c8oV: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8p5() //  [R1]
         { info_tbl: [(c8p5,
                       label: block_c8p5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p5: // global
           _s7oQ::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8p9_info;
           R3 = _s7oQ::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8p9() //  [R1]
         { info_tbl: [(c8p9,
                       label: block_c8p9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8p9: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.735173176 UTC

[section ""data" . GHC.Integer.Type.shiftLPositive_closure" {
     GHC.Integer.Type.shiftLPositive_closure:
         const GHC.Integer.Type.shiftLPositive_info;
 },
 GHC.Integer.Type.shiftLPositive_entry() //  [R2, R3]
         { info_tbl: [(c8pZ,
                       label: GHC.Integer.Type.shiftLPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8q0; else goto u8q5;
       c8q0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftLPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u8q5: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c8pG() args: 0, res: 0, upd: 0;
     }
 },
 _c8pG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pG: // global
           _s7oW::P64 = P64[Sp];
           _s7oX::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s7oX::I64, 64)) goto c8pX; else goto c8pY;
       c8pX: // global
           R3 = _s7oX::I64;
           R2 = _s7oW::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       c8pY: // global
           I64[Sp] = block_c8pN_info;
           R1 = _s7oW::P64;
           if (R1 & 7 != 0) goto u8q7; else goto c8pO;
       u8q7: // global
           call _c8pN(R1) args: 0, res: 0, upd: 0;
       c8pO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pN() //  [R1]
         { info_tbl: [(c8pN,
                       label: block_c8pN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8pN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8q4; else goto c8q3;
       c8q4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8q3: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           P64[Sp] = Hp - 15;
           I64[Sp + 8] = I64[Sp + 8] - 64;
           call _c8pG() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.744416861 UTC

[section ""data" . GHC.Integer.Type.shiftLInteger_closure" {
     GHC.Integer.Type.shiftLInteger_closure:
         const GHC.Integer.Type.shiftLInteger_info;
 },
 GHC.Integer.Type.shiftLInteger_entry() //  [R2, R3]
         { info_tbl: [(c8qA,
                       label: GHC.Integer.Type.shiftLInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qB; else goto c8qC;
       c8qB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftLInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8qC: // global
           I64[Sp - 16] = block_c8qs_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8r3; else goto c8qt;
       u8r3: // global
           call _c8qs(R1) args: 0, res: 0, upd: 0;
       c8qt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8qs() //  [R1]
         { info_tbl: [(c8qs,
                       label: block_c8qs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qs: // global
           _c8qz::P64 = R1 & 7;
           if (_c8qz::P64 < 3) goto u8r2; else goto c8qy;
       u8r2: // global
           _s7p3::I64 = I64[Sp + 8];
           if (_c8qz::P64 < 2) goto c8qw; else goto c8qx;
       c8qw: // global
           I64[Sp + 8] = block_c8qF_info;
           R3 = _s7p3::I64;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLPositive_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
       c8qx: // global
           I64[Sp + 8] = block_c8qQ_info;
           R3 = _s7p3::I64;
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLPositive_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
       c8qy: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qF() //  [R1]
         { info_tbl: [(c8qF,
                       label: block_c8qF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qN; else goto c8qM;
       c8qN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qM: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8qQ() //  [R1]
         { info_tbl: [(c8qQ,
                       label: block_c8qQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8qQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qY; else goto c8qX;
       c8qY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qX: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.758514675 UTC

[section ""data" . GHC.Integer.Type.some_closure" {
     GHC.Integer.Type.some_closure:
         const GHC.Integer.Type.some_info;
 },
 GHC.Integer.Type.some_entry() //  [R2, R3]
         { info_tbl: [(c8rD,
                       label: GHC.Integer.Type.some_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8rE; else goto c8rF;
       c8rE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.some_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8rF: // global
           I64[Sp - 16] = block_c8rw_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8rX; else goto c8rx;
       u8rX: // global
           call _c8rw(R1) args: 0, res: 0, upd: 0;
       c8rx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8rw() //  [R1]
         { info_tbl: [(c8rw,
                       label: block_c8rw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rw: // global
           _s7p9::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c8rA; else goto c8rB;
       c8rA: // global
           Hp = Hp + 24;
           _s7pb::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8rQ; else goto c8rK;
       c8rK: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = _s7pb::P64;
           I64[Hp] = _s7p9::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8rB: // global
           Hp = Hp + 24;
           _s7pb::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8rQ; else goto c8rP;
       c8rQ: // global
           HpAlloc = 24;
           R1 = _s7pb::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8rP: // global
           if (_s7p9::I64 == 0) goto c8rW; else goto c8rV;
       c8rW: // global
           Hp = Hp - 24;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8rV: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s7p9::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.767440617 UTC

[section ""data" . GHC.Integer.Type.quotRemPositive_g_closure" {
     GHC.Integer.Type.quotRemPositive_g_closure:
         const GHC.Integer.Type.quotRemPositive_g_info;
 },
 GHC.Integer.Type.quotRemPositive_g_entry() //  [R2, R3, R4]
         { info_tbl: [(c8sr,
                       label: GHC.Integer.Type.quotRemPositive_g_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8ss; else goto u8t2;
       c8ss: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemPositive_g_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u8t2: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c8sh() args: 0, res: 0, upd: 0;
     }
 },
 _c8sh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sh: // global
           I64[Sp - 8] = block_c8sk_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8t5; else goto c8sl;
       u8t5: // global
           call _c8sk(R1) args: 0, res: 0, upd: 0;
       c8sl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sk() //  [R1]
         { info_tbl: [(c8sk,
                       label: block_c8sk_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sk: // global
           _s7ph::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8so; else goto c8sp;
       c8so: // global
           I64[Sp] = block_c8sw_info;
           R1 = _s7ph::P64;
           if (R1 & 7 != 0) goto u8t6; else goto c8sy;
       u8t6: // global
           call _c8sw(R1) args: 0, res: 0, upd: 0;
       c8sy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8sp: // global
           I64[Sp - 8] = block_c8sF_info;
           _s7pk::P64 = P64[R1 + 6];
           R3 = _s7pk::P64;
           R2 = _s7ph::P64;
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 16] = _s7pk::P64;
           Sp = Sp - 8;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8sw() //  [R1]
         { info_tbl: [(c8sw,
                       label: block_c8sw_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sw: // global
           R2 = R1;
           R1 = I64[Sp + 8];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8sF() //  [R1]
         { info_tbl: [(c8sF,
                       label: block_c8sF_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sF: // global
           _s7ph::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c8sV; else goto c8sN;
       c8sV: // global
           I64[Sp + 16] = I64[Sp + 16] << 1;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _s7ph::P64;
           Sp = Sp + 16;
           call _c8sh() args: 0, res: 0, upd: 0;
       c8sN: // global
           I64[Sp] = block_c8sK_info;
           R3 = P64[Sp + 24];
           R2 = _s7ph::P64;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8sK() //  [R1]
         { info_tbl: [(c8sK,
                       label: block_c8sK_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sK: // global
           I64[Sp + 16] = (I64[Sp + 16] << 1) + 1;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call _c8sh() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.786472965 UTC

[section ""data" . GHC.Integer.Type.quotRemPositive_closure" {
     GHC.Integer.Type.quotRemPositive_closure:
         const GHC.Integer.Type.quotRemPositive_info;
 },
 sat_s7pB_entry() //  [R1]
         { info_tbl: [(c8ub,
                       label: sat_s7pB_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ub: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8uc; else goto c8ud;
       c8uc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ud: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call mkSubtractors_s7pw_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7pz_entry() //  [R1]
         { info_tbl: [(c8ui,
                       label: sat_s7pz_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ui: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8uj; else goto c8uk;
       c8uj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8uk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 mkSubtractors_s7pw_entry() //  [R1, R2]
         { info_tbl: [(c8uo,
                       label: mkSubtractors_s7pw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8uo: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8us; else goto c8ur;
       c8us: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ur: // global
           if (R2 == 0) goto c8un; else goto c8um;
       c8un: // global
           _s7pv::P64 = P64[R1 + 15];
           Hp = Hp - 88;
           R1 = _s7pv::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8um: // global
           _s7pt::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s7pB_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s7pz_info;
           P64[Hp - 32] = _s7pt::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 subtractors_s7pu_entry() //  [R1]
         { info_tbl: [(c8uu,
                       label: subtractors_s7pu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8uu: // global
           _s7pu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8uv; else goto c8uw;
       c8uw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8uy; else goto c8ux;
       c8uy: // global
           HpAlloc = 48;
           goto c8uv;
       c8uv: // global
           R1 = _s7pu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ux: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7pu::P64;
           _s7pt::P64 = P64[_s7pu::P64 + 16];
           I64[Hp - 40] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 32] = _s7pt::P64;
           P64[Hp - 24] = GHC.Integer.Type.Nil_closure+1;
           I64[Hp - 16] = mkSubtractors_s7pw_info;
           P64[Hp - 8] = _s7pt::P64;
           P64[Hp] = Hp - 38;
           R2 = 63;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call mkSubtractors_s7pw_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7pR_entry() //  [R1]
         { info_tbl: [(c8uZ,
                       label: sat_s7pR_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8uZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8v0; else goto c8v1;
       c8v0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8v1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7pX_entry() //  [R1]
         { info_tbl: [(c8vf,
                       label: sat_s7pX_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8vg; else goto c8vh;
       c8vg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7q1_entry() //  [R1]
         { info_tbl: [(c8vr,
                       label: sat_s7q1_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8vs; else goto c8vt;
       c8vs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 f2_s7pC_entry() //  [R1, R2]
         { info_tbl: [(c8vy,
                       label: f2_s7pC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8vz; else goto c8vA;
       c8vz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8vA: // global
           I64[Sp - 24] = block_c8uE_info;
           _s7pC::P64 = R1;
           _s7pu::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s7pu::P64;
           P64[Sp - 8] = _s7pC::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8w9; else goto c8uF;
       u8w9: // global
           call _c8uE(R1) args: 0, res: 0, upd: 0;
       c8uF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8uE() //  [R1]
         { info_tbl: [(c8uE,
                       label: block_c8uE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8uE: // global
           if (R1 & 7 == 1) goto c8vv; else goto c8vw;
       c8vv: // global
           I64[Sp] = block_c8uJ_info;
           R2 = P64[R1 + 7];
           _s7pF::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7pF::I64;
           call f2_s7pC_entry(R2, R1) args: 8, res: 8, upd: 8;
       c8vw: // global
           R2 = GHC.Integer.Type.None_closure+2;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8uJ() //  [R1, R2]
         { info_tbl: [(c8uJ,
                       label: block_c8uJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8uJ: // global
           I64[Sp - 8] = block_c8uL_info;
           _s7pI::P64 = R1;
           R1 = R2;
           P64[Sp] = _s7pI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8w5; else goto c8uM;
       u8w5: // global
           call _c8uL(R1) args: 0, res: 0, upd: 0;
       c8uM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8uL() //  [R1]
         { info_tbl: [(c8uL,
                       label: block_c8uL_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8uL: // global
           _s7pu::P64 = P64[Sp + 16];
           _s7pF::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c8vE; else goto c8vL;
       c8vE: // global
           Hp = Hp + 24;
           _s7pK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8vO; else goto c8vG;
       c8vG: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = _s7pK::P64;
           I64[Hp] = _s7pF::I64;
           I64[Sp] = block_c8uR_info;
           R4 = Hp - 15;
           R3 = _s7pu::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
       c8vL: // global
           Hp = Hp + 24;
           _s7pK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8vO; else goto c8vN;
       c8vO: // global
           HpAlloc = 24;
           R1 = _s7pK::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8vN: // global
           if (_s7pF::I64 == 0) goto c8vU; else goto c8vQ;
       c8vU: // global
           Hp = Hp - 24;
           I64[Sp] = block_c8vj_info;
           R4 = GHC.Integer.Type.None_closure+2;
           R3 = _s7pu::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
       c8vQ: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s7pF::I64;
           I64[Sp] = block_c8v7_info;
           R4 = Hp - 15;
           R3 = _s7pu::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8uR() //  [R1, R2]
         { info_tbl: [(c8uR,
                       label: block_c8uR_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8uR: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c8uS() args: 0, res: 0, upd: 0;
     }
 },
 _c8uS() //  []
         { info_tbl: [(c8uS,
                       label: block_c8uS_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8uS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8vK; else goto c8vJ;
       c8vK: // global
           HpAlloc = 32;
           I64[Sp] = block_c8uS_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vJ: // global
           I64[Hp - 24] = sat_s7pR_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8vj() //  [R1, R2]
         { info_tbl: [(c8vj,
                       label: block_c8vj_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vj: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c8vk() args: 0, res: 0, upd: 0;
     }
 },
 _c8vk() //  []
         { info_tbl: [(c8vk,
                       label: block_c8vk_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8vX; else goto c8vW;
       c8vX: // global
           HpAlloc = 32;
           I64[Sp] = block_c8vk_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vW: // global
           I64[Hp - 24] = sat_s7q1_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8v7() //  [R1, R2]
         { info_tbl: [(c8v7,
                       label: block_c8v7_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8v7: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c8v8() args: 0, res: 0, upd: 0;
     }
 },
 _c8v8() //  []
         { info_tbl: [(c8v8,
                       label: block_c8v8_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8v8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8vT; else goto c8vS;
       c8vT: // global
           HpAlloc = 32;
           I64[Sp] = block_c8v8_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vS: // global
           I64[Hp - 24] = sat_s7pX_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7q6_entry() //  [R1]
         { info_tbl: [(c8wg,
                       label: sat_s7q6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8wh; else goto c8wi;
       c8wh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.digitsMaybeZeroToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7q5_entry() //  [R1]
         { info_tbl: [(c8wn,
                       label: sat_s7q5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8wo; else goto c8wp;
       c8wo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.digitsMaybeZeroToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.quotRemPositive_entry() //  [R2, R3]
         { info_tbl: [(c8wq,
                       label: GHC.Integer.Type.quotRemPositive_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8wr; else goto c8ws;
       c8wr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ws: // global
           I64[Sp - 16] = block_c8tO_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8wz; else goto c8tP;
       u8wz: // global
           call _c8tO(R1) args: 0, res: 0, upd: 0;
       c8tP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8tO() //  [R1]
         { info_tbl: [(c8tO,
                       label: block_c8tO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8tO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8wv; else goto c8wu;
       c8wv: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8wu: // global
           I64[Hp - 32] = subtractors_s7pu_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = f2_s7pC_info;
           P64[Hp] = Hp - 32;
           _s7pr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8wa_info;
           R2 = _s7pr::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call f2_s7pC_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wa() //  [R1, R2]
         { info_tbl: [(c8wa,
                       label: block_c8wa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wa: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8wy; else goto c8wx;
       c8wy: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8wx: // global
           I64[Hp - 40] = sat_s7q6_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7q5_info;
           P64[Hp] = R1;
           R2 = Hp - 40;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.858087476 UTC

[section ""data" . GHC.Integer.Type.quotRemInteger_closure" {
     GHC.Integer.Type.quotRemInteger_closure:
         const GHC.Integer.Type.quotRemInteger_info;
 },
 sat_s7qj_entry() //  [R1]
         { info_tbl: [(c8zi,
                       label: sat_s7qj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zj; else goto c8zk;
       c8zj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8zk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7qr_entry() //  [R1]
         { info_tbl: [(c8zy,
                       label: sat_s7qr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zz; else goto c8zA;
       c8zz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8zA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7qq_entry() //  [R1]
         { info_tbl: [(c8zF,
                       label: sat_s7qq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zG; else goto c8zH;
       c8zG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8zH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7qw_entry() //  [R1]
         { info_tbl: [(c8zQ,
                       label: sat_s7qw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zR; else goto c8zS;
       c8zR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8zS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.quotRemInteger_entry() //  [R2, R3]
         { info_tbl: [(c8zX,
                       label: GHC.Integer.Type.quotRemInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zY; else goto c8zZ;
       c8zY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8zZ: // global
           I64[Sp - 16] = block_c8yR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8AP; else goto c8yS;
       u8AP: // global
           call _c8yR(R1) args: 0, res: 0, upd: 0;
       c8yS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8yR() //  [R1]
         { info_tbl: [(c8yR,
                       label: block_c8yR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yR: // global
           _s7q8::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c8zV; else goto c8zU;
       c8zV: // global
           I64[Sp + 8] = block_c8Az_info;
           R1 = _s7q8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8AL; else goto c8AB;
       u8AL: // global
           call _c8Az() args: 0, res: 0, upd: 0;
       c8AB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8zU: // global
           I64[Sp] = block_c8yW_info;
           _s7q9::P64 = R1;
           R1 = _s7q8::P64;
           P64[Sp + 8] = _s7q9::P64;
           if (R1 & 7 != 0) goto u8AK; else goto c8yX;
       u8AK: // global
           call _c8yW(R1) args: 0, res: 0, upd: 0;
       c8yX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Az() //  []
         { info_tbl: [(c8Az,
                       label: block_c8Az_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Az: // global
           R2 = GHC.Integer.Type.Naught_closure+3;
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8yW() //  [R1]
         { info_tbl: [(c8yW,
                       label: block_c8yW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yW: // global
           if (R1 & 7 == 3) goto c8Aw; else goto c8A3;
       c8Aw: // global
           R2 = GHC.Integer.Type.errorInteger_closure+1;
           R1 = GHC.Integer.Type.errorInteger_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c8A3: // global
           I64[Sp] = block_c8z1_info;
           _s7qa::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7qa::P64;
           if (R1 & 7 != 0) goto u8AM; else goto c8z2;
       u8AM: // global
           call _c8z1(R1) args: 0, res: 0, upd: 0;
       c8z2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8z1() //  [R1]
         { info_tbl: [(c8z1,
                       label: block_c8z1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z1: // global
           _s7qa::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c8A6; else goto c8Ah;
       c8A6: // global
           I64[Sp] = block_c8z6_info;
           _s7qc::P64 = P64[R1 + 7];
           R1 = _s7qa::P64;
           P64[Sp + 8] = _s7qc::P64;
           if (R1 & 7 != 0) goto u8AN; else goto c8z7;
       u8AN: // global
           call _c8z6(R1) args: 0, res: 0, upd: 0;
       c8z7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Ah: // global
           I64[Sp] = block_c8zn_info;
           _s7qk::P64 = P64[R1 + 6];
           R1 = _s7qa::P64;
           P64[Sp + 8] = _s7qk::P64;
           if (R1 & 7 != 0) goto u8AO; else goto c8zo;
       u8AO: // global
           call _c8zn(R1) args: 0, res: 0, upd: 0;
       c8zo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8z6() //  [R1]
         { info_tbl: [(c8z6,
                       label: block_c8z6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z6: // global
           _s7qc::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c8Aa; else goto c8Ac;
       c8Aa: // global
           R3 = P64[R1 + 7];
           R2 = _s7qc::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8Ac: // global
           I64[Sp + 8] = block_c8zc_info;
           R3 = P64[R1 + 6];
           R2 = _s7qc::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8zc() //  [R1, R2]
         { info_tbl: [(c8zc,
                       label: block_c8zc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Af; else goto c8Ae;
       c8Af: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8Ae: // global
           I64[Hp - 16] = sat_s7qj_info;
           P64[Hp] = R1;
           R2 = R2;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8zn() //  [R1]
         { info_tbl: [(c8zn,
                       label: block_c8zn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zn: // global
           _s7qk::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c8Ak; else goto c8Ap;
       c8Ak: // global
           I64[Sp + 8] = block_c8zs_info;
           R3 = P64[R1 + 7];
           R2 = _s7qk::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       c8Ap: // global
           I64[Sp + 8] = block_c8zK_info;
           R3 = P64[R1 + 6];
           R2 = _s7qk::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8zs() //  [R1, R2]
         { info_tbl: [(c8zs,
                       label: block_c8zs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8An; else goto c8Am;
       c8An: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8Am: // global
           I64[Hp - 40] = sat_s7qr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7qq_info;
           P64[Hp] = R1;
           R2 = Hp - 40;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8zK() //  [R1, R2]
         { info_tbl: [(c8zK,
                       label: block_c8zK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8As; else goto c8Ar;
       c8As: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8Ar: // global
           I64[Hp - 16] = sat_s7qw_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.902886612 UTC

[section ""data" . GHC.Integer.Type.divModInteger_closure" {
     GHC.Integer.Type.divModInteger_closure:
         const GHC.Integer.Type.divModInteger_info;
         const 0;
 },
 sat_s7qI_entry() //  [R1]
         { info_tbl: [(c8CF,
                       label: sat_s7qI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CG; else goto c8CH;
       c8CG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7qH_entry() //  [R1]
         { info_tbl: [(c8CM,
                       label: sat_s7qH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CN; else goto c8CO;
       c8CN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Integer.Type.oneInteger_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Integer.Type.divModInteger_entry() //  [R2, R3]
         { info_tbl: [(c8CP,
                       label: GHC.Integer.Type.divModInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8CQ; else goto c8CR;
       c8CQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.divModInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CR: // global
           I64[Sp - 16] = block_c8Ci_info;
           _s7qz::P64 = R3;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = _s7qz::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ci() //  [R1, R2]
         { info_tbl: [(c8Ci,
                       label: block_c8Ci_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ci: // global
           I64[Sp - 16] = block_c8Ck_info;
           _s7qC::P64 = R2;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = _s7qC::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ck() //  [R1]
         { info_tbl: [(c8Ck,
                       label: block_c8Ck_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ck: // global
           I64[Sp] = block_c8Co_info;
           R2 = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Co() //  [R1]
         { info_tbl: [(c8Co,
                       label: block_c8Co_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Co: // global
           I64[Sp - 8] = block_c8Cs_info;
           R2 = P64[Sp + 8];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Cs() //  [R1]
         { info_tbl: [(c8Cs,
                       label: block_c8Cs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cs: // global
           _s7qF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Cw_info;
           R3 = _s7qF::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Cw() //  [R1]
         { info_tbl: [(c8Cw,
                       label: block_c8Cw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cw: // global
           _s7qB::P64 = P64[Sp + 16];
           _s7qC::P64 = P64[Sp + 8];
           if (R1 == 1) goto c8D0; else goto c8CZ;
       c8D0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8D3; else goto c8D2;
       c8D3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8D2: // global
           I64[Hp - 48] = sat_s7qI_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s7qC::P64;
           I64[Hp - 16] = sat_s7qH_info;
           P64[Hp] = _s7qB::P64;
           R2 = Hp - 48;
           R1 = Hp - 16;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c8CZ: // global
           R2 = _s7qC::P64;
           R1 = _s7qB::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.932326548 UTC

[section ""data" . GHC.Integer.Type.divInteger_closure" {
     GHC.Integer.Type.divInteger_closure:
         const GHC.Integer.Type.divInteger_info;
         const 0;
 },
 GHC.Integer.Type.divInteger_entry() //  [R2, R3]
         { info_tbl: [(c8DO,
                       label: GHC.Integer.Type.divInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8DP; else goto c8DQ;
       c8DP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.divInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8DQ: // global
           I64[Sp - 8] = block_c8DM_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8DM() //  [R1]
         { info_tbl: [(c8DM,
                       label: block_c8DM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DM: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.942101743 UTC

[section ""data" . GHC.Integer.Type.modInteger_closure" {
     GHC.Integer.Type.modInteger_closure:
         const GHC.Integer.Type.modInteger_info;
         const 0;
 },
 GHC.Integer.Type.modInteger_entry() //  [R2, R3]
         { info_tbl: [(c8E9,
                       label: GHC.Integer.Type.modInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Ea; else goto c8Eb;
       c8Ea: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.modInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Eb: // global
           I64[Sp - 8] = block_c8E7_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8E7() //  [R2]
         { info_tbl: [(c8E7,
                       label: block_c8E7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E7: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.952307344 UTC

[section ""data" . GHC.Integer.Type.quotInteger_closure" {
     GHC.Integer.Type.quotInteger_closure:
         const GHC.Integer.Type.quotInteger_info;
 },
 GHC.Integer.Type.quotInteger_entry() //  [R2, R3]
         { info_tbl: [(c8Eu,
                       label: GHC.Integer.Type.quotInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Eu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Ev; else goto c8Ew;
       c8Ev: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ew: // global
           I64[Sp - 8] = block_c8Es_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Es() //  [R1]
         { info_tbl: [(c8Es,
                       label: block_c8Es_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Es: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.963202533 UTC

[section ""data" . GHC.Integer.Type.remInteger_closure" {
     GHC.Integer.Type.remInteger_closure:
         const GHC.Integer.Type.remInteger_info;
 },
 GHC.Integer.Type.remInteger_entry() //  [R2, R3]
         { info_tbl: [(c8EP,
                       label: GHC.Integer.Type.remInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8EP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8EQ; else goto c8ER;
       c8EQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.remInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ER: // global
           I64[Sp - 8] = block_c8EN_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8EN() //  [R2]
         { info_tbl: [(c8EN,
                       label: block_c8EN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8EN: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.97373373 UTC

[section ""data" . GHC.Integer.Type.andDigits_closure" {
     GHC.Integer.Type.andDigits_closure:
         const GHC.Integer.Type.andDigits_info;
 },
 GHC.Integer.Type.andDigits_entry() //  [R2, R3]
         { info_tbl: [(c8Ff,
                       label: GHC.Integer.Type.andDigits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ff: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Fg; else goto c8Fh;
       c8Fg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Fh: // global
           I64[Sp - 16] = block_c8F8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8FU; else goto c8F9;
       u8FU: // global
           call _c8F8(R1) args: 0, res: 0, upd: 0;
       c8F9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8F8() //  [R1]
         { info_tbl: [(c8F8,
                       label: block_c8F8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8F8: // global
           _s7r4::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8Fc; else goto c8Fd;
       c8Fc: // global
           I64[Sp - 8] = block_c8Fk_info;
           _s7r7::P64 = P64[R1 + 7];
           _s7r6::I64 = I64[R1 + 15];
           R1 = _s7r4::P64;
           P64[Sp] = _s7r7::P64;
           I64[Sp + 8] = _s7r6::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8FS; else goto c8Fm;
       u8FS: // global
           call _c8Fk(R1) args: 0, res: 0, upd: 0;
       c8Fm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Fd: // global
           I64[Sp + 8] = block_c8FK_info;
           R1 = _s7r4::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8FT; else goto c8FM;
       u8FT: // global
           call _c8FK() args: 0, res: 0, upd: 0;
       c8FM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Fk() //  [R1]
         { info_tbl: [(c8Fk,
                       label: block_c8Fk_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Fk: // global
           if (R1 & 7 == 1) goto c8FA; else goto c8FH;
       c8FA: // global
           I64[Sp] = block_c8Fq_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c8FH: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Fq() //  [R1]
         { info_tbl: [(c8Fq,
                       label: block_c8Fq_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Fq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8FD; else goto c8FC;
       c8FD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8FC: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] & I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8FK() //  []
         { info_tbl: [(c8FK,
                       label: block_c8FK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8FK: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:55.988301269 UTC

[section ""data" . GHC.Integer.Type.andDigitsOnes_closure" {
     GHC.Integer.Type.andDigitsOnes_closure:
         const GHC.Integer.Type.andDigitsOnes_info;
 },
 GHC.Integer.Type.andDigitsOnes_entry() //  [R2, R3]
         { info_tbl: [(c8GF,
                       label: GHC.Integer.Type.andDigitsOnes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8GG; else goto c8GH;
       c8GG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andDigitsOnes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8GH: // global
           I64[Sp - 16] = block_c8Gy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Hd; else goto c8Gz;
       u8Hd: // global
           call _c8Gy(R1) args: 0, res: 0, upd: 0;
       c8Gz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Gy() //  [R1]
         { info_tbl: [(c8Gy,
                       label: block_c8Gy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gy: // global
           _s7rf::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8GC; else goto c8GD;
       c8GC: // global
           I64[Sp - 8] = block_c8GK_info;
           _s7ri::P64 = P64[R1 + 7];
           _s7rh::I64 = I64[R1 + 15];
           R1 = _s7rf::P64;
           P64[Sp] = _s7ri::P64;
           I64[Sp + 8] = _s7rh::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Hc; else goto c8GM;
       u8Hc: // global
           call _c8GK(R1) args: 0, res: 0, upd: 0;
       c8GM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8GD: // global
           R1 = _s7rf::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GK() //  [R1]
         { info_tbl: [(c8GK,
                       label: block_c8GK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GK: // global
           if (R1 & 7 == 1) goto c8H0; else goto c8H7;
       c8H0: // global
           I64[Sp] = block_c8GQ_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c8H7: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GQ() //  [R1]
         { info_tbl: [(c8GQ,
                       label: block_c8GQ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8H3; else goto c8H2;
       c8H3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8H2: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] & I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.000634914 UTC

[section ""data" . GHC.Integer.Type.orDigits_closure" {
     GHC.Integer.Type.orDigits_closure:
         const GHC.Integer.Type.orDigits_info;
 },
 GHC.Integer.Type.orDigits_entry() //  [R2, R3]
         { info_tbl: [(c8HU,
                       label: GHC.Integer.Type.orDigits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8HV; else goto c8HW;
       c8HV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.orDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HW: // global
           I64[Sp - 16] = block_c8HN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Is; else goto c8HO;
       u8Is: // global
           call _c8HN(R1) args: 0, res: 0, upd: 0;
       c8HO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HN() //  [R1]
         { info_tbl: [(c8HN,
                       label: block_c8HN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HN: // global
           _s7rp::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8HR; else goto c8HS;
       c8HR: // global
           I64[Sp - 16] = block_c8HZ_info;
           _s7rq::P64 = R1;
           _s7rs::P64 = P64[R1 + 7];
           _s7rr::I64 = I64[R1 + 15];
           R1 = _s7rp::P64;
           P64[Sp - 8] = _s7rs::P64;
           I64[Sp] = _s7rr::I64;
           P64[Sp + 8] = _s7rq::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Ir; else goto c8I1;
       u8Ir: // global
           call _c8HZ(R1) args: 0, res: 0, upd: 0;
       c8I1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8HS: // global
           R1 = _s7rp::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HZ() //  [R1]
         { info_tbl: [(c8HZ,
                       label: block_c8HZ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HZ: // global
           if (R1 & 7 == 1) goto c8If; else goto c8Im;
       c8If: // global
           _s7rs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8I5_info;
           R3 = P64[R1 + 7];
           R2 = _s7rs::P64;
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
       c8Im: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8I5() //  [R1]
         { info_tbl: [(c8I5,
                       label: block_c8I5_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Ii; else goto c8Ih;
       c8Ii: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ih: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] | I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.014646569 UTC

[section ""data" . GHC.Integer.Type.orInteger_closure" {
     GHC.Integer.Type.orInteger_closure:
         const GHC.Integer.Type.orInteger_info;
 },
 GHC.Integer.Type.orInteger_entry() //  [R2, R3]
         { info_tbl: [(c8Ja,
                       label: GHC.Integer.Type.orInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ja: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Jb; else goto u8Lv;
       c8Jb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.orInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u8Lv: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c8J0() args: 0, res: 0, upd: 0;
     }
 },
 _c8J0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J0: // global
           _s7ry::P64 = P64[Sp];
           I64[Sp] = block_c8J3_info;
           R1 = _s7ry::P64;
           if (R1 & 7 != 0) goto u8LB; else goto c8J4;
       u8LB: // global
           call _c8J3(R1) args: 0, res: 0, upd: 0;
       c8J4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8J3() //  [R1]
         { info_tbl: [(c8J3,
                       label: block_c8J3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J3: // global
           _s7rz::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c8J8; else goto c8J7;
       c8J8: // global
           R1 = _s7rz::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8J7: // global
           I64[Sp] = block_c8Jf_info;
           _s7rA::P64 = R1;
           R1 = _s7rz::P64;
           P64[Sp + 8] = _s7rA::P64;
           if (R1 & 7 != 0) goto u8LC; else goto c8Jh;
       u8LC: // global
           call _c8Jf(R1) args: 0, res: 0, upd: 0;
       c8Jh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Jf() //  [R1]
         { info_tbl: [(c8Jf,
                       label: block_c8Jf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jf: // global
           _s7rA::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c8Ll; else goto c8Jo;
       c8Ll: // global
           R1 = _s7rA::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8Jo: // global
           I64[Sp] = block_c8Jl_info;
           _s7rB::P64 = R1;
           R1 = _s7rA::P64;
           P64[Sp + 8] = _s7rB::P64;
           if (R1 & 7 != 0) goto u8LE; else goto c8Jp;
       u8LE: // global
           call _c8Jl(R1) args: 0, res: 0, upd: 0;
       c8Jp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Jl() //  [R1]
         { info_tbl: [(c8Jl,
                       label: block_c8Jl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jl: // global
           _s7rB::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c8Jw; else goto c8Kv;
       c8Jw: // global
           I64[Sp] = block_c8Jt_info;
           _s7rD::P64 = P64[R1 + 7];
           R1 = _s7rB::P64;
           P64[Sp + 8] = _s7rD::P64;
           if (R1 & 7 != 0) goto u8LF; else goto c8Jx;
       u8LF: // global
           call _c8Jt(R1) args: 0, res: 0, upd: 0;
       c8Jx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Kv: // global
           I64[Sp - 8] = block_c8Kt_info;
           _s7rC::P64 = R1;
           _s7rS::P64 = P64[R1 + 6];
           R1 = _s7rB::P64;
           P64[Sp] = _s7rS::P64;
           P64[Sp + 8] = _s7rC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8LG; else goto c8Kw;
       u8LG: // global
           call _c8Kt(R1) args: 0, res: 0, upd: 0;
       c8Kw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Jt() //  [R1]
         { info_tbl: [(c8Jt,
                       label: block_c8Jt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jt: // global
           if (R1 & 7 < 2) goto c8JI; else goto c8JY;
       c8JI: // global
           _s7rD::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8JB_info;
           R3 = P64[R1 + 7];
           R2 = _s7rD::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
       c8JY: // global
           I64[Sp] = block_c8JO_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8JB() //  [R1]
         { info_tbl: [(c8JB,
                       label: block_c8JB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8JL; else goto c8JK;
       c8JL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8JK: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8JO() //  [R1]
         { info_tbl: [(c8JO,
                       label: block_c8JO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JO: // global
           I64[Sp] = block_c8JS_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8JS() //  [R1]
         { info_tbl: [(c8JS,
                       label: block_c8JS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JS: // global
           _s7rJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8JW_info;
           R3 = _s7rJ::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8JW() //  [R1]
         { info_tbl: [(c8JW,
                       label: block_c8JW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JW: // global
           I64[Sp] = block_c8K4_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8K4() //  [R1, R2]
         { info_tbl: [(c8K4,
                       label: block_c8K4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8K4: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c8K5() args: 0, res: 0, upd: 0;
     }
 },
 _c8K5() //  []
         { info_tbl: [(c8K5,
                       label: block_c8K5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8K5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Kd; else goto c8Kc;
       c8Kd: // global
           HpAlloc = 24;
           I64[Sp] = block_c8K5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Kc: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c8K9_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8K9() //  [R1]
         { info_tbl: [(c8K9,
                       label: block_c8K9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8K9: // global
           if (R1 & 7 == 1) goto c8Kj; else goto u8Lx;
       c8Kj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Km; else goto c8Kl;
       c8Km: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Kl: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8Lx: // global
           Sp = Sp + 8;
           call _c8Lh() args: 0, res: 0, upd: 0;
     }
 },
 _c8Kt() //  [R1]
         { info_tbl: [(c8Kt,
                       label: block_c8Kt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Kt: // global
           if (R1 & 7 < 2) goto c8KC; else goto c8KP;
       c8KC: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c8J0() args: 0, res: 0, upd: 0;
       c8KP: // global
           I64[Sp] = block_c8KF_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8KF() //  [R1]
         { info_tbl: [(c8KF,
                       label: block_c8KF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KF: // global
           _s7rS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8KJ_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s7rS::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8KJ() //  [R1]
         { info_tbl: [(c8KJ,
                       label: block_c8KJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KJ: // global
           _s7rX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8KN_info;
           R3 = _s7rX::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8KN() //  [R1]
         { info_tbl: [(c8KN,
                       label: block_c8KN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KN: // global
           I64[Sp] = block_c8KV_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8KV() //  [R1, R2]
         { info_tbl: [(c8KV,
                       label: block_c8KV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KV: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c8KW() args: 0, res: 0, upd: 0;
     }
 },
 _c8KW() //  []
         { info_tbl: [(c8KW,
                       label: block_c8KW_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8L4; else goto c8L3;
       c8L4: // global
           HpAlloc = 24;
           I64[Sp] = block_c8KW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8L3: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c8L0_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8L0() //  [R1]
         { info_tbl: [(c8L0,
                       label: block_c8L0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L0: // global
           if (R1 & 7 == 1) goto c8La; else goto u8LA;
       c8La: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Ld; else goto c8Lc;
       c8Ld: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Lc: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8LA: // global
           Sp = Sp + 8;
           call _c8Lh() args: 0, res: 0, upd: 0;
     }
 },
 _c8Lh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lh: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.064974528 UTC

[section ""data" . GHC.Integer.Type.mkInteger_f_closure" {
     GHC.Integer.Type.mkInteger_f_closure:
         const GHC.Integer.Type.mkInteger_f_info;
 },
 GHC.Integer.Type.mkInteger_f_entry() //  [R2]
         { info_tbl: [(c8NR,
                       label: GHC.Integer.Type.mkInteger_f_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NS; else goto c8NT;
       c8NS: // global
           R2 = R2;
           R1 = GHC.Integer.Type.mkInteger_f_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NT: // global
           I64[Sp - 8] = block_c8NK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Om; else goto c8NL;
       u8Om: // global
           call _c8NK(R1) args: 0, res: 0, upd: 0;
       c8NL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NK() //  [R1]
         { info_tbl: [(c8NK,
                       label: block_c8NK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NK: // global
           if (R1 & 7 == 1) goto c8NO; else goto c8NP;
       c8NO: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8NP: // global
           I64[Sp - 8] = block_c8NZ_info;
           _s7s9::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s7s9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Ol; else goto c8O0;
       u8Ol: // global
           call _c8NZ(R1) args: 0, res: 0, upd: 0;
       c8O0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NZ() //  [R1]
         { info_tbl: [(c8NZ,
                       label: block_c8NZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NZ: // global
           I64[Sp] = block_c8O4_info;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8O4() //  [R1]
         { info_tbl: [(c8O4,
                       label: block_c8O4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8O4: // global
           I64[Sp] = block_c8O8_info;
           R3 = 31;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8O8() //  [R1]
         { info_tbl: [(c8O8,
                       label: block_c8O8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8O8: // global
           I64[Sp] = block_c8Oc_info;
           R2 = I64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Oc() //  [R1]
         { info_tbl: [(c8Oc,
                       label: block_c8Oc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oc: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.080856828 UTC

[section ""data" . GHC.Integer.Type.mkInteger_closure" {
     GHC.Integer.Type.mkInteger_closure:
         const GHC.Integer.Type.mkInteger_info;
 },
 GHC.Integer.Type.mkInteger_entry() //  [R2, R3]
         { info_tbl: [(c8P3,
                       label: GHC.Integer.Type.mkInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8P3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8P4; else goto c8P5;
       c8P4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.mkInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8P5: // global
           I64[Sp - 16] = block_c8OW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Ph; else goto c8OX;
       u8Ph: // global
           call _c8OW(R1) args: 0, res: 0, upd: 0;
       c8OX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OW() //  [R1]
         { info_tbl: [(c8OW,
                       label: block_c8OW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OW: // global
           _s7sg::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8P0; else goto c8P1;
       c8P0: // global
           I64[Sp + 8] = block_c8P8_info;
           R2 = _s7sg::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 8, upd: 8;
       c8P1: // global
           R2 = _s7sg::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8P8() //  [R1]
         { info_tbl: [(c8P8,
                       label: block_c8P8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8P8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.091766428 UTC

[section ""data" . GHC.Integer.Type.andInteger_closure" {
     GHC.Integer.Type.andInteger_closure:
         const GHC.Integer.Type.andInteger_info;
 },
 GHC.Integer.Type.andInteger_entry() //  [R2, R3]
         { info_tbl: [(c8PJ,
                       label: GHC.Integer.Type.andInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8PK; else goto u8Se;
       c8PK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u8Se: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c8Pz() args: 0, res: 0, upd: 0;
     }
 },
 _c8Pz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Pz: // global
           _s7sj::P64 = P64[Sp];
           I64[Sp] = block_c8PC_info;
           R1 = _s7sj::P64;
           if (R1 & 7 != 0) goto u8Sl; else goto c8PD;
       u8Sl: // global
           call _c8PC(R1) args: 0, res: 0, upd: 0;
       c8PD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8PC() //  [R1]
         { info_tbl: [(c8PC,
                       label: block_c8PC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PC: // global
           _s7sk::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c8PH; else goto c8PG;
       c8PH: // global
           I64[Sp + 8] = block_c8S0_info;
           R1 = _s7sk::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8Sn; else goto c8S2;
       u8Sn: // global
           call _c8S0() args: 0, res: 0, upd: 0;
       c8S2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8PG: // global
           I64[Sp] = block_c8PO_info;
           _s7sl::P64 = R1;
           R1 = _s7sk::P64;
           P64[Sp + 8] = _s7sl::P64;
           if (R1 & 7 != 0) goto u8Sm; else goto c8PQ;
       u8Sm: // global
           call _c8PO(R1) args: 0, res: 0, upd: 0;
       c8PQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8S0() //  []
         { info_tbl: [(c8S0,
                       label: block_c8S0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8S0: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8PO() //  [R1]
         { info_tbl: [(c8PO,
                       label: block_c8PO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PO: // global
           if (R1 & 7 == 3) goto u8Sf; else goto c8PX;
       u8Sf: // global
           Sp = Sp + 16;
           call _c8RX() args: 0, res: 0, upd: 0;
       c8PX: // global
           I64[Sp] = block_c8PU_info;
           _s7sm::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7sm::P64;
           if (R1 & 7 != 0) goto u8Sp; else goto c8PY;
       u8Sp: // global
           call _c8PU(R1) args: 0, res: 0, upd: 0;
       c8PY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8PU() //  [R1]
         { info_tbl: [(c8PU,
                       label: block_c8PU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PU: // global
           _s7sm::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c8Q5; else goto c8R7;
       c8Q5: // global
           I64[Sp] = block_c8Q2_info;
           _s7so::P64 = P64[R1 + 7];
           R1 = _s7sm::P64;
           P64[Sp + 8] = _s7so::P64;
           if (R1 & 7 != 0) goto u8Sr; else goto c8Q6;
       u8Sr: // global
           call _c8Q2(R1) args: 0, res: 0, upd: 0;
       c8Q6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8R7: // global
           I64[Sp - 8] = block_c8R5_info;
           _s7sn::P64 = R1;
           _s7sC::P64 = P64[R1 + 6];
           R1 = _s7sm::P64;
           P64[Sp] = _s7sC::P64;
           P64[Sp + 8] = _s7sn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Ss; else goto c8R8;
       u8Ss: // global
           call _c8R5(R1) args: 0, res: 0, upd: 0;
       c8R8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q2() //  [R1]
         { info_tbl: [(c8Q2,
                       label: block_c8Q2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q2: // global
           if (R1 & 7 < 2) goto c8Qd; else goto c8QI;
       c8Qd: // global
           _s7so::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Qa_info;
           R3 = P64[R1 + 7];
           R2 = _s7so::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c8QI: // global
           I64[Sp] = block_c8Qy_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qa() //  [R1]
         { info_tbl: [(c8Qa,
                       label: block_c8Qa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qa: // global
           I64[Sp] = block_c8Qh_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qh() //  [R1]
         { info_tbl: [(c8Qh,
                       label: block_c8Qh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qh: // global
           if (R1 & 7 == 1) goto c8Qo; else goto u8Sg;
       c8Qo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Qr; else goto c8Qq;
       c8Qr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Qq: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8Sg: // global
           Sp = Sp + 8;
           call _c8RX() args: 0, res: 0, upd: 0;
     }
 },
 _c8Qy() //  [R1]
         { info_tbl: [(c8Qy,
                       label: block_c8Qy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qy: // global
           I64[Sp] = block_c8QC_info;
           R2 = R1;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QC() //  [R1]
         { info_tbl: [(c8QC,
                       label: block_c8QC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QC: // global
           _s7so::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8QG_info;
           R3 = _s7so::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QG() //  [R1]
         { info_tbl: [(c8QG,
                       label: block_c8QG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QG: // global
           I64[Sp] = block_c8QO_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QO() //  [R1]
         { info_tbl: [(c8QO,
                       label: block_c8QO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QO: // global
           if (R1 & 7 == 1) goto c8QV; else goto u8Sh;
       c8QV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QY; else goto c8QX;
       c8QY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QX: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8Sh: // global
           Sp = Sp + 8;
           call _c8RX() args: 0, res: 0, upd: 0;
     }
 },
 _c8R5() //  [R1]
         { info_tbl: [(c8R5,
                       label: block_c8R5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R5: // global
           if (R1 & 7 < 2) goto c8Re; else goto c8Rr;
       c8Re: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c8Pz() args: 0, res: 0, upd: 0;
       c8Rr: // global
           I64[Sp] = block_c8Rh_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rh() //  [R1]
         { info_tbl: [(c8Rh,
                       label: block_c8Rh_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rh: // global
           _s7sC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Rl_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s7sC::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rl() //  [R1]
         { info_tbl: [(c8Rl,
                       label: block_c8Rl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rl: // global
           _s7sH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Rp_info;
           R3 = _s7sH::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rp() //  [R1]
         { info_tbl: [(c8Rp,
                       label: block_c8Rp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rp: // global
           I64[Sp] = block_c8Rx_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rx() //  [R1, R2]
         { info_tbl: [(c8Rx,
                       label: block_c8Rx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rx: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c8Ry() args: 0, res: 0, upd: 0;
     }
 },
 _c8Ry() //  []
         { info_tbl: [(c8Ry,
                       label: block_c8Ry_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ry: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8RG; else goto c8RF;
       c8RG: // global
           HpAlloc = 24;
           I64[Sp] = block_c8Ry_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8RF: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c8RC_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8RC() //  [R1]
         { info_tbl: [(c8RC,
                       label: block_c8RC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RC: // global
           if (R1 & 7 == 1) goto c8RM; else goto u8Sk;
       c8RM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RP; else goto c8RO;
       c8RP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8RO: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8Sk: // global
           Sp = Sp + 8;
           call _c8RX() args: 0, res: 0, upd: 0;
     }
 },
 _c8RX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RX: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.138019913 UTC

[section ""data" . GHC.Integer.Type.testBitInteger_closure" {
     GHC.Integer.Type.testBitInteger_closure:
         const GHC.Integer.Type.testBitInteger_info;
 },
 GHC.Integer.Type.testBitInteger_entry() //  [R2, R3]
         { info_tbl: [(c8Uv,
                       label: GHC.Integer.Type.testBitInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8UD; else goto c8UE;
       c8UD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.testBitInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8UE: // global
           I64[Sp - 16] = block_c8Ut_info;
           R3 = R3;
           _s7sR::P64 = R2;
           R2 = GHC.Integer.Type.oneInteger_closure+1;
           P64[Sp - 8] = _s7sR::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ut() //  [R1]
         { info_tbl: [(c8Ut,
                       label: block_c8Ut_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ut: // global
           _s7sR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Uy_info;
           R3 = R1;
           R2 = _s7sR::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uy() //  [R1]
         { info_tbl: [(c8Uy,
                       label: block_c8Uy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uy: // global
           I64[Sp] = block_c8UC_info;
           R3 = GHC.Integer.Type.Naught_closure+3;
           R2 = R1;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8UC() //  [R1]
         { info_tbl: [(c8UC,
                       label: block_c8UC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UC: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.150358974 UTC

[section ""data" . GHC.Integer.Type.xorDigits_closure" {
     GHC.Integer.Type.xorDigits_closure:
         const GHC.Integer.Type.xorDigits_info;
 },
 GHC.Integer.Type.xorDigits_entry() //  [R2, R3]
         { info_tbl: [(c8Vg,
                       label: GHC.Integer.Type.xorDigits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Vh; else goto c8Vi;
       c8Vh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.xorDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Vi: // global
           I64[Sp - 16] = block_c8V9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8VO; else goto c8Va;
       u8VO: // global
           call _c8V9(R1) args: 0, res: 0, upd: 0;
       c8Va: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V9() //  [R1]
         { info_tbl: [(c8V9,
                       label: block_c8V9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V9: // global
           _s7sX::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8Vd; else goto c8Ve;
       c8Vd: // global
           I64[Sp - 16] = block_c8Vl_info;
           _s7sY::P64 = R1;
           _s7t0::P64 = P64[R1 + 7];
           _s7sZ::I64 = I64[R1 + 15];
           R1 = _s7sX::P64;
           P64[Sp - 8] = _s7t0::P64;
           I64[Sp] = _s7sZ::I64;
           P64[Sp + 8] = _s7sY::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8VN; else goto c8Vn;
       u8VN: // global
           call _c8Vl(R1) args: 0, res: 0, upd: 0;
       c8Vn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Ve: // global
           R1 = _s7sX::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Vl() //  [R1]
         { info_tbl: [(c8Vl,
                       label: block_c8Vl_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vl: // global
           if (R1 & 7 == 1) goto c8VB; else goto c8VI;
       c8VB: // global
           _s7t0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Vr_info;
           R3 = P64[R1 + 7];
           R2 = _s7t0::P64;
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c8VI: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Vr() //  [R1]
         { info_tbl: [(c8Vr,
                       label: block_c8Vr_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8VE; else goto c8VD;
       c8VE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VD: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] ^ I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.164981999 UTC

[section ""data" . GHC.Integer.Type.xorInteger_closure" {
     GHC.Integer.Type.xorInteger_closure:
         const GHC.Integer.Type.xorInteger_info;
 },
 GHC.Integer.Type.xorInteger_entry() //  [R2, R3]
         { info_tbl: [(c8Ww,
                       label: GHC.Integer.Type.xorInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ww: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Wx; else goto u8YQ;
       c8Wx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.xorInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u8YQ: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c8Wm() args: 0, res: 0, upd: 0;
     }
 },
 _c8Wm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wm: // global
           _s7t6::P64 = P64[Sp];
           I64[Sp] = block_c8Wp_info;
           R1 = _s7t6::P64;
           if (R1 & 7 != 0) goto u8YW; else goto c8Wq;
       u8YW: // global
           call _c8Wp(R1) args: 0, res: 0, upd: 0;
       c8Wq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wp() //  [R1]
         { info_tbl: [(c8Wp,
                       label: block_c8Wp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wp: // global
           _s7t7::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c8Wu; else goto c8Wt;
       c8Wu: // global
           R1 = _s7t7::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8Wt: // global
           I64[Sp] = block_c8WB_info;
           _s7t8::P64 = R1;
           R1 = _s7t7::P64;
           P64[Sp + 8] = _s7t8::P64;
           if (R1 & 7 != 0) goto u8YX; else goto c8WD;
       u8YX: // global
           call _c8WB(R1) args: 0, res: 0, upd: 0;
       c8WD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WB() //  [R1]
         { info_tbl: [(c8WB,
                       label: block_c8WB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WB: // global
           _s7t8::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c8YF; else goto c8WK;
       c8YF: // global
           R1 = _s7t8::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8WK: // global
           I64[Sp] = block_c8WH_info;
           _s7t9::P64 = R1;
           R1 = _s7t8::P64;
           P64[Sp + 8] = _s7t9::P64;
           if (R1 & 7 != 0) goto u8YZ; else goto c8WL;
       u8YZ: // global
           call _c8WH(R1) args: 0, res: 0, upd: 0;
       c8WL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WH() //  [R1]
         { info_tbl: [(c8WH,
                       label: block_c8WH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WH: // global
           _s7t9::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c8WS; else goto c8XX;
       c8WS: // global
           I64[Sp] = block_c8WP_info;
           _s7tb::P64 = P64[R1 + 7];
           R1 = _s7t9::P64;
           P64[Sp + 8] = _s7tb::P64;
           if (R1 & 7 != 0) goto u8Z0; else goto c8WT;
       u8Z0: // global
           call _c8WP(R1) args: 0, res: 0, upd: 0;
       c8WT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8XX: // global
           I64[Sp - 8] = block_c8XV_info;
           _s7ta::P64 = R1;
           _s7ts::P64 = P64[R1 + 6];
           R1 = _s7t9::P64;
           P64[Sp] = _s7ts::P64;
           P64[Sp + 8] = _s7ta::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Z1; else goto c8XY;
       u8Z1: // global
           call _c8XV(R1) args: 0, res: 0, upd: 0;
       c8XY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WP() //  [R1]
         { info_tbl: [(c8WP,
                       label: block_c8WP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WP: // global
           if (R1 & 7 < 2) goto c8X0; else goto c8Xr;
       c8X0: // global
           _s7tb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8WX_info;
           R3 = P64[R1 + 7];
           R2 = _s7tb::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c8Xr: // global
           I64[Sp] = block_c8Xl_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8WX() //  [R1]
         { info_tbl: [(c8WX,
                       label: block_c8WX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WX: // global
           I64[Sp] = block_c8X4_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8X4() //  [R1]
         { info_tbl: [(c8X4,
                       label: block_c8X4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8X4: // global
           if (R1 & 7 == 1) goto c8Xb; else goto u8YR;
       c8Xb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Xe; else goto c8Xd;
       c8Xe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Xd: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8YR: // global
           Sp = Sp + 8;
           call _c8YB() args: 0, res: 0, upd: 0;
     }
 },
 _c8Xl() //  [R1]
         { info_tbl: [(c8Xl,
                       label: block_c8Xl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Xl: // global
           _s7tb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Xp_info;
           R3 = R1;
           R2 = _s7tb::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Xp() //  [R1]
         { info_tbl: [(c8Xp,
                       label: block_c8Xp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Xp: // global
           I64[Sp] = block_c8Xw_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Xw() //  [R1, R2]
         { info_tbl: [(c8Xw,
                       label: block_c8Xw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Xw: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c8Xx() args: 0, res: 0, upd: 0;
     }
 },
 _c8Xx() //  []
         { info_tbl: [(c8Xx,
                       label: block_c8Xx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Xx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8XF; else goto c8XE;
       c8XF: // global
           HpAlloc = 24;
           I64[Sp] = block_c8Xx_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8XE: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c8XB_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8XB() //  [R1]
         { info_tbl: [(c8XB,
                       label: block_c8XB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8XB: // global
           if (R1 & 7 == 1) goto c8XL; else goto u8YT;
       c8XL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8XO; else goto c8XN;
       c8XO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8XN: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8YT: // global
           Sp = Sp + 8;
           call _c8YB() args: 0, res: 0, upd: 0;
     }
 },
 _c8XV() //  [R1]
         { info_tbl: [(c8XV,
                       label: block_c8XV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8XV: // global
           if (R1 & 7 < 2) goto c8Y4; else goto c8Yh;
       c8Y4: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c8Wm() args: 0, res: 0, upd: 0;
       c8Yh: // global
           I64[Sp] = block_c8Y7_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Y7() //  [R1]
         { info_tbl: [(c8Y7,
                       label: block_c8Y7_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Y7: // global
           _s7ts::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Yb_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s7ts::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Yb() //  [R1]
         { info_tbl: [(c8Yb,
                       label: block_c8Yb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Yb: // global
           _s7tx::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Yf_info;
           R3 = _s7tx::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Yf() //  [R1]
         { info_tbl: [(c8Yf,
                       label: block_c8Yf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Yf: // global
           I64[Sp] = block_c8Yn_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Yn() //  [R1]
         { info_tbl: [(c8Yn,
                       label: block_c8Yn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Yn: // global
           if (R1 & 7 == 1) goto c8Yu; else goto u8YV;
       c8Yu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Yx; else goto c8Yw;
       c8Yx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Yw: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8YV: // global
           Sp = Sp + 8;
           call _c8YB() args: 0, res: 0, upd: 0;
     }
 },
 _c8YB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YB: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.215011283 UTC

[section ""cstring" . GHC.Integer.Type.$trModule4_bytes" {
     GHC.Integer.Type.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.217059039 UTC

[section ""data" . GHC.Integer.Type.$trModule3_closure" {
     GHC.Integer.Type.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.219150036 UTC

[section ""cstring" . GHC.Integer.Type.$trModule2_bytes" {
     GHC.Integer.Type.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.221166819 UTC

[section ""data" . GHC.Integer.Type.$trModule1_closure" {
     GHC.Integer.Type.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.22360244 UTC

[section ""data" . GHC.Integer.Type.$trModule_closure" {
     GHC.Integer.Type.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Type.$trModule3_closure+1;
         const GHC.Integer.Type.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.225795 UTC

[section ""data" . $krep_r3Bp_closure" {
     $krep_r3Bp_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.227738026 UTC

[section ""data" . $krep1_r3Bq_closure" {
     $krep1_r3Bq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.229831954 UTC

[section ""cstring" . GHC.Integer.Type.$tcDigits2_bytes" {
     GHC.Integer.Type.$tcDigits2_bytes:
         I8[] [68,105,103,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.232129784 UTC

[section ""data" . GHC.Integer.Type.$tcDigits1_closure" {
     GHC.Integer.Type.$tcDigits1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcDigits2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.234186198 UTC

[section ""data" . GHC.Integer.Type.$tcDigits_closure" {
     GHC.Integer.Type.$tcDigits_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcDigits1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16647862651490579480;
         const 7069031713090282797;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.236346429 UTC

[section ""data" . GHC.Integer.Type.$tc'None1_closure" {
     GHC.Integer.Type.$tc'None1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcDigits_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.238542483 UTC

[section ""cstring" . GHC.Integer.Type.$tc'None3_bytes" {
     GHC.Integer.Type.$tc'None3_bytes:
         I8[] [39,78,111,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.240571246 UTC

[section ""data" . GHC.Integer.Type.$tc'None2_closure" {
     GHC.Integer.Type.$tc'None2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'None3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.243777071 UTC

[section ""data" . GHC.Integer.Type.$tc'None_closure" {
     GHC.Integer.Type.$tc'None_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'None2_closure+1;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const 903679638320298226;
         const 12977397153301278560;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.245969614 UTC

[section ""data" . $krep2_r3Br_closure" {
     $krep2_r3Br_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.247941572 UTC

[section ""data" . GHC.Integer.Type.$tc'Some1_closure" {
     GHC.Integer.Type.$tc'Some1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r3Bq_closure+1;
         const $krep2_r3Br_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.249894017 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Some3_bytes" {
     GHC.Integer.Type.$tc'Some3_bytes:
         I8[] [39,83,111,109,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.252119598 UTC

[section ""data" . GHC.Integer.Type.$tc'Some2_closure" {
     GHC.Integer.Type.$tc'Some2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Some3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.25432841 UTC

[section ""data" . GHC.Integer.Type.$tc'Some_closure" {
     GHC.Integer.Type.$tc'Some_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Some2_closure+1;
         const GHC.Integer.Type.$tc'Some1_closure+4;
         const 6045911439621864566;
         const 9702873355935012388;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.256403683 UTC

[section ""cstring" . GHC.Integer.Type.$tcInteger2_bytes" {
     GHC.Integer.Type.$tcInteger2_bytes:
         I8[] [73,110,116,101,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.258323366 UTC

[section ""data" . GHC.Integer.Type.$tcInteger1_closure" {
     GHC.Integer.Type.$tcInteger1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcInteger2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.260280493 UTC

[section ""data" . GHC.Integer.Type.$tcInteger_closure" {
     GHC.Integer.Type.$tcInteger_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcInteger1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12260413788024328428;
         const 9583620696682509916;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.262837109 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught1_closure" {
     GHC.Integer.Type.$tc'Naught1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.26478579 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Naught3_bytes" {
     GHC.Integer.Type.$tc'Naught3_bytes:
         I8[] [39,78,97,117,103,104,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.26683651 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught2_closure" {
     GHC.Integer.Type.$tc'Naught2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Naught3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.268852525 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught_closure" {
     GHC.Integer.Type.$tc'Naught_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Naught2_closure+1;
         const GHC.Integer.Type.$tc'Naught1_closure+1;
         const 7287704174224038176;
         const 776397532388787230;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.271872262 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative1_closure" {
     GHC.Integer.Type.$tc'Negative1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const GHC.Integer.Type.$tc'Naught1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.273922662 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Positive2_bytes" {
     GHC.Integer.Type.$tc'Positive2_bytes:
         I8[] [39,80,111,115,105,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.27595843 UTC

[section ""data" . GHC.Integer.Type.$tc'Positive1_closure" {
     GHC.Integer.Type.$tc'Positive1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Positive2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.278055892 UTC

[section ""data" . GHC.Integer.Type.$tc'Positive_closure" {
     GHC.Integer.Type.$tc'Positive_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Positive1_closure+1;
         const GHC.Integer.Type.$tc'Negative1_closure+4;
         const 6887932004110746796;
         const 9391890139750561935;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.280202084 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Negative3_bytes" {
     GHC.Integer.Type.$tc'Negative3_bytes:
         I8[] [39,78,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.282687841 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative2_closure" {
     GHC.Integer.Type.$tc'Negative2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Negative3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.284792692 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative_closure" {
     GHC.Integer.Type.$tc'Negative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Negative2_closure+1;
         const GHC.Integer.Type.$tc'Negative1_closure+4;
         const 4010847856516363452;
         const 15624358648337932456;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.28690685 UTC

[section ""cstring" . GHC.Integer.Type.$tcList2_bytes" {
     GHC.Integer.Type.$tcList2_bytes:
         I8[] [76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.288810251 UTC

[section ""data" . GHC.Integer.Type.$tcList1_closure" {
     GHC.Integer.Type.$tcList1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcList2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.291298828 UTC

[section ""data" . GHC.Integer.Type.$tcList_closure" {
     GHC.Integer.Type.$tcList_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 732340346576824023;
         const 9653115931589988500;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.293603759 UTC

[section ""data" . $krep3_r3Bs_closure" {
     $krep3_r3Bs_closure:
         const :_con_info;
         const $krep_r3Bp_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.295548954 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil1_closure" {
     GHC.Integer.Type.$tc'Nil1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcList_closure+1;
         const $krep3_r3Bs_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.297589277 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Nil3_bytes" {
     GHC.Integer.Type.$tc'Nil3_bytes:
         I8[] [39,78,105,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.299566882 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil2_closure" {
     GHC.Integer.Type.$tc'Nil2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Nil3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.302195419 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil_closure" {
     GHC.Integer.Type.$tc'Nil_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Nil2_closure+1;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const 13538585131509945451;
         const 9366316088405446135;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.304280859 UTC

[section ""data" . $krep4_r3Bt_closure" {
     $krep4_r3Bt_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.306327493 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons1_closure" {
     GHC.Integer.Type.$tc'Cons1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r3Bp_closure+2;
         const $krep4_r3Bt_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.308366333 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Cons3_bytes" {
     GHC.Integer.Type.$tc'Cons3_bytes:
         I8[] [39,67,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.310816045 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons2_closure" {
     GHC.Integer.Type.$tc'Cons2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Cons3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.312897912 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons_closure" {
     GHC.Integer.Type.$tc'Cons_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Cons2_closure+1;
         const GHC.Integer.Type.$tc'Cons1_closure+4;
         const 3906777924842222150;
         const 5463288556346842885;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.315118935 UTC

[section ""cstring" . GHC.Integer.Type.$tcDigitsOnes2_bytes" {
     GHC.Integer.Type.$tcDigitsOnes2_bytes:
         I8[] [68,105,103,105,116,115,79,110,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.317065554 UTC

[section ""data" . GHC.Integer.Type.$tcDigitsOnes1_closure" {
     GHC.Integer.Type.$tcDigitsOnes1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcDigitsOnes2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.31958081 UTC

[section ""data" . GHC.Integer.Type.$tcDigitsOnes_closure" {
     GHC.Integer.Type.$tcDigitsOnes_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcDigitsOnes1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4554239703586147919;
         const 6957361150436389790;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.321944379 UTC

[section ""data" . $krep5_r3Bu_closure" {
     $krep5_r3Bu_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcDigitsOnes_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.323910223 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes1_closure" {
     GHC.Integer.Type.$tc'DigitsOnes1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const $krep5_r3Bu_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.325949246 UTC

[section ""cstring" . GHC.Integer.Type.$tc'DigitsOnes3_bytes" {
     GHC.Integer.Type.$tc'DigitsOnes3_bytes:
         I8[] [39,68,105,103,105,116,115,79,110,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.327929476 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes2_closure" {
     GHC.Integer.Type.$tc'DigitsOnes2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'DigitsOnes3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.330442399 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes_closure" {
     GHC.Integer.Type.$tc'DigitsOnes_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'DigitsOnes2_closure+1;
         const GHC.Integer.Type.$tc'DigitsOnes1_closure+4;
         const 15211110739657495015;
         const 1682512192113792266;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.332824594 UTC

[section ""data" . GHC.Integer.Type.encodeDouble#_closure" {
     GHC.Integer.Type.encodeDouble#_closure:
         const GHC.Integer.Type.encodeDouble#_info;
 },
 GHC.Integer.Type.encodeDouble#_entry() //  [R2, R3]
         { info_tbl: [(c91R,
                       label: GHC.Integer.Type.encodeDouble#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91R: // global
           _c91Q::I64 = R3;
           (_s7tH::F64) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeDouble(R2, _c91Q::I64);
           D1 = _s7tH::F64;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.337826321 UTC

[section ""data" . f_r3Bv_closure" {
     f_r3Bv_closure:
         const f_r3Bv_info;
 },
 f_r3Bv_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c921: // global
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           D1 = F64[Sp];
           R1 = R1;
           Sp = Sp + 24;
           call f_r3Bv_entry(R3, R2, D1, R1) args: 8, res: 0, upd: 8;
     }
 },
 f_r3Bv_entry() //  [R2, R3, D1]
         { info_tbl: [(c92c,
                       label: f_r3Bv_info
                       rep:HeapRep static {
                             Fun {arity: 3 fun_type: ArgGen [True, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c92c: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c92d; else goto u92s;
       c92d: // global
           R1 = f_r3Bv_closure;
           F64[Sp - 24] = D1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       u92s: // global
           F64[Sp - 24] = D1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _c922() args: 0, res: 0, upd: 0;
     }
 },
 _c922() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c922: // global
           I64[Sp - 8] = block_c925_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u92u; else goto c926;
       u92u: // global
           call _c925(R1) args: 0, res: 0, upd: 0;
       c926: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c925() //  [R1]
         { info_tbl: [(c925,
                       label: block_c925_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c925: // global
           _s7tI::F64 = F64[Sp + 8];
           if (R1 & 7 == 1) goto c929; else goto c92a;
       c929: // global
           _s7tK::I64 = I64[Sp + 24];
           _s7tN::P64 = P64[R1 + 7];
           (_s7tR::F64) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeDouble(I64[R1 + 15], _s7tK::I64);
           F64[Sp + 8] = %MO_F_Add_W64(_s7tI::F64, _s7tR::F64);
           P64[Sp + 16] = _s7tN::P64;
           I64[Sp + 24] = _s7tK::I64 + 64;
           Sp = Sp + 8;
           call _c922() args: 0, res: 0, upd: 0;
       c92a: // global
           D1 = _s7tI::F64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.348111192 UTC

[section ""data" . GHC.Integer.Type.encodeDoubleInteger_closure" {
     GHC.Integer.Type.encodeDoubleInteger_closure:
         const GHC.Integer.Type.encodeDoubleInteger_info;
 },
 GHC.Integer.Type.encodeDoubleInteger_entry() //  [R2, R3]
         { info_tbl: [(c933,
                       label: GHC.Integer.Type.encodeDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c933: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c934; else goto c935;
       c934: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.encodeDoubleInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c935: // global
           I64[Sp - 16] = block_c92V_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u93p; else goto c92W;
       u93p: // global
           call _c92V(R1) args: 0, res: 0, upd: 0;
       c92W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c92V() //  [R1]
         { info_tbl: [(c92V,
                       label: block_c92V_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c92V: // global
           _c932::P64 = R1 & 7;
           if (_c932::P64 < 3) goto u93o; else goto c931;
       u93o: // global
           _s7tV::I64 = I64[Sp + 8];
           if (_c932::P64 < 2) goto c92Z; else goto c930;
       c92Z: // global
           R3 = _s7tV::I64;
           R2 = P64[R1 + 7];
           D1 = 0.0 :: W64;
           Sp = Sp + 16;
           call f_r3Bv_entry(R3, R2, D1) args: 8, res: 0, upd: 8;
       c930: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c93j; else goto c93i;
       c93j: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c93i: // global
           _s7tY::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s7tY::P64;
           I64[Sp + 8] = block_c93c_info;
           R3 = _s7tV::I64;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       c931: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 _c93c() //  [D1]
         { info_tbl: [(c93c,
                       label: block_c93c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c93c: // global
           D1 = %MO_F_Neg_W64(D1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.358458491 UTC

[section ""data" . GHC.Integer.Type.encodeFloat#_closure" {
     GHC.Integer.Type.encodeFloat#_closure:
         const GHC.Integer.Type.encodeFloat#_info;
 },
 GHC.Integer.Type.encodeFloat#_entry() //  [R2, R3]
         { info_tbl: [(c93R,
                       label: GHC.Integer.Type.encodeFloat#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c93R: // global
           _c93Q::I64 = R3;
           (_s7u6::F32) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeFloat(R2, _c93Q::I64);
           F1 = _s7u6::F32;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.363649313 UTC

[section ""data" . f1_r3Bw_closure" {
     f1_r3Bw_closure:
         const f1_r3Bw_info;
 },
 f1_r3Bw_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c941: // global
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           F1 = F32[Sp];
           R1 = R1;
           Sp = Sp + 24;
           call f1_r3Bw_entry(R3, R2, F1, R1) args: 8, res: 0, upd: 8;
     }
 },
 f1_r3Bw_entry() //  [R2, R3, F1]
         { info_tbl: [(c94c,
                       label: f1_r3Bw_info
                       rep:HeapRep static {
                             Fun {arity: 3 fun_type: ArgGen [True, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c94c: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c94d; else goto u94s;
       c94d: // global
           R1 = f1_r3Bw_closure;
           F32[Sp - 24] = F1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       u94s: // global
           F32[Sp - 24] = F1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _c942() args: 0, res: 0, upd: 0;
     }
 },
 _c942() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c942: // global
           I64[Sp - 8] = block_c945_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u94u; else goto c946;
       u94u: // global
           call _c945(R1) args: 0, res: 0, upd: 0;
       c946: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c945() //  [R1]
         { info_tbl: [(c945,
                       label: block_c945_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c945: // global
           _s7u7::F32 = F32[Sp + 8];
           if (R1 & 7 == 1) goto c949; else goto c94a;
       c949: // global
           _s7u9::I64 = I64[Sp + 24];
           _s7uc::P64 = P64[R1 + 7];
           (_s7ug::F32) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeFloat(I64[R1 + 15], _s7u9::I64);
           F32[Sp + 8] = %MO_F_Add_W32(_s7u7::F32, _s7ug::F32);
           P64[Sp + 16] = _s7uc::P64;
           I64[Sp + 24] = _s7u9::I64 + 64;
           Sp = Sp + 8;
           call _c942() args: 0, res: 0, upd: 0;
       c94a: // global
           F1 = _s7u7::F32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.373646853 UTC

[section ""data" . GHC.Integer.Type.encodeFloatInteger_closure" {
     GHC.Integer.Type.encodeFloatInteger_closure:
         const GHC.Integer.Type.encodeFloatInteger_info;
 },
 GHC.Integer.Type.encodeFloatInteger_entry() //  [R2, R3]
         { info_tbl: [(c953,
                       label: GHC.Integer.Type.encodeFloatInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c953: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c954; else goto c955;
       c954: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.encodeFloatInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c955: // global
           I64[Sp - 16] = block_c94V_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u95p; else goto c94W;
       u95p: // global
           call _c94V(R1) args: 0, res: 0, upd: 0;
       c94W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c94V() //  [R1]
         { info_tbl: [(c94V,
                       label: block_c94V_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c94V: // global
           _c952::P64 = R1 & 7;
           if (_c952::P64 < 3) goto u95o; else goto c951;
       u95o: // global
           _s7uk::I64 = I64[Sp + 8];
           if (_c952::P64 < 2) goto c94Z; else goto c950;
       c94Z: // global
           R3 = _s7uk::I64;
           R2 = P64[R1 + 7];
           F1 = 0.0 :: W32;
           Sp = Sp + 16;
           call f1_r3Bw_entry(R3, R2, F1) args: 8, res: 0, upd: 8;
       c950: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95j; else goto c95i;
       c95j: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95i: // global
           _s7un::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s7un::P64;
           I64[Sp + 8] = block_c95c_info;
           R3 = _s7uk::I64;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
       c951: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 _c95c() //  [F1]
         { info_tbl: [(c95c,
                       label: block_c95c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95c: // global
           F1 = %MO_F_Neg_W32(F1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.383838192 UTC

[section ""data" . GHC.Integer.Type.Positive_closure" {
     GHC.Integer.Type.Positive_closure:
         const GHC.Integer.Type.Positive_info;
 },
 GHC.Integer.Type.Positive_entry() //  [R2]
         { info_tbl: [(c95P,
                       label: GHC.Integer.Type.Positive_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95T; else goto c95S;
       c95T: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Type.Positive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95S: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.388696879 UTC

[section ""data" . GHC.Integer.Type.Negative_closure" {
     GHC.Integer.Type.Negative_closure:
         const GHC.Integer.Type.Negative_info;
 },
 GHC.Integer.Type.Negative_entry() //  [R2]
         { info_tbl: [(c965,
                       label: GHC.Integer.Type.Negative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c965: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c969; else goto c968;
       c969: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Type.Negative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c968: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.393022784 UTC

[section ""data" . GHC.Integer.Type.Naught_closure" {
     GHC.Integer.Type.Naught_closure:
         const GHC.Integer.Type.Naught_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.396665083 UTC

[section ""data" . GHC.Integer.Type.Nil_closure" {
     GHC.Integer.Type.Nil_closure:
         const GHC.Integer.Type.Nil_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.399153814 UTC

[section ""data" . GHC.Integer.Type.Cons_closure" {
     GHC.Integer.Type.Cons_closure:
         const GHC.Integer.Type.Cons_info;
 },
 GHC.Integer.Type.Cons_entry() //  [R2, R3]
         { info_tbl: [(c96n,
                       label: GHC.Integer.Type.Cons_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c96r; else goto c96q;
       c96r: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.Cons_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c96q: // global
           I64[Hp - 16] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.403807937 UTC

[section ""data" . GHC.Integer.Type.Some_closure" {
     GHC.Integer.Type.Some_closure:
         const GHC.Integer.Type.Some_info;
 },
 GHC.Integer.Type.Some_entry() //  [R2, R3]
         { info_tbl: [(c96D,
                       label: GHC.Integer.Type.Some_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c96H; else goto c96G;
       c96H: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.Some_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c96G: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R3;
           I64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.408585872 UTC

[section ""data" . GHC.Integer.Type.None_closure" {
     GHC.Integer.Type.None_closure:
         const GHC.Integer.Type.None_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.410711115 UTC

[GHC.Integer.Type.Positive_con_entry() //  [R1]
         { info_tbl: [(c96P,
                       label: GHC.Integer.Type.Positive_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,80,111,115,105,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96P: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.414698111 UTC

[GHC.Integer.Type.Negative_con_entry() //  [R1]
         { info_tbl: [(c96W,
                       label: GHC.Integer.Type.Negative_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,101,103,97,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96W: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.418984811 UTC

[GHC.Integer.Type.Naught_con_entry() //  [R1]
         { info_tbl: [(c973,
                       label: GHC.Integer.Type.Naught_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,97,117,103,104,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c973: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.422872384 UTC

[GHC.Integer.Type.Nil_con_entry() //  [R1]
         { info_tbl: [(c97a,
                       label: GHC.Integer.Type.Nil_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,105,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c97a: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.427119112 UTC

[GHC.Integer.Type.Cons_con_entry() //  [R1]
         { info_tbl: [(c97h,
                       label: GHC.Integer.Type.Cons_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 1
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,67,111,110,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c97h: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.430810224 UTC

[GHC.Integer.Type.Some_con_entry() //  [R1]
         { info_tbl: [(c97o,
                       label: GHC.Integer.Type.Some_con_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Con {tag: 0
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,83,111,109,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c97o: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.434621558 UTC

[GHC.Integer.Type.None_con_entry() //  [R1]
         { info_tbl: [(c97v,
                       label: GHC.Integer.Type.None_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,111,110,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c97v: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:53:56.438687069 UTC

[section ""relreadonly" . S7IQ_srt" {
     S7IQ_srt:
         const GHC.Integer.Type.plusPositive_addWithCarry_closure;
         const lvl_r3Bo_closure;
         const GHC.Integer.Type.timesDigit_closure;
         const GHC.Integer.Type.timesPositive_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const GHC.Integer.Type.complementInteger_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Integer.Type.modInteger_closure;
 }]

