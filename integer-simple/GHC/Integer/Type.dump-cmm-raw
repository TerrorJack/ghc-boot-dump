
==================== Raw Cmm ====================
2018-03-16 15:53:49.605439921 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:53:49.608066562 UTC

[section ""data" . GHC.Integer.Type.$WPositive_closure" {
     GHC.Integer.Type.$WPositive_closure:
         const GHC.Integer.Type.$WPositive_info;
 },
 GHC.Integer.Type.$WPositive_entry() //  [R2]
         { []
         }
     {offset
       c5Ls: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5Lw; else goto c5Lx;
       c5Lw: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$WPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Lx: // global
           I64[Sp - 8] = block_c5Lp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5LB; else goto c5Lq;
       u5LB: // global
           call _c5Lp(R1) args: 0, res: 0, upd: 0;
       c5Lq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.$WPositive_info" {
     GHC.Integer.Type.$WPositive_info:
         const GHC.Integer.Type.$WPositive_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c5Lp() //  [R1]
         { []
         }
     {offset
       c5Lp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5LA; else goto c5Lz;
       c5LA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Lz: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Lp_info" {
     block_c5Lp_info:
         const _c5Lp;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.616408995 UTC

[section ""data" . GHC.Integer.Type.$WNegative_closure" {
     GHC.Integer.Type.$WNegative_closure:
         const GHC.Integer.Type.$WNegative_info;
 },
 GHC.Integer.Type.$WNegative_entry() //  [R2]
         { []
         }
     {offset
       c5LT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5LX; else goto c5LY;
       c5LX: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$WNegative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5LY: // global
           I64[Sp - 8] = block_c5LQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5M2; else goto c5LR;
       u5M2: // global
           call _c5LQ(R1) args: 0, res: 0, upd: 0;
       c5LR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.$WNegative_info" {
     GHC.Integer.Type.$WNegative_info:
         const GHC.Integer.Type.$WNegative_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c5LQ() //  [R1]
         { []
         }
     {offset
       c5LQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5M1; else goto c5M0;
       c5M1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5M0: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5LQ_info" {
     block_c5LQ_info:
         const _c5LQ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.623801464 UTC

[section ""data" . GHC.Integer.Type.$WSome_closure" {
     GHC.Integer.Type.$WSome_closure:
         const GHC.Integer.Type.$WSome_info;
 },
 GHC.Integer.Type.$WSome_entry() //  [R2, R3]
         { []
         }
     {offset
       c5Mk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5Mo; else goto c5Mp;
       c5Mo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$WSome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5Mp: // global
           I64[Sp - 16] = block_c5Mh_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5Mt; else goto c5Mi;
       u5Mt: // global
           call _c5Mh(R1) args: 0, res: 0, upd: 0;
       c5Mi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.$WSome_info" {
     GHC.Integer.Type.$WSome_info:
         const GHC.Integer.Type.$WSome_entry;
         const 0;
         const 14;
         const 8589934605;
 },
 _c5Mh() //  [R1]
         { []
         }
     {offset
       c5Mh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Ms; else goto c5Mr;
       c5Ms: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Mr: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Mh_info" {
     block_c5Mh_info:
         const _c5Mh;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.6306485 UTC

[section ""data" . GHC.Integer.Type.errorPositive_closure" {
     GHC.Integer.Type.errorPositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 47;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.632823577 UTC

[section ""data" . GHC.Integer.Type.errorInteger_closure" {
     GHC.Integer.Type.errorInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.errorPositive_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.635735923 UTC

[section ""data" . GHC.Integer.Type.wordToInteger_closure" {
     GHC.Integer.Type.wordToInteger_closure:
         const GHC.Integer.Type.wordToInteger_info;
 },
 GHC.Integer.Type.wordToInteger_entry() //  [R2]
         { []
         }
     {offset
       c5MP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c5MT; else goto c5MS;
       c5MT: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Integer.Type.wordToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5MS: // global
           if (R2 == 0) goto c5MO; else goto c5MN;
       c5MO: // global
           Hp = Hp - 40;
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5MN: // global
           I64[Hp - 32] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 24] = GHC.Integer.Type.None_closure+2;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.wordToInteger_info" {
     GHC.Integer.Type.wordToInteger_info:
         const GHC.Integer.Type.wordToInteger_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.64246806 UTC

[section ""data" . GHC.Integer.Type.integerToWord_closure" {
     GHC.Integer.Type.integerToWord_closure:
         const GHC.Integer.Type.integerToWord_info;
 },
 GHC.Integer.Type.integerToWord_entry() //  [R2]
         { []
         }
     {offset
       c5Ng: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5Nh; else goto c5Ni;
       c5Nh: // global
           R2 = R2;
           R1 = GHC.Integer.Type.integerToWord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Ni: // global
           I64[Sp - 8] = block_c5N8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5O0; else goto c5N9;
       u5O0: // global
           call _c5N8(R1) args: 0, res: 0, upd: 0;
       c5N9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.integerToWord_info" {
     GHC.Integer.Type.integerToWord_info:
         const GHC.Integer.Type.integerToWord_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c5N8() //  [R1]
         { []
         }
     {offset
       c5N8: // global
           _c5Nf::P64 = R1 & 7;
           if (_c5Nf::P64 < 3) goto u5NT; else goto u5NU;
       u5NT: // global
           if (_c5Nf::P64 < 2) goto c5Nc; else goto c5Nd;
       c5Nc: // global
           I64[Sp] = block_c5Nl_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u5NX; else goto c5Nn;
       u5NX: // global
           call _c5Nl(R1) args: 0, res: 0, upd: 0;
       c5Nn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5Nd: // global
           I64[Sp] = block_c5NA_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u5NY; else goto c5NC;
       u5NY: // global
           call _c5NA(R1) args: 0, res: 0, upd: 0;
       c5NC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u5NU: // global
           Sp = Sp + 8;
           call _c5Ne() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c5N8_info" {
     block_c5N8_info:
         const _c5N8;
         const 0;
         const 30;
 },
 _c5Nl() //  [R1]
         { []
         }
     {offset
       c5Nl: // global
           if (R1 & 7 == 1) goto c5Nt; else goto u5NV;
       c5Nt: // global
           R1 = I64[R1 + 15];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u5NV: // global
           Sp = Sp + 8;
           call _c5Ne() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c5Nl_info" {
     block_c5Nl_info:
         const _c5Nl;
         const 0;
         const 30;
 },
 _c5NA() //  [R1]
         { []
         }
     {offset
       c5NA: // global
           if (R1 & 7 == 1) goto c5NJ; else goto u5NW;
       c5NJ: // global
           R1 = 0 - I64[R1 + 15];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u5NW: // global
           Sp = Sp + 8;
           call _c5Ne() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c5NA_info" {
     block_c5NA_info:
         const _c5NA;
         const 0;
         const 30;
 },
 _c5Ne() //  []
         { []
         }
     {offset
       c5Ne: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.654429235 UTC

[section ""data" . GHC.Integer.Type.integerToInt_closure" {
     GHC.Integer.Type.integerToInt_closure:
         const GHC.Integer.Type.integerToInt_info;
 },
 GHC.Integer.Type.integerToInt_entry() //  [R2]
         { []
         }
     {offset
       c5OC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5OG; else goto c5OH;
       c5OG: // global
           R2 = R2;
           R1 = GHC.Integer.Type.integerToInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5OH: // global
           I64[Sp - 8] = block_c5OA_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.integerToInt_info" {
     GHC.Integer.Type.integerToInt_info:
         const GHC.Integer.Type.integerToInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c5OA() //  [R1]
         { []
         }
     {offset
       c5OA: // global
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5OA_info" {
     block_c5OA_info:
         const _c5OA;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.66069731 UTC

[section ""data" . GHC.Integer.Type.hashInteger_closure" {
     GHC.Integer.Type.hashInteger_closure:
         const GHC.Integer.Type.hashInteger_info;
 },
 GHC.Integer.Type.hashInteger_entry() //  [R2]
         { []
         }
     {offset
       c5OW: // global
           R2 = R2;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.hashInteger_info" {
     GHC.Integer.Type.hashInteger_info:
         const GHC.Integer.Type.hashInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.665757376 UTC

[section ""data" . GHC.Integer.Type.flipBitsDigits_closure" {
     GHC.Integer.Type.flipBitsDigits_closure:
         const GHC.Integer.Type.flipBitsDigits_info;
 },
 GHC.Integer.Type.flipBitsDigits_entry() //  [R2]
         { []
         }
     {offset
       c5Pe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5Pf; else goto c5Pg;
       c5Pf: // global
           R2 = R2;
           R1 = GHC.Integer.Type.flipBitsDigits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Pg: // global
           I64[Sp - 8] = block_c5P7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5Py; else goto c5P8;
       u5Py: // global
           call _c5P7(R1) args: 0, res: 0, upd: 0;
       c5P8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.flipBitsDigits_info" {
     GHC.Integer.Type.flipBitsDigits_info:
         const GHC.Integer.Type.flipBitsDigits_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c5P7() //  [R1]
         { []
         }
     {offset
       c5P7: // global
           if (R1 & 7 == 1) goto c5Pb; else goto c5Pc;
       c5Pb: // global
           I64[Sp - 8] = block_c5Pj_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
       c5Pc: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5P7_info" {
     block_c5P7_info:
         const _c5P7;
         const 0;
         const 30;
 },
 _c5Pj() //  [R1]
         { []
         }
     {offset
       c5Pj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Pu; else goto c5Pt;
       c5Pu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Pt: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = ~I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Pj_info" {
     block_c5Pj_info:
         const _c5Pj;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.674354671 UTC

[section ""data" . GHC.Integer.Type.flipBits1_closure" {
     GHC.Integer.Type.flipBits1_closure:
         const GHC.Integer.Type.flipBits1_info;
 },
 GHC.Integer.Type.flipBits1_entry() //  [R2]
         { []
         }
     {offset
       c5PV: // global
           R2 = R2;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.flipBits1_info" {
     GHC.Integer.Type.flipBits1_info:
         const GHC.Integer.Type.flipBits1_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.67872578 UTC

[section ""data" . GHC.Integer.Type.flipBits_closure" {
     GHC.Integer.Type.flipBits_closure:
         const GHC.Integer.Type.flipBits_info;
 },
 GHC.Integer.Type.flipBits_entry() //  [R2]
         { []
         }
     {offset
       c5Q6: // global
           R2 = R2;
           call GHC.Integer.Type.flipBits1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.flipBits_info" {
     GHC.Integer.Type.flipBits_info:
         const GHC.Integer.Type.flipBits_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.684290963 UTC

[section ""data" . GHC.Integer.Type.negateInteger_closure" {
     GHC.Integer.Type.negateInteger_closure:
         const GHC.Integer.Type.negateInteger_info;
 },
 GHC.Integer.Type.negateInteger_entry() //  [R2]
         { []
         }
     {offset
       c5Qp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5Qq; else goto c5Qr;
       c5Qq: // global
           R2 = R2;
           R1 = GHC.Integer.Type.negateInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Qr: // global
           I64[Sp - 8] = block_c5Qh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5QI; else goto c5Qi;
       u5QI: // global
           call _c5Qh(R1) args: 0, res: 0, upd: 0;
       c5Qi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.negateInteger_info" {
     GHC.Integer.Type.negateInteger_info:
         const GHC.Integer.Type.negateInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c5Qh() //  [R1]
         { []
         }
     {offset
       c5Qh: // global
           _c5Qo::P64 = R1 & 7;
           if (_c5Qo::P64 < 3) goto u5QH; else goto c5Qn;
       u5QH: // global
           if (_c5Qo::P64 < 2) goto c5Ql; else goto c5Qm;
       c5Ql: // global
           Hp = Hp + 16;
           _s3C2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c5QD; else goto c5Qw;
       c5Qw: // global
           _s3C3::P64 = P64[_s3C2::P64 + 7];
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = _s3C3::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5Qm: // global
           Hp = Hp + 16;
           _s3C2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c5QD; else goto c5QC;
       c5QD: // global
           HpAlloc = 16;
           R1 = _s3C2::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5QC: // global
           _s3C4::P64 = P64[_s3C2::P64 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3C4::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5Qn: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Qh_info" {
     block_c5Qh_info:
         const _c5Qh;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.692225296 UTC

[section ""data" . GHC.Integer.Type.smallInteger_closure" {
     GHC.Integer.Type.smallInteger_closure:
         const GHC.Integer.Type.smallInteger_info;
 },
 GHC.Integer.Type.smallInteger_entry() //  [R2]
         { []
         }
     {offset
       c5R5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5R6; else goto c5R7;
       c5R6: // global
           R2 = R2;
           R1 = GHC.Integer.Type.smallInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5R7: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c5R3; else goto c5R4;
       c5R3: // global
           I64[Sp - 8] = block_c5Rf_info;
           R2 = -R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c5R4: // global
           R2 = R2;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.smallInteger_info" {
     GHC.Integer.Type.smallInteger_info:
         const GHC.Integer.Type.smallInteger_entry;
         const 0;
         const 14;
         const 4294967300;
 },
 _c5Rf() //  [R1]
         { []
         }
     {offset
       c5Rf: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Rf_info" {
     block_c5Rf_info:
         const _c5Rf;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.699595995 UTC

[section ""data" . GHC.Integer.Type.decodeFloatInteger_closure" {
     GHC.Integer.Type.decodeFloatInteger_closure:
         const GHC.Integer.Type.decodeFloatInteger_info;
 },
 sat_s3Cf_entry() //  [R1]
         { []
         }
     {offset
       c5RG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5RH; else goto c5RI;
       c5RH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5RI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3Cf_info" {
     sat_s3Cf_info:
         const sat_s3Cf_entry;
         const 4294967296;
         const 17;
 },
 GHC.Integer.Type.decodeFloatInteger_entry() //  [F1]
         { []
         }
     {offset
       c5RJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5RK; else goto c5RL;
       c5RK: // global
           F1 = F1;
           R1 = GHC.Integer.Type.decodeFloatInteger_closure;
           call (stg_gc_fun)(F1, R1) args: 8, res: 0, upd: 8;
       c5RL: // global
           I64[Sp - 8] = block_c5Ry_info;
           F1 = F1;
           Sp = Sp - 8;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.decodeFloatInteger_info" {
     GHC.Integer.Type.decodeFloatInteger_info:
         const GHC.Integer.Type.decodeFloatInteger_entry;
         const 0;
         const 14;
         const 4294967302;
 },
 _c5Ry() //  [R1, R2]
         { []
         }
     {offset
       c5Ry: // global
           I64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5Rz() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c5Ry_info" {
     block_c5Ry_info:
         const _c5Ry;
         const 0;
         const 30;
 },
 _c5Rz() //  []
         { []
         }
     {offset
       c5Rz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5RO; else goto c5RN;
       c5RO: // global
           HpAlloc = 24;
           I64[Sp] = block_c5Rz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5RN: // global
           I64[Hp - 16] = sat_s3Cf_info;
           I64[Hp] = I64[Sp + 16];
           R2 = I64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Rz_info" {
     block_c5Rz_info:
         const _c5Rz;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.71051137 UTC

[section ""data" . GHC.Integer.Type.absInteger_closure" {
     GHC.Integer.Type.absInteger_closure:
         const GHC.Integer.Type.absInteger_info;
 },
 GHC.Integer.Type.absInteger_entry() //  [R2]
         { []
         }
     {offset
       c5Sj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5Sk; else goto c5Sl;
       c5Sk: // global
           R2 = R2;
           R1 = GHC.Integer.Type.absInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Sl: // global
           I64[Sp - 8] = block_c5Sc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5Sv; else goto c5Sd;
       u5Sv: // global
           call _c5Sc(R1) args: 0, res: 0, upd: 0;
       c5Sd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.absInteger_info" {
     GHC.Integer.Type.absInteger_info:
         const GHC.Integer.Type.absInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c5Sc() //  [R1]
         { []
         }
     {offset
       c5Sc: // global
           if (R1 & 7 == 2) goto c5Sh; else goto c5Sg;
       c5Sh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5Su; else goto c5St;
       c5Su: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5St: // global
           _s3Ci::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3Ci::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5Sg: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Sc_info" {
     block_c5Sc_info:
         const _c5Sc;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.71690504 UTC

[section ""data" . GHC.Integer.Type.onePositive_closure" {
     GHC.Integer.Type.onePositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.719585169 UTC

[section ""data" . GHC.Integer.Type.negativeOneInteger_closure" {
     GHC.Integer.Type.negativeOneInteger_closure:
         const GHC.Integer.Type.Negative_con_info;
         const GHC.Integer.Type.onePositive_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.721667075 UTC

[section ""data" . GHC.Integer.Type.oneInteger_closure" {
     GHC.Integer.Type.oneInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.onePositive_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.724895484 UTC

[section ""data" . GHC.Integer.Type.signumInteger_closure" {
     GHC.Integer.Type.signumInteger_closure:
         const GHC.Integer.Type.signumInteger_info;
 },
 GHC.Integer.Type.signumInteger_entry() //  [R2]
         { []
         }
     {offset
       c5SZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5T0; else goto c5T1;
       c5T0: // global
           R2 = R2;
           R1 = GHC.Integer.Type.signumInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5T1: // global
           I64[Sp - 8] = block_c5SR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5Tc; else goto c5SS;
       u5Tc: // global
           call _c5SR(R1) args: 0, res: 0, upd: 0;
       c5SS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.signumInteger_info" {
     GHC.Integer.Type.signumInteger_info:
         const GHC.Integer.Type.signumInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c5SR() //  [R1]
         { []
         }
     {offset
       c5SR: // global
           _c5SY::P64 = R1 & 7;
           if (_c5SY::P64 < 3) goto u5Tb; else goto c5SX;
       u5Tb: // global
           if (_c5SY::P64 < 2) goto c5SV; else goto c5SW;
       c5SV: // global
           R1 = GHC.Integer.Type.oneInteger_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5SW: // global
           R1 = GHC.Integer.Type.negativeOneInteger_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5SX: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5SR_info" {
     block_c5SR_info:
         const _c5SR;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.73174251 UTC

[section ""data" . GHC.Integer.Type.halfBoundUp_closure" {
     GHC.Integer.Type.halfBoundUp_closure:
         const GHC.Integer.Type.halfBoundUp_info;
 },
 GHC.Integer.Type.halfBoundUp_entry() //  [R2]
         { []
         }
     {offset
       c5Tx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5Ty; else goto c5Tz;
       c5Ty: // global
           R2 = R2;
           R1 = GHC.Integer.Type.halfBoundUp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Tz: // global
           I64[Sp - 8] = block_c5Tu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5TD; else goto c5Tv;
       u5TD: // global
           call _c5Tu() args: 0, res: 0, upd: 0;
       c5Tv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.halfBoundUp_info" {
     GHC.Integer.Type.halfBoundUp_info:
         const GHC.Integer.Type.halfBoundUp_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c5Tu() //  []
         { []
         }
     {offset
       c5Tu: // global
           R1 = 9223372036854775808;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Tu_info" {
     block_c5Tu_info:
         const _c5Tu;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.738841498 UTC

[section ""data" . GHC.Integer.Type.fullBound_closure" {
     GHC.Integer.Type.fullBound_closure:
         const GHC.Integer.Type.fullBound_info;
 },
 GHC.Integer.Type.fullBound_entry() //  [R2]
         { []
         }
     {offset
       c5TV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5TW; else goto c5TX;
       c5TW: // global
           R2 = R2;
           R1 = GHC.Integer.Type.fullBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5TX: // global
           I64[Sp - 8] = block_c5TS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5U1; else goto c5TT;
       u5U1: // global
           call _c5TS() args: 0, res: 0, upd: 0;
       c5TT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.fullBound_info" {
     GHC.Integer.Type.fullBound_info:
         const GHC.Integer.Type.fullBound_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c5TS() //  []
         { []
         }
     {offset
       c5TS: // global
           R1 = 18446744073709551615;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5TS_info" {
     block_c5TS_info:
         const _c5TS;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.746971345 UTC

[section ""data" . GHC.Integer.Type.$wsuccPositive_closure" {
     GHC.Integer.Type.$wsuccPositive_closure:
         const GHC.Integer.Type.$wsuccPositive_info;
 },
 GHC.Integer.Type.$wsuccPositive_entry() //  [R2]
         { []
         }
     {offset
       c5Un: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5Uo; else goto c5Up;
       c5Uo: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$wsuccPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Up: // global
           I64[Sp - 8] = block_c5Ug_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5UM; else goto c5Uh;
       u5UM: // global
           call _c5Ug(R1) args: 0, res: 0, upd: 0;
       c5Uh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.$wsuccPositive_info" {
     GHC.Integer.Type.$wsuccPositive_info:
         const GHC.Integer.Type.$wsuccPositive_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c5Ug() //  [R1]
         { []
         }
     {offset
       c5Ug: // global
           if (R1 & 7 == 1) goto c5Uk; else goto c5Ul;
       c5Uk: // global
           _s3Cu::P64 = P64[R1 + 7];
           _s3Cv::I64 = I64[R1 + 15];
           if (_s3Cv::I64 != 18446744073709551615) goto c5Uv; else goto c5UD;
       c5Uv: // global
           R2 = _s3Cu::P64;
           R1 = _s3Cv::I64 + 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c5UD: // global
           I64[Sp] = block_c5Uy_info;
           R2 = _s3Cu::P64;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
       c5Ul: // global
           R2 = GHC.Integer.Type.None_closure+2;
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Ug_info" {
     block_c5Ug_info:
         const _c5Ug;
         const 0;
         const 30;
 },
 _c5Uy() //  [R1, R2]
         { []
         }
     {offset
       c5Uy: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5Uz() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c5Uy_info" {
     block_c5Uy_info:
         const _c5Uy;
         const 0;
         const 30;
 },
 _c5Uz() //  []
         { []
         }
     {offset
       c5Uz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5UG; else goto c5UF;
       c5UG: // global
           HpAlloc = 24;
           I64[Sp] = block_c5Uz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5UF: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = Hp - 15;
           R1 = 0;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Uz_info" {
     block_c5Uz_info:
         const _c5Uz;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.758619618 UTC

[section ""data" . GHC.Integer.Type.succPositive_closure" {
     GHC.Integer.Type.succPositive_closure:
         const GHC.Integer.Type.succPositive_info;
 },
 GHC.Integer.Type.succPositive_entry() //  [R2]
         { []
         }
     {offset
       c5Vj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5Vk; else goto c5Vl;
       c5Vk: // global
           R2 = R2;
           R1 = GHC.Integer.Type.succPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5Vl: // global
           I64[Sp - 8] = block_c5Ve_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.succPositive_info" {
     GHC.Integer.Type.succPositive_info:
         const GHC.Integer.Type.succPositive_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c5Ve() //  [R1, R2]
         { []
         }
     {offset
       c5Ve: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5Vf() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c5Ve_info" {
     block_c5Ve_info:
         const _c5Ve;
         const 0;
         const 30;
 },
 _c5Vf() //  []
         { []
         }
     {offset
       c5Vf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Vo; else goto c5Vn;
       c5Vo: // global
           HpAlloc = 24;
           I64[Sp] = block_c5Vf_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5Vn: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Vf_info" {
     block_c5Vf_info:
         const _c5Vf;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.76779186 UTC

[section ""data" . lvl_r3Bo_closure" {
     lvl_r3Bo_closure:
         const lvl_r3Bo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r3Bo_entry() //  [R1]
         { []
         }
     {offset
       c5VQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c5VR; else goto c5VS;
       c5VR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5VS: // global
           (_c5VI::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c5VI::I64 == 0) goto c5VK; else goto c5VJ;
       c5VK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c5VJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c5VI::I64;
           I64[Sp - 24] = block_c5VL_info;
           R2 = GHC.Integer.Type.None_closure+2;
           Sp = Sp - 24;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . lvl_r3Bo_info" {
     lvl_r3Bo_info:
         const lvl_r3Bo_entry;
         const 0;
         const 21;
 },
 _c5VL() //  [R1, R2]
         { []
         }
     {offset
       c5VL: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5VM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c5VL_info" {
     block_c5VL_info:
         const _c5VL;
         const 0;
         const 30;
 },
 _c5VM() //  []
         { []
         }
     {offset
       c5VM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5VV; else goto c5VU;
       c5VV: // global
           HpAlloc = 24;
           I64[Sp] = block_c5VM_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c5VU: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c5VM_info" {
     block_c5VM_info:
         const _c5VM;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.782269346 UTC

[section ""data" . GHC.Integer.Type.plusPositive_addWithCarry_closure" {
     GHC.Integer.Type.plusPositive_addWithCarry_closure:
         const GHC.Integer.Type.plusPositive_addWithCarry_info;
         const 0;
 },
 GHC.Integer.Type.plusPositive_addWithCarry_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c5Wp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c5Wq; else goto u5YW;
       c5Wq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.plusPositive_addWithCarry_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u5YW: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c5Wf() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.plusPositive_addWithCarry_info" {
     GHC.Integer.Type.plusPositive_addWithCarry_info:
         const GHC.Integer.Type.plusPositive_addWithCarry_entry;
         const 0;
         const 12884901902;
         const 12884901907;
         const S3Xx_srt;
 },
 _c5Wf() //  []
         { []
         }
     {offset
       c5Wf: // global
           I64[Sp - 8] = block_c5Wi_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5Z0; else goto c5Wj;
       u5Z0: // global
           call _c5Wi(R1) args: 0, res: 0, upd: 0;
       c5Wj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5Wi() //  [R1]
         { []
         }
     {offset
       c5Wi: // global
           _s3CK::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c5Wm; else goto c5Wn;
       c5Wm: // global
           I64[Sp - 8] = block_c5Wu_info;
           _s3CL::P64 = R1;
           _s3CN::P64 = P64[R1 + 7];
           _s3CM::I64 = I64[R1 + 15];
           R1 = _s3CK::P64;
           P64[Sp] = _s3CN::P64;
           I64[Sp + 16] = _s3CM::I64;
           P64[Sp + 24] = _s3CL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5Z1; else goto c5Ww;
       u5Z1: // global
           call _c5Wu(R1) args: 0, res: 0, upd: 0;
       c5Ww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c5Wn: // global
           I64[Sp] = block_c5Yq_info;
           R1 = _s3CK::P64;
           if (R1 & 7 != 0) goto u5Z2; else goto c5Ys;
       u5Z2: // global
           call _c5Yq(R1) args: 0, res: 0, upd: 0;
       c5Ys: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Wi_info" {
     block_c5Wi_info:
         const _c5Wi;
         const 195;
         const 12884901918;
         const S3Xx_srt;
 },
 _c5Wu() //  [R1]
         { []
         }
     {offset
       c5Wu: // global
           _s3CI::I64 = I64[Sp + 16];
           _s3CL::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c5Y6; else goto c5Yn;
       c5Y6: // global
           _s3CM::I64 = I64[Sp + 24];
           _s3CP::I64 = I64[R1 + 15];
           if (_s3CM::I64 >= _s3CP::I64) goto c5Y3; else goto c5Y4;
       c5Y3: // global
           _s3CN::P64 = P64[Sp + 8];
           _s3CQ::P64 = P64[R1 + 7];
           if (_s3CP::I64 < 9223372036854775808) goto c5XF; else goto c5XY;
       c5XF: // global
           if (_s3CM::I64 < 9223372036854775808) goto c5WW; else goto c5XD;
       c5WW: // global
           I64[Sp + 8] = block_c5WK_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 0;
           I64[Sp + 32] = _s3CP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c5XD: // global
           _s3CX::I64 = (_s3CM::I64 + -9223372036854775808) + (_s3CP::I64 + _s3CI::I64);
           if (_s3CX::I64 >= 9223372036854775808) goto c5Xm; else goto c5Xz;
       c5Xm: // global
           I64[Sp + 24] = block_c5Xd_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 1;
           I64[Sp + 32] = _s3CX::I64;
           Sp = Sp + 24;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c5Xz: // global
           I64[Sp + 24] = block_c5Xr_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 0;
           I64[Sp + 32] = _s3CX::I64;
           Sp = Sp + 24;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c5XY: // global
           I64[Sp + 8] = block_c5XH_info;
           R4 = _s3CQ::P64;
           R3 = _s3CN::P64;
           R2 = 1;
           I64[Sp + 32] = _s3CP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c5Y4: // global
           I64[Sp + 16] = _s3CI::I64;
           P64[Sp + 24] = R1;
           P64[Sp + 32] = _s3CL::P64;
           Sp = Sp + 16;
           call _c5Wf() args: 0, res: 0, upd: 0;
       c5Yn: // global
           if (_s3CI::I64 == 0) goto c5Ym; else goto c5Yi;
       c5Ym: // global
           R1 = _s3CL::P64 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c5Yi: // global
           I64[Sp + 32] = block_c5Yc_info;
           R2 = _s3CL::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Wu_info" {
     block_c5Wu_info:
         const _c5Wu;
         const 388;
         const 12884901918;
         const S3Xx_srt;
 },
 _c5WK() //  [R1]
         { []
         }
     {offset
       c5WK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5WZ; else goto c5WY;
       c5WZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5WY: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] + (I64[Sp + 24] + I64[Sp + 8]);
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5WK_info" {
     block_c5WK_info:
         const _c5WK;
         const 451;
         const 30;
 },
 _c5Xd() //  [R1]
         { []
         }
     {offset
       c5Xd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Xp; else goto c5Xo;
       c5Xp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Xo: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - 9223372036854775808;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Xd_info" {
     block_c5Xd_info:
         const _c5Xd;
         const 65;
         const 30;
 },
 _c5Xr() //  [R1]
         { []
         }
     {offset
       c5Xr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5XC; else goto c5XB;
       c5XC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5XB: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - 9223372036854775808;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Xr_info" {
     block_c5Xr_info:
         const _c5Xr;
         const 65;
         const 30;
 },
 _c5XH() //  [R1]
         { []
         }
     {offset
       c5XH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Y1; else goto c5Y0;
       c5Y1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5Y0: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] + (I64[Sp + 24] + I64[Sp + 8]);
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5XH_info" {
     block_c5XH_info:
         const _c5XH;
         const 451;
         const 30;
 },
 _c5Yc() //  [R1, R2]
         { []
         }
     {offset
       c5Yc: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5Yd() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c5Yc_info" {
     block_c5Yc_info:
         const _c5Yc;
         const 0;
         const 30;
 },
 _c5Yd() //  []
         { []
         }
     {offset
       c5Yd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5Yl; else goto c5Yk;
       c5Yl: // global
           HpAlloc = 24;
           I64[Sp] = block_c5Yd_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5Yk: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Yd_info" {
     block_c5Yd_info:
         const _c5Yd;
         const 130;
         const 30;
 },
 _c5Yq() //  [R1]
         { []
         }
     {offset
       c5Yq: // global
           _s3CI::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c5YL; else goto c5YT;
       c5YL: // global
           if (_s3CI::I64 == 0) goto c5YJ; else goto c5YF;
       c5YJ: // global
           R1 = R1 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c5YF: // global
           I64[Sp + 24] = block_c5Yz_info;
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
       c5YT: // global
           if (_s3CI::I64 == 0) goto c5YS; else goto c5YR;
       c5YS: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5YR: // global
           R1 = lvl_r3Bo_closure;
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5Yq_info" {
     block_c5Yq_info:
         const _c5Yq;
         const 451;
         const 4294967326;
         const S3Xx_srt+8;
 },
 _c5Yz() //  [R1, R2]
         { []
         }
     {offset
       c5Yz: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c5YA() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c5Yz_info" {
     block_c5Yz_info:
         const _c5Yz;
         const 0;
         const 30;
 },
 _c5YA() //  []
         { []
         }
     {offset
       c5YA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5YI; else goto c5YH;
       c5YI: // global
           HpAlloc = 24;
           I64[Sp] = block_c5YA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5YH: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c5YA_info" {
     block_c5YA_info:
         const _c5YA;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.812374322 UTC

[section ""data" . GHC.Integer.Type.plusPositive_closure" {
     GHC.Integer.Type.plusPositive_closure:
         const GHC.Integer.Type.plusPositive_info;
         const 0;
 },
 GHC.Integer.Type.plusPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c60A: // global
           R4 = R3;
           R3 = R2;
           R2 = 0;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.plusPositive_info" {
     GHC.Integer.Type.plusPositive_info:
         const GHC.Integer.Type.plusPositive_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S3Xx_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.820548643 UTC

[section ""data" . GHC.Integer.Type.minusPositive_closure" {
     GHC.Integer.Type.minusPositive_closure:
         const GHC.Integer.Type.minusPositive_info;
 },
 GHC.Integer.Type.minusPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c60S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c60T; else goto c60U;
       c60T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.minusPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c60U: // global
           I64[Sp - 16] = block_c60L_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u62v; else goto c60M;
       u62v: // global
           call _c60L(R1) args: 0, res: 0, upd: 0;
       c60M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.minusPositive_info" {
     GHC.Integer.Type.minusPositive_info:
         const GHC.Integer.Type.minusPositive_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c60L() //  [R1]
         { []
         }
     {offset
       c60L: // global
           _s3Dp::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c60P; else goto c60Q;
       c60P: // global
           I64[Sp - 16] = block_c60X_info;
           _s3Dq::P64 = R1;
           _s3Ds::P64 = P64[R1 + 7];
           _s3Dr::I64 = I64[R1 + 15];
           R1 = _s3Dp::P64;
           P64[Sp - 8] = _s3Ds::P64;
           I64[Sp] = _s3Dr::I64;
           P64[Sp + 8] = _s3Dq::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u62t; else goto c60Z;
       u62t: // global
           call _c60X(R1) args: 0, res: 0, upd: 0;
       c60Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c60Q: // global
           I64[Sp + 8] = block_c62b_info;
           R1 = _s3Dp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u62u; else goto c62d;
       u62u: // global
           call _c62b(R1) args: 0, res: 0, upd: 0;
       c62d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c60L_info" {
     block_c60L_info:
         const _c60L;
         const 1;
         const 30;
 },
 _c60X() //  [R1]
         { []
         }
     {offset
       c60X: // global
           if (R1 & 7 == 1) goto c624; else goto c628;
       c624: // global
           _s3Dr::I64 = I64[Sp + 16];
           _s3Ds::P64 = P64[Sp + 8];
           _s3Dv::P64 = P64[R1 + 7];
           _s3Du::I64 = I64[R1 + 15];
           if (_s3Dr::I64 == _s3Du::I64) goto c61P; else goto c61M;
       c61P: // global
           I64[Sp + 24] = block_c61O_info;
           R3 = _s3Dv::P64;
           R2 = _s3Ds::P64;
           Sp = Sp + 24;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c61M: // global
           if (_s3Dr::I64 <= _s3Du::I64) goto c61t; else goto c61H;
       c61t: // global
           I64[Sp + 8] = block_c61a_info;
           R3 = _s3Dv::P64;
           R2 = _s3Ds::P64;
           I64[Sp + 24] = _s3Du::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c61H: // global
           I64[Sp + 8] = block_c61z_info;
           R3 = _s3Dv::P64;
           R2 = _s3Ds::P64;
           I64[Sp + 24] = _s3Du::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c628: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c60X_info" {
     block_c60X_info:
         const _c60X;
         const 131;
         const 30;
 },
 _c61O() //  [R1]
         { []
         }
     {offset
       c61O: // global
           if (R1 & 7 == 1) goto c61V; else goto u62s;
       c61V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c61Y; else goto c61X;
       c61Y: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c61X: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u62s: // global
           Sp = Sp + 8;
           call _c62n() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c61O_info" {
     block_c61O_info:
         const _c61O;
         const 0;
         const 30;
 },
 _c61a() //  [R1]
         { []
         }
     {offset
       c61a: // global
           I64[Sp] = block_c61e_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = R1;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c61a_info" {
     block_c61a_info:
         const _c61a;
         const 194;
         const 30;
 },
 _c61e() //  [R1]
         { []
         }
     {offset
       c61e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c61x; else goto c61w;
       c61x: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c61w: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 18446744073709551615 - I64[Sp + 16] + (I64[Sp + 8] + 1);
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c61e_info" {
     block_c61e_info:
         const _c61e;
         const 194;
         const 30;
 },
 _c61z() //  [R1]
         { []
         }
     {offset
       c61z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c61K; else goto c61J;
       c61K: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c61J: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c61z_info" {
     block_c61z_info:
         const _c61z;
         const 194;
         const 30;
 },
 _c62b() //  [R1]
         { []
         }
     {offset
       c62b: // global
           if (R1 & 7 == 1) goto c62j; else goto u62r;
       c62j: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u62r: // global
           Sp = Sp + 8;
           call _c62n() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c62b_info" {
     block_c62b_info:
         const _c62b;
         const 0;
         const 30;
 },
 _c62n() //  []
         { []
         }
     {offset
       c62n: // global
           R1 = GHC.Integer.Type.None_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.83977138 UTC

[section ""data" . GHC.Integer.Type.twosComplementPositive1_closure" {
     GHC.Integer.Type.twosComplementPositive1_closure:
         const GHC.Integer.Type.twosComplementPositive1_info;
 },
 GHC.Integer.Type.twosComplementPositive1_entry() //  [R2]
         { []
         }
     {offset
       c63v: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c63w; else goto c63x;
       c63w: // global
           R2 = R2;
           R1 = GHC.Integer.Type.twosComplementPositive1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c63x: // global
           I64[Sp - 8] = block_c63t_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.twosComplementPositive1_info" {
     GHC.Integer.Type.twosComplementPositive1_info:
         const GHC.Integer.Type.twosComplementPositive1_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c63t() //  [R1]
         { []
         }
     {offset
       c63t: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c63t_info" {
     block_c63t_info:
         const _c63t;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.846177666 UTC

[section ""data" . GHC.Integer.Type.twosComplementPositive_closure" {
     GHC.Integer.Type.twosComplementPositive_closure:
         const GHC.Integer.Type.twosComplementPositive_info;
 },
 GHC.Integer.Type.twosComplementPositive_entry() //  [R2]
         { []
         }
     {offset
       c63N: // global
           R2 = R2;
           call GHC.Integer.Type.twosComplementPositive1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.twosComplementPositive_info" {
     GHC.Integer.Type.twosComplementPositive_info:
         const GHC.Integer.Type.twosComplementPositive_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.850531199 UTC

[section ""data" . GHC.Integer.Type.lowHalfMask_closure" {
     GHC.Integer.Type.lowHalfMask_closure:
         const GHC.Integer.Type.lowHalfMask_info;
 },
 GHC.Integer.Type.lowHalfMask_entry() //  [R2]
         { []
         }
     {offset
       c641: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c642; else goto c643;
       c642: // global
           R2 = R2;
           R1 = GHC.Integer.Type.lowHalfMask_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c643: // global
           I64[Sp - 8] = block_c63Y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u647; else goto c63Z;
       u647: // global
           call _c63Y() args: 0, res: 0, upd: 0;
       c63Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.lowHalfMask_info" {
     GHC.Integer.Type.lowHalfMask_info:
         const GHC.Integer.Type.lowHalfMask_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c63Y() //  []
         { []
         }
     {offset
       c63Y: // global
           R1 = 4294967295;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c63Y_info" {
     block_c63Y_info:
         const _c63Y;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.856961476 UTC

[section ""data" . GHC.Integer.Type.highHalfShift_closure" {
     GHC.Integer.Type.highHalfShift_closure:
         const GHC.Integer.Type.highHalfShift_info;
 },
 GHC.Integer.Type.highHalfShift_entry() //  [R2]
         { []
         }
     {offset
       c64p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c64q; else goto c64r;
       c64q: // global
           R2 = R2;
           R1 = GHC.Integer.Type.highHalfShift_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c64r: // global
           I64[Sp - 8] = block_c64m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u64v; else goto c64n;
       u64v: // global
           call _c64m() args: 0, res: 0, upd: 0;
       c64n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.highHalfShift_info" {
     GHC.Integer.Type.highHalfShift_info:
         const GHC.Integer.Type.highHalfShift_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c64m() //  []
         { []
         }
     {offset
       c64m: // global
           R1 = 32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c64m_info" {
     block_c64m_info:
         const _c64m;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.863880291 UTC

[section ""data" . GHC.Integer.Type.splitHalves_closure" {
     GHC.Integer.Type.splitHalves_closure:
         const GHC.Integer.Type.splitHalves_info;
 },
 GHC.Integer.Type.splitHalves_entry() //  [R2]
         { []
         }
     {offset
       c64M: // global
           _s3DS::I64 = R2 >> 32;
           R2 = R2 & 4294967295;
           R1 = _s3DS::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.splitHalves_info" {
     GHC.Integer.Type.splitHalves_info:
         const GHC.Integer.Type.splitHalves_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.873338162 UTC

[section ""data" . GHC.Integer.Type.doubleFromPositive_closure" {
     GHC.Integer.Type.doubleFromPositive_closure:
         const GHC.Integer.Type.doubleFromPositive_info;
 },
 GHC.Integer.Type.doubleFromPositive_entry() //  [R2]
         { []
         }
     {offset
       c659: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c65a; else goto c65b;
       c65a: // global
           R2 = R2;
           R1 = GHC.Integer.Type.doubleFromPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c65b: // global
           I64[Sp - 8] = block_c652_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u65Z; else goto c653;
       u65Z: // global
           call _c652(R1) args: 0, res: 0, upd: 0;
       c653: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.doubleFromPositive_info" {
     GHC.Integer.Type.doubleFromPositive_info:
         const GHC.Integer.Type.doubleFromPositive_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c652() //  [R1]
         { []
         }
     {offset
       c652: // global
           if (R1 & 7 == 1) goto c656; else goto c657;
       c656: // global
           I64[Sp - 8] = block_c65e_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c657: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c652_info" {
     block_c652_info:
         const _c652;
         const 0;
         const 30;
 },
 _c65e() //  [D1]
         { []
         }
     {offset
       c65e: // global
           _s3DW::I64 = I64[Sp + 8];
           _s3DY::F64 = D1;
           (_c65r::F64) = call MO_F64_Pwr(2.0 :: W64, 32.0 :: W64);
           (_c65I::F64) = call MO_F64_Pwr(2.0 :: W64, 64.0 :: W64);
           D1 = %MO_F_Add_W64(%MO_F_Add_W64(%MO_F_Mul_W64(_s3DY::F64,
                                                          _c65I::F64),
                                            %MO_F_Mul_W64(%MO_SF_Conv_W64_W64(_s3DW::I64 >> 32),
                                                          _c65r::F64)),
                              %MO_SF_Conv_W64_W64(_s3DW::I64 & 4294967295));
           Sp = Sp + 16;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c65e_info" {
     block_c65e_info:
         const _c65e;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.888985279 UTC

[section ""data" . GHC.Integer.Type.doubleFromInteger_closure" {
     GHC.Integer.Type.doubleFromInteger_closure:
         const GHC.Integer.Type.doubleFromInteger_info;
 },
 GHC.Integer.Type.doubleFromInteger_entry() //  [R2]
         { []
         }
     {offset
       c66H: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c66I; else goto c66J;
       c66I: // global
           R2 = R2;
           R1 = GHC.Integer.Type.doubleFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c66J: // global
           I64[Sp - 8] = block_c66z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u670; else goto c66A;
       u670: // global
           call _c66z(R1) args: 0, res: 0, upd: 0;
       c66A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.doubleFromInteger_info" {
     GHC.Integer.Type.doubleFromInteger_info:
         const GHC.Integer.Type.doubleFromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c66z() //  [R1]
         { []
         }
     {offset
       c66z: // global
           _c66G::P64 = R1 & 7;
           if (_c66G::P64 < 3) goto u66Z; else goto c66F;
       u66Z: // global
           if (_c66G::P64 < 2) goto c66D; else goto c66E;
       c66D: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 0, upd: 8;
       c66E: // global
           I64[Sp] = block_c66P_info;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c66F: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c66z_info" {
     block_c66z_info:
         const _c66z;
         const 0;
         const 30;
 },
 _c66P() //  [D1]
         { []
         }
     {offset
       c66P: // global
           D1 = %MO_F_Neg_W64(D1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c66P_info" {
     block_c66P_info:
         const _c66P;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.903959419 UTC

[section ""data" . GHC.Integer.Type.floatFromPositive_closure" {
     GHC.Integer.Type.floatFromPositive_closure:
         const GHC.Integer.Type.floatFromPositive_info;
 },
 GHC.Integer.Type.floatFromPositive_entry() //  [R2]
         { []
         }
     {offset
       c67t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c67u; else goto c67v;
       c67u: // global
           R2 = R2;
           R1 = GHC.Integer.Type.floatFromPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c67v: // global
           I64[Sp - 8] = block_c67m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u68j; else goto c67n;
       u68j: // global
           call _c67m(R1) args: 0, res: 0, upd: 0;
       c67n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.floatFromPositive_info" {
     GHC.Integer.Type.floatFromPositive_info:
         const GHC.Integer.Type.floatFromPositive_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c67m() //  [R1]
         { []
         }
     {offset
       c67m: // global
           if (R1 & 7 == 1) goto c67q; else goto c67r;
       c67q: // global
           I64[Sp - 8] = block_c67y_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c67r: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c67m_info" {
     block_c67m_info:
         const _c67m;
         const 0;
         const 30;
 },
 _c67y() //  [F1]
         { []
         }
     {offset
       c67y: // global
           _s3Eh::I64 = I64[Sp + 8];
           _s3Ej::F32 = F1;
           (_c67L::F32) = call MO_F32_Pwr(2.0 :: W32, 32.0 :: W32);
           (_c682::F32) = call MO_F32_Pwr(2.0 :: W32, 64.0 :: W32);
           F1 = %MO_F_Add_W32(%MO_F_Add_W32(%MO_F_Mul_W32(_s3Ej::F32,
                                                          _c682::F32),
                                            %MO_F_Mul_W32(%MO_SF_Conv_W64_W32(_s3Eh::I64 >> 32),
                                                          _c67L::F32)),
                              %MO_SF_Conv_W64_W32(_s3Eh::I64 & 4294967295));
           Sp = Sp + 16;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c67y_info" {
     block_c67y_info:
         const _c67y;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.919071423 UTC

[section ""data" . GHC.Integer.Type.floatFromInteger_closure" {
     GHC.Integer.Type.floatFromInteger_closure:
         const GHC.Integer.Type.floatFromInteger_info;
 },
 GHC.Integer.Type.floatFromInteger_entry() //  [R2]
         { []
         }
     {offset
       c691: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c692; else goto c693;
       c692: // global
           R2 = R2;
           R1 = GHC.Integer.Type.floatFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c693: // global
           I64[Sp - 8] = block_c68T_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u69k; else goto c68U;
       u69k: // global
           call _c68T(R1) args: 0, res: 0, upd: 0;
       c68U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.floatFromInteger_info" {
     GHC.Integer.Type.floatFromInteger_info:
         const GHC.Integer.Type.floatFromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c68T() //  [R1]
         { []
         }
     {offset
       c68T: // global
           _c690::P64 = R1 & 7;
           if (_c690::P64 < 3) goto u69j; else goto c68Z;
       u69j: // global
           if (_c690::P64 < 2) goto c68X; else goto c68Y;
       c68X: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 0, upd: 8;
       c68Y: // global
           I64[Sp] = block_c699_info;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c68Z: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c68T_info" {
     block_c68T_info:
         const _c68T;
         const 0;
         const 30;
 },
 _c699() //  [F1]
         { []
         }
     {offset
       c699: // global
           F1 = %MO_F_Neg_W32(F1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c699_info" {
     block_c699_info:
         const _c699;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.935297882 UTC

[section ""data" . GHC.Integer.Type.timesDigit_closure" {
     GHC.Integer.Type.timesDigit_closure:
         const GHC.Integer.Type.timesDigit_info;
         const 0;
 },
 GHC.Integer.Type.timesDigit_entry() //  [R2, R3]
         { []
         }
     {offset
       c69I: // global
           _s3EB::I64 = R3;
           _s3EA::I64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c6am; else goto c6an;
       c6an: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6ap; else goto c6ao;
       c6ap: // global
           HpAlloc = 72;
           goto c6am;
       c6am: // global
           R3 = _s3EB::I64;
           R2 = _s3EA::I64;
           R1 = GHC.Integer.Type.timesDigit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ao: // global
           I64[Hp - 64] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 56] = GHC.Integer.Type.None_closure+2;
           _s3ED::I64 = _s3EB::I64 & 4294967295;
           _s3EF::I64 = _s3EA::I64 & 4294967295;
           I64[Hp - 48] = _s3EF::I64 * _s3ED::I64;
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = GHC.Integer.Type.None_closure+2;
           _s3EG::I64 = _s3EB::I64 >> 32;
           _s3EH::I64 = _s3EF::I64 * _s3EG::I64;
           I64[Hp - 24] = _s3EH::I64 & 4294967295 << 32;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           _s3EC::I64 = _s3EA::I64 >> 32;
           _s3EE::I64 = _s3EC::I64 * _s3ED::I64;
           I64[Hp] = _s3EE::I64 & 4294967295 << 32;
           I64[Sp - 48] = block_c6ah_info;
           R4 = Hp - 39;
           R3 = Hp - 15;
           R2 = 0;
           P64[Sp - 40] = Hp - 63;
           I64[Sp - 32] = _s3EC::I64;
           I64[Sp - 24] = _s3EE::I64;
           I64[Sp - 16] = _s3EG::I64;
           I64[Sp - 8] = _s3EH::I64;
           Sp = Sp - 48;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.timesDigit_info" {
     GHC.Integer.Type.timesDigit_info:
         const GHC.Integer.Type.timesDigit_entry;
         const 0;
         const 21474836494;
         const 8589934604;
         const S3Xx_srt;
 },
 _c6ah() //  [R1]
         { []
         }
     {offset
       c6ah: // global
           _c6a2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6al_info;
           R4 = _c6a2::P64;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6ah_info" {
     block_c6ah_info:
         const _c6ah;
         const 1925;
         const 4294967326;
         const S3Xx_srt;
 },
 _c6al() //  [R1]
         { []
         }
     {offset
       c6al: // global
           _s3EW::I64 = I64[Sp + 8] * I64[Sp + 24] + ((I64[Sp + 16] >> 32) + (I64[Sp + 32] >> 32));
           if (_s3EW::I64 == 0) goto c6aW; else goto u6b0;
       c6aW: // global
           R1 = R1 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u6b0: // global
           I64[Sp + 24] = _s3EW::I64;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call _c6aL() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6al_info" {
     block_c6al_info:
         const _c6al;
         const 964;
         const 4294967326;
         const S3Xx_srt;
 },
 _c6aL() //  []
         { []
         }
     {offset
       c6aL: // global
           Hp = Hp + 48;
           _s3EW::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c6aT; else goto c6aS;
       c6aT: // global
           HpAlloc = 48;
           I64[Sp] = block_c6aK_info;
           R1 = _s3EW::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c6aS: // global
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = GHC.Integer.Type.None_closure+2;
           I64[Hp - 24] = _s3EW::I64;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = 0;
           R4 = P64[Sp + 8];
           R3 = Hp - 15;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c6aK() //  [R1]
         { []
         }
     {offset
       c6aK: // global
           I64[Sp] = R1;
           call _c6aL() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6aK_info" {
     block_c6aK_info:
         const _c6aK;
         const 1;
         const 4294967326;
         const S3Xx_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.957795209 UTC

[section ""data" . GHC.Integer.Type.timesPositive_closure" {
     GHC.Integer.Type.timesPositive_closure:
         const GHC.Integer.Type.timesPositive_info;
         const 0;
 },
 GHC.Integer.Type.timesPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c6bS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6bT; else goto u6dC;
       c6bT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.timesPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6dC: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6bI() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.timesPositive_info" {
     GHC.Integer.Type.timesPositive_info:
         const GHC.Integer.Type.timesPositive_entry;
         const 0;
         const 55834574862;
         const 8589934607;
         const S3Xx_srt;
 },
 _c6bI() //  []
         { []
         }
     {offset
       c6bI: // global
           _s3EZ::P64 = P64[Sp];
           I64[Sp] = block_c6bL_info;
           R1 = _s3EZ::P64;
           if (R1 & 7 != 0) goto u6dE; else goto c6bM;
       u6dE: // global
           call _c6bL(R1) args: 0, res: 0, upd: 0;
       c6bM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6bL() //  [R1]
         { []
         }
     {offset
       c6bL: // global
           _s3F0::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6bP; else goto c6bQ;
       c6bP: // global
           I64[Sp - 16] = block_c6bX_info;
           _s3F1::P64 = R1;
           _s3F3::P64 = P64[R1 + 7];
           _s3F2::I64 = I64[R1 + 15];
           R1 = _s3F0::P64;
           P64[Sp - 8] = _s3F3::P64;
           I64[Sp] = _s3F2::I64;
           P64[Sp + 8] = _s3F1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6dF; else goto c6bZ;
       u6dF: // global
           call _c6bX(R1) args: 0, res: 0, upd: 0;
       c6bZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6bQ: // global
           I64[Sp + 8] = block_c6dr_info;
           R1 = _s3F0::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6dG; else goto c6dt;
       u6dG: // global
           call _c6dr() args: 0, res: 0, upd: 0;
       c6dt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6bL_info" {
     block_c6bL_info:
         const _c6bL;
         const 1;
         const 55834574878;
         const S3Xx_srt;
 },
 _c6bX() //  [R1]
         { []
         }
     {offset
       c6bX: // global
           if (R1 & 7 == 1) goto c6c6; else goto c6do;
       c6c6: // global
           I64[Sp - 16] = block_c6c3_info;
           _s3F4::P64 = R1;
           _s3F6::P64 = P64[R1 + 7];
           _s3F5::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s3F6::P64;
           I64[Sp] = _s3F5::I64;
           P64[Sp + 8] = _s3F4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6dI; else goto c6c7;
       u6dI: // global
           call _c6c3(R1) args: 0, res: 0, upd: 0;
       c6c7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6do: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6bX_info" {
     block_c6bX_info:
         const _c6bX;
         const 131;
         const 55834574878;
         const S3Xx_srt;
 },
 _c6c3() //  [R1]
         { []
         }
     {offset
       c6c3: // global
           _s3F6::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6ce; else goto c6d9;
       c6ce: // global
           I64[Sp + 8] = block_c6cb_info;
           _s3F7::P64 = R1;
           R1 = _s3F6::P64;
           P64[Sp + 40] = _s3F7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6dJ; else goto c6cf;
       u6dJ: // global
           call _c6cb(R1) args: 0, res: 0, upd: 0;
       c6cf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6d9: // global
           I64[Sp + 8] = block_c6d7_info;
           R1 = _s3F6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6dK; else goto c6da;
       u6dK: // global
           call _c6d7(R1) args: 0, res: 0, upd: 0;
       c6da: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6c3_info" {
     block_c6c3_info:
         const _c6c3;
         const 645;
         const 55834574878;
         const S3Xx_srt;
 },
 _c6cb() //  [R1]
         { []
         }
     {offset
       c6cb: // global
           _s3F4::P64 = P64[Sp + 16];
           _s3F7::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c6cs; else goto c6d4;
       c6cs: // global
           I64[Sp + 8] = block_c6cj_info;
           R3 = _s3F4::P64;
           R2 = _s3F7::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c6d4: // global
           _s3Fh::I64 = I64[Sp + 24];
           if (_s3Fh::I64 != 0) goto c6cM; else goto c6d0;
       c6cM: // global
           I64[Sp] = block_c6cF_info;
           R3 = _s3F4::P64;
           R2 = _s3F7::P64;
           I64[Sp + 32] = _s3Fh::I64;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c6d0: // global
           I64[Sp + 32] = block_c6cV_info;
           R3 = _s3F4::P64;
           R2 = _s3F7::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6cb_info" {
     block_c6cb_info:
         const _c6cb;
         const 324;
         const 55834574878;
         const S3Xx_srt;
 },
 _c6cj() //  [R1]
         { []
         }
     {offset
       c6cj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6cv; else goto c6cu;
       c6cv: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6cu: // global
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c6cp_info;
           R3 = P64[Sp + 8];
           R2 = Hp - 15;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6cj_info" {
     block_c6cj_info:
         const _c6cj;
         const 387;
         const 38654705694;
         const S3Xx_srt;
 },
 _c6cp() //  [R1]
         { []
         }
     {offset
       c6cp: // global
           R4 = P64[Sp + 8];
           R3 = R1;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6cp_info" {
     block_c6cp_info:
         const _c6cp;
         const 1;
         const 4294967326;
         const S3Xx_srt;
 },
 _c6cF() //  [R1]
         { []
         }
     {offset
       c6cF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6cP; else goto c6cO;
       c6cP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6cO: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           I64[Sp + 24] = block_c6cK_info;
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 32];
           P64[Sp + 32] = Hp - 15;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesDigit_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6cF_info" {
     block_c6cF_info:
         const _c6cF;
         const 964;
         const 21474836510;
         const S3Xx_srt;
 },
 _c6cK() //  [R1]
         { []
         }
     {offset
       c6cK: // global
           R4 = P64[Sp + 8];
           R3 = R1;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6cK_info" {
     block_c6cK_info:
         const _c6cK;
         const 1;
         const 4294967326;
         const S3Xx_srt;
 },
 _c6cV() //  [R1]
         { []
         }
     {offset
       c6cV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6d3; else goto c6d2;
       c6d3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6d2: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6cV_info" {
     block_c6cV_info:
         const _c6cV;
         const 0;
         const 30;
 },
 _c6d7() //  [R1]
         { []
         }
     {offset
       c6d7: // global
           if (R1 & 7 == 1) goto c6dg; else goto c6dk;
       c6dg: // global
           P64[Sp + 24] = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 32];
           Sp = Sp + 24;
           call _c6bI() args: 0, res: 0, upd: 0;
       c6dk: // global
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Integer.Type.timesDigit_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6d7_info" {
     block_c6d7_info:
         const _c6d7;
         const 324;
         const 55834574878;
         const S3Xx_srt;
 },
 _c6dr() //  []
         { []
         }
     {offset
       c6dr: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6dr_info" {
     block_c6dr_info:
         const _c6dr;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:49.989114717 UTC

[section ""data" . GHC.Integer.Type.timesInteger_closure" {
     GHC.Integer.Type.timesInteger_closure:
         const GHC.Integer.Type.timesInteger_info;
         const 0;
 },
 GHC.Integer.Type.timesInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6f0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6f1; else goto c6f2;
       c6f1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.timesInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6f2: // global
           I64[Sp - 16] = block_c6eS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6gu; else goto c6eT;
       u6gu: // global
           call _c6eS(R1) args: 0, res: 0, upd: 0;
       c6eT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.timesInteger_info" {
     GHC.Integer.Type.timesInteger_info:
         const GHC.Integer.Type.timesInteger_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S3Xx_srt+24;
 },
 _c6eS() //  [R1]
         { []
         }
     {offset
       c6eS: // global
           _s3Fr::P64 = P64[Sp + 8];
           _c6eZ::P64 = R1 & 7;
           if (_c6eZ::P64 < 3) goto u6gm; else goto c6eY;
       u6gm: // global
           if (_c6eZ::P64 < 2) goto c6eW; else goto c6eX;
       c6eW: // global
           I64[Sp] = block_c6f5_info;
           _s3Ft::P64 = P64[R1 + 7];
           R1 = _s3Fr::P64;
           P64[Sp + 8] = _s3Ft::P64;
           if (R1 & 7 != 0) goto u6gr; else goto c6f7;
       u6gr: // global
           call _c6f5(R1) args: 0, res: 0, upd: 0;
       c6f7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6eX: // global
           I64[Sp] = block_c6fE_info;
           _s3Fz::P64 = P64[R1 + 6];
           R1 = _s3Fr::P64;
           P64[Sp + 8] = _s3Fz::P64;
           if (R1 & 7 != 0) goto u6gs; else goto c6fG;
       u6gs: // global
           call _c6fE(R1) args: 0, res: 0, upd: 0;
       c6fG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6eY: // global
           I64[Sp + 8] = block_c6gd_info;
           R1 = _s3Fr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6gt; else goto c6gf;
       u6gt: // global
           call _c6gd() args: 0, res: 0, upd: 0;
       c6gf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6eS_info" {
     block_c6eS_info:
         const _c6eS;
         const 1;
         const 4294967326;
         const S3Xx_srt+24;
 },
 _c6f5() //  [R1]
         { []
         }
     {offset
       c6f5: // global
           _c6gl::P64 = R1 & 7;
           if (_c6gl::P64 < 3) goto u6gn; else goto u6gp;
       u6gn: // global
           _s3Ft::P64 = P64[Sp + 8];
           if (_c6gl::P64 < 2) goto c6fi; else goto c6fu;
       c6fi: // global
           I64[Sp + 8] = block_c6fb_info;
           R3 = P64[R1 + 7];
           R2 = _s3Ft::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c6fu: // global
           I64[Sp + 8] = block_c6fo_info;
           R3 = P64[R1 + 6];
           R2 = _s3Ft::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       u6gp: // global
           Sp = Sp + 16;
           call _c6ga() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6f5_info" {
     block_c6f5_info:
         const _c6f5;
         const 1;
         const 4294967326;
         const S3Xx_srt+24;
 },
 _c6fb() //  [R1]
         { []
         }
     {offset
       c6fb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6fl; else goto c6fk;
       c6fl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6fk: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6fb_info" {
     block_c6fb_info:
         const _c6fb;
         const 0;
         const 30;
 },
 _c6fo() //  [R1]
         { []
         }
     {offset
       c6fo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6fx; else goto c6fw;
       c6fx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6fw: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6fo_info" {
     block_c6fo_info:
         const _c6fo;
         const 0;
         const 30;
 },
 _c6fE() //  [R1]
         { []
         }
     {offset
       c6fE: // global
           _c6gk::P64 = R1 & 7;
           if (_c6gk::P64 < 3) goto u6go; else goto u6gq;
       u6go: // global
           _s3Fz::P64 = P64[Sp + 8];
           if (_c6gk::P64 < 2) goto c6fR; else goto c6g3;
       c6fR: // global
           I64[Sp + 8] = block_c6fK_info;
           R3 = P64[R1 + 7];
           R2 = _s3Fz::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c6g3: // global
           I64[Sp + 8] = block_c6fX_info;
           R3 = P64[R1 + 6];
           R2 = _s3Fz::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       u6gq: // global
           Sp = Sp + 16;
           call _c6ga() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6fE_info" {
     block_c6fE_info:
         const _c6fE;
         const 1;
         const 4294967326;
         const S3Xx_srt+24;
 },
 _c6fK() //  [R1]
         { []
         }
     {offset
       c6fK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6fU; else goto c6fT;
       c6fU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6fT: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6fK_info" {
     block_c6fK_info:
         const _c6fK;
         const 0;
         const 30;
 },
 _c6fX() //  [R1]
         { []
         }
     {offset
       c6fX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6g6; else goto c6g5;
       c6g6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6g5: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6fX_info" {
     block_c6fX_info:
         const _c6fX;
         const 0;
         const 30;
 },
 _c6ga() //  []
         { []
         }
     {offset
       c6ga: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6gd() //  []
         { []
         }
     {offset
       c6gd: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6gd_info" {
     block_c6gd_info:
         const _c6gd;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.013766385 UTC

[section ""data" . GHC.Integer.Type.twoToTheThirtytwoPositive_closure" {
     GHC.Integer.Type.twoToTheThirtytwoPositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 4294967296;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.016844589 UTC

[section ""data" . GHC.Integer.Type.twoToTheThirtytwoInteger_closure" {
     GHC.Integer.Type.twoToTheThirtytwoInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.twoToTheThirtytwoPositive_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.020585652 UTC

[section ""data" . GHC.Integer.Type.digitsMaybeZeroToInteger_closure" {
     GHC.Integer.Type.digitsMaybeZeroToInteger_closure:
         const GHC.Integer.Type.digitsMaybeZeroToInteger_info;
 },
 GHC.Integer.Type.digitsMaybeZeroToInteger_entry() //  [R2]
         { []
         }
     {offset
       c6hs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6ht; else goto c6hu;
       c6ht: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsMaybeZeroToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6hu: // global
           I64[Sp - 8] = block_c6hl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6hE; else goto c6hm;
       u6hE: // global
           call _c6hl(R1) args: 0, res: 0, upd: 0;
       c6hm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.digitsMaybeZeroToInteger_info" {
     GHC.Integer.Type.digitsMaybeZeroToInteger_info:
         const GHC.Integer.Type.digitsMaybeZeroToInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c6hl() //  [R1]
         { []
         }
     {offset
       c6hl: // global
           if (R1 & 7 == 1) goto c6hp; else goto c6hq;
       c6hp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6hA; else goto c6hz;
       c6hA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6hz: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6hq: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6hl_info" {
     block_c6hl_info:
         const _c6hl;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.033427322 UTC

[section ""data" . GHC.Integer.Type.removeZeroTails_closure" {
     GHC.Integer.Type.removeZeroTails_closure:
         const GHC.Integer.Type.removeZeroTails_info;
 },
 GHC.Integer.Type.removeZeroTails_entry() //  [R2]
         { []
         }
     {offset
       c6i3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6i4; else goto c6i5;
       c6i4: // global
           R2 = R2;
           R1 = GHC.Integer.Type.removeZeroTails_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6i5: // global
           I64[Sp - 8] = block_c6hW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6iI; else goto c6hX;
       u6iI: // global
           call _c6hW(R1) args: 0, res: 0, upd: 0;
       c6hX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.removeZeroTails_info" {
     GHC.Integer.Type.removeZeroTails_info:
         const GHC.Integer.Type.removeZeroTails_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c6hW() //  [R1]
         { []
         }
     {offset
       c6hW: // global
           if (R1 & 7 == 1) goto c6i0; else goto u6iF;
       c6i0: // global
           _s3FN::P64 = P64[R1 + 7];
           _s3FO::I64 = I64[R1 + 15];
           if (_s3FO::I64 != 0) goto c6ih; else goto c6in;
       c6ih: // global
           I64[Sp - 8] = block_c6ib_info;
           R2 = _s3FN::P64;
           I64[Sp] = _s3FO::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
       c6in: // global
           I64[Sp] = block_c6im_info;
           R2 = _s3FN::P64;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
       u6iF: // global
           Sp = Sp + 8;
           call _c6i1() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6hW_info" {
     block_c6hW_info:
         const _c6hW;
         const 0;
         const 30;
 },
 _c6ib() //  [R1]
         { []
         }
     {offset
       c6ib: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ik; else goto c6ij;
       c6ik: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ij: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6ib_info" {
     block_c6ib_info:
         const _c6ib;
         const 65;
         const 30;
 },
 _c6im() //  [R1]
         { []
         }
     {offset
       c6im: // global
           if (R1 & 7 == 1) goto c6it; else goto u6iG;
       c6it: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6iw; else goto c6iv;
       c6iw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6iv: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u6iG: // global
           Sp = Sp + 8;
           call _c6i1() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6im_info" {
     block_c6im_info:
         const _c6im;
         const 0;
         const 30;
 },
 _c6i1() //  []
         { []
         }
     {offset
       c6i1: // global
           R1 = GHC.Integer.Type.None_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.046553239 UTC

[section ""data" . GHC.Integer.Type.digitsToNegativeInteger_closure" {
     GHC.Integer.Type.digitsToNegativeInteger_closure:
         const GHC.Integer.Type.digitsToNegativeInteger_info;
 },
 GHC.Integer.Type.digitsToNegativeInteger_entry() //  [R2]
         { []
         }
     {offset
       c6jj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6jk; else goto c6jl;
       c6jk: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsToNegativeInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6jl: // global
           I64[Sp - 8] = block_c6jd_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.digitsToNegativeInteger_info" {
     GHC.Integer.Type.digitsToNegativeInteger_info:
         const GHC.Integer.Type.digitsToNegativeInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c6jd() //  [R1]
         { []
         }
     {offset
       c6jd: // global
           if (R1 & 7 == 1) goto c6jg; else goto c6jh;
       c6jg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6jr; else goto c6jq;
       c6jr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6jq: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6jh: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6jd_info" {
     block_c6jd_info:
         const _c6jd;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.05464865 UTC

[section ""data" . GHC.Integer.Type.digitsToInteger_closure" {
     GHC.Integer.Type.digitsToInteger_closure:
         const GHC.Integer.Type.digitsToInteger_info;
 },
 GHC.Integer.Type.digitsToInteger_entry() //  [R2]
         { []
         }
     {offset
       c6jR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6jS; else goto c6jT;
       c6jS: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6jT: // global
           I64[Sp - 8] = block_c6jL_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.digitsToInteger_info" {
     GHC.Integer.Type.digitsToInteger_info:
         const GHC.Integer.Type.digitsToInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c6jL() //  [R1]
         { []
         }
     {offset
       c6jL: // global
           if (R1 & 7 == 1) goto c6jO; else goto c6jP;
       c6jO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6jZ; else goto c6jY;
       c6jZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6jY: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6jP: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6jL_info" {
     block_c6jL_info:
         const _c6jL;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.064400788 UTC

[section ""data" . GHC.Integer.Type.comparePositive_closure" {
     GHC.Integer.Type.comparePositive_closure:
         const GHC.Integer.Type.comparePositive_info;
 },
 GHC.Integer.Type.comparePositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c6kq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6kr; else goto c6ks;
       c6kr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.comparePositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ks: // global
           I64[Sp - 16] = block_c6kj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6lu; else goto c6kk;
       u6lu: // global
           call _c6kj(R1) args: 0, res: 0, upd: 0;
       c6kk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.comparePositive_info" {
     GHC.Integer.Type.comparePositive_info:
         const GHC.Integer.Type.comparePositive_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6kj() //  [R1]
         { []
         }
     {offset
       c6kj: // global
           _s3G2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6kn; else goto c6ko;
       c6kn: // global
           I64[Sp - 8] = block_c6kv_info;
           _s3G5::P64 = P64[R1 + 7];
           _s3G4::I64 = I64[R1 + 15];
           R1 = _s3G2::P64;
           P64[Sp] = _s3G5::P64;
           I64[Sp + 8] = _s3G4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6ls; else goto c6kx;
       u6ls: // global
           call _c6kv(R1) args: 0, res: 0, upd: 0;
       c6kx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6ko: // global
           I64[Sp + 8] = block_c6l6_info;
           R1 = _s3G2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6lt; else goto c6l8;
       u6lt: // global
           call _c6l6(R1) args: 0, res: 0, upd: 0;
       c6l8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6kj_info" {
     block_c6kj_info:
         const _c6kj;
         const 1;
         const 30;
 },
 _c6kv() //  [R1]
         { []
         }
     {offset
       c6kv: // global
           if (R1 & 7 == 1) goto c6kE; else goto u6lo;
       c6kE: // global
           I64[Sp] = block_c6kB_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u6lo: // global
           Sp = Sp + 24;
           call _c6l3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6kv_info" {
     block_c6kv_info:
         const _c6kv;
         const 130;
         const 30;
 },
 _c6kB() //  [R1]
         { []
         }
     {offset
       c6kB: // global
           if (R1 & 7 == 2) goto c6kZ; else goto c6kK;
       c6kZ: // global
           _s3G4::I64 = I64[Sp + 16];
           _s3G7::I64 = I64[Sp + 8];
           if (_s3G4::I64 >= _s3G7::I64) goto c6kX; else goto u6lp;
       c6kX: // global
           if (_s3G4::I64 <= _s3G7::I64) goto u6lr; else goto u6lq;
       u6lr: // global
           Sp = Sp + 24;
           call _c6li() args: 0, res: 0, upd: 0;
       u6lq: // global
           Sp = Sp + 24;
           call _c6l3() args: 0, res: 0, upd: 0;
       u6lp: // global
           Sp = Sp + 24;
           call _c6le() args: 0, res: 0, upd: 0;
       c6kK: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6kB_info" {
     block_c6kB_info:
         const _c6kB;
         const 194;
         const 30;
 },
 _c6l3() //  []
         { []
         }
     {offset
       c6l3: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6l6() //  [R1]
         { []
         }
     {offset
       c6l6: // global
           if (R1 & 7 == 1) goto u6lm; else goto u6ln;
       u6lm: // global
           Sp = Sp + 8;
           call _c6le() args: 0, res: 0, upd: 0;
       u6ln: // global
           Sp = Sp + 8;
           call _c6li() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6l6_info" {
     block_c6l6_info:
         const _c6l6;
         const 0;
         const 30;
 },
 _c6le() //  []
         { []
         }
     {offset
       c6le: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6li() //  []
         { []
         }
     {offset
       c6li: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.089884765 UTC

[section ""data" . GHC.Integer.Type.compareInteger_closure" {
     GHC.Integer.Type.compareInteger_closure:
         const GHC.Integer.Type.compareInteger_info;
 },
 GHC.Integer.Type.compareInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6mr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ms; else goto c6mt;
       c6ms: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.compareInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6mt: // global
           I64[Sp - 16] = block_c6mj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6nt; else goto c6mk;
       u6nt: // global
           call _c6mj(R1) args: 0, res: 0, upd: 0;
       c6mk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.compareInteger_info" {
     GHC.Integer.Type.compareInteger_info:
         const GHC.Integer.Type.compareInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6mj() //  [R1]
         { []
         }
     {offset
       c6mj: // global
           _s3Gg::P64 = P64[Sp + 8];
           _c6mq::P64 = R1 & 7;
           if (_c6mq::P64 < 3) goto u6nk; else goto c6mp;
       u6nk: // global
           if (_c6mq::P64 < 2) goto c6mn; else goto c6mo;
       c6mn: // global
           I64[Sp] = block_c6mw_info;
           _s3Gi::P64 = P64[R1 + 7];
           R1 = _s3Gg::P64;
           P64[Sp + 8] = _s3Gi::P64;
           if (R1 & 7 != 0) goto u6nq; else goto c6my;
       u6nq: // global
           call _c6mw(R1) args: 0, res: 0, upd: 0;
       c6my: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6mo: // global
           I64[Sp] = block_c6mL_info;
           _s3Gl::P64 = P64[R1 + 6];
           R1 = _s3Gg::P64;
           P64[Sp + 8] = _s3Gl::P64;
           if (R1 & 7 != 0) goto u6nr; else goto c6mN;
       u6nr: // global
           call _c6mL(R1) args: 0, res: 0, upd: 0;
       c6mN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6mp: // global
           I64[Sp + 8] = block_c6n0_info;
           R1 = _s3Gg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6ns; else goto c6n2;
       u6ns: // global
           call _c6n0(R1) args: 0, res: 0, upd: 0;
       c6n2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6mj_info" {
     block_c6mj_info:
         const _c6mj;
         const 1;
         const 30;
 },
 _c6mw() //  [R1]
         { []
         }
     {offset
       c6mw: // global
           if (R1 & 7 == 1) goto c6mI; else goto u6nm;
       c6mI: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       u6nm: // global
           Sp = Sp + 16;
           call _c6nc() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6mw_info" {
     block_c6mw_info:
         const _c6mw;
         const 1;
         const 30;
 },
 _c6mL() //  [R1]
         { []
         }
     {offset
       c6mL: // global
           if (R1 & 7 == 2) goto c6mX; else goto u6nn;
       c6mX: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       u6nn: // global
           Sp = Sp + 16;
           call _c6n8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6mL_info" {
     block_c6mL_info:
         const _c6mL;
         const 1;
         const 30;
 },
 _c6n0() //  [R1]
         { []
         }
     {offset
       c6n0: // global
           _c6nh::P64 = R1 & 7;
           if (_c6nh::P64 < 3) goto u6nl; else goto c6ng;
       u6nl: // global
           if (_c6nh::P64 < 2) goto u6np; else goto u6no;
       u6np: // global
           Sp = Sp + 8;
           call _c6n8() args: 0, res: 0, upd: 0;
       u6no: // global
           Sp = Sp + 8;
           call _c6nc() args: 0, res: 0, upd: 0;
       c6ng: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6n0_info" {
     block_c6n0_info:
         const _c6n0;
         const 0;
         const 30;
 },
 _c6n8() //  []
         { []
         }
     {offset
       c6n8: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6nc() //  []
         { []
         }
     {offset
       c6nc: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.111651323 UTC

[section ""data" . GHC.Integer.Type.eqInteger#_closure" {
     GHC.Integer.Type.eqInteger#_closure:
         const GHC.Integer.Type.eqInteger#_info;
 },
 GHC.Integer.Type.eqInteger#_entry() //  [R2, R3]
         { []
         }
     {offset
       c6og: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6oh; else goto c6oi;
       c6oh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.eqInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6oi: // global
           I64[Sp - 8] = block_c6oa_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.eqInteger#_info" {
     GHC.Integer.Type.eqInteger#_info:
         const GHC.Integer.Type.eqInteger#_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6oa() //  [R1]
         { []
         }
     {offset
       c6oa: // global
           if (R1 & 7 == 2) goto c6oe; else goto c6od;
       c6oe: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6od: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6oa_info" {
     block_c6oa_info:
         const _c6oa;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.120749762 UTC

[section ""data" . GHC.Integer.Type.eqInteger_closure" {
     GHC.Integer.Type.eqInteger_closure:
         const GHC.Integer.Type.eqInteger_info;
 },
 GHC.Integer.Type.eqInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6oH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6oI; else goto c6oJ;
       c6oI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.eqInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6oJ: // global
           I64[Sp - 8] = block_c6oF_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.eqInteger_info" {
     GHC.Integer.Type.eqInteger_info:
         const GHC.Integer.Type.eqInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6oF() //  [R1]
         { []
         }
     {offset
       c6oF: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6oF_info" {
     block_c6oF_info:
         const _c6oF;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.129519201 UTC

[section ""data" . GHC.Integer.Type.neqInteger#_closure" {
     GHC.Integer.Type.neqInteger#_closure:
         const GHC.Integer.Type.neqInteger#_info;
 },
 GHC.Integer.Type.neqInteger#_entry() //  [R2, R3]
         { []
         }
     {offset
       c6p7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6p8; else goto c6p9;
       c6p8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.neqInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6p9: // global
           I64[Sp - 8] = block_c6p1_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.neqInteger#_info" {
     GHC.Integer.Type.neqInteger#_info:
         const GHC.Integer.Type.neqInteger#_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6p1() //  [R1]
         { []
         }
     {offset
       c6p1: // global
           if (R1 & 7 == 2) goto c6p5; else goto c6p4;
       c6p5: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6p4: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6p1_info" {
     block_c6p1_info:
         const _c6p1;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.196408456 UTC

[section ""data" . GHC.Integer.Type.neqInteger_closure" {
     GHC.Integer.Type.neqInteger_closure:
         const GHC.Integer.Type.neqInteger_info;
 },
 GHC.Integer.Type.neqInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6py: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6pz; else goto c6pA;
       c6pz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.neqInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6pA: // global
           I64[Sp - 8] = block_c6pw_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.neqInteger_info" {
     GHC.Integer.Type.neqInteger_info:
         const GHC.Integer.Type.neqInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6pw() //  [R1]
         { []
         }
     {offset
       c6pw: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6pw_info" {
     block_c6pw_info:
         const _c6pw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.206241329 UTC

[section ""data" . GHC.Integer.Type.$fEqInteger_closure" {
     GHC.Integer.Type.$fEqInteger_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.210793161 UTC

[section ""data" . GHC.Integer.Type.ltInteger#_closure" {
     GHC.Integer.Type.ltInteger#_closure:
         const GHC.Integer.Type.ltInteger#_info;
 },
 GHC.Integer.Type.ltInteger#_entry() //  [R2, R3]
         { []
         }
     {offset
       c6pZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6q0; else goto c6q1;
       c6q0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.ltInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6q1: // global
           I64[Sp - 8] = block_c6pT_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.ltInteger#_info" {
     GHC.Integer.Type.ltInteger#_info:
         const GHC.Integer.Type.ltInteger#_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6pT() //  [R1]
         { []
         }
     {offset
       c6pT: // global
           if (R1 & 7 == 1) goto c6pX; else goto c6pW;
       c6pX: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6pW: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6pT_info" {
     block_c6pT_info:
         const _c6pT;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.218410459 UTC

[section ""data" . GHC.Integer.Type.ltInteger_closure" {
     GHC.Integer.Type.ltInteger_closure:
         const GHC.Integer.Type.ltInteger_info;
 },
 GHC.Integer.Type.ltInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6qq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6qr; else goto c6qs;
       c6qr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.ltInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6qs: // global
           I64[Sp - 8] = block_c6qo_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.ltInteger_info" {
     GHC.Integer.Type.ltInteger_info:
         const GHC.Integer.Type.ltInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6qo() //  [R1]
         { []
         }
     {offset
       c6qo: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6qo_info" {
     block_c6qo_info:
         const _c6qo;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.226270774 UTC

[section ""data" . GHC.Integer.Type.gtInteger#_closure" {
     GHC.Integer.Type.gtInteger#_closure:
         const GHC.Integer.Type.gtInteger#_info;
 },
 GHC.Integer.Type.gtInteger#_entry() //  [R2, R3]
         { []
         }
     {offset
       c6qQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6qR; else goto c6qS;
       c6qR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.gtInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6qS: // global
           I64[Sp - 8] = block_c6qK_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.gtInteger#_info" {
     GHC.Integer.Type.gtInteger#_info:
         const GHC.Integer.Type.gtInteger#_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6qK() //  [R1]
         { []
         }
     {offset
       c6qK: // global
           if (R1 & 7 == 3) goto c6qO; else goto c6qN;
       c6qO: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6qN: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6qK_info" {
     block_c6qK_info:
         const _c6qK;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.234191327 UTC

[section ""data" . GHC.Integer.Type.gtInteger_closure" {
     GHC.Integer.Type.gtInteger_closure:
         const GHC.Integer.Type.gtInteger_info;
 },
 GHC.Integer.Type.gtInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6rh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6ri; else goto c6rj;
       c6ri: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.gtInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6rj: // global
           I64[Sp - 8] = block_c6rf_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.gtInteger_info" {
     GHC.Integer.Type.gtInteger_info:
         const GHC.Integer.Type.gtInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6rf() //  [R1]
         { []
         }
     {offset
       c6rf: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6rf_info" {
     block_c6rf_info:
         const _c6rf;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.241117782 UTC

[section ""data" . GHC.Integer.Type.leInteger#_closure" {
     GHC.Integer.Type.leInteger#_closure:
         const GHC.Integer.Type.leInteger#_info;
 },
 GHC.Integer.Type.leInteger#_entry() //  [R2, R3]
         { []
         }
     {offset
       c6rH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6rI; else goto c6rJ;
       c6rI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.leInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6rJ: // global
           I64[Sp - 8] = block_c6rB_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.leInteger#_info" {
     GHC.Integer.Type.leInteger#_info:
         const GHC.Integer.Type.leInteger#_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6rB() //  [R1]
         { []
         }
     {offset
       c6rB: // global
           if (R1 & 7 == 3) goto c6rF; else goto c6rE;
       c6rF: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6rE: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6rB_info" {
     block_c6rB_info:
         const _c6rB;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.249137281 UTC

[section ""data" . GHC.Integer.Type.leInteger_closure" {
     GHC.Integer.Type.leInteger_closure:
         const GHC.Integer.Type.leInteger_info;
 },
 GHC.Integer.Type.leInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6s8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6s9; else goto c6sa;
       c6s9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.leInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6sa: // global
           I64[Sp - 8] = block_c6s6_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.leInteger_info" {
     GHC.Integer.Type.leInteger_info:
         const GHC.Integer.Type.leInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6s6() //  [R1]
         { []
         }
     {offset
       c6s6: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6s6_info" {
     block_c6s6_info:
         const _c6s6;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.256916658 UTC

[section ""data" . GHC.Integer.Type.geInteger#_closure" {
     GHC.Integer.Type.geInteger#_closure:
         const GHC.Integer.Type.geInteger#_info;
 },
 GHC.Integer.Type.geInteger#_entry() //  [R2, R3]
         { []
         }
     {offset
       c6sy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6sz; else goto c6sA;
       c6sz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.geInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6sA: // global
           I64[Sp - 8] = block_c6ss_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.geInteger#_info" {
     GHC.Integer.Type.geInteger#_info:
         const GHC.Integer.Type.geInteger#_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6ss() //  [R1]
         { []
         }
     {offset
       c6ss: // global
           if (R1 & 7 == 1) goto c6sw; else goto c6sv;
       c6sw: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6sv: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6ss_info" {
     block_c6ss_info:
         const _c6ss;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.263281702 UTC

[section ""data" . GHC.Integer.Type.geInteger_closure" {
     GHC.Integer.Type.geInteger_closure:
         const GHC.Integer.Type.geInteger_info;
 },
 GHC.Integer.Type.geInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6sZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6t0; else goto c6t1;
       c6t0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.geInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6t1: // global
           I64[Sp - 8] = block_c6sX_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.geInteger_info" {
     GHC.Integer.Type.geInteger_info:
         const GHC.Integer.Type.geInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6sX() //  [R1]
         { []
         }
     {offset
       c6sX: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6sX_info" {
     block_c6sX_info:
         const _c6sX;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.270961042 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_$cmax_closure" {
     GHC.Integer.Type.$fOrdInteger_$cmax_closure:
         const GHC.Integer.Type.$fOrdInteger_$cmax_info;
 },
 GHC.Integer.Type.$fOrdInteger_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c6to: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6tp; else goto c6tq;
       c6tp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$fOrdInteger_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6tq: // global
           I64[Sp - 24] = block_c6tj_info;
           _s3H2::P64 = R3;
           R3 = R3;
           _s3H1::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s3H1::P64;
           P64[Sp - 8] = _s3H2::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.$fOrdInteger_$cmax_info" {
     GHC.Integer.Type.$fOrdInteger_$cmax_info:
         const GHC.Integer.Type.$fOrdInteger_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6tj() //  [R1]
         { []
         }
     {offset
       c6tj: // global
           if (R1 == 1) goto c6tn; else goto c6tm;
       c6tn: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6tm: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6tj_info" {
     block_c6tj_info:
         const _c6tj;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.278455475 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_$cmin_closure" {
     GHC.Integer.Type.$fOrdInteger_$cmin_closure:
         const GHC.Integer.Type.$fOrdInteger_$cmin_info;
 },
 GHC.Integer.Type.$fOrdInteger_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c6tS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6tT; else goto c6tU;
       c6tT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$fOrdInteger_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6tU: // global
           I64[Sp - 24] = block_c6tN_info;
           _s3H5::P64 = R3;
           R3 = R3;
           _s3H4::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s3H4::P64;
           P64[Sp - 8] = _s3H5::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.$fOrdInteger_$cmin_info" {
     GHC.Integer.Type.$fOrdInteger_$cmin_info:
         const GHC.Integer.Type.$fOrdInteger_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6tN() //  [R1]
         { []
         }
     {offset
       c6tN: // global
           if (R1 == 1) goto c6tR; else goto c6tQ;
       c6tR: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6tQ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6tN_info" {
     block_c6tN_info:
         const _c6tN;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.285762715 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_closure" {
     GHC.Integer.Type.$fOrdInteger_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Integer.Type.$fEqInteger_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.294804589 UTC

[section ""data" . GHC.Integer.Type.plusInteger_closure" {
     GHC.Integer.Type.plusInteger_closure:
         const GHC.Integer.Type.plusInteger_info;
         const 0;
 },
 GHC.Integer.Type.plusInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6uq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6ur; else goto u6w0;
       c6ur: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.plusInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6w0: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6uf() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.plusInteger_info" {
     GHC.Integer.Type.plusInteger_info:
         const GHC.Integer.Type.plusInteger_entry;
         const 0;
         const 141733920782;
         const 8589934607;
         const S3Xx_srt;
 },
 _c6uf() //  []
         { []
         }
     {offset
       c6uf: // global
           _s3H7::P64 = P64[Sp];
           I64[Sp] = block_c6ui_info;
           R1 = _s3H7::P64;
           if (R1 & 7 != 0) goto u6w4; else goto c6uj;
       u6w4: // global
           call _c6ui(R1) args: 0, res: 0, upd: 0;
       c6uj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ui() //  [R1]
         { []
         }
     {offset
       c6ui: // global
           _s3H8::P64 = P64[Sp + 8];
           _c6up::P64 = R1 & 7;
           if (_c6up::P64 < 3) goto u6vW; else goto c6uo;
       u6vW: // global
           if (_c6up::P64 < 2) goto c6um; else goto c6un;
       c6um: // global
           I64[Sp - 8] = block_c6uv_info;
           _s3H9::P64 = R1;
           _s3Ha::P64 = P64[R1 + 7];
           R1 = _s3H8::P64;
           P64[Sp] = _s3Ha::P64;
           P64[Sp + 8] = _s3H9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6w5; else goto c6ux;
       u6w5: // global
           call _c6uv(R1) args: 0, res: 0, upd: 0;
       c6ux: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6un: // global
           I64[Sp - 8] = block_c6vr_info;
           _s3H9::P64 = R1;
           _s3Hi::P64 = P64[R1 + 6];
           R1 = _s3H8::P64;
           P64[Sp] = _s3Hi::P64;
           P64[Sp + 8] = _s3H9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6w6; else goto c6vt;
       u6w6: // global
           call _c6vr(R1) args: 0, res: 0, upd: 0;
       c6vt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6uo: // global
           R1 = _s3H8::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6ui_info" {
     block_c6ui_info:
         const _c6ui;
         const 1;
         const 4294967326;
         const S3Xx_srt;
 },
 _c6uv() //  [R1]
         { []
         }
     {offset
       c6uv: // global
           _c6vU::P64 = R1 & 7;
           if (_c6vU::P64 < 3) goto u6vX; else goto u6w1;
       u6vX: // global
           _s3Ha::P64 = P64[Sp + 8];
           if (_c6vU::P64 < 2) goto c6uI; else goto c6uQ;
       c6uI: // global
           I64[Sp + 16] = block_c6uB_info;
           R4 = P64[R1 + 7];
           R3 = _s3Ha::P64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c6uQ: // global
           I64[Sp] = block_c6uO_info;
           _s3He::P64 = P64[R1 + 6];
           R3 = _s3He::P64;
           R2 = _s3Ha::P64;
           P64[Sp + 16] = _s3He::P64;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u6w1: // global
           Sp = Sp + 16;
           call _c6vP() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6uv_info" {
     block_c6uv_info:
         const _c6uv;
         const 2;
         const 4294967326;
         const S3Xx_srt;
 },
 _c6uB() //  [R1]
         { []
         }
     {offset
       c6uB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6uL; else goto c6uK;
       c6uL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6uK: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6uB_info" {
     block_c6uB_info:
         const _c6uB;
         const 0;
         const 30;
 },
 _c6uO() //  [R1]
         { []
         }
     {offset
       c6uO: // global
           _s3Ha::P64 = P64[Sp + 8];
           _s3He::P64 = P64[Sp + 16];
           _c6vV::P64 = R1 & 7;
           if (_c6vV::P64 < 3) goto u6vY; else goto c6vh;
       u6vY: // global
           if (_c6vV::P64 < 2) goto c6v1; else goto c6v8;
       c6v1: // global
           I64[Sp + 16] = block_c6uU_info;
           R3 = _s3Ha::P64;
           R2 = _s3He::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c6v8: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6vh: // global
           I64[Sp + 16] = block_c6vb_info;
           R3 = _s3He::P64;
           R2 = _s3Ha::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6uO_info" {
     block_c6uO_info:
         const _c6uO;
         const 2;
         const 30;
 },
 _c6uU() //  [R1]
         { []
         }
     {offset
       c6uU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6v4; else goto c6v3;
       c6v4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6v3: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6uU_info" {
     block_c6uU_info:
         const _c6uU;
         const 0;
         const 30;
 },
 _c6vb() //  [R1]
         { []
         }
     {offset
       c6vb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vk; else goto c6vj;
       c6vk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vj: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6vb_info" {
     block_c6vb_info:
         const _c6vb;
         const 0;
         const 30;
 },
 _c6vr() //  [R1]
         { []
         }
     {offset
       c6vr: // global
           _c6vT::P64 = R1 & 7;
           if (_c6vT::P64 < 3) goto u6vZ; else goto u6w2;
       u6vZ: // global
           if (_c6vT::P64 < 2) goto c6vz; else goto c6vI;
       c6vz: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c6uf() args: 0, res: 0, upd: 0;
       c6vI: // global
           I64[Sp + 16] = block_c6vC_info;
           R4 = P64[R1 + 6];
           R3 = P64[Sp + 8];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       u6w2: // global
           Sp = Sp + 16;
           call _c6vP() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6vr_info" {
     block_c6vr_info:
         const _c6vr;
         const 2;
         const 4294967326;
         const S3Xx_srt;
 },
 _c6vC() //  [R1]
         { []
         }
     {offset
       c6vC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vL; else goto c6vK;
       c6vL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vK: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6vC_info" {
     block_c6vC_info:
         const _c6vC;
         const 0;
         const 30;
 },
 _c6vP() //  []
         { []
         }
     {offset
       c6vP: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.321783319 UTC

[section ""data" . GHC.Integer.Type.minusInteger_closure" {
     GHC.Integer.Type.minusInteger_closure:
         const GHC.Integer.Type.minusInteger_info;
         const 0;
 },
 GHC.Integer.Type.minusInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6x5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x6; else goto c6x7;
       c6x6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.minusInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6x7: // global
           I64[Sp - 16] = block_c6x3_info;
           _s3Hn::P64 = R2;
           R2 = R3;
           P64[Sp - 8] = _s3Hn::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.minusInteger_info" {
     GHC.Integer.Type.minusInteger_info:
         const GHC.Integer.Type.minusInteger_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S3Xx_srt+40;
 },
 _c6x3() //  [R1]
         { []
         }
     {offset
       c6x3: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6x3_info" {
     block_c6x3_info:
         const _c6x3;
         const 1;
         const 4294967326;
         const S3Xx_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.328273323 UTC

[section ""data" . GHC.Integer.Type.complementInteger_closure" {
     GHC.Integer.Type.complementInteger_closure:
         const GHC.Integer.Type.complementInteger_info;
         const 0;
 },
 GHC.Integer.Type.complementInteger_entry() //  [R2]
         { []
         }
     {offset
       c6xn: // global
           R3 = R2;
           R2 = GHC.Integer.Type.negativeOneInteger_closure+2;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.complementInteger_info" {
     GHC.Integer.Type.complementInteger_info:
         const GHC.Integer.Type.complementInteger_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S3Xx_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.335297784 UTC

[section ""data" . GHC.Integer.Type.decodeDoubleInteger_closure" {
     GHC.Integer.Type.decodeDoubleInteger_closure:
         const GHC.Integer.Type.decodeDoubleInteger_info;
         const 0;
 },
 sat_s3HC_entry() //  [R1]
         { []
         }
     {offset
       c6xI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6xY; else goto c6xZ;
       c6xY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c6xG_info;
           R2 = I64[R1 + 32];
           I64[Sp - 32] = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3HC_info" {
     sat_s3HC_info:
         const sat_s3HC_entry;
         const 12884901888;
         const 12884901903;
         const S3Xx_srt+32;
 },
 _c6xG() //  [R1]
         { []
         }
     {offset
       c6xG: // global
           I64[Sp] = block_c6xL_info;
           R2 = I64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_c6xG_info" {
     block_c6xG_info:
         const _c6xG;
         const 194;
         const 12884901918;
         const S3Xx_srt+32;
 },
 _c6xL() //  [R1]
         { []
         }
     {offset
       c6xL: // global
           I64[Sp] = block_c6xP_info;
           R3 = GHC.Integer.Type.twoToTheThirtytwoInteger_closure+1;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_c6xL_info" {
     block_c6xL_info:
         const _c6xL;
         const 66;
         const 12884901918;
         const S3Xx_srt+32;
 },
 _c6xP() //  [R1]
         { []
         }
     {offset
       c6xP: // global
           I64[Sp] = block_c6xT_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_c6xP_info" {
     block_c6xP_info:
         const _c6xP;
         const 66;
         const 12884901918;
         const S3Xx_srt+32;
 },
 _c6xT() //  [R1]
         { []
         }
     {offset
       c6xT: // global
           _s3Ht::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c6xX_info;
           R2 = _s3Ht::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_c6xT_info" {
     block_c6xT_info:
         const _c6xT;
         const 194;
         const 4294967326;
         const S3Xx_srt+32;
 },
 _c6xX() //  [R1]
         { []
         }
     {offset
       c6xX: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c6xX_info" {
     block_c6xX_info:
         const _c6xX;
         const 1;
         const 4294967326;
         const S3Xx_srt+32;
 },
 GHC.Integer.Type.decodeDoubleInteger_entry() //  [D1]
         { []
         }
     {offset
       c6y8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6y9; else goto c6ya;
       c6y9: // global
           D1 = D1;
           R1 = GHC.Integer.Type.decodeDoubleInteger_closure;
           call (stg_gc_fun)(D1, R1) args: 8, res: 0, upd: 8;
       c6ya: // global
           I64[Sp - 8] = block_c6xy_info;
           D1 = D1;
           Sp = Sp - 8;
           call stg_decodeDouble_2Int#(D1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.decodeDoubleInteger_info" {
     GHC.Integer.Type.decodeDoubleInteger_info:
         const GHC.Integer.Type.decodeDoubleInteger_entry;
         const 0;
         const 47244640270;
         const 4294967303;
         const S3Xx_srt+32;
 },
 _c6xy() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       c6xy: // global
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           I64[Sp] = R1;
           Sp = Sp - 32;
           call _c6xz() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6xy_info" {
     block_c6xy_info:
         const _c6xy;
         const 0;
         const 12884901918;
         const S3Xx_srt+32;
 },
 _c6xz() //  []
         { []
         }
     {offset
       c6xz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6yd; else goto c6yc;
       c6yd: // global
           HpAlloc = 40;
           I64[Sp] = block_c6xz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c6yc: // global
           I64[Hp - 32] = sat_s3HC_info;
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = I64[Sp + 24];
           R1 = Hp - 32;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6xz_info" {
     block_c6xz_info:
         const _c6xz;
         const 964;
         const 12884901918;
         const S3Xx_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.359968726 UTC

[section ""data" . GHC.Integer.Type.smallShiftLPositive_closure" {
     GHC.Integer.Type.smallShiftLPositive_closure:
         const GHC.Integer.Type.smallShiftLPositive_info;
 },
 f2_s3HH_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c6zb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6zc; else goto c6zd;
       c6zc: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zd: // global
           I64[Sp - 40] = block_c6z4_info;
           _s3HH::P64 = R1;
           _s3HF::I64 = I64[R1 + 6];
           _s3HG::I64 = I64[R1 + 14];
           R1 = R3;
           I64[Sp - 32] = _s3HF::I64;
           I64[Sp - 24] = _s3HG::I64;
           P64[Sp - 16] = _s3HH::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u6zJ; else goto c6z5;
       u6zJ: // global
           call _c6z4(R1) args: 0, res: 0, upd: 0;
       c6z5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . f2_s3HH_info" {
     f2_s3HH_info:
         const f2_s3HH_entry;
         const 8589934592;
         const 13;
         const 8589934605;
 },
 _c6z4() //  [R1]
         { []
         }
     {offset
       c6z4: // global
           if (R1 & 7 == 1) goto c6z8; else goto c6z9;
       c6z8: // global
           I64[Sp] = block_c6zj_info;
           R3 = P64[R1 + 7];
           _s3HL::I64 = I64[R1 + 15];
           R2 = _s3HL::I64 >> I64[Sp + 16];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s3HL::I64;
           call f2_s3HH_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
       c6z9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zC; else goto c6zB;
       c6zC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zB: // global
           _s3HR::I64 = I64[Sp + 32];
           if (_s3HR::I64 != 0) goto c6zH; else goto c6zI;
       c6zH: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s3HR::I64;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6zI: // global
           Hp = Hp - 24;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6z4_info" {
     block_c6z4_info:
         const _c6z4;
         const 708;
         const 30;
 },
 _c6zj() //  [R1]
         { []
         }
     {offset
       c6zj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zx; else goto c6zw;
       c6zx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zw: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = (I64[Sp + 24] << I64[Sp + 8]) | I64[Sp + 32];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6zj_info" {
     block_c6zj_info:
         const _c6zj;
         const 964;
         const 30;
 },
 GHC.Integer.Type.smallShiftLPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c6zN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zR; else goto c6zQ;
       c6zR: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.smallShiftLPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zQ: // global
           if (R3 == 0) goto c6zM; else goto c6zL;
       c6zM: // global
           Hp = Hp - 24;
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6zL: // global
           I64[Hp - 16] = f2_s3HH_info;
           I64[Hp - 8] = R3;
           I64[Hp] = 64 - R3;
           R3 = R2;
           R2 = 0;
           R1 = Hp - 14;
           call f2_s3HH_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.smallShiftLPositive_info" {
     GHC.Integer.Type.smallShiftLPositive_info:
         const GHC.Integer.Type.smallShiftLPositive_entry;
         const 0;
         const 14;
         const 8589934606;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.374169047 UTC

[section ""data" . GHC.Integer.Type.smallShiftRPositive_closure" {
     GHC.Integer.Type.smallShiftRPositive_closure:
         const GHC.Integer.Type.smallShiftRPositive_info;
 },
 GHC.Integer.Type.smallShiftRPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c6Ar: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6As; else goto c6At;
       c6As: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.smallShiftRPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6At: // global
           I64[Sp - 16] = block_c6Ao_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Bd; else goto c6Ap;
       u6Bd: // global
           call _c6Ao(R1) args: 0, res: 0, upd: 0;
       c6Ap: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.smallShiftRPositive_info" {
     GHC.Integer.Type.smallShiftRPositive_info:
         const GHC.Integer.Type.smallShiftRPositive_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c6Ao() //  [R1]
         { []
         }
     {offset
       c6Ao: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Ay; else goto c6Ax;
       c6Ay: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Ax: // global
           _s3HV::I64 = I64[Sp + 8];
           if (_s3HV::I64 == 0) goto c6B8; else goto c6AG;
       c6B8: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6AG: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_c6AE_info;
           R3 = 64 - _s3HV::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Ao_info" {
     block_c6Ao_info:
         const _c6Ao;
         const 65;
         const 30;
 },
 _c6AE() //  [R1]
         { []
         }
     {offset
       c6AE: // global
           if (R1 & 7 == 1) goto c6AN; else goto u6Bb;
       c6AN: // global
           I64[Sp] = block_c6AK_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u6Be; else goto c6AO;
       u6Be: // global
           call _c6AK(R1) args: 0, res: 0, upd: 0;
       c6AO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u6Bb: // global
           Sp = Sp + 8;
           call _c6B5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6AE_info" {
     block_c6AE_info:
         const _c6AE;
         const 0;
         const 30;
 },
 _c6AK() //  [R1]
         { []
         }
     {offset
       c6AK: // global
           if (R1 & 7 == 1) goto c6AU; else goto u6Bc;
       c6AU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6AX; else goto c6AW;
       c6AX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AW: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u6Bc: // global
           Sp = Sp + 8;
           call _c6B5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6AK_info" {
     block_c6AK_info:
         const _c6AK;
         const 0;
         const 30;
 },
 _c6B5() //  []
         { []
         }
     {offset
       c6B5: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.38884837 UTC

[section ""data" . GHC.Integer.Type.shiftRPositive_closure" {
     GHC.Integer.Type.shiftRPositive_closure:
         const GHC.Integer.Type.shiftRPositive_info;
 },
 GHC.Integer.Type.shiftRPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c6BS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BT; else goto u6C9;
       c6BT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftRPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6C9: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6BI() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.shiftRPositive_info" {
     GHC.Integer.Type.shiftRPositive_info:
         const GHC.Integer.Type.shiftRPositive_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c6BI() //  []
         { []
         }
     {offset
       c6BI: // global
           _s3I3::P64 = P64[Sp];
           I64[Sp] = block_c6BL_info;
           R1 = _s3I3::P64;
           if (R1 & 7 != 0) goto u6Cb; else goto c6BM;
       u6Cb: // global
           call _c6BL(R1) args: 0, res: 0, upd: 0;
       c6BM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6BL() //  [R1]
         { []
         }
     {offset
       c6BL: // global
           if (R1 & 7 == 1) goto c6BP; else goto c6BQ;
       c6BP: // global
           _s3I4::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s3I4::I64, 64)) goto c6C1; else goto c6C2;
       c6C1: // global
           R3 = _s3I4::I64;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallShiftRPositive_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       c6C2: // global
           P64[Sp] = P64[R1 + 7];
           I64[Sp + 8] = _s3I4::I64 - 64;
           call _c6BI() args: 0, res: 0, upd: 0;
       c6BQ: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6BL_info" {
     block_c6BL_info:
         const _c6BL;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.401214221 UTC

[section ""data" . GHC.Integer.Type.shiftRInteger_closure" {
     GHC.Integer.Type.shiftRInteger_closure:
         const GHC.Integer.Type.shiftRInteger_info;
         const 0;
 },
 GHC.Integer.Type.shiftRInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6CG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CH; else goto c6CI;
       c6CH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftRInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CI: // global
           I64[Sp - 16] = block_c6Cy_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6D3; else goto c6Cz;
       u6D3: // global
           call _c6Cy(R1) args: 0, res: 0, upd: 0;
       c6Cz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.shiftRInteger_info" {
     GHC.Integer.Type.shiftRInteger_info:
         const GHC.Integer.Type.shiftRInteger_entry;
         const 0;
         const 12884901902;
         const 8589934606;
         const S3Xx_srt+64;
 },
 _c6Cy() //  [R1]
         { []
         }
     {offset
       c6Cy: // global
           _c6CF::P64 = R1 & 7;
           if (_c6CF::P64 < 3) goto u6D2; else goto c6CE;
       u6D2: // global
           if (_c6CF::P64 < 2) goto c6CC; else goto c6CD;
       c6CC: // global
           R3 = I64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRPositive_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
       c6CD: // global
           I64[Sp] = block_c6CO_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
       c6CE: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Cy_info" {
     block_c6Cy_info:
         const _c6Cy;
         const 65;
         const 12884901918;
         const S3Xx_srt+64;
 },
 _c6CO() //  [R1]
         { []
         }
     {offset
       c6CO: // global
           _s3Ib::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c6CS_info;
           R3 = _s3Ib::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6CO_info" {
     block_c6CO_info:
         const _c6CO;
         const 65;
         const 12884901918;
         const S3Xx_srt+64;
 },
 _c6CS() //  [R1]
         { []
         }
     {offset
       c6CS: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6CS_info" {
     block_c6CS_info:
         const _c6CS;
         const 0;
         const 4294967326;
         const S3Xx_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.414818924 UTC

[section ""data" . GHC.Integer.Type.shiftLPositive_closure" {
     GHC.Integer.Type.shiftLPositive_closure:
         const GHC.Integer.Type.shiftLPositive_info;
 },
 GHC.Integer.Type.shiftLPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c6DF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6DG; else goto u6DL;
       c6DG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftLPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6DL: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6Dm() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.shiftLPositive_info" {
     GHC.Integer.Type.shiftLPositive_info:
         const GHC.Integer.Type.shiftLPositive_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c6Dm() //  []
         { []
         }
     {offset
       c6Dm: // global
           _s3Ih::P64 = P64[Sp];
           _s3Ii::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s3Ii::I64, 64)) goto c6DD; else goto c6DE;
       c6DD: // global
           R3 = _s3Ii::I64;
           R2 = _s3Ih::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       c6DE: // global
           I64[Sp] = block_c6Dt_info;
           R1 = _s3Ih::P64;
           if (R1 & 7 != 0) goto u6DN; else goto c6Du;
       u6DN: // global
           call _c6Dt(R1) args: 0, res: 0, upd: 0;
       c6Du: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Dt() //  [R1]
         { []
         }
     {offset
       c6Dt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6DK; else goto c6DJ;
       c6DK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DJ: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           P64[Sp] = Hp - 15;
           I64[Sp + 8] = I64[Sp + 8] - 64;
           call _c6Dm() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6Dt_info" {
     block_c6Dt_info:
         const _c6Dt;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.424250761 UTC

[section ""data" . GHC.Integer.Type.shiftLInteger_closure" {
     GHC.Integer.Type.shiftLInteger_closure:
         const GHC.Integer.Type.shiftLInteger_info;
 },
 GHC.Integer.Type.shiftLInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6Ee: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ef; else goto c6Eg;
       c6Ef: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftLInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Eg: // global
           I64[Sp - 16] = block_c6E6_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6EH; else goto c6E7;
       u6EH: // global
           call _c6E6(R1) args: 0, res: 0, upd: 0;
       c6E7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.shiftLInteger_info" {
     GHC.Integer.Type.shiftLInteger_info:
         const GHC.Integer.Type.shiftLInteger_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c6E6() //  [R1]
         { []
         }
     {offset
       c6E6: // global
           _c6Ed::P64 = R1 & 7;
           if (_c6Ed::P64 < 3) goto u6EG; else goto c6Ec;
       u6EG: // global
           _s3Io::I64 = I64[Sp + 8];
           if (_c6Ed::P64 < 2) goto c6Ea; else goto c6Eb;
       c6Ea: // global
           I64[Sp + 8] = block_c6Ej_info;
           R3 = _s3Io::I64;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLPositive_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
       c6Eb: // global
           I64[Sp + 8] = block_c6Eu_info;
           R3 = _s3Io::I64;
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLPositive_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
       c6Ec: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6E6_info" {
     block_c6E6_info:
         const _c6E6;
         const 65;
         const 30;
 },
 _c6Ej() //  [R1]
         { []
         }
     {offset
       c6Ej: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Er; else goto c6Eq;
       c6Er: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Eq: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Ej_info" {
     block_c6Ej_info:
         const _c6Ej;
         const 0;
         const 30;
 },
 _c6Eu() //  [R1]
         { []
         }
     {offset
       c6Eu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6EC; else goto c6EB;
       c6EC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6EB: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Eu_info" {
     block_c6Eu_info:
         const _c6Eu;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.438926276 UTC

[section ""data" . GHC.Integer.Type.some_closure" {
     GHC.Integer.Type.some_closure:
         const GHC.Integer.Type.some_info;
 },
 GHC.Integer.Type.some_entry() //  [R2, R3]
         { []
         }
     {offset
       c6Fc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Fd; else goto c6Fe;
       c6Fd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.some_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Fe: // global
           I64[Sp - 16] = block_c6F5_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Fw; else goto c6F6;
       u6Fw: // global
           call _c6F5(R1) args: 0, res: 0, upd: 0;
       c6F6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.some_info" {
     GHC.Integer.Type.some_info:
         const GHC.Integer.Type.some_entry;
         const 0;
         const 14;
         const 8589934605;
 },
 _c6F5() //  [R1]
         { []
         }
     {offset
       c6F5: // global
           _s3Iu::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c6F9; else goto c6Fa;
       c6F9: // global
           Hp = Hp + 24;
           _s3Iw::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6Fp; else goto c6Fj;
       c6Fj: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = _s3Iw::P64;
           I64[Hp] = _s3Iu::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Fa: // global
           Hp = Hp + 24;
           _s3Iw::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6Fp; else goto c6Fo;
       c6Fp: // global
           HpAlloc = 24;
           R1 = _s3Iw::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Fo: // global
           if (_s3Iu::I64 == 0) goto c6Fv; else goto c6Fu;
       c6Fv: // global
           Hp = Hp - 24;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Fu: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s3Iu::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6F5_info" {
     block_c6F5_info:
         const _c6F5;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.455106379 UTC

[section ""data" . GHC.Integer.Type.quotRemPositive_g_closure" {
     GHC.Integer.Type.quotRemPositive_g_closure:
         const GHC.Integer.Type.quotRemPositive_g_info;
 },
 GHC.Integer.Type.quotRemPositive_g_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c6FW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6FX; else goto u6Gx;
       c6FX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemPositive_g_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u6Gx: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c6FM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.quotRemPositive_g_info" {
     GHC.Integer.Type.quotRemPositive_g_info:
         const GHC.Integer.Type.quotRemPositive_g_entry;
         const 0;
         const 14;
         const 12884901907;
 },
 _c6FM() //  []
         { []
         }
     {offset
       c6FM: // global
           I64[Sp - 8] = block_c6FP_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6GA; else goto c6FQ;
       u6GA: // global
           call _c6FP(R1) args: 0, res: 0, upd: 0;
       c6FQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6FP() //  [R1]
         { []
         }
     {offset
       c6FP: // global
           _s3IC::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6FT; else goto c6FU;
       c6FT: // global
           I64[Sp] = block_c6G1_info;
           R1 = _s3IC::P64;
           if (R1 & 7 != 0) goto u6GB; else goto c6G3;
       u6GB: // global
           call _c6G1(R1) args: 0, res: 0, upd: 0;
       c6G3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6FU: // global
           I64[Sp - 8] = block_c6Ga_info;
           _s3IF::P64 = P64[R1 + 6];
           R3 = _s3IF::P64;
           R2 = _s3IC::P64;
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 16] = _s3IF::P64;
           Sp = Sp - 8;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6FP_info" {
     block_c6FP_info:
         const _c6FP;
         const 195;
         const 30;
 },
 _c6G1() //  [R1]
         { []
         }
     {offset
       c6G1: // global
           R2 = R1;
           R1 = I64[Sp + 8];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6G1_info" {
     block_c6G1_info:
         const _c6G1;
         const 451;
         const 30;
 },
 _c6Ga() //  [R1]
         { []
         }
     {offset
       c6Ga: // global
           _s3IC::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c6Gq; else goto c6Gi;
       c6Gq: // global
           I64[Sp + 16] = I64[Sp + 16] << 1;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _s3IC::P64;
           Sp = Sp + 16;
           call _c6FM() args: 0, res: 0, upd: 0;
       c6Gi: // global
           I64[Sp] = block_c6Gf_info;
           R3 = P64[Sp + 24];
           R2 = _s3IC::P64;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Ga_info" {
     block_c6Ga_info:
         const _c6Ga;
         const 132;
         const 30;
 },
 _c6Gf() //  [R1]
         { []
         }
     {offset
       c6Gf: // global
           I64[Sp + 16] = (I64[Sp + 16] << 1) + 1;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call _c6FM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6Gf_info" {
     block_c6Gf_info:
         const _c6Gf;
         const 900;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.483500103 UTC

[section ""data" . GHC.Integer.Type.quotRemPositive_closure" {
     GHC.Integer.Type.quotRemPositive_closure:
         const GHC.Integer.Type.quotRemPositive_info;
 },
 sat_s3IW_entry() //  [R1]
         { []
         }
     {offset
       c6HC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6HD; else goto c6HE;
       c6HD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6HE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call mkSubtractors_s3IR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3IW_info" {
     sat_s3IW_info:
         const sat_s3IW_entry;
         const 4294967297;
         const 19;
 },
 sat_s3IU_entry() //  [R1]
         { []
         }
     {offset
       c6HJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6HK; else goto c6HL;
       c6HK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6HL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3IU_info" {
     sat_s3IU_info:
         const sat_s3IU_entry;
         const 4294967297;
         const 19;
 },
 mkSubtractors_s3IR_entry() //  [R1, R2]
         { []
         }
     {offset
       c6HP: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6HT; else goto c6HS;
       c6HT: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6HS: // global
           if (R2 == 0) goto c6HO; else goto c6HN;
       c6HO: // global
           _s3IQ::P64 = P64[R1 + 15];
           Hp = Hp - 88;
           R1 = _s3IQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6HN: // global
           _s3IO::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s3IW_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s3IU_info;
           P64[Hp - 32] = _s3IO::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . mkSubtractors_s3IR_info" {
     mkSubtractors_s3IR_info:
         const mkSubtractors_s3IR_entry;
         const 2;
         const 11;
         const 4294967300;
 },
 subtractors_s3IP_entry() //  [R1]
         { []
         }
     {offset
       c6HV: // global
           _s3IP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6HW; else goto c6HX;
       c6HX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6HZ; else goto c6HY;
       c6HZ: // global
           HpAlloc = 48;
           goto c6HW;
       c6HW: // global
           R1 = _s3IP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6HY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s3IP::P64;
           _s3IO::P64 = P64[_s3IP::P64 + 16];
           I64[Hp - 40] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 32] = _s3IO::P64;
           P64[Hp - 24] = GHC.Integer.Type.Nil_closure+1;
           I64[Hp - 16] = mkSubtractors_s3IR_info;
           P64[Hp - 8] = _s3IO::P64;
           P64[Hp] = Hp - 38;
           R2 = 63;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call mkSubtractors_s3IR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . subtractors_s3IP_info" {
     subtractors_s3IP_info:
         const subtractors_s3IP_entry;
         const 1;
         const 16;
 },
 sat_s3Jc_entry() //  [R1]
         { []
         }
     {offset
       c6Iq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ir; else goto c6Is;
       c6Ir: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Is: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3Jc_info" {
     sat_s3Jc_info:
         const sat_s3Jc_entry;
         const 4294967297;
         const 19;
 },
 sat_s3Ji_entry() //  [R1]
         { []
         }
     {offset
       c6IG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IH; else goto c6II;
       c6IH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6II: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3Ji_info" {
     sat_s3Ji_info:
         const sat_s3Ji_entry;
         const 4294967297;
         const 19;
 },
 sat_s3Jm_entry() //  [R1]
         { []
         }
     {offset
       c6IS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IT; else goto c6IU;
       c6IT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3Jm_info" {
     sat_s3Jm_info:
         const sat_s3Jm_entry;
         const 4294967297;
         const 19;
 },
 f2_s3IX_entry() //  [R1, R2]
         { []
         }
     {offset
       c6IZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6J0; else goto c6J1;
       c6J0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6J1: // global
           I64[Sp - 24] = block_c6I5_info;
           _s3IX::P64 = R1;
           _s3IP::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s3IP::P64;
           P64[Sp - 8] = _s3IX::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6JA; else goto c6I6;
       u6JA: // global
           call _c6I5(R1) args: 0, res: 0, upd: 0;
       c6I6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . f2_s3IX_info" {
     f2_s3IX_info:
         const f2_s3IX_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _c6I5() //  [R1]
         { []
         }
     {offset
       c6I5: // global
           if (R1 & 7 == 1) goto c6IW; else goto c6IX;
       c6IW: // global
           I64[Sp] = block_c6Ia_info;
           R2 = P64[R1 + 7];
           _s3J0::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s3J0::I64;
           call f2_s3IX_entry(R2, R1) args: 8, res: 8, upd: 8;
       c6IX: // global
           R2 = GHC.Integer.Type.None_closure+2;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6I5_info" {
     block_c6I5_info:
         const _c6I5;
         const 2;
         const 30;
 },
 _c6Ia() //  [R1, R2]
         { []
         }
     {offset
       c6Ia: // global
           I64[Sp - 8] = block_c6Ic_info;
           _s3J3::P64 = R1;
           R1 = R2;
           P64[Sp] = _s3J3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Jw; else goto c6Id;
       u6Jw: // global
           call _c6Ic(R1) args: 0, res: 0, upd: 0;
       c6Id: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Ia_info" {
     block_c6Ia_info:
         const _c6Ia;
         const 130;
         const 30;
 },
 _c6Ic() //  [R1]
         { []
         }
     {offset
       c6Ic: // global
           _s3IP::P64 = P64[Sp + 16];
           _s3J0::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c6J5; else goto c6Jc;
       c6J5: // global
           Hp = Hp + 24;
           _s3J5::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6Jf; else goto c6J7;
       c6J7: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = _s3J5::P64;
           I64[Hp] = _s3J0::I64;
           I64[Sp] = block_c6Ii_info;
           R4 = Hp - 15;
           R3 = _s3IP::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
       c6Jc: // global
           Hp = Hp + 24;
           _s3J5::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6Jf; else goto c6Je;
       c6Jf: // global
           HpAlloc = 24;
           R1 = _s3J5::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Je: // global
           if (_s3J0::I64 == 0) goto c6Jl; else goto c6Jh;
       c6Jl: // global
           Hp = Hp - 24;
           I64[Sp] = block_c6IK_info;
           R4 = GHC.Integer.Type.None_closure+2;
           R3 = _s3IP::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
       c6Jh: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s3J0::I64;
           I64[Sp] = block_c6Iy_info;
           R4 = Hp - 15;
           R3 = _s3IP::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Ic_info" {
     block_c6Ic_info:
         const _c6Ic;
         const 259;
         const 30;
 },
 _c6Ii() //  [R1, R2]
         { []
         }
     {offset
       c6Ii: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c6Ij() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6Ii_info" {
     block_c6Ii_info:
         const _c6Ii;
         const 387;
         const 30;
 },
 _c6Ij() //  []
         { []
         }
     {offset
       c6Ij: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Jb; else goto c6Ja;
       c6Jb: // global
           HpAlloc = 32;
           I64[Sp] = block_c6Ij_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c6Ja: // global
           I64[Hp - 24] = sat_s3Jc_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Ij_info" {
     block_c6Ij_info:
         const _c6Ij;
         const 259;
         const 30;
 },
 _c6IK() //  [R1, R2]
         { []
         }
     {offset
       c6IK: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c6IL() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6IK_info" {
     block_c6IK_info:
         const _c6IK;
         const 387;
         const 30;
 },
 _c6IL() //  []
         { []
         }
     {offset
       c6IL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Jo; else goto c6Jn;
       c6Jo: // global
           HpAlloc = 32;
           I64[Sp] = block_c6IL_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c6Jn: // global
           I64[Hp - 24] = sat_s3Jm_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6IL_info" {
     block_c6IL_info:
         const _c6IL;
         const 259;
         const 30;
 },
 _c6Iy() //  [R1, R2]
         { []
         }
     {offset
       c6Iy: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c6Iz() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6Iy_info" {
     block_c6Iy_info:
         const _c6Iy;
         const 387;
         const 30;
 },
 _c6Iz() //  []
         { []
         }
     {offset
       c6Iz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Jk; else goto c6Jj;
       c6Jk: // global
           HpAlloc = 32;
           I64[Sp] = block_c6Iz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c6Jj: // global
           I64[Hp - 24] = sat_s3Ji_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Iz_info" {
     block_c6Iz_info:
         const _c6Iz;
         const 259;
         const 30;
 },
 sat_s3Jr_entry() //  [R1]
         { []
         }
     {offset
       c6JH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JI; else goto c6JJ;
       c6JI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.digitsMaybeZeroToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3Jr_info" {
     sat_s3Jr_info:
         const sat_s3Jr_entry;
         const 1;
         const 16;
 },
 sat_s3Jq_entry() //  [R1]
         { []
         }
     {offset
       c6JO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JP; else goto c6JQ;
       c6JP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.digitsMaybeZeroToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3Jq_info" {
     sat_s3Jq_info:
         const sat_s3Jq_entry;
         const 1;
         const 16;
 },
 GHC.Integer.Type.quotRemPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c6JR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JS; else goto c6JT;
       c6JS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JT: // global
           I64[Sp - 16] = block_c6Hf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6K0; else goto c6Hg;
       u6K0: // global
           call _c6Hf(R1) args: 0, res: 0, upd: 0;
       c6Hg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.quotRemPositive_info" {
     GHC.Integer.Type.quotRemPositive_info:
         const GHC.Integer.Type.quotRemPositive_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6Hf() //  [R1]
         { []
         }
     {offset
       c6Hf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6JW; else goto c6JV;
       c6JW: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6JV: // global
           I64[Hp - 32] = subtractors_s3IP_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = f2_s3IX_info;
           P64[Hp] = Hp - 32;
           _s3IM::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6JB_info;
           R2 = _s3IM::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call f2_s3IX_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Hf_info" {
     block_c6Hf_info:
         const _c6Hf;
         const 1;
         const 30;
 },
 _c6JB() //  [R1, R2]
         { []
         }
     {offset
       c6JB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6JZ; else goto c6JY;
       c6JZ: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c6JY: // global
           I64[Hp - 40] = sat_s3Jr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s3Jq_info;
           P64[Hp] = R1;
           R2 = Hp - 40;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6JB_info" {
     block_c6JB_info:
         const _c6JB;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.539844402 UTC

[section ""data" . GHC.Integer.Type.quotRemInteger_closure" {
     GHC.Integer.Type.quotRemInteger_closure:
         const GHC.Integer.Type.quotRemInteger_info;
 },
 sat_s3JE_entry() //  [R1]
         { []
         }
     {offset
       c6Ma: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Mb; else goto c6Mc;
       c6Mb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Mc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3JE_info" {
     sat_s3JE_info:
         const sat_s3JE_entry;
         const 1;
         const 16;
 },
 sat_s3JM_entry() //  [R1]
         { []
         }
     {offset
       c6Mq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Mr; else goto c6Ms;
       c6Mr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ms: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3JM_info" {
     sat_s3JM_info:
         const sat_s3JM_entry;
         const 1;
         const 16;
 },
 sat_s3JL_entry() //  [R1]
         { []
         }
     {offset
       c6Mx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6My; else goto c6Mz;
       c6My: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Mz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3JL_info" {
     sat_s3JL_info:
         const sat_s3JL_entry;
         const 1;
         const 16;
 },
 sat_s3JR_entry() //  [R1]
         { []
         }
     {offset
       c6MI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6MJ; else goto c6MK;
       c6MJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6MK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3JR_info" {
     sat_s3JR_info:
         const sat_s3JR_entry;
         const 1;
         const 16;
 },
 GHC.Integer.Type.quotRemInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6MP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6MQ; else goto c6MR;
       c6MQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6MR: // global
           I64[Sp - 16] = block_c6LJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6NH; else goto c6LK;
       u6NH: // global
           call _c6LJ(R1) args: 0, res: 0, upd: 0;
       c6LK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.quotRemInteger_info" {
     GHC.Integer.Type.quotRemInteger_info:
         const GHC.Integer.Type.quotRemInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6LJ() //  [R1]
         { []
         }
     {offset
       c6LJ: // global
           _s3Jt::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c6MN; else goto c6MM;
       c6MN: // global
           I64[Sp + 8] = block_c6Nr_info;
           R1 = _s3Jt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6ND; else goto c6Nt;
       u6ND: // global
           call _c6Nr() args: 0, res: 0, upd: 0;
       c6Nt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6MM: // global
           I64[Sp] = block_c6LO_info;
           _s3Ju::P64 = R1;
           R1 = _s3Jt::P64;
           P64[Sp + 8] = _s3Ju::P64;
           if (R1 & 7 != 0) goto u6NC; else goto c6LP;
       u6NC: // global
           call _c6LO(R1) args: 0, res: 0, upd: 0;
       c6LP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6LJ_info" {
     block_c6LJ_info:
         const _c6LJ;
         const 1;
         const 30;
 },
 _c6Nr() //  []
         { []
         }
     {offset
       c6Nr: // global
           R2 = GHC.Integer.Type.Naught_closure+3;
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Nr_info" {
     block_c6Nr_info:
         const _c6Nr;
         const 0;
         const 30;
 },
 _c6LO() //  [R1]
         { []
         }
     {offset
       c6LO: // global
           if (R1 & 7 == 3) goto c6No; else goto c6MV;
       c6No: // global
           R2 = GHC.Integer.Type.errorInteger_closure+1;
           R1 = GHC.Integer.Type.errorInteger_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c6MV: // global
           I64[Sp] = block_c6LT_info;
           _s3Jv::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s3Jv::P64;
           if (R1 & 7 != 0) goto u6NE; else goto c6LU;
       u6NE: // global
           call _c6LT(R1) args: 0, res: 0, upd: 0;
       c6LU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6LO_info" {
     block_c6LO_info:
         const _c6LO;
         const 1;
         const 30;
 },
 _c6LT() //  [R1]
         { []
         }
     {offset
       c6LT: // global
           _s3Jv::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c6MY; else goto c6N9;
       c6MY: // global
           I64[Sp] = block_c6LY_info;
           _s3Jx::P64 = P64[R1 + 7];
           R1 = _s3Jv::P64;
           P64[Sp + 8] = _s3Jx::P64;
           if (R1 & 7 != 0) goto u6NF; else goto c6LZ;
       u6NF: // global
           call _c6LY(R1) args: 0, res: 0, upd: 0;
       c6LZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6N9: // global
           I64[Sp] = block_c6Mf_info;
           _s3JF::P64 = P64[R1 + 6];
           R1 = _s3Jv::P64;
           P64[Sp + 8] = _s3JF::P64;
           if (R1 & 7 != 0) goto u6NG; else goto c6Mg;
       u6NG: // global
           call _c6Mf(R1) args: 0, res: 0, upd: 0;
       c6Mg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6LT_info" {
     block_c6LT_info:
         const _c6LT;
         const 1;
         const 30;
 },
 _c6LY() //  [R1]
         { []
         }
     {offset
       c6LY: // global
           _s3Jx::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c6N2; else goto c6N4;
       c6N2: // global
           R3 = P64[R1 + 7];
           R2 = _s3Jx::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c6N4: // global
           I64[Sp + 8] = block_c6M4_info;
           R3 = P64[R1 + 6];
           R2 = _s3Jx::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6LY_info" {
     block_c6LY_info:
         const _c6LY;
         const 1;
         const 30;
 },
 _c6M4() //  [R1, R2]
         { []
         }
     {offset
       c6M4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6N7; else goto c6N6;
       c6N7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c6N6: // global
           I64[Hp - 16] = sat_s3JE_info;
           P64[Hp] = R1;
           R2 = R2;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6M4_info" {
     block_c6M4_info:
         const _c6M4;
         const 0;
         const 30;
 },
 _c6Mf() //  [R1]
         { []
         }
     {offset
       c6Mf: // global
           _s3JF::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c6Nc; else goto c6Nh;
       c6Nc: // global
           I64[Sp + 8] = block_c6Mk_info;
           R3 = P64[R1 + 7];
           R2 = _s3JF::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       c6Nh: // global
           I64[Sp + 8] = block_c6MC_info;
           R3 = P64[R1 + 6];
           R2 = _s3JF::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Mf_info" {
     block_c6Mf_info:
         const _c6Mf;
         const 1;
         const 30;
 },
 _c6Mk() //  [R1, R2]
         { []
         }
     {offset
       c6Mk: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6Nf; else goto c6Ne;
       c6Nf: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c6Ne: // global
           I64[Hp - 40] = sat_s3JM_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s3JL_info;
           P64[Hp] = R1;
           R2 = Hp - 40;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Mk_info" {
     block_c6Mk_info:
         const _c6Mk;
         const 0;
         const 30;
 },
 _c6MC() //  [R1, R2]
         { []
         }
     {offset
       c6MC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Nk; else goto c6Nj;
       c6Nk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c6Nj: // global
           I64[Hp - 16] = sat_s3JR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6MC_info" {
     block_c6MC_info:
         const _c6MC;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.576399263 UTC

[section ""data" . GHC.Integer.Type.divModInteger_closure" {
     GHC.Integer.Type.divModInteger_closure:
         const GHC.Integer.Type.divModInteger_info;
         const 0;
 },
 sat_s3K3_entry() //  [R1]
         { []
         }
     {offset
       c6Pg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ph; else goto c6Pi;
       c6Ph: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Pi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3K3_info" {
     sat_s3K3_info:
         const sat_s3K3_entry;
         const 2;
         const 4294967314;
         const S3Xx_srt+40;
 },
 sat_s3K2_entry() //  [R1]
         { []
         }
     {offset
       c6Pn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Po; else goto c6Pp;
       c6Po: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Pp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Integer.Type.oneInteger_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s3K2_info" {
     sat_s3K2_info:
         const sat_s3K2_entry;
         const 1;
         const 4294967312;
         const S3Xx_srt+48;
 },
 GHC.Integer.Type.divModInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6Pq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Pr; else goto c6Ps;
       c6Pr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.divModInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Ps: // global
           I64[Sp - 16] = block_c6OT_info;
           _s3JU::P64 = R3;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = _s3JU::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.divModInteger_info" {
     GHC.Integer.Type.divModInteger_info:
         const GHC.Integer.Type.divModInteger_entry;
         const 0;
         const 150323855374;
         const 8589934607;
         const S3Xx_srt+40;
 },
 _c6OT() //  [R1, R2]
         { []
         }
     {offset
       c6OT: // global
           I64[Sp - 16] = block_c6OV_info;
           _s3JX::P64 = R2;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = _s3JX::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6OT_info" {
     block_c6OT_info:
         const _c6OT;
         const 1;
         const 12884901918;
         const S3Xx_srt+40;
 },
 _c6OV() //  [R1]
         { []
         }
     {offset
       c6OV: // global
           I64[Sp] = block_c6OZ_info;
           R2 = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6OV_info" {
     block_c6OV_info:
         const _c6OV;
         const 3;
         const 12884901918;
         const S3Xx_srt+40;
 },
 _c6OZ() //  [R1]
         { []
         }
     {offset
       c6OZ: // global
           I64[Sp - 8] = block_c6P3_info;
           R2 = P64[Sp + 8];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6OZ_info" {
     block_c6OZ_info:
         const _c6OZ;
         const 3;
         const 12884901918;
         const S3Xx_srt+40;
 },
 _c6P3() //  [R1]
         { []
         }
     {offset
       c6P3: // global
           _s3K0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6P7_info;
           R3 = _s3K0::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6P3_info" {
     block_c6P3_info:
         const _c6P3;
         const 4;
         const 12884901918;
         const S3Xx_srt+40;
 },
 _c6P7() //  [R1]
         { []
         }
     {offset
       c6P7: // global
           _s3JW::P64 = P64[Sp + 16];
           _s3JX::P64 = P64[Sp + 8];
           if (R1 == 1) goto c6PB; else goto c6PA;
       c6PB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6PE; else goto c6PD;
       c6PE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c6PD: // global
           I64[Hp - 48] = sat_s3K3_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s3JX::P64;
           I64[Hp - 16] = sat_s3K2_info;
           P64[Hp] = _s3JW::P64;
           R2 = Hp - 48;
           R1 = Hp - 16;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c6PA: // global
           R2 = _s3JX::P64;
           R1 = _s3JW::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6P7_info" {
     block_c6P7_info:
         const _c6P7;
         const 3;
         const 12884901918;
         const S3Xx_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.596916937 UTC

[section ""data" . GHC.Integer.Type.divInteger_closure" {
     GHC.Integer.Type.divInteger_closure:
         const GHC.Integer.Type.divInteger_info;
         const 0;
 },
 GHC.Integer.Type.divInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6Qg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6Qh; else goto c6Qi;
       c6Qh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.divInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Qi: // global
           I64[Sp - 8] = block_c6Qe_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.divInteger_info" {
     GHC.Integer.Type.divInteger_info:
         const GHC.Integer.Type.divInteger_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S3Xx_srt+80;
 },
 _c6Qe() //  [R1]
         { []
         }
     {offset
       c6Qe: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Qe_info" {
     block_c6Qe_info:
         const _c6Qe;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.6052341 UTC

[section ""data" . GHC.Integer.Type.modInteger_closure" {
     GHC.Integer.Type.modInteger_closure:
         const GHC.Integer.Type.modInteger_info;
         const 0;
 },
 GHC.Integer.Type.modInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6QA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6QB; else goto c6QC;
       c6QB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.modInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6QC: // global
           I64[Sp - 8] = block_c6Qy_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.modInteger_info" {
     GHC.Integer.Type.modInteger_info:
         const GHC.Integer.Type.modInteger_entry;
         const 0;
         const 21474836494;
         const 8589934607;
         const S3Xx_srt+80;
 },
 _c6Qy() //  [R2]
         { []
         }
     {offset
       c6Qy: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Qy_info" {
     block_c6Qy_info:
         const _c6Qy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.613958691 UTC

[section ""data" . GHC.Integer.Type.quotInteger_closure" {
     GHC.Integer.Type.quotInteger_closure:
         const GHC.Integer.Type.quotInteger_info;
 },
 GHC.Integer.Type.quotInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6QU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6QV; else goto c6QW;
       c6QV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6QW: // global
           I64[Sp - 8] = block_c6QS_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.quotInteger_info" {
     GHC.Integer.Type.quotInteger_info:
         const GHC.Integer.Type.quotInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6QS() //  [R1]
         { []
         }
     {offset
       c6QS: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6QS_info" {
     block_c6QS_info:
         const _c6QS;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.622182935 UTC

[section ""data" . GHC.Integer.Type.remInteger_closure" {
     GHC.Integer.Type.remInteger_closure:
         const GHC.Integer.Type.remInteger_info;
 },
 GHC.Integer.Type.remInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6Re: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6Rf; else goto c6Rg;
       c6Rf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.remInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Rg: // global
           I64[Sp - 8] = block_c6Rc_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.remInteger_info" {
     GHC.Integer.Type.remInteger_info:
         const GHC.Integer.Type.remInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6Rc() //  [R2]
         { []
         }
     {offset
       c6Rc: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Rc_info" {
     block_c6Rc_info:
         const _c6Rc;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.631237028 UTC

[section ""data" . GHC.Integer.Type.andDigits_closure" {
     GHC.Integer.Type.andDigits_closure:
         const GHC.Integer.Type.andDigits_info;
 },
 GHC.Integer.Type.andDigits_entry() //  [R2, R3]
         { []
         }
     {offset
       c6RD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6RE; else goto c6RF;
       c6RE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6RF: // global
           I64[Sp - 16] = block_c6Rw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Si; else goto c6Rx;
       u6Si: // global
           call _c6Rw(R1) args: 0, res: 0, upd: 0;
       c6Rx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.andDigits_info" {
     GHC.Integer.Type.andDigits_info:
         const GHC.Integer.Type.andDigits_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6Rw() //  [R1]
         { []
         }
     {offset
       c6Rw: // global
           _s3Kp::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6RA; else goto c6RB;
       c6RA: // global
           I64[Sp - 8] = block_c6RI_info;
           _s3Ks::P64 = P64[R1 + 7];
           _s3Kr::I64 = I64[R1 + 15];
           R1 = _s3Kp::P64;
           P64[Sp] = _s3Ks::P64;
           I64[Sp + 8] = _s3Kr::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Sg; else goto c6RK;
       u6Sg: // global
           call _c6RI(R1) args: 0, res: 0, upd: 0;
       c6RK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6RB: // global
           I64[Sp + 8] = block_c6S8_info;
           R1 = _s3Kp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u6Sh; else goto c6Sa;
       u6Sh: // global
           call _c6S8() args: 0, res: 0, upd: 0;
       c6Sa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Rw_info" {
     block_c6Rw_info:
         const _c6Rw;
         const 1;
         const 30;
 },
 _c6RI() //  [R1]
         { []
         }
     {offset
       c6RI: // global
           if (R1 & 7 == 1) goto c6RY; else goto c6S5;
       c6RY: // global
           I64[Sp] = block_c6RO_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c6S5: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6RI_info" {
     block_c6RI_info:
         const _c6RI;
         const 130;
         const 30;
 },
 _c6RO() //  [R1]
         { []
         }
     {offset
       c6RO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6S1; else goto c6S0;
       c6S1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6S0: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] & I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6RO_info" {
     block_c6RO_info:
         const _c6RO;
         const 194;
         const 30;
 },
 _c6S8() //  []
         { []
         }
     {offset
       c6S8: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6S8_info" {
     block_c6S8_info:
         const _c6S8;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.647735106 UTC

[section ""data" . GHC.Integer.Type.andDigitsOnes_closure" {
     GHC.Integer.Type.andDigitsOnes_closure:
         const GHC.Integer.Type.andDigitsOnes_info;
 },
 GHC.Integer.Type.andDigitsOnes_entry() //  [R2, R3]
         { []
         }
     {offset
       c6SY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6SZ; else goto c6T0;
       c6SZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andDigitsOnes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6T0: // global
           I64[Sp - 16] = block_c6SR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Tw; else goto c6SS;
       u6Tw: // global
           call _c6SR(R1) args: 0, res: 0, upd: 0;
       c6SS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.andDigitsOnes_info" {
     GHC.Integer.Type.andDigitsOnes_info:
         const GHC.Integer.Type.andDigitsOnes_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6SR() //  [R1]
         { []
         }
     {offset
       c6SR: // global
           _s3KA::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6SV; else goto c6SW;
       c6SV: // global
           I64[Sp - 8] = block_c6T3_info;
           _s3KD::P64 = P64[R1 + 7];
           _s3KC::I64 = I64[R1 + 15];
           R1 = _s3KA::P64;
           P64[Sp] = _s3KD::P64;
           I64[Sp + 8] = _s3KC::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Tv; else goto c6T5;
       u6Tv: // global
           call _c6T3(R1) args: 0, res: 0, upd: 0;
       c6T5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6SW: // global
           R1 = _s3KA::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6SR_info" {
     block_c6SR_info:
         const _c6SR;
         const 1;
         const 30;
 },
 _c6T3() //  [R1]
         { []
         }
     {offset
       c6T3: // global
           if (R1 & 7 == 1) goto c6Tj; else goto c6Tq;
       c6Tj: // global
           I64[Sp] = block_c6T9_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c6Tq: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6T3_info" {
     block_c6T3_info:
         const _c6T3;
         const 130;
         const 30;
 },
 _c6T9() //  [R1]
         { []
         }
     {offset
       c6T9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Tm; else goto c6Tl;
       c6Tm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Tl: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] & I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6T9_info" {
     block_c6T9_info:
         const _c6T9;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.663603048 UTC

[section ""data" . GHC.Integer.Type.orDigits_closure" {
     GHC.Integer.Type.orDigits_closure:
         const GHC.Integer.Type.orDigits_info;
 },
 GHC.Integer.Type.orDigits_entry() //  [R2, R3]
         { []
         }
     {offset
       c6U9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Ua; else goto c6Ub;
       c6Ua: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.orDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Ub: // global
           I64[Sp - 16] = block_c6U2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6UH; else goto c6U3;
       u6UH: // global
           call _c6U2(R1) args: 0, res: 0, upd: 0;
       c6U3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.orDigits_info" {
     GHC.Integer.Type.orDigits_info:
         const GHC.Integer.Type.orDigits_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6U2() //  [R1]
         { []
         }
     {offset
       c6U2: // global
           _s3KK::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6U6; else goto c6U7;
       c6U6: // global
           I64[Sp - 16] = block_c6Ue_info;
           _s3KL::P64 = R1;
           _s3KN::P64 = P64[R1 + 7];
           _s3KM::I64 = I64[R1 + 15];
           R1 = _s3KK::P64;
           P64[Sp - 8] = _s3KN::P64;
           I64[Sp] = _s3KM::I64;
           P64[Sp + 8] = _s3KL::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6UG; else goto c6Ug;
       u6UG: // global
           call _c6Ue(R1) args: 0, res: 0, upd: 0;
       c6Ug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6U7: // global
           R1 = _s3KK::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6U2_info" {
     block_c6U2_info:
         const _c6U2;
         const 1;
         const 30;
 },
 _c6Ue() //  [R1]
         { []
         }
     {offset
       c6Ue: // global
           if (R1 & 7 == 1) goto c6Uu; else goto c6UB;
       c6Uu: // global
           _s3KN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6Uk_info;
           R3 = P64[R1 + 7];
           R2 = _s3KN::P64;
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
       c6UB: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Ue_info" {
     block_c6Ue_info:
         const _c6Ue;
         const 131;
         const 30;
 },
 _c6Uk() //  [R1]
         { []
         }
     {offset
       c6Uk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Ux; else goto c6Uw;
       c6Ux: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Uw: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] | I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Uk_info" {
     block_c6Uk_info:
         const _c6Uk;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.681979319 UTC

[section ""data" . GHC.Integer.Type.orInteger_closure" {
     GHC.Integer.Type.orInteger_closure:
         const GHC.Integer.Type.orInteger_info;
 },
 GHC.Integer.Type.orInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c6Vl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Vm; else goto u6XG;
       c6Vm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.orInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6XG: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6Vb() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.orInteger_info" {
     GHC.Integer.Type.orInteger_info:
         const GHC.Integer.Type.orInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c6Vb() //  []
         { []
         }
     {offset
       c6Vb: // global
           _s3KT::P64 = P64[Sp];
           I64[Sp] = block_c6Ve_info;
           R1 = _s3KT::P64;
           if (R1 & 7 != 0) goto u6XM; else goto c6Vf;
       u6XM: // global
           call _c6Ve(R1) args: 0, res: 0, upd: 0;
       c6Vf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ve() //  [R1]
         { []
         }
     {offset
       c6Ve: // global
           _s3KU::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c6Vj; else goto c6Vi;
       c6Vj: // global
           R1 = _s3KU::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6Vi: // global
           I64[Sp] = block_c6Vq_info;
           _s3KV::P64 = R1;
           R1 = _s3KU::P64;
           P64[Sp + 8] = _s3KV::P64;
           if (R1 & 7 != 0) goto u6XN; else goto c6Vs;
       u6XN: // global
           call _c6Vq(R1) args: 0, res: 0, upd: 0;
       c6Vs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Ve_info" {
     block_c6Ve_info:
         const _c6Ve;
         const 1;
         const 30;
 },
 _c6Vq() //  [R1]
         { []
         }
     {offset
       c6Vq: // global
           _s3KV::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c6Xw; else goto c6Vz;
       c6Xw: // global
           R1 = _s3KV::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6Vz: // global
           I64[Sp] = block_c6Vw_info;
           _s3KW::P64 = R1;
           R1 = _s3KV::P64;
           P64[Sp + 8] = _s3KW::P64;
           if (R1 & 7 != 0) goto u6XP; else goto c6VA;
       u6XP: // global
           call _c6Vw(R1) args: 0, res: 0, upd: 0;
       c6VA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Vq_info" {
     block_c6Vq_info:
         const _c6Vq;
         const 1;
         const 30;
 },
 _c6Vw() //  [R1]
         { []
         }
     {offset
       c6Vw: // global
           _s3KW::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c6VH; else goto c6WG;
       c6VH: // global
           I64[Sp] = block_c6VE_info;
           _s3KY::P64 = P64[R1 + 7];
           R1 = _s3KW::P64;
           P64[Sp + 8] = _s3KY::P64;
           if (R1 & 7 != 0) goto u6XQ; else goto c6VI;
       u6XQ: // global
           call _c6VE(R1) args: 0, res: 0, upd: 0;
       c6VI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c6WG: // global
           I64[Sp - 8] = block_c6WE_info;
           _s3KX::P64 = R1;
           _s3Ld::P64 = P64[R1 + 6];
           R1 = _s3KW::P64;
           P64[Sp] = _s3Ld::P64;
           P64[Sp + 8] = _s3KX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6XR; else goto c6WH;
       u6XR: // global
           call _c6WE(R1) args: 0, res: 0, upd: 0;
       c6WH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Vw_info" {
     block_c6Vw_info:
         const _c6Vw;
         const 1;
         const 30;
 },
 _c6VE() //  [R1]
         { []
         }
     {offset
       c6VE: // global
           if (R1 & 7 < 2) goto c6VT; else goto c6W9;
       c6VT: // global
           _s3KY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6VM_info;
           R3 = P64[R1 + 7];
           R2 = _s3KY::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
       c6W9: // global
           I64[Sp] = block_c6VZ_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6VE_info" {
     block_c6VE_info:
         const _c6VE;
         const 1;
         const 30;
 },
 _c6VM() //  [R1]
         { []
         }
     {offset
       c6VM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6VW; else goto c6VV;
       c6VW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6VV: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c6VM_info" {
     block_c6VM_info:
         const _c6VM;
         const 0;
         const 30;
 },
 _c6VZ() //  [R1]
         { []
         }
     {offset
       c6VZ: // global
           I64[Sp] = block_c6W3_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6VZ_info" {
     block_c6VZ_info:
         const _c6VZ;
         const 1;
         const 30;
 },
 _c6W3() //  [R1]
         { []
         }
     {offset
       c6W3: // global
           _s3L4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6W7_info;
           R3 = _s3L4::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6W3_info" {
     block_c6W3_info:
         const _c6W3;
         const 1;
         const 30;
 },
 _c6W7() //  [R1]
         { []
         }
     {offset
       c6W7: // global
           I64[Sp] = block_c6Wf_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6W7_info" {
     block_c6W7_info:
         const _c6W7;
         const 0;
         const 30;
 },
 _c6Wf() //  [R1, R2]
         { []
         }
     {offset
       c6Wf: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c6Wg() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6Wf_info" {
     block_c6Wf_info:
         const _c6Wf;
         const 0;
         const 30;
 },
 _c6Wg() //  []
         { []
         }
     {offset
       c6Wg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Wo; else goto c6Wn;
       c6Wo: // global
           HpAlloc = 24;
           I64[Sp] = block_c6Wg_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c6Wn: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c6Wk_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Wg_info" {
     block_c6Wg_info:
         const _c6Wg;
         const 130;
         const 30;
 },
 _c6Wk() //  [R1]
         { []
         }
     {offset
       c6Wk: // global
           if (R1 & 7 == 1) goto c6Wu; else goto u6XI;
       c6Wu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Wx; else goto c6Ww;
       c6Wx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Ww: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u6XI: // global
           Sp = Sp + 8;
           call _c6Xs() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6Wk_info" {
     block_c6Wk_info:
         const _c6Wk;
         const 0;
         const 30;
 },
 _c6WE() //  [R1]
         { []
         }
     {offset
       c6WE: // global
           if (R1 & 7 < 2) goto c6WN; else goto c6X0;
       c6WN: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c6Vb() args: 0, res: 0, upd: 0;
       c6X0: // global
           I64[Sp] = block_c6WQ_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6WE_info" {
     block_c6WE_info:
         const _c6WE;
         const 2;
         const 30;
 },
 _c6WQ() //  [R1]
         { []
         }
     {offset
       c6WQ: // global
           _s3Ld::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6WU_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s3Ld::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6WQ_info" {
     block_c6WQ_info:
         const _c6WQ;
         const 130;
         const 30;
 },
 _c6WU() //  [R1]
         { []
         }
     {offset
       c6WU: // global
           _s3Li::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6WY_info;
           R3 = _s3Li::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6WU_info" {
     block_c6WU_info:
         const _c6WU;
         const 1;
         const 30;
 },
 _c6WY() //  [R1]
         { []
         }
     {offset
       c6WY: // global
           I64[Sp] = block_c6X6_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6WY_info" {
     block_c6WY_info:
         const _c6WY;
         const 0;
         const 30;
 },
 _c6X6() //  [R1, R2]
         { []
         }
     {offset
       c6X6: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c6X7() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6X6_info" {
     block_c6X6_info:
         const _c6X6;
         const 0;
         const 30;
 },
 _c6X7() //  []
         { []
         }
     {offset
       c6X7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Xf; else goto c6Xe;
       c6Xf: // global
           HpAlloc = 24;
           I64[Sp] = block_c6X7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c6Xe: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c6Xb_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6X7_info" {
     block_c6X7_info:
         const _c6X7;
         const 130;
         const 30;
 },
 _c6Xb() //  [R1]
         { []
         }
     {offset
       c6Xb: // global
           if (R1 & 7 == 1) goto c6Xl; else goto u6XL;
       c6Xl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Xo; else goto c6Xn;
       c6Xo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Xn: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u6XL: // global
           Sp = Sp + 8;
           call _c6Xs() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c6Xb_info" {
     block_c6Xb_info:
         const _c6Xb;
         const 0;
         const 30;
 },
 _c6Xs() //  []
         { []
         }
     {offset
       c6Xs: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.734293302 UTC

[section ""data" . GHC.Integer.Type.mkInteger_f_closure" {
     GHC.Integer.Type.mkInteger_f_closure:
         const GHC.Integer.Type.mkInteger_f_info;
 },
 GHC.Integer.Type.mkInteger_f_entry() //  [R2]
         { []
         }
     {offset
       c6ZF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ZG; else goto c6ZH;
       c6ZG: // global
           R2 = R2;
           R1 = GHC.Integer.Type.mkInteger_f_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ZH: // global
           I64[Sp - 8] = block_c6Zy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u70a; else goto c6Zz;
       u70a: // global
           call _c6Zy(R1) args: 0, res: 0, upd: 0;
       c6Zz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.mkInteger_f_info" {
     GHC.Integer.Type.mkInteger_f_info:
         const GHC.Integer.Type.mkInteger_f_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c6Zy() //  [R1]
         { []
         }
     {offset
       c6Zy: // global
           if (R1 & 7 == 1) goto c6ZC; else goto c6ZD;
       c6ZC: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6ZD: // global
           I64[Sp - 8] = block_c6ZN_info;
           _s3Lu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s3Lu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u709; else goto c6ZO;
       u709: // global
           call _c6ZN(R1) args: 0, res: 0, upd: 0;
       c6ZO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6Zy_info" {
     block_c6Zy_info:
         const _c6Zy;
         const 0;
         const 30;
 },
 _c6ZN() //  [R1]
         { []
         }
     {offset
       c6ZN: // global
           I64[Sp] = block_c6ZS_info;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6ZN_info" {
     block_c6ZN_info:
         const _c6ZN;
         const 1;
         const 30;
 },
 _c6ZS() //  [R1]
         { []
         }
     {offset
       c6ZS: // global
           I64[Sp] = block_c6ZW_info;
           R3 = 31;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6ZS_info" {
     block_c6ZS_info:
         const _c6ZS;
         const 65;
         const 30;
 },
 _c6ZW() //  [R1]
         { []
         }
     {offset
       c6ZW: // global
           I64[Sp] = block_c700_info;
           R2 = I64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c6ZW_info" {
     block_c6ZW_info:
         const _c6ZW;
         const 65;
         const 30;
 },
 _c700() //  [R1]
         { []
         }
     {offset
       c700: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c700_info" {
     block_c700_info:
         const _c700;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.755402434 UTC

[section ""data" . GHC.Integer.Type.mkInteger_closure" {
     GHC.Integer.Type.mkInteger_closure:
         const GHC.Integer.Type.mkInteger_info;
 },
 GHC.Integer.Type.mkInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c70M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c70N; else goto c70O;
       c70N: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.mkInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c70O: // global
           I64[Sp - 16] = block_c70F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u710; else goto c70G;
       u710: // global
           call _c70F(R1) args: 0, res: 0, upd: 0;
       c70G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.mkInteger_info" {
     GHC.Integer.Type.mkInteger_info:
         const GHC.Integer.Type.mkInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c70F() //  [R1]
         { []
         }
     {offset
       c70F: // global
           _s3LB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c70J; else goto c70K;
       c70J: // global
           I64[Sp + 8] = block_c70R_info;
           R2 = _s3LB::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 8, upd: 8;
       c70K: // global
           R2 = _s3LB::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c70F_info" {
     block_c70F_info:
         const _c70F;
         const 1;
         const 30;
 },
 _c70R() //  [R1]
         { []
         }
     {offset
       c70R: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c70R_info" {
     block_c70R_info:
         const _c70R;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.781877838 UTC

[section ""data" . GHC.Integer.Type.andInteger_closure" {
     GHC.Integer.Type.andInteger_closure:
         const GHC.Integer.Type.andInteger_info;
 },
 GHC.Integer.Type.andInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c71q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c71r; else goto u73V;
       c71r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u73V: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c71g() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.andInteger_info" {
     GHC.Integer.Type.andInteger_info:
         const GHC.Integer.Type.andInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c71g() //  []
         { []
         }
     {offset
       c71g: // global
           _s3LE::P64 = P64[Sp];
           I64[Sp] = block_c71j_info;
           R1 = _s3LE::P64;
           if (R1 & 7 != 0) goto u742; else goto c71k;
       u742: // global
           call _c71j(R1) args: 0, res: 0, upd: 0;
       c71k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c71j() //  [R1]
         { []
         }
     {offset
       c71j: // global
           _s3LF::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c71o; else goto c71n;
       c71o: // global
           I64[Sp + 8] = block_c73H_info;
           R1 = _s3LF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u744; else goto c73J;
       u744: // global
           call _c73H() args: 0, res: 0, upd: 0;
       c73J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c71n: // global
           I64[Sp] = block_c71v_info;
           _s3LG::P64 = R1;
           R1 = _s3LF::P64;
           P64[Sp + 8] = _s3LG::P64;
           if (R1 & 7 != 0) goto u743; else goto c71x;
       u743: // global
           call _c71v(R1) args: 0, res: 0, upd: 0;
       c71x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c71j_info" {
     block_c71j_info:
         const _c71j;
         const 1;
         const 30;
 },
 _c73H() //  []
         { []
         }
     {offset
       c73H: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c73H_info" {
     block_c73H_info:
         const _c73H;
         const 0;
         const 30;
 },
 _c71v() //  [R1]
         { []
         }
     {offset
       c71v: // global
           if (R1 & 7 == 3) goto u73W; else goto c71E;
       u73W: // global
           Sp = Sp + 16;
           call _c73E() args: 0, res: 0, upd: 0;
       c71E: // global
           I64[Sp] = block_c71B_info;
           _s3LH::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s3LH::P64;
           if (R1 & 7 != 0) goto u746; else goto c71F;
       u746: // global
           call _c71B(R1) args: 0, res: 0, upd: 0;
       c71F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c71v_info" {
     block_c71v_info:
         const _c71v;
         const 1;
         const 30;
 },
 _c71B() //  [R1]
         { []
         }
     {offset
       c71B: // global
           _s3LH::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c71M; else goto c72O;
       c71M: // global
           I64[Sp] = block_c71J_info;
           _s3LJ::P64 = P64[R1 + 7];
           R1 = _s3LH::P64;
           P64[Sp + 8] = _s3LJ::P64;
           if (R1 & 7 != 0) goto u748; else goto c71N;
       u748: // global
           call _c71J(R1) args: 0, res: 0, upd: 0;
       c71N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c72O: // global
           I64[Sp - 8] = block_c72M_info;
           _s3LI::P64 = R1;
           _s3LX::P64 = P64[R1 + 6];
           R1 = _s3LH::P64;
           P64[Sp] = _s3LX::P64;
           P64[Sp + 8] = _s3LI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u749; else goto c72P;
       u749: // global
           call _c72M(R1) args: 0, res: 0, upd: 0;
       c72P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c71B_info" {
     block_c71B_info:
         const _c71B;
         const 1;
         const 30;
 },
 _c71J() //  [R1]
         { []
         }
     {offset
       c71J: // global
           if (R1 & 7 < 2) goto c71U; else goto c72p;
       c71U: // global
           _s3LJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c71R_info;
           R3 = P64[R1 + 7];
           R2 = _s3LJ::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c72p: // global
           I64[Sp] = block_c72f_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c71J_info" {
     block_c71J_info:
         const _c71J;
         const 1;
         const 30;
 },
 _c71R() //  [R1]
         { []
         }
     {offset
       c71R: // global
           I64[Sp] = block_c71Y_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c71R_info" {
     block_c71R_info:
         const _c71R;
         const 0;
         const 30;
 },
 _c71Y() //  [R1]
         { []
         }
     {offset
       c71Y: // global
           if (R1 & 7 == 1) goto c725; else goto u73X;
       c725: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c728; else goto c727;
       c728: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c727: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u73X: // global
           Sp = Sp + 8;
           call _c73E() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c71Y_info" {
     block_c71Y_info:
         const _c71Y;
         const 0;
         const 30;
 },
 _c72f() //  [R1]
         { []
         }
     {offset
       c72f: // global
           I64[Sp] = block_c72j_info;
           R2 = R1;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c72f_info" {
     block_c72f_info:
         const _c72f;
         const 1;
         const 30;
 },
 _c72j() //  [R1]
         { []
         }
     {offset
       c72j: // global
           _s3LJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c72n_info;
           R3 = _s3LJ::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c72j_info" {
     block_c72j_info:
         const _c72j;
         const 1;
         const 30;
 },
 _c72n() //  [R1]
         { []
         }
     {offset
       c72n: // global
           I64[Sp] = block_c72v_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c72n_info" {
     block_c72n_info:
         const _c72n;
         const 0;
         const 30;
 },
 _c72v() //  [R1]
         { []
         }
     {offset
       c72v: // global
           if (R1 & 7 == 1) goto c72C; else goto u73Y;
       c72C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c72F; else goto c72E;
       c72F: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c72E: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u73Y: // global
           Sp = Sp + 8;
           call _c73E() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c72v_info" {
     block_c72v_info:
         const _c72v;
         const 0;
         const 30;
 },
 _c72M() //  [R1]
         { []
         }
     {offset
       c72M: // global
           if (R1 & 7 < 2) goto c72V; else goto c738;
       c72V: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c71g() args: 0, res: 0, upd: 0;
       c738: // global
           I64[Sp] = block_c72Y_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c72M_info" {
     block_c72M_info:
         const _c72M;
         const 2;
         const 30;
 },
 _c72Y() //  [R1]
         { []
         }
     {offset
       c72Y: // global
           _s3LX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c732_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s3LX::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c72Y_info" {
     block_c72Y_info:
         const _c72Y;
         const 130;
         const 30;
 },
 _c732() //  [R1]
         { []
         }
     {offset
       c732: // global
           _s3M2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c736_info;
           R3 = _s3M2::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c732_info" {
     block_c732_info:
         const _c732;
         const 1;
         const 30;
 },
 _c736() //  [R1]
         { []
         }
     {offset
       c736: // global
           I64[Sp] = block_c73e_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c736_info" {
     block_c736_info:
         const _c736;
         const 0;
         const 30;
 },
 _c73e() //  [R1, R2]
         { []
         }
     {offset
       c73e: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c73f() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c73e_info" {
     block_c73e_info:
         const _c73e;
         const 0;
         const 30;
 },
 _c73f() //  []
         { []
         }
     {offset
       c73f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c73n; else goto c73m;
       c73n: // global
           HpAlloc = 24;
           I64[Sp] = block_c73f_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c73m: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c73j_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c73f_info" {
     block_c73f_info:
         const _c73f;
         const 130;
         const 30;
 },
 _c73j() //  [R1]
         { []
         }
     {offset
       c73j: // global
           if (R1 & 7 == 1) goto c73t; else goto u741;
       c73t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c73w; else goto c73v;
       c73w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c73v: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u741: // global
           Sp = Sp + 8;
           call _c73E() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c73j_info" {
     block_c73j_info:
         const _c73j;
         const 0;
         const 30;
 },
 _c73E() //  []
         { []
         }
     {offset
       c73E: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.834981584 UTC

[section ""data" . GHC.Integer.Type.testBitInteger_closure" {
     GHC.Integer.Type.testBitInteger_closure:
         const GHC.Integer.Type.testBitInteger_info;
 },
 GHC.Integer.Type.testBitInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c75Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Y; else goto c75Z;
       c75Y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.testBitInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c75Z: // global
           I64[Sp - 16] = block_c75O_info;
           R3 = R3;
           _s3Mc::P64 = R2;
           R2 = GHC.Integer.Type.oneInteger_closure+1;
           P64[Sp - 8] = _s3Mc::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.testBitInteger_info" {
     GHC.Integer.Type.testBitInteger_info:
         const GHC.Integer.Type.testBitInteger_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c75O() //  [R1]
         { []
         }
     {offset
       c75O: // global
           _s3Mc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c75T_info;
           R3 = R1;
           R2 = _s3Mc::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c75O_info" {
     block_c75O_info:
         const _c75O;
         const 1;
         const 30;
 },
 _c75T() //  [R1]
         { []
         }
     {offset
       c75T: // global
           I64[Sp] = block_c75X_info;
           R3 = GHC.Integer.Type.Naught_closure+3;
           R2 = R1;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c75T_info" {
     block_c75T_info:
         const _c75T;
         const 0;
         const 30;
 },
 _c75X() //  [R1]
         { []
         }
     {offset
       c75X: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c75X_info" {
     block_c75X_info:
         const _c75X;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.849691078 UTC

[section ""data" . GHC.Integer.Type.xorDigits_closure" {
     GHC.Integer.Type.xorDigits_closure:
         const GHC.Integer.Type.xorDigits_info;
 },
 GHC.Integer.Type.xorDigits_entry() //  [R2, R3]
         { []
         }
     {offset
       c76x: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c76y; else goto c76z;
       c76y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.xorDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c76z: // global
           I64[Sp - 16] = block_c76q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u775; else goto c76r;
       u775: // global
           call _c76q(R1) args: 0, res: 0, upd: 0;
       c76r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.xorDigits_info" {
     GHC.Integer.Type.xorDigits_info:
         const GHC.Integer.Type.xorDigits_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c76q() //  [R1]
         { []
         }
     {offset
       c76q: // global
           _s3Mi::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c76u; else goto c76v;
       c76u: // global
           I64[Sp - 16] = block_c76C_info;
           _s3Mj::P64 = R1;
           _s3Ml::P64 = P64[R1 + 7];
           _s3Mk::I64 = I64[R1 + 15];
           R1 = _s3Mi::P64;
           P64[Sp - 8] = _s3Ml::P64;
           I64[Sp] = _s3Mk::I64;
           P64[Sp + 8] = _s3Mj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u774; else goto c76E;
       u774: // global
           call _c76C(R1) args: 0, res: 0, upd: 0;
       c76E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c76v: // global
           R1 = _s3Mi::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c76q_info" {
     block_c76q_info:
         const _c76q;
         const 1;
         const 30;
 },
 _c76C() //  [R1]
         { []
         }
     {offset
       c76C: // global
           if (R1 & 7 == 1) goto c76S; else goto c76Z;
       c76S: // global
           _s3Ml::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c76I_info;
           R3 = P64[R1 + 7];
           R2 = _s3Ml::P64;
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c76Z: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c76C_info" {
     block_c76C_info:
         const _c76C;
         const 131;
         const 30;
 },
 _c76I() //  [R1]
         { []
         }
     {offset
       c76I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76V; else goto c76U;
       c76V: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c76U: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] ^ I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c76I_info" {
     block_c76I_info:
         const _c76I;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.870135401 UTC

[section ""data" . GHC.Integer.Type.xorInteger_closure" {
     GHC.Integer.Type.xorInteger_closure:
         const GHC.Integer.Type.xorInteger_info;
 },
 GHC.Integer.Type.xorInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c77J: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c77K; else goto u7a3;
       c77K: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.xorInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u7a3: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c77z() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.xorInteger_info" {
     GHC.Integer.Type.xorInteger_info:
         const GHC.Integer.Type.xorInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c77z() //  []
         { []
         }
     {offset
       c77z: // global
           _s3Mr::P64 = P64[Sp];
           I64[Sp] = block_c77C_info;
           R1 = _s3Mr::P64;
           if (R1 & 7 != 0) goto u7a9; else goto c77D;
       u7a9: // global
           call _c77C(R1) args: 0, res: 0, upd: 0;
       c77D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c77C() //  [R1]
         { []
         }
     {offset
       c77C: // global
           _s3Ms::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c77H; else goto c77G;
       c77H: // global
           R1 = _s3Ms::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c77G: // global
           I64[Sp] = block_c77O_info;
           _s3Mt::P64 = R1;
           R1 = _s3Ms::P64;
           P64[Sp + 8] = _s3Mt::P64;
           if (R1 & 7 != 0) goto u7aa; else goto c77Q;
       u7aa: // global
           call _c77O(R1) args: 0, res: 0, upd: 0;
       c77Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c77C_info" {
     block_c77C_info:
         const _c77C;
         const 1;
         const 30;
 },
 _c77O() //  [R1]
         { []
         }
     {offset
       c77O: // global
           _s3Mt::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c79S; else goto c77X;
       c79S: // global
           R1 = _s3Mt::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c77X: // global
           I64[Sp] = block_c77U_info;
           _s3Mu::P64 = R1;
           R1 = _s3Mt::P64;
           P64[Sp + 8] = _s3Mu::P64;
           if (R1 & 7 != 0) goto u7ac; else goto c77Y;
       u7ac: // global
           call _c77U(R1) args: 0, res: 0, upd: 0;
       c77Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c77O_info" {
     block_c77O_info:
         const _c77O;
         const 1;
         const 30;
 },
 _c77U() //  [R1]
         { []
         }
     {offset
       c77U: // global
           _s3Mu::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c785; else goto c79a;
       c785: // global
           I64[Sp] = block_c782_info;
           _s3Mw::P64 = P64[R1 + 7];
           R1 = _s3Mu::P64;
           P64[Sp + 8] = _s3Mw::P64;
           if (R1 & 7 != 0) goto u7ad; else goto c786;
       u7ad: // global
           call _c782(R1) args: 0, res: 0, upd: 0;
       c786: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c79a: // global
           I64[Sp - 8] = block_c798_info;
           _s3Mv::P64 = R1;
           _s3MN::P64 = P64[R1 + 6];
           R1 = _s3Mu::P64;
           P64[Sp] = _s3MN::P64;
           P64[Sp + 8] = _s3Mv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ae; else goto c79b;
       u7ae: // global
           call _c798(R1) args: 0, res: 0, upd: 0;
       c79b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c77U_info" {
     block_c77U_info:
         const _c77U;
         const 1;
         const 30;
 },
 _c782() //  [R1]
         { []
         }
     {offset
       c782: // global
           if (R1 & 7 < 2) goto c78d; else goto c78E;
       c78d: // global
           _s3Mw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c78a_info;
           R3 = P64[R1 + 7];
           R2 = _s3Mw::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c78E: // global
           I64[Sp] = block_c78y_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c782_info" {
     block_c782_info:
         const _c782;
         const 1;
         const 30;
 },
 _c78a() //  [R1]
         { []
         }
     {offset
       c78a: // global
           I64[Sp] = block_c78h_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c78a_info" {
     block_c78a_info:
         const _c78a;
         const 0;
         const 30;
 },
 _c78h() //  [R1]
         { []
         }
     {offset
       c78h: // global
           if (R1 & 7 == 1) goto c78o; else goto u7a4;
       c78o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c78r; else goto c78q;
       c78r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c78q: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7a4: // global
           Sp = Sp + 8;
           call _c79O() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c78h_info" {
     block_c78h_info:
         const _c78h;
         const 0;
         const 30;
 },
 _c78y() //  [R1]
         { []
         }
     {offset
       c78y: // global
           _s3Mw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c78C_info;
           R3 = R1;
           R2 = _s3Mw::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c78y_info" {
     block_c78y_info:
         const _c78y;
         const 1;
         const 30;
 },
 _c78C() //  [R1]
         { []
         }
     {offset
       c78C: // global
           I64[Sp] = block_c78J_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c78C_info" {
     block_c78C_info:
         const _c78C;
         const 0;
         const 30;
 },
 _c78J() //  [R1, R2]
         { []
         }
     {offset
       c78J: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c78K() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c78J_info" {
     block_c78J_info:
         const _c78J;
         const 0;
         const 30;
 },
 _c78K() //  []
         { []
         }
     {offset
       c78K: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c78S; else goto c78R;
       c78S: // global
           HpAlloc = 24;
           I64[Sp] = block_c78K_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c78R: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c78O_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c78K_info" {
     block_c78K_info:
         const _c78K;
         const 130;
         const 30;
 },
 _c78O() //  [R1]
         { []
         }
     {offset
       c78O: // global
           if (R1 & 7 == 1) goto c78Y; else goto u7a6;
       c78Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c791; else goto c790;
       c791: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c790: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7a6: // global
           Sp = Sp + 8;
           call _c79O() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c78O_info" {
     block_c78O_info:
         const _c78O;
         const 0;
         const 30;
 },
 _c798() //  [R1]
         { []
         }
     {offset
       c798: // global
           if (R1 & 7 < 2) goto c79h; else goto c79u;
       c79h: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c77z() args: 0, res: 0, upd: 0;
       c79u: // global
           I64[Sp] = block_c79k_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c798_info" {
     block_c798_info:
         const _c798;
         const 2;
         const 30;
 },
 _c79k() //  [R1]
         { []
         }
     {offset
       c79k: // global
           _s3MN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c79o_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s3MN::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c79k_info" {
     block_c79k_info:
         const _c79k;
         const 130;
         const 30;
 },
 _c79o() //  [R1]
         { []
         }
     {offset
       c79o: // global
           _s3MS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c79s_info;
           R3 = _s3MS::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c79o_info" {
     block_c79o_info:
         const _c79o;
         const 1;
         const 30;
 },
 _c79s() //  [R1]
         { []
         }
     {offset
       c79s: // global
           I64[Sp] = block_c79A_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c79s_info" {
     block_c79s_info:
         const _c79s;
         const 0;
         const 30;
 },
 _c79A() //  [R1]
         { []
         }
     {offset
       c79A: // global
           if (R1 & 7 == 1) goto c79H; else goto u7a8;
       c79H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c79K; else goto c79J;
       c79K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c79J: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7a8: // global
           Sp = Sp + 8;
           call _c79O() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c79A_info" {
     block_c79A_info:
         const _c79A;
         const 0;
         const 30;
 },
 _c79O() //  []
         { []
         }
     {offset
       c79O: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.912968819 UTC

[section ""cstring" . GHC.Integer.Type.$trModule4_bytes" {
     GHC.Integer.Type.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.915928204 UTC

[section ""data" . GHC.Integer.Type.$trModule3_closure" {
     GHC.Integer.Type.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.918262647 UTC

[section ""cstring" . GHC.Integer.Type.$trModule2_bytes" {
     GHC.Integer.Type.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.921909978 UTC

[section ""data" . GHC.Integer.Type.$trModule1_closure" {
     GHC.Integer.Type.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.924610764 UTC

[section ""data" . GHC.Integer.Type.$trModule_closure" {
     GHC.Integer.Type.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Type.$trModule3_closure+1;
         const GHC.Integer.Type.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.927022889 UTC

[section ""data" . $krep_r3Bp_closure" {
     $krep_r3Bp_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.930110096 UTC

[section ""data" . $krep1_r3Bq_closure" {
     $krep1_r3Bq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.934080528 UTC

[section ""cstring" . GHC.Integer.Type.$tcDigits2_bytes" {
     GHC.Integer.Type.$tcDigits2_bytes:
         I8[] [68,105,103,105,116,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.936911942 UTC

[section ""data" . GHC.Integer.Type.$tcDigits1_closure" {
     GHC.Integer.Type.$tcDigits1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcDigits2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.939688751 UTC

[section ""data" . GHC.Integer.Type.$tcDigits_closure" {
     GHC.Integer.Type.$tcDigits_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcDigits1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16647862651490579480;
         const 7069031713090282797;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.942181041 UTC

[section ""data" . GHC.Integer.Type.$tc'None1_closure" {
     GHC.Integer.Type.$tc'None1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcDigits_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.945015463 UTC

[section ""cstring" . GHC.Integer.Type.$tc'None3_bytes" {
     GHC.Integer.Type.$tc'None3_bytes:
         I8[] [39,78,111,110,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.948247486 UTC

[section ""data" . GHC.Integer.Type.$tc'None2_closure" {
     GHC.Integer.Type.$tc'None2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'None3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.951471815 UTC

[section ""data" . GHC.Integer.Type.$tc'None_closure" {
     GHC.Integer.Type.$tc'None_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'None2_closure+1;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const 903679638320298226;
         const 12977397153301278560;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.954812971 UTC

[section ""data" . $krep2_r3Br_closure" {
     $krep2_r3Br_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.958543085 UTC

[section ""data" . GHC.Integer.Type.$tc'Some1_closure" {
     GHC.Integer.Type.$tc'Some1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r3Bq_closure+1;
         const $krep2_r3Br_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.961643053 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Some3_bytes" {
     GHC.Integer.Type.$tc'Some3_bytes:
         I8[] [39,83,111,109,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.964709449 UTC

[section ""data" . GHC.Integer.Type.$tc'Some2_closure" {
     GHC.Integer.Type.$tc'Some2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Some3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.968078856 UTC

[section ""data" . GHC.Integer.Type.$tc'Some_closure" {
     GHC.Integer.Type.$tc'Some_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Some2_closure+1;
         const GHC.Integer.Type.$tc'Some1_closure+4;
         const 6045911439621864566;
         const 9702873355935012388;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.971799911 UTC

[section ""cstring" . GHC.Integer.Type.$tcInteger2_bytes" {
     GHC.Integer.Type.$tcInteger2_bytes:
         I8[] [73,110,116,101,103,101,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.975050228 UTC

[section ""data" . GHC.Integer.Type.$tcInteger1_closure" {
     GHC.Integer.Type.$tcInteger1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcInteger2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.978249503 UTC

[section ""data" . GHC.Integer.Type.$tcInteger_closure" {
     GHC.Integer.Type.$tcInteger_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcInteger1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12260413788024328428;
         const 9583620696682509916;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.981508184 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught1_closure" {
     GHC.Integer.Type.$tc'Naught1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.984893258 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Naught3_bytes" {
     GHC.Integer.Type.$tc'Naught3_bytes:
         I8[] [39,78,97,117,103,104,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.987678847 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught2_closure" {
     GHC.Integer.Type.$tc'Naught2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Naught3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.990661477 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught_closure" {
     GHC.Integer.Type.$tc'Naught_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Naught2_closure+1;
         const GHC.Integer.Type.$tc'Naught1_closure+1;
         const 7287704174224038176;
         const 776397532388787230;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.993415192 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative1_closure" {
     GHC.Integer.Type.$tc'Negative1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const GHC.Integer.Type.$tc'Naught1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.996448526 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Positive2_bytes" {
     GHC.Integer.Type.$tc'Positive2_bytes:
         I8[] [39,80,111,115,105,116,105,118,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:50.99934119 UTC

[section ""data" . GHC.Integer.Type.$tc'Positive1_closure" {
     GHC.Integer.Type.$tc'Positive1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Positive2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.002206808 UTC

[section ""data" . GHC.Integer.Type.$tc'Positive_closure" {
     GHC.Integer.Type.$tc'Positive_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Positive1_closure+1;
         const GHC.Integer.Type.$tc'Negative1_closure+4;
         const 6887932004110746796;
         const 9391890139750561935;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.005050233 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Negative3_bytes" {
     GHC.Integer.Type.$tc'Negative3_bytes:
         I8[] [39,78,101,103,97,116,105,118,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.008797927 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative2_closure" {
     GHC.Integer.Type.$tc'Negative2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Negative3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.011431287 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative_closure" {
     GHC.Integer.Type.$tc'Negative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Negative2_closure+1;
         const GHC.Integer.Type.$tc'Negative1_closure+4;
         const 4010847856516363452;
         const 15624358648337932456;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.014209123 UTC

[section ""cstring" . GHC.Integer.Type.$tcList2_bytes" {
     GHC.Integer.Type.$tcList2_bytes:
         I8[] [76,105,115,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.016775741 UTC

[section ""data" . GHC.Integer.Type.$tcList1_closure" {
     GHC.Integer.Type.$tcList1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcList2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.019619921 UTC

[section ""data" . GHC.Integer.Type.$tcList_closure" {
     GHC.Integer.Type.$tcList_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 732340346576824023;
         const 9653115931589988500;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.022078388 UTC

[section ""data" . $krep3_r3Bs_closure" {
     $krep3_r3Bs_closure:
         const :_con_info;
         const $krep_r3Bp_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.024327559 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil1_closure" {
     GHC.Integer.Type.$tc'Nil1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcList_closure+1;
         const $krep3_r3Bs_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.026977142 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Nil3_bytes" {
     GHC.Integer.Type.$tc'Nil3_bytes:
         I8[] [39,78,105,108]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.030069431 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil2_closure" {
     GHC.Integer.Type.$tc'Nil2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Nil3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.032627546 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil_closure" {
     GHC.Integer.Type.$tc'Nil_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Nil2_closure+1;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const 13538585131509945451;
         const 9366316088405446135;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.035079749 UTC

[section ""data" . $krep4_r3Bt_closure" {
     $krep4_r3Bt_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.037853312 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons1_closure" {
     GHC.Integer.Type.$tc'Cons1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r3Bp_closure+2;
         const $krep4_r3Bt_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.040985383 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Cons3_bytes" {
     GHC.Integer.Type.$tc'Cons3_bytes:
         I8[] [39,67,111,110,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.043609251 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons2_closure" {
     GHC.Integer.Type.$tc'Cons2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Cons3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.046187382 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons_closure" {
     GHC.Integer.Type.$tc'Cons_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Cons2_closure+1;
         const GHC.Integer.Type.$tc'Cons1_closure+4;
         const 3906777924842222150;
         const 5463288556346842885;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.0486853 UTC

[section ""cstring" . GHC.Integer.Type.$tcDigitsOnes2_bytes" {
     GHC.Integer.Type.$tcDigitsOnes2_bytes:
         I8[] [68,105,103,105,116,115,79,110,101,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.051496144 UTC

[section ""data" . GHC.Integer.Type.$tcDigitsOnes1_closure" {
     GHC.Integer.Type.$tcDigitsOnes1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcDigitsOnes2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.053845055 UTC

[section ""data" . GHC.Integer.Type.$tcDigitsOnes_closure" {
     GHC.Integer.Type.$tcDigitsOnes_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcDigitsOnes1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4554239703586147919;
         const 6957361150436389790;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.056351786 UTC

[section ""data" . $krep5_r3Bu_closure" {
     $krep5_r3Bu_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcDigitsOnes_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.058773383 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes1_closure" {
     GHC.Integer.Type.$tc'DigitsOnes1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const $krep5_r3Bu_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.06212021 UTC

[section ""cstring" . GHC.Integer.Type.$tc'DigitsOnes3_bytes" {
     GHC.Integer.Type.$tc'DigitsOnes3_bytes:
         I8[] [39,68,105,103,105,116,115,79,110,101,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.064255869 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes2_closure" {
     GHC.Integer.Type.$tc'DigitsOnes2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'DigitsOnes3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.066581826 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes_closure" {
     GHC.Integer.Type.$tc'DigitsOnes_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'DigitsOnes2_closure+1;
         const GHC.Integer.Type.$tc'DigitsOnes1_closure+4;
         const 15211110739657495015;
         const 1682512192113792266;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.069607675 UTC

[section ""data" . GHC.Integer.Type.encodeDouble#_closure" {
     GHC.Integer.Type.encodeDouble#_closure:
         const GHC.Integer.Type.encodeDouble#_info;
 },
 GHC.Integer.Type.encodeDouble#_entry() //  [R2, R3]
         { []
         }
     {offset
       c7cK: // global
           _c7cJ::I64 = R3;
           (_s3N2::F64) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeDouble(R2, _c7cJ::I64);
           D1 = _s3N2::F64;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.encodeDouble#_info" {
     GHC.Integer.Type.encodeDouble#_info:
         const GHC.Integer.Type.encodeDouble#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.076147164 UTC

[section ""data" . f_r3Bv_closure" {
     f_r3Bv_closure:
         const f_r3Bv_info;
 },
 f_r3Bv_slow() //  [R1]
         { []
         }
     {offset
       c7cU: // global
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           D1 = F64[Sp];
           R1 = R1;
           Sp = Sp + 24;
           call f_r3Bv_entry(R3, R2, D1, R1) args: 8, res: 0, upd: 8;
     }
 },
 f_r3Bv_entry() //  [R2, R3, D1]
         { []
         }
     {offset
       c7d5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7d6; else goto u7dl;
       c7d6: // global
           R1 = f_r3Bv_closure;
           F64[Sp - 24] = D1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       u7dl: // global
           F64[Sp - 24] = D1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _c7cV() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . f_r3Bv_info" {
     f_r3Bv_info:
         const f_r3Bv_entry;
         const 0;
         const 14;
         const 12884901888;
         const 0;
         const 323;
         const f_r3Bv_slow;
 },
 _c7cV() //  []
         { []
         }
     {offset
       c7cV: // global
           I64[Sp - 8] = block_c7cY_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7dn; else goto c7cZ;
       u7dn: // global
           call _c7cY(R1) args: 0, res: 0, upd: 0;
       c7cZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7cY() //  [R1]
         { []
         }
     {offset
       c7cY: // global
           _s3N3::F64 = F64[Sp + 8];
           if (R1 & 7 == 1) goto c7d2; else goto c7d3;
       c7d2: // global
           _s3N5::I64 = I64[Sp + 24];
           _s3N8::P64 = P64[R1 + 7];
           (_s3Nc::F64) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeDouble(I64[R1 + 15], _s3N5::I64);
           F64[Sp + 8] = %MO_F_Add_W64(_s3N3::F64, _s3Nc::F64);
           P64[Sp + 16] = _s3N8::P64;
           I64[Sp + 24] = _s3N5::I64 + 64;
           Sp = Sp + 8;
           call _c7cV() args: 0, res: 0, upd: 0;
       c7d3: // global
           D1 = _s3N3::F64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7cY_info" {
     block_c7cY_info:
         const _c7cY;
         const 451;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.0888161 UTC

[section ""data" . GHC.Integer.Type.encodeDoubleInteger_closure" {
     GHC.Integer.Type.encodeDoubleInteger_closure:
         const GHC.Integer.Type.encodeDoubleInteger_info;
 },
 GHC.Integer.Type.encodeDoubleInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c7dV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7dW; else goto c7dX;
       c7dW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.encodeDoubleInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7dX: // global
           I64[Sp - 16] = block_c7dN_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7eh; else goto c7dO;
       u7eh: // global
           call _c7dN(R1) args: 0, res: 0, upd: 0;
       c7dO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.encodeDoubleInteger_info" {
     GHC.Integer.Type.encodeDoubleInteger_info:
         const GHC.Integer.Type.encodeDoubleInteger_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c7dN() //  [R1]
         { []
         }
     {offset
       c7dN: // global
           _c7dU::P64 = R1 & 7;
           if (_c7dU::P64 < 3) goto u7eg; else goto c7dT;
       u7eg: // global
           _s3Ng::I64 = I64[Sp + 8];
           if (_c7dU::P64 < 2) goto c7dR; else goto c7dS;
       c7dR: // global
           R3 = _s3Ng::I64;
           R2 = P64[R1 + 7];
           D1 = 0.0 :: W64;
           Sp = Sp + 16;
           call f_r3Bv_entry(R3, R2, D1) args: 8, res: 0, upd: 8;
       c7dS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7eb; else goto c7ea;
       c7eb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ea: // global
           _s3Nj::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3Nj::P64;
           I64[Sp + 8] = block_c7e4_info;
           R3 = _s3Ng::I64;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       c7dT: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7dN_info" {
     block_c7dN_info:
         const _c7dN;
         const 65;
         const 30;
 },
 _c7e4() //  [D1]
         { []
         }
     {offset
       c7e4: // global
           D1 = %MO_F_Neg_W64(D1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7e4_info" {
     block_c7e4_info:
         const _c7e4;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.098905104 UTC

[section ""data" . GHC.Integer.Type.encodeFloat#_closure" {
     GHC.Integer.Type.encodeFloat#_closure:
         const GHC.Integer.Type.encodeFloat#_info;
 },
 GHC.Integer.Type.encodeFloat#_entry() //  [R2, R3]
         { []
         }
     {offset
       c7eG: // global
           _c7eF::I64 = R3;
           (_s3Nr::F32) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeFloat(R2, _c7eF::I64);
           F1 = _s3Nr::F32;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.encodeFloat#_info" {
     GHC.Integer.Type.encodeFloat#_info:
         const GHC.Integer.Type.encodeFloat#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.108207652 UTC

[section ""data" . f1_r3Bw_closure" {
     f1_r3Bw_closure:
         const f1_r3Bw_info;
 },
 f1_r3Bw_slow() //  [R1]
         { []
         }
     {offset
       c7eQ: // global
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           F1 = F32[Sp];
           R1 = R1;
           Sp = Sp + 24;
           call f1_r3Bw_entry(R3, R2, F1, R1) args: 8, res: 0, upd: 8;
     }
 },
 f1_r3Bw_entry() //  [R2, R3, F1]
         { []
         }
     {offset
       c7f1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7f2; else goto u7fh;
       c7f2: // global
           R1 = f1_r3Bw_closure;
           F32[Sp - 24] = F1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       u7fh: // global
           F32[Sp - 24] = F1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _c7eR() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . f1_r3Bw_info" {
     f1_r3Bw_info:
         const f1_r3Bw_entry;
         const 0;
         const 14;
         const 12884901888;
         const 0;
         const 323;
         const f1_r3Bw_slow;
 },
 _c7eR() //  []
         { []
         }
     {offset
       c7eR: // global
           I64[Sp - 8] = block_c7eU_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7fj; else goto c7eV;
       u7fj: // global
           call _c7eU(R1) args: 0, res: 0, upd: 0;
       c7eV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7eU() //  [R1]
         { []
         }
     {offset
       c7eU: // global
           _s3Ns::F32 = F32[Sp + 8];
           if (R1 & 7 == 1) goto c7eY; else goto c7eZ;
       c7eY: // global
           _s3Nu::I64 = I64[Sp + 24];
           _s3Nx::P64 = P64[R1 + 7];
           (_s3NB::F32) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeFloat(I64[R1 + 15], _s3Nu::I64);
           F32[Sp + 8] = %MO_F_Add_W32(_s3Ns::F32, _s3NB::F32);
           P64[Sp + 16] = _s3Nx::P64;
           I64[Sp + 24] = _s3Nu::I64 + 64;
           Sp = Sp + 8;
           call _c7eR() args: 0, res: 0, upd: 0;
       c7eZ: // global
           F1 = _s3Ns::F32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7eU_info" {
     block_c7eU_info:
         const _c7eU;
         const 451;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.119793743 UTC

[section ""data" . GHC.Integer.Type.encodeFloatInteger_closure" {
     GHC.Integer.Type.encodeFloatInteger_closure:
         const GHC.Integer.Type.encodeFloatInteger_info;
 },
 GHC.Integer.Type.encodeFloatInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c7fR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7fS; else goto c7fT;
       c7fS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.encodeFloatInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7fT: // global
           I64[Sp - 16] = block_c7fJ_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7gd; else goto c7fK;
       u7gd: // global
           call _c7fJ(R1) args: 0, res: 0, upd: 0;
       c7fK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.encodeFloatInteger_info" {
     GHC.Integer.Type.encodeFloatInteger_info:
         const GHC.Integer.Type.encodeFloatInteger_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c7fJ() //  [R1]
         { []
         }
     {offset
       c7fJ: // global
           _c7fQ::P64 = R1 & 7;
           if (_c7fQ::P64 < 3) goto u7gc; else goto c7fP;
       u7gc: // global
           _s3NF::I64 = I64[Sp + 8];
           if (_c7fQ::P64 < 2) goto c7fN; else goto c7fO;
       c7fN: // global
           R3 = _s3NF::I64;
           R2 = P64[R1 + 7];
           F1 = 0.0 :: W32;
           Sp = Sp + 16;
           call f1_r3Bw_entry(R3, R2, F1) args: 8, res: 0, upd: 8;
       c7fO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7g7; else goto c7g6;
       c7g7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7g6: // global
           _s3NI::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s3NI::P64;
           I64[Sp + 8] = block_c7g0_info;
           R3 = _s3NF::I64;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
       c7fP: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7fJ_info" {
     block_c7fJ_info:
         const _c7fJ;
         const 65;
         const 30;
 },
 _c7g0() //  [F1]
         { []
         }
     {offset
       c7g0: // global
           F1 = %MO_F_Neg_W32(F1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7g0_info" {
     block_c7g0_info:
         const _c7g0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.132060814 UTC

[section ""data" . GHC.Integer.Type.Positive_closure" {
     GHC.Integer.Type.Positive_closure:
         const GHC.Integer.Type.Positive_info;
 },
 GHC.Integer.Type.Positive_entry() //  [R2]
         { []
         }
     {offset
       c7gA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7gE; else goto c7gD;
       c7gE: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Type.Positive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7gD: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Positive_info" {
     GHC.Integer.Type.Positive_info:
         const GHC.Integer.Type.Positive_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.137413734 UTC

[section ""data" . GHC.Integer.Type.Negative_closure" {
     GHC.Integer.Type.Negative_closure:
         const GHC.Integer.Type.Negative_info;
 },
 GHC.Integer.Type.Negative_entry() //  [R2]
         { []
         }
     {offset
       c7gP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7gT; else goto c7gS;
       c7gT: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Type.Negative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7gS: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Negative_info" {
     GHC.Integer.Type.Negative_info:
         const GHC.Integer.Type.Negative_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.141801735 UTC

[section ""data" . GHC.Integer.Type.Naught_closure" {
     GHC.Integer.Type.Naught_closure:
         const GHC.Integer.Type.Naught_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.144308056 UTC

[section ""data" . GHC.Integer.Type.Nil_closure" {
     GHC.Integer.Type.Nil_closure:
         const GHC.Integer.Type.Nil_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.147797053 UTC

[section ""data" . GHC.Integer.Type.Cons_closure" {
     GHC.Integer.Type.Cons_closure:
         const GHC.Integer.Type.Cons_info;
 },
 GHC.Integer.Type.Cons_entry() //  [R2, R3]
         { []
         }
     {offset
       c7h6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7ha; else goto c7h9;
       c7ha: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.Cons_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7h9: // global
           I64[Hp - 16] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Cons_info" {
     GHC.Integer.Type.Cons_info:
         const GHC.Integer.Type.Cons_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.153409881 UTC

[section ""data" . GHC.Integer.Type.Some_closure" {
     GHC.Integer.Type.Some_closure:
         const GHC.Integer.Type.Some_info;
 },
 GHC.Integer.Type.Some_entry() //  [R2, R3]
         { []
         }
     {offset
       c7hl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7hp; else goto c7ho;
       c7hp: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.Some_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ho: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R3;
           I64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Some_info" {
     GHC.Integer.Type.Some_info:
         const GHC.Integer.Type.Some_entry;
         const 0;
         const 14;
         const 8589934605;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.158125109 UTC

[section ""data" . GHC.Integer.Type.None_closure" {
     GHC.Integer.Type.None_closure:
         const GHC.Integer.Type.None_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.160457225 UTC

[section ""cstring" . i5L8_str" {
     i5L8_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,80,111,115,105,116,105,118,101]
 },
 GHC.Integer.Type.Positive_con_entry() //  [R1]
         { []
         }
     {offset
       c7hw: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Positive_con_info" {
     GHC.Integer.Type.Positive_con_info:
         const GHC.Integer.Type.Positive_con_entry;
         const 1;
         const 2;
         const i5L8_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.164740942 UTC

[section ""cstring" . i5La_str" {
     i5La_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,101,103,97,116,105,118,101]
 },
 GHC.Integer.Type.Negative_con_entry() //  [R1]
         { []
         }
     {offset
       c7hC: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Negative_con_info" {
     GHC.Integer.Type.Negative_con_info:
         const GHC.Integer.Type.Negative_con_entry;
         const 1;
         const 4294967298;
         const i5La_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.168785742 UTC

[section ""cstring" . i5Lc_str" {
     i5Lc_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,97,117,103,104,116]
 },
 GHC.Integer.Type.Naught_con_entry() //  [R1]
         { []
         }
     {offset
       c7hI: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Naught_con_info" {
     GHC.Integer.Type.Naught_con_info:
         const GHC.Integer.Type.Naught_con_entry;
         const 4294967296;
         const 8589934595;
         const i5Lc_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.173138397 UTC

[section ""cstring" . i5Le_str" {
     i5Le_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,105,108]
 },
 GHC.Integer.Type.Nil_con_entry() //  [R1]
         { []
         }
     {offset
       c7hO: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Nil_con_info" {
     GHC.Integer.Type.Nil_con_info:
         const GHC.Integer.Type.Nil_con_entry;
         const 4294967296;
         const 3;
         const i5Le_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.17713319 UTC

[section ""cstring" . i5Lg_str" {
     i5Lg_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,67,111,110,115]
 },
 GHC.Integer.Type.Cons_con_entry() //  [R1]
         { []
         }
     {offset
       c7hU: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Cons_con_info" {
     GHC.Integer.Type.Cons_con_info:
         const GHC.Integer.Type.Cons_con_entry;
         const 2;
         const 4294967300;
         const i5Lg_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.181139842 UTC

[section ""cstring" . i5Li_str" {
     i5Li_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,83,111,109,101]
 },
 GHC.Integer.Type.Some_con_entry() //  [R1]
         { []
         }
     {offset
       c7i0: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Some_con_info" {
     GHC.Integer.Type.Some_con_info:
         const GHC.Integer.Type.Some_con_entry;
         const 4294967297;
         const 5;
         const i5Li_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.185738152 UTC

[section ""cstring" . i5Lk_str" {
     i5Lk_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,111,110,101]
 },
 GHC.Integer.Type.None_con_entry() //  [R1]
         { []
         }
     {offset
       c7i6: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.None_con_info" {
     GHC.Integer.Type.None_con_info:
         const GHC.Integer.Type.None_con_entry;
         const 4294967296;
         const 4294967299;
         const i5Lk_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:51.191283976 UTC

[section ""relreadonly" . S3Xx_srt" {
     S3Xx_srt:
         const GHC.Integer.Type.plusPositive_addWithCarry_closure;
         const lvl_r3Bo_closure;
         const GHC.Integer.Type.timesDigit_closure;
         const GHC.Integer.Type.timesPositive_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const GHC.Integer.Type.complementInteger_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Integer.Type.modInteger_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:54.948965689 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:53:54.951436668 UTC

[section ""data" . GHC.Integer.Type.$WPositive_closure" {
     GHC.Integer.Type.$WPositive_closure:
         const GHC.Integer.Type.$WPositive_info;
 },
 GHC.Integer.Type.$WPositive_entry() //  [R2]
         { []
         }
     {offset
       c7ux: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7uB; else goto c7uC;
       c7uB: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$WPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7uC: // global
           I64[Sp - 8] = block_c7uu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7uG; else goto c7uv;
       u7uG: // global
           call _c7uu(R1) args: 0, res: 0, upd: 0;
       c7uv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.$WPositive_info" {
     GHC.Integer.Type.$WPositive_info:
         const GHC.Integer.Type.$WPositive_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7uu() //  [R1]
         { []
         }
     {offset
       c7uu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7uF; else goto c7uE;
       c7uF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7uE: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7uu_info" {
     block_c7uu_info:
         const _c7uu;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:54.958761844 UTC

[section ""data" . GHC.Integer.Type.$WNegative_closure" {
     GHC.Integer.Type.$WNegative_closure:
         const GHC.Integer.Type.$WNegative_info;
 },
 GHC.Integer.Type.$WNegative_entry() //  [R2]
         { []
         }
     {offset
       c7v0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7v4; else goto c7v5;
       c7v4: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$WNegative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7v5: // global
           I64[Sp - 8] = block_c7uX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7v9; else goto c7uY;
       u7v9: // global
           call _c7uX(R1) args: 0, res: 0, upd: 0;
       c7uY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.$WNegative_info" {
     GHC.Integer.Type.$WNegative_info:
         const GHC.Integer.Type.$WNegative_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7uX() //  [R1]
         { []
         }
     {offset
       c7uX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7v8; else goto c7v7;
       c7v8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7v7: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7uX_info" {
     block_c7uX_info:
         const _c7uX;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:54.966278019 UTC

[section ""data" . GHC.Integer.Type.$WSome_closure" {
     GHC.Integer.Type.$WSome_closure:
         const GHC.Integer.Type.$WSome_info;
 },
 GHC.Integer.Type.$WSome_entry() //  [R2, R3]
         { []
         }
     {offset
       c7vt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7vx; else goto c7vy;
       c7vx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$WSome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7vy: // global
           I64[Sp - 16] = block_c7vq_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7vC; else goto c7vr;
       u7vC: // global
           call _c7vq(R1) args: 0, res: 0, upd: 0;
       c7vr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.$WSome_info" {
     GHC.Integer.Type.$WSome_info:
         const GHC.Integer.Type.$WSome_entry;
         const 0;
         const 14;
         const 8589934605;
 },
 _c7vq() //  [R1]
         { []
         }
     {offset
       c7vq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7vB; else goto c7vA;
       c7vB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7vA: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7vq_info" {
     block_c7vq_info:
         const _c7vq;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:54.972802431 UTC

[section ""data" . GHC.Integer.Type.errorPositive_closure" {
     GHC.Integer.Type.errorPositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 47;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:54.975516813 UTC

[section ""data" . GHC.Integer.Type.errorInteger_closure" {
     GHC.Integer.Type.errorInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.errorPositive_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:54.97957793 UTC

[section ""data" . GHC.Integer.Type.wordToInteger_closure" {
     GHC.Integer.Type.wordToInteger_closure:
         const GHC.Integer.Type.wordToInteger_info;
 },
 GHC.Integer.Type.wordToInteger_entry() //  [R2]
         { []
         }
     {offset
       c7w0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7w4; else goto c7w3;
       c7w4: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Integer.Type.wordToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7w3: // global
           if (R2 == 0) goto c7vZ; else goto c7vY;
       c7vZ: // global
           Hp = Hp - 40;
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7vY: // global
           I64[Hp - 32] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 24] = GHC.Integer.Type.None_closure+2;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.wordToInteger_info" {
     GHC.Integer.Type.wordToInteger_info:
         const GHC.Integer.Type.wordToInteger_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:54.987044719 UTC

[section ""data" . GHC.Integer.Type.integerToWord_closure" {
     GHC.Integer.Type.integerToWord_closure:
         const GHC.Integer.Type.integerToWord_info;
 },
 GHC.Integer.Type.integerToWord_entry() //  [R2]
         { []
         }
     {offset
       c7wu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7wv; else goto c7ww;
       c7wv: // global
           R2 = R2;
           R1 = GHC.Integer.Type.integerToWord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ww: // global
           I64[Sp - 8] = block_c7wm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7xe; else goto c7wn;
       u7xe: // global
           call _c7wm(R1) args: 0, res: 0, upd: 0;
       c7wn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.integerToWord_info" {
     GHC.Integer.Type.integerToWord_info:
         const GHC.Integer.Type.integerToWord_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7wm() //  [R1]
         { []
         }
     {offset
       c7wm: // global
           _c7wt::P64 = R1 & 7;
           if (_c7wt::P64 < 3) goto u7x7; else goto u7x8;
       u7x7: // global
           if (_c7wt::P64 < 2) goto c7wq; else goto c7wr;
       c7wq: // global
           I64[Sp] = block_c7wz_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u7xb; else goto c7wB;
       u7xb: // global
           call _c7wz(R1) args: 0, res: 0, upd: 0;
       c7wB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7wr: // global
           I64[Sp] = block_c7wO_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u7xc; else goto c7wQ;
       u7xc: // global
           call _c7wO(R1) args: 0, res: 0, upd: 0;
       c7wQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u7x8: // global
           Sp = Sp + 8;
           call _c7ws() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7wm_info" {
     block_c7wm_info:
         const _c7wm;
         const 0;
         const 30;
 },
 _c7wz() //  [R1]
         { []
         }
     {offset
       c7wz: // global
           if (R1 & 7 == 1) goto c7wH; else goto u7x9;
       c7wH: // global
           R1 = I64[R1 + 15];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7x9: // global
           Sp = Sp + 8;
           call _c7ws() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7wz_info" {
     block_c7wz_info:
         const _c7wz;
         const 0;
         const 30;
 },
 _c7wO() //  [R1]
         { []
         }
     {offset
       c7wO: // global
           if (R1 & 7 == 1) goto c7wX; else goto u7xa;
       c7wX: // global
           R1 = 0 - I64[R1 + 15];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7xa: // global
           Sp = Sp + 8;
           call _c7ws() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7wO_info" {
     block_c7wO_info:
         const _c7wO;
         const 0;
         const 30;
 },
 _c7ws() //  []
         { []
         }
     {offset
       c7ws: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:54.998599073 UTC

[section ""data" . GHC.Integer.Type.integerToInt_closure" {
     GHC.Integer.Type.integerToInt_closure:
         const GHC.Integer.Type.integerToInt_info;
 },
 GHC.Integer.Type.integerToInt_entry() //  [R2]
         { []
         }
     {offset
       c7xT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7xX; else goto c7xY;
       c7xX: // global
           R2 = R2;
           R1 = GHC.Integer.Type.integerToInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7xY: // global
           I64[Sp - 8] = block_c7xR_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.integerToInt_info" {
     GHC.Integer.Type.integerToInt_info:
         const GHC.Integer.Type.integerToInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7xR() //  [R1]
         { []
         }
     {offset
       c7xR: // global
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7xR_info" {
     block_c7xR_info:
         const _c7xR;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.004406399 UTC

[section ""data" . GHC.Integer.Type.hashInteger_closure" {
     GHC.Integer.Type.hashInteger_closure:
         const GHC.Integer.Type.hashInteger_info;
 },
 GHC.Integer.Type.hashInteger_entry() //  [R2]
         { []
         }
     {offset
       c7ye: // global
           R2 = R2;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.hashInteger_info" {
     GHC.Integer.Type.hashInteger_info:
         const GHC.Integer.Type.hashInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.009828139 UTC

[section ""data" . GHC.Integer.Type.flipBitsDigits_closure" {
     GHC.Integer.Type.flipBitsDigits_closure:
         const GHC.Integer.Type.flipBitsDigits_info;
 },
 GHC.Integer.Type.flipBitsDigits_entry() //  [R2]
         { []
         }
     {offset
       c7yw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7yx; else goto c7yy;
       c7yx: // global
           R2 = R2;
           R1 = GHC.Integer.Type.flipBitsDigits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7yy: // global
           I64[Sp - 8] = block_c7yp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7yQ; else goto c7yq;
       u7yQ: // global
           call _c7yp(R1) args: 0, res: 0, upd: 0;
       c7yq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.flipBitsDigits_info" {
     GHC.Integer.Type.flipBitsDigits_info:
         const GHC.Integer.Type.flipBitsDigits_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7yp() //  [R1]
         { []
         }
     {offset
       c7yp: // global
           if (R1 & 7 == 1) goto c7yt; else goto c7yu;
       c7yt: // global
           I64[Sp - 8] = block_c7yB_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
       c7yu: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7yp_info" {
     block_c7yp_info:
         const _c7yp;
         const 0;
         const 30;
 },
 _c7yB() //  [R1]
         { []
         }
     {offset
       c7yB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7yM; else goto c7yL;
       c7yM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7yL: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = ~I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7yB_info" {
     block_c7yB_info:
         const _c7yB;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.021199214 UTC

[section ""data" . GHC.Integer.Type.flipBits1_closure" {
     GHC.Integer.Type.flipBits1_closure:
         const GHC.Integer.Type.flipBits1_info;
 },
 GHC.Integer.Type.flipBits1_entry() //  [R2]
         { []
         }
     {offset
       c7zg: // global
           R2 = R2;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.flipBits1_info" {
     GHC.Integer.Type.flipBits1_info:
         const GHC.Integer.Type.flipBits1_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.02708841 UTC

[section ""data" . GHC.Integer.Type.flipBits_closure" {
     GHC.Integer.Type.flipBits_closure:
         const GHC.Integer.Type.flipBits_info;
 },
 GHC.Integer.Type.flipBits_entry() //  [R2]
         { []
         }
     {offset
       c7zr: // global
           R2 = R2;
           call GHC.Integer.Type.flipBits1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.flipBits_info" {
     GHC.Integer.Type.flipBits_info:
         const GHC.Integer.Type.flipBits_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.033609939 UTC

[section ""data" . GHC.Integer.Type.negateInteger_closure" {
     GHC.Integer.Type.negateInteger_closure:
         const GHC.Integer.Type.negateInteger_info;
 },
 GHC.Integer.Type.negateInteger_entry() //  [R2]
         { []
         }
     {offset
       c7zK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7zL; else goto c7zM;
       c7zL: // global
           R2 = R2;
           R1 = GHC.Integer.Type.negateInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7zM: // global
           I64[Sp - 8] = block_c7zC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7A3; else goto c7zD;
       u7A3: // global
           call _c7zC(R1) args: 0, res: 0, upd: 0;
       c7zD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.negateInteger_info" {
     GHC.Integer.Type.negateInteger_info:
         const GHC.Integer.Type.negateInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7zC() //  [R1]
         { []
         }
     {offset
       c7zC: // global
           _c7zJ::P64 = R1 & 7;
           if (_c7zJ::P64 < 3) goto u7A2; else goto c7zI;
       u7A2: // global
           if (_c7zJ::P64 < 2) goto c7zG; else goto c7zH;
       c7zG: // global
           Hp = Hp + 16;
           _s7iH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c7zY; else goto c7zR;
       c7zR: // global
           _s7iI::P64 = P64[_s7iH::P64 + 7];
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = _s7iI::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7zH: // global
           Hp = Hp + 16;
           _s7iH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c7zY; else goto c7zX;
       c7zY: // global
           HpAlloc = 16;
           R1 = _s7iH::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7zX: // global
           _s7iJ::P64 = P64[_s7iH::P64 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s7iJ::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7zI: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7zC_info" {
     block_c7zC_info:
         const _c7zC;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.041432354 UTC

[section ""data" . GHC.Integer.Type.smallInteger_closure" {
     GHC.Integer.Type.smallInteger_closure:
         const GHC.Integer.Type.smallInteger_info;
 },
 GHC.Integer.Type.smallInteger_entry() //  [R2]
         { []
         }
     {offset
       c7At: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Au; else goto c7Av;
       c7Au: // global
           R2 = R2;
           R1 = GHC.Integer.Type.smallInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Av: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c7Ar; else goto c7As;
       c7Ar: // global
           I64[Sp - 8] = block_c7AD_info;
           R2 = -R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c7As: // global
           R2 = R2;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.smallInteger_info" {
     GHC.Integer.Type.smallInteger_info:
         const GHC.Integer.Type.smallInteger_entry;
         const 0;
         const 14;
         const 4294967300;
 },
 _c7AD() //  [R1]
         { []
         }
     {offset
       c7AD: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7AD_info" {
     block_c7AD_info:
         const _c7AD;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.049184999 UTC

[section ""data" . GHC.Integer.Type.decodeFloatInteger_closure" {
     GHC.Integer.Type.decodeFloatInteger_closure:
         const GHC.Integer.Type.decodeFloatInteger_info;
 },
 sat_s7iU_entry() //  [R1]
         { []
         }
     {offset
       c7B5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7B6; else goto c7B7;
       c7B6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7B7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7iU_info" {
     sat_s7iU_info:
         const sat_s7iU_entry;
         const 4294967296;
         const 17;
 },
 GHC.Integer.Type.decodeFloatInteger_entry() //  [F1]
         { []
         }
     {offset
       c7B8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7B9; else goto c7Ba;
       c7B9: // global
           F1 = F1;
           R1 = GHC.Integer.Type.decodeFloatInteger_closure;
           call (stg_gc_fun)(F1, R1) args: 8, res: 0, upd: 8;
       c7Ba: // global
           I64[Sp - 8] = block_c7AX_info;
           F1 = F1;
           Sp = Sp - 8;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.decodeFloatInteger_info" {
     GHC.Integer.Type.decodeFloatInteger_info:
         const GHC.Integer.Type.decodeFloatInteger_entry;
         const 0;
         const 14;
         const 4294967302;
 },
 _c7AX() //  [R1, R2]
         { []
         }
     {offset
       c7AX: // global
           I64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c7AY() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7AX_info" {
     block_c7AX_info:
         const _c7AX;
         const 0;
         const 30;
 },
 _c7AY() //  []
         { []
         }
     {offset
       c7AY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Bd; else goto c7Bc;
       c7Bd: // global
           HpAlloc = 24;
           I64[Sp] = block_c7AY_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7Bc: // global
           I64[Hp - 16] = sat_s7iU_info;
           I64[Hp] = I64[Sp + 16];
           R2 = I64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7AY_info" {
     block_c7AY_info:
         const _c7AY;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.059950015 UTC

[section ""data" . GHC.Integer.Type.absInteger_closure" {
     GHC.Integer.Type.absInteger_closure:
         const GHC.Integer.Type.absInteger_info;
 },
 GHC.Integer.Type.absInteger_entry() //  [R2]
         { []
         }
     {offset
       c7BM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7BN; else goto c7BO;
       c7BN: // global
           R2 = R2;
           R1 = GHC.Integer.Type.absInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7BO: // global
           I64[Sp - 8] = block_c7BF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7BY; else goto c7BG;
       u7BY: // global
           call _c7BF(R1) args: 0, res: 0, upd: 0;
       c7BG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.absInteger_info" {
     GHC.Integer.Type.absInteger_info:
         const GHC.Integer.Type.absInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7BF() //  [R1]
         { []
         }
     {offset
       c7BF: // global
           if (R1 & 7 == 2) goto c7BK; else goto c7BJ;
       c7BK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7BX; else goto c7BW;
       c7BX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7BW: // global
           _s7iX::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s7iX::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7BJ: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7BF_info" {
     block_c7BF_info:
         const _c7BF;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.06654556 UTC

[section ""data" . GHC.Integer.Type.onePositive_closure" {
     GHC.Integer.Type.onePositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.068560164 UTC

[section ""data" . GHC.Integer.Type.negativeOneInteger_closure" {
     GHC.Integer.Type.negativeOneInteger_closure:
         const GHC.Integer.Type.Negative_con_info;
         const GHC.Integer.Type.onePositive_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.070720267 UTC

[section ""data" . GHC.Integer.Type.oneInteger_closure" {
     GHC.Integer.Type.oneInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.onePositive_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.074322244 UTC

[section ""data" . GHC.Integer.Type.signumInteger_closure" {
     GHC.Integer.Type.signumInteger_closure:
         const GHC.Integer.Type.signumInteger_info;
 },
 GHC.Integer.Type.signumInteger_entry() //  [R2]
         { []
         }
     {offset
       c7Cu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Cv; else goto c7Cw;
       c7Cv: // global
           R2 = R2;
           R1 = GHC.Integer.Type.signumInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Cw: // global
           I64[Sp - 8] = block_c7Cm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7CH; else goto c7Cn;
       u7CH: // global
           call _c7Cm(R1) args: 0, res: 0, upd: 0;
       c7Cn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.signumInteger_info" {
     GHC.Integer.Type.signumInteger_info:
         const GHC.Integer.Type.signumInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7Cm() //  [R1]
         { []
         }
     {offset
       c7Cm: // global
           _c7Ct::P64 = R1 & 7;
           if (_c7Ct::P64 < 3) goto u7CG; else goto c7Cs;
       u7CG: // global
           if (_c7Ct::P64 < 2) goto c7Cq; else goto c7Cr;
       c7Cq: // global
           R1 = GHC.Integer.Type.oneInteger_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Cr: // global
           R1 = GHC.Integer.Type.negativeOneInteger_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Cs: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Cm_info" {
     block_c7Cm_info:
         const _c7Cm;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.082803443 UTC

[section ""data" . GHC.Integer.Type.halfBoundUp_closure" {
     GHC.Integer.Type.halfBoundUp_closure:
         const GHC.Integer.Type.halfBoundUp_info;
 },
 GHC.Integer.Type.halfBoundUp_entry() //  [R2]
         { []
         }
     {offset
       c7D3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7D4; else goto c7D5;
       c7D4: // global
           R2 = R2;
           R1 = GHC.Integer.Type.halfBoundUp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7D5: // global
           I64[Sp - 8] = block_c7D0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7D9; else goto c7D1;
       u7D9: // global
           call _c7D0() args: 0, res: 0, upd: 0;
       c7D1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.halfBoundUp_info" {
     GHC.Integer.Type.halfBoundUp_info:
         const GHC.Integer.Type.halfBoundUp_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7D0() //  []
         { []
         }
     {offset
       c7D0: // global
           R1 = 9223372036854775808;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7D0_info" {
     block_c7D0_info:
         const _c7D0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.092728324 UTC

[section ""data" . GHC.Integer.Type.fullBound_closure" {
     GHC.Integer.Type.fullBound_closure:
         const GHC.Integer.Type.fullBound_info;
 },
 GHC.Integer.Type.fullBound_entry() //  [R2]
         { []
         }
     {offset
       c7Ds: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Dt; else goto c7Du;
       c7Dt: // global
           R2 = R2;
           R1 = GHC.Integer.Type.fullBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Du: // global
           I64[Sp - 8] = block_c7Dp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Dy; else goto c7Dq;
       u7Dy: // global
           call _c7Dp() args: 0, res: 0, upd: 0;
       c7Dq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.fullBound_info" {
     GHC.Integer.Type.fullBound_info:
         const GHC.Integer.Type.fullBound_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7Dp() //  []
         { []
         }
     {offset
       c7Dp: // global
           R1 = 18446744073709551615;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Dp_info" {
     block_c7Dp_info:
         const _c7Dp;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.104299107 UTC

[section ""data" . GHC.Integer.Type.$wsuccPositive_closure" {
     GHC.Integer.Type.$wsuccPositive_closure:
         const GHC.Integer.Type.$wsuccPositive_info;
 },
 GHC.Integer.Type.$wsuccPositive_entry() //  [R2]
         { []
         }
     {offset
       c7DV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7DW; else goto c7DX;
       c7DW: // global
           R2 = R2;
           R1 = GHC.Integer.Type.$wsuccPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7DX: // global
           I64[Sp - 8] = block_c7DO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Ek; else goto c7DP;
       u7Ek: // global
           call _c7DO(R1) args: 0, res: 0, upd: 0;
       c7DP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.$wsuccPositive_info" {
     GHC.Integer.Type.$wsuccPositive_info:
         const GHC.Integer.Type.$wsuccPositive_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7DO() //  [R1]
         { []
         }
     {offset
       c7DO: // global
           if (R1 & 7 == 1) goto c7DS; else goto c7DT;
       c7DS: // global
           _s7j9::P64 = P64[R1 + 7];
           _s7ja::I64 = I64[R1 + 15];
           if (_s7ja::I64 != 18446744073709551615) goto c7E3; else goto c7Eb;
       c7E3: // global
           R2 = _s7j9::P64;
           R1 = _s7ja::I64 + 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c7Eb: // global
           I64[Sp] = block_c7E6_info;
           R2 = _s7j9::P64;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
       c7DT: // global
           R2 = GHC.Integer.Type.None_closure+2;
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7DO_info" {
     block_c7DO_info:
         const _c7DO;
         const 0;
         const 30;
 },
 _c7E6() //  [R1, R2]
         { []
         }
     {offset
       c7E6: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c7E7() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7E6_info" {
     block_c7E6_info:
         const _c7E6;
         const 0;
         const 30;
 },
 _c7E7() //  []
         { []
         }
     {offset
       c7E7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Ee; else goto c7Ed;
       c7Ee: // global
           HpAlloc = 24;
           I64[Sp] = block_c7E7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7Ed: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = Hp - 15;
           R1 = 0;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7E7_info" {
     block_c7E7_info:
         const _c7E7;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.121121315 UTC

[section ""data" . GHC.Integer.Type.succPositive_closure" {
     GHC.Integer.Type.succPositive_closure:
         const GHC.Integer.Type.succPositive_info;
 },
 GHC.Integer.Type.succPositive_entry() //  [R2]
         { []
         }
     {offset
       c7EV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7EW; else goto c7EX;
       c7EW: // global
           R2 = R2;
           R1 = GHC.Integer.Type.succPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EX: // global
           I64[Sp - 8] = block_c7EQ_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.succPositive_info" {
     GHC.Integer.Type.succPositive_info:
         const GHC.Integer.Type.succPositive_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7EQ() //  [R1, R2]
         { []
         }
     {offset
       c7EQ: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c7ER() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7EQ_info" {
     block_c7EQ_info:
         const _c7EQ;
         const 0;
         const 30;
 },
 _c7ER() //  []
         { []
         }
     {offset
       c7ER: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7F0; else goto c7EZ;
       c7F0: // global
           HpAlloc = 24;
           I64[Sp] = block_c7ER_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7EZ: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7ER_info" {
     block_c7ER_info:
         const _c7ER;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.133547228 UTC

[section ""data" . lvl_r3Bo_closure" {
     lvl_r3Bo_closure:
         const lvl_r3Bo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r3Bo_entry() //  [R1]
         { []
         }
     {offset
       c7Fv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7Fw; else goto c7Fx;
       c7Fw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Fx: // global
           (_c7Fn::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Fn::I64 == 0) goto c7Fp; else goto c7Fo;
       c7Fp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Fo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Fn::I64;
           I64[Sp - 24] = block_c7Fq_info;
           R2 = GHC.Integer.Type.None_closure+2;
           Sp = Sp - 24;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . lvl_r3Bo_info" {
     lvl_r3Bo_info:
         const lvl_r3Bo_entry;
         const 0;
         const 21;
 },
 _c7Fq() //  [R1, R2]
         { []
         }
     {offset
       c7Fq: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c7Fr() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7Fq_info" {
     block_c7Fq_info:
         const _c7Fq;
         const 0;
         const 30;
 },
 _c7Fr() //  []
         { []
         }
     {offset
       c7Fr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7FA; else goto c7Fz;
       c7FA: // global
           HpAlloc = 24;
           I64[Sp] = block_c7Fr_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c7Fz: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c7Fr_info" {
     block_c7Fr_info:
         const _c7Fr;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.149641524 UTC

[section ""data" . GHC.Integer.Type.plusPositive_addWithCarry_closure" {
     GHC.Integer.Type.plusPositive_addWithCarry_closure:
         const GHC.Integer.Type.plusPositive_addWithCarry_info;
         const 0;
 },
 GHC.Integer.Type.plusPositive_addWithCarry_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c7G8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7G9; else goto u7IF;
       c7G9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.plusPositive_addWithCarry_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u7IF: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c7FY() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.plusPositive_addWithCarry_info" {
     GHC.Integer.Type.plusPositive_addWithCarry_info:
         const GHC.Integer.Type.plusPositive_addWithCarry_entry;
         const 0;
         const 12884901902;
         const 12884901907;
         const S7IQ_srt;
 },
 _c7FY() //  []
         { []
         }
     {offset
       c7FY: // global
           I64[Sp - 8] = block_c7G1_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7IJ; else goto c7G2;
       u7IJ: // global
           call _c7G1(R1) args: 0, res: 0, upd: 0;
       c7G2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7G1() //  [R1]
         { []
         }
     {offset
       c7G1: // global
           _s7jp::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c7G5; else goto c7G6;
       c7G5: // global
           I64[Sp - 8] = block_c7Gd_info;
           _s7jq::P64 = R1;
           _s7js::P64 = P64[R1 + 7];
           _s7jr::I64 = I64[R1 + 15];
           R1 = _s7jp::P64;
           P64[Sp] = _s7js::P64;
           I64[Sp + 16] = _s7jr::I64;
           P64[Sp + 24] = _s7jq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7IK; else goto c7Gf;
       u7IK: // global
           call _c7Gd(R1) args: 0, res: 0, upd: 0;
       c7Gf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7G6: // global
           I64[Sp] = block_c7I9_info;
           R1 = _s7jp::P64;
           if (R1 & 7 != 0) goto u7IL; else goto c7Ib;
       u7IL: // global
           call _c7I9(R1) args: 0, res: 0, upd: 0;
       c7Ib: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c7G1_info" {
     block_c7G1_info:
         const _c7G1;
         const 195;
         const 12884901918;
         const S7IQ_srt;
 },
 _c7Gd() //  [R1]
         { []
         }
     {offset
       c7Gd: // global
           _s7jn::I64 = I64[Sp + 16];
           _s7jq::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c7HP; else goto c7I6;
       c7HP: // global
           _s7jr::I64 = I64[Sp + 24];
           _s7ju::I64 = I64[R1 + 15];
           if (_s7jr::I64 >= _s7ju::I64) goto c7HM; else goto c7HN;
       c7HM: // global
           _s7js::P64 = P64[Sp + 8];
           _s7jv::P64 = P64[R1 + 7];
           if (_s7ju::I64 < 9223372036854775808) goto c7Ho; else goto c7HH;
       c7Ho: // global
           if (_s7jr::I64 < 9223372036854775808) goto c7GF; else goto c7Hm;
       c7GF: // global
           I64[Sp + 8] = block_c7Gt_info;
           R4 = _s7jv::P64;
           R3 = _s7js::P64;
           R2 = 0;
           I64[Sp + 32] = _s7ju::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c7Hm: // global
           _s7jC::I64 = (_s7jr::I64 + -9223372036854775808) + (_s7ju::I64 + _s7jn::I64);
           if (_s7jC::I64 >= 9223372036854775808) goto c7H5; else goto c7Hi;
       c7H5: // global
           I64[Sp + 24] = block_c7GW_info;
           R4 = _s7jv::P64;
           R3 = _s7js::P64;
           R2 = 1;
           I64[Sp + 32] = _s7jC::I64;
           Sp = Sp + 24;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c7Hi: // global
           I64[Sp + 24] = block_c7Ha_info;
           R4 = _s7jv::P64;
           R3 = _s7js::P64;
           R2 = 0;
           I64[Sp + 32] = _s7jC::I64;
           Sp = Sp + 24;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c7HH: // global
           I64[Sp + 8] = block_c7Hq_info;
           R4 = _s7jv::P64;
           R3 = _s7js::P64;
           R2 = 1;
           I64[Sp + 32] = _s7ju::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c7HN: // global
           I64[Sp + 16] = _s7jn::I64;
           P64[Sp + 24] = R1;
           P64[Sp + 32] = _s7jq::P64;
           Sp = Sp + 16;
           call _c7FY() args: 0, res: 0, upd: 0;
       c7I6: // global
           if (_s7jn::I64 == 0) goto c7I5; else goto c7I1;
       c7I5: // global
           R1 = _s7jq::P64 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c7I1: // global
           I64[Sp + 32] = block_c7HV_info;
           R2 = _s7jq::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Gd_info" {
     block_c7Gd_info:
         const _c7Gd;
         const 388;
         const 12884901918;
         const S7IQ_srt;
 },
 _c7Gt() //  [R1]
         { []
         }
     {offset
       c7Gt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7GI; else goto c7GH;
       c7GI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7GH: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] + (I64[Sp + 24] + I64[Sp + 8]);
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Gt_info" {
     block_c7Gt_info:
         const _c7Gt;
         const 451;
         const 30;
 },
 _c7GW() //  [R1]
         { []
         }
     {offset
       c7GW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7H8; else goto c7H7;
       c7H8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7H7: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - 9223372036854775808;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7GW_info" {
     block_c7GW_info:
         const _c7GW;
         const 65;
         const 30;
 },
 _c7Ha() //  [R1]
         { []
         }
     {offset
       c7Ha: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Hl; else goto c7Hk;
       c7Hl: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Hk: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - 9223372036854775808;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Ha_info" {
     block_c7Ha_info:
         const _c7Ha;
         const 65;
         const 30;
 },
 _c7Hq() //  [R1]
         { []
         }
     {offset
       c7Hq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7HK; else goto c7HJ;
       c7HK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7HJ: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] + (I64[Sp + 24] + I64[Sp + 8]);
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Hq_info" {
     block_c7Hq_info:
         const _c7Hq;
         const 451;
         const 30;
 },
 _c7HV() //  [R1, R2]
         { []
         }
     {offset
       c7HV: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c7HW() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7HV_info" {
     block_c7HV_info:
         const _c7HV;
         const 0;
         const 30;
 },
 _c7HW() //  []
         { []
         }
     {offset
       c7HW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7I4; else goto c7I3;
       c7I4: // global
           HpAlloc = 24;
           I64[Sp] = block_c7HW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7I3: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7HW_info" {
     block_c7HW_info:
         const _c7HW;
         const 130;
         const 30;
 },
 _c7I9() //  [R1]
         { []
         }
     {offset
       c7I9: // global
           _s7jn::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c7Iu; else goto c7IC;
       c7Iu: // global
           if (_s7jn::I64 == 0) goto c7Is; else goto c7Io;
       c7Is: // global
           R1 = R1 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c7Io: // global
           I64[Sp + 24] = block_c7Ii_info;
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
       c7IC: // global
           if (_s7jn::I64 == 0) goto c7IB; else goto c7IA;
       c7IB: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7IA: // global
           R1 = lvl_r3Bo_closure;
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7I9_info" {
     block_c7I9_info:
         const _c7I9;
         const 451;
         const 4294967326;
         const S7IQ_srt+8;
 },
 _c7Ii() //  [R1, R2]
         { []
         }
     {offset
       c7Ii: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c7Ij() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7Ii_info" {
     block_c7Ii_info:
         const _c7Ii;
         const 0;
         const 30;
 },
 _c7Ij() //  []
         { []
         }
     {offset
       c7Ij: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Ir; else goto c7Iq;
       c7Ir: // global
           HpAlloc = 24;
           I64[Sp] = block_c7Ij_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7Iq: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Ij_info" {
     block_c7Ij_info:
         const _c7Ij;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.178828107 UTC

[section ""data" . GHC.Integer.Type.plusPositive_closure" {
     GHC.Integer.Type.plusPositive_closure:
         const GHC.Integer.Type.plusPositive_info;
         const 0;
 },
 GHC.Integer.Type.plusPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c7KB: // global
           R4 = R3;
           R3 = R2;
           R2 = 0;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.plusPositive_info" {
     GHC.Integer.Type.plusPositive_info:
         const GHC.Integer.Type.plusPositive_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S7IQ_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.18668957 UTC

[section ""data" . GHC.Integer.Type.minusPositive_closure" {
     GHC.Integer.Type.minusPositive_closure:
         const GHC.Integer.Type.minusPositive_info;
 },
 GHC.Integer.Type.minusPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c7KT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7KU; else goto c7KV;
       c7KU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.minusPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7KV: // global
           I64[Sp - 16] = block_c7KM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Mw; else goto c7KN;
       u7Mw: // global
           call _c7KM(R1) args: 0, res: 0, upd: 0;
       c7KN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.minusPositive_info" {
     GHC.Integer.Type.minusPositive_info:
         const GHC.Integer.Type.minusPositive_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c7KM() //  [R1]
         { []
         }
     {offset
       c7KM: // global
           _s7k4::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7KQ; else goto c7KR;
       c7KQ: // global
           I64[Sp - 16] = block_c7KY_info;
           _s7k5::P64 = R1;
           _s7k7::P64 = P64[R1 + 7];
           _s7k6::I64 = I64[R1 + 15];
           R1 = _s7k4::P64;
           P64[Sp - 8] = _s7k7::P64;
           I64[Sp] = _s7k6::I64;
           P64[Sp + 8] = _s7k5::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Mu; else goto c7L0;
       u7Mu: // global
           call _c7KY(R1) args: 0, res: 0, upd: 0;
       c7L0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7KR: // global
           I64[Sp + 8] = block_c7Mc_info;
           R1 = _s7k4::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Mv; else goto c7Me;
       u7Mv: // global
           call _c7Mc(R1) args: 0, res: 0, upd: 0;
       c7Me: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c7KM_info" {
     block_c7KM_info:
         const _c7KM;
         const 1;
         const 30;
 },
 _c7KY() //  [R1]
         { []
         }
     {offset
       c7KY: // global
           if (R1 & 7 == 1) goto c7M5; else goto c7M9;
       c7M5: // global
           _s7k6::I64 = I64[Sp + 16];
           _s7k7::P64 = P64[Sp + 8];
           _s7ka::P64 = P64[R1 + 7];
           _s7k9::I64 = I64[R1 + 15];
           if (_s7k6::I64 == _s7k9::I64) goto c7LQ; else goto c7LN;
       c7LQ: // global
           I64[Sp + 24] = block_c7LP_info;
           R3 = _s7ka::P64;
           R2 = _s7k7::P64;
           Sp = Sp + 24;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c7LN: // global
           if (_s7k6::I64 <= _s7k9::I64) goto c7Lu; else goto c7LI;
       c7Lu: // global
           I64[Sp + 8] = block_c7Lb_info;
           R3 = _s7ka::P64;
           R2 = _s7k7::P64;
           I64[Sp + 24] = _s7k9::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c7LI: // global
           I64[Sp + 8] = block_c7LA_info;
           R3 = _s7ka::P64;
           R2 = _s7k7::P64;
           I64[Sp + 24] = _s7k9::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c7M9: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7KY_info" {
     block_c7KY_info:
         const _c7KY;
         const 131;
         const 30;
 },
 _c7LP() //  [R1]
         { []
         }
     {offset
       c7LP: // global
           if (R1 & 7 == 1) goto c7LW; else goto u7Mt;
       c7LW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7LZ; else goto c7LY;
       c7LZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7LY: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7Mt: // global
           Sp = Sp + 8;
           call _c7Mo() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7LP_info" {
     block_c7LP_info:
         const _c7LP;
         const 0;
         const 30;
 },
 _c7Lb() //  [R1]
         { []
         }
     {offset
       c7Lb: // global
           I64[Sp] = block_c7Lf_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = R1;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Lb_info" {
     block_c7Lb_info:
         const _c7Lb;
         const 194;
         const 30;
 },
 _c7Lf() //  [R1]
         { []
         }
     {offset
       c7Lf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Ly; else goto c7Lx;
       c7Ly: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Lx: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 18446744073709551615 - I64[Sp + 16] + (I64[Sp + 8] + 1);
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Lf_info" {
     block_c7Lf_info:
         const _c7Lf;
         const 194;
         const 30;
 },
 _c7LA() //  [R1]
         { []
         }
     {offset
       c7LA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7LL; else goto c7LK;
       c7LL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7LK: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] - I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7LA_info" {
     block_c7LA_info:
         const _c7LA;
         const 194;
         const 30;
 },
 _c7Mc() //  [R1]
         { []
         }
     {offset
       c7Mc: // global
           if (R1 & 7 == 1) goto c7Mk; else goto u7Ms;
       c7Mk: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u7Ms: // global
           Sp = Sp + 8;
           call _c7Mo() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7Mc_info" {
     block_c7Mc_info:
         const _c7Mc;
         const 0;
         const 30;
 },
 _c7Mo() //  []
         { []
         }
     {offset
       c7Mo: // global
           R1 = GHC.Integer.Type.None_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.207636144 UTC

[section ""data" . GHC.Integer.Type.twosComplementPositive1_closure" {
     GHC.Integer.Type.twosComplementPositive1_closure:
         const GHC.Integer.Type.twosComplementPositive1_info;
 },
 GHC.Integer.Type.twosComplementPositive1_entry() //  [R2]
         { []
         }
     {offset
       c7NG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7NH; else goto c7NI;
       c7NH: // global
           R2 = R2;
           R1 = GHC.Integer.Type.twosComplementPositive1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7NI: // global
           I64[Sp - 8] = block_c7NE_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.twosComplementPositive1_info" {
     GHC.Integer.Type.twosComplementPositive1_info:
         const GHC.Integer.Type.twosComplementPositive1_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7NE() //  [R1]
         { []
         }
     {offset
       c7NE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7NE_info" {
     block_c7NE_info:
         const _c7NE;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.213739376 UTC

[section ""data" . GHC.Integer.Type.twosComplementPositive_closure" {
     GHC.Integer.Type.twosComplementPositive_closure:
         const GHC.Integer.Type.twosComplementPositive_info;
 },
 GHC.Integer.Type.twosComplementPositive_entry() //  [R2]
         { []
         }
     {offset
       c7NZ: // global
           R2 = R2;
           call GHC.Integer.Type.twosComplementPositive1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.twosComplementPositive_info" {
     GHC.Integer.Type.twosComplementPositive_info:
         const GHC.Integer.Type.twosComplementPositive_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.218861999 UTC

[section ""data" . GHC.Integer.Type.lowHalfMask_closure" {
     GHC.Integer.Type.lowHalfMask_closure:
         const GHC.Integer.Type.lowHalfMask_info;
 },
 GHC.Integer.Type.lowHalfMask_entry() //  [R2]
         { []
         }
     {offset
       c7Od: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Oe; else goto c7Of;
       c7Oe: // global
           R2 = R2;
           R1 = GHC.Integer.Type.lowHalfMask_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Of: // global
           I64[Sp - 8] = block_c7Oa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Oj; else goto c7Ob;
       u7Oj: // global
           call _c7Oa() args: 0, res: 0, upd: 0;
       c7Ob: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.lowHalfMask_info" {
     GHC.Integer.Type.lowHalfMask_info:
         const GHC.Integer.Type.lowHalfMask_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7Oa() //  []
         { []
         }
     {offset
       c7Oa: // global
           R1 = 4294967295;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Oa_info" {
     block_c7Oa_info:
         const _c7Oa;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.232237749 UTC

[section ""data" . GHC.Integer.Type.highHalfShift_closure" {
     GHC.Integer.Type.highHalfShift_closure:
         const GHC.Integer.Type.highHalfShift_info;
 },
 GHC.Integer.Type.highHalfShift_entry() //  [R2]
         { []
         }
     {offset
       c7OC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7OD; else goto c7OE;
       c7OD: // global
           R2 = R2;
           R1 = GHC.Integer.Type.highHalfShift_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7OE: // global
           I64[Sp - 8] = block_c7Oz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OI; else goto c7OA;
       u7OI: // global
           call _c7Oz() args: 0, res: 0, upd: 0;
       c7OA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.highHalfShift_info" {
     GHC.Integer.Type.highHalfShift_info:
         const GHC.Integer.Type.highHalfShift_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7Oz() //  []
         { []
         }
     {offset
       c7Oz: // global
           R1 = 32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Oz_info" {
     block_c7Oz_info:
         const _c7Oz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.242547023 UTC

[section ""data" . GHC.Integer.Type.splitHalves_closure" {
     GHC.Integer.Type.splitHalves_closure:
         const GHC.Integer.Type.splitHalves_info;
 },
 GHC.Integer.Type.splitHalves_entry() //  [R2]
         { []
         }
     {offset
       c7P0: // global
           _s7kx::I64 = R2 >> 32;
           R2 = R2 & 4294967295;
           R1 = _s7kx::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.splitHalves_info" {
     GHC.Integer.Type.splitHalves_info:
         const GHC.Integer.Type.splitHalves_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.252050853 UTC

[section ""data" . GHC.Integer.Type.doubleFromPositive_closure" {
     GHC.Integer.Type.doubleFromPositive_closure:
         const GHC.Integer.Type.doubleFromPositive_info;
 },
 GHC.Integer.Type.doubleFromPositive_entry() //  [R2]
         { []
         }
     {offset
       c7Pn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Po; else goto c7Pp;
       c7Po: // global
           R2 = R2;
           R1 = GHC.Integer.Type.doubleFromPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Pp: // global
           I64[Sp - 8] = block_c7Pg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Qd; else goto c7Ph;
       u7Qd: // global
           call _c7Pg(R1) args: 0, res: 0, upd: 0;
       c7Ph: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.doubleFromPositive_info" {
     GHC.Integer.Type.doubleFromPositive_info:
         const GHC.Integer.Type.doubleFromPositive_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7Pg() //  [R1]
         { []
         }
     {offset
       c7Pg: // global
           if (R1 & 7 == 1) goto c7Pk; else goto c7Pl;
       c7Pk: // global
           I64[Sp - 8] = block_c7Ps_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c7Pl: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Pg_info" {
     block_c7Pg_info:
         const _c7Pg;
         const 0;
         const 30;
 },
 _c7Ps() //  [D1]
         { []
         }
     {offset
       c7Ps: // global
           _s7kB::I64 = I64[Sp + 8];
           _s7kD::F64 = D1;
           (_c7PF::F64) = call MO_F64_Pwr(2.0 :: W64, 32.0 :: W64);
           (_c7PW::F64) = call MO_F64_Pwr(2.0 :: W64, 64.0 :: W64);
           D1 = %MO_F_Add_W64(%MO_F_Add_W64(%MO_F_Mul_W64(_s7kD::F64,
                                                          _c7PW::F64),
                                            %MO_F_Mul_W64(%MO_SF_Conv_W64_W64(_s7kB::I64 >> 32),
                                                          _c7PF::F64)),
                              %MO_SF_Conv_W64_W64(_s7kB::I64 & 4294967295));
           Sp = Sp + 16;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Ps_info" {
     block_c7Ps_info:
         const _c7Ps;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.267517097 UTC

[section ""data" . GHC.Integer.Type.doubleFromInteger_closure" {
     GHC.Integer.Type.doubleFromInteger_closure:
         const GHC.Integer.Type.doubleFromInteger_info;
 },
 GHC.Integer.Type.doubleFromInteger_entry() //  [R2]
         { []
         }
     {offset
       c7QX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7QY; else goto c7QZ;
       c7QY: // global
           R2 = R2;
           R1 = GHC.Integer.Type.doubleFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7QZ: // global
           I64[Sp - 8] = block_c7QP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Rg; else goto c7QQ;
       u7Rg: // global
           call _c7QP(R1) args: 0, res: 0, upd: 0;
       c7QQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.doubleFromInteger_info" {
     GHC.Integer.Type.doubleFromInteger_info:
         const GHC.Integer.Type.doubleFromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7QP() //  [R1]
         { []
         }
     {offset
       c7QP: // global
           _c7QW::P64 = R1 & 7;
           if (_c7QW::P64 < 3) goto u7Rf; else goto c7QV;
       u7Rf: // global
           if (_c7QW::P64 < 2) goto c7QT; else goto c7QU;
       c7QT: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 0, upd: 8;
       c7QU: // global
           I64[Sp] = block_c7R5_info;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.doubleFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c7QV: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7QP_info" {
     block_c7QP_info:
         const _c7QP;
         const 0;
         const 30;
 },
 _c7R5() //  [D1]
         { []
         }
     {offset
       c7R5: // global
           D1 = %MO_F_Neg_W64(D1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7R5_info" {
     block_c7R5_info:
         const _c7R5;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.281555728 UTC

[section ""data" . GHC.Integer.Type.floatFromPositive_closure" {
     GHC.Integer.Type.floatFromPositive_closure:
         const GHC.Integer.Type.floatFromPositive_info;
 },
 GHC.Integer.Type.floatFromPositive_entry() //  [R2]
         { []
         }
     {offset
       c7RL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7RM; else goto c7RN;
       c7RM: // global
           R2 = R2;
           R1 = GHC.Integer.Type.floatFromPositive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7RN: // global
           I64[Sp - 8] = block_c7RE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7SB; else goto c7RF;
       u7SB: // global
           call _c7RE(R1) args: 0, res: 0, upd: 0;
       c7RF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.floatFromPositive_info" {
     GHC.Integer.Type.floatFromPositive_info:
         const GHC.Integer.Type.floatFromPositive_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7RE() //  [R1]
         { []
         }
     {offset
       c7RE: // global
           if (R1 & 7 == 1) goto c7RI; else goto c7RJ;
       c7RI: // global
           I64[Sp - 8] = block_c7RQ_info;
           R2 = P64[R1 + 7];
           I64[Sp] = I64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c7RJ: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7RE_info" {
     block_c7RE_info:
         const _c7RE;
         const 0;
         const 30;
 },
 _c7RQ() //  [F1]
         { []
         }
     {offset
       c7RQ: // global
           _s7kW::I64 = I64[Sp + 8];
           _s7kY::F32 = F1;
           (_c7S3::F32) = call MO_F32_Pwr(2.0 :: W32, 32.0 :: W32);
           (_c7Sk::F32) = call MO_F32_Pwr(2.0 :: W32, 64.0 :: W32);
           F1 = %MO_F_Add_W32(%MO_F_Add_W32(%MO_F_Mul_W32(_s7kY::F32,
                                                          _c7Sk::F32),
                                            %MO_F_Mul_W32(%MO_SF_Conv_W64_W32(_s7kW::I64 >> 32),
                                                          _c7S3::F32)),
                              %MO_SF_Conv_W64_W32(_s7kW::I64 & 4294967295));
           Sp = Sp + 16;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7RQ_info" {
     block_c7RQ_info:
         const _c7RQ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.3000709 UTC

[section ""data" . GHC.Integer.Type.floatFromInteger_closure" {
     GHC.Integer.Type.floatFromInteger_closure:
         const GHC.Integer.Type.floatFromInteger_info;
 },
 GHC.Integer.Type.floatFromInteger_entry() //  [R2]
         { []
         }
     {offset
       c7Tl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Tm; else goto c7Tn;
       c7Tm: // global
           R2 = R2;
           R1 = GHC.Integer.Type.floatFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Tn: // global
           I64[Sp - 8] = block_c7Td_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7TE; else goto c7Te;
       u7TE: // global
           call _c7Td(R1) args: 0, res: 0, upd: 0;
       c7Te: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.floatFromInteger_info" {
     GHC.Integer.Type.floatFromInteger_info:
         const GHC.Integer.Type.floatFromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c7Td() //  [R1]
         { []
         }
     {offset
       c7Td: // global
           _c7Tk::P64 = R1 & 7;
           if (_c7Tk::P64 < 3) goto u7TD; else goto c7Tj;
       u7TD: // global
           if (_c7Tk::P64 < 2) goto c7Th; else goto c7Ti;
       c7Th: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 0, upd: 8;
       c7Ti: // global
           I64[Sp] = block_c7Tt_info;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.floatFromPositive_entry(R2) args: 8, res: 8, upd: 8;
       c7Tj: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Td_info" {
     block_c7Td_info:
         const _c7Td;
         const 0;
         const 30;
 },
 _c7Tt() //  [F1]
         { []
         }
     {offset
       c7Tt: // global
           F1 = %MO_F_Neg_W32(F1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Tt_info" {
     block_c7Tt_info:
         const _c7Tt;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.317034928 UTC

[section ""data" . GHC.Integer.Type.timesDigit_closure" {
     GHC.Integer.Type.timesDigit_closure:
         const GHC.Integer.Type.timesDigit_info;
         const 0;
 },
 GHC.Integer.Type.timesDigit_entry() //  [R2, R3]
         { []
         }
     {offset
       c7U4: // global
           _s7lg::I64 = R3;
           _s7lf::I64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto c7UI; else goto c7UJ;
       c7UJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7UL; else goto c7UK;
       c7UL: // global
           HpAlloc = 72;
           goto c7UI;
       c7UI: // global
           R3 = _s7lg::I64;
           R2 = _s7lf::I64;
           R1 = GHC.Integer.Type.timesDigit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7UK: // global
           I64[Hp - 64] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 56] = GHC.Integer.Type.None_closure+2;
           _s7li::I64 = _s7lg::I64 & 4294967295;
           _s7lk::I64 = _s7lf::I64 & 4294967295;
           I64[Hp - 48] = _s7lk::I64 * _s7li::I64;
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = GHC.Integer.Type.None_closure+2;
           _s7ll::I64 = _s7lg::I64 >> 32;
           _s7lm::I64 = _s7lk::I64 * _s7ll::I64;
           I64[Hp - 24] = _s7lm::I64 & 4294967295 << 32;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           _s7lh::I64 = _s7lf::I64 >> 32;
           _s7lj::I64 = _s7lh::I64 * _s7li::I64;
           I64[Hp] = _s7lj::I64 & 4294967295 << 32;
           I64[Sp - 48] = block_c7UD_info;
           R4 = Hp - 39;
           R3 = Hp - 15;
           R2 = 0;
           P64[Sp - 40] = Hp - 63;
           I64[Sp - 32] = _s7lh::I64;
           I64[Sp - 24] = _s7lj::I64;
           I64[Sp - 16] = _s7ll::I64;
           I64[Sp - 8] = _s7lm::I64;
           Sp = Sp - 48;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.timesDigit_info" {
     GHC.Integer.Type.timesDigit_info:
         const GHC.Integer.Type.timesDigit_entry;
         const 0;
         const 21474836494;
         const 8589934604;
         const S7IQ_srt;
 },
 _c7UD() //  [R1]
         { []
         }
     {offset
       c7UD: // global
           _c7Uo::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7UH_info;
           R4 = _c7Uo::P64;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c7UD_info" {
     block_c7UD_info:
         const _c7UD;
         const 1925;
         const 4294967326;
         const S7IQ_srt;
 },
 _c7UH() //  [R1]
         { []
         }
     {offset
       c7UH: // global
           _s7lB::I64 = I64[Sp + 8] * I64[Sp + 24] + ((I64[Sp + 16] >> 32) + (I64[Sp + 32] >> 32));
           if (_s7lB::I64 == 0) goto c7Vi; else goto u7Vm;
       c7Vi: // global
           R1 = R1 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u7Vm: // global
           I64[Sp + 24] = _s7lB::I64;
           P64[Sp + 32] = R1;
           Sp = Sp + 24;
           call _c7V7() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7UH_info" {
     block_c7UH_info:
         const _c7UH;
         const 964;
         const 4294967326;
         const S7IQ_srt;
 },
 _c7V7() //  []
         { []
         }
     {offset
       c7V7: // global
           Hp = Hp + 48;
           _s7lB::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c7Vf; else goto c7Ve;
       c7Vf: // global
           HpAlloc = 48;
           I64[Sp] = block_c7V6_info;
           R1 = _s7lB::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7Ve: // global
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = GHC.Integer.Type.None_closure+2;
           I64[Hp - 24] = _s7lB::I64;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = 0;
           R4 = P64[Sp + 8];
           R3 = Hp - 15;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c7V6() //  [R1]
         { []
         }
     {offset
       c7V6: // global
           I64[Sp] = R1;
           call _c7V7() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7V6_info" {
     block_c7V6_info:
         const _c7V6;
         const 1;
         const 4294967326;
         const S7IQ_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.342716389 UTC

[section ""data" . GHC.Integer.Type.timesPositive_closure" {
     GHC.Integer.Type.timesPositive_closure:
         const GHC.Integer.Type.timesPositive_info;
         const 0;
 },
 GHC.Integer.Type.timesPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c7Wq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7Wr; else goto u7Ya;
       c7Wr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.timesPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u7Ya: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c7Wg() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.timesPositive_info" {
     GHC.Integer.Type.timesPositive_info:
         const GHC.Integer.Type.timesPositive_entry;
         const 0;
         const 55834574862;
         const 8589934607;
         const S7IQ_srt;
 },
 _c7Wg() //  []
         { []
         }
     {offset
       c7Wg: // global
           _s7lE::P64 = P64[Sp];
           I64[Sp] = block_c7Wj_info;
           R1 = _s7lE::P64;
           if (R1 & 7 != 0) goto u7Yc; else goto c7Wk;
       u7Yc: // global
           call _c7Wj(R1) args: 0, res: 0, upd: 0;
       c7Wk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Wj() //  [R1]
         { []
         }
     {offset
       c7Wj: // global
           _s7lF::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7Wn; else goto c7Wo;
       c7Wn: // global
           I64[Sp - 16] = block_c7Wv_info;
           _s7lG::P64 = R1;
           _s7lI::P64 = P64[R1 + 7];
           _s7lH::I64 = I64[R1 + 15];
           R1 = _s7lF::P64;
           P64[Sp - 8] = _s7lI::P64;
           I64[Sp] = _s7lH::I64;
           P64[Sp + 8] = _s7lG::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Yd; else goto c7Wx;
       u7Yd: // global
           call _c7Wv(R1) args: 0, res: 0, upd: 0;
       c7Wx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7Wo: // global
           I64[Sp + 8] = block_c7XZ_info;
           R1 = _s7lF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Ye; else goto c7Y1;
       u7Ye: // global
           call _c7XZ() args: 0, res: 0, upd: 0;
       c7Y1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Wj_info" {
     block_c7Wj_info:
         const _c7Wj;
         const 1;
         const 55834574878;
         const S7IQ_srt;
 },
 _c7Wv() //  [R1]
         { []
         }
     {offset
       c7Wv: // global
           if (R1 & 7 == 1) goto c7WE; else goto c7XW;
       c7WE: // global
           I64[Sp - 16] = block_c7WB_info;
           _s7lJ::P64 = R1;
           _s7lL::P64 = P64[R1 + 7];
           _s7lK::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s7lL::P64;
           I64[Sp] = _s7lK::I64;
           P64[Sp + 8] = _s7lJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Yg; else goto c7WF;
       u7Yg: // global
           call _c7WB(R1) args: 0, res: 0, upd: 0;
       c7WF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7XW: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Wv_info" {
     block_c7Wv_info:
         const _c7Wv;
         const 131;
         const 55834574878;
         const S7IQ_srt;
 },
 _c7WB() //  [R1]
         { []
         }
     {offset
       c7WB: // global
           _s7lL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7WM; else goto c7XH;
       c7WM: // global
           I64[Sp + 8] = block_c7WJ_info;
           _s7lM::P64 = R1;
           R1 = _s7lL::P64;
           P64[Sp + 40] = _s7lM::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Yh; else goto c7WN;
       u7Yh: // global
           call _c7WJ(R1) args: 0, res: 0, upd: 0;
       c7WN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7XH: // global
           I64[Sp + 8] = block_c7XF_info;
           R1 = _s7lL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Yi; else goto c7XI;
       u7Yi: // global
           call _c7XF(R1) args: 0, res: 0, upd: 0;
       c7XI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c7WB_info" {
     block_c7WB_info:
         const _c7WB;
         const 645;
         const 55834574878;
         const S7IQ_srt;
 },
 _c7WJ() //  [R1]
         { []
         }
     {offset
       c7WJ: // global
           _s7lJ::P64 = P64[Sp + 16];
           _s7lM::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c7X0; else goto c7XC;
       c7X0: // global
           I64[Sp + 8] = block_c7WR_info;
           R3 = _s7lJ::P64;
           R2 = _s7lM::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c7XC: // global
           _s7lW::I64 = I64[Sp + 24];
           if (_s7lW::I64 != 0) goto c7Xk; else goto c7Xy;
       c7Xk: // global
           I64[Sp] = block_c7Xd_info;
           R3 = _s7lJ::P64;
           R2 = _s7lM::P64;
           I64[Sp + 32] = _s7lW::I64;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c7Xy: // global
           I64[Sp + 32] = block_c7Xt_info;
           R3 = _s7lJ::P64;
           R2 = _s7lM::P64;
           Sp = Sp + 32;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c7WJ_info" {
     block_c7WJ_info:
         const _c7WJ;
         const 324;
         const 55834574878;
         const S7IQ_srt;
 },
 _c7WR() //  [R1]
         { []
         }
     {offset
       c7WR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7X3; else goto c7X2;
       c7X3: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7X2: // global
           I64[Hp - 40] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c7WX_info;
           R3 = P64[Sp + 8];
           R2 = Hp - 15;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c7WR_info" {
     block_c7WR_info:
         const _c7WR;
         const 387;
         const 38654705694;
         const S7IQ_srt;
 },
 _c7WX() //  [R1]
         { []
         }
     {offset
       c7WX: // global
           R4 = P64[Sp + 8];
           R3 = R1;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7WX_info" {
     block_c7WX_info:
         const _c7WX;
         const 1;
         const 4294967326;
         const S7IQ_srt;
 },
 _c7Xd() //  [R1]
         { []
         }
     {offset
       c7Xd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Xn; else goto c7Xm;
       c7Xn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Xm: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           I64[Sp + 24] = block_c7Xi_info;
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 32];
           P64[Sp + 32] = Hp - 15;
           Sp = Sp + 24;
           call GHC.Integer.Type.timesDigit_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Xd_info" {
     block_c7Xd_info:
         const _c7Xd;
         const 964;
         const 21474836510;
         const S7IQ_srt;
 },
 _c7Xi() //  [R1]
         { []
         }
     {offset
       c7Xi: // global
           R4 = P64[Sp + 8];
           R3 = R1;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Xi_info" {
     block_c7Xi_info:
         const _c7Xi;
         const 1;
         const 4294967326;
         const S7IQ_srt;
 },
 _c7Xt() //  [R1]
         { []
         }
     {offset
       c7Xt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7XB; else goto c7XA;
       c7XB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XA: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7Xt_info" {
     block_c7Xt_info:
         const _c7Xt;
         const 0;
         const 30;
 },
 _c7XF() //  [R1]
         { []
         }
     {offset
       c7XF: // global
           if (R1 & 7 == 1) goto c7XO; else goto c7XS;
       c7XO: // global
           P64[Sp + 24] = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 32];
           Sp = Sp + 24;
           call _c7Wg() args: 0, res: 0, upd: 0;
       c7XS: // global
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Integer.Type.timesDigit_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7XF_info" {
     block_c7XF_info:
         const _c7XF;
         const 324;
         const 55834574878;
         const S7IQ_srt;
 },
 _c7XZ() //  []
         { []
         }
     {offset
       c7XZ: // global
           R1 = GHC.Integer.Type.errorPositive_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7XZ_info" {
     block_c7XZ_info:
         const _c7XZ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.381171439 UTC

[section ""data" . GHC.Integer.Type.timesInteger_closure" {
     GHC.Integer.Type.timesInteger_closure:
         const GHC.Integer.Type.timesInteger_info;
         const 0;
 },
 GHC.Integer.Type.timesInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c7ZO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ZP; else goto c7ZQ;
       c7ZP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.timesInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ZQ: // global
           I64[Sp - 16] = block_c7ZG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u81i; else goto c7ZH;
       u81i: // global
           call _c7ZG(R1) args: 0, res: 0, upd: 0;
       c7ZH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.timesInteger_info" {
     GHC.Integer.Type.timesInteger_info:
         const GHC.Integer.Type.timesInteger_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S7IQ_srt+24;
 },
 _c7ZG() //  [R1]
         { []
         }
     {offset
       c7ZG: // global
           _s7m6::P64 = P64[Sp + 8];
           _c7ZN::P64 = R1 & 7;
           if (_c7ZN::P64 < 3) goto u81a; else goto c7ZM;
       u81a: // global
           if (_c7ZN::P64 < 2) goto c7ZK; else goto c7ZL;
       c7ZK: // global
           I64[Sp] = block_c7ZT_info;
           _s7m8::P64 = P64[R1 + 7];
           R1 = _s7m6::P64;
           P64[Sp + 8] = _s7m8::P64;
           if (R1 & 7 != 0) goto u81f; else goto c7ZV;
       u81f: // global
           call _c7ZT(R1) args: 0, res: 0, upd: 0;
       c7ZV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7ZL: // global
           I64[Sp] = block_c80s_info;
           _s7me::P64 = P64[R1 + 6];
           R1 = _s7m6::P64;
           P64[Sp + 8] = _s7me::P64;
           if (R1 & 7 != 0) goto u81g; else goto c80u;
       u81g: // global
           call _c80s(R1) args: 0, res: 0, upd: 0;
       c80u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7ZM: // global
           I64[Sp + 8] = block_c811_info;
           R1 = _s7m6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u81h; else goto c813;
       u81h: // global
           call _c811() args: 0, res: 0, upd: 0;
       c813: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c7ZG_info" {
     block_c7ZG_info:
         const _c7ZG;
         const 1;
         const 4294967326;
         const S7IQ_srt+24;
 },
 _c7ZT() //  [R1]
         { []
         }
     {offset
       c7ZT: // global
           _c819::P64 = R1 & 7;
           if (_c819::P64 < 3) goto u81b; else goto u81d;
       u81b: // global
           _s7m8::P64 = P64[Sp + 8];
           if (_c819::P64 < 2) goto c806; else goto c80i;
       c806: // global
           I64[Sp + 8] = block_c7ZZ_info;
           R3 = P64[R1 + 7];
           R2 = _s7m8::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c80i: // global
           I64[Sp + 8] = block_c80c_info;
           R3 = P64[R1 + 6];
           R2 = _s7m8::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       u81d: // global
           Sp = Sp + 16;
           call _c80Y() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c7ZT_info" {
     block_c7ZT_info:
         const _c7ZT;
         const 1;
         const 4294967326;
         const S7IQ_srt+24;
 },
 _c7ZZ() //  [R1]
         { []
         }
     {offset
       c7ZZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c809; else goto c808;
       c809: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c808: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c7ZZ_info" {
     block_c7ZZ_info:
         const _c7ZZ;
         const 0;
         const 30;
 },
 _c80c() //  [R1]
         { []
         }
     {offset
       c80c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c80l; else goto c80k;
       c80l: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c80k: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c80c_info" {
     block_c80c_info:
         const _c80c;
         const 0;
         const 30;
 },
 _c80s() //  [R1]
         { []
         }
     {offset
       c80s: // global
           _c818::P64 = R1 & 7;
           if (_c818::P64 < 3) goto u81c; else goto u81e;
       u81c: // global
           _s7me::P64 = P64[Sp + 8];
           if (_c818::P64 < 2) goto c80F; else goto c80R;
       c80F: // global
           I64[Sp + 8] = block_c80y_info;
           R3 = P64[R1 + 7];
           R2 = _s7me::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c80R: // global
           I64[Sp + 8] = block_c80L_info;
           R3 = P64[R1 + 6];
           R2 = _s7me::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       u81e: // global
           Sp = Sp + 16;
           call _c80Y() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c80s_info" {
     block_c80s_info:
         const _c80s;
         const 1;
         const 4294967326;
         const S7IQ_srt+24;
 },
 _c80y() //  [R1]
         { []
         }
     {offset
       c80y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c80I; else goto c80H;
       c80I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c80H: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c80y_info" {
     block_c80y_info:
         const _c80y;
         const 0;
         const 30;
 },
 _c80L() //  [R1]
         { []
         }
     {offset
       c80L: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c80U; else goto c80T;
       c80U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c80T: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c80L_info" {
     block_c80L_info:
         const _c80L;
         const 0;
         const 30;
 },
 _c80Y() //  []
         { []
         }
     {offset
       c80Y: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c811() //  []
         { []
         }
     {offset
       c811: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c811_info" {
     block_c811_info:
         const _c811;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.413949452 UTC

[section ""data" . GHC.Integer.Type.twoToTheThirtytwoPositive_closure" {
     GHC.Integer.Type.twoToTheThirtytwoPositive_closure:
         const GHC.Integer.Type.Some_con_info;
         const GHC.Integer.Type.None_closure+2;
         const 4294967296;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.417017911 UTC

[section ""data" . GHC.Integer.Type.twoToTheThirtytwoInteger_closure" {
     GHC.Integer.Type.twoToTheThirtytwoInteger_closure:
         const GHC.Integer.Type.Positive_con_info;
         const GHC.Integer.Type.twoToTheThirtytwoPositive_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.420369878 UTC

[section ""data" . GHC.Integer.Type.digitsMaybeZeroToInteger_closure" {
     GHC.Integer.Type.digitsMaybeZeroToInteger_closure:
         const GHC.Integer.Type.digitsMaybeZeroToInteger_info;
 },
 GHC.Integer.Type.digitsMaybeZeroToInteger_entry() //  [R2]
         { []
         }
     {offset
       c82s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c82t; else goto c82u;
       c82t: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsMaybeZeroToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c82u: // global
           I64[Sp - 8] = block_c82l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u82E; else goto c82m;
       u82E: // global
           call _c82l(R1) args: 0, res: 0, upd: 0;
       c82m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.digitsMaybeZeroToInteger_info" {
     GHC.Integer.Type.digitsMaybeZeroToInteger_info:
         const GHC.Integer.Type.digitsMaybeZeroToInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c82l() //  [R1]
         { []
         }
     {offset
       c82l: // global
           if (R1 & 7 == 1) goto c82p; else goto c82q;
       c82p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c82A; else goto c82z;
       c82A: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c82z: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c82q: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c82l_info" {
     block_c82l_info:
         const _c82l;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.434872416 UTC

[section ""data" . GHC.Integer.Type.removeZeroTails_closure" {
     GHC.Integer.Type.removeZeroTails_closure:
         const GHC.Integer.Type.removeZeroTails_info;
 },
 GHC.Integer.Type.removeZeroTails_entry() //  [R2]
         { []
         }
     {offset
       c835: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c836; else goto c837;
       c836: // global
           R2 = R2;
           R1 = GHC.Integer.Type.removeZeroTails_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c837: // global
           I64[Sp - 8] = block_c82Y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u83K; else goto c82Z;
       u83K: // global
           call _c82Y(R1) args: 0, res: 0, upd: 0;
       c82Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.removeZeroTails_info" {
     GHC.Integer.Type.removeZeroTails_info:
         const GHC.Integer.Type.removeZeroTails_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c82Y() //  [R1]
         { []
         }
     {offset
       c82Y: // global
           if (R1 & 7 == 1) goto c832; else goto u83H;
       c832: // global
           _s7ms::P64 = P64[R1 + 7];
           _s7mt::I64 = I64[R1 + 15];
           if (_s7mt::I64 != 0) goto c83j; else goto c83p;
       c83j: // global
           I64[Sp - 8] = block_c83d_info;
           R2 = _s7ms::P64;
           I64[Sp] = _s7mt::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
       c83p: // global
           I64[Sp] = block_c83o_info;
           R2 = _s7ms::P64;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
       u83H: // global
           Sp = Sp + 8;
           call _c833() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c82Y_info" {
     block_c82Y_info:
         const _c82Y;
         const 0;
         const 30;
 },
 _c83d() //  [R1]
         { []
         }
     {offset
       c83d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c83m; else goto c83l;
       c83m: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c83l: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c83d_info" {
     block_c83d_info:
         const _c83d;
         const 65;
         const 30;
 },
 _c83o() //  [R1]
         { []
         }
     {offset
       c83o: // global
           if (R1 & 7 == 1) goto c83v; else goto u83I;
       c83v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c83y; else goto c83x;
       c83y: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c83x: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u83I: // global
           Sp = Sp + 8;
           call _c833() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c83o_info" {
     block_c83o_info:
         const _c83o;
         const 0;
         const 30;
 },
 _c833() //  []
         { []
         }
     {offset
       c833: // global
           R1 = GHC.Integer.Type.None_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.449970794 UTC

[section ""data" . GHC.Integer.Type.digitsToNegativeInteger_closure" {
     GHC.Integer.Type.digitsToNegativeInteger_closure:
         const GHC.Integer.Type.digitsToNegativeInteger_info;
 },
 GHC.Integer.Type.digitsToNegativeInteger_entry() //  [R2]
         { []
         }
     {offset
       c84q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c84r; else goto c84s;
       c84r: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsToNegativeInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c84s: // global
           I64[Sp - 8] = block_c84k_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.digitsToNegativeInteger_info" {
     GHC.Integer.Type.digitsToNegativeInteger_info:
         const GHC.Integer.Type.digitsToNegativeInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c84k() //  [R1]
         { []
         }
     {offset
       c84k: // global
           if (R1 & 7 == 1) goto c84n; else goto c84o;
       c84n: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c84y; else goto c84x;
       c84y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c84x: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c84o: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c84k_info" {
     block_c84k_info:
         const _c84k;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.458249571 UTC

[section ""data" . GHC.Integer.Type.digitsToInteger_closure" {
     GHC.Integer.Type.digitsToInteger_closure:
         const GHC.Integer.Type.digitsToInteger_info;
 },
 GHC.Integer.Type.digitsToInteger_entry() //  [R2]
         { []
         }
     {offset
       c850: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c851; else goto c852;
       c851: // global
           R2 = R2;
           R1 = GHC.Integer.Type.digitsToInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c852: // global
           I64[Sp - 8] = block_c84U_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.digitsToInteger_info" {
     GHC.Integer.Type.digitsToInteger_info:
         const GHC.Integer.Type.digitsToInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c84U() //  [R1]
         { []
         }
     {offset
       c84U: // global
           if (R1 & 7 == 1) goto c84X; else goto c84Y;
       c84X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c858; else goto c857;
       c858: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c857: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c84Y: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c84U_info" {
     block_c84U_info:
         const _c84U;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.472060164 UTC

[section ""data" . GHC.Integer.Type.comparePositive_closure" {
     GHC.Integer.Type.comparePositive_closure:
         const GHC.Integer.Type.comparePositive_info;
 },
 GHC.Integer.Type.comparePositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c85B: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c85C; else goto c85D;
       c85C: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.comparePositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c85D: // global
           I64[Sp - 16] = block_c85u_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u86F; else goto c85v;
       u86F: // global
           call _c85u(R1) args: 0, res: 0, upd: 0;
       c85v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.comparePositive_info" {
     GHC.Integer.Type.comparePositive_info:
         const GHC.Integer.Type.comparePositive_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c85u() //  [R1]
         { []
         }
     {offset
       c85u: // global
           _s7mH::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c85y; else goto c85z;
       c85y: // global
           I64[Sp - 8] = block_c85G_info;
           _s7mK::P64 = P64[R1 + 7];
           _s7mJ::I64 = I64[R1 + 15];
           R1 = _s7mH::P64;
           P64[Sp] = _s7mK::P64;
           I64[Sp + 8] = _s7mJ::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u86D; else goto c85I;
       u86D: // global
           call _c85G(R1) args: 0, res: 0, upd: 0;
       c85I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c85z: // global
           I64[Sp + 8] = block_c86h_info;
           R1 = _s7mH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u86E; else goto c86j;
       u86E: // global
           call _c86h(R1) args: 0, res: 0, upd: 0;
       c86j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c85u_info" {
     block_c85u_info:
         const _c85u;
         const 1;
         const 30;
 },
 _c85G() //  [R1]
         { []
         }
     {offset
       c85G: // global
           if (R1 & 7 == 1) goto c85P; else goto u86z;
       c85P: // global
           I64[Sp] = block_c85M_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u86z: // global
           Sp = Sp + 24;
           call _c86e() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c85G_info" {
     block_c85G_info:
         const _c85G;
         const 130;
         const 30;
 },
 _c85M() //  [R1]
         { []
         }
     {offset
       c85M: // global
           if (R1 & 7 == 2) goto c86a; else goto c85V;
       c86a: // global
           _s7mJ::I64 = I64[Sp + 16];
           _s7mM::I64 = I64[Sp + 8];
           if (_s7mJ::I64 >= _s7mM::I64) goto c868; else goto u86A;
       c868: // global
           if (_s7mJ::I64 <= _s7mM::I64) goto u86C; else goto u86B;
       u86C: // global
           Sp = Sp + 24;
           call _c86t() args: 0, res: 0, upd: 0;
       u86B: // global
           Sp = Sp + 24;
           call _c86e() args: 0, res: 0, upd: 0;
       u86A: // global
           Sp = Sp + 24;
           call _c86p() args: 0, res: 0, upd: 0;
       c85V: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c85M_info" {
     block_c85M_info:
         const _c85M;
         const 194;
         const 30;
 },
 _c86e() //  []
         { []
         }
     {offset
       c86e: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c86h() //  [R1]
         { []
         }
     {offset
       c86h: // global
           if (R1 & 7 == 1) goto u86x; else goto u86y;
       u86x: // global
           Sp = Sp + 8;
           call _c86p() args: 0, res: 0, upd: 0;
       u86y: // global
           Sp = Sp + 8;
           call _c86t() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c86h_info" {
     block_c86h_info:
         const _c86h;
         const 0;
         const 30;
 },
 _c86p() //  []
         { []
         }
     {offset
       c86p: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c86t() //  []
         { []
         }
     {offset
       c86t: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.493148293 UTC

[section ""data" . GHC.Integer.Type.compareInteger_closure" {
     GHC.Integer.Type.compareInteger_closure:
         const GHC.Integer.Type.compareInteger_info;
 },
 GHC.Integer.Type.compareInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c87J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c87K; else goto c87L;
       c87K: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.compareInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c87L: // global
           I64[Sp - 16] = block_c87B_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u88L; else goto c87C;
       u88L: // global
           call _c87B(R1) args: 0, res: 0, upd: 0;
       c87C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.compareInteger_info" {
     GHC.Integer.Type.compareInteger_info:
         const GHC.Integer.Type.compareInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c87B() //  [R1]
         { []
         }
     {offset
       c87B: // global
           _s7mV::P64 = P64[Sp + 8];
           _c87I::P64 = R1 & 7;
           if (_c87I::P64 < 3) goto u88C; else goto c87H;
       u88C: // global
           if (_c87I::P64 < 2) goto c87F; else goto c87G;
       c87F: // global
           I64[Sp] = block_c87O_info;
           _s7mX::P64 = P64[R1 + 7];
           R1 = _s7mV::P64;
           P64[Sp + 8] = _s7mX::P64;
           if (R1 & 7 != 0) goto u88I; else goto c87Q;
       u88I: // global
           call _c87O(R1) args: 0, res: 0, upd: 0;
       c87Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c87G: // global
           I64[Sp] = block_c883_info;
           _s7n0::P64 = P64[R1 + 6];
           R1 = _s7mV::P64;
           P64[Sp + 8] = _s7n0::P64;
           if (R1 & 7 != 0) goto u88J; else goto c885;
       u88J: // global
           call _c883(R1) args: 0, res: 0, upd: 0;
       c885: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c87H: // global
           I64[Sp + 8] = block_c88i_info;
           R1 = _s7mV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u88K; else goto c88k;
       u88K: // global
           call _c88i(R1) args: 0, res: 0, upd: 0;
       c88k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c87B_info" {
     block_c87B_info:
         const _c87B;
         const 1;
         const 30;
 },
 _c87O() //  [R1]
         { []
         }
     {offset
       c87O: // global
           if (R1 & 7 == 1) goto c880; else goto u88E;
       c880: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       u88E: // global
           Sp = Sp + 16;
           call _c88u() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c87O_info" {
     block_c87O_info:
         const _c87O;
         const 1;
         const 30;
 },
 _c883() //  [R1]
         { []
         }
     {offset
       c883: // global
           if (R1 & 7 == 2) goto c88f; else goto u88F;
       c88f: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       u88F: // global
           Sp = Sp + 16;
           call _c88q() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c883_info" {
     block_c883_info:
         const _c883;
         const 1;
         const 30;
 },
 _c88i() //  [R1]
         { []
         }
     {offset
       c88i: // global
           _c88z::P64 = R1 & 7;
           if (_c88z::P64 < 3) goto u88D; else goto c88y;
       u88D: // global
           if (_c88z::P64 < 2) goto u88H; else goto u88G;
       u88H: // global
           Sp = Sp + 8;
           call _c88q() args: 0, res: 0, upd: 0;
       u88G: // global
           Sp = Sp + 8;
           call _c88u() args: 0, res: 0, upd: 0;
       c88y: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c88i_info" {
     block_c88i_info:
         const _c88i;
         const 0;
         const 30;
 },
 _c88q() //  []
         { []
         }
     {offset
       c88q: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c88u() //  []
         { []
         }
     {offset
       c88u: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.512361777 UTC

[section ""data" . GHC.Integer.Type.eqInteger#_closure" {
     GHC.Integer.Type.eqInteger#_closure:
         const GHC.Integer.Type.eqInteger#_info;
 },
 GHC.Integer.Type.eqInteger#_entry() //  [R2, R3]
         { []
         }
     {offset
       c89F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c89G; else goto c89H;
       c89G: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.eqInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c89H: // global
           I64[Sp - 8] = block_c89z_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.eqInteger#_info" {
     GHC.Integer.Type.eqInteger#_info:
         const GHC.Integer.Type.eqInteger#_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c89z() //  [R1]
         { []
         }
     {offset
       c89z: // global
           if (R1 & 7 == 2) goto c89D; else goto c89C;
       c89D: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c89C: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c89z_info" {
     block_c89z_info:
         const _c89z;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.522205677 UTC

[section ""data" . GHC.Integer.Type.eqInteger_closure" {
     GHC.Integer.Type.eqInteger_closure:
         const GHC.Integer.Type.eqInteger_info;
 },
 GHC.Integer.Type.eqInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8a7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8a8; else goto c8a9;
       c8a8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.eqInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8a9: // global
           I64[Sp - 8] = block_c8a5_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.eqInteger_info" {
     GHC.Integer.Type.eqInteger_info:
         const GHC.Integer.Type.eqInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8a5() //  [R1]
         { []
         }
     {offset
       c8a5: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8a5_info" {
     block_c8a5_info:
         const _c8a5;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.529403533 UTC

[section ""data" . GHC.Integer.Type.neqInteger#_closure" {
     GHC.Integer.Type.neqInteger#_closure:
         const GHC.Integer.Type.neqInteger#_info;
 },
 GHC.Integer.Type.neqInteger#_entry() //  [R2, R3]
         { []
         }
     {offset
       c8az: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8aA; else goto c8aB;
       c8aA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.neqInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aB: // global
           I64[Sp - 8] = block_c8at_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.neqInteger#_info" {
     GHC.Integer.Type.neqInteger#_info:
         const GHC.Integer.Type.neqInteger#_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8at() //  [R1]
         { []
         }
     {offset
       c8at: // global
           if (R1 & 7 == 2) goto c8ax; else goto c8aw;
       c8ax: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8aw: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8at_info" {
     block_c8at_info:
         const _c8at;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.535878692 UTC

[section ""data" . GHC.Integer.Type.neqInteger_closure" {
     GHC.Integer.Type.neqInteger_closure:
         const GHC.Integer.Type.neqInteger_info;
 },
 GHC.Integer.Type.neqInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8b1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8b2; else goto c8b3;
       c8b2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.neqInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8b3: // global
           I64[Sp - 8] = block_c8aZ_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.neqInteger_info" {
     GHC.Integer.Type.neqInteger_info:
         const GHC.Integer.Type.neqInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8aZ() //  [R1]
         { []
         }
     {offset
       c8aZ: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8aZ_info" {
     block_c8aZ_info:
         const _c8aZ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.543233233 UTC

[section ""data" . GHC.Integer.Type.$fEqInteger_closure" {
     GHC.Integer.Type.$fEqInteger_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.546475354 UTC

[section ""data" . GHC.Integer.Type.ltInteger#_closure" {
     GHC.Integer.Type.ltInteger#_closure:
         const GHC.Integer.Type.ltInteger#_info;
 },
 GHC.Integer.Type.ltInteger#_entry() //  [R2, R3]
         { []
         }
     {offset
       c8bu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bv; else goto c8bw;
       c8bv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.ltInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bw: // global
           I64[Sp - 8] = block_c8bo_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.ltInteger#_info" {
     GHC.Integer.Type.ltInteger#_info:
         const GHC.Integer.Type.ltInteger#_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8bo() //  [R1]
         { []
         }
     {offset
       c8bo: // global
           if (R1 & 7 == 1) goto c8bs; else goto c8br;
       c8bs: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8br: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8bo_info" {
     block_c8bo_info:
         const _c8bo;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.553705249 UTC

[section ""data" . GHC.Integer.Type.ltInteger_closure" {
     GHC.Integer.Type.ltInteger_closure:
         const GHC.Integer.Type.ltInteger_info;
 },
 GHC.Integer.Type.ltInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8bW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bX; else goto c8bY;
       c8bX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.ltInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bY: // global
           I64[Sp - 8] = block_c8bU_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.ltInteger_info" {
     GHC.Integer.Type.ltInteger_info:
         const GHC.Integer.Type.ltInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8bU() //  [R1]
         { []
         }
     {offset
       c8bU: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8bU_info" {
     block_c8bU_info:
         const _c8bU;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.560319953 UTC

[section ""data" . GHC.Integer.Type.gtInteger#_closure" {
     GHC.Integer.Type.gtInteger#_closure:
         const GHC.Integer.Type.gtInteger#_info;
 },
 GHC.Integer.Type.gtInteger#_entry() //  [R2, R3]
         { []
         }
     {offset
       c8co: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cp; else goto c8cq;
       c8cp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.gtInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cq: // global
           I64[Sp - 8] = block_c8ci_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.gtInteger#_info" {
     GHC.Integer.Type.gtInteger#_info:
         const GHC.Integer.Type.gtInteger#_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8ci() //  [R1]
         { []
         }
     {offset
       c8ci: // global
           if (R1 & 7 == 3) goto c8cm; else goto c8cl;
       c8cm: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8cl: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8ci_info" {
     block_c8ci_info:
         const _c8ci;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.56744775 UTC

[section ""data" . GHC.Integer.Type.gtInteger_closure" {
     GHC.Integer.Type.gtInteger_closure:
         const GHC.Integer.Type.gtInteger_info;
 },
 GHC.Integer.Type.gtInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8cQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cR; else goto c8cS;
       c8cR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.gtInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cS: // global
           I64[Sp - 8] = block_c8cO_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.gtInteger_info" {
     GHC.Integer.Type.gtInteger_info:
         const GHC.Integer.Type.gtInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8cO() //  [R1]
         { []
         }
     {offset
       c8cO: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8cO_info" {
     block_c8cO_info:
         const _c8cO;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.574971202 UTC

[section ""data" . GHC.Integer.Type.leInteger#_closure" {
     GHC.Integer.Type.leInteger#_closure:
         const GHC.Integer.Type.leInteger#_info;
 },
 GHC.Integer.Type.leInteger#_entry() //  [R2, R3]
         { []
         }
     {offset
       c8di: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8dj; else goto c8dk;
       c8dj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.leInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8dk: // global
           I64[Sp - 8] = block_c8dc_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.leInteger#_info" {
     GHC.Integer.Type.leInteger#_info:
         const GHC.Integer.Type.leInteger#_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8dc() //  [R1]
         { []
         }
     {offset
       c8dc: // global
           if (R1 & 7 == 3) goto c8dg; else goto c8df;
       c8dg: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8df: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8dc_info" {
     block_c8dc_info:
         const _c8dc;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.581735738 UTC

[section ""data" . GHC.Integer.Type.leInteger_closure" {
     GHC.Integer.Type.leInteger_closure:
         const GHC.Integer.Type.leInteger_info;
 },
 GHC.Integer.Type.leInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8dK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8dL; else goto c8dM;
       c8dL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.leInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8dM: // global
           I64[Sp - 8] = block_c8dI_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.leInteger_info" {
     GHC.Integer.Type.leInteger_info:
         const GHC.Integer.Type.leInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8dI() //  [R1]
         { []
         }
     {offset
       c8dI: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8dI_info" {
     block_c8dI_info:
         const _c8dI;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.588753777 UTC

[section ""data" . GHC.Integer.Type.geInteger#_closure" {
     GHC.Integer.Type.geInteger#_closure:
         const GHC.Integer.Type.geInteger#_info;
 },
 GHC.Integer.Type.geInteger#_entry() //  [R2, R3]
         { []
         }
     {offset
       c8ec: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ed; else goto c8ee;
       c8ed: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.geInteger#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ee: // global
           I64[Sp - 8] = block_c8e6_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.compareInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.geInteger#_info" {
     GHC.Integer.Type.geInteger#_info:
         const GHC.Integer.Type.geInteger#_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8e6() //  [R1]
         { []
         }
     {offset
       c8e6: // global
           if (R1 & 7 == 1) goto c8ea; else goto c8e9;
       c8ea: // global
           R1 = 0;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8e9: // global
           R1 = 1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8e6_info" {
     block_c8e6_info:
         const _c8e6;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.596207559 UTC

[section ""data" . GHC.Integer.Type.geInteger_closure" {
     GHC.Integer.Type.geInteger_closure:
         const GHC.Integer.Type.geInteger_info;
 },
 GHC.Integer.Type.geInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8eE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8eF; else goto c8eG;
       c8eF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.geInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eG: // global
           I64[Sp - 8] = block_c8eC_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.geInteger_info" {
     GHC.Integer.Type.geInteger_info:
         const GHC.Integer.Type.geInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8eC() //  [R1]
         { []
         }
     {offset
       c8eC: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8eC_info" {
     block_c8eC_info:
         const _c8eC;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.603542442 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_$cmax_closure" {
     GHC.Integer.Type.$fOrdInteger_$cmax_closure:
         const GHC.Integer.Type.$fOrdInteger_$cmax_info;
 },
 GHC.Integer.Type.$fOrdInteger_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c8f5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8f6; else goto c8f7;
       c8f6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$fOrdInteger_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8f7: // global
           I64[Sp - 24] = block_c8f0_info;
           _s7nH::P64 = R3;
           R3 = R3;
           _s7nG::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s7nG::P64;
           P64[Sp - 8] = _s7nH::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.$fOrdInteger_$cmax_info" {
     GHC.Integer.Type.$fOrdInteger_$cmax_info:
         const GHC.Integer.Type.$fOrdInteger_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8f0() //  [R1]
         { []
         }
     {offset
       c8f0: // global
           if (R1 == 1) goto c8f4; else goto c8f3;
       c8f4: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8f3: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8f0_info" {
     block_c8f0_info:
         const _c8f0;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.611227973 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_$cmin_closure" {
     GHC.Integer.Type.$fOrdInteger_$cmin_closure:
         const GHC.Integer.Type.$fOrdInteger_$cmin_info;
 },
 GHC.Integer.Type.$fOrdInteger_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c8fA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8fB; else goto c8fC;
       c8fB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.$fOrdInteger_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8fC: // global
           I64[Sp - 24] = block_c8fv_info;
           _s7nK::P64 = R3;
           R3 = R3;
           _s7nJ::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s7nJ::P64;
           P64[Sp - 8] = _s7nK::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.$fOrdInteger_$cmin_info" {
     GHC.Integer.Type.$fOrdInteger_$cmin_info:
         const GHC.Integer.Type.$fOrdInteger_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8fv() //  [R1]
         { []
         }
     {offset
       c8fv: // global
           if (R1 == 1) goto c8fz; else goto c8fy;
       c8fz: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8fy: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8fv_info" {
     block_c8fv_info:
         const _c8fv;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.61733357 UTC

[section ""data" . GHC.Integer.Type.$fOrdInteger_closure" {
     GHC.Integer.Type.$fOrdInteger_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Integer.Type.$fEqInteger_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.624683122 UTC

[section ""data" . GHC.Integer.Type.plusInteger_closure" {
     GHC.Integer.Type.plusInteger_closure:
         const GHC.Integer.Type.plusInteger_info;
         const 0;
 },
 GHC.Integer.Type.plusInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8g9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8ga; else goto u8hJ;
       c8ga: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.plusInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u8hJ: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c8fY() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.plusInteger_info" {
     GHC.Integer.Type.plusInteger_info:
         const GHC.Integer.Type.plusInteger_entry;
         const 0;
         const 141733920782;
         const 8589934607;
         const S7IQ_srt;
 },
 _c8fY() //  []
         { []
         }
     {offset
       c8fY: // global
           _s7nM::P64 = P64[Sp];
           I64[Sp] = block_c8g1_info;
           R1 = _s7nM::P64;
           if (R1 & 7 != 0) goto u8hN; else goto c8g2;
       u8hN: // global
           call _c8g1(R1) args: 0, res: 0, upd: 0;
       c8g2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g1() //  [R1]
         { []
         }
     {offset
       c8g1: // global
           _s7nN::P64 = P64[Sp + 8];
           _c8g8::P64 = R1 & 7;
           if (_c8g8::P64 < 3) goto u8hF; else goto c8g7;
       u8hF: // global
           if (_c8g8::P64 < 2) goto c8g5; else goto c8g6;
       c8g5: // global
           I64[Sp - 8] = block_c8ge_info;
           _s7nO::P64 = R1;
           _s7nP::P64 = P64[R1 + 7];
           R1 = _s7nN::P64;
           P64[Sp] = _s7nP::P64;
           P64[Sp + 8] = _s7nO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8hO; else goto c8gg;
       u8hO: // global
           call _c8ge(R1) args: 0, res: 0, upd: 0;
       c8gg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8g6: // global
           I64[Sp - 8] = block_c8ha_info;
           _s7nO::P64 = R1;
           _s7nX::P64 = P64[R1 + 6];
           R1 = _s7nN::P64;
           P64[Sp] = _s7nX::P64;
           P64[Sp + 8] = _s7nO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8hP; else goto c8hc;
       u8hP: // global
           call _c8ha(R1) args: 0, res: 0, upd: 0;
       c8hc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8g7: // global
           R1 = _s7nN::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8g1_info" {
     block_c8g1_info:
         const _c8g1;
         const 1;
         const 4294967326;
         const S7IQ_srt;
 },
 _c8ge() //  [R1]
         { []
         }
     {offset
       c8ge: // global
           _c8hD::P64 = R1 & 7;
           if (_c8hD::P64 < 3) goto u8hG; else goto u8hK;
       u8hG: // global
           _s7nP::P64 = P64[Sp + 8];
           if (_c8hD::P64 < 2) goto c8gr; else goto c8gz;
       c8gr: // global
           I64[Sp + 16] = block_c8gk_info;
           R4 = P64[R1 + 7];
           R3 = _s7nP::P64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       c8gz: // global
           I64[Sp] = block_c8gx_info;
           _s7nT::P64 = P64[R1 + 6];
           R3 = _s7nT::P64;
           R2 = _s7nP::P64;
           P64[Sp + 16] = _s7nT::P64;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u8hK: // global
           Sp = Sp + 16;
           call _c8hy() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8ge_info" {
     block_c8ge_info:
         const _c8ge;
         const 2;
         const 4294967326;
         const S7IQ_srt;
 },
 _c8gk() //  [R1]
         { []
         }
     {offset
       c8gk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8gu; else goto c8gt;
       c8gu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8gt: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8gk_info" {
     block_c8gk_info:
         const _c8gk;
         const 0;
         const 30;
 },
 _c8gx() //  [R1]
         { []
         }
     {offset
       c8gx: // global
           _s7nP::P64 = P64[Sp + 8];
           _s7nT::P64 = P64[Sp + 16];
           _c8hE::P64 = R1 & 7;
           if (_c8hE::P64 < 3) goto u8hH; else goto c8h0;
       u8hH: // global
           if (_c8hE::P64 < 2) goto c8gK; else goto c8gR;
       c8gK: // global
           I64[Sp + 16] = block_c8gD_info;
           R3 = _s7nP::P64;
           R2 = _s7nT::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c8gR: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8h0: // global
           I64[Sp + 16] = block_c8gU_info;
           R3 = _s7nT::P64;
           R2 = _s7nP::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8gx_info" {
     block_c8gx_info:
         const _c8gx;
         const 2;
         const 30;
 },
 _c8gD() //  [R1]
         { []
         }
     {offset
       c8gD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8gN; else goto c8gM;
       c8gN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8gM: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8gD_info" {
     block_c8gD_info:
         const _c8gD;
         const 0;
         const 30;
 },
 _c8gU() //  [R1]
         { []
         }
     {offset
       c8gU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8h3; else goto c8h2;
       c8h3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8h2: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8gU_info" {
     block_c8gU_info:
         const _c8gU;
         const 0;
         const 30;
 },
 _c8ha() //  [R1]
         { []
         }
     {offset
       c8ha: // global
           _c8hC::P64 = R1 & 7;
           if (_c8hC::P64 < 3) goto u8hI; else goto u8hL;
       u8hI: // global
           if (_c8hC::P64 < 2) goto c8hi; else goto c8hr;
       c8hi: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c8fY() args: 0, res: 0, upd: 0;
       c8hr: // global
           I64[Sp + 16] = block_c8hl_info;
           R4 = P64[R1 + 6];
           R3 = P64[Sp + 8];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusPositive_addWithCarry_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 8, upd: 8;
       u8hL: // global
           Sp = Sp + 16;
           call _c8hy() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8ha_info" {
     block_c8ha_info:
         const _c8ha;
         const 2;
         const 4294967326;
         const S7IQ_srt;
 },
 _c8hl() //  [R1]
         { []
         }
     {offset
       c8hl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8hu; else goto c8ht;
       c8hu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ht: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8hl_info" {
     block_c8hl_info:
         const _c8hl;
         const 0;
         const 30;
 },
 _c8hy() //  []
         { []
         }
     {offset
       c8hy: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.651127777 UTC

[section ""data" . GHC.Integer.Type.minusInteger_closure" {
     GHC.Integer.Type.minusInteger_closure:
         const GHC.Integer.Type.minusInteger_info;
         const 0;
 },
 GHC.Integer.Type.minusInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8j0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8j1; else goto c8j2;
       c8j1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.minusInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8j2: // global
           I64[Sp - 16] = block_c8iY_info;
           _s7o2::P64 = R2;
           R2 = R3;
           P64[Sp - 8] = _s7o2::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.minusInteger_info" {
     GHC.Integer.Type.minusInteger_info:
         const GHC.Integer.Type.minusInteger_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S7IQ_srt+40;
 },
 _c8iY() //  [R1]
         { []
         }
     {offset
       c8iY: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8iY_info" {
     block_c8iY_info:
         const _c8iY;
         const 1;
         const 4294967326;
         const S7IQ_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.65789066 UTC

[section ""data" . GHC.Integer.Type.complementInteger_closure" {
     GHC.Integer.Type.complementInteger_closure:
         const GHC.Integer.Type.complementInteger_info;
         const 0;
 },
 GHC.Integer.Type.complementInteger_entry() //  [R2]
         { []
         }
     {offset
       c8jj: // global
           R3 = R2;
           R2 = GHC.Integer.Type.negativeOneInteger_closure+2;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.complementInteger_info" {
     GHC.Integer.Type.complementInteger_info:
         const GHC.Integer.Type.complementInteger_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S7IQ_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.664235481 UTC

[section ""data" . GHC.Integer.Type.decodeDoubleInteger_closure" {
     GHC.Integer.Type.decodeDoubleInteger_closure:
         const GHC.Integer.Type.decodeDoubleInteger_info;
         const 0;
 },
 sat_s7oh_entry() //  [R1]
         { []
         }
     {offset
       c8jE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8jU; else goto c8jV;
       c8jU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8jV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8jC_info;
           R2 = I64[R1 + 32];
           I64[Sp - 32] = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7oh_info" {
     sat_s7oh_info:
         const sat_s7oh_entry;
         const 12884901888;
         const 12884901903;
         const S7IQ_srt+32;
 },
 _c8jC() //  [R1]
         { []
         }
     {offset
       c8jC: // global
           I64[Sp] = block_c8jH_info;
           R2 = I64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_c8jC_info" {
     block_c8jC_info:
         const _c8jC;
         const 194;
         const 12884901918;
         const S7IQ_srt+32;
 },
 _c8jH() //  [R1]
         { []
         }
     {offset
       c8jH: // global
           I64[Sp] = block_c8jL_info;
           R3 = GHC.Integer.Type.twoToTheThirtytwoInteger_closure+1;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_c8jH_info" {
     block_c8jH_info:
         const _c8jH;
         const 66;
         const 12884901918;
         const S7IQ_srt+32;
 },
 _c8jL() //  [R1]
         { []
         }
     {offset
       c8jL: // global
           I64[Sp] = block_c8jP_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_c8jL_info" {
     block_c8jL_info:
         const _c8jL;
         const 66;
         const 12884901918;
         const S7IQ_srt+32;
 },
 _c8jP() //  [R1]
         { []
         }
     {offset
       c8jP: // global
           _s7o8::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8jT_info;
           R2 = _s7o8::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_c8jP_info" {
     block_c8jP_info:
         const _c8jP;
         const 194;
         const 4294967326;
         const S7IQ_srt+32;
 },
 _c8jT() //  [R1]
         { []
         }
     {offset
       c8jT: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c8jT_info" {
     block_c8jT_info:
         const _c8jT;
         const 1;
         const 4294967326;
         const S7IQ_srt+32;
 },
 GHC.Integer.Type.decodeDoubleInteger_entry() //  [D1]
         { []
         }
     {offset
       c8k4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8k5; else goto c8k6;
       c8k5: // global
           D1 = D1;
           R1 = GHC.Integer.Type.decodeDoubleInteger_closure;
           call (stg_gc_fun)(D1, R1) args: 8, res: 0, upd: 8;
       c8k6: // global
           I64[Sp - 8] = block_c8ju_info;
           D1 = D1;
           Sp = Sp - 8;
           call stg_decodeDouble_2Int#(D1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.decodeDoubleInteger_info" {
     GHC.Integer.Type.decodeDoubleInteger_info:
         const GHC.Integer.Type.decodeDoubleInteger_entry;
         const 0;
         const 47244640270;
         const 4294967303;
         const S7IQ_srt+32;
 },
 _c8ju() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       c8ju: // global
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           I64[Sp] = R1;
           Sp = Sp - 32;
           call _c8jv() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8ju_info" {
     block_c8ju_info:
         const _c8ju;
         const 0;
         const 12884901918;
         const S7IQ_srt+32;
 },
 _c8jv() //  []
         { []
         }
     {offset
       c8jv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8k9; else goto c8k8;
       c8k9: // global
           HpAlloc = 40;
           I64[Sp] = block_c8jv_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8k8: // global
           I64[Hp - 32] = sat_s7oh_info;
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = I64[Sp + 24];
           R1 = Hp - 32;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8jv_info" {
     block_c8jv_info:
         const _c8jv;
         const 964;
         const 12884901918;
         const S7IQ_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.686720075 UTC

[section ""data" . GHC.Integer.Type.smallShiftLPositive_closure" {
     GHC.Integer.Type.smallShiftLPositive_closure:
         const GHC.Integer.Type.smallShiftLPositive_info;
 },
 f2_s7om_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8lg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8lh; else goto c8li;
       c8lh: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8li: // global
           I64[Sp - 40] = block_c8l9_info;
           _s7om::P64 = R1;
           _s7ok::I64 = I64[R1 + 6];
           _s7ol::I64 = I64[R1 + 14];
           R1 = R3;
           I64[Sp - 32] = _s7ok::I64;
           I64[Sp - 24] = _s7ol::I64;
           P64[Sp - 16] = _s7om::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8lO; else goto c8la;
       u8lO: // global
           call _c8l9(R1) args: 0, res: 0, upd: 0;
       c8la: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . f2_s7om_info" {
     f2_s7om_info:
         const f2_s7om_entry;
         const 8589934592;
         const 13;
         const 8589934605;
 },
 _c8l9() //  [R1]
         { []
         }
     {offset
       c8l9: // global
           if (R1 & 7 == 1) goto c8ld; else goto c8le;
       c8ld: // global
           I64[Sp] = block_c8lo_info;
           R3 = P64[R1 + 7];
           _s7oq::I64 = I64[R1 + 15];
           R2 = _s7oq::I64 >> I64[Sp + 16];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7oq::I64;
           call f2_s7om_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
       c8le: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lH; else goto c8lG;
       c8lH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lG: // global
           _s7ow::I64 = I64[Sp + 32];
           if (_s7ow::I64 != 0) goto c8lM; else goto c8lN;
       c8lM: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s7ow::I64;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8lN: // global
           Hp = Hp - 24;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8l9_info" {
     block_c8l9_info:
         const _c8l9;
         const 708;
         const 30;
 },
 _c8lo() //  [R1]
         { []
         }
     {offset
       c8lo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lC; else goto c8lB;
       c8lC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8lB: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = (I64[Sp + 24] << I64[Sp + 8]) | I64[Sp + 32];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8lo_info" {
     block_c8lo_info:
         const _c8lo;
         const 964;
         const 30;
 },
 GHC.Integer.Type.smallShiftLPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c8lS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8lW; else goto c8lV;
       c8lW: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.smallShiftLPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8lV: // global
           if (R3 == 0) goto c8lR; else goto c8lQ;
       c8lR: // global
           Hp = Hp - 24;
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8lQ: // global
           I64[Hp - 16] = f2_s7om_info;
           I64[Hp - 8] = R3;
           I64[Hp] = 64 - R3;
           R3 = R2;
           R2 = 0;
           R1 = Hp - 14;
           call f2_s7om_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.smallShiftLPositive_info" {
     GHC.Integer.Type.smallShiftLPositive_info:
         const GHC.Integer.Type.smallShiftLPositive_entry;
         const 0;
         const 14;
         const 8589934606;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.700704456 UTC

[section ""data" . GHC.Integer.Type.smallShiftRPositive_closure" {
     GHC.Integer.Type.smallShiftRPositive_closure:
         const GHC.Integer.Type.smallShiftRPositive_info;
 },
 GHC.Integer.Type.smallShiftRPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c8mC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8mD; else goto c8mE;
       c8mD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.smallShiftRPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8mE: // global
           I64[Sp - 16] = block_c8mz_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8no; else goto c8mA;
       u8no: // global
           call _c8mz(R1) args: 0, res: 0, upd: 0;
       c8mA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.smallShiftRPositive_info" {
     GHC.Integer.Type.smallShiftRPositive_info:
         const GHC.Integer.Type.smallShiftRPositive_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c8mz() //  [R1]
         { []
         }
     {offset
       c8mz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8mJ; else goto c8mI;
       c8mJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8mI: // global
           _s7oA::I64 = I64[Sp + 8];
           if (_s7oA::I64 == 0) goto c8nj; else goto c8mR;
       c8nj: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8mR: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_c8mP_info;
           R3 = 64 - _s7oA::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8mz_info" {
     block_c8mz_info:
         const _c8mz;
         const 65;
         const 30;
 },
 _c8mP() //  [R1]
         { []
         }
     {offset
       c8mP: // global
           if (R1 & 7 == 1) goto c8mY; else goto u8nm;
       c8mY: // global
           I64[Sp] = block_c8mV_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u8np; else goto c8mZ;
       u8np: // global
           call _c8mV(R1) args: 0, res: 0, upd: 0;
       c8mZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8nm: // global
           Sp = Sp + 8;
           call _c8ng() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8mP_info" {
     block_c8mP_info:
         const _c8mP;
         const 0;
         const 30;
 },
 _c8mV() //  [R1]
         { []
         }
     {offset
       c8mV: // global
           if (R1 & 7 == 1) goto c8n5; else goto u8nn;
       c8n5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8n8; else goto c8n7;
       c8n8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8n7: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8nn: // global
           Sp = Sp + 8;
           call _c8ng() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8mV_info" {
     block_c8mV_info:
         const _c8mV;
         const 0;
         const 30;
 },
 _c8ng() //  []
         { []
         }
     {offset
       c8ng: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.715762538 UTC

[section ""data" . GHC.Integer.Type.shiftRPositive_closure" {
     GHC.Integer.Type.shiftRPositive_closure:
         const GHC.Integer.Type.shiftRPositive_info;
 },
 GHC.Integer.Type.shiftRPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c8o8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8o9; else goto u8op;
       c8o9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftRPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u8op: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c8nY() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.shiftRPositive_info" {
     GHC.Integer.Type.shiftRPositive_info:
         const GHC.Integer.Type.shiftRPositive_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c8nY() //  []
         { []
         }
     {offset
       c8nY: // global
           _s7oI::P64 = P64[Sp];
           I64[Sp] = block_c8o1_info;
           R1 = _s7oI::P64;
           if (R1 & 7 != 0) goto u8or; else goto c8o2;
       u8or: // global
           call _c8o1(R1) args: 0, res: 0, upd: 0;
       c8o2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8o1() //  [R1]
         { []
         }
     {offset
       c8o1: // global
           if (R1 & 7 == 1) goto c8o5; else goto c8o6;
       c8o5: // global
           _s7oJ::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s7oJ::I64, 64)) goto c8oh; else goto c8oi;
       c8oh: // global
           R3 = _s7oJ::I64;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallShiftRPositive_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       c8oi: // global
           P64[Sp] = P64[R1 + 7];
           I64[Sp + 8] = _s7oJ::I64 - 64;
           call _c8nY() args: 0, res: 0, upd: 0;
       c8o6: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8o1_info" {
     block_c8o1_info:
         const _c8o1;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.725389103 UTC

[section ""data" . GHC.Integer.Type.shiftRInteger_closure" {
     GHC.Integer.Type.shiftRInteger_closure:
         const GHC.Integer.Type.shiftRInteger_info;
         const 0;
 },
 GHC.Integer.Type.shiftRInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8oX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8oY; else goto c8oZ;
       c8oY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftRInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8oZ: // global
           I64[Sp - 16] = block_c8oP_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8pk; else goto c8oQ;
       u8pk: // global
           call _c8oP(R1) args: 0, res: 0, upd: 0;
       c8oQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.shiftRInteger_info" {
     GHC.Integer.Type.shiftRInteger_info:
         const GHC.Integer.Type.shiftRInteger_entry;
         const 0;
         const 12884901902;
         const 8589934606;
         const S7IQ_srt+64;
 },
 _c8oP() //  [R1]
         { []
         }
     {offset
       c8oP: // global
           _c8oW::P64 = R1 & 7;
           if (_c8oW::P64 < 3) goto u8pj; else goto c8oV;
       u8pj: // global
           if (_c8oW::P64 < 2) goto c8oT; else goto c8oU;
       c8oT: // global
           R3 = I64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRPositive_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
       c8oU: // global
           I64[Sp] = block_c8p5_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
       c8oV: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8oP_info" {
     block_c8oP_info:
         const _c8oP;
         const 65;
         const 12884901918;
         const S7IQ_srt+64;
 },
 _c8p5() //  [R1]
         { []
         }
     {offset
       c8p5: // global
           _s7oQ::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8p9_info;
           R3 = _s7oQ::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8p5_info" {
     block_c8p5_info:
         const _c8p5;
         const 65;
         const 12884901918;
         const S7IQ_srt+64;
 },
 _c8p9() //  [R1]
         { []
         }
     {offset
       c8p9: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8p9_info" {
     block_c8p9_info:
         const _c8p9;
         const 0;
         const 4294967326;
         const S7IQ_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.737113213 UTC

[section ""data" . GHC.Integer.Type.shiftLPositive_closure" {
     GHC.Integer.Type.shiftLPositive_closure:
         const GHC.Integer.Type.shiftLPositive_info;
 },
 GHC.Integer.Type.shiftLPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c8pZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8q0; else goto u8q5;
       c8q0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftLPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u8q5: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c8pG() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.shiftLPositive_info" {
     GHC.Integer.Type.shiftLPositive_info:
         const GHC.Integer.Type.shiftLPositive_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c8pG() //  []
         { []
         }
     {offset
       c8pG: // global
           _s7oW::P64 = P64[Sp];
           _s7oX::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s7oX::I64, 64)) goto c8pX; else goto c8pY;
       c8pX: // global
           R3 = _s7oX::I64;
           R2 = _s7oW::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       c8pY: // global
           I64[Sp] = block_c8pN_info;
           R1 = _s7oW::P64;
           if (R1 & 7 != 0) goto u8q7; else goto c8pO;
       u8q7: // global
           call _c8pN(R1) args: 0, res: 0, upd: 0;
       c8pO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8pN() //  [R1]
         { []
         }
     {offset
       c8pN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8q4; else goto c8q3;
       c8q4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8q3: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = 0;
           P64[Sp] = Hp - 15;
           I64[Sp + 8] = I64[Sp + 8] - 64;
           call _c8pG() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8pN_info" {
     block_c8pN_info:
         const _c8pN;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.746428809 UTC

[section ""data" . GHC.Integer.Type.shiftLInteger_closure" {
     GHC.Integer.Type.shiftLInteger_closure:
         const GHC.Integer.Type.shiftLInteger_info;
 },
 GHC.Integer.Type.shiftLInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8qA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8qB; else goto c8qC;
       c8qB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.shiftLInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8qC: // global
           I64[Sp - 16] = block_c8qs_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8r3; else goto c8qt;
       u8r3: // global
           call _c8qs(R1) args: 0, res: 0, upd: 0;
       c8qt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.shiftLInteger_info" {
     GHC.Integer.Type.shiftLInteger_info:
         const GHC.Integer.Type.shiftLInteger_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c8qs() //  [R1]
         { []
         }
     {offset
       c8qs: // global
           _c8qz::P64 = R1 & 7;
           if (_c8qz::P64 < 3) goto u8r2; else goto c8qy;
       u8r2: // global
           _s7p3::I64 = I64[Sp + 8];
           if (_c8qz::P64 < 2) goto c8qw; else goto c8qx;
       c8qw: // global
           I64[Sp + 8] = block_c8qF_info;
           R3 = _s7p3::I64;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLPositive_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
       c8qx: // global
           I64[Sp + 8] = block_c8qQ_info;
           R3 = _s7p3::I64;
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLPositive_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
       c8qy: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8qs_info" {
     block_c8qs_info:
         const _c8qs;
         const 65;
         const 30;
 },
 _c8qF() //  [R1]
         { []
         }
     {offset
       c8qF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qN; else goto c8qM;
       c8qN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qM: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8qF_info" {
     block_c8qF_info:
         const _c8qF;
         const 0;
         const 30;
 },
 _c8qQ() //  [R1]
         { []
         }
     {offset
       c8qQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8qY; else goto c8qX;
       c8qY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8qX: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8qQ_info" {
     block_c8qQ_info:
         const _c8qQ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.760504558 UTC

[section ""data" . GHC.Integer.Type.some_closure" {
     GHC.Integer.Type.some_closure:
         const GHC.Integer.Type.some_info;
 },
 GHC.Integer.Type.some_entry() //  [R2, R3]
         { []
         }
     {offset
       c8rD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8rE; else goto c8rF;
       c8rE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.some_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8rF: // global
           I64[Sp - 16] = block_c8rw_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8rX; else goto c8rx;
       u8rX: // global
           call _c8rw(R1) args: 0, res: 0, upd: 0;
       c8rx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.some_info" {
     GHC.Integer.Type.some_info:
         const GHC.Integer.Type.some_entry;
         const 0;
         const 14;
         const 8589934605;
 },
 _c8rw() //  [R1]
         { []
         }
     {offset
       c8rw: // global
           _s7p9::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c8rA; else goto c8rB;
       c8rA: // global
           Hp = Hp + 24;
           _s7pb::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8rQ; else goto c8rK;
       c8rK: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = _s7pb::P64;
           I64[Hp] = _s7p9::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8rB: // global
           Hp = Hp + 24;
           _s7pb::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8rQ; else goto c8rP;
       c8rQ: // global
           HpAlloc = 24;
           R1 = _s7pb::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8rP: // global
           if (_s7p9::I64 == 0) goto c8rW; else goto c8rV;
       c8rW: // global
           Hp = Hp - 24;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8rV: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s7p9::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8rw_info" {
     block_c8rw_info:
         const _c8rw;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.769514486 UTC

[section ""data" . GHC.Integer.Type.quotRemPositive_g_closure" {
     GHC.Integer.Type.quotRemPositive_g_closure:
         const GHC.Integer.Type.quotRemPositive_g_info;
 },
 GHC.Integer.Type.quotRemPositive_g_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c8sr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8ss; else goto u8t2;
       c8ss: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemPositive_g_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u8t2: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c8sh() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.quotRemPositive_g_info" {
     GHC.Integer.Type.quotRemPositive_g_info:
         const GHC.Integer.Type.quotRemPositive_g_entry;
         const 0;
         const 14;
         const 12884901907;
 },
 _c8sh() //  []
         { []
         }
     {offset
       c8sh: // global
           I64[Sp - 8] = block_c8sk_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8t5; else goto c8sl;
       u8t5: // global
           call _c8sk(R1) args: 0, res: 0, upd: 0;
       c8sl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sk() //  [R1]
         { []
         }
     {offset
       c8sk: // global
           _s7ph::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8so; else goto c8sp;
       c8so: // global
           I64[Sp] = block_c8sw_info;
           R1 = _s7ph::P64;
           if (R1 & 7 != 0) goto u8t6; else goto c8sy;
       u8t6: // global
           call _c8sw(R1) args: 0, res: 0, upd: 0;
       c8sy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8sp: // global
           I64[Sp - 8] = block_c8sF_info;
           _s7pk::P64 = P64[R1 + 6];
           R3 = _s7pk::P64;
           R2 = _s7ph::P64;
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 16] = _s7pk::P64;
           Sp = Sp - 8;
           call GHC.Integer.Type.comparePositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sk_info" {
     block_c8sk_info:
         const _c8sk;
         const 195;
         const 30;
 },
 _c8sw() //  [R1]
         { []
         }
     {offset
       c8sw: // global
           R2 = R1;
           R1 = I64[Sp + 8];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sw_info" {
     block_c8sw_info:
         const _c8sw;
         const 451;
         const 30;
 },
 _c8sF() //  [R1]
         { []
         }
     {offset
       c8sF: // global
           _s7ph::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c8sV; else goto c8sN;
       c8sV: // global
           I64[Sp + 16] = I64[Sp + 16] << 1;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _s7ph::P64;
           Sp = Sp + 16;
           call _c8sh() args: 0, res: 0, upd: 0;
       c8sN: // global
           I64[Sp] = block_c8sK_info;
           R3 = P64[Sp + 24];
           R2 = _s7ph::P64;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8sF_info" {
     block_c8sF_info:
         const _c8sF;
         const 132;
         const 30;
 },
 _c8sK() //  [R1]
         { []
         }
     {offset
       c8sK: // global
           I64[Sp + 16] = (I64[Sp + 16] << 1) + 1;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call _c8sh() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8sK_info" {
     block_c8sK_info:
         const _c8sK;
         const 900;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.794176933 UTC

[section ""data" . GHC.Integer.Type.quotRemPositive_closure" {
     GHC.Integer.Type.quotRemPositive_closure:
         const GHC.Integer.Type.quotRemPositive_info;
 },
 sat_s7pB_entry() //  [R1]
         { []
         }
     {offset
       c8ub: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8uc; else goto c8ud;
       c8uc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ud: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call mkSubtractors_s7pw_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7pB_info" {
     sat_s7pB_info:
         const sat_s7pB_entry;
         const 4294967297;
         const 19;
 },
 sat_s7pz_entry() //  [R1]
         { []
         }
     {offset
       c8ui: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8uj; else goto c8uk;
       c8uj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8uk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallShiftLPositive_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7pz_info" {
     sat_s7pz_info:
         const sat_s7pz_entry;
         const 4294967297;
         const 19;
 },
 mkSubtractors_s7pw_entry() //  [R1, R2]
         { []
         }
     {offset
       c8uo: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8us; else goto c8ur;
       c8us: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ur: // global
           if (R2 == 0) goto c8un; else goto c8um;
       c8un: // global
           _s7pv::P64 = P64[R1 + 15];
           Hp = Hp - 88;
           R1 = _s7pv::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8um: // global
           _s7pt::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s7pB_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s7pz_info;
           P64[Hp - 32] = _s7pt::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . mkSubtractors_s7pw_info" {
     mkSubtractors_s7pw_info:
         const mkSubtractors_s7pw_entry;
         const 2;
         const 11;
         const 4294967300;
 },
 subtractors_s7pu_entry() //  [R1]
         { []
         }
     {offset
       c8uu: // global
           _s7pu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8uv; else goto c8uw;
       c8uw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8uy; else goto c8ux;
       c8uy: // global
           HpAlloc = 48;
           goto c8uv;
       c8uv: // global
           R1 = _s7pu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ux: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7pu::P64;
           _s7pt::P64 = P64[_s7pu::P64 + 16];
           I64[Hp - 40] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 32] = _s7pt::P64;
           P64[Hp - 24] = GHC.Integer.Type.Nil_closure+1;
           I64[Hp - 16] = mkSubtractors_s7pw_info;
           P64[Hp - 8] = _s7pt::P64;
           P64[Hp] = Hp - 38;
           R2 = 63;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call mkSubtractors_s7pw_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . subtractors_s7pu_info" {
     subtractors_s7pu_info:
         const subtractors_s7pu_entry;
         const 1;
         const 16;
 },
 sat_s7pR_entry() //  [R1]
         { []
         }
     {offset
       c8uZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8v0; else goto c8v1;
       c8v0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8v1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7pR_info" {
     sat_s7pR_info:
         const sat_s7pR_entry;
         const 4294967297;
         const 19;
 },
 sat_s7pX_entry() //  [R1]
         { []
         }
     {offset
       c8vf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8vg; else goto c8vh;
       c8vg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7pX_info" {
     sat_s7pX_info:
         const sat_s7pX_entry;
         const 4294967297;
         const 19;
 },
 sat_s7q1_entry() //  [R1]
         { []
         }
     {offset
       c8vr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8vs; else goto c8vt;
       c8vs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8vt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.some_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7q1_info" {
     sat_s7q1_info:
         const sat_s7q1_entry;
         const 4294967297;
         const 19;
 },
 f2_s7pC_entry() //  [R1, R2]
         { []
         }
     {offset
       c8vy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8vz; else goto c8vA;
       c8vz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8vA: // global
           I64[Sp - 24] = block_c8uE_info;
           _s7pC::P64 = R1;
           _s7pu::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s7pu::P64;
           P64[Sp - 8] = _s7pC::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8w9; else goto c8uF;
       u8w9: // global
           call _c8uE(R1) args: 0, res: 0, upd: 0;
       c8uF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . f2_s7pC_info" {
     f2_s7pC_info:
         const f2_s7pC_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _c8uE() //  [R1]
         { []
         }
     {offset
       c8uE: // global
           if (R1 & 7 == 1) goto c8vv; else goto c8vw;
       c8vv: // global
           I64[Sp] = block_c8uJ_info;
           R2 = P64[R1 + 7];
           _s7pF::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7pF::I64;
           call f2_s7pC_entry(R2, R1) args: 8, res: 8, upd: 8;
       c8vw: // global
           R2 = GHC.Integer.Type.None_closure+2;
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8uE_info" {
     block_c8uE_info:
         const _c8uE;
         const 2;
         const 30;
 },
 _c8uJ() //  [R1, R2]
         { []
         }
     {offset
       c8uJ: // global
           I64[Sp - 8] = block_c8uL_info;
           _s7pI::P64 = R1;
           R1 = R2;
           P64[Sp] = _s7pI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8w5; else goto c8uM;
       u8w5: // global
           call _c8uL(R1) args: 0, res: 0, upd: 0;
       c8uM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8uJ_info" {
     block_c8uJ_info:
         const _c8uJ;
         const 130;
         const 30;
 },
 _c8uL() //  [R1]
         { []
         }
     {offset
       c8uL: // global
           _s7pu::P64 = P64[Sp + 16];
           _s7pF::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c8vE; else goto c8vL;
       c8vE: // global
           Hp = Hp + 24;
           _s7pK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8vO; else goto c8vG;
       c8vG: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = _s7pK::P64;
           I64[Hp] = _s7pF::I64;
           I64[Sp] = block_c8uR_info;
           R4 = Hp - 15;
           R3 = _s7pu::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
       c8vL: // global
           Hp = Hp + 24;
           _s7pK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8vO; else goto c8vN;
       c8vO: // global
           HpAlloc = 24;
           R1 = _s7pK::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8vN: // global
           if (_s7pF::I64 == 0) goto c8vU; else goto c8vQ;
       c8vU: // global
           Hp = Hp - 24;
           I64[Sp] = block_c8vj_info;
           R4 = GHC.Integer.Type.None_closure+2;
           R3 = _s7pu::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
       c8vQ: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = GHC.Integer.Type.None_closure+2;
           I64[Hp] = _s7pF::I64;
           I64[Sp] = block_c8v7_info;
           R4 = Hp - 15;
           R3 = _s7pu::P64;
           R2 = 0;
           call GHC.Integer.Type.quotRemPositive_g_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8uL_info" {
     block_c8uL_info:
         const _c8uL;
         const 259;
         const 30;
 },
 _c8uR() //  [R1, R2]
         { []
         }
     {offset
       c8uR: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c8uS() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8uR_info" {
     block_c8uR_info:
         const _c8uR;
         const 387;
         const 30;
 },
 _c8uS() //  []
         { []
         }
     {offset
       c8uS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8vK; else goto c8vJ;
       c8vK: // global
           HpAlloc = 32;
           I64[Sp] = block_c8uS_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vJ: // global
           I64[Hp - 24] = sat_s7pR_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8uS_info" {
     block_c8uS_info:
         const _c8uS;
         const 259;
         const 30;
 },
 _c8vj() //  [R1, R2]
         { []
         }
     {offset
       c8vj: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c8vk() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8vj_info" {
     block_c8vj_info:
         const _c8vj;
         const 387;
         const 30;
 },
 _c8vk() //  []
         { []
         }
     {offset
       c8vk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8vX; else goto c8vW;
       c8vX: // global
           HpAlloc = 32;
           I64[Sp] = block_c8vk_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vW: // global
           I64[Hp - 24] = sat_s7q1_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8vk_info" {
     block_c8vk_info:
         const _c8vk;
         const 259;
         const 30;
 },
 _c8v7() //  [R1, R2]
         { []
         }
     {offset
       c8v7: // global
           P64[Sp + 16] = R2;
           I64[Sp + 24] = R1;
           call _c8v8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8v7_info" {
     block_c8v7_info:
         const _c8v7;
         const 387;
         const 30;
 },
 _c8v8() //  []
         { []
         }
     {offset
       c8v8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8vT; else goto c8vS;
       c8vT: // global
           HpAlloc = 32;
           I64[Sp] = block_c8v8_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8vS: // global
           I64[Hp - 24] = sat_s7pX_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8v8_info" {
     block_c8v8_info:
         const _c8v8;
         const 259;
         const 30;
 },
 sat_s7q6_entry() //  [R1]
         { []
         }
     {offset
       c8wg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8wh; else goto c8wi;
       c8wh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.digitsMaybeZeroToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7q6_info" {
     sat_s7q6_info:
         const sat_s7q6_entry;
         const 1;
         const 16;
 },
 sat_s7q5_entry() //  [R1]
         { []
         }
     {offset
       c8wn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8wo; else goto c8wp;
       c8wo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8wp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.digitsMaybeZeroToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7q5_info" {
     sat_s7q5_info:
         const sat_s7q5_entry;
         const 1;
         const 16;
 },
 GHC.Integer.Type.quotRemPositive_entry() //  [R2, R3]
         { []
         }
     {offset
       c8wq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8wr; else goto c8ws;
       c8wr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemPositive_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ws: // global
           I64[Sp - 16] = block_c8tO_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8wz; else goto c8tP;
       u8wz: // global
           call _c8tO(R1) args: 0, res: 0, upd: 0;
       c8tP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.quotRemPositive_info" {
     GHC.Integer.Type.quotRemPositive_info:
         const GHC.Integer.Type.quotRemPositive_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8tO() //  [R1]
         { []
         }
     {offset
       c8tO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8wv; else goto c8wu;
       c8wv: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8wu: // global
           I64[Hp - 32] = subtractors_s7pu_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = f2_s7pC_info;
           P64[Hp] = Hp - 32;
           _s7pr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8wa_info;
           R2 = _s7pr::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call f2_s7pC_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8tO_info" {
     block_c8tO_info:
         const _c8tO;
         const 1;
         const 30;
 },
 _c8wa() //  [R1, R2]
         { []
         }
     {offset
       c8wa: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8wy; else goto c8wx;
       c8wy: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8wx: // global
           I64[Hp - 40] = sat_s7q6_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7q5_info;
           P64[Hp] = R1;
           R2 = Hp - 40;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8wa_info" {
     block_c8wa_info:
         const _c8wa;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.865030111 UTC

[section ""data" . GHC.Integer.Type.quotRemInteger_closure" {
     GHC.Integer.Type.quotRemInteger_closure:
         const GHC.Integer.Type.quotRemInteger_info;
 },
 sat_s7qj_entry() //  [R1]
         { []
         }
     {offset
       c8zi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zj; else goto c8zk;
       c8zj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8zk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7qj_info" {
     sat_s7qj_info:
         const sat_s7qj_entry;
         const 1;
         const 16;
 },
 sat_s7qr_entry() //  [R1]
         { []
         }
     {offset
       c8zy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zz; else goto c8zA;
       c8zz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8zA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7qr_info" {
     sat_s7qr_info:
         const sat_s7qr_entry;
         const 1;
         const 16;
 },
 sat_s7qq_entry() //  [R1]
         { []
         }
     {offset
       c8zF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zG; else goto c8zH;
       c8zG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8zH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7qq_info" {
     sat_s7qq_info:
         const sat_s7qq_entry;
         const 1;
         const 16;
 },
 sat_s7qw_entry() //  [R1]
         { []
         }
     {offset
       c8zQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zR; else goto c8zS;
       c8zR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8zS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7qw_info" {
     sat_s7qw_info:
         const sat_s7qw_entry;
         const 1;
         const 16;
 },
 GHC.Integer.Type.quotRemInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8zX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zY; else goto c8zZ;
       c8zY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotRemInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8zZ: // global
           I64[Sp - 16] = block_c8yR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8AP; else goto c8yS;
       u8AP: // global
           call _c8yR(R1) args: 0, res: 0, upd: 0;
       c8yS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.quotRemInteger_info" {
     GHC.Integer.Type.quotRemInteger_info:
         const GHC.Integer.Type.quotRemInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8yR() //  [R1]
         { []
         }
     {offset
       c8yR: // global
           _s7q8::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c8zV; else goto c8zU;
       c8zV: // global
           I64[Sp + 8] = block_c8Az_info;
           R1 = _s7q8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8AL; else goto c8AB;
       u8AL: // global
           call _c8Az() args: 0, res: 0, upd: 0;
       c8AB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8zU: // global
           I64[Sp] = block_c8yW_info;
           _s7q9::P64 = R1;
           R1 = _s7q8::P64;
           P64[Sp + 8] = _s7q9::P64;
           if (R1 & 7 != 0) goto u8AK; else goto c8yX;
       u8AK: // global
           call _c8yW(R1) args: 0, res: 0, upd: 0;
       c8yX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8yR_info" {
     block_c8yR_info:
         const _c8yR;
         const 1;
         const 30;
 },
 _c8Az() //  []
         { []
         }
     {offset
       c8Az: // global
           R2 = GHC.Integer.Type.Naught_closure+3;
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Az_info" {
     block_c8Az_info:
         const _c8Az;
         const 0;
         const 30;
 },
 _c8yW() //  [R1]
         { []
         }
     {offset
       c8yW: // global
           if (R1 & 7 == 3) goto c8Aw; else goto c8A3;
       c8Aw: // global
           R2 = GHC.Integer.Type.errorInteger_closure+1;
           R1 = GHC.Integer.Type.errorInteger_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c8A3: // global
           I64[Sp] = block_c8z1_info;
           _s7qa::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7qa::P64;
           if (R1 & 7 != 0) goto u8AM; else goto c8z2;
       u8AM: // global
           call _c8z1(R1) args: 0, res: 0, upd: 0;
       c8z2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8yW_info" {
     block_c8yW_info:
         const _c8yW;
         const 1;
         const 30;
 },
 _c8z1() //  [R1]
         { []
         }
     {offset
       c8z1: // global
           _s7qa::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c8A6; else goto c8Ah;
       c8A6: // global
           I64[Sp] = block_c8z6_info;
           _s7qc::P64 = P64[R1 + 7];
           R1 = _s7qa::P64;
           P64[Sp + 8] = _s7qc::P64;
           if (R1 & 7 != 0) goto u8AN; else goto c8z7;
       u8AN: // global
           call _c8z6(R1) args: 0, res: 0, upd: 0;
       c8z7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Ah: // global
           I64[Sp] = block_c8zn_info;
           _s7qk::P64 = P64[R1 + 6];
           R1 = _s7qa::P64;
           P64[Sp + 8] = _s7qk::P64;
           if (R1 & 7 != 0) goto u8AO; else goto c8zo;
       u8AO: // global
           call _c8zn(R1) args: 0, res: 0, upd: 0;
       c8zo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8z1_info" {
     block_c8z1_info:
         const _c8z1;
         const 1;
         const 30;
 },
 _c8z6() //  [R1]
         { []
         }
     {offset
       c8z6: // global
           _s7qc::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c8Aa; else goto c8Ac;
       c8Aa: // global
           R3 = P64[R1 + 7];
           R2 = _s7qc::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8Ac: // global
           I64[Sp + 8] = block_c8zc_info;
           R3 = P64[R1 + 6];
           R2 = _s7qc::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8z6_info" {
     block_c8z6_info:
         const _c8z6;
         const 1;
         const 30;
 },
 _c8zc() //  [R1, R2]
         { []
         }
     {offset
       c8zc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Af; else goto c8Ae;
       c8Af: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8Ae: // global
           I64[Hp - 16] = sat_s7qj_info;
           P64[Hp] = R1;
           R2 = R2;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8zc_info" {
     block_c8zc_info:
         const _c8zc;
         const 0;
         const 30;
 },
 _c8zn() //  [R1]
         { []
         }
     {offset
       c8zn: // global
           _s7qk::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c8Ak; else goto c8Ap;
       c8Ak: // global
           I64[Sp + 8] = block_c8zs_info;
           R3 = P64[R1 + 7];
           R2 = _s7qk::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       c8Ap: // global
           I64[Sp + 8] = block_c8zK_info;
           R3 = P64[R1 + 6];
           R2 = _s7qk::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemPositive_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8zn_info" {
     block_c8zn_info:
         const _c8zn;
         const 1;
         const 30;
 },
 _c8zs() //  [R1, R2]
         { []
         }
     {offset
       c8zs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8An; else goto c8Am;
       c8An: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8Am: // global
           I64[Hp - 40] = sat_s7qr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7qq_info;
           P64[Hp] = R1;
           R2 = Hp - 40;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8zs_info" {
     block_c8zs_info:
         const _c8zs;
         const 0;
         const 30;
 },
 _c8zK() //  [R1, R2]
         { []
         }
     {offset
       c8zK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8As; else goto c8Ar;
       c8As: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8Ar: // global
           I64[Hp - 16] = sat_s7qw_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8zK_info" {
     block_c8zK_info:
         const _c8zK;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.906900625 UTC

[section ""data" . GHC.Integer.Type.divModInteger_closure" {
     GHC.Integer.Type.divModInteger_closure:
         const GHC.Integer.Type.divModInteger_info;
         const 0;
 },
 sat_s7qI_entry() //  [R1]
         { []
         }
     {offset
       c8CF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CG; else goto c8CH;
       c8CG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7qI_info" {
     sat_s7qI_info:
         const sat_s7qI_entry;
         const 2;
         const 4294967314;
         const S7IQ_srt+40;
 },
 sat_s7qH_entry() //  [R1]
         { []
         }
     {offset
       c8CM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CN; else goto c8CO;
       c8CN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Integer.Type.oneInteger_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7qH_info" {
     sat_s7qH_info:
         const sat_s7qH_entry;
         const 1;
         const 4294967312;
         const S7IQ_srt+48;
 },
 GHC.Integer.Type.divModInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8CP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8CQ; else goto c8CR;
       c8CQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.divModInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CR: // global
           I64[Sp - 16] = block_c8Ci_info;
           _s7qz::P64 = R3;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = _s7qz::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.divModInteger_info" {
     GHC.Integer.Type.divModInteger_info:
         const GHC.Integer.Type.divModInteger_entry;
         const 0;
         const 150323855374;
         const 8589934607;
         const S7IQ_srt+40;
 },
 _c8Ci() //  [R1, R2]
         { []
         }
     {offset
       c8Ci: // global
           I64[Sp - 16] = block_c8Ck_info;
           _s7qC::P64 = R2;
           R2 = P64[Sp + 8];
           P64[Sp - 8] = _s7qC::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Ci_info" {
     block_c8Ci_info:
         const _c8Ci;
         const 1;
         const 12884901918;
         const S7IQ_srt+40;
 },
 _c8Ck() //  [R1]
         { []
         }
     {offset
       c8Ck: // global
           I64[Sp] = block_c8Co_info;
           R2 = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Ck_info" {
     block_c8Ck_info:
         const _c8Ck;
         const 3;
         const 12884901918;
         const S7IQ_srt+40;
 },
 _c8Co() //  [R1]
         { []
         }
     {offset
       c8Co: // global
           I64[Sp - 8] = block_c8Cs_info;
           R2 = P64[Sp + 8];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Co_info" {
     block_c8Co_info:
         const _c8Co;
         const 3;
         const 12884901918;
         const S7IQ_srt+40;
 },
 _c8Cs() //  [R1]
         { []
         }
     {offset
       c8Cs: // global
           _s7qF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Cw_info;
           R3 = _s7qF::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Cs_info" {
     block_c8Cs_info:
         const _c8Cs;
         const 4;
         const 12884901918;
         const S7IQ_srt+40;
 },
 _c8Cw() //  [R1]
         { []
         }
     {offset
       c8Cw: // global
           _s7qB::P64 = P64[Sp + 16];
           _s7qC::P64 = P64[Sp + 8];
           if (R1 == 1) goto c8D0; else goto c8CZ;
       c8D0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8D3; else goto c8D2;
       c8D3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8D2: // global
           I64[Hp - 48] = sat_s7qI_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s7qC::P64;
           I64[Hp - 16] = sat_s7qH_info;
           P64[Hp] = _s7qB::P64;
           R2 = Hp - 48;
           R1 = Hp - 16;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c8CZ: // global
           R2 = _s7qC::P64;
           R1 = _s7qB::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Cw_info" {
     block_c8Cw_info:
         const _c8Cw;
         const 3;
         const 12884901918;
         const S7IQ_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.934155776 UTC

[section ""data" . GHC.Integer.Type.divInteger_closure" {
     GHC.Integer.Type.divInteger_closure:
         const GHC.Integer.Type.divInteger_info;
         const 0;
 },
 GHC.Integer.Type.divInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8DO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8DP; else goto c8DQ;
       c8DP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.divInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8DQ: // global
           I64[Sp - 8] = block_c8DM_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.divInteger_info" {
     GHC.Integer.Type.divInteger_info:
         const GHC.Integer.Type.divInteger_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S7IQ_srt+80;
 },
 _c8DM() //  [R1]
         { []
         }
     {offset
       c8DM: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8DM_info" {
     block_c8DM_info:
         const _c8DM;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.944471937 UTC

[section ""data" . GHC.Integer.Type.modInteger_closure" {
     GHC.Integer.Type.modInteger_closure:
         const GHC.Integer.Type.modInteger_info;
         const 0;
 },
 GHC.Integer.Type.modInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8E9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Ea; else goto c8Eb;
       c8Ea: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.modInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Eb: // global
           I64[Sp - 8] = block_c8E7_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.modInteger_info" {
     GHC.Integer.Type.modInteger_info:
         const GHC.Integer.Type.modInteger_entry;
         const 0;
         const 21474836494;
         const 8589934607;
         const S7IQ_srt+80;
 },
 _c8E7() //  [R2]
         { []
         }
     {offset
       c8E7: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8E7_info" {
     block_c8E7_info:
         const _c8E7;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.954372071 UTC

[section ""data" . GHC.Integer.Type.quotInteger_closure" {
     GHC.Integer.Type.quotInteger_closure:
         const GHC.Integer.Type.quotInteger_info;
 },
 GHC.Integer.Type.quotInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Eu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Ev; else goto c8Ew;
       c8Ev: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.quotInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ew: // global
           I64[Sp - 8] = block_c8Es_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.quotInteger_info" {
     GHC.Integer.Type.quotInteger_info:
         const GHC.Integer.Type.quotInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8Es() //  [R1]
         { []
         }
     {offset
       c8Es: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Es_info" {
     block_c8Es_info:
         const _c8Es;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.965070514 UTC

[section ""data" . GHC.Integer.Type.remInteger_closure" {
     GHC.Integer.Type.remInteger_closure:
         const GHC.Integer.Type.remInteger_info;
 },
 GHC.Integer.Type.remInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8EP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8EQ; else goto c8ER;
       c8EQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.remInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ER: // global
           I64[Sp - 8] = block_c8EN_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.remInteger_info" {
     GHC.Integer.Type.remInteger_info:
         const GHC.Integer.Type.remInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8EN() //  [R2]
         { []
         }
     {offset
       c8EN: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8EN_info" {
     block_c8EN_info:
         const _c8EN;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.976166444 UTC

[section ""data" . GHC.Integer.Type.andDigits_closure" {
     GHC.Integer.Type.andDigits_closure:
         const GHC.Integer.Type.andDigits_info;
 },
 GHC.Integer.Type.andDigits_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Ff: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Fg; else goto c8Fh;
       c8Fg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Fh: // global
           I64[Sp - 16] = block_c8F8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8FU; else goto c8F9;
       u8FU: // global
           call _c8F8(R1) args: 0, res: 0, upd: 0;
       c8F9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.andDigits_info" {
     GHC.Integer.Type.andDigits_info:
         const GHC.Integer.Type.andDigits_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8F8() //  [R1]
         { []
         }
     {offset
       c8F8: // global
           _s7r4::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8Fc; else goto c8Fd;
       c8Fc: // global
           I64[Sp - 8] = block_c8Fk_info;
           _s7r7::P64 = P64[R1 + 7];
           _s7r6::I64 = I64[R1 + 15];
           R1 = _s7r4::P64;
           P64[Sp] = _s7r7::P64;
           I64[Sp + 8] = _s7r6::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8FS; else goto c8Fm;
       u8FS: // global
           call _c8Fk(R1) args: 0, res: 0, upd: 0;
       c8Fm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Fd: // global
           I64[Sp + 8] = block_c8FK_info;
           R1 = _s7r4::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8FT; else goto c8FM;
       u8FT: // global
           call _c8FK() args: 0, res: 0, upd: 0;
       c8FM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8F8_info" {
     block_c8F8_info:
         const _c8F8;
         const 1;
         const 30;
 },
 _c8Fk() //  [R1]
         { []
         }
     {offset
       c8Fk: // global
           if (R1 & 7 == 1) goto c8FA; else goto c8FH;
       c8FA: // global
           I64[Sp] = block_c8Fq_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c8FH: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Fk_info" {
     block_c8Fk_info:
         const _c8Fk;
         const 130;
         const 30;
 },
 _c8Fq() //  [R1]
         { []
         }
     {offset
       c8Fq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8FD; else goto c8FC;
       c8FD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8FC: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] & I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Fq_info" {
     block_c8Fq_info:
         const _c8Fq;
         const 194;
         const 30;
 },
 _c8FK() //  []
         { []
         }
     {offset
       c8FK: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8FK_info" {
     block_c8FK_info:
         const _c8FK;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:55.990232808 UTC

[section ""data" . GHC.Integer.Type.andDigitsOnes_closure" {
     GHC.Integer.Type.andDigitsOnes_closure:
         const GHC.Integer.Type.andDigitsOnes_info;
 },
 GHC.Integer.Type.andDigitsOnes_entry() //  [R2, R3]
         { []
         }
     {offset
       c8GF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8GG; else goto c8GH;
       c8GG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andDigitsOnes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8GH: // global
           I64[Sp - 16] = block_c8Gy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Hd; else goto c8Gz;
       u8Hd: // global
           call _c8Gy(R1) args: 0, res: 0, upd: 0;
       c8Gz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.andDigitsOnes_info" {
     GHC.Integer.Type.andDigitsOnes_info:
         const GHC.Integer.Type.andDigitsOnes_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8Gy() //  [R1]
         { []
         }
     {offset
       c8Gy: // global
           _s7rf::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8GC; else goto c8GD;
       c8GC: // global
           I64[Sp - 8] = block_c8GK_info;
           _s7ri::P64 = P64[R1 + 7];
           _s7rh::I64 = I64[R1 + 15];
           R1 = _s7rf::P64;
           P64[Sp] = _s7ri::P64;
           I64[Sp + 8] = _s7rh::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Hc; else goto c8GM;
       u8Hc: // global
           call _c8GK(R1) args: 0, res: 0, upd: 0;
       c8GM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8GD: // global
           R1 = _s7rf::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Gy_info" {
     block_c8Gy_info:
         const _c8Gy;
         const 1;
         const 30;
 },
 _c8GK() //  [R1]
         { []
         }
     {offset
       c8GK: // global
           if (R1 & 7 == 1) goto c8H0; else goto c8H7;
       c8H0: // global
           I64[Sp] = block_c8GQ_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 15];
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c8H7: // global
           R1 = GHC.Integer.Type.None_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8GK_info" {
     block_c8GK_info:
         const _c8GK;
         const 130;
         const 30;
 },
 _c8GQ() //  [R1]
         { []
         }
     {offset
       c8GQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8H3; else goto c8H2;
       c8H3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8H2: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16] & I64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8GQ_info" {
     block_c8GQ_info:
         const _c8GQ;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.002560767 UTC

[section ""data" . GHC.Integer.Type.orDigits_closure" {
     GHC.Integer.Type.orDigits_closure:
         const GHC.Integer.Type.orDigits_info;
 },
 GHC.Integer.Type.orDigits_entry() //  [R2, R3]
         { []
         }
     {offset
       c8HU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8HV; else goto c8HW;
       c8HV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.orDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HW: // global
           I64[Sp - 16] = block_c8HN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Is; else goto c8HO;
       u8Is: // global
           call _c8HN(R1) args: 0, res: 0, upd: 0;
       c8HO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.orDigits_info" {
     GHC.Integer.Type.orDigits_info:
         const GHC.Integer.Type.orDigits_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8HN() //  [R1]
         { []
         }
     {offset
       c8HN: // global
           _s7rp::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8HR; else goto c8HS;
       c8HR: // global
           I64[Sp - 16] = block_c8HZ_info;
           _s7rq::P64 = R1;
           _s7rs::P64 = P64[R1 + 7];
           _s7rr::I64 = I64[R1 + 15];
           R1 = _s7rp::P64;
           P64[Sp - 8] = _s7rs::P64;
           I64[Sp] = _s7rr::I64;
           P64[Sp + 8] = _s7rq::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Ir; else goto c8I1;
       u8Ir: // global
           call _c8HZ(R1) args: 0, res: 0, upd: 0;
       c8I1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8HS: // global
           R1 = _s7rp::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HN_info" {
     block_c8HN_info:
         const _c8HN;
         const 1;
         const 30;
 },
 _c8HZ() //  [R1]
         { []
         }
     {offset
       c8HZ: // global
           if (R1 & 7 == 1) goto c8If; else goto c8Im;
       c8If: // global
           _s7rs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8I5_info;
           R3 = P64[R1 + 7];
           R2 = _s7rs::P64;
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
       c8Im: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8HZ_info" {
     block_c8HZ_info:
         const _c8HZ;
         const 131;
         const 30;
 },
 _c8I5() //  [R1]
         { []
         }
     {offset
       c8I5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Ii; else goto c8Ih;
       c8Ii: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ih: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] | I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8I5_info" {
     block_c8I5_info:
         const _c8I5;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.020145151 UTC

[section ""data" . GHC.Integer.Type.orInteger_closure" {
     GHC.Integer.Type.orInteger_closure:
         const GHC.Integer.Type.orInteger_info;
 },
 GHC.Integer.Type.orInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Ja: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Jb; else goto u8Lv;
       c8Jb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.orInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u8Lv: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c8J0() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.orInteger_info" {
     GHC.Integer.Type.orInteger_info:
         const GHC.Integer.Type.orInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8J0() //  []
         { []
         }
     {offset
       c8J0: // global
           _s7ry::P64 = P64[Sp];
           I64[Sp] = block_c8J3_info;
           R1 = _s7ry::P64;
           if (R1 & 7 != 0) goto u8LB; else goto c8J4;
       u8LB: // global
           call _c8J3(R1) args: 0, res: 0, upd: 0;
       c8J4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8J3() //  [R1]
         { []
         }
     {offset
       c8J3: // global
           _s7rz::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c8J8; else goto c8J7;
       c8J8: // global
           R1 = _s7rz::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8J7: // global
           I64[Sp] = block_c8Jf_info;
           _s7rA::P64 = R1;
           R1 = _s7rz::P64;
           P64[Sp + 8] = _s7rA::P64;
           if (R1 & 7 != 0) goto u8LC; else goto c8Jh;
       u8LC: // global
           call _c8Jf(R1) args: 0, res: 0, upd: 0;
       c8Jh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8J3_info" {
     block_c8J3_info:
         const _c8J3;
         const 1;
         const 30;
 },
 _c8Jf() //  [R1]
         { []
         }
     {offset
       c8Jf: // global
           _s7rA::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c8Ll; else goto c8Jo;
       c8Ll: // global
           R1 = _s7rA::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8Jo: // global
           I64[Sp] = block_c8Jl_info;
           _s7rB::P64 = R1;
           R1 = _s7rA::P64;
           P64[Sp + 8] = _s7rB::P64;
           if (R1 & 7 != 0) goto u8LE; else goto c8Jp;
       u8LE: // global
           call _c8Jl(R1) args: 0, res: 0, upd: 0;
       c8Jp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Jf_info" {
     block_c8Jf_info:
         const _c8Jf;
         const 1;
         const 30;
 },
 _c8Jl() //  [R1]
         { []
         }
     {offset
       c8Jl: // global
           _s7rB::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c8Jw; else goto c8Kv;
       c8Jw: // global
           I64[Sp] = block_c8Jt_info;
           _s7rD::P64 = P64[R1 + 7];
           R1 = _s7rB::P64;
           P64[Sp + 8] = _s7rD::P64;
           if (R1 & 7 != 0) goto u8LF; else goto c8Jx;
       u8LF: // global
           call _c8Jt(R1) args: 0, res: 0, upd: 0;
       c8Jx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Kv: // global
           I64[Sp - 8] = block_c8Kt_info;
           _s7rC::P64 = R1;
           _s7rS::P64 = P64[R1 + 6];
           R1 = _s7rB::P64;
           P64[Sp] = _s7rS::P64;
           P64[Sp + 8] = _s7rC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8LG; else goto c8Kw;
       u8LG: // global
           call _c8Kt(R1) args: 0, res: 0, upd: 0;
       c8Kw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Jl_info" {
     block_c8Jl_info:
         const _c8Jl;
         const 1;
         const 30;
 },
 _c8Jt() //  [R1]
         { []
         }
     {offset
       c8Jt: // global
           if (R1 & 7 < 2) goto c8JI; else goto c8JY;
       c8JI: // global
           _s7rD::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8JB_info;
           R3 = P64[R1 + 7];
           R2 = _s7rD::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
       c8JY: // global
           I64[Sp] = block_c8JO_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Jt_info" {
     block_c8Jt_info:
         const _c8Jt;
         const 1;
         const 30;
 },
 _c8JB() //  [R1]
         { []
         }
     {offset
       c8JB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8JL; else goto c8JK;
       c8JL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8JK: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JB_info" {
     block_c8JB_info:
         const _c8JB;
         const 0;
         const 30;
 },
 _c8JO() //  [R1]
         { []
         }
     {offset
       c8JO: // global
           I64[Sp] = block_c8JS_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JO_info" {
     block_c8JO_info:
         const _c8JO;
         const 1;
         const 30;
 },
 _c8JS() //  [R1]
         { []
         }
     {offset
       c8JS: // global
           _s7rJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8JW_info;
           R3 = _s7rJ::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JS_info" {
     block_c8JS_info:
         const _c8JS;
         const 1;
         const 30;
 },
 _c8JW() //  [R1]
         { []
         }
     {offset
       c8JW: // global
           I64[Sp] = block_c8K4_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8JW_info" {
     block_c8JW_info:
         const _c8JW;
         const 0;
         const 30;
 },
 _c8K4() //  [R1, R2]
         { []
         }
     {offset
       c8K4: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c8K5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8K4_info" {
     block_c8K4_info:
         const _c8K4;
         const 0;
         const 30;
 },
 _c8K5() //  []
         { []
         }
     {offset
       c8K5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Kd; else goto c8Kc;
       c8Kd: // global
           HpAlloc = 24;
           I64[Sp] = block_c8K5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Kc: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c8K9_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8K5_info" {
     block_c8K5_info:
         const _c8K5;
         const 130;
         const 30;
 },
 _c8K9() //  [R1]
         { []
         }
     {offset
       c8K9: // global
           if (R1 & 7 == 1) goto c8Kj; else goto u8Lx;
       c8Kj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Km; else goto c8Kl;
       c8Km: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Kl: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8Lx: // global
           Sp = Sp + 8;
           call _c8Lh() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8K9_info" {
     block_c8K9_info:
         const _c8K9;
         const 0;
         const 30;
 },
 _c8Kt() //  [R1]
         { []
         }
     {offset
       c8Kt: // global
           if (R1 & 7 < 2) goto c8KC; else goto c8KP;
       c8KC: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c8J0() args: 0, res: 0, upd: 0;
       c8KP: // global
           I64[Sp] = block_c8KF_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Kt_info" {
     block_c8Kt_info:
         const _c8Kt;
         const 2;
         const 30;
 },
 _c8KF() //  [R1]
         { []
         }
     {offset
       c8KF: // global
           _s7rS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8KJ_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s7rS::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8KF_info" {
     block_c8KF_info:
         const _c8KF;
         const 130;
         const 30;
 },
 _c8KJ() //  [R1]
         { []
         }
     {offset
       c8KJ: // global
           _s7rX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8KN_info;
           R3 = _s7rX::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8KJ_info" {
     block_c8KJ_info:
         const _c8KJ;
         const 1;
         const 30;
 },
 _c8KN() //  [R1]
         { []
         }
     {offset
       c8KN: // global
           I64[Sp] = block_c8KV_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8KN_info" {
     block_c8KN_info:
         const _c8KN;
         const 0;
         const 30;
 },
 _c8KV() //  [R1, R2]
         { []
         }
     {offset
       c8KV: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c8KW() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8KV_info" {
     block_c8KV_info:
         const _c8KV;
         const 0;
         const 30;
 },
 _c8KW() //  []
         { []
         }
     {offset
       c8KW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8L4; else goto c8L3;
       c8L4: // global
           HpAlloc = 24;
           I64[Sp] = block_c8KW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8L3: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c8L0_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8KW_info" {
     block_c8KW_info:
         const _c8KW;
         const 130;
         const 30;
 },
 _c8L0() //  [R1]
         { []
         }
     {offset
       c8L0: // global
           if (R1 & 7 == 1) goto c8La; else goto u8LA;
       c8La: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Ld; else goto c8Lc;
       c8Ld: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Lc: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8LA: // global
           Sp = Sp + 8;
           call _c8Lh() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8L0_info" {
     block_c8L0_info:
         const _c8L0;
         const 0;
         const 30;
 },
 _c8Lh() //  []
         { []
         }
     {offset
       c8Lh: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.067597098 UTC

[section ""data" . GHC.Integer.Type.mkInteger_f_closure" {
     GHC.Integer.Type.mkInteger_f_closure:
         const GHC.Integer.Type.mkInteger_f_info;
 },
 GHC.Integer.Type.mkInteger_f_entry() //  [R2]
         { []
         }
     {offset
       c8NR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NS; else goto c8NT;
       c8NS: // global
           R2 = R2;
           R1 = GHC.Integer.Type.mkInteger_f_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NT: // global
           I64[Sp - 8] = block_c8NK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Om; else goto c8NL;
       u8Om: // global
           call _c8NK(R1) args: 0, res: 0, upd: 0;
       c8NL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.mkInteger_f_info" {
     GHC.Integer.Type.mkInteger_f_info:
         const GHC.Integer.Type.mkInteger_f_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c8NK() //  [R1]
         { []
         }
     {offset
       c8NK: // global
           if (R1 & 7 == 1) goto c8NO; else goto c8NP;
       c8NO: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8NP: // global
           I64[Sp - 8] = block_c8NZ_info;
           _s7s9::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s7s9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Ol; else goto c8O0;
       u8Ol: // global
           call _c8NZ(R1) args: 0, res: 0, upd: 0;
       c8O0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8NK_info" {
     block_c8NK_info:
         const _c8NK;
         const 0;
         const 30;
 },
 _c8NZ() //  [R1]
         { []
         }
     {offset
       c8NZ: // global
           I64[Sp] = block_c8O4_info;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8NZ_info" {
     block_c8NZ_info:
         const _c8NZ;
         const 1;
         const 30;
 },
 _c8O4() //  [R1]
         { []
         }
     {offset
       c8O4: // global
           I64[Sp] = block_c8O8_info;
           R3 = 31;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8O4_info" {
     block_c8O4_info:
         const _c8O4;
         const 65;
         const 30;
 },
 _c8O8() //  [R1]
         { []
         }
     {offset
       c8O8: // global
           I64[Sp] = block_c8Oc_info;
           R2 = I64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8O8_info" {
     block_c8O8_info:
         const _c8O8;
         const 65;
         const 30;
 },
 _c8Oc() //  [R1]
         { []
         }
     {offset
       c8Oc: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Oc_info" {
     block_c8Oc_info:
         const _c8Oc;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.082735436 UTC

[section ""data" . GHC.Integer.Type.mkInteger_closure" {
     GHC.Integer.Type.mkInteger_closure:
         const GHC.Integer.Type.mkInteger_info;
 },
 GHC.Integer.Type.mkInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8P3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8P4; else goto c8P5;
       c8P4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.mkInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8P5: // global
           I64[Sp - 16] = block_c8OW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Ph; else goto c8OX;
       u8Ph: // global
           call _c8OW(R1) args: 0, res: 0, upd: 0;
       c8OX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.mkInteger_info" {
     GHC.Integer.Type.mkInteger_info:
         const GHC.Integer.Type.mkInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8OW() //  [R1]
         { []
         }
     {offset
       c8OW: // global
           _s7sg::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8P0; else goto c8P1;
       c8P0: // global
           I64[Sp + 8] = block_c8P8_info;
           R2 = _s7sg::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 8, upd: 8;
       c8P1: // global
           R2 = _s7sg::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.mkInteger_f_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8OW_info" {
     block_c8OW_info:
         const _c8OW;
         const 1;
         const 30;
 },
 _c8P8() //  [R1]
         { []
         }
     {offset
       c8P8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8P8_info" {
     block_c8P8_info:
         const _c8P8;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.097484272 UTC

[section ""data" . GHC.Integer.Type.andInteger_closure" {
     GHC.Integer.Type.andInteger_closure:
         const GHC.Integer.Type.andInteger_info;
 },
 GHC.Integer.Type.andInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8PJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8PK; else goto u8Se;
       c8PK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.andInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u8Se: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c8Pz() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.andInteger_info" {
     GHC.Integer.Type.andInteger_info:
         const GHC.Integer.Type.andInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8Pz() //  []
         { []
         }
     {offset
       c8Pz: // global
           _s7sj::P64 = P64[Sp];
           I64[Sp] = block_c8PC_info;
           R1 = _s7sj::P64;
           if (R1 & 7 != 0) goto u8Sl; else goto c8PD;
       u8Sl: // global
           call _c8PC(R1) args: 0, res: 0, upd: 0;
       c8PD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8PC() //  [R1]
         { []
         }
     {offset
       c8PC: // global
           _s7sk::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c8PH; else goto c8PG;
       c8PH: // global
           I64[Sp + 8] = block_c8S0_info;
           R1 = _s7sk::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8Sn; else goto c8S2;
       u8Sn: // global
           call _c8S0() args: 0, res: 0, upd: 0;
       c8S2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8PG: // global
           I64[Sp] = block_c8PO_info;
           _s7sl::P64 = R1;
           R1 = _s7sk::P64;
           P64[Sp + 8] = _s7sl::P64;
           if (R1 & 7 != 0) goto u8Sm; else goto c8PQ;
       u8Sm: // global
           call _c8PO(R1) args: 0, res: 0, upd: 0;
       c8PQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8PC_info" {
     block_c8PC_info:
         const _c8PC;
         const 1;
         const 30;
 },
 _c8S0() //  []
         { []
         }
     {offset
       c8S0: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8S0_info" {
     block_c8S0_info:
         const _c8S0;
         const 0;
         const 30;
 },
 _c8PO() //  [R1]
         { []
         }
     {offset
       c8PO: // global
           if (R1 & 7 == 3) goto u8Sf; else goto c8PX;
       u8Sf: // global
           Sp = Sp + 16;
           call _c8RX() args: 0, res: 0, upd: 0;
       c8PX: // global
           I64[Sp] = block_c8PU_info;
           _s7sm::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7sm::P64;
           if (R1 & 7 != 0) goto u8Sp; else goto c8PY;
       u8Sp: // global
           call _c8PU(R1) args: 0, res: 0, upd: 0;
       c8PY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8PO_info" {
     block_c8PO_info:
         const _c8PO;
         const 1;
         const 30;
 },
 _c8PU() //  [R1]
         { []
         }
     {offset
       c8PU: // global
           _s7sm::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c8Q5; else goto c8R7;
       c8Q5: // global
           I64[Sp] = block_c8Q2_info;
           _s7so::P64 = P64[R1 + 7];
           R1 = _s7sm::P64;
           P64[Sp + 8] = _s7so::P64;
           if (R1 & 7 != 0) goto u8Sr; else goto c8Q6;
       u8Sr: // global
           call _c8Q2(R1) args: 0, res: 0, upd: 0;
       c8Q6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8R7: // global
           I64[Sp - 8] = block_c8R5_info;
           _s7sn::P64 = R1;
           _s7sC::P64 = P64[R1 + 6];
           R1 = _s7sm::P64;
           P64[Sp] = _s7sC::P64;
           P64[Sp + 8] = _s7sn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Ss; else goto c8R8;
       u8Ss: // global
           call _c8R5(R1) args: 0, res: 0, upd: 0;
       c8R8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8PU_info" {
     block_c8PU_info:
         const _c8PU;
         const 1;
         const 30;
 },
 _c8Q2() //  [R1]
         { []
         }
     {offset
       c8Q2: // global
           if (R1 & 7 < 2) goto c8Qd; else goto c8QI;
       c8Qd: // global
           _s7so::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Qa_info;
           R3 = P64[R1 + 7];
           R2 = _s7so::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c8QI: // global
           I64[Sp] = block_c8Qy_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Q2_info" {
     block_c8Q2_info:
         const _c8Q2;
         const 1;
         const 30;
 },
 _c8Qa() //  [R1]
         { []
         }
     {offset
       c8Qa: // global
           I64[Sp] = block_c8Qh_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Qa_info" {
     block_c8Qa_info:
         const _c8Qa;
         const 0;
         const 30;
 },
 _c8Qh() //  [R1]
         { []
         }
     {offset
       c8Qh: // global
           if (R1 & 7 == 1) goto c8Qo; else goto u8Sg;
       c8Qo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Qr; else goto c8Qq;
       c8Qr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Qq: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8Sg: // global
           Sp = Sp + 8;
           call _c8RX() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8Qh_info" {
     block_c8Qh_info:
         const _c8Qh;
         const 0;
         const 30;
 },
 _c8Qy() //  [R1]
         { []
         }
     {offset
       c8Qy: // global
           I64[Sp] = block_c8QC_info;
           R2 = R1;
           call GHC.Integer.Type.flipBitsDigits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Qy_info" {
     block_c8Qy_info:
         const _c8Qy;
         const 1;
         const 30;
 },
 _c8QC() //  [R1]
         { []
         }
     {offset
       c8QC: // global
           _s7so::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8QG_info;
           R3 = _s7so::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.andDigitsOnes_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8QC_info" {
     block_c8QC_info:
         const _c8QC;
         const 1;
         const 30;
 },
 _c8QG() //  [R1]
         { []
         }
     {offset
       c8QG: // global
           I64[Sp] = block_c8QO_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8QG_info" {
     block_c8QG_info:
         const _c8QG;
         const 0;
         const 30;
 },
 _c8QO() //  [R1]
         { []
         }
     {offset
       c8QO: // global
           if (R1 & 7 == 1) goto c8QV; else goto u8Sh;
       c8QV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QY; else goto c8QX;
       c8QY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QX: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8Sh: // global
           Sp = Sp + 8;
           call _c8RX() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8QO_info" {
     block_c8QO_info:
         const _c8QO;
         const 0;
         const 30;
 },
 _c8R5() //  [R1]
         { []
         }
     {offset
       c8R5: // global
           if (R1 & 7 < 2) goto c8Re; else goto c8Rr;
       c8Re: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c8Pz() args: 0, res: 0, upd: 0;
       c8Rr: // global
           I64[Sp] = block_c8Rh_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8R5_info" {
     block_c8R5_info:
         const _c8R5;
         const 2;
         const 30;
 },
 _c8Rh() //  [R1]
         { []
         }
     {offset
       c8Rh: // global
           _s7sC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Rl_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s7sC::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Rh_info" {
     block_c8Rh_info:
         const _c8Rh;
         const 130;
         const 30;
 },
 _c8Rl() //  [R1]
         { []
         }
     {offset
       c8Rl: // global
           _s7sH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Rp_info;
           R3 = _s7sH::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.orDigits_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Rl_info" {
     block_c8Rl_info:
         const _c8Rl;
         const 1;
         const 30;
 },
 _c8Rp() //  [R1]
         { []
         }
     {offset
       c8Rp: // global
           I64[Sp] = block_c8Rx_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Rp_info" {
     block_c8Rp_info:
         const _c8Rp;
         const 0;
         const 30;
 },
 _c8Rx() //  [R1, R2]
         { []
         }
     {offset
       c8Rx: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c8Ry() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8Rx_info" {
     block_c8Rx_info:
         const _c8Rx;
         const 0;
         const 30;
 },
 _c8Ry() //  []
         { []
         }
     {offset
       c8Ry: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8RG; else goto c8RF;
       c8RG: // global
           HpAlloc = 24;
           I64[Sp] = block_c8Ry_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8RF: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c8RC_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Ry_info" {
     block_c8Ry_info:
         const _c8Ry;
         const 130;
         const 30;
 },
 _c8RC() //  [R1]
         { []
         }
     {offset
       c8RC: // global
           if (R1 & 7 == 1) goto c8RM; else goto u8Sk;
       c8RM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RP; else goto c8RO;
       c8RP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8RO: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8Sk: // global
           Sp = Sp + 8;
           call _c8RX() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8RC_info" {
     block_c8RC_info:
         const _c8RC;
         const 0;
         const 30;
 },
 _c8RX() //  []
         { []
         }
     {offset
       c8RX: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.139789333 UTC

[section ""data" . GHC.Integer.Type.testBitInteger_closure" {
     GHC.Integer.Type.testBitInteger_closure:
         const GHC.Integer.Type.testBitInteger_info;
 },
 GHC.Integer.Type.testBitInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Uv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8UD; else goto c8UE;
       c8UD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.testBitInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8UE: // global
           I64[Sp - 16] = block_c8Ut_info;
           R3 = R3;
           _s7sR::P64 = R2;
           R2 = GHC.Integer.Type.oneInteger_closure+1;
           P64[Sp - 8] = _s7sR::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.testBitInteger_info" {
     GHC.Integer.Type.testBitInteger_info:
         const GHC.Integer.Type.testBitInteger_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c8Ut() //  [R1]
         { []
         }
     {offset
       c8Ut: // global
           _s7sR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Uy_info;
           R3 = R1;
           R2 = _s7sR::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Ut_info" {
     block_c8Ut_info:
         const _c8Ut;
         const 1;
         const 30;
 },
 _c8Uy() //  [R1]
         { []
         }
     {offset
       c8Uy: // global
           I64[Sp] = block_c8UC_info;
           R3 = GHC.Integer.Type.Naught_closure+3;
           R2 = R1;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Uy_info" {
     block_c8Uy_info:
         const _c8Uy;
         const 0;
         const 30;
 },
 _c8UC() //  [R1]
         { []
         }
     {offset
       c8UC: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8UC_info" {
     block_c8UC_info:
         const _c8UC;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.152742127 UTC

[section ""data" . GHC.Integer.Type.xorDigits_closure" {
     GHC.Integer.Type.xorDigits_closure:
         const GHC.Integer.Type.xorDigits_info;
 },
 GHC.Integer.Type.xorDigits_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Vg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Vh; else goto c8Vi;
       c8Vh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.xorDigits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Vi: // global
           I64[Sp - 16] = block_c8V9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8VO; else goto c8Va;
       u8VO: // global
           call _c8V9(R1) args: 0, res: 0, upd: 0;
       c8Va: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.xorDigits_info" {
     GHC.Integer.Type.xorDigits_info:
         const GHC.Integer.Type.xorDigits_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8V9() //  [R1]
         { []
         }
     {offset
       c8V9: // global
           _s7sX::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8Vd; else goto c8Ve;
       c8Vd: // global
           I64[Sp - 16] = block_c8Vl_info;
           _s7sY::P64 = R1;
           _s7t0::P64 = P64[R1 + 7];
           _s7sZ::I64 = I64[R1 + 15];
           R1 = _s7sX::P64;
           P64[Sp - 8] = _s7t0::P64;
           I64[Sp] = _s7sZ::I64;
           P64[Sp + 8] = _s7sY::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8VN; else goto c8Vn;
       u8VN: // global
           call _c8Vl(R1) args: 0, res: 0, upd: 0;
       c8Vn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Ve: // global
           R1 = _s7sX::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8V9_info" {
     block_c8V9_info:
         const _c8V9;
         const 1;
         const 30;
 },
 _c8Vl() //  [R1]
         { []
         }
     {offset
       c8Vl: // global
           if (R1 & 7 == 1) goto c8VB; else goto c8VI;
       c8VB: // global
           _s7t0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Vr_info;
           R3 = P64[R1 + 7];
           R2 = _s7t0::P64;
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c8VI: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Vl_info" {
     block_c8Vl_info:
         const _c8Vl;
         const 131;
         const 30;
 },
 _c8Vr() //  [R1]
         { []
         }
     {offset
       c8Vr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8VE; else goto c8VD;
       c8VE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VD: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8] ^ I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Vr_info" {
     block_c8Vr_info:
         const _c8Vr;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.170115907 UTC

[section ""data" . GHC.Integer.Type.xorInteger_closure" {
     GHC.Integer.Type.xorInteger_closure:
         const GHC.Integer.Type.xorInteger_info;
 },
 GHC.Integer.Type.xorInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Ww: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Wx; else goto u8YQ;
       c8Wx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.xorInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u8YQ: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c8Wm() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.xorInteger_info" {
     GHC.Integer.Type.xorInteger_info:
         const GHC.Integer.Type.xorInteger_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c8Wm() //  []
         { []
         }
     {offset
       c8Wm: // global
           _s7t6::P64 = P64[Sp];
           I64[Sp] = block_c8Wp_info;
           R1 = _s7t6::P64;
           if (R1 & 7 != 0) goto u8YW; else goto c8Wq;
       u8YW: // global
           call _c8Wp(R1) args: 0, res: 0, upd: 0;
       c8Wq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wp() //  [R1]
         { []
         }
     {offset
       c8Wp: // global
           _s7t7::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c8Wu; else goto c8Wt;
       c8Wu: // global
           R1 = _s7t7::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8Wt: // global
           I64[Sp] = block_c8WB_info;
           _s7t8::P64 = R1;
           R1 = _s7t7::P64;
           P64[Sp + 8] = _s7t8::P64;
           if (R1 & 7 != 0) goto u8YX; else goto c8WD;
       u8YX: // global
           call _c8WB(R1) args: 0, res: 0, upd: 0;
       c8WD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Wp_info" {
     block_c8Wp_info:
         const _c8Wp;
         const 1;
         const 30;
 },
 _c8WB() //  [R1]
         { []
         }
     {offset
       c8WB: // global
           _s7t8::P64 = P64[Sp + 8];
           if (R1 & 7 == 3) goto c8YF; else goto c8WK;
       c8YF: // global
           R1 = _s7t8::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8WK: // global
           I64[Sp] = block_c8WH_info;
           _s7t9::P64 = R1;
           R1 = _s7t8::P64;
           P64[Sp + 8] = _s7t9::P64;
           if (R1 & 7 != 0) goto u8YZ; else goto c8WL;
       u8YZ: // global
           call _c8WH(R1) args: 0, res: 0, upd: 0;
       c8WL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8WB_info" {
     block_c8WB_info:
         const _c8WB;
         const 1;
         const 30;
 },
 _c8WH() //  [R1]
         { []
         }
     {offset
       c8WH: // global
           _s7t9::P64 = P64[Sp + 8];
           if (R1 & 7 < 2) goto c8WS; else goto c8XX;
       c8WS: // global
           I64[Sp] = block_c8WP_info;
           _s7tb::P64 = P64[R1 + 7];
           R1 = _s7t9::P64;
           P64[Sp + 8] = _s7tb::P64;
           if (R1 & 7 != 0) goto u8Z0; else goto c8WT;
       u8Z0: // global
           call _c8WP(R1) args: 0, res: 0, upd: 0;
       c8WT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8XX: // global
           I64[Sp - 8] = block_c8XV_info;
           _s7ta::P64 = R1;
           _s7ts::P64 = P64[R1 + 6];
           R1 = _s7t9::P64;
           P64[Sp] = _s7ts::P64;
           P64[Sp + 8] = _s7ta::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Z1; else goto c8XY;
       u8Z1: // global
           call _c8XV(R1) args: 0, res: 0, upd: 0;
       c8XY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8WH_info" {
     block_c8WH_info:
         const _c8WH;
         const 1;
         const 30;
 },
 _c8WP() //  [R1]
         { []
         }
     {offset
       c8WP: // global
           if (R1 & 7 < 2) goto c8X0; else goto c8Xr;
       c8X0: // global
           _s7tb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8WX_info;
           R3 = P64[R1 + 7];
           R2 = _s7tb::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       c8Xr: // global
           I64[Sp] = block_c8Xl_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8WP_info" {
     block_c8WP_info:
         const _c8WP;
         const 1;
         const 30;
 },
 _c8WX() //  [R1]
         { []
         }
     {offset
       c8WX: // global
           I64[Sp] = block_c8X4_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8WX_info" {
     block_c8WX_info:
         const _c8WX;
         const 0;
         const 30;
 },
 _c8X4() //  [R1]
         { []
         }
     {offset
       c8X4: // global
           if (R1 & 7 == 1) goto c8Xb; else goto u8YR;
       c8Xb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Xe; else goto c8Xd;
       c8Xe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Xd: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8YR: // global
           Sp = Sp + 8;
           call _c8YB() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8X4_info" {
     block_c8X4_info:
         const _c8X4;
         const 0;
         const 30;
 },
 _c8Xl() //  [R1]
         { []
         }
     {offset
       c8Xl: // global
           _s7tb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Xp_info;
           R3 = R1;
           R2 = _s7tb::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Xl_info" {
     block_c8Xl_info:
         const _c8Xl;
         const 1;
         const 30;
 },
 _c8Xp() //  [R1]
         { []
         }
     {offset
       c8Xp: // global
           I64[Sp] = block_c8Xw_info;
           R2 = R1;
           call GHC.Integer.Type.$wsuccPositive_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Xp_info" {
     block_c8Xp_info:
         const _c8Xp;
         const 0;
         const 30;
 },
 _c8Xw() //  [R1, R2]
         { []
         }
     {offset
       c8Xw: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c8Xx() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8Xw_info" {
     block_c8Xw_info:
         const _c8Xw;
         const 0;
         const 30;
 },
 _c8Xx() //  []
         { []
         }
     {offset
       c8Xx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8XF; else goto c8XE;
       c8XF: // global
           HpAlloc = 24;
           I64[Sp] = block_c8Xx_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8XE: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 16] = block_c8XB_info;
           R2 = Hp - 15;
           Sp = Sp + 16;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Xx_info" {
     block_c8Xx_info:
         const _c8Xx;
         const 130;
         const 30;
 },
 _c8XB() //  [R1]
         { []
         }
     {offset
       c8XB: // global
           if (R1 & 7 == 1) goto c8XL; else goto u8YT;
       c8XL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8XO; else goto c8XN;
       c8XO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8XN: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8YT: // global
           Sp = Sp + 8;
           call _c8YB() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8XB_info" {
     block_c8XB_info:
         const _c8XB;
         const 0;
         const 30;
 },
 _c8XV() //  [R1]
         { []
         }
     {offset
       c8XV: // global
           if (R1 & 7 < 2) goto c8Y4; else goto c8Yh;
       c8Y4: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _c8Wm() args: 0, res: 0, upd: 0;
       c8Yh: // global
           I64[Sp] = block_c8Y7_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = P64[R1 + 6];
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8XV_info" {
     block_c8XV_info:
         const _c8XV;
         const 2;
         const 30;
 },
 _c8Y7() //  [R1]
         { []
         }
     {offset
       c8Y7: // global
           _s7ts::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Yb_info;
           R3 = GHC.Integer.Type.onePositive_closure+1;
           R2 = _s7ts::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.minusPositive_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Y7_info" {
     block_c8Y7_info:
         const _c8Y7;
         const 130;
         const 30;
 },
 _c8Yb() //  [R1]
         { []
         }
     {offset
       c8Yb: // global
           _s7tx::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Yf_info;
           R3 = _s7tx::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.xorDigits_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Yb_info" {
     block_c8Yb_info:
         const _c8Yb;
         const 1;
         const 30;
 },
 _c8Yf() //  [R1]
         { []
         }
     {offset
       c8Yf: // global
           I64[Sp] = block_c8Yn_info;
           R2 = R1;
           call GHC.Integer.Type.removeZeroTails_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Yf_info" {
     block_c8Yf_info:
         const _c8Yf;
         const 0;
         const 30;
 },
 _c8Yn() //  [R1]
         { []
         }
     {offset
       c8Yn: // global
           if (R1 & 7 == 1) goto c8Yu; else goto u8YV;
       c8Yu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Yx; else goto c8Yw;
       c8Yx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Yw: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8YV: // global
           Sp = Sp + 8;
           call _c8YB() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8Yn_info" {
     block_c8Yn_info:
         const _c8Yn;
         const 0;
         const 30;
 },
 _c8YB() //  []
         { []
         }
     {offset
       c8YB: // global
           R1 = GHC.Integer.Type.Naught_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.215663006 UTC

[section ""cstring" . GHC.Integer.Type.$trModule4_bytes" {
     GHC.Integer.Type.$trModule4_bytes:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.217808532 UTC

[section ""data" . GHC.Integer.Type.$trModule3_closure" {
     GHC.Integer.Type.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.219830596 UTC

[section ""cstring" . GHC.Integer.Type.$trModule2_bytes" {
     GHC.Integer.Type.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.222221087 UTC

[section ""data" . GHC.Integer.Type.$trModule1_closure" {
     GHC.Integer.Type.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.224227341 UTC

[section ""data" . GHC.Integer.Type.$trModule_closure" {
     GHC.Integer.Type.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Integer.Type.$trModule3_closure+1;
         const GHC.Integer.Type.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.226412967 UTC

[section ""data" . $krep_r3Bp_closure" {
     $krep_r3Bp_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.22844305 UTC

[section ""data" . $krep1_r3Bq_closure" {
     $krep1_r3Bq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.230443053 UTC

[section ""cstring" . GHC.Integer.Type.$tcDigits2_bytes" {
     GHC.Integer.Type.$tcDigits2_bytes:
         I8[] [68,105,103,105,116,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.232797094 UTC

[section ""data" . GHC.Integer.Type.$tcDigits1_closure" {
     GHC.Integer.Type.$tcDigits1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcDigits2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.234913838 UTC

[section ""data" . GHC.Integer.Type.$tcDigits_closure" {
     GHC.Integer.Type.$tcDigits_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcDigits1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16647862651490579480;
         const 7069031713090282797;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.237045668 UTC

[section ""data" . GHC.Integer.Type.$tc'None1_closure" {
     GHC.Integer.Type.$tc'None1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcDigits_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.239180129 UTC

[section ""cstring" . GHC.Integer.Type.$tc'None3_bytes" {
     GHC.Integer.Type.$tc'None3_bytes:
         I8[] [39,78,111,110,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.242383944 UTC

[section ""data" . GHC.Integer.Type.$tc'None2_closure" {
     GHC.Integer.Type.$tc'None2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'None3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.244473465 UTC

[section ""data" . GHC.Integer.Type.$tc'None_closure" {
     GHC.Integer.Type.$tc'None_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'None2_closure+1;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const 903679638320298226;
         const 12977397153301278560;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.246640848 UTC

[section ""data" . $krep2_r3Br_closure" {
     $krep2_r3Br_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.248580556 UTC

[section ""data" . GHC.Integer.Type.$tc'Some1_closure" {
     GHC.Integer.Type.$tc'Some1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r3Bq_closure+1;
         const $krep2_r3Br_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.250456783 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Some3_bytes" {
     GHC.Integer.Type.$tc'Some3_bytes:
         I8[] [39,83,111,109,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.252786031 UTC

[section ""data" . GHC.Integer.Type.$tc'Some2_closure" {
     GHC.Integer.Type.$tc'Some2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Some3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.255005208 UTC

[section ""data" . GHC.Integer.Type.$tc'Some_closure" {
     GHC.Integer.Type.$tc'Some_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Some2_closure+1;
         const GHC.Integer.Type.$tc'Some1_closure+4;
         const 6045911439621864566;
         const 9702873355935012388;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.257021145 UTC

[section ""cstring" . GHC.Integer.Type.$tcInteger2_bytes" {
     GHC.Integer.Type.$tcInteger2_bytes:
         I8[] [73,110,116,101,103,101,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.258963268 UTC

[section ""data" . GHC.Integer.Type.$tcInteger1_closure" {
     GHC.Integer.Type.$tcInteger1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcInteger2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.260950379 UTC

[section ""data" . GHC.Integer.Type.$tcInteger_closure" {
     GHC.Integer.Type.$tcInteger_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcInteger1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12260413788024328428;
         const 9583620696682509916;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.263471282 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught1_closure" {
     GHC.Integer.Type.$tc'Naught1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.265498416 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Naught3_bytes" {
     GHC.Integer.Type.$tc'Naught3_bytes:
         I8[] [39,78,97,117,103,104,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.267462405 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught2_closure" {
     GHC.Integer.Type.$tc'Naught2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Naught3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.270123815 UTC

[section ""data" . GHC.Integer.Type.$tc'Naught_closure" {
     GHC.Integer.Type.$tc'Naught_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Naught2_closure+1;
         const GHC.Integer.Type.$tc'Naught1_closure+1;
         const 7287704174224038176;
         const 776397532388787230;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.272600394 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative1_closure" {
     GHC.Integer.Type.$tc'Negative1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const GHC.Integer.Type.$tc'Naught1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.274588792 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Positive2_bytes" {
     GHC.Integer.Type.$tc'Positive2_bytes:
         I8[] [39,80,111,115,105,116,105,118,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.276611382 UTC

[section ""data" . GHC.Integer.Type.$tc'Positive1_closure" {
     GHC.Integer.Type.$tc'Positive1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Positive2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.278787334 UTC

[section ""data" . GHC.Integer.Type.$tc'Positive_closure" {
     GHC.Integer.Type.$tc'Positive_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Positive1_closure+1;
         const GHC.Integer.Type.$tc'Negative1_closure+4;
         const 6887932004110746796;
         const 9391890139750561935;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.281281963 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Negative3_bytes" {
     GHC.Integer.Type.$tc'Negative3_bytes:
         I8[] [39,78,101,103,97,116,105,118,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.283398407 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative2_closure" {
     GHC.Integer.Type.$tc'Negative2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Negative3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.28556266 UTC

[section ""data" . GHC.Integer.Type.$tc'Negative_closure" {
     GHC.Integer.Type.$tc'Negative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Negative2_closure+1;
         const GHC.Integer.Type.$tc'Negative1_closure+4;
         const 4010847856516363452;
         const 15624358648337932456;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.287524084 UTC

[section ""cstring" . GHC.Integer.Type.$tcList2_bytes" {
     GHC.Integer.Type.$tcList2_bytes:
         I8[] [76,105,115,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.289495743 UTC

[section ""data" . GHC.Integer.Type.$tcList1_closure" {
     GHC.Integer.Type.$tcList1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcList2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.292041802 UTC

[section ""data" . GHC.Integer.Type.$tcList_closure" {
     GHC.Integer.Type.$tcList_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 732340346576824023;
         const 9653115931589988500;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.294234167 UTC

[section ""data" . $krep3_r3Bs_closure" {
     $krep3_r3Bs_closure:
         const :_con_info;
         const $krep_r3Bp_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.296238626 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil1_closure" {
     GHC.Integer.Type.$tc'Nil1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcList_closure+1;
         const $krep3_r3Bs_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.298209649 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Nil3_bytes" {
     GHC.Integer.Type.$tc'Nil3_bytes:
         I8[] [39,78,105,108]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.30060289 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil2_closure" {
     GHC.Integer.Type.$tc'Nil2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Nil3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.302866335 UTC

[section ""data" . GHC.Integer.Type.$tc'Nil_closure" {
     GHC.Integer.Type.$tc'Nil_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Nil2_closure+1;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const 13538585131509945451;
         const 9366316088405446135;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.304948758 UTC

[section ""data" . $krep4_r3Bt_closure" {
     $krep4_r3Bt_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const GHC.Integer.Type.$tc'Nil1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.306989349 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons1_closure" {
     GHC.Integer.Type.$tc'Cons1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r3Bp_closure+2;
         const $krep4_r3Bt_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.309042389 UTC

[section ""cstring" . GHC.Integer.Type.$tc'Cons3_bytes" {
     GHC.Integer.Type.$tc'Cons3_bytes:
         I8[] [39,67,111,110,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.311525304 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons2_closure" {
     GHC.Integer.Type.$tc'Cons2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'Cons3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.313670353 UTC

[section ""data" . GHC.Integer.Type.$tc'Cons_closure" {
     GHC.Integer.Type.$tc'Cons_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'Cons2_closure+1;
         const GHC.Integer.Type.$tc'Cons1_closure+4;
         const 3906777924842222150;
         const 5463288556346842885;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.315822078 UTC

[section ""cstring" . GHC.Integer.Type.$tcDigitsOnes2_bytes" {
     GHC.Integer.Type.$tcDigitsOnes2_bytes:
         I8[] [68,105,103,105,116,115,79,110,101,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.317836552 UTC

[section ""data" . GHC.Integer.Type.$tcDigitsOnes1_closure" {
     GHC.Integer.Type.$tcDigitsOnes1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tcDigitsOnes2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.320419711 UTC

[section ""data" . GHC.Integer.Type.$tcDigitsOnes_closure" {
     GHC.Integer.Type.$tcDigitsOnes_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tcDigitsOnes1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4554239703586147919;
         const 6957361150436389790;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.322644613 UTC

[section ""data" . $krep5_r3Bu_closure" {
     $krep5_r3Bu_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcDigitsOnes_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.324570661 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes1_closure" {
     GHC.Integer.Type.$tc'DigitsOnes1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Integer.Type.$tc'None1_closure+1;
         const $krep5_r3Bu_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.326603778 UTC

[section ""cstring" . GHC.Integer.Type.$tc'DigitsOnes3_bytes" {
     GHC.Integer.Type.$tc'DigitsOnes3_bytes:
         I8[] [39,68,105,103,105,116,115,79,110,101,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.328586641 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes2_closure" {
     GHC.Integer.Type.$tc'DigitsOnes2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Integer.Type.$tc'DigitsOnes3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.33117046 UTC

[section ""data" . GHC.Integer.Type.$tc'DigitsOnes_closure" {
     GHC.Integer.Type.$tc'DigitsOnes_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Integer.Type.$trModule_closure+1;
         const GHC.Integer.Type.$tc'DigitsOnes2_closure+1;
         const GHC.Integer.Type.$tc'DigitsOnes1_closure+4;
         const 15211110739657495015;
         const 1682512192113792266;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.333812211 UTC

[section ""data" . GHC.Integer.Type.encodeDouble#_closure" {
     GHC.Integer.Type.encodeDouble#_closure:
         const GHC.Integer.Type.encodeDouble#_info;
 },
 GHC.Integer.Type.encodeDouble#_entry() //  [R2, R3]
         { []
         }
     {offset
       c91R: // global
           _c91Q::I64 = R3;
           (_s7tH::F64) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeDouble(R2, _c91Q::I64);
           D1 = _s7tH::F64;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.encodeDouble#_info" {
     GHC.Integer.Type.encodeDouble#_info:
         const GHC.Integer.Type.encodeDouble#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.339495129 UTC

[section ""data" . f_r3Bv_closure" {
     f_r3Bv_closure:
         const f_r3Bv_info;
 },
 f_r3Bv_slow() //  [R1]
         { []
         }
     {offset
       c921: // global
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           D1 = F64[Sp];
           R1 = R1;
           Sp = Sp + 24;
           call f_r3Bv_entry(R3, R2, D1, R1) args: 8, res: 0, upd: 8;
     }
 },
 f_r3Bv_entry() //  [R2, R3, D1]
         { []
         }
     {offset
       c92c: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c92d; else goto u92s;
       c92d: // global
           R1 = f_r3Bv_closure;
           F64[Sp - 24] = D1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       u92s: // global
           F64[Sp - 24] = D1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _c922() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . f_r3Bv_info" {
     f_r3Bv_info:
         const f_r3Bv_entry;
         const 0;
         const 14;
         const 12884901888;
         const 0;
         const 323;
         const f_r3Bv_slow;
 },
 _c922() //  []
         { []
         }
     {offset
       c922: // global
           I64[Sp - 8] = block_c925_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u92u; else goto c926;
       u92u: // global
           call _c925(R1) args: 0, res: 0, upd: 0;
       c926: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c925() //  [R1]
         { []
         }
     {offset
       c925: // global
           _s7tI::F64 = F64[Sp + 8];
           if (R1 & 7 == 1) goto c929; else goto c92a;
       c929: // global
           _s7tK::I64 = I64[Sp + 24];
           _s7tN::P64 = P64[R1 + 7];
           (_s7tR::F64) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeDouble(I64[R1 + 15], _s7tK::I64);
           F64[Sp + 8] = %MO_F_Add_W64(_s7tI::F64, _s7tR::F64);
           P64[Sp + 16] = _s7tN::P64;
           I64[Sp + 24] = _s7tK::I64 + 64;
           Sp = Sp + 8;
           call _c922() args: 0, res: 0, upd: 0;
       c92a: // global
           D1 = _s7tI::F64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c925_info" {
     block_c925_info:
         const _c925;
         const 451;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.349891315 UTC

[section ""data" . GHC.Integer.Type.encodeDoubleInteger_closure" {
     GHC.Integer.Type.encodeDoubleInteger_closure:
         const GHC.Integer.Type.encodeDoubleInteger_info;
 },
 GHC.Integer.Type.encodeDoubleInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c933: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c934; else goto c935;
       c934: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.encodeDoubleInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c935: // global
           I64[Sp - 16] = block_c92V_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u93p; else goto c92W;
       u93p: // global
           call _c92V(R1) args: 0, res: 0, upd: 0;
       c92W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.encodeDoubleInteger_info" {
     GHC.Integer.Type.encodeDoubleInteger_info:
         const GHC.Integer.Type.encodeDoubleInteger_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c92V() //  [R1]
         { []
         }
     {offset
       c92V: // global
           _c932::P64 = R1 & 7;
           if (_c932::P64 < 3) goto u93o; else goto c931;
       u93o: // global
           _s7tV::I64 = I64[Sp + 8];
           if (_c932::P64 < 2) goto c92Z; else goto c930;
       c92Z: // global
           R3 = _s7tV::I64;
           R2 = P64[R1 + 7];
           D1 = 0.0 :: W64;
           Sp = Sp + 16;
           call f_r3Bv_entry(R3, R2, D1) args: 8, res: 0, upd: 8;
       c930: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c93j; else goto c93i;
       c93j: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c93i: // global
           _s7tY::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s7tY::P64;
           I64[Sp + 8] = block_c93c_info;
           R3 = _s7tV::I64;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       c931: // global
           D1 = 0.0 :: W64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c92V_info" {
     block_c92V_info:
         const _c92V;
         const 65;
         const 30;
 },
 _c93c() //  [D1]
         { []
         }
     {offset
       c93c: // global
           D1 = %MO_F_Neg_W64(D1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(D1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c93c_info" {
     block_c93c_info:
         const _c93c;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.359415953 UTC

[section ""data" . GHC.Integer.Type.encodeFloat#_closure" {
     GHC.Integer.Type.encodeFloat#_closure:
         const GHC.Integer.Type.encodeFloat#_info;
 },
 GHC.Integer.Type.encodeFloat#_entry() //  [R2, R3]
         { []
         }
     {offset
       c93R: // global
           _c93Q::I64 = R3;
           (_s7u6::F32) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeFloat(R2, _c93Q::I64);
           F1 = _s7u6::F32;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.encodeFloat#_info" {
     GHC.Integer.Type.encodeFloat#_info:
         const GHC.Integer.Type.encodeFloat#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.365234107 UTC

[section ""data" . f1_r3Bw_closure" {
     f1_r3Bw_closure:
         const f1_r3Bw_info;
 },
 f1_r3Bw_slow() //  [R1]
         { []
         }
     {offset
       c941: // global
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           F1 = F32[Sp];
           R1 = R1;
           Sp = Sp + 24;
           call f1_r3Bw_entry(R3, R2, F1, R1) args: 8, res: 0, upd: 8;
     }
 },
 f1_r3Bw_entry() //  [R2, R3, F1]
         { []
         }
     {offset
       c94c: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c94d; else goto u94s;
       c94d: // global
           R1 = f1_r3Bw_closure;
           F32[Sp - 24] = F1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       u94s: // global
           F32[Sp - 24] = F1;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _c942() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . f1_r3Bw_info" {
     f1_r3Bw_info:
         const f1_r3Bw_entry;
         const 0;
         const 14;
         const 12884901888;
         const 0;
         const 323;
         const f1_r3Bw_slow;
 },
 _c942() //  []
         { []
         }
     {offset
       c942: // global
           I64[Sp - 8] = block_c945_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u94u; else goto c946;
       u94u: // global
           call _c945(R1) args: 0, res: 0, upd: 0;
       c946: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c945() //  [R1]
         { []
         }
     {offset
       c945: // global
           _s7u7::F32 = F32[Sp + 8];
           if (R1 & 7 == 1) goto c949; else goto c94a;
       c949: // global
           _s7u9::I64 = I64[Sp + 24];
           _s7uc::P64 = P64[R1 + 7];
           (_s7ug::F32) = call "ccall" arg hints:  [,
                                                    signed]  result hints:  [] __word_encodeFloat(I64[R1 + 15], _s7u9::I64);
           F32[Sp + 8] = %MO_F_Add_W32(_s7u7::F32, _s7ug::F32);
           P64[Sp + 16] = _s7uc::P64;
           I64[Sp + 24] = _s7u9::I64 + 64;
           Sp = Sp + 8;
           call _c942() args: 0, res: 0, upd: 0;
       c94a: // global
           F1 = _s7u7::F32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c945_info" {
     block_c945_info:
         const _c945;
         const 451;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.375322292 UTC

[section ""data" . GHC.Integer.Type.encodeFloatInteger_closure" {
     GHC.Integer.Type.encodeFloatInteger_closure:
         const GHC.Integer.Type.encodeFloatInteger_info;
 },
 GHC.Integer.Type.encodeFloatInteger_entry() //  [R2, R3]
         { []
         }
     {offset
       c953: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c954; else goto c955;
       c954: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.encodeFloatInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c955: // global
           I64[Sp - 16] = block_c94V_info;
           R1 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u95p; else goto c94W;
       u95p: // global
           call _c94V(R1) args: 0, res: 0, upd: 0;
       c94W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.encodeFloatInteger_info" {
     GHC.Integer.Type.encodeFloatInteger_info:
         const GHC.Integer.Type.encodeFloatInteger_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _c94V() //  [R1]
         { []
         }
     {offset
       c94V: // global
           _c952::P64 = R1 & 7;
           if (_c952::P64 < 3) goto u95o; else goto c951;
       u95o: // global
           _s7uk::I64 = I64[Sp + 8];
           if (_c952::P64 < 2) goto c94Z; else goto c950;
       c94Z: // global
           R3 = _s7uk::I64;
           R2 = P64[R1 + 7];
           F1 = 0.0 :: W32;
           Sp = Sp + 16;
           call f1_r3Bw_entry(R3, R2, F1) args: 8, res: 0, upd: 8;
       c950: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95j; else goto c95i;
       c95j: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95i: // global
           _s7un::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = _s7un::P64;
           I64[Sp + 8] = block_c95c_info;
           R3 = _s7uk::I64;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
       c951: // global
           F1 = 0.0 :: W32;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c94V_info" {
     block_c94V_info:
         const _c94V;
         const 65;
         const 30;
 },
 _c95c() //  [F1]
         { []
         }
     {offset
       c95c: // global
           F1 = %MO_F_Neg_W32(F1);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(F1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c95c_info" {
     block_c95c_info:
         const _c95c;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.385125652 UTC

[section ""data" . GHC.Integer.Type.Positive_closure" {
     GHC.Integer.Type.Positive_closure:
         const GHC.Integer.Type.Positive_info;
 },
 GHC.Integer.Type.Positive_entry() //  [R2]
         { []
         }
     {offset
       c95P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95T; else goto c95S;
       c95T: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Type.Positive_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95S: // global
           I64[Hp - 8] = GHC.Integer.Type.Positive_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Positive_info" {
     GHC.Integer.Type.Positive_info:
         const GHC.Integer.Type.Positive_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.389751415 UTC

[section ""data" . GHC.Integer.Type.Negative_closure" {
     GHC.Integer.Type.Negative_closure:
         const GHC.Integer.Type.Negative_info;
 },
 GHC.Integer.Type.Negative_entry() //  [R2]
         { []
         }
     {offset
       c965: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c969; else goto c968;
       c969: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Integer.Type.Negative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c968: // global
           I64[Hp - 8] = GHC.Integer.Type.Negative_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Negative_info" {
     GHC.Integer.Type.Negative_info:
         const GHC.Integer.Type.Negative_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.394968939 UTC

[section ""data" . GHC.Integer.Type.Naught_closure" {
     GHC.Integer.Type.Naught_closure:
         const GHC.Integer.Type.Naught_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.397420308 UTC

[section ""data" . GHC.Integer.Type.Nil_closure" {
     GHC.Integer.Type.Nil_closure:
         const GHC.Integer.Type.Nil_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.400235906 UTC

[section ""data" . GHC.Integer.Type.Cons_closure" {
     GHC.Integer.Type.Cons_closure:
         const GHC.Integer.Type.Cons_info;
 },
 GHC.Integer.Type.Cons_entry() //  [R2, R3]
         { []
         }
     {offset
       c96n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c96r; else goto c96q;
       c96r: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.Cons_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c96q: // global
           I64[Hp - 16] = GHC.Integer.Type.Cons_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Cons_info" {
     GHC.Integer.Type.Cons_info:
         const GHC.Integer.Type.Cons_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.404803231 UTC

[section ""data" . GHC.Integer.Type.Some_closure" {
     GHC.Integer.Type.Some_closure:
         const GHC.Integer.Type.Some_info;
 },
 GHC.Integer.Type.Some_entry() //  [R2, R3]
         { []
         }
     {offset
       c96D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c96H; else goto c96G;
       c96H: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Integer.Type.Some_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c96G: // global
           I64[Hp - 16] = GHC.Integer.Type.Some_con_info;
           P64[Hp - 8] = R3;
           I64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Some_info" {
     GHC.Integer.Type.Some_info:
         const GHC.Integer.Type.Some_entry;
         const 0;
         const 14;
         const 8589934605;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.409200222 UTC

[section ""data" . GHC.Integer.Type.None_closure" {
     GHC.Integer.Type.None_closure:
         const GHC.Integer.Type.None_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.41153547 UTC

[section ""cstring" . i96Q_str" {
     i96Q_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,80,111,115,105,116,105,118,101]
 },
 GHC.Integer.Type.Positive_con_entry() //  [R1]
         { []
         }
     {offset
       c96P: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Positive_con_info" {
     GHC.Integer.Type.Positive_con_info:
         const GHC.Integer.Type.Positive_con_entry;
         const 1;
         const 2;
         const i96Q_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.415525802 UTC

[section ""cstring" . i96X_str" {
     i96X_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,101,103,97,116,105,118,101]
 },
 GHC.Integer.Type.Negative_con_entry() //  [R1]
         { []
         }
     {offset
       c96W: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Negative_con_info" {
     GHC.Integer.Type.Negative_con_info:
         const GHC.Integer.Type.Negative_con_entry;
         const 1;
         const 4294967298;
         const i96X_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.419816123 UTC

[section ""cstring" . i974_str" {
     i974_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,97,117,103,104,116]
 },
 GHC.Integer.Type.Naught_con_entry() //  [R1]
         { []
         }
     {offset
       c973: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Naught_con_info" {
     GHC.Integer.Type.Naught_con_info:
         const GHC.Integer.Type.Naught_con_entry;
         const 4294967296;
         const 8589934595;
         const i974_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.42364115 UTC

[section ""cstring" . i97b_str" {
     i97b_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,105,108]
 },
 GHC.Integer.Type.Nil_con_entry() //  [R1]
         { []
         }
     {offset
       c97a: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Nil_con_info" {
     GHC.Integer.Type.Nil_con_info:
         const GHC.Integer.Type.Nil_con_entry;
         const 4294967296;
         const 3;
         const i97b_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.42789058 UTC

[section ""cstring" . i97i_str" {
     i97i_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,67,111,110,115]
 },
 GHC.Integer.Type.Cons_con_entry() //  [R1]
         { []
         }
     {offset
       c97h: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Cons_con_info" {
     GHC.Integer.Type.Cons_con_info:
         const GHC.Integer.Type.Cons_con_entry;
         const 2;
         const 4294967300;
         const i97i_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.431604634 UTC

[section ""cstring" . i97p_str" {
     i97p_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,83,111,109,101]
 },
 GHC.Integer.Type.Some_con_entry() //  [R1]
         { []
         }
     {offset
       c97o: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.Some_con_info" {
     GHC.Integer.Type.Some_con_info:
         const GHC.Integer.Type.Some_con_entry;
         const 4294967297;
         const 5;
         const i97p_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.435350725 UTC

[section ""cstring" . i97w_str" {
     i97w_str:
         I8[] [105,110,116,101,103,101,114,45,115,105,109,112,108,101,58,71,72,67,46,73,110,116,101,103,101,114,46,84,121,112,101,46,78,111,110,101]
 },
 GHC.Integer.Type.None_con_entry() //  [R1]
         { []
         }
     {offset
       c97v: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Integer.Type.None_con_info" {
     GHC.Integer.Type.None_con_info:
         const GHC.Integer.Type.None_con_entry;
         const 4294967296;
         const 4294967299;
         const i97w_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:53:56.4394403 UTC

[section ""relreadonly" . S7IQ_srt" {
     S7IQ_srt:
         const GHC.Integer.Type.plusPositive_addWithCarry_closure;
         const lvl_r3Bo_closure;
         const GHC.Integer.Type.timesDigit_closure;
         const GHC.Integer.Type.timesPositive_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const GHC.Integer.Type.complementInteger_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Integer.Type.modInteger_closure;
 }]

